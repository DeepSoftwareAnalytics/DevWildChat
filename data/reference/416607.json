[
    {
        "link": "https://learn.microsoft.com/en-us/iis/extensions/url-rewrite-module/url-rewrite-module-configuration-reference",
        "document": "This article provides an overview of the URL Rewrite Module and explains the configuration concepts that are used by the module.\n\nThe URL Rewrite Module rewrites request URLs to simple, user-friendly, and search-engine friendly addresses that are displayed to users or in Web applications. URL Rewrite uses defined rules to evaluate and then map the request URL to the address defined in the rule before it is processed by an IIS Web server. You can define URL rewriting logic that includes regular expressions and wildcards, and rules can be applied based on the request URL, HTTP headers, and server variables. While the primary purpose of the module is to rewrite request URLs to more friendly URLs, you can also use the module to define rules that perform redirects, send custom responses, or abort requests.\n\nA rewrite rule defines the logic of what to compare or match the request URL with, and what to do if the comparison is successful.\n\nRewrite rules consists of the following parts:\n• Pattern – The rule pattern is used to specify either the regular expression or a wildcard pattern that is used to match URL strings.\n• Conditions – The optional conditions collection is used to specify additional logical operations to perform if a URL string matches the rule pattern. Within the conditions, you can check for certain values of HTTP headers or server variables, or verify if the requested URL corresponds to a file or directory on a physical file system.\n• Action – The action is used to specify what to do if the URL string matches the rule pattern and all the rule conditions are met.\n\nRewrite rules can be defined in two different collections:\n• – Rules in this collection can be defined only on the server level. Global rules are used to define server-wide URL rewriting logic. These rules are defined within the ApplicationHost.config file, and they cannot be overridden or disabled on any lower configuration levels. Global rules always operate on the absolute URL's path (that is, the requested URI without the server name). These rules are evaluated early in the IIS request-processing pipeline (PreBeginRequest event).\n• – Rules in this collection are called distributed rules, and they can be defined on any level in the configuration hierarchy. Distributed rules are used to define URL rewriting logic specific to a particular configuration scope. This type of rule can be added on any configuration level by using Web.config files or by using tags within ApplicationHost.config or Web.config files. Distributed rules operate on the URL path, relative to the location of the Web.config file where they are defined. In cases where distributed rules are defined inside of a tag, they operate on the URL path, relative to the path specified for that tag. These rules are evaluated on the BeginRequest event in the IIS pipeline.\n\nEach configuration level in IIS can have zero or more rewrite rules defined. The rules are evaluated in the same order in which they are specified. The URL Rewrite Module processes the set of rules by using the following algorithm:\n• First, the URL is matched against the pattern of a rule. If it does not match, the URL Rewrite Module immediately stops processing that rule, and goes on to the next rule.\n• If a pattern matches and there are no conditions for the rule, the URL Rewrite Module performs the action specified for this rule and then goes on to the next rule, where it uses the substituted URL as an input for that rule.\n• If a pattern matches and there are conditions for the rule, the URL Rewrite Module evaluates the conditions. If the evaluation is successful, the specified rule action is performed, and then the rewritten URL is used as input to the subsequent rule\n\nA rule may have the StopProcessing flag turned on. When the rule action is performed (i.e. the rule matched) and this flag is turned on, it means that no more subsequent rules will be processed and the request will be passed to the IIS request pipeline. By default, this flag is turned off.\n\nIf rules are defined on multiple configuration levels, the URL Rewrite Module evaluates the rules in the following order:\n• Evaluate a rule set that includes distributed rules from parent configuration levels as well as rules from the current configuration level. The evaluation is performed in a parent-to-child order, which means that parent rules are evaluated first and the rules defined on a last child level are evaluated last.\n\nThe URL Rewrite Module preserves the original requested URL path in the following server variables:\n• HTTP_X_ORIGINAL_URL – this server variable contains the original URL in decoded format;\n• UNENCODED_URL – this server variable contains the original URL exactly as it was requested by a Web client, with all original encoding preserved.\n\nIt is important to understand how certain parts of the URL string can be accessed from a rewrite rule.\n\nFor an HTTP URL in this form: http(s)://<host>:<port>/<path>?<querystring>\n• The <path> is matched against the pattern of the rule.\n• The <querystring> is available in the server variable called QUERY_STRING and can be accessed by using a condition within a rule.\n• The <host> is available in the server variable HTTP_HOST and can be accessed by using a condition within a rule.\n• The <port> is available in the server variable SERVER_PORT and can be accessed by using a condition within a rule.\n• Server variables SERVER_PORT_SECURE and HTTPS can be used to determine if a secure connection was used. These server variables can be accessed by using a condition within a rule.\n• The server variable REQUEST_URI can be used to access the entire requested URL path, including the query string.\n\nFor example, if a request was made for this URL: , and a rewrite rule was defined on the site level then:\n• The rule pattern gets the URL string as an input.\n• The SERVER_PORT_SECURE server variable contains and HTTPS contains .\n\nNote that the input URL string passed to a distributed rule is always relative to the location of the Web.config file where the rule is defined. For example, if a request is made for , and a rewrite rule is defined in the /content directory, then the rule gets this URL string default.aspx as an input.\n\nA rewrite rule pattern is used to specify a pattern to which the current URL path is compared. Current, in this context, means the value of the URL path when the rule is applied. If there were any rules that preceded the current rule, they may have matched the original requested URL and modified it. The URL string that is evaluated against the pattern does not include the query string. To include the query string in the rule evaluation you can use the QUERY_STRING server variable in the rule's condition. For more information, refer to \"Using server variables in rewrite rules\".\n\nA pattern is specified within a <match> element of a rewrite rule.\n\nRule pattern syntax can be specified by using the patternSyntax attribute of a rule. This attribute can be set to one of the following options:\n\nECMAScript – Perl compatible (ECMAScript standard compliant) regular expression syntax. This is a default option for any rule. This is an example of the pattern format: \"^([_0-9a-zA-Z-]+/)?(wp-.*)\"\n\nWildcard – Wildcard syntax used in IIS HTTP redirection module. The following is an example of a pattern in this format: \"/Scripts/*_in.???\", where asterisk (\"*\") means \"match any number of any characters and capture them in a back-reference\" and \"?\" means match exactly one character (no back-reference is created).\n\nThe scope of the patternSyntax attribute is per rule, meaning that it applies to the current rule's pattern and to all patterns used within conditions of that rule.\n\nA pattern can be negated by using the negate attribute of the <match> element. When this attribute is used, the rule action is performed only if the current URL does not match the specified pattern.\n\nBy default, case-insensitive pattern matching is used. To enable case sensitivity, you can use the ignoreCase attribute of the <match> element of the rule.\n\nRule conditions allow defining additional logic for rule evaluation, which can be based on inputs other than just a current URL string. Any rule can have zero or more conditions. Rule conditions are evaluated after the rule pattern match is successful.\n\nConditions are defined within a <conditions> collection of a rewrite rule. This collection has an attribute called logicalGrouping that controls how conditions are evaluated. If a rule has conditions, then the rule action is performed only if rule pattern is matched and:\n• All conditions were evaluated as true, provided that logicalGrouping=\"MatchAll\" was used.\n• At least one of the conditions was evaluated as true, provided that logicalGrouping=\"MatchAny\" was used.\n\nA condition is defined by specifying the following properties:\n\nCondition input specifies which item to use as an input for the condition evaluation. Condition input is an arbitrary string that can include server variables and back-references to prior condition patterns and/or to rule patterns.\n\nThe match type can be one of the following three options:\n• None IsFile – This match type is used to determine whether the input string contains a physical path to a file on a file system. If a condition input string is not specified, the URL Rewrite Module uses the physical path of the requested file as a default value for the condition input. This match type can be used only for distributed rules.\n• None IsDirectory – This match type is used to determine whether the input string contains a physical path to a directory on a file system. If a condition input string is not specified, the URL Rewrite Module uses the physical path of the requested file as a default value for the condition input. This match type can be used only for distributed rules.\n• None Pattern – This match type is used to express a condition where an arbitrary input string is matched against a regular expression pattern. A condition pattern can be specified by using either regular expression syntax or by using wildcard syntax. The type of pattern to use in a condition depends on the value of the patternSyntax flag defined for the rule to which this condition belongs. This condition type has two related attributes that control pattern matching:\n• pattern – Use this attribute to specify the actual pattern.\n• ignoreCase – Use this attribute to control whether pattern matching for the condition should be case sensitive or case insensitive.\n\nIn addition, the result of the condition evaluation can be negated by using the negate attribute. This can be used to specify a condition that checks if the requested URL is NOT a file, as in the following example:\n\nA rewrite rule action is performed when the current URL matches the rule pattern and the condition evaluation succeeded (depending on the rule configuration, either all conditions matched or any one or more of the conditions matched). There are several types of actions available, and the type attribute of the <action> configuration element can be used to specify which action the rule performs. The following sections describe different action types and the configuration options related to specific action types.\n\nA Rewrite action replaces the current URL string with a substitution string. A substitution string must always specify the URL path (for example, contoso/test/default.aspx). Note that substitutions that contain a physical path on a file system (for example, ) are not supported in IIS.\n\nA Rewrite action has the following configuration options:\n• None url – This is the substitution string to use when rewriting the current URL. The substitution URL is a string value that can include the following:\n• Back-references to the condition and rule patterns. (For more information, see the section about how to use back-references.)\n• Server variables. (For more information, see the section about how to use server variables.)\n• None appendQueryString – Specifies whether the query string from the current URL is preserved during substitution. By default, if the value of the appendQueryString flag is not specified, it is assumed to be TRUE. This means that the query string from the original URL is appended to the substituted URL.\n\nA Redirect action instructs the URL Rewrite Module to send a redirect response back to the client. The redirect status code (3xx) can be specified as a parameter for this action. The Location field of the response contains the substitution string specified in the rule.\n\nThe substitution URL for the redirect rule can be specified in one of the following forms:\n\nUsage of a Redirect action implies that no subsequent rules evaluated for the current URL after redirection is performed.\n\nA Redirect action has the following configuration options:\n• None url – Uses a substitution string as a redirection URL. A substitution URL is a string that can include the following:\n• Back-references to the condition and rule patterns. (For more information, see the section about how to use back-references.)\n• Server variables. (For more information, see the section about how to use server variables.)\n• None appendQueryString – Specifies whether the query string from the current URL should be preserved during substitution. By default, if the AppendQueryString flag is not specified, it is assumed to be TRUE. This means that the query string from the original URL is appended to the substituted URL.\n• None redirectType – Specifies the status code to use during redirect:\n\nA CustomResponse action causes the URL Rewrite Module to respond to the HTTP client by using a user-specified status code, subcode, and reason. Use of a CustomResponse action implies that no subsequent rules are evaluated for the current URL after this action is performed.\n\nCustomResponse action has the following configuration options:\n• statusCode– Specifies the status code to use in response to the client.\n• subStatusCode – Specifies the substatus code to use in response to the client.\n• statusReason – Specifies the reason phrase to use with the status code.\n• statusDescription – Specifies the one line description to put in the body of the response.\n\nAn AbortRequest action causes the URL Rewrite Module to drop the HTTP connection for the current request. The action does not have any parameters. Use of this action implies that no subsequent rules are evaluated for the current URL after this action is performed.\n\nA None action is used to specify that no action is performed.\n\nServer variables provide additional information about current HTTP requests. You can use this information to make rewriting decisions or to compose the rewritten URL. Server variables can be referenced in the following locations within rewrite rules:\n\nServer variables can be referenced by using the {VARIABLE_NAME} syntax. For example, the following condition uses the QUERY_STRING server variable:\n\nServer variables can also be used to access HTTP headers from the current request. Any HTTP header supplied by the current request is represented as a server variable that has a name generated in accordance to this naming convention:\n• All dash (\"-\") symbols in the HTTP header name are converted to underscore symbols (\"_\").\n• All letters in the HTTP header name are converted to capital case.\n• \"HTTP_\" prefix is added to the header name.\n\nFor example, in order to access the HTTP header \"user-agent\" from a rewrite rule, you can use the {HTTP_USER_AGENT} server variable.\n\nParts of rules or conditions inputs can be captures in back-references. These can be then used to construct substitution URLs within rules actions or to construct input strings for rule conditions.\n\nBack-references are generated in different ways, depending on which kind of pattern syntax is used for the rule. When an ECMAScript pattern syntax is used, a back-reference can be created by putting parenthesis around the part of the pattern that must capture the back-reference. For example, the pattern ([0-9]+)/([a-z]+).html will capture 07 and article in back-references from this requested URL: 07/article.html. When \"Wildcard\" pattern syntax is used, the back-references are always created when an asterisk symbol (*) is used in the pattern. No back-references are created when \"?\" is used in the pattern. For example the pattern */*.html will capture contoso and test in back-references from this requested URL: contoso/test.html.\n\nUsage of back-references is the same regardless of which pattern syntax was used to capture them. Back-references can be used in the following locations within rewrite rules:\n• None In a key parameter to the rewrite map\n\nBack-references to condition patterns are identified by {C:N} where N is from 0 to 9. Back-references to rule patterns are identified by {R:N} where N is from 0 to 9. Note that for both types of back-references, {R:0} and {C:0}, will contain the matched string.\n\nFor example, in this pattern:\n\nFor the string: the back-references will be indexed as follows:\n\nWithin a rule action, you can use the back-references to the rule pattern and to the last matched condition of that rule. Within a condition input string, you can use the back-references to the rule pattern and to the previously matched condition.\n\nThe following rule example demonstrates how back-references are created and referenced:\n\nThe URL Rewrite Module controls the IIS output cache behavior in order to:\n• Optimally utilize kernel mode and user mode output caching of responses for rewritten URLs, thus improving performance of the Web application that uses URL Rewrite Module.\n• Prevent caching of responses, when caching logic may be violated due to URL rewriting.\n\nThe module controls output caching either by altering certain caching properties or by disabling the caching altogether. The module cannot enable output caching if it has been disabled by IIS configuration or by any other module in the IIS pipeline. The output caching is controlled as follows:\n• None The module always sets the user mode cache setting varyByHeader=\"HTTP_X_ORIGINAL_URL\". This ensures that when user mode caching is enabled the module takes into account the original URL to construct a key for the cache entry.\n• None If a rewrite rule set uses server variables with values that are either constant throughout the life of the process or are derived from the requested URL, the rule set is considered safe for output caching. This means that the URL Rewrite Module will not alter existing caching policy in any way other than setting varyByHeader as described in step 1. The following server variables, when used in rewrite rules, do not cause any effect on output caching policy:\n• None If a rewrite rule set uses any server variable not mentioned in the above list, the rule set is considered unsafe for output caching. This means that the URL Rewrite Module will disable kernel mode caching for all requests whether the request URLs were rewritten or not. In addition, the module will alter the caching policy for user-mode cache by setting the caching property varyByValue to contain the concatenated string of all server variables values used in the rule set.\n\nThere are three string functions available for changing the values within a rewrite rule action, as well as any conditions:\n• UrlEncode - returns the input string converted to URL-encoded format. This function can be used if the substitution URL in rewrite rule contains special characters (for example non-ASCII or URI-unsafe characters).\n• UrlDecode - decodes the URL-encoded input string. This function can be used to decode a condition input before matching it against a pattern.\n\nThe functions can be invoked by using the following syntax:\n\nWhere \"function_name\" can be on eof the following: \"ToLower\", \"UrlEncode\", \"UrlDecode\". \"Any_string\" can be either a literal string or a string built by using server variables or back-references. For example, the following are valid invocations of string functions:\n\nThe string functions can be used in the following locations within rewrite rules:\n\nAn example of a rule that uses the ToLower function:\n\nAn example of a rule that uses the UrlEncode function:\n\nAn example of a rule that uses the UrlDecode function:\n\nA rewrite map is an arbitrary collection of name-value pairs that can be used within rewrite rules to generate the substitution URL during rewriting. Rewrite maps are particularly useful when you have a large set of rewrite rules and all of these rules use static strings (that is, when there is no pattern matching used). In those cases, instead of defining a large set of simple rewrite rules, you can put all the mappings into the rewrite map as keys and values between the input URL and the substitution URL. Then, to look up the substitution URL based on the input URL, you will have one rewrite rule that references the rewrite map.\n\nA rewrite map defines a named collection of name-value pair strings, as in the following example:\n\nA rewrite map is uniquely identified by its name and can contain zero or more key-value entries. In addition, a rewrite map can specify the default value to use when a key is not found. This is controlled by using the defaultValue attribute. By default, an empty string is used as a default value.\n\nThere can be any number of rewrite maps on any configuration level, except the file level. Rewrite maps are located within <rewriteMaps> collection element.\n\nRewrite maps are referenced within a rewrite rule by using the following syntax:\n\nWhere the Key parameter can be any arbitrary string, and can include back-references to rule or condition patterns. For example, the following are valid uses of a rewrite map:\n\nA reference to a rewrite map gets substituted with the value that was looked up by using the key passed as a parameter within a rewrite map reference. If a key was not found, the default value for that rewrite map is used.\n\nA Rewrite map can be referenced in the following locations within rewrite rules:\n\nExample 1: With a rewrite map defined as follows:\n\nAnd a rewrite rule defined as follows:\n\nThe requested URL /diagnostic will be rewritten as /default.aspx?tabid=2&subtabid=29.\n\n The requested URL /webcasts will be rewritten to /default.aspx?tabid=2&subtabid=24.\n\n The requested URL /php will be rewritten to /default.aspx?tabid=7116.\n\n The requested URL /default.aspx will not be rewritten because the rewrite map does not contain an element with key=\"/default.aspx\"; therefore the rewrite map will return an empty string which will not match the condition pattern, hence the rule action will not be performed.\n\nExample 2: With a rewrite map defined as follows:\n\nAnd a rewrite rule defined as follows:\n\nThe requested URL /default.aspx?tabid=2&subtabid=29 will be redirected to .\n\n The requested URL /default.aspx?tabid=2&subtabid=24 will be redirected to .\n\n The requested URL /default.aspx?tabid=7116 will be redirected to .\n\n The requested URL /default.aspx will not be redirected because rewrite map does not contain an element with key=\"/default.aspx\"; therefore the rewrite map will return an empty string which will not match the condition pattern, hence rule action will not be performed."
    },
    {
        "link": "https://learn.microsoft.com/en-us/iis/extensions/url-rewrite-module/creating-rewrite-rules-for-the-url-rewrite-module",
        "document": "The URL rewrite module is an extension to IIS which is available as a download for your stand-alone IIS Server, and is also pre-installed on any website on Windows Azure Web Sites (WAWS) and available for your use. This walkthrough will guide you through how to create and test a set of rewrite rules for the URL Rewrite Module.\n\nThis walkthrough requires the following prerequisites:\n• IIS 7 or above with ASP.NET role service enabled.\n• URL Rewrite Module installed. For more information, see Using the URL Rewrite Module.\n\nTo demonstrate how the URL Rewrite Module works, we will use a simple test ASP.NET page. This page reads the Web server variables and outputs their values in the browser.\n\nCopy the following ASP.NET code and put it in the %SystemDrive%\\inetpub\\wwwroot\\ folder in a file called article.aspx:\n\nAfter copying this file, browse to and check that the page was rendered correctly in a browser.\n\nWe will create a simple rewrite rule that will rewrite URLs using the following format:\n\nWe will create a rewrite rule by using URL Rewrite UI in IIS Manager. To do this, follow these steps:\n• In the Actions pane on the right-hand side, click Add rules…\n• In the Add Rules dialog box, select Blank Rule and click OK.\n\n\n\nNow you must define the actual rewrite rule. In the URL Rewrite Module, a rewrite rule is defined by specifying four required pieces of information:\n• Name of the rule.\n• Pattern to use for matching the URL string.\n• Action to perform if a pattern is matched and whether all conditions checks succeed.\n\nIn the Name text box, enter a name that will uniquely identify the rule, for example: \"Rewrite to article.aspx\".\n\nIn the Pattern text box, enter the following string:\n\nThis string is a regular expression that specifies that the pattern will match any URL string that meets the following conditions:\n• Starts with the sequence of characters \"article/\".\n• Contains one or more numeric characters after the first \"/\".\n• Contains one or more alphanumeric or \"_\" or \"-\" characters after the second \"/\".\n\nNotice that certain parts of the regular expression are within parentheses. These parentheses create capture groups, which can be later referenced in the rule by using back-references.\n\nSince the rule that we are creating is supposed to rewrite the URL, choose the Rewrite action type that is listed in the Action group box. In the Rewrite URL: text box, enter the following string:\n\nThis string specifies the new value to which the input URL should be rewritten. Notice that for the values of the query string parameters we used {R:1} and {R:2}, which are back-references to the capture groups that were defined in the rule pattern by using parentheses.\n\nLeave default values for all other settings. The Edit Inbound Rule property page should look like the following page:\n\nSave the rule by clicking Apply on the right-hand side.\n\nThe rewrite rules are stored either in the ApplicationHost.config file or in Web.config files. To check the configuration of the rule that we have just created, open a Web.config file located in %SystemDrive%\\inetpub\\wwwroot. In this file you should see the section that contains this rule definition:\n\nThe syntax above also applies to configuring URL Rewrite in Web.config in Windows Azure Web Sites (WAWS).\n\nTo test that the rule correctly rewrites URLs, open a Web browser and request the following URL:\n\nYou should see that the rewrite rule on your Web server has changed the original URL to Article.aspx and it has passed \"234\" and \"some-title\" as values for query string parameters.\n\nNow we will create a redirect rule that will redirect all URLs in the following format:\n\n\n\n to the following format:\n\n\n\nA redirect rule enables more than one URL to point to a single Web page.\n\nTo do this, open the URL Rewrite feature view UI in IIS Manager. Click Add Rule(s)…, and then select the Blank Rule template again.\n\nWithin the Edit Rule page, enter the following:\n• Name: Redirect from blog (This is a unique name for the rule.)\n• Pattern: ^blog/([_0-9a-z-]+)/([0-9]+) (This pattern will match the URL string that starts with \"blog\" and captures the second and third segments of the URL into back-references.)\n• Action: Redirect (The redirect action will cause a redirect response to be sent back to the browser.)\n• Redirect URL: article/{R:2}/{R:1} (This substitution string will be used as a redirect URL; notice that it uses back-references to preserve and rearrange the original URL pieces captured during pattern match.)\n\nEnter the name, pattern, and action as shown below:\n\nEnter the redirect URL as shown below:\n\nLeave default values for all other settings. Save the rule by clicking Apply on the right-hand side.\n\nTo test that the rule redirects requests correctly, open a Web browser and request the following URL:\n\nYou should see that the browser was redirected to as a result of redirect rule execution and then the request was rewritten in accordance with the rewrite rule that you have created earlier.\n\nThe third rule that we will create is used to block all requests made to a Web site if those requests do not have the host header set. This type of rule is useful when you want to prevent hacking attempts that are made by issuing HTTP requests against the IP address of the server instead of using the host name.\n\nWe will create this rule without using IIS Manager. Open the Web.config file in the folder that you used for the article.aspx test file early in this article. Locate the section. Insert the following rule into the <rules> collection, so that it is the first rule in the collection:\n\nThe section should look like the following code:\n\nLet's analyze the rule to understand what it does.\n\nThe element above says that the rule will match any URL string.\n\nThe element above adds a condition to the rule that retrieves the host header value by reading the server variable HTTP_HOST, matches it against the pattern \"localhost\" and then negates the result of matching. In other words, the condition verifies that the host header does not match \"localhost\".\n\nThe element above tells the URL Rewrite Module to end the HTTP request.\n\nTo test this rule, open a Web browser and make a request to . What you should see is a browser that does not receive any response from the server. However, if you request , then the Web server will respond successfully.\n\nThe unsuccessful display will be the following:\n\nThe successful display will be the following:\n\nIn this walkthrough, you have learned how to configure URL rewrite rules by using IIS manager or by manually editing Web.config files. The rules that were created in this walkthrough demonstrated some of the important features of the URL Rewrite Module, such as regular expressions support and the ability to use HTTP headers and server variables to make rewriting decisions."
    },
    {
        "link": "https://stackoverflow.com/questions/49387486/iis-url-rewriting-rule-exclude-all-files-and-a-specific-path",
        "document": "I want to create a URL rewrite rule that adds a on URLs that don't have one so for example:\n\nwill get redirected to\n\nThe rule below does exactly that, but the problem I am having is two fold:\n• None This rewrite rule is getting applied to things like image files. So For example gets changed to causing a 404 its not happening with CSS files which is strange, maybe because I am adding them using the method in MVC?\n• None This is a ASP.NET MVC based website using a CMS (episerver) so I want to ignore any redirects in the Admin area so I added a second rule, but again its doing this to the CSS and images breaking the admin area.\n\nThis is what I have got so far, can anyone help me get this rule working correctly?"
    },
    {
        "link": "https://docs.secureauth.com/0902/en/use-url-rewrite-for-ip-restrictions.html",
        "document": "1. In the IIS window, select the SecureAuth IdP realm from the tree view pane\n\n2. On the target pane, double-click the URL Rewrite icon\n\n7. Select Wildcards from the Using dropdown, if enabling wildcards\n\n6. Enter the first internal Pattern (IP Address) to allow, using \" * \" (dot asterisk) to enable a wildcard\n\n5. Select Matches the Pattern from the Block request that dropdown\n\n4. In the Add Request Blocking Rule dialog, select IP Address from the Block access based on dropdown\n\n3. On the URL Rewrite pane, on the Actions section in the upper right corner, click Add Rule(s) to create the first rule (i.e. to allow internal access to remain on this realm)\n\n9. Double-click the newly created rule to edit the settings for that rule\n\n10. On the Edit Inbound Rule pane, click Add to add another IP address to the internally allowed list\n\n11. In the Add Condition dialog, specify {REMOTE_ADDR} as the Condition input\n\n12. Select Matches the Pattern from the Check if input string dropdown\n\n13. Enter the Pattern and test it to verify it works\n\n15. After adding all the internally allowed IP Addresses to the Conditions list, select Match Any from the Logical grouping dropdown\n\n16. In the Action section, select None from the Action type dropdown\n\n18. On the Actions section in the upper right corner, clickApply\n\n20. On the rules pane, click Add Rule(s) to add the next rule (to redirect external traffic)"
    },
    {
        "link": "https://stackoverflow.com/questions/43047795/iis-rewrite-rule-to-deny-access-files-and-folder-starting-with",
        "document": "I need an IIS rewrite rule to deny access to all files and folder starting with \".\"\n\nFiles like .git .composer .htaccess (I know is for Apache )\n\nAny folder like /.test/ A plus if rule can cover any folder starting with “.” but not this one “./well-known/acme-challenge”"
    },
    {
        "link": "https://learn.microsoft.com/en-us/iis/get-started/planning-for-security/secure-content-in-iis-through-file-system-acls",
        "document": "The access control list (ACL) is a list of permissions associated with an object. Each of these permission entries is called an access control entry (ACE); an ACE contains permissions associated with a particular object for a particular identity. For example, for file system objects, you can set ACLs on files/directories on an NTFS file system.\n\nYou can use graphical user interface (GUI) tools (such as My Computer or Windows® Explorer) to set or edit ACLs. Simply right-click any file or folder resource from one of these tools, select Properties, and then click the Security tab to see a graphical representation of the ACL on the resource you chose. From this dialog box, you can apply or remove group or user permissions to system resources such as files and folders. You can also use a command-line utility Cacl.exe to display or modify file ACLs.\n\nIt is useful to start with some ACL basics.\n\nThe most common permissions of interest in ACE are read, write, execute, and list folder contents.\n• Read / Write Permissions. The read and write permissions give read and write access to the file system object, respectively.\n• List Folder Contents Permission. The list folder content permission is used for displaying the contents of a folder and is required to register file change notifications on a directory.\n• Execute Permission. The execute permission is used to specify if the operating system should execute a particular application as the specified user. This does not cover dynamic application scenarios such as PHP (or Microsoft® ASP.NET). You are running code when you invoke a .php or .aspx file, but not from the perspective of the operating system. Instead of setting the execute permission, you should look into using the script/execute permissions.\n• Full Control. The full control permission gives all access to the file system object. Avoid full control, and use more granular read/write permissions.\n• IIS Script / Execute Permissions. Files with dynamic content, such as .php (or .aspx) files, need script permission to function. But note that while the file system ACLs have an execute flag, they have nothing for script. This is because Internet Information Services 7 and above (IIS 7 and above) have a special configuration to denote if a particular file has dynamic content; this configuration is stored in IIS configuration, outside file system ACLs. When script or execute permissions are discussed, it is actually the IIS configuration not the file system execute permission.\n• Object Inheritance. File system ACLs are usually inherited. In some cases, the parent directory might have very loose ACLs that need to be overridden at the child level to adequately lock content. This is unlikely to be an issue in a hosted scenario since there are few permissions at the root.\n\nYou can either allow or deny permissions to particular identities through ACLs to secure your content. There are two types of identities: process identities (those that the IIS worker process is launched with) and the request handler identities (those from authentication of the request).\n• Worker Process Identity (WPI). The IIS worker process runs as the WPI, which is configurable through the Application Pool configuration settings in IIS. IIS 6.0 on Windows Server® 2003 and IIS 7 and above on Windows Server® 2008 have the \"Network Service\" identity as the default WPI. Windows Server® 2008 R2 however uses the application pool identity as the default WPI. If your application authenticates and impersonates, your request hander identity is the authenticated user identity.\n\n If your Php.ini has fcgi.impersonate set to \"true\" (recommended for IIS), then your PHP processes are running as the authenticated user. It is important to note that in the case of anonymous authentication, the authenticated user would be the configured anonymous user.\n• IIS_IUSRS. This is a built-in identity group that is a container of all worker process identities (WPIs) on the server. IIS automatically includes all WPIs in this group (no need to add them manually).\n\n On IIS 6.0 on Windows Server 2003, this group is called IIS_WPG. This is an overarching group that contains all WPIs, and is therefore not a good candidate for isolating content. Any application running in any application pool would be running as an identity that falls into this group, so giving this group read access means that all applications are able to read your content.\n• IUSR / Anonymous User Identity. The built-in IUSR account is the default used to denote the user identity of anyone using anonymous authentication. The anonymous user identity is configurable and can be set to an identity besides this built-in default.\n\n In practice, you should configure a custom account for the anonymous user account and never use the built-in account. It is important to understand that in IIS, the anonymous user is not the lack of an authenticated user. Rather, anonymous requests should be considered as requests where the authenticated user is the anonymous user identity.\n• Application Pool Identity. This is a virtual identity associated with a particular application pool. Whenever a user creates an application pool, a virtual identity (security identifier or SID) is created with it; this identity is injected into the IIS worker process so that the worker process running under this application pool has access to content with permissions locked to this virtual identity. In Windows Server 2008 Service Pack 2 (SP2), the administrator can create their worker processes with this virtual identity. This is configurable in the IIS application pool configuration settings as the \"Application Pool Identity\" type and is the default WPI identity type for Windows Server 2008 R2. (Identity is unique to the application pool that created it and can therefore be used to isolate content on the server to application pools more effectively.)\n• Authenticated User Identity. If your application uses any form of authentication (including anonymous authentication), then this is the identity of the authenticated user. In the anonymous authentication case, this identity would be your configured anonymous user identity.\n\nTo understand which identities are applicable at which stages, it is helpful to understand the basics of the IIS execution pipeline. The two parts of the pipeline that are most applicable are authentication and handler mapping.\n• None Authentication. Before authentication, the authenticated user context is unknown and all IIS worker processes are running as the WPI. If you have a PHP request that is trying to access content before the request is authenticated, then the WPI needs access to the content. This scenario comes into play when using the Global rules for URL Rewriter that run in the global pre-begin request phase of the IIS pipeline, which occurs before authentication. The URL Rewriter has the ability to process rules differently based on whether the resource being accessed is a file or a directory. For this to be evaluated, a filesystem access needs to occur, and due to its position in the execution pipeline, this access request occurs as the WPI. Post authentication, the authenticated user context is set, but you are not necessarily impersonating until your request gets mapped to a handler. For phases between authentication and handler mapping, you are most likely to be running as WPI.\n• None Handler Mapping. In this phase of the execution pipeline, your request gets mapped to a handler; for example, requests to *.php get mapped to the FastCGI handler. After this mapping occurs and you have impersonation enabled, the handler identity is the Authenticated User, and all resource access in this phase occurs using the authenticated user identity.\n\nFiguring out the right accounts to grant permissions depends on the profile and critical resources of your application. The main considerations are which permissions to grant and whether or not you are authenticated.\n• Granting the Proper Permissions. Dynamic content such as that in PHP and ASP.NET applications needs IIS script permission and read access. If you need to run executables, they need to have the IIS execute permission and they need to be properly configured in the CGI Restriction List. Anything that is not user-uploaded needs only read access on the file system.\n\n Content that is going to be uploaded by a user should reside in a separate folder to which you assign write access. It is important not to give this folder IIS execute or script permissions so users can't upload and execute malicious code.\n\n In general, the WPI should have read access to all content for your application to work correctly.\n• Applications That Require Authentication. For applications that require authentication, lock down all resources to a group containing all authenticated users. If you have different categories of users (admin and non-admin), create separate groups, and give access accordingly. For example, if your application has an admin directory that contains administration scripts, give permissions to read this directory only to the admin group. If your application is impersonating, then the handler identity is the authenticated user; otherwise, it is your WPI. If you have set fcgi.impersonate to \"true\" in your Php.ini file, then your fcgi processes identity is the authenticated user identity; otherwise, it is the WPI. With this information, an administrator can determine the right set of ACLs to place on the content.\n• Applications That Run Anonymously. It is important to note that running anonymously on IIS means that you are authenticated as the anonymous user identity. In this case, lock down resources to either the application pool identity or your custom configured anonymous identity, and give access to the application pool identity over the anonymous identity. If you give IIS_IUSRS group access to your content, the applications running in any application pool have access to your content. If you allow anonymous users to upload files, your application should ensure further checks on the types of content these users can upload in order to keep the server secure.\n\nThere are several ways to set your ACLs through the shell, including command-line tools such as Icacls.exe. This article focuses on the Web Deployment Tool manifest (XML) mechanism that can be used to set ACLs. This is used when installing an application through the Web Deployment Tool.\n\nTo give Read, Execute, and Write permissions to MyApp file system directory for user Foo, add the following line to the Manifest.xml file:\n\nTo set the ACL on the path MyApp/Upload to allow anonymous users to upload content, add the following line to your Manifest.xml file:\n\nNote that anonymousAuthenticationUser is a special token that will resolve to your configured anonymous authentication identity.\n\nTo grant Read access to the MyApp\\Data folder for the application pool identity, add the following line to the Manifest.xml file:\n\nNote that the setAclUse r is not used here (the default value for this is Application Pool Identity).\n• Understanding the Built-In User and Group Accounts in IIS7 and Above"
    },
    {
        "link": "https://learn.microsoft.com/en-us/iis/configuration/system.webserver/security",
        "document": "The section group resides in the section and contains all elements that configure security settings on an Internet Information Services (IIS) 7 server. These include Secure Sockets Layer (SSL) settings for a site, applications that are dependent on Common Gateway Interface (CGI) or Internet Server API (ISAPI) binaries, configuration settings for all authentication modules installed on your server, and authorization rule settings. It also includes IP security and request filtering configuration settings and a list of ISAPI and CGI restrictions on the server.\n\nThe settings in the section group can be combined for extra security. For example:\n• The element defines configuration sections for all user authentication types that you can install and enable on your IIS 7 server, whereas the element configures the user accounts that can access your site or application. You use in combination with to secure access to content on your server. The element configures SSL settings for your Web server, site, or application.\n• The element specifies a list of CGI and ISAPI applications that can run on IIS 7. This element allows you to ensure that malicious users cannot copy unauthorized CGI and ISAPI binaries to your Web server and then run them. The element specifies an application that has dependencies to one or more CGI or ISAPI extension restrictions. You can combine the element with the element in order to ensure your CGI or ISAPI extension restrictions are set properly.\n\nThe element is included in the default installation of IIS 7.\n• \n• None If you are using Windows Server 2012 or Windows Server 2012 R2:\n• On the taskbar, click Server Manager, click Tools, and then click Internet Information Services (IIS) Manager.\n• None If you are using Windows 8 or Windows 8.1:\n• Hold down the Windows key, press the letter X, and then click Control Panel.\n• None If you are using Windows Server 2008 or Windows Server 2008 R2:\n• On the taskbar, click Start, point to Administrative Tools, and then click Internet Information Services (IIS) Manager.\n• None If you are using Windows Vista or Windows 7:\n• On the taskbar, click Start, and then click Control Panel.\n• None In the Connections pane, expand the server name, expand Sites, and go to the level in the hierarchy pane that you want to configure, and then click the Web site or Web application.\n• None Scroll to the Security section in the Home pane, and then double-click Authentication.\n• None In the Authentication pane, select Anonymous Authentication, and then click Disable in the Actions pane.\n\n\n\nHow to change anonymous authentication credentials from the IUSR account\n• \n• None If you are using Windows Server 2012 or Windows Server 2012 R2:\n• On the taskbar, click Server Manager, click Tools, and then click Internet Information Services (IIS) Manager.\n• None If you are using Windows 8 or Windows 8.1:\n• Hold down the Windows key, press the letter X, and then click Control Panel.\n• None If you are using Windows Server 2008 or Windows Server 2008 R2:\n• On the taskbar, click Start, point to Administrative Tools, and then click Internet Information Services (IIS) Manager.\n• None If you are using Windows Vista or Windows 7:\n• On the taskbar, click Start, and then click Control Panel.\n• None In the Connections pane, expand the server name, expand Sites, and navigate to the level in the hierarchy pane that you want to configure, and then click the Web site or Web application.\n• None Scroll to the Security section in the Home pane, and then double-click Authentication.\n• None In the Authentication pane, select Anonymous Authentication, and then click Edit... in the Actions pane.\n• None In the Edit Anonymous Authentication Credentials dialog box, do one of the following:\n• None Select Application pool identity to use the identity set for the application pool, and then click OK.\n• None Click Set..., and then in the Set Credentials dialog box, enter the user name for the account in the User name box, enter the password for the account in the Password and Confirm password boxes, click OK, and then click OK again.\n\n If you use this procedure, only grant the new account minimal privileges on the IIS server computer.\n\nHow to enable basic authentication and disable anonymous authentication\n• \n• None If you are using Windows Server 2012 or Windows Server 2012 R2:\n• On the taskbar, click Server Manager, click Tools, and then click Internet Information Services (IIS) Manager.\n• None If you are using Windows 8 or Windows 8.1:\n• Hold down the Windows key, press the letter X, and then click Control Panel.\n• None If you are using Windows Server 2008 or Windows Server 2008 R2:\n• On the taskbar, click Start, point to Administrative Tools, and then click Internet Information Services (IIS) Manager.\n• None If you are using Windows Vista or Windows 7:\n• On the taskbar, click Start, and then click Control Panel.\n• None In the Connections pane, expand the server name, expand Sites, and then click the site, application or Web service for which you want to enable basic authentication.\n• None Scroll to the Security section in the Home pane, and then double-click Authentication.\n• None In the Authentication pane, select Basic Authentication, and then, in the Actions pane, click Enable.\n• None In the Authentication pane, select Anonymous Authentication, and then click Disable in the Actions pane.\n• \n• None If you are using Windows Server 2012 or Windows Server 2012 R2:\n• On the taskbar, click Server Manager, click Tools, and then click Internet Information Services (IIS) Manager.\n• None If you are using Windows 8 or Windows 8.1:\n• Hold down the Windows key, press the letter X, and then click Control Panel.\n• None If you are using Windows Server 2008 or Windows Server 2008 R2:\n• On the taskbar, click Start, point to Administrative Tools, and then click Internet Information Services (IIS) Manager.\n• None If you are using Windows Vista or Windows 7:\n• On the taskbar, click Start, and then click Control Panel.\n• None In the Connections pane, go to the site, application, or directory for which you want to configure SSL requirements. You cannot configure SSL at the server level.\n\nHow to enable Windows authentication for a Web site, Web application, or Web service\n• \n• None If you are using Windows Server 2012 or Windows Server 2012 R2:\n• On the taskbar, click Server Manager, click Tools, and then click Internet Information Services (IIS) Manager.\n• None If you are using Windows 8 or Windows 8.1:\n• Hold down the Windows key, press the letter X, and then click Control Panel.\n• None If you are using Windows Server 2008 or Windows Server 2008 R2:\n• On the taskbar, click Start, point to Administrative Tools, and then click Internet Information Services (IIS) Manager.\n• None If you are using Windows Vista or Windows 7:\n• On the taskbar, click Start, and then click Control Panel.\n• None In the Connections pane, expand the server name, expand Sites, and then the site, application, or Web service for which you want to enable Windows authentication.\n• None Scroll to the Security section in the Home pane, and then double-click Authentication.\n• None In the Authentication pane, select Windows Authentication, and then click Enable in the Actions pane.\n\n\n\nWhen you configure security settings, the configuration XML must include the section group. You can configure security settings at the server level in the ApplicationHost.config file, or at the site level, application level, or directory level in the appropriate Web.config file.\n\nThe following example configures the authentication, SSL, and request filtering settings for a Web site named Contoso.\n\nThe following examples disable Anonymous authentication for a site named Contoso, then enable both Basic authentication and Windows authentication for the site."
    },
    {
        "link": "https://stackoverflow.com/questions/19590490/restrict-browsing-an-xml-file-using-web-config",
        "document": "I have an application where I have an XML file which holds the connection string. When hit the URL with the exact file name it opens the file in the browser that is natural.\n\nNow I need to restrict this file browsing and I can not change that code to do any redirect or anything else.\n\nWhat I have tried is using denyurlsequences in the security tag in the web.config but it restricts the application too to access the file and that makes the application stop working."
    },
    {
        "link": "https://stackoverflow.com/questions/48281184/how-to-secure-config-file-while-hosting-a-web-service-on-a-public-domain",
        "document": "Thanks to how IIS works, your file won't be accessible from outside your application. You won't be able to get to it by just browsing directly to it unless you manually allow that action such as enabling directory browsing etc.\n\nThe file is more an IIS config than anything else, as it merely configured the IIS environment to run the application as you intend it to.\n\nYou have nothing to worry about"
    },
    {
        "link": "https://medium.com/work-insight/secure-your-net-config-files-part-1-251aed4ce4c8",
        "document": "With data breaches becoming more common, ensuring security is an important part of software development. Clients need to make sure their data is safe from security threats and following the standards of encryption. Web.config contains keys that hold data and usually, these keys contain sensitive information like the database configuration, credentials, etc. Failing to secure this information is like giving the hackers a golden chance to steal your sensitive data.\n\nWeb.config is presented in an understandable XML format that contains application-wide data such as database connection strings, custom error message, cultural settings, custom configs, etc.\n\nWeb.config files are protected by IIS, so clients cannot access it. If you try to retrieve an existing http://mydomain.com/Web.config file, you’ll be notified with an “Access denied” error message.\n\nIIS monitors the Web.config files for changes and caches the contents for performance reasons. There’s no need to restart the Web server after you modify a Web.config file.\n\nStep 2: Provide the path where the .Net Framework is installed\n\naspnet_regiis -pef “<section>” “<Path of WebConfig>”\n\n Here let us encrypt the <appSettings> under <configuration>\n\n· aspnet_regiis : The ASP.NET IIS Registration Tool (Aspnet_regiis.exe) allows an administrator or installation program to easily update the script maps for an ASP.NET application to point to the ASP.NET ISAPI version that is associated with the tool.\n\n Also used for encrypting machine / web.config and custom configuration files.\n\nex: aspnet_regiis -pef “appSettings” “ C:\\Project\\Calculator”\n\n Note: The section tags are case sensitive, you have to provide the section tag name exactly as how it is in the web.config.\n\n \n\n On submitting the script, you will be provided with a success message.\n\nNow if you open your web.config, you would be able to see that your data has been encrypted. You will be able to see the Cipher Data. Since the key is private and RSA encrypted, you can only decrypt the file from the machine which you have encrypted. \n\n \n\n You do not have to write code to decrypt the config to read the content. But, if you need to modify the content in the web.config, or view the data in the file, you can decrypt the config file using the ‘pdf’ command.\n\n ex: aspnet_regiis -pdf “<section>” “<Path of WebConfig>”\n\nClosing Remarks\n\n In this article, I have touched one of the many ways of securing your data and hiding them from the outside world. Let us make our projects more secure and thereby enhancing the trust of our clients and users.\n\nHere is a link to Part 2"
    }
]