[
    {
        "link": "https://intellij-support.jetbrains.com/hc/en-us/articles/206544799-Java-slow-performance-or-hangups-when-starting-debugger-and-stepping",
        "document": "will slow down debugger a lot because of the JVM design, they are expensive to evaluate. Remove method breakpoints and consider using the regular line breakpoints. To verify that you don't have any method breakpoints open\n\nfile in the project root directory (or\n\nfile if you are using the old project format) and look for any breakpoints inside the"
    },
    {
        "link": "https://jetbrains.com/help/idea/monitor-debugger-overhead.html",
        "document": "Every time you evaluate an expression or step over the code, IntelliJ IDEA uses the same resources as the debugged application, and this may drastically impact the overall performance in particular cases. For example, breakpoints with heavy conditions may significantly increase the time required for a line of code to complete.\n\nIf the performance of the debugged application is not satisfactory, use the Overhead tab to find out which debugger features eat up most resources.\n\nThe Overhead tab provides you with the information about the number of hits and processor time used by each debugger feature. The view is updated dynamically, so you don't have to suspend your application to see the results.\n\nIf you see that a feature is consuming too much CPU time, you can disable it right in the Overhead tab.\n• None Clear the checkbox next to the feature you want to disable.\n\nBreakpoints that use conditions can cause significant overhead when hit too frequently. When this happens, you can substitute the conditional breakpoint with an statement and a regular breakpoint inside. // hot loop for (int i = 0; i < Integer.MAX_VALUE; i++) { System.out.println(\"some code\"); if (breakpointCondition) { System.out.println(\"Set breakpoint here\"); } } Conditions in code are evaluated much faster, which can significantly improve the performance of the debugged application."
    },
    {
        "link": "https://stackoverflow.com/questions/46292095/intelliji-idea-is-very-slow-in-debug-mode-and-it-is-running-perfectly-in-normal",
        "document": "Intelliji idea is very slow in debug mode and it is running perfectly in normal mode.\n\nI already tried by setting the below thing in /etc/hosts file sudo nano /etc/hosts and add these two entries.\n\nBut it did not work out for me.\n\nAny help on this is highly regarded."
    },
    {
        "link": "https://intellij-support.jetbrains.com/hc/en-us/articles/206544799-Java-slow-performance-or-hangups-when-starting-debugger-and-stepping?page=2",
        "document": "will slow down debugger a lot because of the JVM design, they are expensive to evaluate. Remove method breakpoints and consider using the regular line breakpoints. To verify that you don't have any method breakpoints open\n\nfile in the project root directory (or\n\nfile if you are using the old project format) and look for any breakpoints inside the"
    },
    {
        "link": "https://tharakamd-12.medium.com/debug-like-a-pro-in-intellij-idea-6c3599117297",
        "document": "IntelliJ IDEA is my favorite IDE in Java development. Might be yours too. When developing Java projects (Not only Java) debugging acts a huge role. IntelliJ IDEA debugger provides powerful tools to debug Java applications. The purpose of this article is not to give you an introduction to the Intellij IDEA debugger, but to give you few tricks to use some of the powerful features. So, let’s get started.\n\nStream tracing is an interesting feature in the Intellij IDEA debugger. This feature allows us to debug the behavior of a Java Stream in a graphical way. To demonstrate this, I’m using the following sample code. This has a List of Strings and using stream processing to uppercase the list of words and get the count of words where length is greater than 3.\n\nIf we place a debug point in the line having the stream procession part, and run the program. When the debugger hits that line, In the debug tools, we can see this button, “Trace Current Stream Chain” is activated.\n\nWhen we click on that button, a new window named “Stream Trace” is popping up. This window lists out the stream operations we defined. We can click on each operation and see the transformations doing by that step.\n\nAnd if we click on the “Flat Mode” button, it gives us a nice representation of the stream procession including all the steps and results of each step.\n\nThe following GIF shows the full process,\n\nDon’t forget to try this feature the next time debugging a stream 😎\n\nImagine a situation where you have a loop and you need to check a value of a variable inside the loop in the runtime. What would you do? Console log 🤔 , Nope, since we have the debugger, we can simply place a debug point 😎. But, wait, if that loop iterates thousands of times, the program would stop at the breakpoint thousands of times and you have to observe the value and continue. That is a real pain 😐 Console log then, isn’t is 🙃. Nope, we have this cool feature in the IntelliJ IDEA debugger called non-suspending breakpoints which is really useful in this type of scenario.\n\nTo demonstrate this, I developed the same scenario we used before without using streams.\n\nLet’s say, we need to check the word length in line 20. We can simply place a breakpoint. But if our word list is lengthy, this would be a real headache. To avoid this, we can place a breakpoint, right-click on it and untick the Suspend check box.\n\nAfter you untick the Suspend check box, you would get the following popup,\n\nIf you check the Evaluate and log check box, then you can write any piece of code in the bellow text box (this can be expanded using the expand button on the right corner).\n\nIntellij Idea would log the output of the code that we write here. So, in this case, I wrote a line of code to build a String with the word and the word length. Intellij Idea would log this sentence when the debugger hits this line and the debugger won’t stop on that debug point. So, when I debug, the debugger console gives the following output,\n\nAs you can see, it has printed all the words and word lengths. Not only for logging but also to change the program status (to change a value of a variable, etc. ) on runtime, we can use this approach. What we have to do is, we have to write the code that we need to change the state of the application in that text box. As an example, if I want to add 1 to the word length at line 21, I can do that in runtime by giving the following code to Elavuate and Log text box.\n\nThen, when we debugged the program, it gives the following output,\n\nNote that the last number 4 is from the print statement of the main method. This means all the words have counted since the word length now equals word length + 1. The full process is shown in the following gif,\n\nSo, using this method you can completely change the program behavior in the runtime (in debug time 😁) without compiling and running the code again."
    },
    {
        "link": "https://stackoverflow.com/questions/46292095/intelliji-idea-is-very-slow-in-debug-mode-and-it-is-running-perfectly-in-normal",
        "document": "Intelliji idea is very slow in debug mode and it is running perfectly in normal mode.\n\nI already tried by setting the below thing in /etc/hosts file sudo nano /etc/hosts and add these two entries.\n\nBut it did not work out for me.\n\nAny help on this is highly regarded."
    },
    {
        "link": "https://intellij-support.jetbrains.com/hc/en-us/articles/206544799-Java-slow-performance-or-hangups-when-starting-debugger-and-stepping",
        "document": "will slow down debugger a lot because of the JVM design, they are expensive to evaluate. Remove method breakpoints and consider using the regular line breakpoints. To verify that you don't have any method breakpoints open\n\nfile in the project root directory (or\n\nfile if you are using the old project format) and look for any breakpoints inside the"
    },
    {
        "link": "https://medium.com/@rosolko/%D1%81urbing-slow-intellij-idea-debugging-1e2b9d5d7eff",
        "document": "Some time ago I started working with the Intellij IDEA and until that moment everything was great and flawless. But…\n\nIn one time my debugger just end. If I just run project everything was great, but each time when I start debug and fall down to some method from another class each Step Out took about ~5 second for small,~15 for medium classes and ~30 for large size classes.\n\nAfter I face this issue I’m going to Google and found that I’m not alone."
    },
    {
        "link": "https://youtrack.jetbrains.com/issue/IDEA-187063/During-debugging-IntelliJ-IDEA-gets-extremely-slow",
        "document": "This version of your browser is not supported.\n\n Try upgrading to the latest stable version.\n\nSomething went seriously wrong."
    },
    {
        "link": "https://flounder.dev/posts/troubleshoot-slow-debugging",
        "document": "Although their overhead is generally minimal, Java debuggers can still incur significant runtime costs under certain circumstances. In an unfortunate scenario, the debugger can even completely freeze the VM.\n\nLet’s examine the reasons behind these issues and their possible solutions.\n\nBefore exploring possible solutions, it would be wise to identify the problem. The most common reasons for the debugger slowing down an application include:\n• Evaluating expressions that are computationally too heavy\n\nIntelliJ IDEA eliminates any guesswork in identifying the cause of debugger performance issues by providing detailed statistics in the debugger’s Overhead tab:\n\nTo access it, select Overhead from the Layout Settings tab. The Overhead tab will show the list of breakpoints and debugger features. Next to each breakpoint or feature, you can see how many times each debugger feature was used and the amount of time it took to execute.\n\nNow that we’ve seen how to identify the source of the performance issue, let’s look at the most common causes and how to address them.\n\nWhen using method breakpoints in Java, you might experience performance drops, depending on the debugger you’re using. This is because the corresponding feature provided by the Java Debug Interface is notably slow.\n\nTo address this issue, IntelliJ IDEA offers emulated method breakpoints. These work just like regular method breakpoints, but they function more efficiently. Emulated method breakpoints involve a trick under the hood: instead of setting actual method breakpoints, the IDE replaces them with regular line breakpoints within all the method’s implementations across the project.\n\nBy default, all method breakpoints in IntelliJ IDEA are emulated:\n\nIf you’re using a debugger that doesn’t have this feature and you encounter performance problems with method breakpoints, you can do the same trick manually. Visiting all the method implementations might be tedious, but it may pay off by saving you time while debugging.\n\nIf a method has a huge number of implementations, setting a method breakpoint on it might take some time. In this case, IntelliJ IDEA and Android Studio will show a dialog saying Processing classes for emulated method breakpoints.\n\nIf the process of emulating method breakpoints takes too long for you, consider using a line breakpoint instead. Alternatively, you can trade off some runtime performance by clearing the Emulated checkbox in the breakpoint’s settings.\n\nSetting a conditional breakpoint in hot code might drastically slow down a debugging session, depending on how often this code is executed.\n\nConsider the following code snippet:\n\nLet’s set a breakpoint at and specify as the condition. This effectively means that the debugger should never stop at this breakpoint. However, every time this line runs, the debugger would have to evaluate .\n\nIn this case, the results of running this code with and without the breakpoint were and , respectively. Remarkably, even with as few as 100,000 iterations, the difference is huge!\n\nIt may be surprising that evaluating a seemingly trivial condition like takes up so much time. This is because the elapsed time is not only due to the calculation of the expression’s result. It also involves handling debugger events and communicating with the debugger’s frontend.\n\nThe solution is straightforward. You can integrate the condition directly into the application code:\n\nWith this setup, the VM will directly execute the code of the condition, and it might even optimize this code. Conversely, the debugger will only come into play upon hitting the breakpoint. While not required in most cases, this change can save you time if you need to conditionally suspend the program in the middle of a hot path.\n\nThe described technique works perfectly with classes with available source code. However, with compiled code, such as libraries, the trick might be harder to pull off. This is a special use case, which I will cover in a separate discussion.\n\nIn addition to features – such as breakpoint conditions and watches – where you specify expressions yourself, there are also features that implicitly evaluate expressions for you.\n\nWhenever you suspend a program, the debugger displays the values of the variables that are available in the current context. Some types might have complex structures that are difficult to view and navigate. For your convenience, the debugger transforms them using special expressions called renderers.\n\nRenderers can be trivial, like , or more complex, such as those that transform the content of collections. They can be either built-in or custom.\n\nTypically, the overhead brought by debug renderers is negligible, but the impact ultimately depends on the particular use case. Indeed, if some of your implementations contain code for mining crypto, the debugger will have a hard time showing the value for that class!\n\nIf rendering a certain class proves to be slow, you can turn the corresponding renderer off. As a more flexible alternative, you can set up the renderer for use only when needed. On-demand renderers will only execute when you explicitly request to show their result.\n\nFrom a technical standpoint, debugging a remote application is no different from debugging locally. Either way, the connection is established via a socket – we’re excluding the shared memory mode from this discussion – and the debugger isn’t even aware of where the host JVM runs.\n\nHowever, one factor that might be unique to remote debugging is network latency. Certain debugger features perform several network round trips each time they are used. Combined with high latency, this can lead to a considerable drop in debugging performance.\n\nIf that’s the case, think about running the project locally, as it could save you a lot of time. Otherwise, you might benefit from temporarily turning off some of the advanced features.\n\nIn this article, we’ve learned how to fix the most common issues resulting in poor debugger performance. While the IDE will sometimes take care of that for you, it’s important to understand the underlying mechanisms. This empowers you to be more flexible, efficient, and creative in your day-to-day debugging.\n\nI hope you found these tips and tricks useful. As always, your feedback is greatly appreciated! Feel free to reach out to me on X, LinkedIn, or Telegram."
    }
]