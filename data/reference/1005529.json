[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.readonlyspan-1?view=net-9.0",
        "document": ""
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.readonlyspan-1.op_implicit?view=net-9.0",
        "document": "Collaborate with us on GitHub\n\nThe source for this content can be found on GitHub, where you can also create and review issues and pull requests. For more information, see our contributor guide"
    },
    {
        "link": "https://stackoverflow.com/questions/74301014/how-can-i-cast-a-readonlyspandog-into-a-readonlyspananimal-or-vice-versa",
        "document": "Listing out the variations since Google has no useful results:\n\nAttempting to do any of these yields the same errors, so I figure this is all one question.\n\nI'd be OK with an unsafe cast and the runtime exploding if I pass a Giraffe in a . Searching \"span cast items C#\" on Google brings up reinterpret casts (e.g. to ) which isn't what I want. If this isn't possible, where is the documentation stating so?\n\nI'm using ReadOnlySpan to represent ranges of a read-only managed array (say, an Animal[]). Consumers handle specific Animal implementations (e.g. a GiraffeHandler takes a and treats it as a ).\n\nI recognize an alternative solution would be to allocate an array copy & make a span out of that, or to perform the cast every time I take an element out of the span (perhaps via wrapping the span in a ref struct), but both of these are ugly... I'd prefer to cast the actual to a (or vice versa) if possible, or learn why that's not possible otherwise."
    },
    {
        "link": "https://codemag.com/Article/2207031/Writing-High-Performance-Code-Using-SpanT-and-MemoryT-in-C",
        "document": "By Joydip Kanjilal\n\n Published in: CODE Magazine: 2022 - July/August\n\n Last updated: January 9, 2025\n\nIn this article, you'll be introduced to the new types introduced in C# 7.2: Span and Memory. I'll take a deep dive into and and demonstrate how to work with them in C#.\n\nIf you're to work with the code examples discussed in this article, you need the following installed in your system:\n\nIf you don't already have Visual Studio 2022 installed on your computer, you can download it from here: https://visualstudio.microsoft.com/downloads/.\n\nMicrosoft .NET enables you to work with three types of memory that include:\n• Stack memory: Resides in the Stack and is allocated using the keyword\n• Managed memory: Resides in the heap and is managed by the GC\n• Unmanaged memory: Resides in the unmanaged heap and is allocated by calling the or methods\n\nThe newly introduced types in .NET Core 2.1 are:\n• System.Span: This represents a continuous section of arbitrary memory in a type-safe and memory-safe manner.\n• System.ReadOnlySpan: This represents a type-safe and memory-safe read-only representation of an arbitrary contiguous area of memory.\n• System.ReadOnlyMemory: Similar to , this type represents a continuous section of memory. However, unlike , it's not a ByRef type.\n\nYou might often need to work with massive volumes of data in your applications. String handling is critical in any application because you must follow the recommended practices to avoid unnecessary allocations. You can use unsafe code blocks and pointers to directly manipulate memory, but this approach has considerable risks involved. Pointer manipulations are prone to bugs such as overflows, null-pointer accesses, buffer overruns, and dangling pointers. If the bug affects only the stack or static memory areas, it will be harmless; but if it affects critical system memory areas, it may cause your application to crash. Enter and .\n\nand have been newly introduced in .NET. They provide a type-safe way to access contiguous regions of arbitrary memory. Both and are a part of the System namespace and represent a contiguous block of memory, sans any copy semantics. , , , and types have been newly added to C# and can help you to work with memory directly in a safe and performant matter.\n\nThese new types are part of the namespace and are intended to be used in high performance scenarios where you need to process large amounts of data or want to avoid unnecessary memory allocations, such as when working with buffers. Unlike array types that allocate memory on the GC heap, these new types provide an abstraction over contiguous regions of arbitrary managed or native memory without allocating on the GC heap.\n\nThe and structs provide low-level interfaces to an array, string, or any contiguous managed or unmanaged memory block. Their primary function is to foster micro-optimization and write low-allocation code that reduces managed memory allocations, thus decreasing the strain on the garbage collector. They also allow for slicing or dealing with a section of an array, string, or memory block without duplicating the original chunk of memory. and are very beneficial in high-performance areas, such as the ASP.NET 6 request-processing pipelines.\n\n(earlier known as Slice) is a value type introduced in C# 7.2 and .NET Core 2.1 with almost zero overhead. It provides a type-safe way to work with a contiguous block of memory such as:\n\nA Span type represents a contiguous chunk of memory that resides in the managed heap, the stack, or even in unmanaged memory. If you create an array of a primitive type, it's allocated on the stack and doesn't require garbage collection to manage its lifetime. is capable of pointing to a chunk of memory allocated whether on the stack or on the heap. However, because is defined as a ref struct, it should reside only on the stack.\n\nThe following are the characteristics of at a glance:\n\nYou can use Span with any of the following\n\nThe list of types that can be converted to are:\n\nYou can convert all of the following to :\n\nis a stack-only type; precisely, it's a ByRef type. Thus, spans can neither be boxed nor appear as fields of stack-only type, nor can they be used in generic parameters. However, you can use spans to represent return values or method arguments. Refer to the code snippet given below that illustrates the complete source code of the Span struct:\n\nYou can take a look at the complete source code of the struct here: https://github.com/dotnet/corefx/blob/master/src/Common/src/CoreLib/System/Span.cs.\n\nThe source code shows that it basically comprises two read-only fields: a native pointer and a property denoting the number of elements that the Span contains.\n\nSpan may be used in the same ways that an array can. However, unlike arrays, it can refer to stack memory, i.e., memory allocated on the stack, managed memory, and native memory. This provides an easy way for you to take advantage of performance improvements that were previously only available when dealing with unmanaged code.\n\nHere's how is declared in the namespace.\n\nTo create an empty Span, you can use the property:\n\nThe following code snippet shows how you can create a byte array in the managed memory and then create a span instance out of it.\n\nHere's how you can allocate a chunk of memory in the stack and use a Span to point to it:\n\nThe following code snippet shows how you can create a Span using a byte array, store integers inside the byte array, and calculate the sum of all the integers stored.\n\nThe following code snippet creates a Span from the native memory:\n\nYou can now use the following code snippet to store integers inside the memory pointed to by the Span and display the sum of all the integers stored:\n\nYou can also allocate a Span in the stack memory using the keyword, as shown below:\n\nRemember to enable compilation of unsafe code in your project. To do this, right-click on your project, click Properties, and check the Unsafe code checkbox, as shown in Figure 1.\n\nSlicing enables data to be treated as logical chunks that can then be processed with minimal resource overhead. can wrap an entire array and, because it supports slicing, you can make it point to any contiguous region within the array. The following code snippet shows how you can use a to point to a slice of three elements within the array.\n\nThere are two overloads of the method available as part of the struct, allowing slices to be created based on an index. This allows the data to be treated as a series of logical chunks that can be processed individually or as desired by sections of a data processing pipeline.\n\nYou can use to wrap an entire array. Because it supports slicing, it can not only point to the first element of the array, but any contiguous range of elements within the array.\n\nWhen you execute the preceding code snippet, the integers present in the sliced array will be displayed at the console, as shown in Figure 2.\n\nA instance is often used to refer to array items or a chunk of an array. As opposed to arrays, instances can refer to native memory, managed memory, or stack memory. Both and provide a type-safe representation of a contiguous region of memory. Although provides a read-write access to a region of memory, provides a read-only access to a memory segment.\n\nThe following code snippet illustrates how you can use to slice a portion of a string in C#:\n\nis a reference type that represents a contiguous region of memory and has a length, but doesn't necessarily start at index 0 and can be one of many regions inside another Memory. The memory represented by the Memory might not even be your process's own, as it could have been allocated in unmanaged code. Memory is useful for representing data in non-contiguous buffers because it allows you to treat them like a single contiguous buffer without copying.\n\nIn addition to , provides a safe and sliceable view into any contiguous buffer, whether an array or a string. Unlike , it has no stack-only constraints because it's not a ref-like type. As a result, you can place it on the heap, use it in collections or with async-await, save it as a field, or box it, just as you would any other C# struct.\n\nThe property allows you to get efficient indexing capabilities when you need to modify or process the buffer referenced by . On the contrary, is a more general-purpose and high-level exchange type than with an immutable, read-only counterpart named .\n\nAlthough both and represent a contiguous chunk of memory, unlike , is not a ref struct. So, contrary to , you can have anywhere on the managed heap. Hence, you don't have the same restrictions in as you do in . And you can use as a class field, and across await and yield boundaries.\n\nSimilar to , represents read only access to a contiguous region of memory but unlike a , it isn't a ByRef type.\n\nNow refer to the following string that contains country names separated by space characters.\n\nThe method extracts each of the country names as shown below:\n\nYou can call the above method and display the country names at the console window using the following code snippet:\n\nThe main advantage of using the Span and Memory types is improved performance. You can allocate memory on the stack by using the keyword, which allocates an uninitialized block that's an instance of type T[size]. This isn't necessary if your data is already on the stack, but for large objects, it's useful because arrays allocated in this way exist only for as long as their scope lasts. If you're using a heap-allocated arrays, you can pass them through a method like and create views without copying any data.\n\nHere are some more advantages:\n• They reduce the number of allocations for the garbage collector. They also reduce the number of copies of the data and provide a more efficient way to work with multiple buffers at once.\n• They allow you to write high performance code. For example, if you have a large chunk of memory that you need to divide into smaller pieces, use Span as a view of the original memory. This allows your app to directly access the bytes from the original buffer without making copies.\n• They allow you to directly access memory without copying it. This can be particularly useful when working with native libraries or interop with other languages.\n• They allow you to eliminate bounds checking in tight loops where performance is critical (such as cryptography or network packet inspection).\n• They allow you to eliminate boxing and unboxing costs associated with generic collections, like List.\n• They enable writing code that is easier to understand by using a single data type (Span) rather than two different types (Array and ArraySegment).\n\nA contiguous memory buffer is a block of memory that holds the data in sequentially adjacent locations. In other words, all of the bytes are next to each other in memory. An array represents a contiguous memory buffer. For example:\n\nThe five integers in the above example will be placed in five sequential locations in memory starting with the first element (values[0]).\n\nIn contrast to contiguous buffers, you can use non-contiguous buffers for cases where there are multiple blocks of data that aren't located next to one another or when working with unmanaged code. Span and Memory types were designed specifically for non-contiguous buffers and provide convenient ways to work with them.\n\nA non-contiguous region of memory has no guarantee that the elements are stored in any particular order or that they're stored close together in memory. Non-contiguous buffers, such as (when used with segments), reside in separate areas of memory that may be scattered across the heap and cannot be accessed by a single pointer.\n\nFor example, is non-contiguous because there's no way to know where the next item will be until you have enumerated over each one individually. In order to represent these gaps between segments, you must use additional data to track where each segment starts and ends.\n\nLet's assume that you're working with a buffer that is not contiguous. For example, the data might be coming from a network stream, database call, or file stream. Each of these scenarios can have multiple buffers of varying sizes. A single instance can contain one or more segments of memory and each segment can have its own instance. Therefore, a single instance allows for better management of available memory and provides better performance than many concatenated instances.\n\nYou can create a instance using the factory method on the class as well as other methods such as . The method has several overloads that allow you to pass in or , sequence of byte arrays , or collections of byte arrays ( ) and .\n\nYou now know that and provide support for contiguous memory buffers such as arrays. The namespace contains a struct called that provides support for working with discontiguous memory buffers. The following code snippet illustrates how you can work with in C#:\n\nYou can also use , as shown below:\n\nLet's now talk about a real-life problem and how and can help. Consider the following array of strings that contains log data retrieved from a log file:\n\nRemember, you can have millions of log records, so performance is critical. This example is just an extract of log data from massive volumes of log data. The data for each of the rows comprise of the HTTP Request ID, the DateTime of the HTTP Request, and the endpoint URL. Now suppose you need to extract the request ID and the endpoint URL from this data.\n\nYou need a solution that's high performant. If you use the method of the class, many string objects will be created and it would degrade the performance of your application as well. The best solution is to use a here to avoid allocations. The solution to this is using and the method as illustrated in the next section.\n\nIt's time for some measurements. Let's now benchmark the performance of struct versus the method of the class.\n\nLet's create a console application project that you'll use for benchmarking performance. You can create a project in Visual Studio 2022 in several ways. When you launch Visual Studio 2022, you'll see the Start window. You can choose Continue without code to launch the main screen of the Visual Studio 2022 IDE.\n\nTo create a new Console Application Project in Visual Studio 2022:\n• In the Create a new project window, select Console App, and click Next to move on.\n• Specify the project name as HighPerformanceCodeDemo and the path where it should be created in the Configure your new project window.\n• If you want the solution file and project to be created in the same directory, you can optionally check the Place solution and project in the same directory checkbox. Click Next to move on.\n• In the next screen, specify the target framework you would like to use for your console application.\n\nYou'll use this application in the subsequent sections of this article.\n\nSo far so good. The next step is to install the necessary NuGet Package(s). To install the required packages into your project, right-click on the solution and the select Manage NuGet Packages for Solution…. Now search for the package named BenchmarkDotNet in the search box and install it. Alternatively, you can type the commands shown below at the NuGet Package Manager Command Prompt:\n\nLet's now examine how to benchmark the performance of and methods. Create a new class named with the code in Listing 1. You should note how data has been set up in the method and the usage of the attribute.\n\nNow, write the two methods named and , as shown in Listing 2. While the former retrieves using the last country name with the method of the class, the latter extracts the last country name using the method.\n\nThe complete source code of the class is provided for your reference in Listing 3.\n\nWrite the following piece of code in the file to run the benchmarks:\n\nTo execute the benchmarks, set the compile mode of the project to Release and run the following command in the same folder where your project file resides:\n\nFigure 3 shows the result of the execution of the benchmarks.\n\nAs you can see in Figure 3, there's absolutely no allocation when you're using the method to extract the string. For each of the benchmarked methods, a row of the result data is generated. Because there are two benchmark methods, there are two rows of benchmark result data. The benchmark results show the mean execution time, Gen0 collections, and the allocated memory. As is evident from the benchmark results, is more than 7.5 times faster than the method.\n\nis stack-only, which means it's inappropriate for storing references to buffers on the heap, as in routines performing asynchronous calls. It's not allocated in the managed heap but on the stack and it doesn't support boxing to prevent promotion to the managed heap. You can't use as a generic type but you can use it as a field type in a ref struct. You can't assign to variables of type dynamic, object, or any other interface type. You can't use as fields in a reference type, nor can you use it across await and yield boundaries. Additionally, because doesn't inherit , you can't use LINQ with it.\n\nIt's important to note that you can't have a field in a class, create an array of a , or box a instance. Note that neither nor implement . So, you wouldn't be able to use LINQ operations with either of these. However, you can take advantage of or to get around this limitation.\n\nIn this article I examined the features and benefits of and and how you can implement them in your applications. I also discussed a real-life scenario where can be used to improve string handling performance. Note that is more versatile and better performant than but it isn't a complete replacement of it."
    },
    {
        "link": "https://stackoverflow.com/questions/62233484/copy-a-readonlyspan-to-a-span-in-one-pass",
        "document": "All guidelines seem to boil down to creating a new , initialized by an array of a given type. This involves an extra pass and an extra zeroing of the array.\n\nI'm wondering if there's a way to allocate some memory for a (like ), but then with a as source. I currently have two approaches ( is a string, is the string length):\n\nApproach 2 has one pass too few (this turns a ReadOnlySpan into a read/write Span, dangerous stuff):\n\nI've searched for both C# and F# solutions but couldn't find a good answer. One approach might be with , but that seems to be overkill for the simple \"copy this into something read-/writeable\".\n\ntagged this both C# and F# as I don't really mind an answer in either language"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.asspan?view=net-9.0",
        "document": "Creates a new read-only span over a portion of the target string from a specified position for a specified number of characters.\n\nCreates a new ReadOnlySpan<T> over a portion of a target string using the range start and end indexes.\n\nCreates a new ReadOnlySpan<T> over a portion of the target string from a specified position to the end of the string.\n\nCreates a new read-only span over a portion of the target string from a specified position to the end of the string.\n\nCreates a new span over the portion of the target array beginning at a specified position for a specified length.\n\nCreates a new span over a portion of the target array segment beginning at a specified index and ending at the end of the segment.\n\nCreates a new span over a portion of a target array segment from a specified position to the end of the segment.\n\nCreates a new span over a portion of a target array segment using the range start and end indexes.\n\nCreates a new span over the portion of the target array defined by an Index value.\n\nCreates a new span over a portion of the target array starting at a specified position to the end of the array.\n\nCreates a new span over a portion of a target array defined by a Range value.\n\nCreates a new span over a portion of a target array segment from a specified position for a specified length."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca1831",
        "document": "CA1831: Use AsSpan instead of Range-based indexers for string when appropriate\n\nA range-indexer is used on a string and the value is implicitly assigned to .\n\nThis rule fires when you use a range-indexer on a string and assign it to a span type. The range indexer on a Span<T> is a non-copying Slice operation, but for the range indexer on a string, the method Substring will be used instead of Slice. This produces a copy of the requested portion of the string. This copy is usually unnecessary when it's implicitly used as a ReadOnlySpan<T> or ReadOnlyMemory<T> value. If a copy isn't intended, use the AsSpan method to avoid the unnecessary copy. If the copy is intended, either assign it to a local variable first or add an explicit cast. The analyzer only reports when an implicit cast is used on the result of the range indexer operation.\n\nTo fix a violation of this rule, use AsSpan instead of the Range-based indexer on the string to avoid creating unnecessary data copies.\n\nYou can also add an explicit cast to avoid this warning.\n\nIt's safe to suppress a violation of this rule if creating a copy is intended.\n\nIf you just want to suppress a single violation, add preprocessor directives to your source file to disable and then re-enable the rule.\n\nTo disable the rule for a file, folder, or project, set its severity to in the configuration file.\n\nTo disable this entire category of rules, set the severity for the category to in the configuration file.\n\nFor more information, see How to suppress code analysis warnings.\n• CA1832: Use AsSpan or AsMemory instead of Range-based indexers for getting ReadOnlySpan or ReadOnlyMemory portion of an array\n• CA1833: Use AsSpan or AsMemory instead of Range-based indexers for getting Span or Memory portion of an array"
    },
    {
        "link": "https://stackoverflow.com/questions/77535131/string-asspan-vs-implicit-cast-operator-performance-in-net-for-readonlyspanc",
        "document": "Since .NET version something we now have an implicit cast from -> . This means that if a function accepts a , we can just pass it a string and the \"conversion\" will happen automatically.\n\n This implicit operator is not available in .NET Standard 2.0 nor in .NET Framework though... We are working with all three :)\n\nBasically I have this field in my\n\nI use this field every time a function called is called. The alternative would be to remove this field and put a inside . But I do not know if that is wise or not\n\nTo make my .NET code compliant with .NET Standard 2.0 and Framework I could simply add calls to my strings. This is however \"unnecessary\" in .NET (Core) but my question is: Is it also performance wise worse? Or do the extension and the implicit operator perform the same operation behind the scenes anyway?"
    },
    {
        "link": "https://stackoverflow.com/questions/73939576/why-cant-i-assign-a-string-to-a-readonlyspan-using-net-framework-4-8",
        "document": "I am trying to make use of . I am trying to convert a guid variable to like this:\n\nThe type comes from the System.Memory nuget package. How do I fix this?"
    },
    {
        "link": "https://dotnettips.wordpress.com/2024/01/30/collection-performance-in-microsoft-net-converting-byte-array-to-readonlyspanbyte",
        "document": "When dealing with byte arrays and needing conversion to , there are two methods to achieve this, with one being more performant. Here’s an example:\n\nHere is an example of achieving the same result using :\n\ncan also be utilized to convert a byte array to as demonstrated in this example:\n\nUsing is important for several reasons:\n• Performance Optimization: Utilizing directly provides access to a portion of an array without creating temporary copies or new arrays. This eliminates unnecessary memory allocations and potential garbage collection overhead, resulting in significant performance gains. This is especially beneficial in scenarios involving large arrays or frequent array operations.\n• Efficient Memory Management: enables working with segments of arrays without allocating additional memory. This reduces overall memory usage and alleviates pressure on the garbage collector. This aspect is crucial for memory-sensitive applications and those handling large datasets.\n• Improved Code Clarity and Modernity: offers a more concise and expressive way to work with array segments, enhancing code readability and maintainability. Adopting these methods contributes to writing clearer and more modern code.\n• Future-Proofing Code: As the .NET framework evolves, features and APIs are optimized for working with . By incorporating these constructs into your code now, you ensure that it is ready for future .NET versions and potential performance enhancements. This proactive approach helps maintain the efficiency and relevance of your code over time.\n\nThe benchmark results clearly demonstrate the significant performance advantage of using . With a performance improvement of 54 times compared to other methods, and the additional benefit of not allocating any memory, it underscores the efficiency gains achievable through this approach. This reinforces the importance of choosing for optimal performance, particularly in scenarios where memory allocation and efficient array handling are critical considerations.\n\nUtilizing to transform a byte array into demonstrates a 57-fold improvement in performance, as indicated by the following results.\n\nPick up any books by David McCarter by going to Amazon.com: http://bit.ly/RockYourCodeBooks\n\nIf you liked this article, please buy David a cup of Coffee by going here: https://www.buymeacoffee.com/dotnetdave\n\n© The information in this article is copywritten and be preproduced in any way without express permission from David McCarter."
    },
    {
        "link": "https://stackoverflow.com/questions/129120/when-should-i-use-debug-assert",
        "document": "Should I begin using Asserts in our production code? And if so, When is its use most appropriate? Would it make more sense to do\n\nOur production code contains no asserts whatsoever and my question is this...\n\nI've been a professional software engineer for about a year now, having graduated with a CS degree. I've known about assertions for a while in C++ and C, but had no idea they existed in C# and .NET at all until recently.\n\nFWIW ... I find that my public methods tend to use the pattern to ensure that the method is being called correctly. My private methods tend to use . The idea is that with my private methods, I'm the one under control, so if I start calling one of my own private methods with parameters that are incorrect, then I've broken my own assumption somewhere--I should have never gotten into that state. In production, these private asserts should ideally be unnecessary work since I am supposed to be keeping my internal state valid and consistent. Contrast with parameters given to public methods, which could be called by anyone at runtime: I still need to enforce parameter constraints there by throwing exceptions. Additionally, my private methods can still throw exceptions if something doesn't work at runtime (network error, data access error, bad data retrieved from a third party service, etc.). My asserts are just there to make sure that I haven't broken my own internal assumptions about the state of the object.\n\nAn assertion is code that’s used during development—usually a routine or macro—that allows a program to check itself as it runs. When an assertion is true, that means everything is operating as expected. When it’s false, that means it has detected an unexpected error in the code. For example, if the system assumes that a customer-information file will never have more than 50,000 records, the program might contain an assertion that the number of records is lessthan or equal to 50,000. As long as the number of records is less than or equal to 50,000, the assertion will be silent. If it encounters more than 50,000 records, however, it will loudly “assert” that there is an error in the program. Assertions are especially useful in large, complicated programs and in high reliability programs. They enable programmers to more quickly flush out mismatched interface assumptions, errors that creep in when code is modified, and so on. An assertion usually takes two arguments: a boolean expression that describes the assumption that’s supposed to be true and a message to display if it isn’t. Normally, you don’t want users to see assertion messages in production code; assertions are primarily for use during development and maintenance. Assertions are normally compiled into the code at development time and compiled out of the code for production. During development, assertions flush out contradictory assumptions, unexpected conditions, bad values passed to routines, and so on. During production, they are compiled out of the code so that the assertions don’t degrade system performance.\n\nare used for guards and for checking Design by Contract constraints, i.e. to ensure that the state of your code, objects, variables and parameters is operating within the boundaries and limits of your intended design.\n• should be for Debug and non-Production builds only. Asserts are typically ignored by the compiler in Release builds.\n• can check for bugs / unexpected conditions which ARE in the control of your system\n• are NOT a mechanism for first-line validation of user input or business rules\n• should not be used to detect unexpected environmental conditions (which are outside the control of the code) e.g. out of memory, network failure, database failure, etc. Although rare, these conditions are to be expected (and your app code cannot fix issues like hardware failure or resource exhaustion). Typically, exceptions will be thrown - your application can then either take corrective action (e.g. retry a database or network operation, attempt to free up cached memory), or abort gracefully if the exception cannot be handled.\n• A failed Assertion should be fatal to your system - i.e. unlike an exception, do not try and catch or handle failed - your code is operating in unexpected territory. Stack Traces and crash dumps can be used to determine what went wrong.\n• To assist in finding missing validation of user inputs, or upstream bugs in higher level code.\n• Asserts in the code base clearly convey the assumptions made in the code to the reader\n• Assert will be checked at runtime in builds.\n• Once code has been exhaustively tested, rebuilding the code as Release will remove the performance overhead of verifying the assumption (but with the benefit that a later Debug build will always revert the checks, if needed). expresses a condition which has been assumed about state by the remainder of the code block within the control of the program. This can include the state of the provided parameters, state of members of a class instance, or that the return from a method call is in its contracted / designed range. Typically, asserts should crash the thread / process / program with all necessary info (Stack Trace, Crash Dump, etc), as they indicate the presence of a bug or unconsidered condition which has not been designed for (i.e. do not try and catch or handle assertion failures), with one possible exception of when an assertion itself could cause more damage than the bug (e.g. Air Traffic Controllers wouldn't want a YSOD when an aircraft goes submarine, although it is moot whether a debug build should be deployed to production ...) When should you use\n• At any point in a system, or library API, or service where the inputs to a function or state of a class are assumed valid (e.g. when validation has already been done on user input in the presentation tier of a system, the business and data tier classes typically assume that null checks, range checks, string length checks etc on input have been already done).\n• Common checks include where an invalid assumption would result in a null object dereference, a zero divisor, numerical or date arithmetic overflow, and general out of band / not designed for behaviour (e.g. if a 32 bit int was used to model a human's age, it would be prudent to that the age is actually between 0 and 125 or so - values of -100 and 10^10 were not designed for). .Net Code Contracts\n\n In the .Net Stack, Code Contracts can be used in addition to, or as an alternative to using . Code Contracts can further formalize state checking, and can assist in detecting violations of assumptions at ~compile time (or shortly thereafter, if run as a background check in an IDE).\n• - Expresses an assumption about the state of an object at all points in its lifespan.\n• - pacifies the static checker when a call to non-Contract decorated methods is made.\n\nMostly never in my book. In the vast majority of occasions if you want to check if everything is sane then throw if it isn't. What I dislike is the fact that it makes a debug build functionally different to a release build. If a debug assert fails but the functionality works in release then how does that make any sense? It's even better when the asserter has long left the company and no-one knows that part of the code. Then you have to kill some of your time exploring the issue to see if it is really a problem or not. If it is a problem then why isn't the person throwing in the first place? To me this suggests by using Debug.Asserts you're deferring the problem to someone else, deal with the problem yourself. If something is supposed to be the case and it isn't then throw. I guess there are possibly performance critical scenarios where you want to optimise away your asserts and they're useful there, however I am yet to encounter such a scenario.\n\nAll asserts should be code that could be optimised to: Because it's checking something that you have already assumed is true. E.g.: In the above, there are three different approaches to null parameters. The first accepts it as allowable (it just does nothing). The second throws an exception for the calling code to handle (or not, resulting in an error message). The third assumes it can't possibly happen, and asserts that it is so. In the first case, there's no problem. In the second case, there's a problem with the calling code - it shouldn't have called with null, so it gets an exception back. In the third case, there's a problem with this code, because it should already have been checked that before it was ever called, so that it isn't true is a bug. Or in other words, it should be code that could theoretically be optimised to , sicne should always be !\n\nQuote Taken from The Pragmatic Programmer: From Journeyman to Master There is a common misunderstanding about assertions, promulgated by the people who write compilers and language environments. It goes something like this: Assertions add some overhead to code. Because they check for things that should never happen, they'll get triggered only by a bug in the code. Once the code has been tested and shipped, they are no longer needed, and should be turned off to make the code run faster. Assertions are a debugging facility. There are two patently wrong assumptions here. First, they assume that testing finds all the bugs. In reality, for any complex program you are unlikely to test even a miniscule percentage of the permutations your code will be put through (see Ruthless Testing). Second, the optimists are forgetting that your program runs in a dangerous world. During testing, rats probably won't gnaw through a communications cable, someone playing a game won't exhaust memory, and log files won't fill the hard drive. These things might happen when your program runs in a production environment. Your first line of defense is checking for any possible error, and your second is using assertions to try to detect those you've missed. Turning off assertions when you deliver a program to production is like crossing a high wire without a net because you once made it across in practice. There's dramatic value, but it's hard to get life insurance. Even if you do have performance issues, turn off only those assertions that really hit you.\n\nI thought I would add four more cases, where Debug.Assert can be the right choice. 1) Something I have not seen mentioned here is the additional conceptual coverage Asserts can provide during automated testing. As a simple example: When some higher-level caller is modified by an author who believes they have expanded the scope of the code to handle additional scenarios, ideally (!) they will write unit tests to cover this new condition. It may then be that the fully integrated code appears to work fine. However, actually a subtle flaw has been introduced, but not detected in test results. The callee has become non-deterministic in this case, and only happens to provide the expected result. Or perhaps it has yielded a rounding error that was unnoticed. Or caused an error that was offset equally elsewhere. Or granted not only the access requested but additional privileges that should not be granted. Etc. At this point, the Debug.Assert() statements contained in the callee coupled with the new case (or edge case) driven in by unit tests can provide invaluable notification during test that the original author's assumptions have been invalidated, and the code should not be released without additional review. Asserts with unit tests are the perfect partners. 2) Additionally, some tests are simple to write, but high-cost and unnecessary given the initial assumptions. For example: If an object can only be accessed from a certain secured entry point, should an additional query be made to a network rights database from every object method to ensure the caller has permissions? Surely not. Perhaps the ideal solution includes caching or some other expansion of features, but the design does not require it. A Debug.Assert() will immediately show when the object has been attached to an insecure entry point. 3) Next, in some cases your product may have no helpful diagnostic interaction for all or part of its operations when deployed in release mode. For example: Suppose it is an embedded real-time device. Throwing exceptions and restarting when it encounters a malformed packet is counter-productive. Instead the device may benefit from best-effort operation, even to the point of rendering noise in its output. It also may not have a human interface, logging device, or even be physically accessible by human at all when deployed in release mode, and awareness of errors is best provided by assessing the same output. In this case, liberal Assertions and thorough pre-release testing are more valuable than exceptions. 4) Lastly, some tests are unneccessary only because the callee is perceived as extremely reliable. In most cases, the more reusable code is, the more effort has been put into making it reliable. Therefore it is common to Exception for unexpected parameters from callers, but Assert for unexpected results from callees. For example: If a core operation states it will return a when the search criteria is not found, you may be able to safely perform one operation rather than three. However, if it actually returned , you may have no reasonable course of action. It would be unhelpful to replace the simpler calculation with one that tests separately for a value, and unreasonable in most release environments to litter your code with tests ensuring core libraries are operating as expected. In this case Asserts are ideal.\n\nI've read the answers here and I thought I should add an important distinction. There are two very different ways in which asserts are used. One is as a temporary developer shortcut for \"This shouldn't really happen so if it does let me know so I can decide what to do\", sort of like a conditional breakpoint, for cases in which your program is able to continue. The other, is a as a way to put assumptions about valid program states in your code. In the first case, the assertions don't even need to be in the final code. You should use during development and you can remove them if/when no longer needed. If you want to leave them or if you forget to remove them no problem, since they won't have any consequence in Release compilations. But in the second case, the assertions are part of the code. They, well, assert, that your assumptions are true, and also document them. In that case, you really want to leave them in the code. If the program is in an invalid state it should not be allowed to continue. If you couldn't afford the performance hit you wouldn't be using C#. On one hand it might be useful to be able to attach a debugger if it happens. On the other, you don't want the stack trace popping up on your users and perhaps more important you don't want them to be able to ignore it. Besides, if it's in a service it will always be ignored. Therefore in production the correct behavior would be to throw an Exception, and use the normal exception handling of your program, which might show the user a nice message and log the details. has the perfect way to achieve this. It won't be removed in production, and can be configured with different listeners using app.config. So for development the default handler is fine, and for production you can create a simple TraceListener like below which throws an exception and activate it in the production config file. And in the production config file:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.debug.assert?view=net-9.0",
        "document": "Checks for a condition; if the condition is , displays a message box that shows the call stack. The conditional expression to evaluate. If the condition is , a failure message is not sent and the message box is not displayed. The following example creates an index for an array, performs some action to set the value of the index, and then calls Assert to confirm that the index value is valid. If it is not valid, Assert outputs the call stack. // Create a local value. int index; // Perform some action that sets the local value. index = -40; // Test that the local value is valid. #if defined(DEBUG) Debug::Assert( index > -1 ); #endif // Create an index for an array. int index; // Perform some action that sets the index. index = -40; // Test that the index value is valid. Debug.Assert(index > -1); ' Create an index for an array. Dim index As Integer ' Perform some action that sets the index. index = -40 ' Test that the index value is valid. Debug.Assert((index > - 1)) By default, the Debug.Assert method works only in debug builds. Use the Trace.Assert method if you want to do assertions in release builds. For more information, see Assertions in Managed Code. Typically, the Assert(Boolean) method is used to identify logic errors during program development. Assert evaluates the condition. If the result is , it sends a failure message to the Listeners collection. You can customize this behavior by adding a TraceListener to, or removing one from, the Listeners collection. When the application runs in user interface mode, it displays a message box that shows the call stack with file and line numbers. The message box contains three buttons: Abort, Retry, and Ignore. Clicking the Abort button terminates the application. Clicking Retry sends you to the code in the debugger if your application is running in a debugger, or offers to open a debugger if it is not. Clicking Ignore continues with the next instruction in the code. Windows 8.x apps do not support modal dialog boxes, so they behave the same in user interface mode and non-user interface mode. The message is written to the active trace listeners in debugging mode, or no message is written in release mode. The display of the message box depends on the presence of the DefaultTraceListener. If the DefaultTraceListener is not in the Listeners collection, the message box is not displayed. The DefaultTraceListener can be removed by calling the Clear method on the Listeners property ( ). For .NET Framework apps, you can also use the <clear> element and the <remove> element in your app's configuration file. For .NET Framework apps, you can change the behavior of the DefaultTraceListener in the configuration file that corresponds to the name of your application. In this file, you can enable and disable the assert message box or set the DefaultTraceListener.LogFileName property. The configuration file should be formatted as follows:\n\nChecks for a condition; if the condition is , outputs a specified message and displays a message box that shows the call stack. Public Shared Sub Assert (condition As Boolean, ByRef message As Debug.AssertInterpolatedStringHandler) The conditional expression to evaluate. If the condition is , the specified message is not sent and the message box is not displayed. The message to send to the Listeners collection. This overload was introduced in .NET 6 to improve performance. In comparison to the overloads that take a parameter, this overload only evaluates any interpolated string formatting items if the message is required. By default, the Debug.Assert method works only in debug builds. Use the Trace.Assert method if you want to do assertions in release builds. For more information, see Assertions in Managed Code. Typically, the Assert method is used to identify logic errors during program development. Assert evaluates the condition. If the result is , it sends the specified diagnostic message to the Listeners collection. You can customize this behavior by adding a TraceListener to, or removing one from, the Listeners collection. When the application runs in user interface mode, it displays a message box that shows the call stack with file and line numbers. The message box contains three buttons: Abort, Retry, and Ignore. Clicking the Abort button terminates the application. Clicking Retry sends you to the code in the debugger if your application is running in a debugger, or offers to open a debugger if it is not. Clicking Ignore continues with the next instruction in the code. The display of the message box depends on the presence of the DefaultTraceListener. If the DefaultTraceListener is not in the Listeners collection, the message box is not displayed. The DefaultTraceListener can be removed by calling the Clear method on the Listeners property ( ). For .NET Framework apps, you can also use the <clear> element and the <remove> element in your app's configuration file. For .NET Framework apps, you can change the behavior of the DefaultTraceListener in the configuration file that corresponds to the name of your application. In this file, you can enable and disable the assert message box or set the DefaultTraceListener.LogFileName property. The configuration file should be formatted as follows:\n\nChecks for a condition; if the condition is , outputs a specified message and displays a message box that shows the call stack. Public Shared Sub Assert (condition As Boolean, message As String) Public Shared Sub Assert (condition As Boolean, Optional message As String = Nothing) The conditional expression to evaluate. If the condition is , the specified message is not sent and the message box is not displayed. The message to send to the Listeners collection. The following example checks whether the parameter is valid. If is , Assert outputs a message. Public Shared Sub MyMethod(type As Type, baseType As Type) Debug.Assert(Not (type Is Nothing), \"Type parameter is null\") End Sub By default, the Debug.Assert method works only in debug builds. Use the Trace.Assert method if you want to do assertions in release builds. For more information, see Assertions in Managed Code. Typically, the Assert method is used to identify logic errors during program development. Assert evaluates the condition. If the result is , it sends the specified diagnostic message to the Listeners collection. You can customize this behavior by adding a TraceListener to, or removing one from, the Listeners collection. When the application runs in user interface mode, it displays a message box that shows the call stack with file and line numbers. The message box contains three buttons: Abort, Retry, and Ignore. Clicking the Abort button terminates the application. Clicking Retry sends you to the code in the debugger if your application is running in a debugger, or offers to open a debugger if it is not. Clicking Ignore continues with the next instruction in the code. The display of the message box depends on the presence of the DefaultTraceListener. If the DefaultTraceListener is not in the Listeners collection, the message box is not displayed. The DefaultTraceListener can be removed by calling the Clear method on the Listeners property ( ). For .NET Framework apps, you can also use the <clear> element and the <remove> element in your app's configuration file. For .NET Framework apps, you can change the behavior of the DefaultTraceListener in the configuration file that corresponds to the name of your application. In this file, you can enable and disable the assert message box or set the DefaultTraceListener.LogFileName property. The configuration file should be formatted as follows:\n\nChecks for a condition; if the condition is , outputs a specified message and displays a message box that shows the call stack. Public Shared Sub Assert (condition As Boolean, ByRef message As Debug.AssertInterpolatedStringHandler, ByRef detailMessage As Debug.AssertInterpolatedStringHandler) The conditional expression to evaluate. If the condition is , the specified message is not sent and the message box is not displayed. The message to send to the Listeners collection. The detailed message to send to the Listeners collection. This overload was introduced in .NET 6 to improve performance. In comparison to the overloads that take a parameter, this overload only evaluates any interpolated string formatting items if the message is required. By default, the Debug.Assert method works only in debug builds. Use the Trace.Assert method if you want to do assertions in release builds. For more information, see Assertions in Managed Code. Typically, the Assert method is used to identify logic errors during program development. Assert evaluates the condition. If the result is , it sends the specified diagnostic message to the Listeners collection. You can customize this behavior by adding a TraceListener to, or removing one from, the Listeners collection. When the application runs in user interface mode, it displays a message box that shows the call stack with file and line numbers. The message box contains three buttons: Abort, Retry, and Ignore. Clicking the Abort button terminates the application. Clicking Retry sends you to the code in the debugger if your application is running in a debugger, or offers to open a debugger if it is not. Clicking Ignore continues with the next instruction in the code. The display of the message box depends on the presence of the DefaultTraceListener. If the DefaultTraceListener is not in the Listeners collection, the message box is not displayed. The DefaultTraceListener can be removed by calling the Clear method on the Listeners property ( ). For .NET Framework apps, you can also use the <clear> element and the <remove> element in your app's configuration file. For .NET Framework apps, you can change the behavior of the DefaultTraceListener in the configuration file that corresponds to the name of your application. In this file, you can enable and disable the assert message box or set the DefaultTraceListener.LogFileName property. The configuration file should be formatted as follows:\n\nChecks for a condition; if the condition is , outputs two specified messages and displays a message box that shows the call stack. Public Shared Sub Assert (condition As Boolean, message As String, detailMessage As String) The conditional expression to evaluate. If the condition is , the specified messages are not sent and the message box is not displayed. The message to send to the Listeners collection. The detailed message to send to the Listeners collection. The following example checks whether the parameter is valid. If is , Assert outputs two messages. void MyMethod( Object^ obj, Type^ type ) { #if defined(DEBUG) Debug::Assert( type != nullptr, \"Type paramater is null\", \"Can't get object for null type\" ); #endif } public static void MyMethod(Type type, Type baseType) { Debug.Assert(type != null, \"Type parameter is null\", \"Can't get object for null type\"); // Perform some processing. } Public Shared Sub MyMethod(type As Type, baseType As Type) Debug.Assert( Not (type Is Nothing), \"Type parameter is null\", \"Can't get object for null type\") ' Perform some processing. End Sub By default, the Debug.Assert method works only in debug builds. Use the Trace.Assert method if you want to do assertions in release builds. For more information, see Assertions in Managed Code. Typically, the Assert(Boolean, String, String) method is used to identify logic errors during program development. Assert evaluates the condition. If the result is , it sends the specified diagnostic message and detailed message to the Listeners collection. You can customize this behavior by adding a TraceListener to, or removing one from, the Listeners collection. When the application runs in user interface mode, it displays a message box that shows the call stack with file and line numbers. The message box contains three buttons: Abort, Retry, and Ignore. Clicking the Abort button terminates the application. Clicking Retry sends you to the code in the debugger if your application is running in a debugger, or offers to open a debugger if it is not. Clicking Ignore continues with the next instruction in the code. The display of the message box depends on the presence of the DefaultTraceListener. If the DefaultTraceListener is not in the Listeners collection, the message box is not displayed. The DefaultTraceListener can be removed by calling the Clear method on the Listeners property ( ). For .NET Framework apps, you can also use the <clear> element and the <remove> element in your app's configuration file. For .NET Framework apps, you can change the behavior of the DefaultTraceListener in the configuration file that corresponds to the name of your application. In this file, you can enable and disable the assert message box or set the DefaultTraceListener.LogFileName property. The configuration file should be formatted as follows:\n\nChecks for a condition; if the condition is , outputs two messages (simple and formatted) and displays a message box that shows the call stack. Public Shared Sub Assert (condition As Boolean, message As String, detailMessageFormat As String, ParamArray args As Object()) The conditional expression to evaluate. If the condition is , the specified messages are not sent and the message box is not displayed. The message to send to the Listeners collection. The composite format string to send to the Listeners collection. This message contains text intermixed with zero or more format items, which correspond to objects in the array. An object array that contains zero or more objects to format. This method uses the .NET composite formatting feature to convert the value of an object to its text representation and embed that representation in a string. The resulting string is sent to the Listeners collection. By default, the Debug.Assert method works only in debug builds. Use the Trace.Assert method if you want to do assertions in release builds. For more information, see Assertions in Managed Code. Typically, the Assert(Boolean, String, String, Object[]) method is used to identify logic errors during program development. Assert evaluates the condition. If the result is , The String.Format(String, Object[]) method is called and the string and array are passed in as parameters. Assert(Boolean, String, String, Object[]) then sends the specified text message and the formatted text message to the Listeners collection. You can customize this behavior by adding a TraceListener to, or removing one from, the Listeners collection. When the application runs in user interface mode, it displays a message box that shows the call stack with file and line numbers. The message box contains three buttons: Abort, Retry, and Ignore. Clicking the Abort button terminates the application. Clicking Retry sends you to the code in the debugger if your application is running in a debugger, or offers to open a debugger if it is not. Clicking Ignore continues with the next instruction in the code. The display of the message box is dependent on the presence of the DefaultTraceListener. If the DefaultTraceListener is not in the Listeners collection, the message box is not displayed. The DefaultTraceListener can be removed by calling the Clear method on the Listeners property ( ). For .NET Framework apps, you can also use the <clear> element and the <remove> element in your app's configuration file. For .NET Framework apps, you can change the behavior of the DefaultTraceListener in the configuration file that corresponds to the name of your application. In this file, you can enable and disable the assert message box or set the DefaultTraceListener.LogFileName property. The configuration file should be formatted as follows:"
    },
    {
        "link": "https://stackoverflow.com/questions/20603510/debug-assert-vs-code-contract-usage",
        "document": "These are different things. A debug assert is only executed when the code is compiled as debug and therefore will only check/assert under debug. The idea is to use this for \"sanity checks\" for code you are developing. Code contracts can be used in either debug or release. They assure that pre and post conditions of methods comply with the expectations of the method (meet the contract). There is also a testing framework that provides similar functionality, designed for checking test compliance.\n\nUse Debug.Assert when you want ensure that certain things are as you expect when developing the code (and in later maintenance development).\n\nUse code contracts when you want to assure that conditions are true in both debug and release. Contracts also allow certain forms of static analysis that can be helpful in verifying that your program is \"correct\".\n\nUse the Testing framework assertions when creating unit tests."
    },
    {
        "link": "https://vbforums.com/showthread.php?293831-*RESOLVED*-Debug-Assert",
        "document": "Assertions are a convenient way to test for conditions that should exist at specific points in your code. Think of an Assert statement as making an assumption. If your assumption is True, the assertion will be ignored; if your assumption is False, VB will bring it to your attention.In Visual Basic, assertions take the form of a method: the Assert method of the Debug object. The Assert method takes a single argument of the type Boolean which states the condition to be evaluated. The syntax for the Assert method is as follows:Debug.Assert(boolean expression)A Debug.Assert statement will never appear in a compiled application, but when you're running in the design environment it causes the application to enter break mode with the line containing the statement highlighted (assuming that the expression evaluates to False). The following example shows the Debug.Assert statement:Debug.Assert Trim(CustName) = \"John Doe\"In this case, if the CustName isn't John Doe, the application will enter break mode; otherwise the execution will continue as usual. Using Debug.Assert is similar to setting a watch with the Break When Value Is True option selected, except that it will break when the value is false."
    },
    {
        "link": "https://quora.com/What-is-debug-assert-in-VBA-and-when-should-I-use-it",
        "document": "Something went wrong. Wait a moment and try again."
    }
]