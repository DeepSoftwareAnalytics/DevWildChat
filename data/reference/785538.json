[
    {
        "link": "https://forum.cheatengine.org/viewtopic.php?t=217758",
        "document": "Posted: Sun Mar 23, 2008 12:14 pm Post subject: [Tutorial] How to nop and make cleaner scripts! \n\n \n\n Original Post by me \n\n \n\n Sponsered by \n\n \n\n This tutorial may not matter much, but is useful for people who like things neat \n\n \n\n I will be showing you how to do this with nopping in this tutorial. \n\n \n\n First Step: Find an opcode that you would like to nop. \n\n \n\n The Bytes are what you will be using instead of opcodes to make this Auto-Assembly script looking neat. So for this address the bytes are: \n\n This was first posted on MMOVision by meSponsered by MMOVision This tutorial may not matter much, but is useful for people who like things neatI will be showing you how to do this with nopping in this tutorial.First Step: Find an opcode that you would like to nop.The Bytes are what you will be using instead of opcodes to make this Auto-Assembly script looking neat. So for this address the bytes are: \n\n and the opcode which you would put in a normal script is: \n\n \n\n \n\n So now you can make your disable section which is: \n\n [disable] \n\n 0008359A: //This is the address of the opcode which always before the opcode or bytes \n\n db 68 e0 17 08 00 //db means define byte so now you put this here since it is the original opcode/bytes so you can restore the code once you disable the cheat \n\n \n\n but the original disable section would be: \n\n [disable] \n\n 0008359A: //This is the address of the opcode which always before the opcode or bytes \n\n push 000817e0 //This is the original opcode so it can restore the code when you disable the cheat \n\n \n\n \n\n \n\n \n\n Second Step: Now we nop that address by right clicking and clicking replace with code that does nothing. \n\n \n\n \n\n \n\n Third Step: Once we nop the address we count how many opcodes change to nop or how many bytes change to 90 in a row below it. \n\n \n\n \n\n \n\n Fourth Step: In this case there are 5 nops or 90s so now we can build our enable section. \n\n \n\n The original script would look like this: \n\n Second Step: Now we nop that address by right clicking and clicking replace with code that does nothing.Third Step: Once we nop the address we count how many opcodes change to nop or how many bytes change to 90 in a row below it.Fourth Step: In this case there are 5 nops or 90s so now we can build our enable section.The original script would look like this: [enable] \n\n 0008359A: //This is the address of the opcode which always before the opcode or bytes \n\n nop //This is the amount of opcodes that changed to nop when you replaced with a code that does nothing \n\n nop \n\n nop \n\n nop \n\n nop \n\n \n\n \n\n but this script annoys some people and looks messy so to make it neater we can insert the bytes instead and make the script like this: \n\n \n\n [enable] \n\n 0008359A: //This is the address of the opcode which always before the opcode or bytes \n\n db 90 90 90 90 90 //This is the amount of nops and one nop in bytes is 90 so we put define byte and 5 nops \n\n \n\n \n\n Then we would combine the enable and the original script would be: \n\n \n\n [enable] \n\n 0008359A: //This is the address of the opcode which always before the opcode or bytes \n\n nop //This is the amount of opcodes that changed to nop when you replaced with a code that does nothing \n\n nop \n\n nop \n\n nop \n\n nop \n\n [disable] \n\n 0008359A: //This is the address of the opcode which always before the opcode or bytes \n\n push 000817e0 //This is the original opcode so it can restore the code when you disable the cheat \n\n \n\n A much neater version of this script using bytes would be: \n\n \n\n [enable] \n\n 0008359A: //This is the address of the opcode which always before the opcode or bytes \n\n db 90 90 90 90 90 //This is the amount of nops and one nop in bytes is 90 so we put define byte and 5 nops \n\n [disable] \n\n 0008359A: //This is the address of the opcode which always before the opcode or bytes \n\n db 68 e0 17 08 00 //db means define byte so now you put this here since it is the original opcode/bytes so you can restore the code once you disable the cheat \n\n \n\n See how the clean script without my commentary is 6 lines while the original script would be 10 lines long. \n\n \n\n You have just learned hop to nop and script neater!"
    },
    {
        "link": "https://forum.cheatengine.org/viewtopic.php?t=95363",
        "document": ": 7\n\n\n\nJoined: 04 May 2007\n\nPosts: 955\n\nLocation: Why do you care? Reputation : 7Joined: 04 May 2007Posts: 955Location: Why do you care? \n\n\n\nPosted: Wed Jun 13, 2007 11:55 am Post subject: A Very In Depth Tutorial on Auto Assembler ------------------------------ \n\n Table of Contents \n\n ------------------------------ \n\n \n\n I. Introduction \n\n II. Registers \n\n II.a 32 Bit Registers \n\n II.b 16 Bit Registers \n\n III. Commands \n\n III.a JMP \n\n III.b MOV \n\n III.c Push/Pop + The Stack \n\n III.d alloc/label/registersymbol \n\n III.e Call and Ret \n\n III.f Others \n\n IV. Array of Bytes \n\n V. Conclusion \n\n VI. Credits/Acknowledgements \n\n \n\n BONUS: Writing a Script \n\n \n\n ------------------------------ \n\n I. Introduction \n\n ------------------------------ \n\n 'Ello there, I assume one of two things because you're reading this. \n\n \n\n 1) You're trying to learn Auto Assembler (I won't call you a noob, because everybody has to start somewhere, right? =) ) \n\n \n\n or \n\n \n\n 2) You want to test your Auto Assembler knowledge (to an extent). \n\n \n\n Now, if the first of the two is correct, then take each part slowly, and make sure you understand a section before going on ahead. \n\n \n\n \n\n Most people think that AA is hard, but in fact, it's really quite easy. \n\n \n\n \n\n Words from the creator of Cheat Engine himself. \n\n \n\n If the second of the two is true, then I don't really have any advice for you, however I do have a favor to ask. If you find something incorrect, or vague, or something that you think I can redo better, PLEASE TELL ME. I sitll in the process of learning myself! But wait, don't even ask, I can read your mind... \n\n \n\n \n\n Why should I listen (or in this case, read) to/from someone who is still learning? \n\n \n\n \n\n Well, I'll tell you, my good friend. Although I'm still learning, I do know about Auto Assembler, and I just thought it would be nice to share the knowledge that I have with you. =) \n\n \n\n Edit: This was written a long time ago, but I've learned a lot, and I've rechecked it. \n\n \n\n Now, off we go... into the amazing world of the computer..... \n\n \n\n ------------------------------ \n\n II. Registers \n\n ------------------------------ \n\n \n\n Now you have probably seen these before in scripts, as they are VERY commonly used. There are two types of Registers used, and I shall explain both in this guide. \n\n \n\n --------------- \n\n II.a 32 Bit \n\n --------------- \n\n \n\n First of all, I will explain how each register got its name, in order to possibly help you remember which is which. First of all, the E in front (if you notice below, all of the 32 Bit Registers have an E in front) tells you that the register is a 32 Bit Register. The A, B, C, and D, should become obvious after reading the description. As should SI, DI, BP, SP, and IP. The X after EAX, EBX, ECX, and EDX, is simply there to show that there are no more letters to put, kinda like a NOP command (which you will read about later on). If you notice, there are three letters in each of the 32 Bit Registers. \n\n \n\n EAX: The Acculmulator register. It can also be used as storage. \n\n EBX: Once upon a time, it was the base register, but now it's just free storage. \n\n ECX: The Counting register. Once again, can also be used as storage. \n\n EDX: The Data register. As with the last three, it can be used as storage. \n\n ESI: The Source Index register. It is used as a pointer variable in strings, but you shouldn't worry about that part right now. Can be used for storage. \n\n EDI: The Destiny Index register. Once again, can be used as storage, and is a pointer variable in strings, but don't worry about it. \n\n EBP: The Base Pointer register. It temporarily store ESP, but can also be used as general storage. \n\n ESP: The Source Pointer register. It points to registers and addresses on the stack (more on that later). \n\n EIP: The Instruction Pointer register. Using this incorrectly can lead to a crash in whatever program you're trying to mess with. \n\n \n\n --------------- \n\n II.b 16 Bit \n\n --------------- \n\n \n\n The 16 Bit Registers are very similar to the 32 Bit Registers, save a couple things. One of the things is that, instead of three letters, as the 32 Bit registers have, they have two letters. There are also a couple more 16 Bit registers than 32 Bit registers, but don't worry about them. 16 Bit registers probably won't be used in our general purposes anyway. \n\n \n\n AX: See EAX \n\n BX: See EBX \n\n CX: See ECX \n\n DX: See EDX \n\n SI: See ESI \n\n DI: See EDI \n\n BP: See EBP \n\n SP: See ESP \n\n IP: See EIP \n\n \n\n --------------- \n\n \n\n And that's pretty much it on registers. If you want to learn more about registers, then just go \n\n \n\n ------------------------------ \n\n III. Commands \n\n ------------------------------ \n\n \n\n Now, what is a language without its functions or commands? Comparing this to English, a command is like a word, and an opcode is like a sentence. For those that don't know, an opcode is something simple, such as: \n\n \n\n Well, I'll tell you, my good friend. Although I'm still learning, I do know about Auto Assembler, and I just thought it would be nice to share the knowledge that I have with you. =)Edit: This was written a long time ago, but I've learned a lot, and I've rechecked it.Now, off we go... into the amazing world of the computer.....------------------------------II. Registers------------------------------Now you have probably seen these before in scripts, as they are VERY commonly used. There are two types of Registers used, and I shall explain both in this guide.---------------II.a 32 Bit---------------First of all, I will explain how each register got its name, in order to possibly help you remember which is which. First of all, the E in front (if you notice below, all of the 32 Bit Registers have an E in front) tells you that the register is a 32 Bit Register. The A, B, C, and D, should become obvious after reading the description. As should SI, DI, BP, SP, and IP. The X after EAX, EBX, ECX, and EDX, is simply there to show that there are no more letters to put, kinda like a NOP command (which you will read about later on). If you notice, there are three letters in each of the 32 Bit Registers.EAX: The Acculmulator register. It can also be used as storage.EBX: Once upon a time, it was the base register, but now it's just free storage.ECX: The Counting register. Once again, can also be used as storage.EDX: The Data register. As with the last three, it can be used as storage.ESI: The Source Index register. It is used as a pointer variable in strings, but you shouldn't worry about that part right now. Can be used for storage.EDI: The Destiny Index register. Once again, can be used as storage, and is a pointer variable in strings, but don't worry about it.EBP: The Base Pointer register. It temporarily store ESP, but can also be used as general storage.ESP: The Source Pointer register. It points to registers and addresses on the stack (more on that later).EIP: The Instruction Pointer register. Using this incorrectly can lead to a crash in whatever program you're trying to mess with.---------------II.b 16 Bit---------------The 16 Bit Registers are very similar to the 32 Bit Registers, save a couple things. One of the things is that, instead of three letters, as the 32 Bit registers have, they have two letters. There are also a couple more 16 Bit registers than 32 Bit registers, but don't worry about them. 16 Bit registers probably won't be used in our general purposes anyway.AX: See EAXBX: See EBXCX: See ECXDX: See EDXSI: See ESIDI: See EDIBP: See EBPSP: See ESPIP: See EIP---------------And that's pretty much it on registers. If you want to learn more about registers, then just go Google it. For most learners, however, this should suffice.------------------------------III. Commands------------------------------Now, what is a language without its functions or commands? Comparing this to English, a command is like a word, and an opcode is like a sentence. For those that don't know, an opcode is something simple, such as: \n\n \n\n There are a couple things that you should know about Opcodes. \n\n \n\n Firstly, there is always an address and/or a register involved in an opcode, as well as the obvious command. An address is in Hex, which is short for Hexadecimal. Hexadecimal is a numbering system with base 16. It's like the Decimal numbering system, which has a base of ten. \n\n \n\n Think about it this way. Our normal numbering system is decimal, which, as I said above, is base 10. This means that we can not have a \"10\" in one column, rather, it is placed in two. In Hexadecimal, you CAN have a 10 in one column--you can have all the way up to 15 in one column. But you may be wondering about that fact that 1 and 0 don't fit in one column still. \n\n \n\n Calm down, though. In hexadecimal, the decimal 10 is replaced by A, the decimal 11 is replaced by B, and so forth up to F, which stands for 16. After that, it becomes 10, then 11, up until 1F, and then it starts over at 20, and so forth. A way to translate between these two, is to click on \"Start\" at the bottom left corner of your screen, then click the \"Run\" button, and type in \"calc\". Next, click on view, and click on \"Scientific\", so that your calculator nearly doubles in size, with many new functions (unless of course, it was already in \"Scientific\" mode). Next, click on the numbering system that your original number is in. e.g Click on \"Hex\" if you want to put 6AF0 into Decimal. Next, type in your number, and then click on the system that you want to translate to. Voila, you have your number translated! \n\n \n\n Also, every address has an opcode and a number of bytes. The number of bytes corresponds to what the opcode is, as every command takes up a certain number of bytes. I know how many bytes some of the very common functions take up, but if you want to know the number of bytes that each command takes up, you'll have to rely on someone else... preferably \n\n \n\n Lastly, something very handy is to \"comment\" something. To comment, all you do is put \"//\" after a command, or a space, and then type whatever you would like. If you don't type the \"//\" after a command or space, then the computer will think that you're typing a command. \n\n \n\n Now, on to what each command does... \n\n \n\n --------------- \n\n III.a JMP \n\n --------------- \n\n \n\n The JMP command is one of the most commonly used commands (around as common as the MOV command, which we will get to next). However, you don't see \"JMP\" nearly as much as you see \"MOV\" in opcodes and scripts, because there are many variations to the JMP command. There are way too many to list, but some are listed below. \n\n \n\n JMP: Always jump to \n\n JE/JZ: Jump to if equal \n\n JNE/JNZ: Jump to if not equal \n\n JA: Jump to if Above \n\n JG: Jump to if Greater \n\n JNA: Jump to if not Above \n\n JNG: Jump to if not Greater \n\n JB: Jump to if Below \n\n JL: Jump to if Lower \n\n JNB: Jump to if not Below \n\n JNL: Jump to if not Lower \n\n JAE: Jump to if Above or Equal \n\n JGE: Jump to if Greater or Equal \n\n JNAE: Jump to if not Above or Equal (i.e. JB) \n\n JNGE: Jump to if not greater than or Equal (i.e. JL) \n\n \n\n And you get the picture. Now this must seem confusing. \"Jump to if greater\", or JG is one of the Conditional Jumps. A conditional jump is as its name implies, it jumps when a certain condition is met. Usually, there is a \"CMP\" or compare function above it--more on that later. That's pretty much it for JMP. On to... \n\n \n\n --------------- \n\n III.b MOV \n\n --------------- \n\n \n\n Now, as you read above, the MOV command is one of the most widely used commands, because it is one of the most versatile. An example of MOV is below. \n\n \n\n There are a couple things that you should know about Opcodes.Firstly, there is always an address and/or a register involved in an opcode, as well as the obvious command. An address is in Hex, which is short for Hexadecimal. Hexadecimal is a numbering system with base 16. It's like the Decimal numbering system, which has a base of ten.Think about it this way. Our normal numbering system is decimal, which, as I said above, is base 10. This means that we can not have a \"10\" in one column, rather, it is placed in two. In Hexadecimal, you CAN have a 10 in one column--you can have all the way up to 15 in one column. But you may be wondering about that fact that 1 and 0 don't fit in one column still.Calm down, though. In hexadecimal, the decimal 10 is replaced by A, the decimal 11 is replaced by B, and so forth up to F, which stands for 16. After that, it becomes 10, then 11, up until 1F, and then it starts over at 20, and so forth. A way to translate between these two, is to click on \"Start\" at the bottom left corner of your screen, then click the \"Run\" button, and type in \"calc\". Next, click on view, and click on \"Scientific\", so that your calculator nearly doubles in size, with many new functions (unless of course, it was already in \"Scientific\" mode). Next, click on the numbering system that your original number is in. e.g Click on \"Hex\" if you want to put 6AF0 into Decimal. Next, type in your number, and then click on the system that you want to translate to. Voila, you have your number translated!Also, every address has an opcode and a number of bytes. The number of bytes corresponds to what the opcode is, as every command takes up a certain number of bytes. I know how many bytes some of the very common functions take up, but if you want to know the number of bytes that each command takes up, you'll have to rely on someone else... preferably Google ! =)Lastly, something very handy is to \"comment\" something. To comment, all you do is put \"//\" after a command, or a space, and then type whatever you would like. If you don't type the \"//\" after a command or space, then the computer will think that you're typing a command.Now, on to what each command does...---------------III.a JMP---------------The JMP command is one of the most commonly used commands (around as common as the MOV command, which we will get to next). However, you don't see \"JMP\" nearly as much as you see \"MOV\" in opcodes and scripts, because there are many variations to the JMP command. There are way too many to list, but some are listed below.JMP: Always jump toJE/JZ: Jump to if equalJNE/JNZ: Jump to if not equalJA: Jump to if AboveJG: Jump to if GreaterJNA: Jump to if not AboveJNG: Jump to if not GreaterJB: Jump to if BelowJL: Jump to if LowerJNB: Jump to if not BelowJNL: Jump to if not LowerJAE: Jump to if Above or EqualJGE: Jump to if Greater or EqualJNAE: Jump to if not Above or Equal (i.e. JB)JNGE: Jump to if not greater than or Equal (i.e. JL)And you get the picture. Now this must seem confusing. \"Jump to if greater\", or JG is one of the Conditional Jumps. A conditional jump is as its name implies, it jumps when a certain condition is met. Usually, there is a \"CMP\" or compare function above it--more on that later. That's pretty much it for JMP. On to...---------------III.b MOV---------------Now, as you read above, the MOV command is one of the most widely used commands, because it is one of the most versatile. An example of MOV is below. \n\n \n\n What this means is \"move the address that is stored at ebx into eax\". Notice that there is a comma that seperates the two registers, but no space. It may seem a bit confusing at first, but it is really simple. Here is a better explanation. \n\n \n\n \"Mov\" stands for \"move\". A register by itself means \"the address stored within that register\". So basically, \"Move, the address stored in ebx, into the address of eax\", which will overwrite whatever was in eax before, and completely erase its existance. =D What you could relate this to is copying what is in ebx, and pasting it into eax. \n\n \n\n Another form of mov is below. \n\n \n\n \n\n \n\n This means \"move the VALUE of ebx into the address that is stored within eax\". Simply put, having the [brackets] around a register or address means the value of what is in the register or address. \n\n \n\n However, something that will not work is below. \n\n \n\n \n\n \n\n WILL NOT WORK. REPEAT: THE CODE ABOVE WILL NOT WORK. You can not, repeat CAN NOT move the value of one thing into the value of another thing. But don't take this the wrong way--you can move the value of one thing indirectly into another thing. ;) Refer to the code below. \n\n \n\n \n\n push eax //Push eax onto the stack--we'll cover this later \n\n mov eax,[0100200A] //Move the value of 0100200A into eax \n\n mov [ebx],eax //Move eax (which is the value of 0100200A) into the value of ebx \n\n pop eax //Pop eax from the stack--once again, we'll cover this later \n\n \n\n \n\n I believe that covers it for the MOV function. Onto... \n\n \n\n --------------- \n\n III.c Push and Pop + The Stack \n\n --------------- \n\n \n\n You saw above how I used the Push and Pop commands. But wait, I'm psychic... I can read your mind! \n\n \n\n \n\n What does push and pop do? And what is the stack? \n\n \n\n \n\n Ok, well as you saw above, after the \"Push\", I commented: \n\n \n\n \n\n \n\n This is basically just putting eax onto the stack. The Pop eax is basically taking eax out of the stack. A very, VERY good explanation of the stack was written by Skyone, from CEF, and I just couldn't live with myself if I didn't allow you the pleasure of learning about it the way I did. ;) \n\n \n\n \n\n The stack is used to give a variable a blank value, and use it for storage. This about it like this: You have a piece of paper that you are doing your homework on, but then your friend calls you to tell you that you need to call Phil, where his number is 555-6405. You panic, with nothing else to write on, you write it on your homework sheet. After you hang up from talking to your friend, you now have time to find your phone book so you can write down Phil's number. After writing Phil's number in the phone book, you erase it from your homework, call Phil, and continue on with the homework. \n\n \n\n To push a value on to the stack is to \"write down Phil's number on the homework.\" To pop it is to \"transfer the number to a phone book, then erase it from the homework.\" \n\n \n\n \n\n Next up... \n\n \n\n --------------- \n\n III.d Alloc/Label/RegisterSymbol \n\n --------------- \n\n \n\n I like to classify Auto Assembler scripts two ways. \n\n \n\n 1) The simple changing of an address \n\n \n\n This is simply something like the code below. \n\n \n\n \n\n \n\n All it really is doing is changing the opcode of the address 00ABC123. \n\n \n\n But then there are very complicated scripts, much like the scripts for dICE or pID00. (I'm not gonna put one here, because it isn't really necessary to your learning. \n\n \n\n In the very complicated scripts, at the top you will see things (note how I didn't use usually--in a complicated script there will be the functions \"alloc\", \"label\", and sometimes \"registersymbol\". \n\n \n\n ```````````` \n\n Label \n\n ```````````` \n\n \n\n I believe the \"label\" function is the most important of the three. What it does is allows the variable that you \"label\" to be used in your script, like below. \n\n \n\n \n\n \n\n There are a few things to note in this script. First, this script is missing the \"alloc\" functions, which I'll get into after this one. \n\n \n\n Next, if you understand why I chose the label that corresponds to the \"jne\", then you're doing well. \n\n \n\n Note that I use all of the labels that are defined in my script, otherwise it would not compile. \n\n \n\n ```````````` \n\n Alloc \n\n ```````````` \n\n \n\n Now, the \"alloc\" function. What it does is allocates (hence, alloc, allocate) X amount of memory to your purpose. Now, this memory isn't just any old memory, this is unused memory that you can overwrite without running into problems. Now, as I said, it allocates X amount of memory. X is a variable that is a certain number of bytes. 1024 bytes, or one kb (kilobyte) is usually enough for what you're trying to accomplish. Now that we know about the alloc function, let me demonstrate to you how to use it--and for now, let us just build upon what we have so far. \n\n \n\n \n\n \n\n because those are already defined in Cheat Engine's \"dictionary,\" as we'll call it. \n\n \n\n ```````````` \n\n RegisterSymbol \n\n ```````````` \n\n \n\n Lastly, the function \"registersymbol\". What this does, is allows you to add the symbol that you register to your Cheat Table. Note, you still have to allocate memory for it. Let's try this in our script. \n\n \n\n \n\n \n\n \n\n ```````````` \n\n Counterparts \n\n \n\n ```````````` \n\n \n\n Now, the last part of this mini-section: the counterparts. \n\n \n\n There are two things that you can do with an Auto Assembler script. Firstly, you can inject something. Secondly, you can add it to your Cheat Table. If you decide that you want to add it to your cheat table (which is how most scripts are nowadays), then you need an enable and disable section of your code, like below. \n\n \n\n \n\n \n\n Now, as you noticed, there is nothing in the Disable section--but not for long! ;) \n\n \n\n What you want to accomplish in the DISABLE section of your code, is to undo whatever you did in the ENABLE section. \n\n \n\n How you do this is to undo the allocating, and the registering of symbols. Now, I feel a question coming on... \n\n \n\n \n\n How do you do that? \n\n \n\n \n\n Simple, my friend. Via the dealloc, and unregister symbol functions! Oh wait, another question, \n\n \n\n \"What about label?\" you ask? \n\n \n\n Well, there is nothing to undo label. =) That means that n the DISABLE section, you drop almost half of the code from the beginning section! =) \n\n \n\n So why don't we add what we've learned to the script? \n\n \n\n \n\n \n\n Oh hey there... another question. \n\n \n\n \n\n Why didn't you put the \"1024\"? \n\n \n\n \n\n Well since the computer knows that you allocated 1024 bytes to AutoAssembler (let's just use this as an example), you only need to dealloc AutoAssembler, and it knows to deallocate the whole 1024 bytes that were allocated to AutoAssembler. (Sorry if this is a bit vague) \n\n \n\n --------------- \n\n III.e Call and Ret \n\n --------------- \n\n \n\n The Call function is very similar to the JMP function. The only difference is that it has a counterpart to get back to where it was before. A simple script utilizing these two functions is below. \n\n \n\n \n\n mov [0100579C],10 //Move 10 into the value of the address \n\n cmp [0100579C],0 //Compare it to 0 \n\n call NameGoesHere //Call, or JMP to NameGoesHere \n\n jmp 01002FF5 \n\n \n\n NameGoesHere: \n\n dec [0100579C] //Decrease the value of the address \n\n cmp [0100579C],0 //Compare it to Zero \n\n jne NameGoesHere //If it's not equal, jump back to the beginning of \n\n //NameGoesHere, otherwise continue \n\n ret //Go back to the code before, right after the call function \n\n \n\n \n\n --------------- \n\n III.f Others \n\n --------------- \n\n \n\n Now, obviously, there are many, many other functions in Auto Assembler, or else it would be a VERY limited language. \n\n \n\n I'll go ahead and define as many as I can. (Oh boy...) \n\n \n\n ````` \n\n Nop \n\n ````` \n\n Nop: I mentioned this earlier. This means \"No Operation\", and it basically cancels out what was there before it. \n\n \n\n ````` \n\n Inc/Dec \n\n ````` \n\n \n\n Inc: Increase by one. This increases the value of the register or addres by one. Used as below. \n\n \n\n \n\n \n\n Dec: Decrease by one. Virtually the same as Inc. \n\n \n\n ````` \n\n Add/Sub \n\n ````` \n\n \n\n Add: Addition. Used as the script below. \n\n \n\n \n\n add eax,02 //Add 2 to eax, and store the result in eax \n\n \n\n \n\n Sub: Subtraction. Used like add. \n\n \n\n ````` \n\n Lea \n\n ````` \n\n This is a bit confusing, but here goes. Look at the script below. \n\n \n\n \n\n \n\n If you couldn't tell, [eax+DEF] is a pointer. LEA is taking the address that is being pointed at by [eax+DEF] and placing it (the address being pointed at) into ebx. \n\n \n\n ````` \n\n And/Or/Xor \n\n ````` \n\n Ok, I haven't the slightest clue what \"xor\" means in English--many websites say something along the lines of... \n\n \n\n \n\n I assume you understand how these logical operator behave. \n\n \n\n \n\n If someone could define XOR in English for me, I would be most indebted. However, I need no help explaining how they work in Assembly. ;) \n\n \n\n First off, they all have the same syntax as the add, and sub commands--as in below. \n\n \n\n \n\n \n\n In which eax and ebx can be anything. But no, it cannot be \"my mom\". -.-; \n\n \n\n Back to the script. To process this, (yes I know we're not computers...) we have to first give the two registers values. How about we give eax the value of 12, and ebx the value of 27. Next, we change them to binary--the one's and zero's language. =O Is that a question? \n\n \n\n \n\n But I do I change it from decimal to binary? \n\n \n\n \n\n Simple my friend, just load up your good ol' friend the calculator, select decimal and type in your number, then click the binary! Something to note, the calculator does not allow you to put decimals, it simply rounds then changes to binary. \n\n \n\n I come up with: \n\n \n\n \n\n \n\n Ok, now you remember back in Elementary school when we lined up our numbers to do arithmetic? Well let's do that here. \n\n \n\n \n\n \n\n Now, the AND instruction will give a 1 if both of the numbers are 1, otherwise it will give a zero. So let's check it out on this problem. \n\n \n\n \n\n and eax,ebx \n\n \n\n EAX = 01100 (added the zero just to make it easier) \n\n EBX = 11011 \n\n ----------- \n\n 01000 \n\n \n\n \n\n And now we change 01000 to decimal, and we get 8, which is stored into EAX. \n\n \n\n Next, the OR function. Let's use our same scenario, just for the sake of ease. \n\n \n\n \n\n \n\n Now, what the OR function does is the oppositte of the AND function. If both digits are 0, then it will produce a 0, otherwise it will produce a one. \n\n \n\n \n\n \n\n We change 11111 to decimal, and we get 31, which is stored into EAX. \n\n \n\n Lastly, the XOR function. Once again, let's use the same scenario. \n\n \n\n \n\n \n\n Ok, now the XOR function will return 0 if both digits have the same value, otherwise it will return a one. \n\n \n\n \n\n \n\n We translate that to 23, and so 23 is stored into EAX. By the way, when writing a script/code/whavever, you don't need to inclue the EAX = BlahBlahBlah, I was just using it to show you how it worked. \n\n \n\n ````` \n\n Well that's about all you need to know for commands! (Man that was long...) Onto the next section... \n\n \n\n ------------------------------ \n\n IV. Array of Bytes \n\n ------------------------------ \n\n \n\n Ok, picture this. You've gotten your script and your addresses and you start hacking. All's well. until... OH NO! A PATCH! But don't fret. Now you don't have to worry about waiting for other people to post the new addresses! \n\n \n\n \n\n I did? I don't recall doing that... \n\n \n\n \n\n You didn't?! \n\n \n\n Oh, you don't know how. \n\n \n\n Alrighty, then, I'll tell you, my good friend. \n\n \n\n 1) Load up your Engine and attatch it to the game you are hacking. \n\n \n\n 2) Click on \"Add Address Manually\", which is above the right side of your Cheat Table. \n\n \n\n 3) Click on the box next to what says \"Address\", and type in the Addresses of whos AOB's you want to get. \n\n \n\n 4) Click on the drop-down-arrow next to what says \"Type\" and choose Array of Byte. \n\n \n\n 5) Type in 8 as the number (or Nr.) of bytes. \n\n \n\n 6) Click ok. =) \n\n \n\n Ok, now you have the Array of Bytes for your address. But how about after the patch? \n\n \n\n 1) Load up your Engine and attatch it to the game that you want to hack. \n\n \n\n 2) Around the top of the middle area of the Engine should be a section of scanning. Click on the drop-down-box by \"Value Type\" then choose Array of Bytes. \n\n \n\n 3) Now, type (or paste if you want, from a Notepad doccument), the Array of Bytes into the Value section. \n\n \n\n 4) Click first scan, and an address should pop up. If an address doesn't pop up, take a few bytes (the two letter/number segments) off of the end, and then search again. \n\n \n\n Ok, you've got the address... now what do you do with it? Take the script that you want to convert--let's just use the v.38 Maplestory God Mode script. \n\n \n\n \n\n \n\n So you have the new address. Delete the \"6803EC\" in the Enable and Disable sections, and then paste your address. MAKE SURE THAT YOU LEAVE THE COLON ( : ) THERE. \n\n \n\n Well, that's it for the Array of Bytes... \n\n \n\n ------------------------------ \n\n V. Conclusion \n\n ------------------------------ \n\n \n\n ...and that's pretty much it for the Auto Assembler tutorial! Hey wait, do I sense a question? \n\n \n\n \n\n Was it really that easy? That's it? No more tricks or anything like that? \n\n \n\n \n\n Nope, that really was it! Once again, I shall quote the creator of Cheat Engine... \n\n \n\n \"Most people think that ASM is really hard, but in fact, it's really quite simple.\" ~Dark Byte himself \n\n \n\n However, I have a mini-tut after this on writing a script, so stay tuned, folks! You don't need to read the \"Writing a Script\" tutorial, as it is only Bonus, although I highly recommend it. \n\n \n\n ------------------------------ \n\n VI. Credits/Acknowledgements \n\n ------------------------------ \n\n \n\n There are a couple acknowledgements I would like to give, before giving the credits. \n\n \n\n First, and foremost, Wizet, for creating Maplestory that I got so in to hacking. ; ) \n\n \n\n Second, Dark Byte, for creating the base of our hacking today, and for creating the Tutorial for Cheat Engine. Hey, we all have to start somewhere! \n\n \n\n Third, Sponge and Labyrnth for helping me with my scripts. \n\n \n\n and Fourth, the creators of all the guides that I got my information from. \n\n \n\n Thank you! \n\n \n\n `````````` \n\n Credits \n\n `````````` \n\n \n\n Note, that these are not in any order. \n\n \n\n Scrbly's Tutorial on CodeInjection and AutoAssembler \n\n \n\n Idogear's post on Basic Assembly \n\n \n\n TheSorc3r3r's tutorial on Beginning Assembly Language \n\n \n\n Skyone's Tutorial on Basic Assembly \n\n \n\n M3KillU's tutorial on Array of Bytes \n\n \n\n Renkokuken's Post on Register Sets \n\n \n\n Vrunk's Tutorial on Allocated Memory \n\n \n\n Dark Byte's Guide on Basic Assembler \n\n \n\n Dark Byte's Guide on the registersymbol/unregistersymbol functions \n\n \n\n Zhoul's \"There's always more than 1 way to skin a cat\" \n\n \n\n Dark Byte's \"Auto assembler scripts in cheat tables\" \n\n \n\n ------------------------------ \n\n Bonus. Writing a Script \n\n ------------------------------ \n\n \n\n So you've read the tutorial, and you understand it fully, but you still want more. I understand, as I felt like that once--unfortunately I don't believe there were any tutorials on writing scripts when I needed them. \n\n \n\n Nope, that really was it! Once again, I shall quote the creator of Cheat Engine...\"Most people think that ASM is really hard, but in fact, it's really quite simple.\" ~Dark Byte himselfHowever, I have a mini-tut after this on writing a script, so stay tuned, folks! You don't need to read the \"Writing a Script\" tutorial, as it is only Bonus, although I highly recommend it.------------------------------VI. Credits/Acknowledgements------------------------------There are a couple acknowledgements I would like to give, before giving the credits.First, and foremost, Wizet, for creating Maplestory that I got so in to hacking. ; )Second, Dark Byte, for creating the base of our hacking today, and for creating the Tutorial for Cheat Engine. Hey, we all have to start somewhere!Third, Sponge and Labyrnth for helping me with my scripts.and Fourth, the creators of all the guides that I got my information from.Thank you!``````````Credits``````````Note, that these are not in any order.------------------------------Bonus. Writing a Script------------------------------So you've read the tutorial, and you understand it fully, but you still want more. I understand, as I felt like that once--unfortunately I don't believe there were any tutorials on writing scripts when I needed them. \n\n \n\n Remember this script from before? Well let's turn it into a full script, using a lot of what we've learned. \n\n \n\n \n\n \n\n Something that you NEED for a script, is an address in the actual memory of the program that you're hacking. However, this can't be just any random address, or something could happen that you don't want to happen (crash, maybe). This address has to be related to your cause. \n\n \n\n But why do we need an address? Well as I said before, the alloc function allocates UNUSED MEMORY, in the program to your function. Because this is UNUSED, the program does nothing to access this, and therefore, you have to MAKE IT access this. \n\n \n\n There are a couple crucial things when messing with addresses. First, you MUST use the same ammount of bytes as the original opcode used. How do we tell the number of bytes in an opcode? Simple. Look between the address and the opcode and there should be a bunch of segments of 2 letter/number combinations. These are called the Array of Bytes. \n\n \n\n Something very helpful when meeting this need is the function \"nop\". As I explained earlier, it means \"no operation\". All it does is take up a byte. Meaning, if you don't use up all of the bytes, then you can fill in the remaining bytes with 'nop's. \n\n \n\n There are 3 scenarios you can encounter when filling in bytes. I have already described one, in which your code is smaller than the original code. Another of the last two scenarios is when you have exactly the same ammount of bytes as the original opcode, in which all is fine. \n\n \n\n But the last of the scenarios is a bit confusing. This is the scenario in which your code has more bytes than the original opcode. Now, what you have to do has overwrite the NEXT address's opcode with your code, and do so forth until you have enough bytes. \n\n \n\n Why don't we play with Minesweeper? I wrote a code a little while back while I was learning about writing scripts (I still am, but that was when I knew less). \n\n \n\n \n\n [enable] \n\n alloc(WhatNowMinesweeper,256) //Allocating... \n\n alloc(ChiliDog,4) \n\n label(ReturnHere) \n\n registersymbol(ChiliDog) //Registering... \n\n \n\n ChiliDog: \n\n dd 0 //Just FYI, this is telling it that ChiliDog's value starts out at 0 \n\n \n\n 01002FF5: //This is the address that writes to the time on MineSweeper \n\n jmp WhatNowMinesweeper //I rewrote the opcode to tell it to jmp to my \n\n //script \n\n nop //I fill in the last byte \n\n ReturnHere: //I'll tell you about this later \n\n \n\n WhatNowMinesweeper: //My actual code \n\n push eax //Save eax, we could have trouble if we don't do this \n\n mov eax,[ChiliDog] //Move the value of ChiliDog into eax \n\n mov [0100579C],eax //Move eax, which is the value of ChiliDog, into the \n\n //time \n\n pop eax //Take eax out, because we're done editing it \n\n jmp ReturnHere //Jmp to ReturnHere, I'll explain this later \n\n \n\n [disable] \n\n dealloc(WhatNowMinesweeper) //Deallocate the memory \n\n dealloc(ChiliDog) \n\n unregistersymbol(ChiliDog) //Unregister the symbol \n\n \n\n 01002FF5: //The address that we modified to jmp to my code \n\n inc [0100579C] //The original opcode, to prevent a crash \n\n \n\n \n\n Now, first thing's first. I told you that I would tell you about the \"ReturnHere\" thing, and so I shall. Just so you know, a program processes what it is told to do in one opcode, then moves on to the next opcode, and so on. It's pretty much like a never ending cycle. However, if we make a dead end, i.e. if the code has no where else to go after the code, then the program will most likely crash. Therefore, we redirect it out back right after the end of the address that we changed, and therefore the code has a place to go--and we don't crash! =D \n\n \n\n And that's pretty much it on writing a script. Please, feel free to ask questions, and to comment on whether you liked it or not. =) \n\n\n\nLast edited by samuri25404 on Fri Apr 04, 2008 6:38 pm; edited 3 times in total"
    },
    {
        "link": "https://forum.cheatengine.org/viewtopic.php?t=570083",
        "document": "So if you're here, it's likely because you've been trying out new cheat tables for new games, and \n\n instead of addresses and pointers you see scripts everywhere. You check these scripts, think \n\n \"WTF do these ancient runes mean\", but marvel at the black magic they hold (or some crap like that). \n\n I'm going to teach you what these scripts do, why they're used so often nowadays, and how to make \n\n them yourself. First, I think that a brief history of the stages/techniques used in game hacking \n\n is in order so you know we do this the way we do. \n\n \n\n This tutorial assumes that you have at least a basic understanding of cheat engine. \n\n If you don't know how to find and edit stuff in games at all yet, go somewhere else first. \n\n \n\n \n\n \n\n \n\n The first and most basic type of game hacking most people are familiar with is static RAM editing. \n\n You find an address and whatever tool you're using keeps resetting it to a certain value very quickly \n\n to \"lock\" it there. The Gameshark for the Gameboy and the Action Replay for the SNES worked like this. \n\n These codes were generally short and simple. For example the code to always have the cape in \n\n Super Mario World for the SNES is 7E001902. \n\n \n\n We can break this down into...\n• 7E: Bank of memory to work on. 7E is the RAM bank.\n• 0019: The memory address to edit. This is the SNES so there's not that many possible addresses in RAM!\n• 02: The value to set it to (in this case the cape). The basic idea of just having a single address to edit every time applies on the PC too, but is usually only \n\n useful in very old and/or custom-engine games. Cave Story and Nethack, for example, are PC games that \n\n still use static addresses for the player data. The main downside to this is that if a game doesn't \n\n load it's data into the exact same places each run, then you'll have to rescan every time you play. \n\n \n\n \n\n \n\n \n\n As systems and games got more complex, they stopped holding the same things in the exact same memory \n\n addresses every single time in order to account for varying numbers of players and entities and monsters \n\n and rules in effect. Since the memory locations were shifting around, pointers are used to keep track \n\n of what exists where. This is what most people will be familiar with as more advanced cheating, because \n\n you can use certain methods/tools to find out the pointer paths and then lock/change the final address. \n\n \n\n But even though pointers tend to work after a game has been restarted multiple times, this shares a \n\n downside with just locking the address manually (since that's all that's being done). On the PC, tools \n\n like Cheat Engine can't really \"lock\" an address. What they do is inject/overwrite it with your chosen \n\n value multiple times a second. In many cases this is enough, but if, for example, your character only \n\n has 100 max HP and you take an attack of 115 damage... in most cases you still die. This is because \n\n the game's logic is running much faster than CE can reset the value, so the game realizes that you \n\n died in that split second. Obviously something other than RAM locking is needed to get around this. \n\n \n\n \n\n \n\n \n\n So, given the above example, how would somebody stop dying if they're dealt more damage than they have \n\n health? The code that deals damage in the first place should be edited. This was the idea behind \n\n the old Game Genie devices for the NES, SNES, and such. They edited the ROM reads instead of RAM, \n\n to change some data around to make the game run differently. After all, you don't need to keep \n\n finding and locking your money amount if you edit the game's code so that your money is never \n\n taken away when you buy something! \n\n \n\n \"But Rydian, if this is so much more powerful, why did all the Game Genie codes suck ass? If they could make \n\n us invincible or anything they wanted why did they keep making each apple picked up worth 5 apples instead?\" \n\n This boils down to two big flaws in the original Game Genie's idea and implementation.\n• Without any way to debug/trace what games were doing, making your own codes as a customer is a \n\n shot in the dark. Edit random bytes and see what happens, keep the few positive things as codes, \n\n discard all the crashy/negative things.\n• The Game Genie's codes were encrypted, and it wasn't until a few years later that people would \n\n publicly make converters to allow you to tell the Game Genie to edit arbitrary ROM reads. These two things combined made it so that the only good/targeted codes were from Galoob itself \n\n (or whoever was doing the distribution of the device at the time). Thankfully that's not the case with \n\n the PC. There's all sorts of debugging, tracing, and logging tools available, in fact Cheat Engine \n\n actually has it's own debugger and tons of other tools (that are hidden by default) that are \n\n specifically geared towards making cheats. \n\n \n\n \n\n \n\n \n\n For this example I'm going to be using the original version of Cave Story for the PC (which is freeware, \n\n not to be confused with Cave Story+ or the Wii/3DS releases). \n\n Download it here, and there's a link to the translation patch too. \n\n \n\n The first thing you'll want to do is to start a new game, and get used to the awkward-as-hell controls. \n\n Then you want to launch+attach Cheat Engine and do the usual bit with scanning for the RAM, in this \n\n case we want to find health. Change it to make sure you found the right value. \n\n \n\n \n\n \n\n Next you want to right-click that table entry, and choose \"Find What Writes To This Address\". \n\n That will bring up a new window that logs any bits of code that change that address. Go back to the \n\n game and get hit or something a few times and you'll see one or more entries show up in the list. \n\n \n\n \n\n \n\n Once you see a few things show up, hit the \"stop\" button so the logging stops. Click the entry that \n\n comes up when you get hit (each different type of effect on the health will usually have it's own \n\n entry and they're numbered by how often they happened), then click that \"Show Disassembler\" button \n\n on the right to open up the Memory Viewer window, which is where the magic is. This is a big window, \n\n but right now we're only concerned with the top half of it. Scroll up a bit so the targeted line \n\n is more or less centered. \n\n \n\n \n\n \n\n What we see right there is the actual assembly that makes up the running game. It doesn't matter \n\n which language a game is written in or which engine it runs on. Anything that runs is assembly \n\n one way or the other. For example you don't run C++ code itself, you put C++ code through the \n\n compiler, which turns it into assembly (more or less). Even interpreted languages like Javascript \n\n get turned into assembly when they run. So if you can edit assembly in RAM, then you can edit any \n\n program's behavior, no matter what language it was written in. \n\n \n\n At this point, I suggest you go look at some basic x86 assembly tutorials, or at least a newbie \n\n instruction list, but I will run over some of the very basics you need to know in this instance. \n\n \n\n That \"mov\" instruction that's highlighted is what takes the new calculated health amount and sets \n\n our health address to it. If you look at the bottom of the assembly view, you'll see \"copy memory\", \n\n which describes the \"mov\" command. Any time you have an operation/line highlighted, that little \n\n box will show you what it stands for. \n\n \n\n The syntax is generally (operation) (destination),(source). So for the mov command, it's moving \n\n whatever's in register cx (part of ecx) into memory address 0049E6CC. Sort of like \n\n $currenthealth = $calculatedhealth; in a more modern language. \n\n And the command above that is a subtraction. \n\n \n\n You'll also see things like \"eax\" and \"ecx\" everywhere. These are the x86 registers. You can, \n\n for this type of work, think of a register as the simplest form of a variable there is. It's \n\n actually physical memory housed inside the CPU itself. \n\n \n\n \n\n \n\n So in this case we can see that there's math done to determine the damage, then the game moves \n\n the new health into the current health. So if we want to stop taking damage, we can edit either \n\n of these. If we remove the subtraction, your health is never lowered. If we remove the mov right \n\n after it, then even though the game determines what your new health be, it never \n\n becomes that value. In this case we'll focus on the subtraction. \n\n \n\n The simplest kind of edit we can do is to make one of the operations simply not happen. To do this, \n\n we generally replace the bytes that make up that operation with the bytes that stand for \"do nothing\". \n\n In x86 the \"no operation\" (nop or noop) byte is 90 (in hex). Cheat Engine, being geared for game \n\n cheating, actually has a quick function to do that, which we'll use just for example. \n\n \n\n Right-click the \"sub\" line (right above the targeted mov line) and choose \"Replace With Code That \n\n Does Nothing\". Hit enter for the default on the prompt, and you should see the change. \n\n \n\n \n\n \n\n And when you go back into the game, you shouldn't take any damage from enemies anymore. You can have \n\n 3 max HP and take 5 damage from the spikes in the starting area, and nothing happens. Yay! \n\n \n\n But that was just a quick example to show you the context. You'll rarely be doing that normally, \n\n except for testing. So in the Memory Viewer window again, right-click the edited code and choose \n\n \"Restore with original code\", because we're going to do something else. \n\n \n\n \n\n \n\n \n\n So instead of right-clicking that \"sub\" line and using a built-in function to remove it, we want to write \n\n a script that focuses on that section of code. Highlight the \"sub\" command and his CTRL+A (or go to \n\n Tools - Auto Assemble). In the new window that comes up, go to Template - Cheat Table Framework Code and \n\n then Template - Code Injection (and hit okay on the default). \n\n \n\n This should make Cheat Engine fill in the Auto Assembly window with something that looks like this, \n\n which is the basic framework you need to customize the game's code. I've marked out, in a basic sense, \n\n which each segment does. \n\n \n\n \n\n \n\n So you can see, for this example, the \"originalcode\" section is what we want to edit. It put in the \n\n original code for us automatically, but we can do whatever we want. For now though, what you want to \n\n do is hit File - Assign To Current Cheat Table, then close the existing window. This is important, \n\n do NOT hit the \"execute\" button. Assign it to the cheat table, then re-open it from there, and the \n\n \"execute\" button will be replaced with \"ok\" (which just saves the script). \n\n \n\n Now that the script is saved on the cheat table and we can edit it on and off (by toggling/locking it \n\n like a normal cheat), feel free to replace or modify the original code. For example change the \"sub\" \n\n into an \"add\", or simply comment it out (//thisisacomment), and when you enable the script Cheat Engine \n\n will interpret what you typed (assuming no syntax errors) and make whatever edits you intend for it to. \n\n \n\n The way this works is that Cheat Engine will overwrite the original code with a jump to some new code, \n\n and then include whatever code you want, which then jumps back at the end. This means that you can \n\n insert new code as well, so if you wanted to change the math or logic being done, you generally have \n\n enough room to write a small little assembly routine there to do whatever, so have fun with it. \n\n \n\n \n\n \n\n \n\n \n\n Note: this section assumes that you've messed around with assembly editing in Cheat Engine enough \n\n to have a basic grasp of the concept and know what you're doing. \n\n \n\n So making a script that edits the game code is a great way to get around moving memory addresses. \n\n You don't need to scan for pointers or watch changing addresses when you edit the game code to control \n\n things. But... newer games (especially ones written in .NET and such) don't even load their code in \n\n the same order each time! So we need a way to find where certain code snippets are, and then \n\n reference/edit them. We do this with AOBscans. AOB stands for \"Array of Bytes\", and is just a list of \n\n values in RAM. \n\n \n\n You write a script in the Auto Assembler window (CTRL+A in the memory browser, add it to the table \n\n like before and edit it from there), and here's a very basic AOB script for editing some assembly. \n\n \n\n So if you're here, it's likely because you've been trying out new cheat tables for new games, andinstead of addresses and pointers you see scripts everywhere. You check these scripts, think\"WTF do these ancient runes mean\", but marvel at the black magic they hold (or some crap like that).I'm going to teach you what these scripts do, why they're used so often nowadays, and how to makethem yourself. First, I think that a brief history of the stages/techniques used in game hackingis in order so you knowwe do this the way we do.This tutorial assumes that you have at least a basic understanding of cheat engine.If you don't know how to find and edit stuff in games at all yet, go somewhere else first.The first and most basic type of game hacking most people are familiar with is static RAM editing.You find an address and whatever tool you're using keeps resetting it to a certain value very quicklyto \"lock\" it there. The Gameshark for the Gameboy and the Action Replay for the SNES worked like this.These codes were generally short and simple. For example the code to always have the cape inSuper Mario World for the SNES is 7E001902.We can break this down into...The basic idea of just having a single address to edit every time applies on the PC too, but is usually onlyuseful in very old and/or custom-engine games. Cave Story and Nethack, for example, are PC games thatstill use static addresses for the player data. The main downside to this is that if a game doesn'tload it's data into the exact same places each run, then you'll have to rescan every time you play.As systems and games got more complex, they stopped holding the same things in the exact same memoryaddresses every single time in order to account for varying numbers of players and entities and monstersand rules in effect. Since the memory locations were shifting around, pointers are used to keep trackof what exists where. This is what most people will be familiar with as more advanced cheating, becauseyou can use certain methods/tools to find out the pointer paths and then lock/change the final address.But even though pointers tend to work after a game has been restarted multiple times, this shares adownside with just locking the address manually (since that's all that's being done). On the PC, toolslike Cheat Engine can't really \"lock\" an address. What they do is inject/overwrite it with your chosenvalue multiple times a second. In many cases this is enough, but if, for example, your character onlyhas 100 max HP and you take an attack of 115 damage... in most cases you still die. This is becausethe game's logic is running much faster than CE can reset the value, so the game realizes that youdied in that split second. Obviously something other than RAM locking is needed to get around this.So, given the above example, how would somebody stop dying if they're dealt more damage than they havehealth? The code that deals damage in the first place should be edited. This was the idea behindthe old Game Genie devices for the NES, SNES, and such. They edited the ROM reads instead of RAM,to change some data around to make the game run differently. After all, you don't need to keepfinding and locking your money amount if you edit the game's code so that your money is nevertaken away when you buy something!This boils down to two big flaws in the original Game Genie's idea and implementation.These two things combined made it so that the only good/targeted codes were from Galoob itself(or whoever was doing the distribution of the device at the time). Thankfully that's not the case withthe PC. There's all sorts of debugging, tracing, and logging tools available, in fact Cheat Engineactually has it's own debugger and tons of other tools (that are hidden by default) that arespecifically geared towards making cheats.For this example I'm going to be using the original version of Cave Story for the PC (which is freeware,not to be confused with Cave Story+ or the Wii/3DS releases).The first thing you'll want to do is to start a new game, and get used to the awkward-as-hell controls.Then you want to launch+attach Cheat Engine and do the usual bit with scanning for the RAM, in thiscase we want to find health. Change it to make sure you found the right value.Next you want to right-click that table entry, and choose \"Find What Writes To This Address\".That will bring up a new window that logs any bits of code that change that address. Go back to thegame and get hit or something a few times and you'll see one or more entries show up in the list.Once you see a few things show up, hit the \"stop\" button so the logging stops. Click the entry thatcomes up when you get hit (each different type of effect on the health will usually have it's ownentry and they're numbered by how often they happened), then click that \"Show Disassembler\" buttonon the right to open up the Memory Viewer window, which is where the magic is. This is a big window,but right now we're only concerned with the top half of it. Scroll up a bit so the targeted lineis more or less centered.What we see right there is the actual assembly that makes up the running game. It doesn't matterwhich language a game is written in or which engine it runs on. Anything that runs is assemblyone way or the other. For example you don't run C++ code itself, you put C++ code through thecompiler, which turns it into assembly (more or less). Even interpreted languages like Javascriptget turned into assembly when they run. So if you can edit assembly in RAM, then you can edit anyprogram's behavior, no matter what language it was written in.At this point, I suggest you go look at some basic x86 assembly tutorials, or at least a newbieinstruction list, but I will run over some of the very basics you need to know in this instance.That \"mov\" instruction that's highlighted is what takes the new calculated health amount and setsour health address to it. If you look at the bottom of the assembly view, you'll see \"copy memory\",which describes the \"mov\" command. Any time you have an operation/line highlighted, that littlebox will show you what it stands for.The syntax is generally (operation) (destination),(source). So for the mov command, it's movingwhatever's in register cx (part of ecx) into memory address 0049E6CC. Sort of like$currenthealth = $calculatedhealth; in a more modern language.And the command above that is a subtraction.You'll also see things like \"eax\" and \"ecx\" everywhere. These are the x86 registers. You can,for this type of work, think of a register as the simplest form of a variable there is. It'sactually physical memory housed inside the CPU itself.So in this case we can see that there's math done to determine the damage, then the game movesthe new health into the current health. So if we want to stop taking damage, we can edit eitherof these. If we remove the subtraction, your health is never lowered. If we remove the mov rightafter it, then even though the game determines what your new healthbe, it neverbecomes that value. In this case we'll focus on the subtraction.The simplest kind of edit we can do is to make one of the operations simply not happen. To do this,we generally replace the bytes that make up that operation with the bytes that stand for \"do nothing\".In x86 the \"no operation\" (nop or noop) byte is 90 (in hex). Cheat Engine, being geared for gamecheating, actually has a quick function to do that, which we'll use just for example.Right-click the \"sub\" line (right above the targeted mov line) and choose \"Replace With Code ThatDoes Nothing\". Hit enter for the default on the prompt, and you should see the change.And when you go back into the game, you shouldn't take any damage from enemies anymore. You can have3 max HP and take 5 damage from the spikes in the starting area, and nothing happens. Yay!But that was just a quick example to show you the context. You'll rarely be doing that normally,except for testing. So in the Memory Viewer window again, right-click the edited code and choose\"Restore with original code\", because we're going to do something else.So instead of right-clicking that \"sub\" line and using a built-in function to remove it, we want to writea script that focuses on that section of code. Highlight the \"sub\" command and his CTRL+A (or go toTools - Auto Assemble). In the new window that comes up, go to Template - Cheat Table Framework Code andthen Template - Code Injection (and hit okay on the default).This should make Cheat Engine fill in the Auto Assembly window with something that looks like this,which is the basic framework you need to customize the game's code. I've marked out, in a basic sense,which each segment does.So you can see, for this example, the \"originalcode\" section is what we want to edit. It put in theoriginal code for us automatically, but we can do whatever we want. For now though, what you want todo is hit File - Assign To Current Cheat Table, then close the existing window.Assign it to the cheat table, then re-open it from there, and the\"execute\" button will be replaced with \"ok\" (which just saves the script).Now that the script is saved on the cheat table and we can edit it on and off (by toggling/locking itlike a normal cheat), feel free to replace or modify the original code. For example change the \"sub\"into an \"add\", or simply comment it out (//thisisacomment), and when you enable the script Cheat Enginewill interpret what you typed (assuming no syntax errors) and make whatever edits you intend for it to.The way this works is that Cheat Engine will overwrite the original code with a jump to some new code,and then include whatever code you want, which then jumps back at the end. This means that you caninsert new code as well, so if you wanted to change the math or logic being done, you generally haveenough room to write a small little assembly routine there to do whatever, so have fun with it.Note: this section assumes that you've messed around with assembly editing in Cheat Engine enoughto have a basic grasp of the concept and know what you're doing.So making a script that edits the game code is a great way to get around moving memory addresses.You don't need to scan for pointers or watch changing addresses when you edit the game code to controlthings. But... newer games (especially ones written in .NET and such) don't even load their code inthe same order each time! So we need a way to find where certain code snippets are, and thenreference/edit them. We do this with AOBscans. AOB stands for \"Array of Bytes\", and is just a list ofvalues in RAM.You write a script in the Auto Assembler window (CTRL+A in the memory browser, add it to the tablelike before and edit it from there), and here's a very basic AOB script for editing some assembly. \n\n \n\n In this specific case, it's a \"No Damage\" code for Cave Story. The first thing it does is scan for \n\n certain bytes in RAM in a certain order (using aobscan to find a unique sequence of bytes, known here \n\n as a signature). Then it applies a label (_nodamage) to that found address (sort of like a variable). \n\n Then it acts on that address. In this case I'm using the \"db\" command, which writes specific bytes. \n\n In the \"enable\" section it's writing the bytes \"90 90\", which is nop, remember? Then the disable \n\n section writes the original bytes back (2B C8, which was the sub). \n\n \n\n Instead of using \"db\", you could just write out your assembly normally, but with this kind of simple \n\n replacement you can't add more code than was already there, you're only limited to the number of bytes \n\n that already exist, so I usually just use db to keep it simple and remind myself of the limits. \n\n \n\n \"But wait, what the hell are the bytes at the beginning of the scripts?\" \n\n Well... it's the snippet of code we want to find/target. \n\n \n\n \n\n \n\n If you start with the line of code that you want to edit and then select it and a few more instructions \n\n after it, you can right-click and Copy To Clipboard - Bytes Only (No Addresses). This will copy the \n\n string of bytes for you to paste right into the template (and make sure to change the [DISABLE] section \n\n to put the right new bytes back too). \n\n \n\n So there's a basic and direct AOB assembly replacement script for making minor changes. \n\n \n\n It's very important to remember that when you're manually overwriting bytes like this (without \n\n injection) that the replacement and disable bytes need to account for eachother. \n\n \n\n For example this below code handles it properly... \n\n In this specific case, it's a \"No Damage\" code for Cave Story. The first thing it does is scan forcertain bytes in RAM in a certain order (using aobscan to find a unique sequence of bytes, known hereas a signature). Then it applies a label (_nodamage) to that found address (sort of like a variable).Then it acts on that address. In this case I'm using the \"db\" command, which writes specific bytes.In the \"enable\" section it's writing the bytes \"90 90\", which is nop, remember? Then the disablesection writes the original bytes back (2B C8, which was the sub).Instead of using \"db\", you could just write out your assembly normally, but with this kind of simplereplacement you can't add more code than was already there, you're only limited to the number of bytesthat already exist, so I usually just use db to keep it simple and remind myself of the limits.Well... it's the snippet of code we want to find/target.If you start with the line of code that you want to edit and then select it and a few more instructionsafter it, you can right-click and Copy To Clipboard - Bytes Only (No Addresses). This will copy thestring of bytes for you to paste right into the template (and make sure to change the [DISABLE] sectionto put the right new bytes back too).So there's a basic and direct AOB assembly replacement script for making minor changes.It's very important to remember thatthat the replacement and disable bytes need to account for eachother. \n\n However this below code it just asking for crashes... \n\n \n\n That's because it's not fixing all of the edited bytes, it's not putting things back the way they were. It's \n\n also the reason that stuff is overwritten with 90 (nop, no operation), to keep the same number of bytes \n\n modified. For inserting more code, you'll want to use either the code injection (step 3) or AOB injection \n\n (step 7) template, in which CE allocates your own little code space and shuffles things around for you. \n\n \n\n \n\n \n\n \n\n \n\n So let's say you've made some aobscans for various games. Some of them work just fine, but others stop \n\n enabling after a restart of the game or something. This just means that you need to find better \n\n signatures (the sequence of bytes to search for). The two main things you can do to improve your \n\n signatures is to use wildcards to avoid changing addresses/offsets, and to shift your signature up or \n\n down more and then refer to it with an offset in order to target a more unique string of data. \n\n \n\n For the wildcards, let's take our Cave Story example aobscan and look at it closer. \n\n \n\n \n\n \n\n The bytes I've circled in red are the kinds of things you usually don't want to reference directly. \n\n They're memory addresses that may change from one run to another. (This isn't the case with Cave Story \n\n specifically, but tons of games do this). So in order to avoid referencing that data directly, we'll \n\n just use wildcards. We replace the that can change with a question joe. \n\n \n\n So... \n\n That's because it's not fixing all of the edited bytes, it's not putting things back the way they were. It'salso the reason that stuff is overwritten with 90 (nop, no operation), to keep the same number of bytesmodified. For inserting more code, you'll want to use either the code injection (step 3) or AOB injection(step 7) template, in which CE allocates your own little code space and shuffles things around for you.So let's say you've made some aobscans for various games. Some of them work just fine, but others stopenabling after a restart of the game or something. This just means that you need to find bettersignatures (the sequence of bytes to search for). The two main things you can do to improve yoursignatures is to use wildcards to avoid changing addresses/offsets, and to shift your signature up ordown more and then refer to it with an offset in order to target a more unique string of data.For the wildcards, let's take our Cave Story example aobscan and look at it closer.The bytes I've circled in red are the kinds of things you usually don't want to reference directly.They're memory addresses that may change from one run to another. (This isn't the case with Cave Storyspecifically, but tons of games do this). So in order to avoid referencing that data directly, we'lljust use wildcards. We replace thethat can change with a question joe.So... \n\n \n\n Generally anything that's a small offset (like +2 or +216) isn't going to change, it's the huge things \n\n (four bytes or so) that do change and should be replaced with wildcards. But beware, the more wildcards \n\n you have, the less unique your signature is, so you may need to add more bytes to search for at the \n\n end if you have a lot of wildcards. \n\n \n\n Sometimes you may not be able to find a good signature directly after the code you want to edit. Sometimes \n\n you have the line you want to edit, followed by 4-6 functions that deal with random addresses and numbers \n\n that keep changing. That's okay, you can search ahead of the function you want to work off of too! \n\n \n\n So here's the same code, but using both techniques. \n\n \n\n \n\n \n\n \n\n \n\n \n\n Now that you know the basics of how to edit game code and what an AOB and such is, you can take a much \n\n shorter method to get custom scripts up and running. Make sure that your version of Cheat Engine is at least \n\n 6.4, that's when this feature was included. When you target some code and open up the AA window, this time \n\n go to Template - Cheat Table Framework and then Template - AOB Injection. \n\n \n\n \n\n \n\n It'll ask which address you want the jump on, defaulting to what was highlighted when you opened the AA \n\n window, and this is usually what you want anyways. \n\n \n\n \n\n \n\n Next it'll ask you to name the symbol. Make sure you give it an actual unique name for the table. \n\n \n\n \n\n \n\n Next CE make take a few moments because it'll try to develop and AOB scan that's unique to the code you \n\n targeted, but once it's done it'll present you with a nice AOB injection template. \n\n \n\n \n\n \n\n As before, the orange box indicates the copy of the original game code that will be injected for you to change. \n\n \n\n \n\n \n\n \n\n Once you go off to start making your own things for games, you'll likely run into situations where games use \n\n floats (floating-point numbers) for things. In theory you could use the same sort of techniques here, but the \n\n thing is that a lot of the time the instruction that writes the final value to memory is FSTP. This stands for \n\n loatingpoint oreand op (more or less). This unfortunately means that not only does \n\n the instruction modify the target value, but it also modifies the stack . Stack modification is very important \n\n to keep track of, because an unbalanced stack can cause all sorts of problems or outright crashes in games. \n\n \n\n This basically means that the safest thing to do when you're dealing with floating-point instructions is to avoid \n\n removing them. Unless you're quite familiar with assembly and the stack and such, what you'll want to do is \n\n overwrite the results instead. For example let's say that this is our target function here, an fstp. \n\n \n\n \n\n \n\n Since we need to insert our own code to handle this type of thing, you'll want to use the AOB injection \n\n template like you were shown earlier in this guide. Once you do that, look at the code section as usual... \n\n \n\n \n\n \n\n Now, in order to overwrite the results of the FSTP into the target address, we'll simply add our own instruction \n\n there which will set it to the value we specifically want. The easiest way to do this is with a mov. \n\n \n\n \n\n \n\n And with that, the code shouldn't cause odd problems or crash the game anymore. Generally anything that's a small offset (like +2 or +216) isn't going to change, it's the huge things(four bytes or so) that do change and should be replaced with wildcards. But beware, the more wildcardsyou have, the less unique your signature is, so you may need to add more bytes to search for at theend if you have a lot of wildcards.Sometimes you may not be able to find a good signature directly after the code you want to edit. Sometimesyou have the line you want to edit, followed by 4-6 functions that deal with random addresses and numbersthat keep changing. That's okay, you can search ahead of the function you want to work off of too!So here's the same code, but using both techniques.Now that you know the basics of how to edit game code and what an AOB and such is, you can take a muchshorter method to get custom scripts up and running. Make sure that your version of Cheat Engine is at least6.4, that's when this feature was included. When you target some code and open up the AA window, this timego to Template - Cheat Table Framework and then Template - AOB Injection.It'll ask which address you want the jump on, defaulting to what was highlighted when you opened the AAwindow, and this is usually what you want anyways.Next it'll ask you to name the symbol. Make sure you give it an actual unique name for the table.Next CE make take a few moments because it'll try to develop and AOB scan that's unique to the code youtargeted, but once it's done it'll present you with a nice AOB injection template.As before, the orange box indicates the copy of the original game code that will be injected for you to change.Once you go off to start making your own things for games, you'll likely run into situations where games usefloats (floating-point numbers) for things. In theory you could use the same sort of techniques here, but thething is that a lot of the time the instruction that writes the final value to memory is FSTP. This stands forloatingpointoreandop (more or less). This unfortunately means that not only doesthe instruction modify the target value,. Stack modification is very importantto keep track of, because an unbalanced stack can cause all sorts of problems or outright crashes in games.This basically means that the safest thing to do when you're dealing with floating-point instructions is to avoidremoving them. Unless you're quite familiar with assembly and the stack and such, what you'll want to do isoverwrite the results instead. For example let's say that this is our target function here, an fstp.Since we need to insert our own code to handle this type of thing, you'll want to use the AOB injectiontemplate like you were shown earlier in this guide. Once you do that, look at the code section as usual...Now, in order to overwrite the results of the FSTP into the target address, we'll simply add our own instructionthere which will set it to the value we specifically want. The easiest way to do this is with a mov.And with that, the code shouldn't cause odd problems or crash the game anymore. \n\n\n\nLast edited by Rydian on Thu Oct 29, 2015 7:30 am; edited 5 times in total"
    },
    {
        "link": "https://cheatengine.fandom.com/wiki/Tutorials:Auto_Assembler:Injection_basic",
        "document": "So in most games to really do any thing cool, you will want or need to use code injection.\n\nNow there are different types of injection, the most common methods are DLL injection and assembly injection. We will be going over assembly injection.\n\n\n\n Any game will work but I will be using Windows Solitaire.\n\nFirst you will need to find the score.\n\nIf unsure how to find values see: Finding values - Integers\n\nAfter you have found the address of the score then we can find the injection point. Where this is depends on what we want to do so in Windows Solitaire the score decreases over timer, lets stop that.\n\nFirst we need to find the code we want, so select the address of the score in the address list, right-click and select find out what writes to this address.\n\nA message window will tell you this will attach the debugger of Cheat Engine to the current process. Continue?. click the yes button.\n\nNow we wait for the score to decrease.\n\nThen you should see some code come up in the debugger window, with the number of times it has written to the address:\n\nOnce some code comes up you can click the stop button.\n\nThen click on the line of code, this should enable the buttons, now click the show disassembler button.\n\nThis will bring up the disassembler / memory view form.\n\nWith the disassembler / memory view form open, on the highlighted line of code right-click and select find out what addresses this instruction accesses.\n\nNow let it run for a while, make some moves, and see what comes up. In most games this is a good thing to do because many functions deal with multiple addresses.\n\nSo we are looking to see that this only accesses the score address.\n\nSo if only the address we want (the score) comes up then we can close the window, click the form close button or click the stop button then it becomes a close button and just click it again.\n\nNow on the memory view form menu select tools then select auto assemble, or just press Ctrl+A.\n\nNow here is where you could just NOP the line of code, but we will setup a script to enable and disable the injection.\n\nThe easiest way to do this is with templates, so on the form's menu click template then click cheat table framework code.\n\nThis will give you the base code needed to add a script to the table.\n\nSo now on the form's menu click template then click full injection.\n\nYou will be prompted for the address if you haven't changed the selected code in the memory view form, then click the ok button.\n\nThis will give you the base code needed for a full injection.\n\nBut we don't need a full injection for this so we can remove some code.\n\nSo now we need to add the injection code, we'll just NOP the instruction out. If we look at the injection information (the commented out code at the bottom). We can see that the instruction is 5 bytes long, so we need 5 NOPs to disable the score decrease function.\n\nSo we need some thing like this:\n\nNow we can add this to the table, so on the form's menu click file then click assign to current cheat table.\n\nThis should create a memory record in the tables address list.\n\nNow we are ready to test the code.\n\nWith the memory view form visible, looking at the injection line, enable the script (click the box or with it selected press the space bar).\n\nYou should see a red X in the enabler box, 5 Nops, and the same code as before the injection on the next line, if all went as planed.\n\nNow check that the score doesn't get decreased.\n\nNow disable the script, same steps as enabling, and the red X should be gone and the original code should be injected back.\n\nNow check that the score gets decreased.\n\n\n\n And that's that basics of assembly injection with Cheat Engine."
    },
    {
        "link": "https://wiki.cheatengine.org/index.php?title=Tutorials:Auto_Assembler:Injection_basic",
        "document": "So in most games to really do any thing cool, you will want or need to use code injection.\n\nNow there are different types of injection, the most common methods are DLL injection and assembly injection. We will be going over assembly injection.\n\n\n\n Any game will work but I will be using Windows Solitaire.\n\nFirst you will need to find the score.\n\nIf unsure how to find values see: Finding values - Integers\n\nAfter you have found the address of the score then we can find the injection point. Where this is depends on what we want to do so in Windows Solitaire the score decreases over timer, lets stop that.\n\nFirst we need to find the code we want, so select the address of the score in the address list, right-click and select find out what writes to this address.\n\nA message window will tell you this will attach the debugger of Cheat Engine to the current process. Continue?. click the yes button.\n\nNow we wait for the score to decrease.\n\nThen you should see some code come up in the debugger window, with the number of times it has written to the address:\n\nOnce some code comes up you can click the stop button.\n\nThen click on the line of code, this should enable the buttons, now click the show disassembler button.\n\nThis will bring up the disassembler / memory view form.\n\nWith the disassembler / memory view form open, on the highlighted line of code right-click and select find out what addresses this instruction accesses.\n\nNow let it run for a while, make some moves, and see what comes up. In most games this is a good thing to do because many functions deal with multiple addresses.\n\nSo we are looking to see that this only accesses the score address.\n\nSo if only the address we want (the score) comes up then we can close the window, click the form close button or click the stop button then it becomes a close button and just click it again.\n\nNow on the memory view form menu select tools then select auto assemble, or just press Ctrl+A.\n\nNow here is where you could just NOP the line of code, but we will setup a script to enable and disable the injection.\n\nThe easiest way to do this is with templates, so on the form's menu click template then click cheat table framework code.\n\nThis will give you the base code needed to add a script to the table.\n\nSo now on the form's menu click template then click full injection.\n\nYou will be prompted for the address if you haven't changed the selected code in the memory view form, then click the ok button.\n\nThis will give you the base code needed for a full injection.\n\nBut we don't need a full injection for this so we can remove some code.\n\nSo now we need to add the injection code, we'll just NOP the instruction out. If we look at the injection information (the commented out code at the bottom). We can see that the instruction is 5 bytes long, so we need 5 NOPs to disable the score decrease function.\n\nSo we need some thing like this:\n\nNow we can add this to the table, so on the form's menu click file then click assign to current cheat table.\n\nThis should create a memory record in the tables address list.\n\nNow we are ready to test the code.\n\nWith the memory view form visible, looking at the injection line, enable the script (click the box or with it selected press the space bar).\n\nYou should see a red X in the enabler box, 5 Nops, and the same code as before the injection on the next line, if all went as planed.\n\nNow check that the score doesn't get decreased.\n\nNow disable the script, same steps as enabling, and the red X should be gone and the original code should be injected back.\n\nNow check that the score gets decreased.\n\n\n\n And that's that basics of assembly injection with Cheat Engine."
    },
    {
        "link": "http://cons.mit.edu/fa18/x86-64-architecture-guide.html",
        "document": "For the code-generation project, we expect your compiler to produce simple assembly code. We shall expose you to a subset of the x86-64 platform.\n\nConsider the following Decaf program:\n\nFor the code generation phase of the compiler project, you are encouraged to output simple and inefficient (but correct!) assembly code. This assembly code can assign every variable and temporary to a location on the current stack frame. Every expression value will be loaded from the stack, manipulated using the registers %r10 and %r11, and then the result will be written back to the stack, ready to be used in another expression. Compiling the above decaf code using this simple scheme might look like this:\n\n\n\nWe shall dissect this assembly listing carefully and relate it to the Decaf code. Note that this is not the only possible assembly of the program; it only serves as an illustration of some techniques you can use in this project phase.\n• This is the standard boilerplate code for a function definition. The first line creates a label which names the entry point of the function. The following instruction sets up the stack frame. After the function is done with its actual work, the instruction restores the stack frame for the caller, and passes control back to the caller.\n• Notice that one of the operands to is a static arithmetic expression. Such expressions are evaluated by the assembler and converted into constants in the final output.\n• Enter first saves the callers frame (base) pointer (%rbp) unto the stack. Then it sets the frame pointer to the stack pointer (%rsp) to set the current frame pointer. Enter next allocates N bytes (where N is the left operand) of stack space to be used for locals and temporaries of the stack frame. It does this by subtracting N from %rsp (remember that the stack grows downward toward address 0). This space is allocated after the caller's frame (base) pointer is saved to the stack.\n• The movq instruction moves the 1st argument (passed in %rdi) to its place on the stack. The argument occupies the first stack position (stack entries are 8 bytes) after the base pointer (%rbp). 0(%rbp) stores the previous frame's base pointer.\n• The purpose of is to add 3 to its argument, and return the result. The first movq instruction fetches the argument from the stack and places it in the temporay register %r10. The next instruction increments the value in by the literal or immediate value 3. Note that immediate values are always prefixed by a ‘$’.\n• The second movq instruction stores the value of the addition back onto the stack at the second position of the frame (after the saved %rbp).\n• According to the calling convention, a function must place its return value in the register, so has succeeded in returning by moving the value of the x + 3 expression into %rax.\n• he directive makes the symbol accessible to modules other than this one. This is important, because the C run-time library, which we link against, expects to find a procedure to call at program startup.\n• The instruction allocates space for 6 quadwords on the stack: one for a local variable and 5 for temporaries.\n• We call the function, which reads an integer from standard input and returns it. The function takes no arguments.\n• The integer is returned in , and we store the value of the method call expression onto the stack.\n• Now we are ready to call We start by loading the temporary that stored the return value of into %rdi. According to the calling convention defined in the Linux ABI (see below), %rbi is used to pass the first argument. Then we call foo.\n• Once returns, we store the return value, stored in %rax, onto the stack at location -16(%rbp).\n• Next, we perform the assigment to y of the return value of foo by loading the temporary into %r10 and storing %r10 into the stack location designated for y, -24(%rbp).\n• This sequence demonstrates how a comparison operation might be implemented using only two registers and temporary storage. We begin by loading the values to compare, i.e., y and the literal 15, into registers. This is necessary because the comparison instructions only work on register operands.\n• Then, we perform the actual comparison using the instruction. The result of the comparison is to change the internal flags register.\n• Our aim is to store a boolean value—1 or 0—in a temporary variable as the result of this operation. To set this up, we place the two possible values, 1 and 0, in registers and .\n• Then we use the instruction (read - - , or conditional move if equal) to decide whether our output value should be 0 or 1, based on the flags set by our previous comparison. The instruction puts the result in .\n• Finally, we store the boolean value from to a temporary variable at .\n• This is the standard linearized structure of a conditional statement. We compare a boolean variable to 1, and perform a (jump if equal) instruction which jumps to its target block if the comparison succeeded. If the comparison failed, acts as a no-op.\n• We mark the end of the target block with a label, and jump to it at the end of the fall-through block. Conventionally, such local labels, which do not define functions, are named starting with a period.\n• The block of instructions performs the false (else) block of the if statement.\n• We first load the value of the .what string (see below) into %rdi. Next we load the value of y into %rsi. %rsi is the register designated for the second argument of a function.\n• The third movq instruction is necessary for printf because printf uses a variable list of arguments. We must assign 0 to %rax to let printf know that we are not using SSE registers to pass any of the arguments.\n• After the call, the final move instruction stores the return value of printf onto the stack. Note that the return value is never referenced.\n• At the end of the procedure, we set to 0 to indicate that the program has terminated successfully (used even though the main method is declared to be of type void).\n• These labels point to static strings defined in the program. They are used as arguments to callout functions.\n\nThis handout only mentions a small subset of the rich possibilities provided by the x86-64 instruction set and architecture. For a more complete (but still readable) introduction, consult . Another helpful resource is the\n\nIn the assembly syntax accepted by , register names are always prefixed with . All of these registers are 64 bits wide.\n\nThe register file is as follows:For the code generation phase of the project you will not be performing register allocation. You should use %r10 and %r11 for temporary values that you load from the stack.\n\nEach mnemonic opcode presented here represents a family of instructions. Within each family, there are variants which take different argument types (registers, immediate values, or memory addresses) and/or argument sizes (byte, word, double-word, or quad-word). The former can be distinguished from the prefixes of the arguments, and the latter by an optional one-letter suffix on the mnemonic.\n\nFor example, a instruction which sets the value of the 64-bit register to the immediate value 3 can be written as\n\nImmediate operands are always prefixed by . Un-prefixed operands are treated as memory addresses, and should be avoided since they are confusing.\n\nFor instructions which modify one of their operands, the operand which is modified appears second. This differs from the convention used by Microsoft’s and Borland’s assemblers, which are commonly used on DOS and Windows.\n\nGlobal and local variables are stored on the stack, a region of memory that is typically addressed by offsets from the registers and . Each procedure call results in the creation of a stack frame where the procedure can store local variables and temporary intermediate values for that invocation.The stack is organized as follows:\n\nWe will use the standard Linux function calling convention. The calling convention is defined in detail in We will summarize the calling convention as it applies to decaf.The caller uses registers to pass the first 6 arguments to the callee. Given the arguments in left-to-right order, the order of registers used is: %rdi, %rsi, %rdx, %rcx, %r8, and %r9. Any remaining arguments are passed on the stack in reverse order so that they can be popped off the stack in order.The callee is responsible for perserving the value of registers %rbp %rbx, and %r12-r15, as these registers are owned by the caller. The remaining registers are owned by the callee.\n\nThe callee places its return value in and is responsible for cleaning up its local variables as well as for removing the return address from the stack.\n\nThe , , and instructions make it easy to follow this calling convention.\n\n\n\nSince we follow the standard linux ABI, we can call C functions and library functions using our callout structure. For the purposes of the project we are only going to call printf and get_int_035. When calling printf, we must set the value of register %rax to 0 before issuing the call instruction. This is because printf uses a variable number of arguments and %rax specifies how many SSE registers are used for the arguments. For our purposes the value will always be 0. Since callouts can only return an single integer value, we have provided a function (), which will read a single integer input from the terminal and return its integer value. This function is included in the 6035 static library. We cannot use scanf because it returns the number of items read."
    },
    {
        "link": "https://web.stanford.edu/class/cs107/guide/x86-64.html",
        "document": "x86-64 (also known as just x64 and/or AMD64) is the 64-bit version of the x86/IA32 instruction set. Below is our overview of its features that are relevant to CS107. There is more extensive coverage on these topics in Chapter 3 of the B&O textbook. See also our x86-64 sheet for a compact reference.\n\nThe table below lists the commonly used registers (sixteen general-purpose plus two special). Each register is 64 bits wide; the lower 32-, 16- and 8-bit portions are selectable by a pseudo-register name. Some registers are designated for a certain purpose, such as being used as the stack pointer or for the return value from a function. Other registers are all-purpose, but have a conventional use depending on whether caller-owned or callee-owned. If the function calls , we refer to as the caller and as the callee. For example, the registers used for the first 6 arguments and return value are all callee-owned. The callee can freely use those registers, overwriting existing values without taking any precautions. If holds a value the caller wants to retain, the caller must copy the value to a \"safe\" location before making a call. The callee-owned registers are ideal for scratch/temporary use by the callee. In contrast, if the callee intends to use a caller-owned register, it must first preserve its value and restore it before exiting the call. The caller-owned registers are used for local state of the caller that needs to preserved across further function calls.\n\nTrue to its CISC nature, x86-64 supports a variety of addressing modes. An addressing mode is an expression that calculates an address in memory to be read/written to. These expressions are used as the source or destination for a instruction and other instructions that access memory. The code below demonstrates how to write the immediate value 1 to various memory locations in an example of each of the available addressing modes:\n\nA note about instruction suffixes: many instructions have a suffix ( , , , or ) which indicates the bitwidth of the operation (1, 2, 4, or 8 bytes, respectively). The suffix is often elided when the bitwidth can be determined from the operands. For example, if the destination register is , it must be 4 bytes, if it must be 2 bytes, and would be 1 byte. A few instructions such as and have two suffixes: the first is for the source operand, the second for the destination. For example, moves a 1-byte source value to a 4-byte destination.\n\nWhen the destination is a sub-register, only those specific bytes in the sub-register are written with one broad exception: a 32-bit instruction zeroes the high order 32 bits of the destination register.\n\nBy far most frequent instruction you'll encounter is in one of its its multi-faceted variants. Mov copies a value from source to destination. The source can be an immediate value, a register, or a memory location (expressed using one of the addressing mode expressions from above). The destination is either a register or a memory location. At most one of source or destination can be memory. The suffix (b, w, l, or q) indicates how many bytes are being copied (1, 2, 4, or 8 respectively). For the (load effective address) instruction, the source operand is a memory location (using an addressing mode from above) and it copies the calculated source address to destination. Note that does not dereference the source address, it simply calculates its location. This means is nothing more than an arithmetic operation and commonly used to calculate the value of simple linear combinations that have nothing to do with memory locations!\n\nThe instruction copies the same number of bytes from one location to another. In situations where the move is copying a smaller bitwidth to a larger, the and variants are used to specify how to fill the additional bytes, either sign-extend or zero-fill.\n\nA special case to note is that a to write a 32-bit value into a register also zeroes the upper 32 bits of the register by default, i.e does an implicit zero-extend to bitwidth q. This explains use of instructions such as that look odd/redundant, but are, in fact, being used to zero-extend from 32 to 64. Given this default behavior, there is no need for an explicit instruction. To instead sign-extend from 32-bit to 64-bit, there is an instruction.\n\nThe instruction is a specialized that operates on . This no-operand instruction does sign-extension in-place on ; source bitwidth is l, destination bitwidth is q.\n\nThe binary operations are generally expressed in a two-operand form where the second operand is both a source to the operation and the destination. The source can be an immediate constant, register, or memory location. The destination must be either register or memory. At most one of source or destination can be memory. The unary operations have one operand which is both source and destination, which can be either register or memory. Many of the arithmetic instructions are used for both signed and unsigned types, i.e. there is not a signed add and unsigned add, the same instruction is used for both. Where needed, the condition codes set by the operation can be used to detect the different kinds of overflow.\n\nBranches and other use of condition codes\n\nThe special register stores a set of boolean flags called the condition codes. Most arithmetic operations update those codes. A conditional jump reads the condition codes to determine whether to take the branch or not. The condition codes include ZF (zero flag), SF (sign flag), OF (overflow flag, signed), and CF (carry flag, unsigned). For example, if the result was zero, the ZF is set, if a operation overflowed (into sign bit), OF is set.\n\nThe general pattern for all branches is to execute a or operation to set the flags followed by a jump instruction variant that reads the flags to determine whether to take the branch or continue on. The operands to a or are immediate, register, or memory location (with at most one memory operand). There are 32 variants of conditional jump, several of which are synonyms. Here are some example branch instructions.\n\nThere are two other families of instructions that read/react to the current condition codes. The instructions set a destination register to 0 or 1 according to the status of condition . The instructions will conditionally execute a move based on whether condition holds. The is a placeholder for any of the conditional variants: , , , , etc.\n\nFor the instruction, the destination must be a single-byte sub-register (e.g. for the low byte of ). For the instructions, both the source and destination must be registers.\n\nThe register is used as the \"stack pointer\"; and are used to add/remove values from the stack. The instruction takes one operand: an immediate, a register, or a memory location. Push decrements and copies the operand to be tompost on the stack. The instruction takes one operand, the destination register. Pop copies the topmost value to destination and increments . It is also valid to directly adjust to add/remove an entire array or a collection of variables with a single operation. Note the stack grows downward (toward lower addresses).\n\nCall/return are used to transfer control between functions. The instruction takes one operand, the address of the function being called. It pushes the return address (current value of , which is the next instruction after the call) onto the stack and then jumps to the address of the function being called. The instruction pops the return address from the stack into , thus resuming at the saved return address.\n\nTo set up for a call, the caller puts the first six arguments into registers , , , , , and (any additional arguments are pushed onto the stack) and then executes the instruction.\n\nWhen callee finishes, it writes the return value (if any) to , cleans up the stack, and use instruction to return control to the caller.\n\nThe target for a branch or call instruction is most typically an absolute address that was determined at compile-time. However there are cases where the target is not known until runtime, such as a statement compiled into a jump table or when invoking a function pointer. For these, the target address is computed and stored in a register and the branch/call variant is used or to read the target address from the specified register.\n\nThe debugger has many features that allow you to trace and debug code at the assembly level. You can print the value in a register by prefixing its name with or use the command to dump the values of all registers:\n\nThe command will print the disassembly for a function by name. The command supports an format which interprets the contents of a memory address as an encoded instruction.\n\nYou can set a breakpoint at a particular assembly instruction by its direct address or offset within a function\n\nYou can advance by instruction (instead of source line) using the and commands."
    },
    {
        "link": "https://cs.virginia.edu/~evans/cs216/guides/x86.html",
        "document": "This guide describes the basics of 32-bit x86 assembly language programming, covering a small but useful subset of the available instructions and assembler directives. There are several different assembly languages for generating x86 machine code. The one we will use in CS216 is the Microsoft Macro Assembler (MASM) assembler. MASM uses the standard Intel syntax for writing x86 assembly code.\n\nThe full x86 instruction set is large and complex (Intel's x86 instruction set manuals comprise over 2900 pages), and we do not cover it all in this guide. For example, there is a 16-bit subset of the x86 instruction set. Using the 16-bit programming model can be quite complex. It has a segmented memory model, more restrictions on register usage, and so on. In this guide, we will limit our attention to more modern aspects of x86 programming, and delve into the instruction set only in enough detail to get a basic feel for x86 programming.\n• Guide to Using Assembly in Visual Studio — a tutorial on building and debugging assembly code in Visual Studio\n\nModern (i.e 386 and beyond) x86 processors have eight 32-bit general purpose registers, as depicted in Figure 1. The register names are mostly historical. For example, used to be called the accumulator since it was used by a number of arithmetic operations, and was known as the counter since it was used to hold a loop index. Whereas most of the registers have lost their special purposes in the modern instruction set, by convention, two are reserved for special purposes — the stack pointer ( ) and the base pointer ( ).\n\nFor the , , , and registers, subsections may be used. For example, the least significant 2 bytes of can be treated as a 16-bit register called . The least significant byte of can be used as a single 8-bit register called , while the most significant byte of can be used as a single 8-bit register called . These names refer to the same physical register. When a two-byte quantity is placed into , the update affects the value of , , and . These sub-registers are mainly hold-overs from older, 16-bit versions of the instruction set. However, they are sometimes convenient when dealing with data that are smaller than 32-bits (e.g. 1-byte ASCII characters).\n\nWhen referring to registers in assembly language, the names are not case-sensitive. For example, the names and refer to the same register.\n\nYou can declare static data regions (analogous to global variables) in x86 assembly using special assembler directives for this purpose. Data declarations should be preceded by thedirective. Following this directive, the directives, andcan be used to declare one, two, and four byte data locations, respectively. Declared locations can be labeled with names for later reference — this is similar to declaring variables by name, but abides by some lower level rules. For example, locations declared in sequence will be located in memory next to one another.\n\nUnlike in high level languages where arrays can have many dimensions and are accessed by indices, arrays in x86 assembly language are simply a number of cells located contiguously in memory. An array can be declared by just listing the values, as in the first example below. Two other common methods used for declaring arrays of data are the DUP directive and the use of string literals. The DUP directive tells the assembler to duplicate an expression a given number of times. For example, 4 DUP(2) is equivalent to 2, 2, 2, 2.\n\nModern x86-compatible processors are capable of addressing up to 2bytes of memory: memory addresses are 32-bits wide. In the examples above, where we used labels to refer to memory regions, these labels are actually replaced by the assembler with 32-bit quantities that specify addresses in memory. In addition to supporting referring to memory regions by labels (i.e. constant values), the x86 provides a flexible scheme for computing and referring to memory addresses: up to two of the 32-bit registers and a 32-bit signed constant can be added together to compute a memory address. One of the registers can be optionally pre-multiplied by 2, 4, or 8.\n\nThe addressing modes can be used with many x86 instructions (we'll describe them in the next section). Here we illustrate some examples using theinstruction that moves data between registers and memory. This instruction has two operands: the first is the destination and the second specifies the source.\n\nSome examples ofinstructions using address computations are:Some examples of invalid address calculations include:\n\nIn general, the intended size of the data item at a given memory address can be inferred from the assembly code instruction in which it is referenced. For example, in all of the above instructions, the size of the memory regions could be inferred from the size of the register operand. When we were loading a 32-bit register, the assembler could infer that the region of memory we were referring to was 4 bytes wide. When we were storing the value of a one byte register to memory, the assembler could infer that we wanted the address to refer to a single byte in memory.\n\nHowever, in some cases the size of a referred-to memory region is ambiguous. Consider the instruction. Should this instruction move the value 2 into the single byte at address? Perhaps it should move the 32-bit integer representation of 2 into the 4-bytes starting at address. Since either is a valid possible interpretation, the assembler must be explicitly directed as to which is correct. The size directives, andserve this purpose, indicating sizes of 1, 2, and 4 bytes respectively.\n\nFor example:Machine instructions generally fall into three categories: data movement, arithmetic/logic, and control-flow. In this section, we will look at important examples of x86 instructions from each category. This section should not be considered an exhaustive list of x86 instructions, but rather a useful subset. For a complete list, see Intel's instruction set reference.\n\nWe use the following notation:— Move (Opcodes: 88, 89, 8A, 8B, 8C, 8E, ...)\n\n— Push stack (Opcodes: FF, 89, 8A, 8B, 8C, 8E, ...)— Pop stack— Load effective address— Integer Addition— Integer Subtraction— Increment, Decrement— Integer Multiplication— Integer Division— Bitwise logical and, or and exclusive or— Bitwise Logical Not\n\n— Negate— Shift Left, Shift RightThe x86 processor maintains an instruction pointer (IP) register that is a 32-bit value indicating the location in memory where the current instruction starts. Normally, it increments to point to the next instruction in memory begins after execution an instruction. The IP register cannot be manipulated directly, but is updated implicitly by provided control flow instructions.\n\nWe use the notation <label> to refer to labeled locations in the program text. Labels can be inserted anywhere in x86 assembly code text by entering a label name followed by a colon. For example,\n\nThe second instruction in this code fragment is labeled. Elsewhere in the code, we can refer to the memory location that this instruction is located at in memory using the more convenient symbolic name. This label is just a convenient way of expressing the location instead of its 32-bit value.\n\n— Conditional Jump— Compare— Subroutine call and returnTo allow separate programmers to share code and develop libraries for use by many programs, and to simplify the use of subroutines in general, programmers typically adopt a common calling convention. The calling convention is a protocol about how to call and return from routines. For example, given a set of calling convention rules, a programmer need not examine the definition of a subroutine to determine how parameters should be passed to that subroutine. Furthermore, given a set of calling convention rules, high-level language compilers can be made to follow the rules, thus allowing hand-coded assembly language routines and high-level language routines to call one another.\n\nIn practice, many calling conventions are possible. We will use the widely used C language calling convention. Following this convention will allow you to write assembly language subroutines that are safely callable from C (and C++) code, and will also enable you to call C library functions from your assembly language code.\n\nThe C calling convention is based heavily on the use of the hardware-supported stack. It is based on the, andinstructions. Subroutine parameters are passed on the stack. Registers are saved on the stack, and local variables used by subroutines are placed in memory on the stack. The vast majority of high-level procedural languages implemented on most processors have used similar calling conventions.\n\nThe calling convention is broken into two sets of rules. The first set of rules is employed by the caller of the subroutine, and the second set of rules is observed by the writer of the subroutine (the callee). It should be emphasized that mistakes in the observance of these rules quickly result in fatal program errors since the stack will be left in an inconsistent state; thus meticulous care should be used when implementing the call convention in your own subroutines.\n\nA good way to visualize the operation of the calling convention is to draw the contents of the nearby region of the stack during subroutine execution. The image above depicts the contents of the stack during the execution of a subroutine with three parameters and three local variables. The cells depicted in the stack are 32-bit wide memory locations, thus the memory addresses of the cells are 4 bytes apart. The first parameter resides at an offset of 8 bytes from the base pointer. Above the parameters on the stack (and below the base pointer), the call instruction placed the return address, thus leading to an extra 4 bytes of offset from the base pointer to the first parameter. When the ret instruction is used to return from the subroutine, it will jump to the return address stored on the stack.\n• Before calling a subroutine, the caller should save the contents of certain registers that are designated caller-saved. The caller-saved registers are EAX, ECX, EDX. Since the called subroutine is allowed to modify these registers, if the caller relies on their values after the subroutine returns, the caller must push the values in these registers onto the stack (so they can be restore after the subroutine returns.\n• To pass parameters to the subroutine, push them onto the stack before the call. The parameters should be pushed in inverted order (i.e. last parameter first). Since the stack grows down, the first parameter will be stored at the lowest address (this inversion of parameters was historically used to allow functions to be passed a variable number of parameters).\n• To call the subroutine, use the instruction. This instruction places the return address on top of the parameters on the stack, and branches to the subroutine code. This invokes the subroutine, which should follow the callee rules below.\n• Remove the parameters from stack. This restores the stack to its state before the call was performed.\n• Restore the contents of caller-saved registers (EAX, ECX, EDX) by popping them off of the stack. The caller can assume that no other registers were modified by the subroutine.\n\nTo make a subrouting call, the caller should:After the subroutine returns (immediately following theinstruction), the caller can expect to find the return value of the subroutine in the register EAX. To restore the machine state, the caller should:The code below shows a function call that follows the caller rules. The caller is calling a function _myFunc that takes three integer parameters. First parameter is in EAX, the second parameter is the constant 216; the third parameter is in memory location var.Note that after the call returns, the caller cleans up the stack using theinstruction. We have 12 bytes (3 parameters * 4 bytes each) on the stack, and the stack grows down. Thus, to get rid of the parameters, we can simply add 12 to the stack pointer.\n\nThe result produced by _myFunc is now available for use in the register EAX. The values of the caller-saved registers (ECX and EDX), may have been changed. If the caller uses them after the call, it would have needed to save them on the stack before the call and restore them after it.\n• Push the value of EBP onto the stack, and then copy the value of ESP into EBP using the following instructions: This initial action maintains the base pointer, EBP. The base pointer is used by convention as a point of reference for finding parameters and local variables on the stack. When a subroutine is executing, the base pointer holds a copy of the stack pointer value from when the subroutine started executing. Parameters and local variables will always be located at known, constant offsets away from the base pointer value. We push the old base pointer value at the beginning of the subroutine so that we can later restore the appropriate base pointer value for the caller when the subroutine returns. Remember, the caller is not expecting the subroutine to change the value of the base pointer. We then move the stack pointer into EBP to obtain our point of reference for accessing parameters and local variables.\n• Next, allocate local variables by making space on the stack. Recall, the stack grows down, so to make space on the top of the stack, the stack pointer should be decremented. The amount by which the stack pointer is decremented depends on the number and size of local variables needed. For example, if 3 local integers (4 bytes each) were required, the stack pointer would need to be decremented by 12 to make space for these local variables (i.e., ). As with parameters, local variables will be located at known offsets from the base pointer.\n• Next, save the values of the callee-saved registers that will be used by the function. To save registers, push them onto the stack. The callee-saved registers are EBX, EDI, and ESI (ESP and EBP will also be preserved by the calling convention, but need not be pushed on the stack during this step).\n• Leave the return value in EAX.\n• Restore the old values of any callee-saved registers (EDI and ESI) that were modified. The register contents are restored by popping them from the stack. The registers should be popped in the inverse order that they were pushed.\n• Deallocate local variables. The obvious way to do this might be to add the appropriate value to the stack pointer (since the space was allocated by subtracting the needed amount from the stack pointer). In practice, a less error-prone way to deallocate the variables is to move the value in the base pointer into the stack pointer: . This works because the base pointer always contains the value that the stack pointer contained immediately prior to the allocation of the local variables.\n• Immediately before returning, restore the caller's base pointer value by popping EBP off the stack. Recall that the first thing we did on entry to the subroutine was to push the base pointer to save its old value.\n• Finally, return to the caller by executing a instruction. This instruction will find and remove the appropriate return address from the stack.\n\nThe definition of the subroutine should adhere to the following rules at the beginning of the subroutine:After these three actions are performed, the body of the subroutine may proceed. When the subroutine is returns, it must follow these steps:Note that the callee's rules fall cleanly into two halves that are basically mirror images of one another. The first half of the rules apply to the beginning of the function, and are commonly said to define the prologue to the function. The latter half of the rules apply to the end of the function, and are thus commonly said to define the epilogue of the function.Here is an example function definition that follows the callee rules:The subroutine prologue performs the standard actions of saving a snapshot of the stack pointer in EBP (the base pointer), allocating local variables by decrementing the stack pointer, and saving register values on the stack.\n\nIn the body of the subroutine we can see the use of the base pointer. Both parameters and local variables are located at constant offsets from the base pointer for the duration of the subroutines execution. In particular, we notice that since parameters were placed onto the stack before the subroutine was called, they are always located below the base pointer (i.e. at higher addresses) on the stack. The first parameter to the subroutine can always be found at memory location EBP + 8, the second at EBP + 12, the third at EBP + 16. Similarly, since local variables are allocated after the base pointer is set, they always reside above the base pointer (i.e. at lower addresses) on the stack. In particular, the first local variable is always located at EBP - 4, the second at EBP - 8, and so on. This conventional use of the base pointer allows us to quickly identify the use of local variables and parameters within a function body.\n\nThe function epilogue is basically a mirror image of the function prologue. The caller's register values are recovered from the stack, the local variables are deallocated by resetting the stack pointer, the caller's base pointer value is recovered, and the ret instruction is used to return to the appropriate code location in the caller.\n\nThese materials are released under a Creative Commons Attribution-Noncommercial-Share Alike 3.0 United States License . We are delighted when people want to use or adapt the course materials we developed, and you are welcome to reuse and adapt these materials for any non-commercial purposes (if you would like to use them for a commercial purpose, please contact David Evans for more information). If you do adapt or use these materials, please include a credit like \"Adapted from materials developed for University of Virginia cs216 by David Evans. This guide was revised for cs216 by David Evans, based on materials originally created by Adam Ferrari many years ago, and since updated by Alan Batson, Mike Lack, and Anita Jones.\" and a link back to this page."
    },
    {
        "link": "https://docs.oracle.com/cd/E19253-01/817-5477/817-5477.pdf",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/asm/comments/1b5c9yl/why_cant_i_find_any_full_fledged_documentation_of",
        "document": "This is probably a stupid misguided question but I am seriously confused. Unlike say, C or C++, I can't find a single site that documents/explains all the operators and registers. Every link i look at, there's just bits and pieces of the assembly language explained. No where seems to fully document everything about the language. It'd be nice if I didn't have to have 4 tabs open just to have a proper reference while learning. What am I missing here?"
    }
]