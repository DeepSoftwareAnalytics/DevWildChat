[
    {
        "link": "https://stackoverflow.com/questions/1538676/uppercasing-first-letter-of-words-using-sed",
        "document": "Use the following sed command for capitalizing the first letter of the each word.\n\nThe switch tells to use extended regular expressions. The instructions to then tell it to \"search and replace\" (the at the beginning) the pattern with the pattern globally, i.e. all instances in every line (that's the modifier at the end). The pattern we're searching for is which is looking for a word boundary ( ) followed by any character ( ). The replacement pattern is , where instructs to make the following text uppercase and is a synonym for , which refers to \"everything that was matched\". In this case, \"everything that was matched\" is just what the matched, as word boundaries are not included in the matches (instead, they are anchors). What matched is just one character, so this is what is upper cased."
    },
    {
        "link": "https://stackoverflow.com/questions/25962929/using-sed-to-capitalize-the-first-letter-of-each-word",
        "document": "Here is the data I want to capitalize:\n\nHere is the script I have written so far to capitalize the first letter of name including initial\n\nIt gives me:\n\nI want to only have:"
    },
    {
        "link": "https://unix.stackexchange.com/questions/631384/using-sed-tr-or-awk-to-capitolise-the-first-letter",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://unix.stackexchange.com/questions/427109/how-can-i-capitalise-the-first-character-after-a-constant-string-in-multiple-fil",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://geeksforgeeks.org/sed-command-in-linux-unix-with-examples",
        "document": "The SED (Stream Editor) command is one of the most powerful tools used during text processing in Linux/Unix systems. The SED command is generally used to perform tasks such as search and replace, text manipulation, and stream editing.\n\nUsing SED, you can easily handle text files without opening them in an editor, and that’s what makes it a perfect choice to edit batch files, manage log files, and perform quick transformations on large files.\n\nIn this guide, we will walk you through the SED command syntax, use cases and most commonly used SED options to help you master this power tool. You’ll also learn how to securely manipulate text, replace strings, delete lines, and automate tasks seamlessly in Linux/Unix environments.\n\nWhat is the Sed Command\n\nThe SED command (Stream Editor) is a text manipulation tool used to perform basic text transformations and advanced operations such as find and replace, text insertion, deletion, and substitution. It is commonly used in bscripts to automate tasks (such as file editing).\n\nThe basic syntax for using the SED command in Linux is:\n• ‘OPTIONS’: These are optional flags that modify the behavior of the sed command.\n• ‘COMMAND’ : This defines the command or sequence of commands to execute on the input file.\n• ‘INPUTFILE’ : One or more input files to be processed.\n\nBelow are some of the most frequently used SED command options, let’s check them out:\n\nHere are some basic SED commands that will help you get started with text manipulation.\n\nConsider the below text file as an input.\n\nReplacing or substituting string: Sed command is mostly used to replace the text in a file. The below simple sed command replaces the word “unix” with “linux” in the file.\n\nHere the “s” specifies the substitution operation. The “/” are delimiters. The “unix” is the search pattern and the “linux” is the replacement string. By default, the sed command replaces the first occurrence of the pattern in each line and it won’t replace the second, third…occurrence in the line.\n\n2. Replacing the nth Occurrence of a Pattern in a Line\n\nTo replace only the nth occurance of a word in a line, use the following syntax:\n\nUse the ‘/1’, ‘/2’ etc. flags to replace the first, second occurrence of a pattern in a line. The below command replaces the second occurrence of the word “unix” with “linux” in a line.\n\n3. Replacing all the Occurrence of the Pattern in a Line\n\nHere, we will use the g flag to replace all the occurances of a pattern in a line. Let’s check out the syntax below:\n\nThe substitute flag /g (global replacement) specifies the sed command to replace all the occurrences of the string in the line.\n\n4. Replacing from nth Occurrence to all Occurrences in a Line\n\nUse the combination of /1, /2 etc and /g to replace all the patterns from the nth occurrence of a pattern in a line. The following sed command replaces the third, fourth, fifth… “unix” word with “linux” word in a line.\n\n5. Parenthesize First Character of Each Word\n\nThis sed example prints the first character of every word in parenthesis.\n\nYou can restrict the sed command to replace the string on a specific line number. An example is\n\nThe above sed command replaces the string only on the third line.\n\nThe /p print flag prints the replaced line twice on the terminal. If a line does not have the search pattern and is not replaced, then the /p prints that line only once.\n\nUse the -n option along with the /p print flag to display only the replaced lines. Here the -n option suppresses the duplicate rows generated by the /p flag and prints the replaced lines only one time.\n\nIf you use -n alone without /p, then the sed does not print anything.\n\nYou can specify a range of line numbers to the sed command for replacing a string.\n\nHere the sed command replaces the lines with range from 1 to 3. Another example is\n\nHere $ indicates the last line in the file. So the sed command replaces the text from second line to last line in the file.\n\nSED command can also be used for deleting lines from a particular file. SED command is used for performing deletion operation without even opening the file\n\n1. To Delete a particular line say n in this example\n\n3. To Delete line from range x to y\n\n4. To Delete from nth to last line\n\nBelow are some of the advanced SED commands that can be used for handling various editing tasks. let’s check them out:\n\nSED supports regular expressions that allows it to handle more complex pattern matching. To enable regular expressions, you need to use -r option.\n\nHere, we have matched any word start with ‘u’ and replacing it with “Linux”. Let’s check this out in the provided syntax below:\n\nYou can use this option to insert any text before or after any specific line. Here’s the syntax provided below:\n\nExample: To insert a new line before line2 in geekfile.txt\n\n1. Ensure to back up your files before applying for the changes. (especially while using -i)\n\n2. Be cautious before using the extended reular expressions to avoid any unintended substitutions.\n\n3. Always test your SED command on sample file first (to avoid unintentional changes).\n\nThe SED command in Linux/Unix is a versatile and powerful tool for automating text editing tasks, from simple find-and-replace operations to more complex pattern matching. Whether you’re working with a single file or need to process multiple files in a script, sed offers an efficient solution for text manipulation.\n\nBy using the above provided examples of basic and advanced, you can easily utilize the full capacity of SED to manipulate and process text files directly.\n\nWhat is the\n\nWhat are examples of\n\nWhat is the correct syntax for using\n\nHow to use\n\nWhat is the purpose of\n\nHow to use SED to replace text in a file?"
    },
    {
        "link": "https://gnu.org/s/gawk/manual/html_node/String-Functions.html",
        "document": "The functions in this section look at or change the text of one or more strings.\n\nunderstands locales (see Where You Are Makes a Difference) and does all string processing in terms of characters, not bytes. This distinction is particularly important to understand for locales where one character may be represented by multiple bytes. Thus, for example, returns the number of characters in a string, and not the number of bytes used to represent those characters. Similarly, works with character indices, and not byte indices.\n\nCAUTION: A number of functions deal with indices into strings. For these functions, the first character of a string is at position (index) one. This is different from C and the languages descended from it, where the first character is at position zero. You need to remember this when doing index calculations, particularly if you are used to C.\n\nIn the following list, optional parameters are enclosed in square brackets ([ ]). Several functions perform string substitution; the full discussion is provided in the description of the function, which comes toward the end, because the list is presented alphabetically.\n\nThose functions that are specific to are marked with a pound sign (‘ ’). They are not available in compatibility mode (see Command-Line Options):\n\nThese two functions are similar in behavior, so they are described together. NOTE: The following description ignores the third argument, , as it requires understanding features that we have not discussed yet. Thus, the discussion here is a deliberate simplification. (We do provide all the details later on; see Sorting Array Values and Indices with for the full story.) Both functions return the number of elements in the array . For , sorts the values of and replaces the indices of the sorted values of with sequential integers starting with one. If the optional array is specified, then is duplicated into . is then sorted, leaving the indices of unchanged. When comparing strings, affects the sorting (see Sorting Array Values and Indices with ). If the array contains subarrays as values (see Arrays of Arrays), they will come last, after all scalar values. Subarrays are not recursively sorted. For example, if the contents of are as follows: results in the following contents of : The function works similarly to ; however, the indices are sorted, instead of the values. Thus, in the previous example, starting with the same initial set of indices and values in , calling ‘ ’ would yield: NOTE: You may not use either or as the second argument to these functions. Attempting to do so produces a fatal error. You may use them as the first argument, but only if providing a second array to use for the actual sorting. You are allowed to use the same array for both the and arguments, but doing so only makes sense if you’re also supplying the third argument.\n\nSearch the target string for matches of the regular expression . If is a string beginning with ‘ ’ or ‘ ’ (short for “global”), then replace all matches of with . Otherwise, treat as a number indicating which match of to replace. Treat numeric values less than one as if they were one. If no is supplied, use . Return the modified string as the result of the function. The original target string is not changed. The returned value is always a string, even if the original was a number or a regexp value. is a general substitution function. Its purpose is to provide more features than the standard and functions. provides an additional feature that is not available in or : the ability to specify components of a regexp in the replacement text. This is done by using parentheses in the regexp to mark the components and then specifying ‘ ’ in the replacement text, where is a digit from 1 to 9. For example: As with , you must type two backslashes in order to get one into the string. In the replacement text, the sequence ‘ ’ represents the entire matched text, as does the character ‘ ’. The following example shows how you can use the third argument to control which match of the regexp should be changed: In this case, is the default target string. returns the new string as its result, which is passed directly to for printing. If the argument is a string that does not begin with ‘ ’ or ‘ ’, or if it is a number that is less than or equal to zero, only one substitution is performed. If is zero, issues a warning message. If does not match , ’s return value is the original unchanged value of . Note that, as mentioned above, the returned value is a string, even if was not. In the replacement string, a backslash before a non-digit character is simply elided. For example, ‘ ’ becomes ‘ ’ in the result. If the final character in the replacement string is a backslash, it is left alone.\n\nReturn the number of characters in . If is a number, the length of the digit string representing that number is returned. For example, is five. By contrast, works out to three. In this example, 15 * 35 = 525, and 525 is then converted to the string , which has three characters. If no argument is supplied, returns the length of . NOTE: In older versions of , the function could be called without any parentheses. Doing so is considered poor practice, although the 2008 POSIX standard explicitly allows it, to support historical practice. For programs to be maximally portable, always supply the parentheses. If is called with a variable that has not been used, forces the variable to be a scalar. Other implementations of leave the variable without a type. (d.c.) Consider: $ -| 0 error→ gawk: fatal: attempt to use scalar `x' as array $ -| 0 If has been specified on the command line, issues a warning about this. With and several other implementations, when given an array argument, the function returns the number of elements in the array. (c.e.) This is less useful than it might seem at first, as the array is not guaranteed to be indexed from one to the number of elements in it. If is provided on the command line (see Command-Line Options), warns that passing an array argument is not portable. If is supplied, using an array argument is a fatal error (see Arrays in ).\n\nSearch for the longest, leftmost substring matched by the regular expression and return the character position (index) at which that substring begins (one, if it starts at the beginning of ). If no match is found, return zero. The argument may be either a regexp constant ( … ) or a string constant ( … ). In the latter case, the string is treated as a regexp to be matched. See Using Dynamic Regexps for a discussion of the difference between the two forms, and the implications for writing your program correctly. The order of the first two arguments is the opposite of most other string functions that work with regular expressions, such as and . It might help to remember that for , the order is the same as for the ‘ ’ operator: ‘ ’. The function sets the predefined variable to the index. It also sets the predefined variable to the length in characters of the matched substring. If no match is found, is set to zero, and to −1. { if ($1 == \"FIND\") regex = $2 else { where = match($0, regex) if (where != 0) print \"Match of\", regex, \"found at\", where, \"in\", $0 } } This program looks for lines that match the regular expression stored in the variable . This regular expression can be changed. If the first word on a line is ‘ ’, is changed to be the second word on that line. Therefore, if given: FIND ru+n My program runs but not very quickly FIND Melvin JF+KM This line is property of Reality Engineering Co. Melvin was here. Match of ru+n found at 12 in My program runs Match of Melvin found at 1 in Melvin was here. If is present, it is cleared, and then the zeroth element of is set to the entire portion of matched by . If contains parentheses, the integer-indexed elements of are set to contain the portion of matching the corresponding parenthesized subexpression. For example: In addition, multidimensional subscripts are available providing the start index and length of each matched subexpression: There may not be subscripts for the start and index for every parenthesized subexpression, because they may not all have matched text; thus, they should be tested for with the operator (see Referring to an Array Element). The argument to is a extension. In compatibility mode (see Command-Line Options), using a third argument is a fatal error.\n\nDivide into pieces (or “fields”) defined by and store the pieces in and the separator strings in the array. The first piece is stored in , the second piece in , and so forth. The third argument, , is a regexp describing the fields in (just as is a regexp describing the fields in input records). It may be either a regexp constant or a string. If is omitted, the value of is used. returns the number of elements created. is the possibly null separator string after . The possibly null leading separator will be in . So a non-null with fields will have separators. A null has no fields or separators. The function splits strings into pieces in a manner similar to the way input lines are split into fields using (see Defining Fields by Content). Before splitting the string, deletes any previously existing elements in the arrays and .\n\nDivide into pieces separated by and store the pieces in and the separator strings in the array. The first piece is stored in , the second piece in , and so forth. The string value of the third argument, , is a regexp describing where to split (much as can be a regexp describing where to split input records). If is omitted, the value of is used. returns the number of elements created. is a extension, with being the separator string between and . If is a single space, then any leading whitespace goes into and any trailing whitespace goes into , where is the return value of (i.e., the number of elements in ). The function splits strings into pieces in the same way that input lines are split into fields. For example: splits the string into three fields using ‘ ’ as the separator. It sets the contents of the array as follows: and sets the contents of the array as follows: The value returned by this call to is three. If is invoked with , then a two-argument call to splits the string using the CSV parsing rules as described in Working With Comma Separated Value Files. With three and four arguments, works as just described. The four-argument call makes no sense, since each element of would simply consist of a string containing a comma. As with input field-splitting, when the value of is , leading and trailing whitespace is ignored in values assigned to the elements of but not in , and the elements are separated by runs of whitespace. Also, as with input field splitting, if is the null string, each individual character in the string is split into its own array element. (c.e.) Additionally, if is a single-character string, that string acts as the separator, even if its value is a regular expression metacharacter. Note, however, that has no effect on the way works. Even though ‘ ’ causes the newline character to also be an input field separator, this does not affect how splits strings. Modern implementations of , including , allow the third argument to be a regexp constant ( … ) as well as a string. (d.c.) The POSIX standard allows this as well. See Using Dynamic Regexps for a discussion of the difference between using a string constant or a regexp constant, and the implications for writing your program correctly. Before splitting the string, deletes any previously existing elements in the arrays and . If is null, the array has no elements. (So this is a portable way to delete an entire array with one statement. See The Statement.) If does not match at all (but is not null), has one element only. The value of that element is the original . In POSIX mode (see Command-Line Options), the fourth argument is not allowed.\n\nSearch , which is treated as a string, for the leftmost, longest substring matched by the regular expression . Modify the entire string by replacing the matched text with . The modified string becomes the new value of . Return the number of substitutions made (zero or one). The argument may be either a regexp constant ( … ) or a string constant ( … ). In the latter case, the string is treated as a regexp to be matched. See Using Dynamic Regexps for a discussion of the difference between the two forms, and the implications for writing your program correctly. This function is peculiar because is not simply used to compute a value, and not just any expression will do—it must be a variable, field, or array element so that can store a modified value there. If this argument is omitted, then the default is to use and alter . For example: sets to ‘ ’ , by replacing the leftmost longest occurrence of ‘ ’ with ‘ ’. If the special character ‘ ’ appears in , it stands for the precise substring that was matched by . (If the regexp can match more than one string, then this precise substring may vary.) For example: changes the first occurrence of ‘ ’ to ‘ ’ on each input line. Here is another example: This shows how ‘ ’ can represent a nonconstant string and also illustrates the “leftmost, longest” rule in regexp matching (see How Much Text Matches?). The effect of this special character (‘ ’) can be turned off by putting a backslash before it in the string. As usual, to insert one backslash in the string, you must write two backslashes. Therefore, write ‘ ’ in a string constant to include a literal ‘ ’ in the replacement. For example, the following shows how to replace the first ‘ ’ on each line with an ‘ ’: As mentioned, the third argument to must be a variable, field, or array element. Some versions of allow the third argument to be an expression that is not an lvalue. In such a case, still searches for the pattern and returns zero or one, but the result of the substitution (if any) is thrown away because there is no place to put it. Such versions of accept expressions like the following: For historical compatibility, accepts such erroneous code. However, using any other nonchangeable object as the third parameter causes a fatal error and your program will not run. Finally, if the is not a regexp constant, it is converted into a string, and then the value of that string is treated as the regexp to match.\n\nReturn a -character-long substring of , starting at character number . The first character of a string is character number one. For example, returns . If is not present, returns the whole suffix of that begins at character number . For example, returns . The whole suffix is also returned if is greater than the number of characters remaining in the string, counting from character . If is less than one, treats it as if it was one. (POSIX doesn’t specify what to do in this case: BWK acts this way, and therefore does too.) If is greater than the number of characters in the string, returns the null string. Similarly, if is present but less than or equal to zero, the null string is returned. The string returned by cannot be assigned. Thus, it is a mistake to attempt to change a portion of a string, as shown in the following example: string = \"abcdef\" # try to get \"abCDEf\", won't work substr(string, 3, 3) = \"CDE\" It is also a mistake to use as the third argument of or : If you need to replace bits and pieces of a string, combine with string concatenation, in the following manner:"
    },
    {
        "link": "https://tutorialspoint.com/awk/awk_string_functions.htm",
        "document": "AWK has the following built-in String functions −\n\nThis function sorts the contents of arr using GAWK's normal rules for comparing values, and replaces the indexes of the sorted values arr with sequential integers starting with 1.\n\nOn executing this code, you get the following result −\n\nThe behavior of this function is the same as that of asort(), except that the array indexes are used for sorting.\n\nOn executing this code, you get the following result −\n\ngsub stands for global substitution. It replaces every occurrence of regex with the given string (sub). The third parameter is optional. If it is omitted, then $0 is used.\n\nOn executing this code, you get the following result −\n\nIt checks whether sub is a substring of str or not. On success, it returns the position where sub starts; otherwise it returns 0. The first character of str is at position 1.\n\nOn executing this code, you get the following result −\n\nIt returns the length of a string.\n\nOn executing this code, you get the following result −\n\nIt returns the index of the first longest match of regex in string str. It returns 0 if no match found.\n\nOn executing this code, you get the following result −\n\nThis function splits the string str into fields by regular expression regex and the fields are loaded into the array arr. If regex is omitted, then FS is used.\n\nOn executing this code, you get the following result −\n\nThis function returns a string constructed from expr-list according to format.\n\nOn executing this code, you get the following result −\n\nThis function examines str and return its numeric value. If str begins with a leading 0, it is treated as an octal number. If str begins with a leading 0x or 0X, it is taken as a hexadecimal number. Otherwise, assume it is a decimal number.\n\nOn executing this code, you get the following result −\n\nThis function performs a single substitution. It replaces the first occurrence of the regex pattern with the given string (sub). The third parameter is optional. If it is omitted, $0 is used.\n\nOn executing this code, you get the following result −\n\nThis function returns the substring of string str, starting at index start of length l. If length is omitted, the suffix of str starting at index start is returned.\n\nOn executing this code, you get the following result −\n\nThis function returns a copy of string str with all upper-case characters converted to lower-case.\n\nOn executing this code, you get the following result −\n\nThis function returns a copy of string str with all lower-case characters converted to upper case.\n\nOn executing this code, you get the following result −"
    },
    {
        "link": "https://gnu.org/s/gawk/manual/gawk.html",
        "document": ""
    },
    {
        "link": "https://cs.unibo.it/~renzo/doc/awk/nawkA4.pdf",
        "document": ""
    },
    {
        "link": "https://docs.rockylinux.org/books/sed_awk_grep/4_awk_command",
        "document": "In 1977, a programming language-level tool for processing text, named' awk', was born at Bell Labs. The name comes from the first letters of the last names of three famous people:\n\nSimilar to shell (bash, csh, zsh, and ksh), has derivatives with the development of history:\n• (new awk): It was born in 1985 and is an updated and enhanced version of . It was widely used with Unix System V Release 3.1 (1987). The old version of is called (old awk).\n• (GNU awk): It was written by Paul Rubin in 1986. The GNU Project was born in 1984.\n• : was written in 1996 by Mike Brennan, the interpreter of the awk programming language.\n\nIn the GNU/Linux operating system, the usual refers to . However, some distributions, such as Ubuntu or Debian, use as their default .\n\nIn the Rocky Linux 8.8, refers to .\n\nFor information not covered, see the gawk manual.\n\nAlthough is a tool for processing text, it has some programming language features:\n\nThe working principle of : Similar to relational databases, it supports processing fields (columns) and records (rows). By default, treats each line of a file as a record and places these records in memory for line-by-line processing, with a portion of each line treated as a field in the record. By default, delimiters to separate different fields use spaces and tabs, while numbers represent different fields in the row record. To reference multiple fields, separate them with commas or tabs.\n\nA simple example that is easy to understand：\n\nThe usage of is -\n\npattern: Find specific content in the text action: Action instruction { }: Group some instructions according to specific patterns\n\nis powerful and involves a lot of knowledge, so some of the content will be explained later.\n\nBefore formally learning , beginners need to understand the command .\n\n：format and print data. Its usage is -\n\nFORMAT：Used to control the content of the output. The following common interpretation sequences are supported：\n• %Ns - The output string. The N represents the number of strings, for example:\n• %Ni - Output integers. The N represents the number of integers of the output, for example:\n• %m.nf - Output Floating Point Number. The m represents the total number of digits output, and the n represents the number of digits after the decimal point. For example:\n\nARGUMENT: If it is a file, you need to do some preprocessing to output correctly.\n\nNo command exists in RockyLinux OS. You can only use in , and its difference from is that it automatically adds a newline at the end of each line. For example:\n• None You can also use words as delimiters. Parentheses indicate this is an overall delimiter, and \"|\" means or.\n• None Assign the value of user-defined variables in bash to awk's variables.\n• None Later, we will introduce what these variables mean. To review them now, jump to variables.\n• None Shell > df -hT awk --profile start line Filesystem Type Size Used Avail Use% Mounted on devtmpfs devtmpfs .8G .8G % /dev tmpfs tmpfs .8G .8G % /dev/shm tmpfs tmpfs .8G .9M .8G % /run tmpfs tmpfs .8G .8G % /sys/fs/cgroup /dev/nvme0n1p2 ext4 47G .7G 42G % / /dev/nvme0n1p1 xfs 1014M 181M 834M % /boot tmpfs tmpfs 363M 363M % /run/user/0 end line Shell > cat /root/awkprof.out BEGIN print print END print Shell > vim /root/awkprof.out BEGIN print print END print Shell > df -hT awk -f /root/awkprof.out start line Filesystem Type Size Used Avail Use% Mounted on devtmpfs devtmpfs .8G .8G % /dev tmpfs tmpfs .8G .8G % /dev/shm tmpfs tmpfs .8G .9M .8G % /run tmpfs tmpfs .8G .8G % /sys/fs/cgroup /dev/nvme0n1p2 ext4 47G .7G 42G % / /dev/nvme0n1p1 xfs 1014M 181M 834M % /boot tmpfs tmpfs 363M 363M % /run/user/0 end line\n• None Locates consecutive lines by string and prints them Start range: stop matching when the first match is encountered. End range: stop matching when the first match is encountered.\n• None You can also use the -v option to assign values to variables. The default output delimiter is a space when using commas to reference multiple fields. You can, however, specify the output delimiter separately.\n• None By default, uses newline characters to distinguish each line record\n• None Count the number of fields per line in the current text Exclude the last two fields\n• None Print the total number of lines in the file content Print the second field on line 200 Shell > cat /etc/services awk # Note that it is presently the policy of IANA to assign a single well-known # port number for both TCP and UDP; hence, most entries here have two entries # even if the protocol doesn't support UDP operations. # Updated from RFC 1700, ``Assigned Numbers'' (October 1994). Not all ports\n• None This variable is mainly used to determine the file the program is working on.\n• None You can reference operating systems or user-defined variables in programs.\n• None This variable is useful if you want to use regular expressions in and ignore case.\n• None Why? Read the first line: Because \"i\" is not assigned a value, so \"i=!i\" indicates TRUE. Read the second line: At this point, \"i=!i\" indicates FALSE. And so on, the final printed line is an odd number. As you can see, sometimes you can ignore the syntax for the \"action\" part, which by default is equivalent to \"{print $0}\".\n• None It can also be used in the \"pattern\":\n• None You can use the bash command in the awk program, for example: Please pay attention! You must use double quotes to include the command.\n• None Here, we cover basic examples of regular expressions. You can use regular expressions on row records. If the file has a large amount of text, regular expressions can also be used for fields, which will help improve processing efficiency. The usage example is as follows:\n• None Example of a single branch use of an if statement: The condition is determined as a regular expression:\n• None Traverse and print out the fields of all row records.\n• None Traverse and print out the fields of all row records. Print the fields for each row of records in reverse order. Print each line of records in the opposite direction.\n• None The comparison between the two is as follows:\n• None You can specify a return value in the range of [0,255]\n\narray: A collection of data with the same data type arranged in a certain order. Each data in an array is called an element.\n\nLike most programming languages, also supports arrays, which are divided into indexed arrays (with numbers as subscripts) and associative arrays (with strings as subscripts).\n\nhas a lot of functions, and the functions related to arrays are:\n• None length(Array_Name) - Get the length of the array.\n• None Get the length of the array: Store all GNU/Linux users in an array: The numeric subscript of an array can be a positive integer, a negative integer, a string, or 0, so the numeric subscript of an array has no concept of an initial value. This is not the same as arrays in .\n• None Delete an element from an array\n• None You can use the for statement, which is suitable for cases where the array subscript is unknown: If the subscript of an array is regular, you can use this form of the for statement:\n• None Use \"++\" as the subscript of the array\n• None Use a field as the subscript of an array\n• None Count the number of occurrences of the same field Count the number of occurrences of the same IPv4 address. Basic idea:\n• First use the command to filter out all IPv4 addresses\n• Then hand it over to the program for processing Count the number of occurrences of words regardless of case. Basic idea:\n• Split all fields into multiple rows of records\n• Then hand it over to the program for processing You can first filter specific row records and then perform statistics, such as:\n• None Print lines based on the number of occurrences of a specific field\n• None The program does not support multi-dimensional arrays, but support for multi-dimensional arrays is achievable through simulation. By default, \"\\034\" is the delimiter for the subscript of a multidimensional array. Please note the following differences when using multidimensional arrays: Count the number of times the field appears:\n• None As you can see, the int function only works for numbers, and when encountering a string, converts it to 0. When encountering a string starting with a number, truncates it.\n• None The example of using the rand function is as follows: The example of using the srand function is as follows: Generate an integer within the range of (0,100):\n• None\n• Numbers have higher priority than strings and are arranged in ascending order. If you are using the asorti function, the example is as follows:\n• If a negative number is encountered, the first digit from the left will be compared. If it is the same, the second digit will be compared, and so on\n• If a positive number is encountered, it will be arranged in ascending order\n• None Just like the command, you can also use the \"&\" symbol to reference already matched strings. Shell > vim /tmp/tmp-file1.txt A .168.1.1 HTTP B .168.1.2 HTTP B .168.1.2 MYSQL C .168.1.1 MYSQL C .168.1.1 MQ D .168.1.4 NGINX # Add a line of text before the second line Shell > cat /tmp/tmp-file1.txt awk A .168.1.1 HTTP add a line B .168.1.2 HTTP B .168.1.2 MYSQL C .168.1.1 MYSQL C .168.1.1 MQ D .168.1.4 NGINX # Add a string after the IP address in the second line Shell > cat /tmp/tmp-file1.txt awk A .168.1.1 HTTP B .168.1.2 STRING HTTP B .168.1.2 MYSQL C .168.1.1 MYSQL C .168.1.1 MQ D .168.1.4 NGINX\n• None # The length of the output field Shell > tail -n /etc/services awk # The length of the output array Shell > cat /etc/passwd awk -F\n• None Shell > head -n /etc/passwd root:x:0:0:root:/root:/bin/bash bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin adm:x:3:4:adm:/var/adm:/sbin/nologin lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin # I need this part of the content - \"emon:/sbin:/sbin/nologin\" Shell > head -n /etc/passwd awk emon:/sbin:/sbin/nologin Shell > tail -n /etc/services axio-disc /udp pmwebapi /tcp cloudcheck-ping /udp cloudcheck /tcp spremotetablet /tcp # I need this part of the content - \"tablet\" Shell > tail -n /etc/services awk tablet\n• None Functions that deal with time and date What is a UNIX timestamp? According to the development history of GNU/Linux, UNIX V1 was born in 1971, and the book \"UNIX Programmer's Manual\" was published on November 3 of the same year, which defines 1970-01-01 as the reference date of the start of UNIX. The conversion between a timestamp and a natural date time in days: The conversion between a timestamp and a natural date time in seconds: The conversion between natural date time and UNIX timestamp in program:\n• None Using the functions we learned earlier and the \"&\" symbol, we can:\n• None Add each line of the b file to the end of each line of the C file: Shell > cat /tmp/b.txt b1 b2 b3 b4 b5 b6 Shell > cat /tmp/c.txt A .168.1.1 HTTP B .168.1.2 HTTP B .168.1.2 MYSQL C .168.1.1 MYSQL C .168.1.1 MQ D .168.1.4 NGINX Shell > awk /tmp/c.txt A .168.1.1 HTTP b1 B .168.1.2 HTTP b2 B .168.1.2 MYSQL b3 C .168.1.1 MYSQL b4 C .168.1.1 MQ b5 D .168.1.4 NGINX b6 Replace the specified field of the c file with the content line of the b file:\n• None Earlier, we introduced the break statement and the continue statement, the former used to terminate the loop, and the latter used to jump out of the current loop. See here. For next, when the conditions are met, it will stop the input recording that meets the conditions and continue with subsequent actions. \"next\" cannot be used in \"BEGIN{}\" and \"END{}\".\n• None You can use this function to call commands in the Shell, such as: Please note to add double quotes when using the system function. If not added, the program will consider it a variable of the program. What if the Shell command itself contains double quotes? Using escape characters - \"\\\", such as:\n• None Write the output of the program to a file \">\" indicates writing to the file as an overlay. If you want to write to the file as an append, please use \">>\". Reminder again, you should use double quotation marks to include the file path.\n\nIf you have specialized programming language skills, is relatively easy to learn. However, for most sysadmins with weak programming language skills (including the author), can be very complicated to learn. For information not covered, please refer to here.\n\nThank you again for reading."
    }
]