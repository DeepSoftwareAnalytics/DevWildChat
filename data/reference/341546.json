[
    {
        "link": "https://docs.python.org/2/library/functions.html",
        "document": "The Python interpreter has a number of functions built into it that are always available. They are listed here in alphabetical order.\n\nIn addition, there are other four built-in functions that are no longer considered essential: , , , and . They are documented in the Non-essential Built-in Functions section."
    },
    {
        "link": "https://docs.python.org/3/library/functions.html",
        "document": "The Python interpreter has a number of functions and types built into it that are always available. They are listed here in alphabetical order.\n\nOpen file and return a corresponding file object. If the file cannot be opened, an is raised. See Reading and Writing Files for more examples of how to use this function. file is a path-like object giving the pathname (absolute or relative to the current working directory) of the file to be opened or an integer file descriptor of the file to be wrapped. (If a file descriptor is given, it is closed when the returned I/O object is closed unless closefd is set to .) mode is an optional string that specifies the mode in which the file is opened. It defaults to which means open for reading in text mode. Other common values are for writing (truncating the file if it already exists), for exclusive creation, and for appending (which on some Unix systems, means that all writes append to the end of the file regardless of the current seek position). In text mode, if encoding is not specified the encoding used is platform-dependent: is called to get the current locale encoding. (For reading and writing raw bytes use binary mode and leave encoding unspecified.) The available modes are: open for writing, truncating the file first open for exclusive creation, failing if the file already exists open for writing, appending to the end of file if it exists The default mode is (open for reading text, a synonym of ). Modes and open and truncate the file. Modes and open the file with no truncation. As mentioned in the Overview, Python distinguishes between binary and text I/O. Files opened in binary mode (including in the mode argument) return contents as objects without any decoding. In text mode (the default, or when is included in the mode argument), the contents of the file are returned as , the bytes having been first decoded using a platform-dependent encoding or using the specified encoding if given. Python doesn’t depend on the underlying operating system’s notion of text files; all the processing is done by Python itself, and is therefore platform-independent. buffering is an optional integer used to set the buffering policy. Pass 0 to switch buffering off (only allowed in binary mode), 1 to select line buffering (only usable when writing in text mode), and an integer > 1 to indicate the size in bytes of a fixed-size chunk buffer. Note that specifying a buffer size this way applies for binary buffered I/O, but (i.e., files opened with ) would have another buffering. To disable buffering in , consider using the flag for . When no buffering argument is given, the default buffering policy works as follows:\n• None Binary files are buffered in fixed-size chunks; the size of the buffer is chosen using a heuristic trying to determine the underlying device’s “block size” and falling back on . On many systems, the buffer will typically be 4096 or 8192 bytes long.\n• None “Interactive” text files (files for which returns ) use line buffering. Other text files use the policy described above for binary files. encoding is the name of the encoding used to decode or encode the file. This should only be used in text mode. The default encoding is platform dependent (whatever returns), but any text encoding supported by Python can be used. See the module for the list of supported encodings. errors is an optional string that specifies how encoding and decoding errors are to be handled—this cannot be used in binary mode. A variety of standard error handlers are available (listed under Error Handlers), though any error handling name that has been registered with is also valid. The standard names include:\n• None to raise a exception if there is an encoding error. The default value of has the same effect.\n• None ignores errors. Note that ignoring encoding errors can lead to data loss.\n• None causes a replacement marker (such as ) to be inserted where there is malformed data.\n• None will represent any incorrect bytes as low surrogate code units ranging from U+DC80 to U+DCFF. These surrogate code units will then be turned back into the same bytes when the error handler is used when writing data. This is useful for processing files in an unknown encoding.\n• None is only supported when writing to a file. Characters not supported by the encoding are replaced with the appropriate XML character reference .\n• None (also only supported when writing) replaces unsupported characters with escape sequences. newline determines how to parse newline characters from the stream. It can be , , , , and . It works as follows:\n• None When reading input from the stream, if newline is , universal newlines mode is enabled. Lines in the input can end in , , or , and these are translated into before being returned to the caller. If it is , universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.\n• None When writing output to the stream, if newline is , any characters written are translated to the system default line separator, . If newline is or , no translation takes place. If newline is any of the other legal values, any characters written are translated to the given string. If closefd is and a file descriptor rather than a filename was given, the underlying file descriptor will be kept open when the file is closed. If a filename is given closefd must be (the default); otherwise, an error will be raised. A custom opener can be used by passing a callable as opener. The underlying file descriptor for the file object is then obtained by calling opener with (file, flags). opener must return an open file descriptor (passing as opener results in functionality similar to passing ). The following example uses the dir_fd parameter of the function to open a file relative to a given directory: 'This will be written to somedir/spamspam.txt' The type of file object returned by the function depends on the mode. When is used to open a file in a text mode ( , , , , etc.), it returns a subclass of (specifically ). When used to open a file in a binary mode with buffering, the returned class is a subclass of . The exact class varies: in read binary mode, it returns an ; in write binary and append binary modes, it returns an , and in read/write mode, it returns an . When buffering is disabled, the raw stream, a subclass of , , is returned. See also the file handling modules, such as , (where is declared), , , , and . The and arguments may have been modified or inferred from the original call.\n• None used to be raised, it is now an alias of .\n• None is now raised if the file opened in exclusive creation mode ( ) already exists.\n• None The file is now non-inheritable.\n• None If the system call is interrupted and the signal handler does not raise an exception, the function now retries the system call instead of raising an exception (see PEP 475 for the rationale).\n• None On Windows, opening a console buffer may return a subclass of other than . Changed in version 3.11: The mode has been removed.\n\nReturn a proxy object that delegates method calls to a parent or sibling class of type. This is useful for accessing inherited methods that have been overridden in a class. The object_or_type determines the method resolution order to be searched. The search starts from the class right after the type. For example, if of object_or_type is and the value of type is , then searches . The attribute of the class corresponding to object_or_type lists the method resolution search order used by both and . The attribute is dynamic and can change whenever the inheritance hierarchy is updated. If the second argument is omitted, the super object returned is unbound. If the second argument is an object, must be true. If the second argument is a type, must be true (this is useful for classmethods). When called directly within an ordinary method of a class, both arguments may be omitted (“zero-argument ”). In this case, type will be the enclosing class, and obj will be the first argument of the immediately enclosing function (typically ). (This means that zero-argument will not work as expected within nested functions, including generator expressions, which implicitly create nested functions.) There are two typical use cases for super. In a class hierarchy with single inheritance, super can be used to refer to parent classes without naming them explicitly, thus making the code more maintainable. This use closely parallels the use of super in other programming languages. The second use case is to support cooperative multiple inheritance in a dynamic execution environment. This use case is unique to Python and is not found in statically compiled languages or languages that only support single inheritance. This makes it possible to implement “diamond diagrams” where multiple base classes implement the same method. Good design dictates that such implementations have the same calling signature in every case (because the order of calls is determined at runtime, because that order adapts to changes in the class hierarchy, and because that order can include sibling classes that are unknown prior to runtime). For both use cases, a typical superclass call looks like this: # This does the same thing as: In addition to method lookups, also works for attribute lookups. One possible use case for this is calling descriptors in a parent or sibling class. Note that is implemented as part of the binding process for explicit dotted attribute lookups such as . It does so by implementing its own method for searching classes in a predictable order that supports cooperative multiple inheritance. Accordingly, is undefined for implicit lookups using statements or operators such as . Also note that, aside from the zero argument form, is not limited to use inside methods. The two argument form specifies the arguments exactly and makes the appropriate references. The zero argument form only works inside a class definition, as the compiler fills in the necessary details to correctly retrieve the class being defined, as well as accessing the current instance for ordinary methods. For practical suggestions on how to design cooperative classes using , see guide to using super()."
    },
    {
        "link": "https://w3schools.com/python/ref_func_range.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "http://python-reference.readthedocs.io/en/latest/docs/functions/range.html",
        "document": "This is a versatile function to create lists containing arithmetic progressions. It is most often used in for loops. The arguments must be plain integers. If the step argument is omitted, it defaults to 1. If the start argument is omitted, it defaults to 0. The full form returns a list of plain integers [start, start + step, start + 2 * step, …]. If step is positive, the last element is the largest start + i * step less than stop; if step is negative, the last element is the smallest start + i * step greater than stop. step must not be zero (or else ValueError is raised)."
    },
    {
        "link": "https://docs.python.org/3/tutorial/datastructures.html",
        "document": "This chapter describes some things you’ve learned about already in more detail, and adds some new things as well.\n\nThe list data type has some more methods. Here are all of the methods of list objects: Add an item to the end of the list. Similar to . Extend the list by appending all the items from the iterable. Similar to . Insert an item at a given position. The first argument is the index of the element before which to insert, so inserts at the front of the list, and is equivalent to . Remove the first item from the list whose value is equal to x. It raises a if there is no such item. Remove the item at the given position in the list, and return it. If no index is specified, removes and returns the last item in the list. It raises an if the list is empty or the index is outside the list range. Remove all items from the list. Similar to . Return zero-based index in the list of the first item whose value is equal to x. Raises a if there is no such item. The optional arguments start and end are interpreted as in the slice notation and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument. Return the number of times x appears in the list. Sort the items of the list in place (the arguments can be used for sort customization, see for their explanation). Reverse the elements of the list in place. Return a shallow copy of the list. Similar to . An example that uses most of the list methods: You might have noticed that methods like , or that only modify the list have no return value printed – they return the default . This is a design principle for all mutable data structures in Python. Another thing you might notice is that not all data can be sorted or compared. For instance, doesn’t sort because integers can’t be compared to strings and can’t be compared to other types. Also, there are some types that don’t have a defined ordering relation. For example, isn’t a valid comparison. The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved (“last-in, first-out”). To add an item to the top of the stack, use . To retrieve an item from the top of the stack, use without an explicit index. For example: It is also possible to use a list as a queue, where the first element added is the first element retrieved (“first-in, first-out”); however, lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from the beginning of a list is slow (because all of the other elements have to be shifted by one). To implement a queue, use which was designed to have fast appends and pops from both ends. For example: # The first to arrive now leaves # The second to arrive now leaves List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition. For example, assume we want to create a list of squares, like: Note that this creates (or overwrites) a variable named that still exists after the loop completes. We can calculate the list of squares without any side effects using: which is more concise and readable. A list comprehension consists of brackets containing an expression followed by a clause, then zero or more or clauses. The result will be a new list resulting from evaluating the expression in the context of the and clauses which follow it. For example, this listcomp combines the elements of two lists if they are not equal: Note how the order of the and statements is the same in both these snippets. If the expression is a tuple (e.g. the in the previous example), it must be parenthesized. # create a new list with the values doubled # apply a function to all the elements # the tuple must be parenthesized, otherwise an error is raised File , line : did you forget parentheses around the comprehension target? # flatten a list using a listcomp with two 'for' List comprehensions can contain complex expressions and nested functions: The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension. Consider the following example of a 3x4 matrix implemented as a list of 3 lists of length 4: The following list comprehension will transpose rows and columns: As we saw in the previous section, the inner list comprehension is evaluated in the context of the that follows it, so this example is equivalent to: which, in turn, is the same as: # the following 3 lines implement the nested listcomp In the real world, you should prefer built-in functions to complex flow statements. The function would do a great job for this use case: See Unpacking Argument Lists for details on the asterisk in this line.\n\nWe saw that lists and strings have many common properties, such as indexing and slicing operations. They are two examples of sequence data types (see Sequence Types — list, tuple, range). Since Python is an evolving language, other sequence data types may be added. There is also another standard sequence data type: the tuple. A tuple consists of a number of values separated by commas, for instance: File , line , in : # but they can contain mutable objects: As you see, on output tuples are always enclosed in parentheses, so that nested tuples are interpreted correctly; they may be input with or without surrounding parentheses, although often parentheses are necessary anyway (if the tuple is part of a larger expression). It is not possible to assign to the individual items of a tuple, however it is possible to create tuples which contain mutable objects, such as lists. Though tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are immutable, and usually contain a heterogeneous sequence of elements that are accessed via unpacking (see later in this section) or indexing (or even by attribute in the case of ). Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list. A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. For example: The statement is an example of tuple packing: the values , and are packed together in a tuple. The reverse operation is also possible: This is called, appropriately enough, sequence unpacking and works for any sequence on the right-hand side. Sequence unpacking requires that there are as many variables on the left side of the equals sign as there are elements in the sequence. Note that multiple assignment is really just a combination of tuple packing and sequence unpacking.\n\nPython also includes a data type for sets. A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like union, intersection, difference, and symmetric difference. Curly braces or the function can be used to create sets. Note: to create an empty set you have to use , not ; the latter creates an empty dictionary, a data structure that we discuss in the next section. Here is a brief demonstration: # show that duplicates have been removed # Demonstrate set operations on unique letters from two words # letters in a but not in b # letters in a or b or both # letters in both a and b # letters in a or b but not both Similarly to list comprehensions, set comprehensions are also supported:\n\nAnother useful data type built into Python is the dictionary (see Mapping Types — dict). Dictionaries are sometimes found in other languages as “associative memories” or “associative arrays”. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by keys, which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You can’t use lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like and . It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: . Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output. The main operations on a dictionary are storing a value with some key and extracting the value given the key. It is also possible to delete a key:value pair with . If you store using a key that is already in use, the old value associated with that key is forgotten. It is an error to extract a value using a non-existent key. Performing on a dictionary returns a list of all the keys used in the dictionary, in insertion order (if you want it sorted, just use instead). To check whether a single key is in the dictionary, use the keyword. Here is a small example using a dictionary: The constructor builds dictionaries directly from sequences of key-value pairs: In addition, dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments:\n\nWhen looping through dictionaries, the key and corresponding value can be retrieved at the same time using the method. When looping through a sequence, the position index and corresponding value can be retrieved at the same time using the function. To loop over two or more sequences at the same time, the entries can be paired with the function. What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. To loop over a sequence in reverse, first specify the sequence in a forward direction and then call the function. To loop over a sequence in sorted order, use the function which returns a new sorted list while leaving the source unaltered. Using on a sequence eliminates duplicate elements. The use of in combination with over a sequence is an idiomatic way to loop over unique elements of the sequence in sorted order. It is sometimes tempting to change a list while you are looping over it; however, it is often simpler and safer to create a new list instead.\n\nThe conditions used in and statements can contain any operators, not just comparisons. The comparison operators and are membership tests that determine whether a value is in (or not in) a container. The operators and compare whether two objects are really the same object. All comparison operators have the same priority, which is lower than that of all numerical operators. Comparisons can be chained. For example, tests whether is less than and moreover equals . Comparisons may be combined using the Boolean operators and , and the outcome of a comparison (or of any other Boolean expression) may be negated with . These have lower priorities than comparison operators; between them, has the highest priority and the lowest, so that A and not B or C is equivalent to (A and (not B)) or C . As always, parentheses can be used to express the desired composition. The Boolean operators and are so-called short-circuit operators: their arguments are evaluated from left to right, and evaluation stops as soon as the outcome is determined. For example, if and are true but is false, A and B and C does not evaluate the expression . When used as a general value and not as a Boolean, the return value of a short-circuit operator is the last evaluated argument. It is possible to assign the result of a comparison or other Boolean expression to a variable. For example, Note that in Python, unlike C, assignment inside expressions must be done explicitly with the walrus operator . This avoids a common class of problems encountered in C programs: typing in an expression when was intended.\n\nSequence objects typically may be compared to other objects with the same sequence type. The comparison uses lexicographical ordering: first the first two items are compared, and if they differ this determines the outcome of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is exhausted. If two items to be compared are themselves sequences of the same type, the lexicographical comparison is carried out recursively. If all items of two sequences compare equal, the sequences are considered equal. If one sequence is an initial sub-sequence of the other, the shorter sequence is the smaller (lesser) one. Lexicographical ordering for strings uses the Unicode code point number to order individual characters. Some examples of comparisons between sequences of the same type: Note that comparing objects of different types with or is legal provided that the objects have appropriate comparison methods. For example, mixed numeric types are compared according to their numeric value, so 0 equals 0.0, etc. Otherwise, rather than providing an arbitrary ordering, the interpreter will raise a exception."
    },
    {
        "link": "https://stackoverflow.com/questions/12964460/adding-numbers-in-a-range-with-for-loop",
        "document": "I'm having trouble filling out a question on an online python tutorial. It seems really simple but for the life of me I can't figure it out. This is the problem \"write a for loop that adds all the numbers 1 to 10 and returns the sum.\" And this is the code I have been trying:\n\nWhat am I doing wrong? Thanks for any help."
    },
    {
        "link": "https://stackoverflow.com/questions/20888913/summing-up-elements-in-a-list-in-python-using-a-for-loop",
        "document": "While working on a program that creates bars out of sets of numbers in a list, I found that adding up items in my list doesn't work. I thought the best way to do this is just to make a loop.\n\nAnd then I try to add this up with a loop\n\nYet I get this error:\n\nWhat should I do?"
    },
    {
        "link": "https://realpython.com/python-sum-function",
        "document": "Python’s built-in function is an efficient and Pythonic way to sum a list of numeric values. Adding several numbers together is a common intermediate step in many computations, so is a pretty handy tool for a Python programmer.\n\nAs an additional and interesting use case, you can concatenate lists and tuples using , which can be convenient when you need to flatten a list of lists.\n\nIn this tutorial, you’ll learn how to:\n• Sum numeric values by hand using general techniques and tools\n• Use Python’s to add several numeric values efficiently\n• Use appropriate values for the arguments in\n• Decide between and alternative tools to sum and concatenate objects\n\nThis knowledge will help you efficiently approach and solve summation problems in your code using either or other alternative and specialized tools.\n\nSumming numeric values together is a fairly common problem in programming. For example, say you have a list of numbers [1, 2, 3, 4, 5] and want to add them together to compute their total sum. With standard arithmetic, you’ll do something like this: As far as math goes, this expression is pretty straightforward. It walks you through a short series of additions until you find the sum of all the numbers. It’s possible to do this particular calculation by hand, but imagine some other situations where it might not be so possible. If you have a particularly long list of numbers, adding by hand can be inefficient and error-prone. What happens if you don’t even know how many items are in the list? Finally, imagine a scenario where the number of items you need to add changes dynamically or unpredictably. In situations like these, whether you have a long or short list of numbers, Python can be quite useful to solve summation problems. If you want to sum the numbers by creating your own solution from scratch, then you can try using a loop: Here, you first create and initialize it to . This variable works as an accumulator in which you store intermediate results until you get the final one. The loop iterates through and updates by accumulating each successive value using an augmented assignment. You can also wrap the loop in a function. This way, you can reuse the code for different lists: In , you take an iterable—specifically, a list of numeric values—as an argument and return the total sum of the values in the input list. If the input list is empty, then the function returns . The loop is the same one that you saw before. You can also use recursion instead of iteration. Recursion is a functional programming technique where a function is called within its own definition. In other words, a recursive function calls itself in a loop: When you define a recursive function, you take the risk of running into an infinite loop. To prevent this, you need to define both a base case that stops the recursion and a recursive case to call the function and start the implicit loop. In the above example, the base case implies that the sum of a zero-length list is . The recursive case implies that the total sum is the first value, , plus the sum of the rest of the values, . Because the recursive case uses a shorter sequence on each iteration, you expect to run into the base case when is a zero-length list. As a final result, you get the sum of all the items in your input list, . Note: In this example, if you don’t check for an empty input list (your base case), then will never run into an infinite recursive loop. When your list reaches a length of , the code tries to access an item from the empty list, which raises an and breaks the loop. With this kind of implementation, you’ll never get a sum from this function. You’ll get an every time. Another option to sum a list of numbers in Python is to use from . To get the sum of a list of numbers, you can pass either or an appropriate function as the first argument to : : reduce() of empty sequence with no initial value You can call with a reduction, or folding, along with an as arguments. Then uses the input function to process and returns a single cumulative value. In the first example, the reduction function is , which takes two numbers and adds them together. The final result is the sum of the numbers in the input . As a drawback, raises a when you call it with an empty . In the second example, the reduction function is a function that returns the addition of two numbers. Since summations like these are commonplace in programming, coding a new function every time you need to sum some numbers is a lot of repetitive work. Additionally, using isn’t the most readable solution available to you. Python provides a dedicated built-in function to solve this problem. The function is conveniently called . Since it’s a built-in function, you can use it directly in your code without importing anything.\n\nReadability is one of the most important principles behind Python’s philosophy. Visualize what you are asking a loop to do when summing a list of values. You want it to loop over some numbers, accumulate them in an intermediate variable, and return the final sum. However, you can probably imagine a more readable version of summation that doesn’t need a loop. You want Python to take some numbers and sum them together. Now think about how does summation. Using is arguably less readable and less straightforward than even the loop-based solution. This is why Python 2.3 added as a built-in function to provide a Pythonic solution to the summation problem. Alex Martelli contributed the function, which nowadays is the preferred syntax for summing a list of values: Wow! That’s neat, isn’t it? It reads like plain English and clearly communicates the action you’re performing on the input list. Using is way more readable than a loop or a call. Unlike , doesn’t raise a when you provide an empty iterable. Instead, it understandably returns . You can call with the following two arguments:\n• is a required argument that can hold any Python iterable. The iterable typically contains numeric values but can also contain lists or tuples.\n• is an optional argument that can hold an initial value. This value is then added to the final result. It defaults to . Internally, adds plus the values in from left to right. The values in the input are normally numbers, but you can also use lists and tuples. The optional argument can accept a number, list, or tuple, depending on what is passed to . It can’t take a string. In the following two sections, you’ll learn the basics of using in your code. Accepting any Python iterable as its first argument makes generic, reusable, and polymorphic. Because of this feature, you can use with lists, tuples, sets, objects, and dictionaries: In all these examples, computes the arithmetic sum of all the values in the input iterable regardless of their types. In the two dictionary examples, both calls to return the sum of the keys of the input dictionary. The first example sums the keys by default and the second example sums the keys because of the call on the input dictionary. If your dictionary stores numbers in its values and you would like to sum these values instead of the keys, then you can do this by using just like in the example. You can also use with a list comprehension as an argument. Here’s an example that computes the sum of the squares of a range of values: Python 2.4 added generator expressions to the language. Again, works as expected when you use a generator expression as an argument: This example shows one of the most Pythonic techniques to approach the summation problem. It provides an elegant, readable, and efficient solution in a single line of code. The second and optional argument, , allows you to provide a value to initialize the summation process. This argument is handy when you need to process cumulative values sequentially: Here, you provide an initial value of to . The net effect is that adds this value to the cumulative sum of the values in the input iterable. Note that you can provide as a positional argument or as a keyword argument. The latter option is way more explicit and readable. If you don’t provide a value to , then it defaults to . A default value of ensures the expected behavior of returning the total sum of the input values.\n\nEven though is mostly intended to operate on numeric values, you can also use the function to concatenate sequences such as lists and tuples. To do that, you need to provide an appropriate value to : In these examples, you use to concatenate lists and tuples. This is an interesting feature that you can use to flatten a list of lists or a tuple of tuples. The key requirement for these examples to work is to select an appropriate value for . For example, if you want to concatenate lists, then needs to hold a list. In the examples above, is internally performing a concatenation operation, so it works only with those sequence types that support concatenation, with the exception of strings: File , line , in : sum() can't sum strings [use ''.join(seq) instead] When you try to use to concatenate strings, you get a . As the exception message suggests, you should use to concatenate strings in Python. You’ll see examples of using this method later on when you get to the section on Using Alternatives to .\n\nSo far, you’ve learned the basics of working with . You’ve learned how to use this function to add numeric values together and also to concatenate sequences such as lists and tuples. In this section, you’ll look at some more examples of when and how to use in your code. With these practical examples, you’ll learn that this built-in function is quite handy when you’re performing computations that require finding the sum of a series of numbers as an intermediate step. You’ll also learn that can be helpful when you’re working with lists and tuples. A special example you’ll look at is when you need to flatten a list of lists. The first example you’ll code has to do with how to take advantage of the argument for summing cumulative lists of numeric values. Say you’re developing a system to manage the sales of a given product at several different points of sale. Every day, you get a sold units report from each point of sale. You need to systematically compute the cumulative sum to know how many units the whole company sold over the week. To solve this problem, you can use : By using , you set an initial value to initialize the sum, which allows you to add successive units to the previously computed subtotal. At the end of the week, you’ll have the company’s total count of sold units. Calculating the Mean of a Sample Another practical use case of is to use it as an intermediate calculation before doing further calculations. For example, say you need to calculate the arithmetic mean of a sample of numeric values. The arithmetic mean, also known as the average, is the total sum of the values divided by the number of values, or data points, in the sample. If you have the sample [2, 3, 4, 2, 3, 6, 4, 2] and you want to calculate the arithmetic mean by hand, then you can solve this operation: If you want to speed this up by using Python, you can break it up into two parts. The first part of this computation, where you are adding together the numbers, is a task for . The next part of the operation, where you are dividing by 8, uses the count of numbers in your sample. To calculate your divisor, you can use : Here, the call to computes the total sum of the data points in your sample. Next, you use to get the number of data points. Finally, you perform the required division to calculate the sample’s arithmetic mean. In practice, you may want to turn this code into a function with some additional features, such as a descriptive name and a check for empty samples: \"average requires at least one data point\" File , line , in File , line , in : average requires at least one data point Inside , you first check if the input sample has any data points. If not, then you raise a with a descriptive message. In this example, you use the walrus operator to store the number of data points in the variable so that you won’t need to call again. The return statement computes the sample’s arithmetic mean and sends it back to the calling code. Note: Computing the mean of a sample of data is a common operation in statistics and data analysis. The Python standard library provides a convenient module called to approach these kinds of calculations. : mean requires at least one data point The function has very similar behavior to the function you coded earlier. When you call with a sample of numeric values, you’ll get the arithmetic mean of the input data. When you pass an empty list to , you’ll get a . Note that when you call with a proper sample, you’ll get the desired mean. If you call with an empty sample, then you get a as expected. Finding the Dot Product of Two Sequences Another problem you can solve using is finding the dot product of two equal-length sequences of numeric values. The dot product is the algebraic sum of products of every pair of values in the input sequences. For example, if you have the sequences (1, 2, 3) and (4, 5, 6), then you can calculate their dot product by hand using addition and multiplication: To extract successive pairs of values from the input sequences, you can use . Then you can use a generator expression to multiply each pair of values. Finally, can sum the products: With , you generate a list of tuples with the values from each of the input sequences. The generator expression loops over each tuple while multiplying the successive pairs of values previously arranged by . The final step is to add the products together using . The code in the above example works. However, the dot product is defined for sequences of equal length, so what happens if you provide sequences with different lengths? In that case, ignores the extra values from the longest sequence, which leads to an incorrect result. To deal with this possibility, you can wrap the call to in a custom function and provide a proper check for the length of the input sequences: Here, takes two sequences as arguments and returns their corresponding dot product. If the input sequences have different lengths, then the function raises a . Embedding the functionality in a custom function allows you to reuse the code. It also gives you the opportunity to name the function descriptively so that the user knows what the function does just by reading its name. Flattening a list of lists is a common task in Python. Say you have a list of lists and need to flatten it into a single list containing all the items from the original nested lists. You have options when deciding how to flatten lists in Python. For example, you can use a loop, as in the following code: Inside , the loop iterates over all the nested lists contained in . Then it concatenates them in using an augmented assignment operation ( ). As the result, you get a flat list with all the items from the original nested lists. But hold on! You’ve already learned how to use to concatenate sequences in this tutorial. Can you use that feature to flatten a list of lists like you did in the example above? Yes! Here’s how: That was quick! A single line of code and is now a flat list. However, using doesn’t seem to be the fastest solution. Using a list comprehension is another common way to flatten a list of list in Python: This new version of uses a comprehension instead of a regular loop. However, the nested comprehensions can be challenging to read and understand. Using is another way to flatten a list of lists: In this version of , someone reading your code can see that the function iterates over every in . In the second loop, the function iterates over each in to finally populate the new list with . Arguably, readability can be an advantage of this solution.\n\nAs you’ve already learned, is helpful for working with numeric values in general. However, when it comes to working with floating-point numbers, Python provides an alternative tool. In , you’ll find a function called that can help you improve the general precision of your floating-point computations. You might have a task where you want to concatenate or chain several iterables so that you can work with them as one. For this scenario, you can look to the module’s function . You might also have a task where you want to concatenate a list of strings. You’ve learned in this tutorial that there’s no way to use for concatenating strings. This function just wasn’t built for string concatenation. The most Pythonic alternative is to use . If your code is constantly summing floating-point numbers with , then you should consider using instead. This function performs floating-point computations more carefully than , which improves the precision of your computation. According to its documentation, “avoids loss of precision by tracking multiple intermediate partial sums.” The documentation provides the following example: With , you get a more precise result. However, you should note that doesn’t solve the representation error in floating-point arithmetic. The following example uncovers this limitation: In these examples, both functions return the same result. This is due to the impossibility of accurately representing both values and in binary floating-point: Unlike , however, can help you reduce floating-point error propagation when you add very large and very small numbers together: Wow! The second example is pretty surprising and totally defeats . With , you get as a result. This is quite far away from the correct result of , as you get with . If you’re looking for a handy tool for concatenating or chaining a series of iterables, then consider using from . This function can take multiple iterables and build an iterator that yields items from the first one, from the second one, and so on until it exhausts all the input iterables: When you call , you get an iterator of the items from the input iterables. In this example, you access successive items from using . If you want to work with a list instead, then you can use to consume the iterator and return a regular Python list. is also a good option for flattening a list of lists in Python: To flatten a list of lists with , you need to use the iterable unpacking operator ( ). This operator unpacks all the input iterables so that can work with them and generate the corresponding iterator. The final step is to call to build the desired flat list. As you’ve already seen, doesn’t concatenate or join strings. If you need to do so, then the preferred and fastest tool available in Python is . This method takes a sequence of strings as an argument and returns a new, concatenated string: 'Hello, welcome to Real Python!' Using is the most efficient and Pythonic way to concatenate strings. Here, you use a list of strings as an argument and build a single string from the input. Note that uses the string on which you call the method as a separator during the concatenation. In this example, you call on a string that consists of a single space character ( ), so the original strings from are separated by spaces in your final string."
    },
    {
        "link": "https://reddit.com/r/learnpython/comments/ripmdt/how_to_cumulative_sum_over_for_loop",
        "document": "Hello, so I am trying to understand how to sum values through a for loop within python so that I start with a value, and then add to it, and then add the next value to that, and then add the next value to that, and so on, going through all values in my list/folder. I think this would be referred to as a \"cumulative sum\". So let's say I have a list of numbers:\n\nI want to iterate over each value in this list and add all values to the previous like so:\n\nor something like that? I tried this, and it just adds one to each value in the list, when I want a single final cumulative sum produced. I am really confused about if my logic is correct there. Is this how I would carry out this cumulative sum operation? I am trying to take 1, and then add 4, and then add 6 to that, and then add 3 to that sum, and then add 7 to that sum, and so on. I realize one could also just add all of these values at once, but I am trying to understand how to do this with a for loop. Thanks!"
    },
    {
        "link": "https://uvm.edu/~cbcafier/cs1210/book/11_loops/loops_and_summation.html",
        "document": ""
    }
]