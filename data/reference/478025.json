[
    {
        "link": "https://developer.android.com/develop/ui/views/graphics/drawables",
        "document": "When you need to display static images in your app, you can use the class and its subclasses to draw shapes and images. A is a general abstraction for something that can be drawn. The various subclasses help with specific image scenarios, and you can extend them to define your own drawable objects that behave in unique ways.\n\nThere are two ways to define and instantiate a besides using the class constructors:\n• Inflate an image resource (a bitmap file) saved in your project.\n• Inflate an XML resource that defines the drawable properties.\n\nNote: You might instead prefer using a vector drawable, which defines an image with a set of points, lines, and curves, along with associated color information. This allows vector drawables to be scaled for different sizes without a loss of quality. For more information, see Vector drawables overview.\n\nYou can add graphics to your app by referencing an image file from your project resources. Supported file types are PNG (preferred), JPG (acceptable), and GIF (discouraged). App icons, logos, and other graphics, such as those used in games, are well suited for this technique.\n\nTo use an image resource, add your file to the directory of your project. Once in your project, you can reference the image resource from your code or your XML layout. Either way, it's referred to using a resource ID, which is the file name without the file type extension. For example, refer to as .\n\nNote: Image resources placed in the directory may be automatically optimized with lossless image compression by the tool during the build process. For example, a true-color PNG that doesn't require more than 256 colors may be converted to an 8-bit PNG with a color palette. This results in an image of equal quality but which requires less memory. As a result, the image binaries placed in this directory can change at build time. If you plan on reading an image as a bitstream in order to convert it to a bitmap, put your images in the folder instead, where the tool doesn't modify them.\n\nThe following code snippet demonstrates how to build an that uses an image created from a drawable resource and adds it to the layout:\n\nIn other cases, you may want to handle your image resource as a object, as shown in the following example:\n\nWarning: Each unique resource in your project can maintain only one state, no matter how many different objects you instantiate for it. For example, if you instantiate two objects from the same image resource and change a property (such as the alpha) for one object, then it also affects the other. When dealing with multiple instances of an image resource, instead of directly transforming the object you should perform a tween animation.\n\nThe XML snippet below shows how to add a drawable resource to an in the XML layout:\n\nFor more information about using project resources, see Resources and assets.\n\nNote: When using image resources as the source of your drawables, be sure the images are the appropriate size for various pixel densities. If the images are not correct they will be scaled up to fit, which can cause artifacting in your drawables. For more information, read Support different pixel densities.\n\nIf there is a object that you'd like to create, which isn't initially dependent on variables defined by your code or user interaction, then defining the in XML is a good option. Even if you expect your to change its properties during the user's interaction with your app, you should consider defining the object in XML, as you can modify properties after the object has been instantiated.\n\nAfter you've defined your in XML, save the file in the directory of your project. The following example shows the XML that defines a resource, which inherits from :\n\nThen, retrieve and instantiate the object by calling and passing the resource ID of your XML file. Any subclass that supports the method can be defined in XML and instantiated by your app.\n\nEach drawable class that supports XML inflation utilizes specific XML attributes that help define the object properties. The following code instantiates the and sets it as the content of an object:\n\nFor more information about the XML attributes supported, refer to the classes listed above.\n\nA object can be a good option when you want to dynamically draw a two-dimensional graphic. You can programmatically draw primitive shapes on a object and apply the styles that your app needs.\n\nis a subclass of . For this reason, you can use a wherever a is expected. For example, you can use a object to set the background of a view by passing it to the method of the view. You can also draw your shape as its own custom view and add it to a layout in your app.\n\nBecause has its own method, you can create a subclass of that draws the object during the event, as shown in the following code example:\n\nYou can use the class in the code sample above as you would use any other custom view. For example, you can programmatically add it to an activity in your app, as shown in the following example:\n\nIf you want to use the custom view in the XML layout instead, then the class must override the constructor, which is called when the class is inflated from XML. The following example shows how to declare the in the XML layout:\n\nThe class, like many other drawable types in the package, allows you to define various properties of the object by using public methods. Some example properties you might want to adjust include alpha transparency, color filter, dither, opacity, and color.\n\nYou can also define primitive drawable shapes using XML resources. For more information, see Shape drawable in Drawable resource types.\n\nA graphic is a stretchable bitmap image that you can use as the background of a view. Android automatically resizes the graphic to accommodate the contents of the view. An example use of a NinePatch image is the background used by standard Android buttons—buttons must stretch to accommodate strings of various lengths. A NinePatch graphic is a standard PNG image that includes an extra 1-pixel border. It must be saved with the extension in the directory of your project.\n\nUse the border to define the stretchable and static areas of the image. You indicate a stretchable section by drawing one (or more) 1-pixel wide black line(s) in the left and top part of the border (the other border pixels should be fully transparent or white). You can have as many stretchable sections as you want. The relative size of the stretchable sections stays the same, so the largest section always remains the largest.\n\nYou can also define an optional drawable section of the image (effectively, the padding lines) by drawing a line on the right and a line on the bottom. If a object sets the NinePatch graphic as its background and then specifies the view's text, it stretches itself so that all the text occupies only the area designated by the right and bottom lines (if included). If the padding lines aren't included, Android uses the left and top lines to define this drawable area.\n\nTo clarify the difference between the lines, the left and top lines define which pixels of the image are allowed to be replicated in order to stretch the image. The bottom and right lines define the relative area within the image that the contents of the view are allowed to occupy.\n\nFigure 1 shows an example of a NinePatch graphic used to define a button:\n\nFigure 1: Example of a NinePatch graphic that defines a button\n\nThis NinePatch graphic defines one stretchable area with the left and top lines, and the drawable area with the bottom and right lines. In the top image, the dotted grey lines identify the regions of the image that are replicated in order to stretch the image. The pink rectangle in the bottom image identifies the region in which the contents of the view are allowed. If the contents don't fit in this region, then the image is stretched to make them fit.\n\nThe Draw 9-patch tool offers an extremely handy way to create your NinePatch images, using a WYSIWYG graphics editor. It even raises warnings if the region you've defined for the stretchable area is at risk of producing drawing artifacts as a result of the pixel replication.\n\nThe following sample layout XML demonstrates how to add a NinePatch graphic to a couple of buttons. The NinePatch image is saved to .\n\nNote that the and attributes are set to to make the button fit neatly around the text.\n\nFigure 2 shows the two buttons rendered from the XML and NinePatch image shown above. Notice how the width and height of the button varies with the text, and the background image stretches to accommodate it.\n\nFigure 2: Buttons rendered using an XML resource and a NinePatch graphic\n\nWhen you want to create some custom drawings, you can do so by extending the class (or any of its subclasses).\n\nThe most important method to implement is because this provides the object you must use to provide your drawing instructions.\n\nThe following code shows a simple subclass of that draws a circle:\n\nThen you can add your drawable wherever you'd like, such as to an as shown here:\n\nOn Android 7.0 (API level 24) and higher, you can also define instances of your custom drawable with XML in the following ways:\n• Using the fully-qualified class name as the XML element name. For this approach, the custom drawable class must be a public top-level class:\n• Using as the XML tag name and specifying the fully-qualified class name from the class attribute. This approach may be used for both public top-level classes and public static inner classes:\n\nWith Android 5.0 (API level 21) and above, you can tint bitmaps and nine-patches defined as alpha masks. You can tint them with color resources or theme attributes that resolve to color resources (for example, ). Usually, you create these assets only once and color them automatically to match your theme.\n\nYou can apply a tint to , or objects with the method. You can also set the tint color and mode in your layouts with the and attributes.\n\nThe Android Support Library includes the class, which lets you extract prominent colors from an image. You can load your drawables as a and pass it to to access its colors. For more information, read Selecting colors with the Palette API."
    },
    {
        "link": "https://developer.android.com/reference/android/graphics/drawable/ShapeDrawable",
        "document": "Base class defines a factory object that is called each time the drawable is resized (has a new width or height).\n\nApplies the specified theme to this Drawable and its children. Draw in its bounds (set via setBounds) respecting optional effects such as alpha (set via setAlpha) and color filter (set via setColorFilter). Gets the current alpha value for the drawable. Return a mask of the configuration parameters for which this drawable may change, requiring that it be re-created. Return a instance that holds the shared state of this Drawable. This method is deprecated. This method is no longer used in graphics optimizations Called to get the drawable to populate the Outline that defines its drawing area. Return in padding the insets suggested by this Drawable for placing content inside the drawable's bounds. Returns the Paint used to draw the shape. Returns the ShaderFactory used by this ShapeDrawable for requesting a . Returns the Shape of this ShapeDrawable. Indicates whether this drawable has at least one state spec explicitly specifying . Inflate this Drawable from an XML resource optionally styled by a theme. Indicates whether this drawable will change its appearance based on state. Set the alpha level for this drawable [0..255]. Specify an optional color filter for the drawable. This method is deprecated. This property is ignored. Sets the intrinsic (default) height for this shape. Sets the intrinsic (default) width for this shape. Sets padding for this shape, defined by a Rect object. Sets a ShaderFactory to which requests for a object will be made. Sets the Shape of this ShapeDrawable. Specifies tint color for this drawable as a color state list.\n\nApplies the specified theme to this Drawable and its children. Removes the color filter for this drawable. Return a copy of the drawable's bounds in a new Rect. Return a copy of the drawable's bounds in the specified Rect (allocated by the caller). This method was deprecated in API level 28. Prefer the version without an Options object. Create a drawable from an inputstream, using the given resources and value to determine density information. Create a drawable from an XML document using an optional . Create a drawable from inside an XML document using an optional . Draw in its bounds (set via setBounds) respecting optional effects such as alpha (set via setAlpha) and color filter (set via setColorFilter). Gets the current alpha value for the drawable. Return the current implementation attached to this Drawable. Return a mask of the configuration parameters for which this drawable may change, requiring that it be re-created. Returns the current color filter, or if none set. Return a instance that holds the shared state of this Drawable. Returns the resolved layout direction for this Drawable. Returns the minimum height suggested by this Drawable. Returns the minimum width suggested by this Drawable. This method was deprecated in API level 29. This method is no longer used in graphics optimizations Return in insets the layout insets suggested by this Drawable for use with alignment operations during layout. Called to get the drawable to populate the Outline that defines its drawing area. Return in padding the insets suggested by this Drawable for placing content inside the drawable's bounds. Describes the current state, as a union of primitive states, such as , , etc. Returns a Region representing the part of the Drawable that is completely transparent. Indicates whether this drawable has at least one state spec explicitly specifying . Inflate this Drawable from an XML resource optionally styled by a theme. Inflate this Drawable from an XML resource. Use the current implementation to have this Drawable redrawn. Tells if this Drawable will be automatically mirrored when its layout direction is RTL right-to-left. Indicates whether this drawable will change its appearance based on state. If this Drawable does transition animations between states, ask that it immediately jump to the current state and skip any active animations. Override this in your subclass to change appearance if you vary based on the bounds. Called when the drawable's resolved layout direction changes. Override this in your subclass to change appearance if you vary based on level. Override this in your subclass to change appearance if you recognize the specified state. Return the appropriate opacity value for two source opacities. Use the current implementation to have this Drawable scheduled. Specify an alpha value for the drawable. Set whether this Drawable is automatically mirrored when its layout direction is RTL (right-to left). Specify a bounding rectangle for the Drawable. Specify a bounding rectangle for the Drawable. Set a mask of the configuration parameters for which this drawable may change, requiring that it be re-created. This method was deprecated in API level 29. use with an instance of Specify an optional color filter for the drawable. This method was deprecated in API level 23. This property is ignored. Set to true to have the drawable filter its bitmaps with bilinear sampling when they are scaled or rotated. Specifies the hotspot's location within the drawable. Sets the bounds to which the hotspot is constrained, if they should be different from the drawable bounds. Set the layout direction for this drawable. Specify the level for the drawable. Specify a set of states for the drawable. Specifies tint color for this drawable as a color state list. Set whether this Drawable is visible. Use the current implementation to have this Drawable unscheduled. Creates and returns a copy of this object. Indicates whether some other object is \"equal to\" this one. Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. Returns the runtime class of this . Returns a hash code value for the object. Wakes up a single thread that is waiting on this object's monitor. Wakes up all threads that are waiting on this object's monitor. Causes the current thread to wait until it is awakened, typically by being notified or interrupted, or until a certain amount of real time has elapsed. Causes the current thread to wait until it is awakened, typically by being notified or interrupted, or until a certain amount of real time has elapsed. Causes the current thread to wait until it is awakened, typically by being notified or interrupted.\n\nMay be a dimension value, which is a floating point number appended with a unit such as \" \". Available units are: px (pixels), dp (density-independent pixels), sp (scaled pixels based on preferred font size), in (inches), and mm (millimeters).\n\nDefines the color of the shape.\n\nMay be a color value, in the form of \" \", \" \", \" \", or \" \".\n\nDefines the height of the shape.\n\nMay be a dimension value, which is a floating point number appended with a unit such as \" \". Available units are: px (pixels), dp (density-independent pixels), sp (scaled pixels based on preferred font size), in (inches), and mm (millimeters).\n\nMay be a dimension value, which is a floating point number appended with a unit such as \" \". Available units are: px (pixels), dp (density-independent pixels), sp (scaled pixels based on preferred font size), in (inches), and mm (millimeters).\n\nMay be a dimension value, which is a floating point number appended with a unit such as \" \". Available units are: px (pixels), dp (density-independent pixels), sp (scaled pixels based on preferred font size), in (inches), and mm (millimeters).\n\nMay be a dimension value, which is a floating point number appended with a unit such as \" \". Available units are: px (pixels), dp (density-independent pixels), sp (scaled pixels based on preferred font size), in (inches), and mm (millimeters).\n\nDefines the width of the shape.\n\nMay be a dimension value, which is a floating point number appended with a unit such as \" \". Available units are: px (pixels), dp (density-independent pixels), sp (scaled pixels based on preferred font size), in (inches), and mm (millimeters).\n\nThis method is deprecated.\n\n This method is no longer used in graphics optimizations Return the opacity/transparency of this Drawable. The returned value is one of the abstract format constants in : , , , or . An OPAQUE drawable is one that draws all all content within its bounds, completely covering anything behind the drawable. A TRANSPARENT drawable is one that draws nothing within its bounds, allowing everything behind it to show through. A TRANSLUCENT drawable is a drawable in any other state, where the drawable will draw some, but not all, of the content within its bounds and at least some content behind the drawable will be visible. If the visibility of the drawable's contents cannot be determined, the safest/best return value is TRANSLUCENT. Generally a Drawable should be as conservative as possible with the value it returns. For example, if it contains multiple child drawables and only shows one of them at a time, if only one of the children is TRANSLUCENT and the others are OPAQUE then TRANSLUCENT should be returned. You can use the method to perform a standard reduction of two opacities to the appropriate single output. Note that the returned value does not necessarily take into account a custom alpha or color filter that has been applied by the client through the or methods. Some subclasses, such as , , and , do account for the value of , but the general behavior is dependent upon the implementation of the subclass. int The opacity class of the Drawable. Value is , , , or\n\n[[[\"Easy to understand\",\"easyToUnderstand\",\"thumb-up\"],[\"Solved my problem\",\"solvedMyProblem\",\"thumb-up\"],[\"Other\",\"otherUp\",\"thumb-up\"]],[[\"Missing the information I need\",\"missingTheInformationINeed\",\"thumb-down\"],[\"Too complicated / too many steps\",\"tooComplicatedTooManySteps\",\"thumb-down\"],[\"Out of date\",\"outOfDate\",\"thumb-down\"],[\"Samples / code issue\",\"samplesCodeIssue\",\"thumb-down\"],[\"Other\",\"otherDown\",\"thumb-down\"]],[\"Last updated 2025-02-10 UTC.\"],[],[]]"
    },
    {
        "link": "https://github.com/codepath/android_guides/wiki/Drawables",
        "document": "A drawable resource is a general concept for a graphic that can be drawn to the screen. Drawables are used to define shapes, colors, borders, gradients, etc. which can then be applied to views within an Activity.\n\nThis is typically used for customizing the view graphics that are displayed within a particular view or context. Drawables tend to be defined in XML and can then be applied to a view via XML or Java.\n\nFor a list of the default drawables for every version of Android, see the androiddrawables site as an excellent reference.\n\nDrawables can be an initially overwhelming topic because there are many drawable types used in different situations such as drawing shapes, setting state behaviors for buttons, creating stretchable button backgrounds and creating compound drawable layers.\n\nThere are at least 17 types of drawables but there are five that are most important to understand:\n• Shape Drawables - Defines a shape with properties such as stroke, fill, and padding\n• StateList Drawables - Defines a list of drawables to use for different states\n• LayerList Drawables - Defines a list of drawables grouped together into a composite result\n• NinePatch Drawables - A PNG file with stretchable regions to allow proper resizing\n\nLet's explore these drawable file types one by one and take a look at examples of usage.\n\nThe Shape Drawable is an XML file that defines a geometric shape, including colors and gradients. This is used to create a complex shape that can then be attached as the background of a layout or a view on screen. For example, you can use a shape drawable to change the shape, border, and gradient of a button background.\n\nA shape is simply a collection of properties that are combined to describe a background. The shape can be described with properties such as for rounding, for backgrounds, for spacing, for background colors, and for border.\n\nHere's an example of drawing a rounded rectangle with a border in :\n\nand then applied to a TextView using the property:\n\nand the resulting view looks like:\n\nNote that drawables can be applied to any view and are usually set with the property referencing the drawable resource.\n\nShapes also support gradients backgrounds as well as supporting properties such as , , , . Different gradients such as radial, linear or sweep can be selected using the property.\n\nHere's an example of a simple linear gradient shape specified in :\n\napplied to a button and the resulting view looks like:\n\nYou can also setup radial-type gradients with:\n\nand applied to a TextView, this looks like:\n\nUsing solid color shapes and gradients we can customize the appearance of buttons, layouts and other views without requiring the use of any images. Note that custom shapes can be created at runtime using other shape drawable types using and .\n\nA StateListDrawable is a drawable object defined in XML that uses several different images to represent the same graphic, depending on the state of the object. For example, a Button widget can exist in one of several different states (pressed, focused, or neither) and, using a state list drawable, you can provide a different background image for each state. The state list supports different view states such as , , , , among many others. The illustration below shows all the major states that can be represented:\n\nFor example, a state list XML for a button background might look like the following in a file such as :\n\nNow, when the view (i.e button) is pressed or focused, the drawable used for the view will change accordingly. Note that any view can have a state selector, but the most common uses are with buttons and listview items. There are also color state selectors which allow a color to be chosen based on view state such as in a file named :\n\nand applied to any field that accepts a color value such as the property of a button in a layout file:\n\nUsing state lists allows us to easily define dynamic views that respond to pressed, checked, enabled or other related states.\n\nA LayerDrawable is a drawable object that manages an array of other drawables. Each drawable in the list is drawn in the order of the list—the last drawable in the list is drawn on top. Each drawable is represented by an element inside a single element.\n\nThe LayerList can be used to draw multiple other drawables (shapes, images, etc) and position them in relationship to one another. The layers are placed on top of one another by default with the last item being drawn on the top. Layers can then have their coordinates shifted using the , , , and properties.\n\nFor a simple example, the following layer list draws several shapes in relation to each other:\n\nand this results in the following:\n\nKeep in mind that the items in a LayerList can also be images or any other type of drawable. You can use this to create more complex drawings and overlay multiple drawables on top of each other. See more examples within the official docs.\n\nA NinePatch is a PNG image in which you can define stretchable regions that are stretched when the content within the View exceeds the normal image bounds. You typically assign this type of image as the background of a View which has its width set to . The most common use is a button that has to stretch based on the text displayed inside.\n\nNinePatch are images that have a file extension, which signifies that this is a stretchable PNG image. The file is no different from a normal PNG file except that you will add thin black lines to indicate the vertical and horizontal \"stretchable\" and \"fill\" areas for the image. Android will not show these guide lines, which are used to determine how the image should be rendered.\n\nAn example of a 9-patch image is embedded below (left is the 9patch graphic, right is an example of use in an app):\n\nA NinePatch is defined and saved in the folder and setting the background works the same as with any image:\n\nAndroid Studio comes with the ability to edit 9-patch files directly. Your PNG file simply needs to be saved with the extension in the folder, and the 9-patch editor will display instead of the normal image editor. You can use the mouse to select the regions to be stretched (use Shift and click while dragging the mouse to erase the region), and the preview pane on the right displays how images will be rendered depending on the text inside.\n\nThe left and top lines need to be defined for the stretchable regions. To avoid stretching the arrow of this speech bubble in the above example, we define regions outside this area. The right and bottom lines define where text can be filled. Without the bottom line for instance, your text will not fill up the entire width of the stretched region and may not be centered properly.\n\nYou can also use the draw9patch tool to create special nine-patch images or you can use the online 9-patch utility. You can check out great ready-made examples of pretty 9-patch buttons for examples.\n\nSee this simple guide for more information. You can also refer to the official nine-patch docs.\n\nThese are XML drawables that can define complex vector-based images which can scale to support all densities automatically. This means using vector-based images, you will need only one asset file as opposed to an asset file for each screen density in the case of bitmap images.\n\nFirst, see the setup guide to enable support for vector drawables for pre-Lollipop devices.\n\nTo create a vector image, you need to define pathData syntax which is located here. This example defines the details of the shape inside a XML element such as with:\n\nWe can then load vectors using the property:\n\nNote: Be sure to use to support older Android devices. If you use for a vector drawable, your app may render correctly in newer devices but may crash in pre-Lollipop devices.\n\nThis results in the following image being rendered:\n\nYou can also set a vector at runtime using:\n\nBe sure to check out this great age of vectors blog post for a more detailed look at vectors. Also see the official release blog post for additional compatibility notes and this video talk.\n\nVector drawables can now be found directly within Android Studio and also on many Android resource websites. Assuming you have updated to Android Studio v2.2, you can check for vector drawables inside the wizard:\n\nYou can find additional icons on the material design icons website which includes community-contributed icons as well.\n\nLearn more about finding icons here for use within your app.\n\nIn addition, there are several ways to create vector drawables directly from SVG graphics:\n• Vector Asset Studio is a utility included in Android Studio (shown above) for converting SVG assets into vector drawables.\n• SVG2Android Online Utility converts SVG into vectors right in your browser.\n• Vectorizer - Transform a PNG image into an SVG to be converted to a vector drawable.\n\nYou can refer to this VectorDrawables guide for more details.\n\nLet's take a look at an end-to-end example of customizing a button using drawables to govern the styling and the pressed states.\n\nCreating a custom button require combining at least a state list drawable with a shape drawable. First, let's create our shape drawable which represents the \"default\" button background in :\n\nLet's also create a style (set of view properties) that includes setting the background in :\n\nThis now represents the shape and background of the button in the default state along with all the other properties. We could apply this by setting the of the button:\n\nIf we run that, we will see the following button:\n\nNow the button shows up nicely but doesn't have any \"pressed\" or \"focused\" states. To do this, we need to create a State List drawable that describes the drawables for each state in :\n\nThis describes the look of the button in all three major states (default, pressed and focused). Now we need to create two more Shape drawable states. One for and another for :\n\nFor this guide the pressed and focused states will appear the same but of course these could be distinct visual states as well. Now, we need to change the style to use the :\n\nNow we have a button that has a nice shape drawable background and changes visual state when pressed all without requiring a single image asset! Be sure to check out the Button Generator for a tool that allows you to make your own buttons via a web interface.\n\nAnother common task is customizing the appearance of items in a ListView. First let's create the basic ListView and populate String items inside. First, the layout XML for the item in :\n\nNext, let's setup the basic ListView xml in an activity:\n\nand then populate the ListView with items:\n\nThis results in the following default styles ListView:\n\nNow, let's add our own styling to the ListView. Let's add a default gradient and a pressed gradient, change the divider color between items and add a border around the ListView. First, let's add the shape gradient background for the default state in :\n\nand then for the pressed gradient background in :\n\nand then let's create a state list which describes the drawables to use in various list states in :\n\nNext, let's setup the border for our ListView using a Shape drawable in by setting the \"stroke\" property:\n\nLet's now apply each of these XML drawables to the various elements. First, let's add the background to the list item itself and tweak :\n\nNotice that the property has been set to the states list in order to apply the default background for the item. Next, let's add the border and the selector states to the existing ListView in the activity layout file:\n\nHere we have customized the color and as well as the to apply the border and to manage the states when an item is pressed. With all this in place, our customized ListView now looks like:\n\nWe've now successfully customized the appearance of our ListView and it's items using a series of drawables. You can use these techniques to make a list look however you want based on the needs for your app.\n\nWe can access drawables at runtime within our Java code by accessing the background of a view that has the drawable applied. For example, given this layer list at :\n\nWe can then access the by the specified id from within our activity:\n\nNote that the shape is accessed as a here even though the shape is a solid color.\n\nIf you are using vector drawables or animated vector drawables at runtime for pre-Lollipop devices, make sure to use the new class instead of the normal call, especially if you reference custom theme attributes (i.e. `?attr/colorAccent) in your drawables:\n\nStarting in Android 5.0 and above, a tint color can now be applied to drawables. The advantage is that images to be styled according to the current theme used. For instance, in Twitter's recent Android UI update, most of the images are stored as vector drawables in black color:\n\nHere is the corresponding vector drawable:\n\nFirst, we add the color to our file:\n\nThe simplest way to change this vector drawable to be blue is to apply an attribute to the tag.\n\nWe can also apply this change dynamically:\n\nNote that tinting color used can also use a state list drawable. For instance, if we wish for the tint to be change colors depending on whether the icon has been selected, we can create a :\n• LevelList - A Drawable that manages a number of alternate Drawables, each assigned a maximum numerical value.\n• TransitionDrawable - A drawable object that can cross-fade between the two drawable resources. Used for animating between two drawables.\n• InsetDrawable - A drawable defined in XML that insets another drawable by a specified distance. This is useful when a View needs a background that is smaller than the View's actual bounds.\n• ClipDrawable - A drawable defined in XML that clips another drawable based on this Drawable's current level. Most often used to implement things like progress bars.\n• ScaleDrawable - A drawable defined in XML that changes the size of another drawable based on its current level."
    },
    {
        "link": "https://developer.android.com/reference/android/graphics/drawable/Drawable",
        "document": "This class can also be created via XML inflation using <adaptive-icon> tag in addition to dynamic creation.\n\nA Drawable that can rotate another Drawable based on the current level value.\n\nA Drawable is a general abstraction for \"something that can be drawn.\" Most often you will deal with Drawable as the type of resource retrieved for drawing things to the screen; the Drawable class provides a generic API for dealing with an underlying visual resource that may take a variety of forms. Unlike a , a Drawable does not have any facility to receive events or otherwise interact with the user.\n\nIn addition to simple drawing, Drawable provides a number of generic mechanisms for its client to interact with what is being drawn:\n\nThough usually not visible to the application, Drawables may take a variety of forms:\n\nAll versions of Android allow the Drawable class to be extended and used at run time in place of framework-provided drawable classes. Starting in , custom drawables classes may also be used in XML.\n\nNote: Custom drawable classes are only accessible from within your application package. Other applications will not be able to load them.\n\nAt a minimum, custom drawable classes must implement the abstract methods on Drawable and should override the method to draw content.\n\nCustom drawables classes may be used in XML in multiple ways:\n\nFor more information about how to use drawables, read the Canvas and Drawables developer guide. For information and examples of creating drawable resources (XML or bitmap files that can be loaded in code), read the Drawable Resources document.\n\nApplies the specified theme to this Drawable and its children. Removes the color filter for this drawable. Return a copy of the drawable's bounds in a new Rect. Return a copy of the drawable's bounds in the specified Rect (allocated by the caller). This method was deprecated in API level 28. Prefer the version without an Options object. Create a drawable from an inputstream, using the given resources and value to determine density information. Create a drawable from an XML document using an optional . Create a drawable from inside an XML document using an optional . Draw in its bounds (set via setBounds) respecting optional effects such as alpha (set via setAlpha) and color filter (set via setColorFilter). Gets the current alpha value for the drawable. Return the current implementation attached to this Drawable. Return a mask of the configuration parameters for which this drawable may change, requiring that it be re-created. Returns the current color filter, or if none set. Return a instance that holds the shared state of this Drawable. Returns the resolved layout direction for this Drawable. Returns the minimum height suggested by this Drawable. Returns the minimum width suggested by this Drawable. This method was deprecated in API level 29. This method is no longer used in graphics optimizations Return in insets the layout insets suggested by this Drawable for use with alignment operations during layout. Called to get the drawable to populate the Outline that defines its drawing area. Return in padding the insets suggested by this Drawable for placing content inside the drawable's bounds. Describes the current state, as a union of primitive states, such as , , etc. Returns a Region representing the part of the Drawable that is completely transparent. Indicates whether this drawable has at least one state spec explicitly specifying . Inflate this Drawable from an XML resource optionally styled by a theme. Inflate this Drawable from an XML resource. Use the current implementation to have this Drawable redrawn. Tells if this Drawable will be automatically mirrored when its layout direction is RTL right-to-left. Indicates whether this drawable will change its appearance based on state. If this Drawable does transition animations between states, ask that it immediately jump to the current state and skip any active animations. Called when the drawable's resolved layout direction changes. Return the appropriate opacity value for two source opacities. Use the current implementation to have this Drawable scheduled. Specify an alpha value for the drawable. Set whether this Drawable is automatically mirrored when its layout direction is RTL (right-to left). Specify a bounding rectangle for the Drawable. Specify a bounding rectangle for the Drawable. Set a mask of the configuration parameters for which this drawable may change, requiring that it be re-created. This method was deprecated in API level 29. use with an instance of Specify an optional color filter for the drawable. This method was deprecated in API level 23. This property is ignored. Set to true to have the drawable filter its bitmaps with bilinear sampling when they are scaled or rotated. Specifies the hotspot's location within the drawable. Sets the bounds to which the hotspot is constrained, if they should be different from the drawable bounds. Set the layout direction for this drawable. Specify the level for the drawable. Specify a set of states for the drawable. Specifies tint color for this drawable as a color state list. Set whether this Drawable is visible. Use the current implementation to have this Drawable unscheduled.\n\nThis method was deprecated in API level 29.\n\n This method is no longer used in graphics optimizations Return the opacity/transparency of this Drawable. The returned value is one of the abstract format constants in : , , , or . An OPAQUE drawable is one that draws all all content within its bounds, completely covering anything behind the drawable. A TRANSPARENT drawable is one that draws nothing within its bounds, allowing everything behind it to show through. A TRANSLUCENT drawable is a drawable in any other state, where the drawable will draw some, but not all, of the content within its bounds and at least some content behind the drawable will be visible. If the visibility of the drawable's contents cannot be determined, the safest/best return value is TRANSLUCENT. Generally a Drawable should be as conservative as possible with the value it returns. For example, if it contains multiple child drawables and only shows one of them at a time, if only one of the children is TRANSLUCENT and the others are OPAQUE then TRANSLUCENT should be returned. You can use the method to perform a standard reduction of two opacities to the appropriate single output. Note that the returned value does not necessarily take into account a custom alpha or color filter that has been applied by the client through the or methods. Some subclasses, such as , , and , do account for the value of , but the general behavior is dependent upon the implementation of the subclass. int The opacity class of the Drawable. Value is , , , or\n\n[[[\"Easy to understand\",\"easyToUnderstand\",\"thumb-up\"],[\"Solved my problem\",\"solvedMyProblem\",\"thumb-up\"],[\"Other\",\"otherUp\",\"thumb-up\"]],[[\"Missing the information I need\",\"missingTheInformationINeed\",\"thumb-down\"],[\"Too complicated / too many steps\",\"tooComplicatedTooManySteps\",\"thumb-down\"],[\"Out of date\",\"outOfDate\",\"thumb-down\"],[\"Samples / code issue\",\"samplesCodeIssue\",\"thumb-down\"],[\"Other\",\"otherDown\",\"thumb-down\"]],[\"Last updated 2025-02-10 UTC.\"],[],[]]"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/android.graphics.drawables.shapedrawable?view=net-android-35.0",
        "document": "A Drawable object that draws primitive shapes. A ShapeDrawable takes a object and manages its presence on the screen. If no Shape is given, then the ShapeDrawable will default to a .\n\nThis object can be defined in an XML file with the element.\n\nFor more information about how to use ShapeDrawable, read the Canvas and Drawables document. For more information about defining a ShapeDrawable in XML, read the Drawable Resources document.\n\nPortions of this page are modifications based on work created and shared by the Android Open Source Project and used according to terms described in the Creative Commons 2.5 Attribution License.\n\nGets the current alpha value for the drawable. (Inherited from Drawable) Tells if this Drawable will be automatically mirrored when its layout direction is RTL right-to-left. -or- Set whether this Drawable is automatically mirrored when its layout direction is RTL (right-to left). (Inherited from Drawable) Return the drawable's bounds Rect. -or- Specify a bounding rectangle for the Drawable. (Inherited from Drawable) Return the current implementation attached to this Drawable. (Inherited from Drawable) Return a mask of the configuration parameters for which this drawable may change, requiring that it be re-created. -or- Set a mask of the configuration parameters for which this drawable may change, requiring that it be re-created. (Inherited from Drawable) Returns the runtime class of this . (Inherited from Object) Returns the current color filter, or if none set. (Inherited from Drawable) The handle to the underlying Android instance. (Inherited from Object) Indicates whether this drawable has at least one state spec explicitly specifying . (Inherited from Drawable) Indicates whether this drawable will change its appearance based on state. (Inherited from Drawable) Returns the resolved layout direction for this Drawable. (Inherited from Drawable) Returns the minimum height suggested by this Drawable. (Inherited from Drawable) Returns the minimum width suggested by this Drawable. (Inherited from Drawable) Return the opacity/transparency of this Drawable. Return in insets the layout insets suggested by this Drawable for use with alignment operations during layout. (Inherited from Drawable) Returns the Paint used to draw the shape. Returns the Shape of this ShapeDrawable. -or- Sets the Shape of this ShapeDrawable. This API supports the Mono for Android infrastructure and is not intended to be used directly from your code. This API supports the Mono for Android infrastructure and is not intended to be used directly from your code. Returns a Region representing the part of the Drawable that is completely transparent. (Inherited from Drawable)"
    },
    {
        "link": "https://stackoverflow.com/questions/16161448/how-to-make-layout-with-rounded-corners",
        "document": "I think a better way to do it is to merge 2 things:\n• None make a bitmap of the layout, as shown here.\n• None make a rounded drawable from the bitmap, as shown here\n• None set the drawable on an imageView.\n\nThis will handle cases that other solutions have failed to solve, such as having content that has corners.\n\nI think it's also a bit more GPU-friendly, as it shows a single layer instead of 2 .\n\nThe only better way is to make a totally customized view, but that's a lot of code and might take a lot of time. I think that what I suggested here is the best of both worlds.\n\nHere's a snippet of how it can be done:\n\nEDIT: found a nice alternative, based on \"RoundKornersLayouts\" library. Have a class that will be used for all of the layout classes you wish to extend, to be rounded:\n\nThen, in each of your customized layout classes, add code similar to this one:\n\nIf you wish to support attributes, use this as written on the library:\n\nAnother alternative, which might be easier for most uses: use MaterialCardView . It allows customizing the rounded corners, stroke color and width, and elevation.\n\nDo note that there is a slight artifacts issue at the edges of the stroke (leaves some pixels of the content there), if you use it. You can notice it if you zoom in. I've reported about this issue here.\n\nEDIT: seems to be fixed, but not on the IDE. Reported here."
    },
    {
        "link": "https://stackoverflow.com/questions/61881906/constraintlayout-set-rounded-corner-by-shape-resource-file-doesnt-work",
        "document": "I have met a strange problem, It didn't work when I set layout used for adapter item corners by resource file.\n\nThis is my resource file\n\nThis is my adapter item layout\n\nThis is my for display the above item layout\n\nThis is my Adapter\n\nAny ideas for this odd problem? Thank you in advance!"
    },
    {
        "link": "https://developer.android.com/develop/ui/compose/graphics/draw/shapes",
        "document": "With Compose, you can create shapes that are made from polygons. For example, you can make the following kinds of shapes:\n\nTo create a custom rounded polygon in Compose, add the dependency to your :\n\nThis library lets you create shapes that are made from polygons. While polygonal shapes have only straight edges and sharp corners, these shapes allow for optional rounded corners. It makes it simple to morph between two different shapes. Morphing is difficult between arbitrary shapes, and tends to be a design-time problem. But this library makes it simple by morphing between these shapes with similar polygonal structures.\n\nThe following snippet creates a basic polygon shape with 6 points in the center of the drawing area:\n\nIn this example, the library creates a which holds the geometry representing the requested shape. In order to draw that shape in a Compose app, you must get a object from it to get the shape into a form which Compose knows how to draw.\n\nTo round the corners of a polygon, use the parameter. This takes two parameters, and . Each rounded corner is made up of 1-3 cubic curves, the center of which has a circular arc shape while the two side (\"flanking\") curves transition from the shape's edge to the center curve.\n\nThe is the radius of the circle used to round a vertex.\n\nFor example, the following rounded corner triangle is made as follows:\n\nSmoothing is a factor which determines how long it takes to get from the circular rounding portion of the corner to the edge. A smoothing factor of 0 (unsmoothed, the default value for ) results in purely circular corner rounding. A nonzero smoothing factor (up to the max of 1.0) results in the corner being rounded by three separate curves.\n\nFor example, the snippet below illustrates the subtle difference in setting smoothing to 0 versus 1:\n\nBy default, a shape is created with a radius of around the center ( ). This radius represents the distance between the center and the exterior vertices of the polygon on which the shape is based. Note that rounding the corners results in a smaller shape since the rounded corners will be closer to the center than the vertices being rounded. To size a polygon, adjust the value. To adjust the position, change the or of the polygon. Alternatively, transform the object to change its size, position, and rotation using standard transformation functions such as .\n\nA object is a new shape representing an animation between two polygonal shapes. To morph between two shapes, create two and a object that takes these two shapes. To calculate a shape between the start and end shapes, provide a value between zero and one to determine its form between the starting (0) and ending (1) shapes:\n\nIn the above example, the progress is exactly halfway between the two shapes (rounded triangle and a square), producing the following result:\n\nIn most scenarios, morphing is done as part of an animation, and not just a static rendering. To animate between these two, you can use the standard Animation APIs in Compose to change the progress value over time. For example, you can infinitely animate the morph between these two shapes as follows:\n\nIt's common to use the modifier in Compose to change how a composable is rendered, and to take advantage of shadows that draw around the clipping area:\n\nYou can then use the polygon as a clip, as shown in the following snippet:\n\nThis results in the following:\n\nThis may not look that different from what was rendering before, but it allows for leveraging other features in Compose. For example, this technique can be used to clip an image and apply a shadow around the clipped region:\n\nYou can use the library to create a button that morphs between two shapes on press. First, create a that extends , scaling and translating it to fit appropriately. Note the passing in of the progress so that the shape can be animated:\n\nTo use this morph shape, create two polygons, and . Create and remember the . Then, apply the morph to the button as a clip outline, using the on press as the driving force behind the animation:\n\nThis results in the following animation when the box is tapped:\n\nTo endlessly animate a morph shape, use . Below is an example of a profile picture that changes shape (and rotates) infinitely over time. This approach uses a small adjustment to the shown above:\n\nThis code gives the following fun result:\n\nIf shapes created from regular polygons don't cover your use case, you can create a more custom shape with a list of vertices. For example, you may want to create a heart shape like this:\n\nYou can specify the individual vertices of this shape using the overload that takes a float array of x, y coordinates.\n\nTo break down the heart polygon, notice that the polar coordinate system for specifying points makes this easier than using the cartesian (x,y) coordinate system, where starts on the right hand side, and proceeds clockwise, with at the 12 o'clock position:\n\nThe shape can now be defined in an easier way by specifying the angle (𝜭) and radius from the center at each point:\n\nThe vertices can now be created and passed to the function:\n\nThe vertices need to be translated into cartesian coordinates using this function:\n\nThe preceding code gives you the raw vertices for the heart, but you need to round specific corners to get the chosen heart shape. The corners at and have no rounding, but the other corners do. To achieve custom rounding for individual corners, use the parameter:\n\nThis results in the pink heart:\n\nIf the preceding shapes don't cover your use case, consider using the class to draw a custom shape, or loading up an file from disk. The library is not intended for use for arbitrary shapes, but is specifically meant to simplify creation of rounded polygons and morph animations between them.\n\nFor more information and examples, see the following resources:\n• Blog: The Shape of Things to Come - Shapes"
    },
    {
        "link": "https://medium.com/androiddevelopers/the-shape-of-things-to-come-1c7663d9dbc0",
        "document": "Android offers a very flexible drawing API. In a custom , you can override and use the parameter to draw anything from lines to circles to rectangles, to complex objects. And if you want something rounded, you can create and draw any shape you want… as long you want a RoundRect.\n\nOf course, you can always (if you’re up for the effort) create a very complex shape (complete with arbitrary rounding) with the API. But out of the box, we give you only . Moreover, Android offers very little flexibility in terms of how those rects are rounded. That is, each of the corners of the rectangles are rounded with a circular curve… period. So if you want something more custom (either in the shape of the rounded corners or the number of vertices), you are on your own.\n\nWe thought it would be useful to provide simple creation of all kinds of rounded shapes. I mean, rectangles are cool and all. And so are those circular corners, right? They’re so… circular! But sometimes you want just a little more. Or even a lot more.\n\nWe also wanted these shapes to be available not just for apps running on future platform versions, but also across much older releases, for the enjoyment of all developers and users. So we created an API to do just that, by using objects internally. has been available since 1.0 and thus offers compatibility back as far as AndroidX itself goes.\n\nThe API for creating and drawing these shapes is simple (we saved all the complicated bits for the internal code which creates them). There are just a couple of different pieces to understand: creating a polygonal shape and specifying optional rounding parameters for the shape’s corners. I’ll cover these below.\n\nIt’s worth talking a little bit first about what we mean by “polygon.” In particular, it’s worth explaining what we mean when we use of the term, to show how we get to the much more complex (and interesting) shapes enabled by this library.\n\nwhich I find… not terribly helpful. I think mathematicians enjoy math so much that even when they’re writing words, it still sounds like equations. Let’s simplify this definition for the non mathematicians in the audience.\n\nIn its most basic form, a polygon is a 2D shape with edges and vertices (or “corners”). I usually think of polygons as having vertices that are ordered around some center, with all edges having the same length. Polygons can be much more complex than that, however, including shapes that can be self-intersecting.\n\nOur library’s polygons are, however, a bit more staid and boring, with vertices that are positioned equidistant from some center, marching around in order. All sides are of equal length and there are no funky self-intersections. (This constraint ends up being important in being able to handle automatic morphing between our shapes with reasonable results). You can think of the base object (which we will see in more detail below) as being a shape that has a center around which all of its vertices are positioned at some given radius away from that center.\n\nOur polygons can be a bit more complex as well. For one thing, the library has the concept of a “star polygon.” Star polygons are similar to polygons, except they have both an inner and outer radius, with vertices lying on one or the other, taking turns as the outline proceeds around the center.\n\nFinally, our polygons have the concept of “rounding.” Rounding is not strictly a polygonal concept, since mathematical polygons are defined to have straight edges and sharp corners. So we call our shapes “Rounded Polygons,” as a blend of the general concepts of polygons with the additional nuance of optionally rounded corners. Rounded polygons have a similar geometry as the shapes above, except that each vertex has optional parameters which describe how to round its corner. For example, here is a 5-sided star polygon, like the one above, but with rounding specified for corners formed by the vertices on its outer radius.\n\nThese, then, are the types of shapes that this library will produce: polygonal (ish) non-self-intersecting shapes where the vertices are ordered and equidistant from a radius (or two), with optionally rounded corners.\n\nNow let’s look at how to use the library’s API to create those shapes.\n\nNote: This article is current as of the alpha02 release. There will probably be minor API changes during the alpha phase; I will update the article when the API changes, and will update this release note accordingly.\n\nThe main class used to create a shape is . There are many different shapes you can create with this API, but all of them boil down to polygonal variations.\n\nThe way that you create a simple, unrounded* is by telling the API how many vertices you want and optionally providing a radius and center. Of course, any shape will have a radius and center, but by default the library creates canonical shapes with a radius of 1 around a center at . Note that you can transform (scale, translate, rotate) the canonical shape to get it to the size and location you want by calling .\n\n* At this point, you might be wondering why we have an API named “Rounded” which allows you to create an unrounded thing. The original version of the API handled that semantic difference, with a Polygon superclass and a RoundedPolygon subclass. But in the end, it was all a bit academic to split this functionality based on the meaning of the word “polygon,” so we went with a single class instead which handles all possibilities.\n\nAPI naming is hard, imperfect, and a perpetual source of regret.\n\nThe simplest use of the API involves passing in the number of vertices and letting the library do its thing. You can then call the function to resize and position the object and finally draw it into your custom view with an extension method provided by the library.\n\nHere’s an example which creates a five-sided figure with a radius of 200 and draws it with a given and object (created elsewhere):\n\nStar polygons (discussed earlier) are nearly as simple; the only extra thing needed is a second radius, which is provided via the parameter in the function. This inner radius is a value ranging from 0 to the value of (which is the “outer” radius for the shape).\n\nFor example, to create a five-sided star polygon with a radius of 100 and an inner radius halfway between the outer radius and the center, you would do this:\n\nSo all of this is nice. We’ve provided a simple API to create and draw regular and star polygons. But these are not the hard parts in this problem space; it’s not too difficult to create straight-edged, sharp-corner shapes like these with the existing APIs. The interesting (and tricky) part is how to round those corners.\n\nFiguring this out meant (in my case) re-learning a bunch of high-school level geometry and trigonometry (hey, it had been… a long time since I had those classes). Thing like trig identities, the Law of Cosines, and handy geometry facts like the angles of a triangle adding up to 180 degrees all came into play. Maybe I’ll write up that stuff sometime (or you can just look at the code and see where it ended up).\n\nBut the key part (for users of the library) is: how do you use the API to get nice, rounded shapes? Fortunately, the API (like so many APIs) is much simpler than the implementation. Creating a polygon, or star polygon, with rounded corners is nothing more than creating those shapes with the APIs described above, with additional information about how the corners should be rounded.\n\nTo accomplish this task, use the class which is responsible for determining how the corners should be rounded. It takes two parameters: and .\n\nis the radius of the circle used to round a vertex. This is similar to the radius parameters supplied to the existing method of , except it works in concert with the optional parameter (see below). For example, we can create this rounded triangle:\n\nwhere the rounding radius r for each of the corners can be pictured geometrically as follows:\n\nNote that a rounding radius produces a purely circular curve on the corner, between the two straight edges that meet at the vertex.\n\n“Smoothing,” unlike the corner rounding radius, is a new concept in our APIs. You can think of smoothing as a factor which determines how long it takes to get from the circular rounding portion of the corner to the edge. A smoothing factor of 0 (unsmoothed, the default value for ) results in purely circular corner rounding (if a nonzero radius is specified, as above). A nonzero smoothing factor (up to the max of 1.0) results in the corner being rounded by three separate curves. The center curve is the same circular arc produced by the rounding radius, explained above. But instead of that curve coming all the way to the polygon edges, there are now two “flanking” curves, which transition from the inner circular curve to the outer edges in smooth (non-circular) arcs of their own.\n\nThe magnitude of the smoothing curve determines both the length of the inner circular curve (more smoothing == smaller circular curve) and the length of the flanking curves (more smoothing == larger flanking curves). The flanking curves affect not only how much of the rounding happens on a circular path, but also the distance of the overall rounding curve. A larger smoothing factor pushes the intersection point of the rounding curve further along the edge toward the next vertex. A value of 1 (the max) results in no inner curve at all (the circular portion has length zero) and the maximum length of the flanking curves (which can extend as far as the next vertex, depending on the rounding parameters of that vertex).\n\nTo illustrate the impact of smoothing, it is helpful to look at a diagram showing the underlying curves. Note that all polygons are represented internally by a list of Bézier cubic curves, which are each defined by pairs of anchor and control points. These cubic curves are then used internally to create the objects responsible for drawing the shapes into the custom view.\n\n** I have to give a shout out to the that Bezier curve primer site linked here; it’s a vast treasure trove of information about all things Bézier, with proofs, equations, sample code, diagrams, live embedded demos, and thorough explanations. I return to it often to understand more in this complex and interesting space.\n\nLet’s look at some pictures to see what’s going on with the underlying curves. In the diagram below, the corner of the shape (the white object on the left) is represented on the right by the green line (the outline of the shape) and the white dashed line (a circle with the given rounding radius). The cubic curve is represented by pink circles that are anchor points, yellow circles that are control points for the curve, and yellow lines between the anchor and control points. If you’ve used drawing programs such as Adobe Illustrator, or even Keynote, you may have seen similar handle visuals when drawing curves.\n\nWhen we supply a non-zero smoothing factor, the rounded corner is created with three cubic curves: the circular curve (which we saw above in the unsmoothed case) plus two flanking curves which transition between the inner circular curve and the edges. Note that the flanking curves start further back along the edge than in the unsmoothed case. The resulting shape is shown by the white object on the right. The effects of smoothing can be quite subtle, but they allow much more flexibility for designers in producing smoothed shapes that go beyond the traditional circular-round shapes.\n\nI should note that although there are many separate segments which make up each rounded corner (two edges, two flanking curves, and one inner circular curve), the result is very, er, smooth because each curve is calculated to match the slope at the point where it joins the next segment. Thus, for example, the rounded corner smoothly transitions from the inner circular curve to the non-circular smoothing curve, and then again to the straight edge.\n\nBesides the constructors covered above, which all take the number of vertices, there is also a more general constructor which takes a list of vertices:\n\nThis constructor makes it possible for you to create shapes that… do not work well with the rest of our rounded-polygon assumptions. So don’t be surprised if you throw randomly complex lists of vertices at it and the results are not as pleasing as the more constrained polygons created by the other constructors.\n\nThis constructor exists to allow creation of more interesting polygonal shapes whose vertices are not all equidistant from some center point. For example, we can use the vertex-list constructor to create a triangle shape where the bottom edge bows in.\n\nThis triangle-ish shape is created with this code.\n\n(Don’t worry about the function above — or check it out in the sample project listed below if you are curious. It’s just a function that simplifies placing vertices around a center point at specific angles).\n\nAnd So On\n\nI talked specifically about a single parameter above, but the API allows you to specify multiple rounding parameters, including one for the inner and outer radii to get an effect like this on star polygons.\n\nYou can also, if you want to take it that far, define per-vertex rounding parameters, to get a very custom shape indeed. For any of these situations, the API allows you to easily create and draw all kinds of rounded (or unrounded) polygonal shapes. You could always do this on Android, of course. After all, we are just using the existing API underneath to handle the drawing. But there are a lot of details (and so much math!) to sort out along the way. This new library makes the job, we hope, far easier.\n\nOne of the things that drove the internal structure using cubic curves was the need to not just create and draw these shapes, but to also animate smoothly and automatically between them. Check out the next article, Shape Morphing in Android, to see how to do that with this library.\n\nThe library is available in alpha form on AndroidX:\n\nThe shape editing animation in the header was created with a sample app which demonstrates shape creation, editing, and morphing. It is hosted on GitHub:\n\nThe sample has both Compose and View apps, showing how to use the library to create and morph shapes in both kinds of UI toolkits. The Compose version has an additional editor view that helps visualize the various shape parameters."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-make-a-layout-with-rounded-corners-in-android",
        "document": "In this article, we will learn about How we can Make a Layout With rounded corners with the help of Drawables. We can create and use any type of shape for different UI Components because of the Flexibility of the Android. Various attractive designs for creating user interfaces can be created using a layout with rounded corners like:\n• For chat app for showing the messages.\n• To Make an attractive Bottom Sheet as we see in Many Apps.\n\nSo let’s start with the implementation, In this article, we will design a Simple Login Screen with a Rounded Shaped Layout.\n\nTo create a new project in Android Project just refer to this article on How to Create New Project in Android Studio. The code can be implemented in both Java and Kotlin Programming Language for Android.\n\nFirstly we will create a Simple Drawable file For The Rounded Shape.\n\nGo to res > drawable folder > Right Click on it and click on New > Drawable Resource file. In a pop up fill the Required details like file name And root element as shape(shown below image)\n\nSince there is no change in the Java/Kotlin MainActivity File, we’ve only provided the XML File Code.\n\nIn the above File, we have used an inner Relative layout with the drawable file we have set the background property of the inner relative layout as rounded_shape drawable so according to that file, the layout would be drawn on the screen.\n\nWe have also removed the action bar from the main activity by defining android:theme=”@style/Theme.MaterialComponents.NoActionBar” inside the manifest.xml file for the main activity."
    }
]