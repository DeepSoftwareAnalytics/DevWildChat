[
    {
        "link": "https://geeksforgeeks.org/taking-multiple-inputs-from-user-in-python",
        "document": "While taking a single input from a user is straightforward using the input() function, many real world scenarios require the user to provide multiple pieces of data at once. This article will explore various ways to take multiple inputs from the user in Python.\n\nOne of the simplest ways to take multiple inputs from a user in Python is by using the input() function along with the split() method. The split() method splits a string into a list based on a specified separator (by default, it uses whitespace).\n• .split() divides the string into separate components based on whitespace by default.\n• None The values are assigned to individual variables (x, y, z).\n\nLet’s take a look at other cases of taking multiple inputs from user in python:\n\nUsing List Comprehension (Multiple Inputs in One Line\n\nIf we want to ask the user for multiple values on a single line, we can use list comprehension combined with the input() function and split() to break the input into individual components. Also we can take inputs separated by custom delimiter which is comma in the below example.\n• input() function is used to take the user’s input as a string.\n• split() method splits the string based on whitespace (by default) into a list of strings.\n• [item for item in input().split()] takes each element in the split input and stores it in the list inputs.\n\nIf you need to collect multiple inputs in a single line and convert them into integers (or another data type), the map() function is useful. The map() function applies a specified function to each item in an iterable.\n• None to take a single line of input.\n• None method divides the string into a list of substrings.\n• None converts each element in the list to an integer.\n• None Finally, we convert the result back into a list to display the values.\n\nIf you want to collect multiple inputs from the user one at a time, you can use a loop. This is particularly useful when you need to collect an arbitrary number of inputs or perform validation on each input.\n• None We first ask how many items the user wants to input.\n• None We then use a loop to take inputs one by one, appending each input to a list.\n• None After the loop finishes, we print the collected items.\n• None This approach gives the user the flexibility to enter as many items as needed.\n\nHow to Take Multiple Inputs in Python?\n\nHow to Use\n\nHow to Split User Input in Python?\n\nYou can split the user input using the method. This is especially useful when the user inputs multiple values separated by spaces. If the user enters: , the output will be:\n\nWhat is the Use of\n\nThe function is used to apply a specific function to all items in an input list. This is useful for converting all input strings to integers or floats, for example. # Taking multiple numeric inputs in a single line and converting them to integers \n\n \n\n\n\n \n\n If the user enters: , the output will be:\n\nHow to Take Multiple Numeric Inputs in Python?"
    },
    {
        "link": "https://stackoverflow.com/questions/7378091/taking-multiple-integers-on-the-same-line-as-input-from-the-user-in-python",
        "document": "A common arrangement is to read one string at a time until the user inputs an empty string.\n\nThis is Python 3 code; for Python 2, you would use instead of .\n\nAnother common arrangement is to read strings from a file, one per line. This is more convenient for the user because they can go back and fix typos in the file and rerun the script, which they can't for a tool which requires interactive input (unless you spend a lot more time on basically building an editor into the script!)"
    },
    {
        "link": "https://stackoverflow.com/questions/65437582/how-do-i-read-multiple-integers-from-a-line-of-input-in-python-2",
        "document": "I am new to python. I searched and found out how to do it in python 3:\n\nbut in python 2 I get the syntax error. I need it for foobar because I can't code in c++ nor python 3 there which is incredibly annoying."
    },
    {
        "link": "https://docs.python.org/3/library/functions.html",
        "document": "The Python interpreter has a number of functions and types built into it that are always available. They are listed here in alphabetical order.\n\nOpen file and return a corresponding file object. If the file cannot be opened, an is raised. See Reading and Writing Files for more examples of how to use this function. file is a path-like object giving the pathname (absolute or relative to the current working directory) of the file to be opened or an integer file descriptor of the file to be wrapped. (If a file descriptor is given, it is closed when the returned I/O object is closed unless closefd is set to .) mode is an optional string that specifies the mode in which the file is opened. It defaults to which means open for reading in text mode. Other common values are for writing (truncating the file if it already exists), for exclusive creation, and for appending (which on some Unix systems, means that all writes append to the end of the file regardless of the current seek position). In text mode, if encoding is not specified the encoding used is platform-dependent: is called to get the current locale encoding. (For reading and writing raw bytes use binary mode and leave encoding unspecified.) The available modes are: open for writing, truncating the file first open for exclusive creation, failing if the file already exists open for writing, appending to the end of file if it exists The default mode is (open for reading text, a synonym of ). Modes and open and truncate the file. Modes and open the file with no truncation. As mentioned in the Overview, Python distinguishes between binary and text I/O. Files opened in binary mode (including in the mode argument) return contents as objects without any decoding. In text mode (the default, or when is included in the mode argument), the contents of the file are returned as , the bytes having been first decoded using a platform-dependent encoding or using the specified encoding if given. Python doesn’t depend on the underlying operating system’s notion of text files; all the processing is done by Python itself, and is therefore platform-independent. buffering is an optional integer used to set the buffering policy. Pass 0 to switch buffering off (only allowed in binary mode), 1 to select line buffering (only usable when writing in text mode), and an integer > 1 to indicate the size in bytes of a fixed-size chunk buffer. Note that specifying a buffer size this way applies for binary buffered I/O, but (i.e., files opened with ) would have another buffering. To disable buffering in , consider using the flag for . When no buffering argument is given, the default buffering policy works as follows:\n• None Binary files are buffered in fixed-size chunks; the size of the buffer is chosen using a heuristic trying to determine the underlying device’s “block size” and falling back on . On many systems, the buffer will typically be 4096 or 8192 bytes long.\n• None “Interactive” text files (files for which returns ) use line buffering. Other text files use the policy described above for binary files. encoding is the name of the encoding used to decode or encode the file. This should only be used in text mode. The default encoding is platform dependent (whatever returns), but any text encoding supported by Python can be used. See the module for the list of supported encodings. errors is an optional string that specifies how encoding and decoding errors are to be handled—this cannot be used in binary mode. A variety of standard error handlers are available (listed under Error Handlers), though any error handling name that has been registered with is also valid. The standard names include:\n• None to raise a exception if there is an encoding error. The default value of has the same effect.\n• None ignores errors. Note that ignoring encoding errors can lead to data loss.\n• None causes a replacement marker (such as ) to be inserted where there is malformed data.\n• None will represent any incorrect bytes as low surrogate code units ranging from U+DC80 to U+DCFF. These surrogate code units will then be turned back into the same bytes when the error handler is used when writing data. This is useful for processing files in an unknown encoding.\n• None is only supported when writing to a file. Characters not supported by the encoding are replaced with the appropriate XML character reference .\n• None (also only supported when writing) replaces unsupported characters with escape sequences. newline determines how to parse newline characters from the stream. It can be , , , , and . It works as follows:\n• None When reading input from the stream, if newline is , universal newlines mode is enabled. Lines in the input can end in , , or , and these are translated into before being returned to the caller. If it is , universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.\n• None When writing output to the stream, if newline is , any characters written are translated to the system default line separator, . If newline is or , no translation takes place. If newline is any of the other legal values, any characters written are translated to the given string. If closefd is and a file descriptor rather than a filename was given, the underlying file descriptor will be kept open when the file is closed. If a filename is given closefd must be (the default); otherwise, an error will be raised. A custom opener can be used by passing a callable as opener. The underlying file descriptor for the file object is then obtained by calling opener with (file, flags). opener must return an open file descriptor (passing as opener results in functionality similar to passing ). The following example uses the dir_fd parameter of the function to open a file relative to a given directory: 'This will be written to somedir/spamspam.txt' The type of file object returned by the function depends on the mode. When is used to open a file in a text mode ( , , , , etc.), it returns a subclass of (specifically ). When used to open a file in a binary mode with buffering, the returned class is a subclass of . The exact class varies: in read binary mode, it returns an ; in write binary and append binary modes, it returns an , and in read/write mode, it returns an . When buffering is disabled, the raw stream, a subclass of , , is returned. See also the file handling modules, such as , (where is declared), , , , and . The and arguments may have been modified or inferred from the original call.\n• None used to be raised, it is now an alias of .\n• None is now raised if the file opened in exclusive creation mode ( ) already exists.\n• None The file is now non-inheritable.\n• None If the system call is interrupted and the signal handler does not raise an exception, the function now retries the system call instead of raising an exception (see PEP 475 for the rationale).\n• None On Windows, opening a console buffer may return a subclass of other than . Changed in version 3.11: The mode has been removed.\n\nReturn a proxy object that delegates method calls to a parent or sibling class of type. This is useful for accessing inherited methods that have been overridden in a class. The object_or_type determines the method resolution order to be searched. The search starts from the class right after the type. For example, if of object_or_type is and the value of type is , then searches . The attribute of the class corresponding to object_or_type lists the method resolution search order used by both and . The attribute is dynamic and can change whenever the inheritance hierarchy is updated. If the second argument is omitted, the super object returned is unbound. If the second argument is an object, must be true. If the second argument is a type, must be true (this is useful for classmethods). When called directly within an ordinary method of a class, both arguments may be omitted (“zero-argument ”). In this case, type will be the enclosing class, and obj will be the first argument of the immediately enclosing function (typically ). (This means that zero-argument will not work as expected within nested functions, including generator expressions, which implicitly create nested functions.) There are two typical use cases for super. In a class hierarchy with single inheritance, super can be used to refer to parent classes without naming them explicitly, thus making the code more maintainable. This use closely parallels the use of super in other programming languages. The second use case is to support cooperative multiple inheritance in a dynamic execution environment. This use case is unique to Python and is not found in statically compiled languages or languages that only support single inheritance. This makes it possible to implement “diamond diagrams” where multiple base classes implement the same method. Good design dictates that such implementations have the same calling signature in every case (because the order of calls is determined at runtime, because that order adapts to changes in the class hierarchy, and because that order can include sibling classes that are unknown prior to runtime). For both use cases, a typical superclass call looks like this: # This does the same thing as: In addition to method lookups, also works for attribute lookups. One possible use case for this is calling descriptors in a parent or sibling class. Note that is implemented as part of the binding process for explicit dotted attribute lookups such as . It does so by implementing its own method for searching classes in a predictable order that supports cooperative multiple inheritance. Accordingly, is undefined for implicit lookups using statements or operators such as . Also note that, aside from the zero argument form, is not limited to use inside methods. The two argument form specifies the arguments exactly and makes the appropriate references. The zero argument form only works inside a class definition, as the compiler fills in the necessary details to correctly retrieve the class being defined, as well as accessing the current instance for ordinary methods. For practical suggestions on how to design cooperative classes using , see guide to using super()."
    },
    {
        "link": "https://geeksforgeeks.org/python-input-function",
        "document": "Python input() function is used to take user input. By default, it returns the user input in form of a string.\n\nRefer to all datatypes and examples from here.\n\nExample 1: Taking Name and Age of the user as input and printing it\n\nBy default, input returns a string. So the name and age will be stored as strings.\n\nExample 2: Taking two integers from users and adding them.\n\nIn this example, we will be looking at how to take integer input from users. To take integer input we will be using int() along with Python input()\n\nSimilarly, we can use float() to take two float numbers. Let’s see one more example of how to take lists as input\n\nExample 3: Taking Two lists as input and appending them\n\nTaking user input as a string and splitting on each character using list() to convert into list of characters.\n\nHow to use the\n\nCan we provide a basic example of using the\n\nHow to store the value entered by the user using the\n\nHow does the\n\nHow can we convert the input received from the\n\nYou can use the function to convert the input to an integer. Here’s an example: If you need to convert to other data types, you can use for floating-point numbers, for boolean values, etc."
    },
    {
        "link": "https://reddit.com/r/learnpython/comments/ky34rt/struggling_with_input_validation_in_loops",
        "document": "I'm required to write a program with a loop that asks the user to enter a series of positive numbers. The user should enter a negative number to signal the end of the series. After all the positive numbers have been entered, the program should display their sum.\n\nThe loop is not terminating with the code I have written. Instead it waits for the negative entries to be greater than the positive entries and then goes into an infinite loop.\n\nHere is the code -\n\nPlease guide me on how to progress.\n\nThanks for your time and help. Kind regards"
    },
    {
        "link": "https://p-kane.medium.com/input-validation-with-python-570953d5d297",
        "document": "Getting user inputs is one of the most crucial part of any program. What’s more important is to get the right type of input so that the program continues to run without problem.\n\nJust like any other programming language, you can easily write a block of code to validate and filter a user input to ensure the program takes the only correct type of input with Python. You can even create a loop that keeps sending a message to inform the user to input correctly before going to the next step.\n\nFor example, assuming that you need to create a program which takes an integer from the user to perform further operations, you’ll write the following block of code to transform any whole number input into an integer:\n\nTry an input any whole number with the above code and there’s no problem. The variable num stored any whole number you typed in as an integer. Great! The first layer of input validation is successfully pealed. Did I say layer? Yes. That’s because there can be many layers stacked on top of an input validation process, depending solely on what is needed for it to perform.\n\nThe code above will work fine as long as the user inptut a whole number. It breaks easily, however, when it gets something that is not a whole number such as ‘3.14’ or ‘pi’. In other words, the code above will throw an error message if the user give it anything but a whole number:\n\nWe can easily avoid the above error by using try and except as shown in the following code block to catch the error:\n\nAs we already know, without the try except block, the code will throw a ValueError error if the input is anything that can’t be converted into an integer by the int() function, so we specifically tell the try except block to catch this type of error in the code above. However, the program just ends and we need to restart the program again if we are to give it another input.\n\nA while loop can ease this pain. We can create a loop that will never stop telling the user to give the correct type of input until he/she does so:\n\nBasically, the above code tells the program to keep asking the user for a valid integer until it gets one. Once the input is correct, the loop is terminated with the break command. However, it will keep telling the user “Please input a valid integer.” until it gets one. This way, we don’t have to restart the program every time we give it a wrong input. And there’s no error message. The program keeps running (validating the input) smoothly even when we give wrong types of inputs. The second layer of the input validation process is cracked!\n\nIn general, the more specific an input, the more smoothly the program (or data processing) in the later phases will perform. Let’s say, for example, that we need to validate the input so that it’s an integer with the value ranges from 1 to 10 only, we can tweak the above code so that it will take only the said values like the following:\n\nSimply adding an if block that will tell the user to input a valid integer anytime when the value of the variable num is out of the 1–10 range does the trick of letting the program be even more specific about ingesting any input from the user based on the condition(s) in the if block.\n\nThe third layer is cracked!\n\nYou can also apply this knowledge in validating inputs of string type without having to down-cast it to any other data type as well, since the initial data type of the input() function is already string.\n\nLet’s say that, for some reason, you need a program to input a string with only 3 characters in length, you can write a block of code to validate the input according to the said condition like so:\n\nThe above code will keep asking the user for any input with specifically 3 characters in length. Anything less or more than 3-character long will be disregarded.\n\nThere you have it, some easy tricks to validate inputs and negate errors with Python.\n\nIn summary, there are basically 3 main layers for input validation:\n• Type-cast the input as needed just as the example of casting a string to an integer with the int() function.\n• Use the while loop to negate error, let the process of data validation runs smoothly until the program gets the correct type of input.\n• Create conditions so that the input is more tailored to what the user reallly needed. This layer is very important for the future data processing and operations. It minimalizes the chances of future possible errors!\n\nYou see how we can specifically handle the ValueError with the try except block. What if we don’t know what type of error will happen and we just want to handle an error? We can do so with the following code:\n\nIn the code above, we can use Exception to handle a variety of types of unexpected (or unknown) errors.\n\nI do hope you find this short article about input validation with Python useful an applicable with your works. Enjoy coding. Until next time!"
    },
    {
        "link": "https://stackoverflow.com/questions/70013270/how-do-i-make-a-validation-loop-to-make-sure-the-user-inputs-the-correct-amount",
        "document": "This may be kind of stupid but I've made a really roundabout way of validating a credit card number. I'm still really new at python and coding in general and wanted to make it so that I can validate the amount of digits, whether or not the input is numbers, and to also make it so I can print the input split up like this: xxx-xxxx-xxxx\n\nSo far I have this (please excuse how messy and probably unnecessary a lot of it is!)\n\nIt does the job for the most part except for the fact that if the user just inputs something like 4 4 or like a singular letter it will get a ValueError:\n\nBasically what I've been trying to do is create a validation that allows the loop to continue after the error and return to the start of the loop. I've tried a try except loop and it didn't work, I wanted to get a second opinion on this and maybe some help from somebody who understands what I'm trying to achieve with my code."
    },
    {
        "link": "https://geeksforgeeks.org/input-validation-in-python",
        "document": "Input validation ensures that data entered by the user is correct, safe, and in the expected format. In Python, input validation is essential for creating robust, error free programs that can handle incorrect or unexpected inputs. This article will cover the importance of input validation, common methods for validating input and practical examples in Python.\n\nPython provides several ways to validate user inputs.\n\nOne of the simplest methods to ensure the input is of the correct type is to use a try-except block. For example, when accepting numeric input, we can ensure that the user enters a valid integer.\n\nHere, if the user enters something that cannot be converted to an integer (like a string), a ValueError is raised, and the user is prompted again.\n\nUsing if Statements for Range Validation\n\nFor situations where you need to ensure the input is within a certain range, you can use a simple if statement.\n\nIn this case, the function will repeatedly prompt the user until they enter a valid age.\n\nFor more complex input validation, such as ensuring an email address or phone number follows a particular format, regular expressions (regex) are useful.\n\nHere, the regular expression pattern ensures that the input matches the typical structure of an email address."
    },
    {
        "link": "https://stackoverflow.com/questions/67341936/is-there-a-simpler-way-to-validate-user-input-in-python-without-repeating-while",
        "document": "I am currently learning python and I was wondering if there is an easier way to validate user input. I am working on a Body Mass Index calculator. Even though the code is working, I feel like this is not the best practice and that there is an easier way to validate user input without using multiple while loops.\n\nRight now my code is looking as follows."
    },
    {
        "link": "https://docs.python.org/3/tutorial/controlflow.html",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/conditional-statements-in-python",
        "document": "Conditional statements in Python are used to execute certain blocks of code based on specific conditions. These statements help control the flow of a program, making it behave differently in different situations.\n\nIf statement is the simplest form of a conditional statement. It executes a block of code if the given condition is true.\n\nShort-hand if statement allows us to write a single-line if statement.\n\nThis is a compact way to write an if statement. It executes the print statement if the condition is true.\n\nIf else Conditional Statements in Python\n\nElse allows us to specify a block of code that will execute if the condition(s) associated with an if or elif statement evaluates to False. Else block provides a way to handle all other cases that don't meet the specified conditions.\n\nThe short-hand if-else statement allows us to write a single-line if-else statement.\n\nNote: This method is also known as ternary operator. Ternary Operator essentially a shorthand for the if-else statement that allows us to write more compact and readable code, especially for simple conditions.\n\nelif statement in Python stands for \"else if.\" It allows us to check multiple conditions , providing a way to execute different blocks of code based on which condition is true. Using elif statements makes our code more readable and efficient by eliminating the need for multiple nested if statements.\n\nHere, the first condition x > 15 is False, so the elif condition x > 5 is checked next. Since it is True, the corresponding block is executed.\n\nNested if..else means an if-else statement inside another if statement. We can use nested if statements to check conditions within conditions.\n\nA ternary conditional statement is a compact way to write an if-else condition in a single line. It’s sometimes called a \"conditional expression.\"\n• None If age >= 18 is True, status is assigned \"Adult\".\n\nmatch-case statement is Python's version of a switch-case found in other languages. It allows us to match a variable's value against a set of patterns.\n• None Python If Else in One Line\n\nWhat are Conditional Statements in Python?\n\nWhat is a Conditional Expression in Python?\n\nWhat are Decision-Making Statements in Python?\n\nWhat are Conditional Selection Statements in Python?\n\nWhat are the Conditional Loops in Python?\n\nWhile Python supports loops that can incorporate conditions, the term \"conditional loops\" might specifically refer to loops that run based on a condition. Python provides two primary types of such loops:\n• None loop: Continues to execute as long as a given condition is true. It checks the condition before executing the loop body.\n• None loop: Iterates over a sequence (like a list, tuple or string) and executes the loop body for each item in the sequence. Although not traditionally a \"conditional\" loop, it can incorporate conditions using # for loop example with condition \n\n\n\n\n\n break # Exit the loop when i is 5 \n\n These explanations outline how Python uses conditional statements and expressions to manage the flow of execution and make decisions within programs, crucial for creating dynamic and responsive applications"
    },
    {
        "link": "https://w3schools.com/python/python_conditions.asp",
        "document": "\n• Less than or equal to:\n• Greater than or equal to:\n\nThese conditions can be used in several ways, most commonly in \"if statements\" and loops.\n\nAn \"if statement\" is written by using the if keyword.\n\nIn this example we use two variables, a and b, which are used as part of the if statement to test whether b is greater than a. As a is 33, and b is 200, we know that 200 is greater than 33, and so we print to screen that \"b is greater than a\".\n\nPython relies on indentation (whitespace at the beginning of a line) to define scope in the code. Other programming languages often use curly-brackets for this purpose.\n\nThe elif keyword is Python's way of saying \"if the previous conditions were not true, then try this condition\".\n\nIn this example a is equal to b, so the first condition is not true, but the elif condition is true, so we print to screen that \"a and b are equal\".\n\nThe else keyword catches anything which isn't caught by the preceding conditions.\n\nIn this example a is greater than b, so the first condition is not true, also the elif condition is not true, so we go to the else condition and print to screen that \"a is greater than b\".\n\nYou can also have an without the :\n\nIf you have only one statement to execute, you can put it on the same line as the if statement.\n\nIf you have only one statement to execute, one for if, and one for else, you can put it all on the same line:\n\nYou can also have multiple else statements on the same line:\n\nThe and keyword is a logical operator, and is used to combine conditional statements:\n\nThe keyword is a logical operator, and is used to combine conditional statements:\n\nThe keyword is a logical operator, and is used to reverse the result of the conditional statement:\n\nYou can have statements inside statements, this is called nested statements.\n\nstatements cannot be empty, but if you for some reason have an statement with no content, put in the statement to avoid getting an error."
    },
    {
        "link": "https://walker-data.com/geog30323/03-functions-and-iteration.html",
        "document": "Congratulations on completing your first Python assignment! You’ll be progressively building on those core skills throughout the semester.\n\nIn this week’s notebook, you are first going to learn about functions. Functions are in some ways the bread-and-butter of Python programming. They make code re-usable, as they allow you to apply your code in other contexts and circumstances. You can think about functions this way: while variables store elements of your code (e.g. numbers, strings, lists), functions can store entire chunks of your code, which can in turn be re-used as necessary.\n\nFunctions include a definition and parameters, and are specified with as follows:\n\nThe command allows you to introduce a function definition. You then specify the parameters within parentheses following the function name, which are like variables that operate within your function. A colon ( ) then follows the parentheses, and the contents of the function are found beginning on the next line as an indented code block (more on indentation soon).\n\nAfter you’ve defined the function, it can be called by supplying arguments to the parameters you’ve defined, again within parentheses. For example:\n\nSo how does this all work? Let’s try it out!\n\nAt a very basic level, you can define a function without parameters - an empty function. This function will return whatever you’ve specified after it is called.\n\nNow, we call the function:\n\nNotice what happened when we called our function. As the function has no parameters, it will always give us back 5. Naturally, you’re going to want your functions to get more complicated than this - which is what parameters are for. Let’s try out a function that has a parameter and performs a basic mathematical operation.\n\nThe function itself is fairly straightforward. Our new function, , takes a number, which we are calling . It divides by two, and then prints the result for us. By adding a parameter, however, our function is now re-usable. Let’s try it out:\n\nYou may have noticed that the statements that follow the function definitions above are indented. Python code obeys whitespace for code organization. In many languages, functions, loops, and conditional logic (which we’ll get to next week), etc. are organized with curly braces, like the equivalent R code below: The R code, like in many languages, is organized in relation to the position of the curly braces, not the positioning of the code itself per se. In Python, curly braces are not used in this capacity. Instead, code is organized by indentation and whitespace. Within a function definition, for example, the code to be executed by the function call should be indented with four spaces beneath the line that contains the statement. In many Python IDEs and the IPython Notebook, the software will already know this and indent your code accordingly. In addition, the Tab key is set to be equivalent to the four spaces in most of these software packages as well. Without proper indentation, however, your code will not run correctly. : expected an indented block after function definition on line 1\n\nLater in the semester, we’ll get started using external libraries to do our work, which have many pre-built functions for accomplishing data analysis tasks. Many of these functions are very flexible - which means they have a lot of parameters! It turn, it can be helpful to keep your code organized when you are working with multiple parameters in a function. There are a couple ways to supply multiple arguments to a function in Python:\n• None In the order they are specified in the function definition;\n• None As named arguments, in which both the parameter name and the argument are invoked. I’ll explain this further. Let’s define a function, , that takes two numbers and will subtract the second number from the first. Now, we call the function by supplying two arguments to it: We could get the same result by supplying named arguments to the function, which take the form of : Flipping the order of the arguments will give us a different result unless we name the arguments accordingly. Take a look: Be careful when mixing named and unnamed arguments, however. When arguments are unnamed, Python assumes that you are supplying them in the order of the corresponding parameters in the function definition. As such, you can mix named and unnamed arguments, but unnamed arguments cannot follow named arguments in a function call.\n\nYou’ve already learned how to use comments to document your code with the operator, like this: # I just commented out this line! Comments are generally best used for small descriptive statements about your code, or notes to yourself regarding something you’d like to remember. More formal documentation of your code - e.g. what you functions are supposed to do - are best handled through docstrings. Docstrings are enclosed in triple quotes ( ), and can go beneath the function definition to explain its components. Let’s try using a docstring to explain, in basic terms, the contents of our function. Subtract one number from another. x: The number you would like to subtract a quantity from (the minuend). y: The quantity you would like to subtract from x (the subtrahend). You’ve now created a new function, with associated help documentation. To view the documentation, you can use the built-in function to print the docstring, or type the function name followed by a question mark to pop up the documentation at the bottom of the screen. Try it out! Help on function subtract in module __main__: subtract(x, y) Subtract one number from another. Parameters: ----------- x: The number you would like to subtract a quantity from (the minuend). y: The quantity you would like to subtract from x (the subtrahend). # Create a new function, \"multiply\", that multiplies two numbers together. # Write a docstring in the function definition that describes what the function does, # and explains the parameters to the user. # Run your function and call it to test it out.\n\nThe above functions we’ve written perform the same operations for any input values that are passed to them. When writing programs, however, you’ll often have to design them to be flexible to user input where outcomes may vary based on what users supply to the program. In regards to data analysis, you might want to produce a particular type of chart if the data are structured a certain way, which wouldn’t work in another scenario. You can build this type of logic into your programs with conditional statements. Before we get into this, however, I want to introduce booleans in Python. You may have heard this term before in other classes. Booleans in Python are the values and ; they can be used to evaluate, understandably, if a condition is true or not. For example: In the above lines of code, we used basic mathematical operators to see if conditions are true or false. When we asked Python if 3 is greater than 2, it told us it was True; when we asked it if 2 is greater than 3, it said False. Such true/false logic can be used with conditional statements in your code. To do this, you’ll often use conditional operators, which you’ll be familiar with from basic mathematics, possibly with a couple exceptions. Conditional operators in Python are as follows:\n• None Greater than or equal to As humans, we use conditional logic all of the time without really thinking about it. For example, if I am hungry, I’ll probably go eat something; otherwise, I won’t. Such logic can be expressed in Python as a series of , (which means else if), and statements. Let’s try to express this now in code in basic terms. This is made-up code, so we don’t need to understand everything, but here are the basics of it. We define a function, , that measures the biological/psychological properties that govern hunger reflexes in the human body. We say, hypothetically, that a hunger index value encapsulating these properties that exceeds 100 means that a person is hungry; in turn, the function returns . Otherwise, it returns . We can then pass a variable , which represents my hunger index, to the function. The function then checks to see if I am hungry, and returns if I am, and otherwise. These results can then be embedded in other workflows, in which you program Python to perform different tasks depending on the function results. For example: As you can see above, this can be simplified in Python as the code checks to see if the returned value is . If I am hungry, the code calls an unseen function telling me to go eat; otherwise, it tells me to stay put with an unseen function. Simple enough, right? Not quite. I’m hungry right now, but I’m not currently eating. Why is that the case? Well… I have to get this assignment written for you! While I am hungry, my level of hunger is not so debilitating that I am unable to work, and I know that finishing my work is a higher priority than eating at the moment. In reality, there are countless conditions that influence whether we eat or not beyond simply how hungry we are. For example - is there food accessible? Are you in a place where it is socially acceptable to eat? Perhaps you are at a party where pizza is available - you aren’t hungry, but you eat it anyway? Your brain processes all of this conditional logic at once as you make decisions, so we aren’t always used to thinking explicitly about conditionals in such discrete ways. However, to get a computer to understand this, you have to make it explicit in your code! The function we defined above used conditional logic, telling Python to return or depending on the value of the hunger index. Note that the statement starts on a new indented line of code beneath the function definition, and itself is followed by a colon; the code associated with the statement then follows on another, indented line of code. The same goes for the statement beneath it. You should be getting a sense now of style rules in Python, and the importance of whitespace for code organization, which applies to conditional statements as well. Now I’d like you to try to replicate this yourself! Define a function called that checks to see if a number is greater than 2 or not. Call the function.\n\nIn programming, you will often want to do an operation multiple times, or carry out some process over a list of values that you’ve created. To do this, you will frequently turn to iterators. The most commonly used iterators in Python are and . A loop carries out an action, or set of actions, for every element that you tell it to. Let’s give it a try in very simple terms. I’ve created a list of teams in the Big 12 below; we’ll loop through this list with and concatenate another string to each element. # You can read this here as \"for every team in the Big 12.... # ... print the name of the team along with \"are in the Big 12.\" TCU Horned Frogs are in the Big 12. Baylor Bears are in the Big 12. Oklahoma Sooners are in the Big 12. Oklahoma State Cowboys are in the Big 12. Texas Longhorns are in the Big 12. Texas Tech Red Raiders are in the Big 12. West Virginia Mountaineers are in the Big 12. Kansas Jayhawks are in the Big 12. Kansas State Wildcats are in the Big 12. Iowa State Cyclones are in the Big 12. A couple notes about the above code. Notice that I’m using as a temporary variable that will successively store each value of the list as we loop through it. This variable, , takes on each value of the list in turn; and presently stores the last value of the list. As such, this is how the loop works. tells Python to evaluate every element of the list ; these elements will be represented by the variable . The loop then walks through the list and prints the specified text for every element in the list. This loop is equivalent, then, to: \"TCU Horned Frogs are in the Big 12\" \"Baylor Bears are in the Big 12\" \"Oklahoma Sooners are in the Big 12\" but you don’t really want to do that manually, especially when you might have thousands of strings to evaluate. In turn, the loop does the work for you, which is one of the main benefits of programming. Also, I’d like you to notice the structure of the loop. Like functions, loops obey whitespace rules for code organization, and will fail if your code is not properly indented. The first line of the loop - in this case - is not indented, and is followed by a colon. Everything else contained in the loop is found in an indented block on the line(s) following the loop call. As with functions, your loop will fail without proper indentation. : expected an indented block after 'for' statement on line 1 Now let’s say you want to create a new list of the “…are in the Big 12” elements. There are a couple ways to do this. In the first, you define an empty list object, then populate the list with the for loop and the method, as shown below. # The empty brackets designate an empty list, which you'll fill up with the loop. ['TCU Horned Frogs are in the Big 12.', 'Baylor Bears are in the Big 12.', 'Oklahoma Sooners are in the Big 12.', 'Oklahoma State Cowboys are in the Big 12.', 'Texas Longhorns are in the Big 12.', 'Texas Tech Red Raiders are in the Big 12.', 'West Virginia Mountaineers are in the Big 12.', 'Kansas Jayhawks are in the Big 12.', 'Kansas State Wildcats are in the Big 12.', 'Iowa State Cyclones are in the Big 12.'] You can also do the same thing with something called list comprehension. List comprehension allows for the creation of a new list with one line of code. In this case, the loop is embedded within the statement you make. Below is an example: ['TCU Horned Frogs are in the Big 12.', 'Baylor Bears are in the Big 12.', 'Oklahoma Sooners are in the Big 12.', 'Oklahoma State Cowboys are in the Big 12.', 'Texas Longhorns are in the Big 12.', 'Texas Tech Red Raiders are in the Big 12.', 'West Virginia Mountaineers are in the Big 12.', 'Kansas Jayhawks are in the Big 12.', 'Kansas State Wildcats are in the Big 12.', 'Iowa State Cyclones are in the Big 12.'] You can use methods and functions in your list comprehension as well, as in the example below: Loops also work for strings - though in this case the loop will iterate through each character contained in your string. An example: The index of T is 0 The index of e is 1 The index of x is 2 The index of a is 3 The index of s is 4 The index of is 5 The index of C is 6 The index of h is 7 The index of r is 8 The index of i is 9 The index of s is 10 The index of t is 11 The index of i is 12 The index of a is 13 The index of n is 14 The index of is 15 The index of U is 16 The index of n is 17 The index of i is 18 The index of v is 19 The index of e is 20 The index of r is 21 The index of s is 22 The index of i is 23 The index of t is 24 The index of y is 25 is not the only loop you’ll come across in Python. You can also specify a loop, which will run a loop until a given condition is satisfied. I’ll give you an example below. Let’s say you only want to return the first five elements of your list. While you could do this with indexing (which is simpler), let’s try the loop instead. Have a look at what we did. We created an empty list, and set a new variable, , to 0. We then looped through the elements of the list index by index, adding 1 to with each run of the loop, and then stopping the code when became equal to 5. In turn, we got back the elements of the list indexed 0 to 4, which are the first five elements. Be careful with while loops, however. If you don’t specify them correctly, you can get stuck in an infinite loop, which will not stop! For example, if we had not continued to add 1 to , the loop would have never stopped and would have kept iterating through the list. This can cause your computer to lock up, as it is infinitely trying to carry out an operation! I’ve been there a few times…"
    },
    {
        "link": "https://openbookproject.net/books/bpp4awd/ch04.html",
        "document": "In order to write useful programs, we almost always need the ability to check conditions and change the behavior of the program accordingly. Conditional statements give us this ability. The simplest form is the if statement, which has the genaral form: A few important things to note about statements:\n• None The colon ( ) is significant and required. It separates the header of the compound statement from the body.\n• None The line after the colon must be indented. It is standard in Python to use four spaces for indenting.\n• None All lines indented the same amount after the colon will be executed whenever the BOOLEAN_EXPRESSION is true. 'I feel like saying it 100 times...' The boolean expression after the statement is called the condition. If it is true, then all the indented statements get executed. What happens if the condition is false, and is not equal to ? In a simple statement like this, nothing happens, and the program continues on to the next statement. Run this example code and see what happens. Then change the value of to something other than and run it again, confirming that you don’t get any output. Flowchart of an if statement As with the statement from the last chapter, the statement is a compound statement. Compound statements consist of a header line and a body. The header line of the statement begins with the keyword followed by a boolean expression and ends with a colon ( ). The indented statements that follow are called a block. The first unindented statement marks the end of the block. Each statement inside the block must have the same indentation. The Python community has developed a Style Guide for Python Code, usually referred to simply as “PEP 8”. The Python Enhancement Proposals, or PEPs, are part of the process the Python community uses to discuss and adopt changes to the language. PEP 8 recommends the use of 4 spaces per indentation level. We will follow this (and the other PEP 8 recommendations) in this book. To help us learn to write well styled Python code, there is a program called pep8 that works as an automatic style guide checker for Python source code. is installable as a package on Debian based GNU/Linux systems like Debian. In the Vim section of the appendix, Configuring Debian for Python Web Development, there is instruction on configuring vim to run on your source code with the push of a button. It is frequently the case that you want one thing to happen when a condition it true, and something else to happen when it is false. For that we have the statement. \"No, I won't have it. I want spam!\" Here, the first print statement will execute if is equal to , and the print statement indented under the clause will get executed when it is not. Flowchart of a if else statement The syntax for an statement looks like this: Each statement inside the block of an statement is executed in order if the boolean expression evaluates to . The entire block of statements is skipped if the boolean expression evaluates to , and instead all the statements under the clause are executed. There is no limit on the number of statements that can appear under the two clauses of an statement, but there has to be at least one statement in each block. Occasionally, it is useful to have a section with no statements (usually as a place keeper, or scaffolding, for code you haven’t written yet). In that case, you can use the statement, which does nothing except act as a placeholder. # so this is always executed, but it does nothing Python documentation sometimes uses the term suite of statements to mean what we have called a block here. They mean the same thing, and since most other languages and computer scientists use the word block, we’ll stick with that. Notice too that is not a statement. The statement has two clauses, one of which is the (optional) clause. The Python documentation calls both forms, together with the next form we are about to meet, the statement.\n\nOne conditional can also be nested within another. (It is the same theme of composibility, again!) We could have written the previous example as follows: The outer conditional contains two branches. The second branch contains another statement, which has two branches of its own. Those two branches could contain conditional statements as well. Although the indentation of the statements makes the structure apparent, nested conditionals very quickly become difficult to read. In general, it is a good idea to avoid them when you can. Logical operators often provide a way to simplify nested conditional statements. For example, we can rewrite the following code using a single conditional: # assume x is an int here The function is called only if we make it past both the conditionals, so we can use the operator: Python actually allows a short hand form for this, so the following will also work:\n\nComputers are often used to automate repetitive tasks. Repeating identical or similar tasks without making errors is something that computers do well and people do poorly. Repeated execution of a set of statements is called iteration. Python has two statements for iteration – the statement, which we met last chapter, and the statement. Before we look at those, we need to review a few ideas. As we saw back in the Variables are variable section, it is legal to make more than one assignment to the same variable. A new assignment makes an existing variable refer to a new value (and stop referring to the old value). The output of this program is because the first time is printed, its value is 5, and the second time, its value is 7. Here is what reassignment looks like in a state snapshot: With reassignment it is especially important to distinguish between an assignment statement and a boolean expression that tests for equality. Because Python uses the equal token ( ) for assignment, it is tempting to interpret a statement like as a boolean test. Unlike mathematics, it is not! Remember that the Python token for the equality operator is . Note too that an equality test is symmetric, but assignment is not. For example, if then . But in Python, the statement is legal and is not. Furthermore, in mathematics, a statement of equality is always true. If now, then will always equal . In Python, an assignment statement can make two variables equal, but because of the possibility of reassignment, they don’t have to stay that way: # after executing this line, a and b are now equal # after executing this line, a and b are no longer equal The third line changes the value of but does not change the value of , so they are no longer equal. In some programming languages, a different symbol is used for assignment, such as or , to avoid confusion. Python chose to use the tokens for assignment, and for equality. This is a common choice, also found in languages like C, C++, Java, JavaScript, and PHP, though it does make things a bit confusing for new programmers. When an assignment statement is executed, the right-hand-side expression (i.e. the expression that comes after the assignment token) is evaluated first. Then the result of that evaluation is written into the variable on the left hand side, thereby changing it. One of the most common forms of reassignment is an update, where the new value of the variable depends on its old value. The second line means “get the current value of n, multiply it by three and add one, and put the answer back into n as its new value”. So after executing the two lines above, will have the value 16. If you try to get the value of a variable that doesn’t exist yet, you’ll get an error: Before you can update a variable, you have to initialize it, usually with a simple assignment: This second statement — updating a variable by adding 1 to it — is very common. It is called an increment of the variable; subtracting 1 is called a decrement.\n\nThe loop processes each item in a sequence, so it is used with Python’s sequence data types - strings, lists, and tuples. Each item in turn is (re-)assigned to the loop variable, and the body of the loop is executed. The general form of a loop is: This is another example of a compound statement in Python, and like the branching statements, it has a header terminated by a colon ( ) and a body consisting of a sequence of one or more statements indented the same amount from the header. The loop variable is created when the statement runs, so you do not need to create the variable before then. Each iteration assigns the the loop variable to the next element in the sequence, and then executes the statements in the body. The statement finishes when the last element in the sequence is reached. This type of flow is called a loop because it loops back around to the top after each iteration. \". Please come to my party on Saturday!\" Running through all the items in a sequence is called traversing the sequence, or traversal. You should run this example to see what it does. As with all the examples you see in this book, you should try this code out yourself and see what it does. You should also try to anticipate the results before you do, and create your own related examples and try them out as well. If you get the results you expected, pat yourself on the back and move on. If you don’t, try to figure out why. This is the essence of the scientific method, and is essential if you want to think like a computer programmer. Often times you will want a loop that iterates a given number of times, or that iterates over a given sequence of numbers. The function come in handy for that.\n\nOne of the things loops are good for is generating tables. Before computers were readily available, people had to calculate logarithms, sines and cosines, and other mathematical functions by hand. To make that easier, mathematics books contained long tables listing the values of these functions. Creating the tables was slow and boring, and they tended to be full of errors. When computers appeared on the scene, one of the initial reactions was, “This is great! We can use the computers to generate the tables, so there will be no errors.” That turned out to be true (mostly) but shortsighted. Soon thereafter, computers and calculators were so pervasive that the tables became obsolete. Well, almost. For some operations, computers use tables of values to get an approximate answer and then perform computations to improve the approximation. In some cases, there have been errors in the underlying tables, most famously in the table the Intel Pentium processor chip used to perform floating-point division. Although a log table is not as useful as it once was, it still makes a good example. The following program outputs a sequence of values in the left column and 2 raised to the power of that value in the right column: Using the tab character ( ) makes the output align nicely.\n\nThe general syntax for the while statement looks like this: Like the branching statements and the loop, the statement is a compound statement consisting of a header and a body. A loop executes an unknown number of times, as long at the BOOLEAN EXPRESSION is true. Here is a simple example: \"What is the meaning of life, the universe, and everything? \" Notice that if is set to on the first line, the body of the statement will not execute at all. Here is a more elaborate example program demonstrating the use of the statement \"So I'm thinking of person's name. Try to guess it: \" \"Nope, that's not it! Hint: letter \" \"Too bad, you couldn't get it. The name was\" The flow of execution for a statement works like this:\n• None If the condition is false, exit the statement and continue execution at the next statement.\n• None If the condition is true, execute each of the in the body and then go back to step 1. The body consists of all of the statements below the header with the same indentation. The body of the loop should change the value of one or more variables so that eventually the condition becomes false and the loop terminates. Otherwise the loop will repeat forever, which is called an infinite loop. An endless source of amusement for computer programmers is the observation that the directions on shampoo, lather, rinse, repeat, are an infinite loop. In the case here, we can prove that the loop terminates because we know that the value of is finite, and we can see that the value of increments each time through the loop, so eventually it will have to equal . In other cases, it is not so easy to tell. What you will notice here is that the loop is more work for you — the programmer — than the equivalent loop. When using a loop one has to control the loop variable yourself: give it an initial value, test for completion, and then make sure you change something in the body so that the loop terminates.\n\nSo why have two kinds of loop if looks easier? This next example shows a case where we need the extra power that we get from the loop. Use a loop if you know, before you start looping, the maximum number of times that you’ll need to execute the body. For example, if you’re traversing a list of elements, you know that the maximum number of loop iterations you can possibly need is “all the elements in the list”. Or if you need to print the 12 times table, we know right away how many times the loop will need to run. So any problem like “iterate this weather model for 1000 cycles”, or “search this list of words”, “find all prime numbers up to 10000” suggest that a loop is best. By contrast, if you are required to repeat some computation until some condition is met, and you cannot calculate in advance when this will happen, as we did in the “greatest name” program, you’ll need a loop. We call the first case definite iteration — we have some definite bounds for what is needed. The latter case is called indefinite iteration — we’re not sure how many iterations we’ll need — we cannot even establish an upper bound!\n\nTo write effective computer programs a programmer needs to develop the ability to trace the execution of a computer program. Tracing involves “becoming the computer” and following the flow of execution through a sample program run, recording the state of all variables and any output the program generates after each instruction is executed. To understand this process, let’s trace the execution of the program from The while statement section. At the start of the trace, we have a local variable, with an initial value of . The user will enter a string that is stored in the variable, . Let’s assume they enter . The next line creates a variable named and gives it an intial value of . To keep track of all this as you hand trace a program, make a column heading on a piece of paper for each variable created as the program runs and another one for output. Our trace so far would look something like this: Since evaluates to (take a minute to convince yourself of this), the loop body is executed. Nope, that's not it! Hint: letter 1 is 'H'. Guess again: Assuming the user enters this time, will be incremented, again evaluates to , and our trace will now look like this: 'Harrison' 'Maribel' 0 Nope, that's not it! Hint: letter 1 is 'H'. Guess again: 'Harrison' 'Henry' 1 Nope, that's not it! Hint: letter 2 is 'a'. Guess again: A full trace of the program might produce something like this: 'Harrison' 'Maribel' 0 Nope, that's not it! Hint: letter 1 is 'H'. Guess again: 'Harrison' 'Henry' 1 Nope, that's not it! Hint: letter 2 is 'a'. Guess again: 'Harrison' 'Hakeem' 2 Nope, that's not it! Hint: letter 3 is 'r'. Guess again: 'Harrison' 'Harold' 3 Nope, that's not it! Hint: letter 4 is 'r'. Guess again: 'Harrison' 'Harry' 4 Nope, that's not it! Hint: letter 5 is 'i'. Guess again: 'Harrison' 'Harrison' 5 Great, you got it in 6 guesses! Tracing can be a bit tedious and error prone (that’s why we get computers to do this stuff in the first place!), but it is an essential skill for a programmer to have. From a trace we can learn a lot about the way our code works.\n\nNow we’ll come up with an even more adventurous list of structured data. In this case, we have a list of students. Each student has a name which is paired up with another list of subjects that they are enrolled for: Here we’ve assigned a list of five elements to the variable . Let’s print out each student name, and the number of subjects they are enrolled for: # print all students with a count of their courses. Python agreeably responds with the following output: Now we’d like to ask how many students are taking CompSci. This needs a counter, and for each student we need a second loop that tests each of the subjects in turn: # Count how many students are taking CompSci \"The number of students taking CompSci is\" The number of students taking CompSci is 3 You should set up a list of your own data that interests you — perhaps a list of your CDs, each containing a list of song titles on the CD, or a list of movie titles, each with a list of movie stars who acted in the movie. You could then ask questions like “Which movies starred Angelina Jolie?”"
    }
]