[
    {
        "link": "https://python-binance.readthedocs.io",
        "document": "This is an unofficial Python wrapper for the Binance exchange REST API v3.\n\nIf you came here looking for the Binance exchange to purchase cryptocurrencies, then go here. If you want to automate interactions with Binance stick around.\n\nThis project is powered by\n\nPlease make sure your version is v.1.0.20 or higher. The previous versions are no longer recommended because some endpoints have been deprecated.\n\nMake sure you update often and check the Changelog for new features and bug fixes.\n\nYour contributions, suggestions, and fixes are always welcome! Don’t hesitate to open a GitHub issue or reach out to us on our Telegram chat\n\nThe breaking changes include the migration from wapi to sapi endpoints which related to the wallet endpoints detailed in the Binance Docs The other breaking change is for websocket streams and the Depth Cache Manager which have been converted to use Asynchronous Context Managers. See examples in the Async section below or view the websockets and depth cache docs.\n\nIf you are using an exchange from the US, Japan or other TLD then make sure pass when creating the client. To use the Spot, Vanilla Options , or Futures Testnet pass when creating the client. # place a test market buy order, to place an actual order use the create_order function # get historical kline data from any date range # fetch 1 minute klines for the last day up until now # fetch 30 minute klines for the last month of 2017 # join the threaded managers to the main thread For more check out the documentation.\n\nRead Async basics for Binance for more information. # this will exit and close the connection after 5 messages # get historical kline data from any date range # fetch 1 minute klines for the last day up until now # use generator to fetch 1 minute klines for the last day up until now # fetch 30 minute klines for the last month of 2017 # setup an async context the Depth Cache and exit after 5 messages # Vanilla options Depth Cache works the same, update the symbol to a current one The library is under , that means it’s absolutely free for any developer to build commercial and opensource software on top of it, but use it at your own risk with no warranties, as is.\n\nPython-binance also supports for parsing JSON since it is much faster than the builtin library. This is especially important when using websockets because some exchanges return big messages that need to be parsed and dispatched as quickly as possible. However, is not enabled by default because it is not supported by every python interpreter. If you want to opt-in, you just need to install it ( ) on your local environment. Python-binance will detect the installion and pick it up automatically."
    },
    {
        "link": "https://python-binance.readthedocs.io/en/latest/binance.html",
        "document": ""
    },
    {
        "link": "https://github.com/sammchardy/python-binance",
        "document": "This is an unofficial Python wrapper for the Binance exchange REST API v3.\n\nIf you came here looking for the Binance exchange to purchase cryptocurrencies, then go here. If you want to automate interactions with Binance stick around.\n\nThis project is powered by\n\nPlease make sure your python-binance version is v.1.0.20 or higher. The previous versions are no longer recommended because some endpoints have been deprecated.\n\nMake sure you update often and check the Changelog for new features and bug fixes.\n\nYour contributions, suggestions, and fixes are always welcome! Don't hesitate to open a GitHub issue or reach out to us on our Telegram chat\n• Implementation of all General, Market Data and Account endpoints.\n• No need to generate timestamps yourself, the wrapper does it for you\n• CRUD over websockets, create/fetch/edit through websockets for minimum latency.\n• Support other domains (.us, .jp, etc)\n\nThe breaking changes include the migration from wapi to sapi endpoints which related to the wallet endpoints detailed in the Binance Docs\n\nThe other breaking change is for websocket streams and the Depth Cache Manager which have been converted to use Asynchronous Context Managers. See examples in the Async section below or view the websockets and depth cache docs.\n\nIf you are using an exchange from the US, Japan or other TLD then make sure pass tld='us' when creating the client.\n\nTo use the Spot, Vanilla Options , or Futures Testnet pass testnet=True when creating the client.\n\nFor more check out the documentation.\n\nRead Async basics for Binance for more information.\n\n, , (): . () ( . ( . (), )) ( . ( . ( ), )) ( ) # this will exit and close the connection after 5 messages . ( ) : ( ): . () ( ) # get historical kline data from any date range # fetch 1 minute klines for the last day up until now . ( , . , ) # use generator to fetch 1 minute klines for the last day up until now . ( , . , ): ( ) # fetch 30 minute klines for the last month of 2017 . ( , . , , ) . ( , . , ) . ( , , , ) # setup an async context the Depth Cache and exit after 5 messages ( , ) : ( ): . () ( ) ( ) ( . ()[: ]) ( ) ( . ()[: ]) # Vanilla options Depth Cache works the same, update the symbol to a current one ( , ) : ( ): . () ( ) ( ) ( . ()[: ]) ( ) ( . ()[: ]) . () : . () . ( ())\n\nThe library is under MIT license, that means it's absolutely free for any developer to build commercial and opensource software on top of it, but use it at your own risk with no warranties, as is.\n\nPython-binance also supports orjson for parsing JSON since it is much faster than the builtin library. This is especially important when using websockets because some exchanges return big messages that need to be parsed and dispatched as quickly as possible.\n\nHowever, orjson is not enabled by default because it is not supported by every python interpreter. If you want to opt-in, you just need to install it (pip install orjson) on your local environment. Python-binance will detect the installion and pick it up automatically.\n• Check out CCXT for more than 100 crypto exchanges with a unified trading API.\n• If you use Kucoin check out my python-kucoin library."
    },
    {
        "link": "https://docs.binance.us",
        "document": "Welcome to the Binance.US API Documentation!\n• Do not disclose your API Key to anyone to avoid asset losses. It is recommended to bind IP for API Key to increase your account security.\n• Be aware that your API Key may be disclosed by authorizing it to a third-party platform.\n• You will not be able to create an API if KYC is not completed.\n• Learn more about API key best practices and safety tips.\n\nBinance.US currently offers three API key types: Exchange API Keys, Custodial Solution API Keys, and Credit Line API Keys. Please read on for more information on the differences and instructions on how to set up your key type.\n• Private API keys for the majority of API users to interact with Binance.US API endpoints.\n• Provides access to markets and real-time trading services on Binance.US via a third-party site or application.\n• None Log into Binance.US with your account details\n• None Enter a name for your API key for reference.\n• None Click ‘Create.’ Enter your 2FA code to confirm when prompted\n• Private API keys only available to users who have entered into a Custody Exchange Network agreement between a participating custody partner and Binance.US.\n• Provides access to Custodial Solution related API endpoints only. To access other types of API endpoints, please generate other corresponding API keys.\n\nAfter entering into a Custody Exchange Network agreement between a participating custody partner and Binance.US, users can create a Custodial Solution API key:\n• None Log into Binance.US with your account details\n• None Select ‘Custodial Solution API’’ and give your API key a label for reference\n• None Click ‘Create.’ Enter your 2FA code to confirm when prompted\n• Private API keys only available to institutional users who have signed a credit line agreement with Binance.US.\n• Provides access to Credit Line related API endpoints only. To access other types of API endpoints, please generate other corresponding API keys.\n\nAfter signing a credit line agreement with Binance.US, users can create a Credit Line API key:\n• None Log into Binance.US with your account details\n• None Select ‘Credit Line API’ and give your API key a label for reference\n• None Click ‘Create.’ Enter your 2FA code to confirm when prompted\n• Each endpoint has a security type that determines how you will interact with it. This is stated next to the NAME of the endpoint.\n• If no security type is stated, assume the security type is NONE.\n• API-keys are passed into the REST API via the header.\n• API-keys can be configured to only access certain types of secure endpoints. For example, one API-key could be used for TRADE only, while another API-key can access everything except for TRADE routes.\n• By default, API keys can access all secure routes.\n• A endpoint also requires a parameter and to be sent, which should be the millisecond timestamp of when the request was created and sent.\n• An additional parameter, , may be sent to specify the number of milliseconds after the that the request is valid for. If is not sent, it defaults to 5,000.\n• The exact timing authentication logic can be viewed in the code sample on the right panel (or below on a mobile device).\n\nSerious trading is about timing. Networks can be unstable and unreliable, which can lead to requests taking varying amounts of time to reach the servers. With , you can specify that the request must be processed within a certain number of milliseconds or be rejected by the server.\n• endpoints require an additional parameter: , to be sent in the or .\n• Endpoints use signatures. The is a keyed operation. Use your as the key and as the value for the HMAC operation.\n• The is not case sensitive.\n• is defined as the concatenated with the .\n\nHere is a step-by-step example of how to send a valid signed payload from the Linux command line using , , and .\n\nErrors consist of two parts: an error code and a message. Codes are universal, but messages can vary. Here is the error JSON payload:\n• HTTP return codes are used for malformed requests; the issue is on the sender's side.\n• HTTP return code is used when the WAF (Web Application Firewall) Limit has been violated.\n• HTTP return code is used when a cancelReplace order partially succeeds. (i.e. if the cancellation of the order fails but the new order placement succeeds.)\n• HTTP return code is used when breaking a request rate limit.\n• HTTP return code is used when an IP has been auto-banned for continuing to send requests after receiving codes.\n• HTTP return codes are used for internal errors; the issue is on Binance's side. It is important to NOT treat this as a failure operation; the execution status is UNKNOWN and could have been a success.\n• An unknown error occurred while processing the request.\n• Internal error; unable to process your request. Please try again.\n• You are not authorized to execute this request.\n• Too much request weight used; current limit is %s request weight per %s. Please use WebSocket Streams for live updates to avoid polling the API.\n• Way too much request weight used; IP banned until %s. Please use WebSocket Streams for live updates to avoid bans.\n• An unexpected response was received from the message bus. Execution status is unknown.\n• Timeout waiting for a response from the backend server. Send status unknown; execution status unknown.\n• Spot server is currently overloaded with other requests. Please try again in a few minutes.\n• Too many new orders.\n• Too many new orders; current limit is %s orders per %s.\n• This service is no longer available.\n• This operation is not supported.\n• Timestamp for this request is outside of the recvWindow.\n• Timestamp for this request was 1000ms ahead of the server's time.\n• Signature for this request is not valid.\n• Illegal characters found in parameter '%s'; the legal range is '%s'.\n• Too many parameters sent for this endpoint.\n• Too many parameters; expected '%s' and received '%s'.\n• A mandatory parameter was not sent, was empty/null, or was malformed.\n• Mandatory parameter '%s' was not sent, was empty/null, or was malformed.\n• Param '%s' or '%s' must be sent, but both were empty/null.\n• An unknown parameter was sent.\n• Not all sent parameters were read.\n• Not all sent parameters were read; read '%s' parameter(s) but was sent '%s'.\n• A parameter was sent when not required.\n• Parameter '%s' sent when not required.\n• Precision is over the maximum defined for this asset.\n• No orders on the book for this symbol.\n• TimeInForce parameter sent when not required.\n• This listenKey does not exist.\n• More than %s hours between startTime and endTime.\n• Data sent for p arameter '%s' is not valid.\n• JSON sent for parameter '%s' is not valid\n• has to be either or .\n• No trading window could be found for the symbol. Try ticker/24hrs instead.\n• This code is sent when either the cancellation of the order failed or the new order placement failed but not both.\n• This code is sent when both the cancellation of the order failed and the new order placement failed.\n• Order was canceled or expired with no executed qty over 90 days ago and has been archived.\n\nThis code is sent when an error has been returned by the matching engine. The following messages will indicate the specific error:\n• Spot WebSocket APIs are now available for Binance US.\n• WebSocket API allows placing orders, canceling orders, etc. through a WebSocket connection.\n• WebSocket API is a separate service from WebSocket Market Data streams. i.e., placing orders and listening to market data requires two separate WebSocket connections.\n• WebSocket API is subject to the same Filter and Rate Limit rules as REST API.\n• WebSocket API and REST API are functionally equivalent: they provide the same features, accept the same parameters, return the same status and error codes.\n• The full documentation can be found here.\n• Trading parameters for 3 trading pairs have been updated. Click here to learn more.\n• Improved error messages for certain issues for easier troubleshooting.\n• Fixed error message for querying archived orders(status or where == 0 in the last 90 days):\n• Now error message: \"msg\": \"Order was canceled or expired with no executed qty over 90 days ago and has been archived.\"\n• None Behavior for API requests with and :\n• Previously some requests failed if the == .\n• Now, all API requests that accept and allow the parameters to be equal. This applies to the following requests:\n• \n• Previous behavior: Reverse market orders would have the status even if the order was not fully filled.\n• New behavior: If the reverse market order did not fully fill due to low liquidity, the order status will be , and only if completely filled.\n• Changes to and :\n• New optional parameter that determines whether the cancel will succeed if the order status is or .\n• If the order cancellation fails due to , error will be: \"msg\": \"Order was not canceled due to cancel restrictions.\"\n• Added a new endpoint to get all orders\n\nTrading parameters for 153 trading pairs have been updated. Click here to learn more.\n• New API Key Type (Credit Line): Added a new API Key type (Credit Line) and instructions for generating this key type in ‘Get API Keys.’\n\nThe changes to the system will take place on January 31, 2023.\n\n\n\nAdditional details on the functionality of STP is explained in the STP FAQ document.\n• None Self-Trade Prevention (aka STP) has been added to the system. STP is a measure to prevent users from trading against their own account or other accounts that share the same (such as parent and sub-accounts which belong to the same entity). The default and allowed modes of STP are as follows, and can be confirmed using : \"defaultSelfTradePreventionMode\": \"EXPIRE_MAKER\", //If selfTradePreventionMode not provided, this will be the value passed to the engine \n\n \"allowedSelfTradePreventionModes\": [//What the allowed modes of\n• None New order status: - This means that the order expired due to STP being triggered.\n• \n• - This queries the orders that expired due to STP being triggered.\n• None New optional parameter has been added to the following endpoints:\n• None New responses that will appear for all order placement endpoints if there was a prevented match (i.e. if an order could have matched with an order of the same account, or the accounts are in the same ):\n• - This will only appear if account is configured to a and if there was a prevented match.\n• - Only appears if there was a prevented match\n• An array with the following fields:\n• - This will only appear if set is or .\n• - This will only appear if set is or .\n• None New fields and that can appear in the order query endpoints if the order had expired due to STP :\n• None New field will appear in the response.\n• New fields for (These fields will only appear if the order has expired due to STP)\n• ’Withdraw Fiat (via SEN or SIGNET)’ updated to support signet.\n• ’Get All OTC Trade Orders’ and ‘Get All OCBS Trade Orders’ parameters updated. 90-day limit removed from both.\n• !bookTicker removed.\n• Multiple streams can be subscribed to over one connection. (E.g. wss://stream.binance.us:9443/stream?streams=btcusdt@bookTicker/bnbbtc@bookTicker)\n• New error code -1135 occurs if a parameter requiring a JSON object is invalid.\n• New error code -1108 occurs if a value sent to a parameter is too large.\n• Changes to GET /api/v3/aggTrades\n• startTime and endTime can now be used individually and the 1-hour limit has been removed.\n• Changes to GET /api/v3/myTrades\n• Bug fixed: The combination of symbol + orderId no longer returns all trades beyond the 500 default limit.\n• Sending an unsupported combination of optional parameters now responds with generic error: { “code”: -1128, “msg”: “Combination of optional parameters invalid.” }.\n• defaultSelfTradePreventionMode and allowedSelfTradePreventionModes fields will appear in GET /api/v3/exchangeInfo\n• selfTradePreventionMode field will appear in the response for several order endpoints.\n• requireSelfTradePrevention field will appear in the response for GET /api/v3/account\n• workingTime field indicating when the order started working on the order book, will appear in several order endpoints.\n• trailingTime field will appear in order types: (TAKE_PROFIT, TAKE_PROFIT_LIMIT, STOP_LOSS, STOP_LOSS_LIMIT if trailingDelta parameter was provided), for several order endpoints.\n• commissionRates field will appear in the GET /api/v3/acccount response.\n• eventType executionReport has new fields:\n• D - trailing_time (Appears if the trailing stop order is active)\n• W - workingTime (Appears if the order is working on the order book)\n• Staking Endpoints: Added four new staking-focused endpoints, including:\n• Unstake Asset: Unstake an asset that is currently staking.\n• Get Staking Asset Information: Information on staking asset(s) including reward asset received, APR, APY, unstaking period (hrs.), minimum and maximum staking amounts, and whether auto restaking is enabled.\n• Get Staking History: History of staking transactions for an asset in a given time period, including transaction amount, type, and initiation time.\n• Revised Error Messages: Updated several API error messages related to staking for increased clarity.\n• New API Key Type (Custodial Solution): Added a new API Key type (Custodial Solution) and instructions for generating this key type in 'Get API Keys.'\n• Added Custodial Solution API & Endpoints: Added 'Custodial Solution Endpoints' section for new Custodial Solution API. Contains four endpoint categories and 18 endpoints in total:\n• Enabled trailing stop order: Updated three endpoints: POST /api/v3/order, POST /api/v3/order/test, POST /api/v3/order/oco, and added one new filter: TRAILING_DELTA, to support trailing stop orders. This type of stop order activates based on the percentage of a price change in the market using the new parameter: trailingDelta. This can be used with STOP_LOSS_LIMIT, or TAKE_PROFIT_LIMIT.\n• Enabled replace order: Added one endpoint to cancel an existing order and place a new order with the same symbol.\n• Scheduled changes: The All Book Tickers stream (!bookTicker) is set to be removed in late November 2022. Please use the Individual Book Ticker Streams instead. (<symbol>@bookTicker). Multiple <symbol>@bookTicker streams can be subscribed to over one connection. For example: wss://stream.binance.us:9443/stream?streams=btcusdt@bookTicker/bnbbtc@bookTicker\n• Market Data: Added a new optional parameter type in two endpoints: GET /api/v3/ticker and GET /api/v3/ticker/24hr. Also removed Individual Symbol Ticker Streams as it duplicates with Ticker Order Book Stream, supported new candlestick chart interval: 1s.\n• Get Asset Distribution History endpoint: Updated this endpoint to also query the rebate distribution record.\n• Get Exchange Information endpoint: Added a service line permission parameter to display all symbols with the permission matching the value provided.\n• User data endpoints: Added two endpoints to get trading fees and trading volume for the past 30 days.\n• Convert dust to BNB endpoints: Added three endpoints to convert dust to BNB and query the conversion history and convertible assets.\n• Staking endpoints: Added two endpoints to get staking balance and staking reward history.\n• Market data endpoints: Added one endpoint to get price change data within a requested time window and updated four endpoints to support more parameter options.\n• Market data streams: Added two ticker streams with 1h and 4h windows, individual symbol ticker streams, and all market ticker streams.\n• Filters: Added three filters (percent price by side, notional, exchange maximum number iceberg orders) and updated the rules of price filters.\n• Usability improvements: Fixed some language errors and improved the content.\n• User data endpoints: Migrated seven endpoints from WAPI to SAPI to improve performance and added five endpoints for status query and crypto withdrawals.\n• Wallet endpoints: Added two endpoints to get sub-account deposit addresses and history.\n• OTC endpoints: Added one OTC endpoint for users to query all OTC order details.\n• Referral endpoints: Added one referral endpoint for users to get referral rewards history.\n• Usability improvements: Made several improvements to content and readability.\n• Miscellaneous updates: Temporarily removed the Get User Maker/Taker Rates endpoint. The endpoint will return in a future update.\n• Updated five wallet endpoints related to crypto withdrawals and deposits.\n• Added new OTC trade endpoints which support larger buy and sell order quotes, placements, and queries, as well as crypto-to-crypto conversion (e.g. KSHIB/SHIB).\n\nHave questions about our APIs? Contact customer support here.\n\nAll endpoints return either a JSON object or array.\n\nData is returned in ascending order: oldest first, newest last.\n\nAll times for the fields of staking, referrals, airdrops, etc. are in milliseconds.\n• For endpoints, parameters must be sent as a .\n• For , , and endpoints, the parameters may be sent as a or in the with content type . You may mix parameters between both the and if you wish to do so.\n• Parameters may be sent in any order.\n• If a parameter is sent in both the and , the parameter will be used.\n• The API system is asynchronous, so some delay in the response is normal.\n• Each endpoint has a data source indicating where the data is being retrieved, and thus which endpoints have the most up-to-date response.\n\nThese are the three sources ordered from the most up-to-date response to the one with potential delays in updates:\n• Matching Engine - the data is from the matching engine\n• Memory - the data is from a server's local or external memory\n• Database - the data is taken directly from a database\n\nSome endpoints can have more than one data source(e.g. Memory => Database). This means that the endpoint will check the first data source. If it cannot find the value it's looking for it will check the next one etc.\n\nThese terms will be used throughout the documentation, so it is recommended that you read them to enhance your understanding of the API (especially for new users).\n• refers to the asset that is the of a symbol; for the symbol BTCUSDT, BTC would be the\n• refers to the asset that is the of a symbol; for the symbol BTCUSDT, USDT would be the .\n• The following are values for headers:\n• The array contains objects related to the exchange's , , and rate limits. These are further defined in the section under .\n• A 429 will be returned when either rate limit is violated.\n• Each route has a that determines the number of requests each endpoint counts for. Heavier endpoints and endpoints that do operations on multiple symbols will have a heavier .\n• REST API and WebSocket API are subject to the same Rate Limit rules.\n• Every request will contain an header which has the currently used weight for the IP of all request rate limiters defined.\n• Every successful order will contain an header which has the current order count for the IP of all order rate limiters defined. Rejected/unsuccessful orders are not guaranteed to have a header in the response.\n• None When a 429 is received, it's your obligation as an API user/trader to back off and not spam the API.\n• None Repeatedly violating rate limits and/or failing to back off after receiving 429s will result in an automated IP ban (HTTP status 418).\n• None IP bans are tracked and scale in duration for repeat offenders, from 2 minutes to 3 days.\n• None A header is sent with a 418 or 429 response and will give the number of seconds required to wait to prevent a ban (for a 418) or until the ban is over (for a 429).\n• None The limits on the API are based on the IPs, not the API keys.\n• Every successful order response will contain an header which has the current order count for the account for all order rate limiters defined.\n• Rejected/unsuccessful orders are not guaranteed to have a header in the response.\n• The order rate limit is counted against each account.\n\nUse this endpoint to test connectivity to the exchange.\n\nUse this endpoint to get the exchange’s server time.\n\nUse this endpoint to fetch whether the system status is normal or under maintenance.\n\nUse this endpoint to get the current exchange trading rules and trading pair information.\n\nThere are 4 possible options:\n• If the value provided to or do not exist, the endpoint will throw an error saying the symbol is invalid.\n• If parameter not provided, the default values will be .\n\nUse this endpoint to get the recent trades. Please note the maximum limit is 1,000 trades.\n\nUse this endpoint to get older trades. Please note the maximum limit is 1,000 trades.\n\nUse this endpoint to get compressed, aggregate trades. Trades that fill at the same time, from the same order, with the same price, will have the quantity aggregated. Please note the maximum limit is 1,000 trades.\n• If fromId, startTime, and endTime are not sent, the most recent aggregate trades will be returned.\n\nUse this endpoint to get order book depth (prices and quantities of bids and asks).\n\nUse this endpoint to get Kline/candlestick bars for a token symbol. Klines are uniquely identified by their open time. Please note the maximum limit is 1,000 bars.\n• If startTime and endTime are not sent, the most recent klines are returned.\n\nUse this endpoint to get the live ticker price.\n\nUse this endpoint to get the current average price for a symbol.\n\nUse this endpoint to get the best available order book price.\n\nUse this endpoint to get price change data for the past 24hrs.\n• If the symbol is not sent, tickers for all symbols will be returned in an array.\n\nUse this endpoint to get the price change data within a requested window of time.\n\nNote: reverts to the start of the minute (e.g. 09:17:00 UTC, instead of 09:17:47:99). is the current time of the request (including seconds and milliseconds). Therefore, the effective window can be up to 59999ms (59 seconds) longer than the specified .\n\nE.g. If the is 1641287867099 (January 04, 2022 09:17:47:099 UTC), and the is 1d. the will be: 1641201420000 (January 3, 2022, 09:17:00 UTC).\n\n2 for each requested symbol regardless of .\n\nThe weight for this request will cap at 100 once the number of in the request is more than 50.\n\nUse this endpoint to get current account information.\n\nUse this endpoint to fetch account status details.\n\nUse this endpoint to fetch account API trading status details.\n\nUse this endpoint to query asset distribution records, including Market Maker Rebate, MM Streaks Rebate, API Partner Rebate and airdrop, etc.\n\nUse this endpoint to get your current maker & taker fee rates for spot trading based on your VIP level or manual fee adjustment. Discount for using BNB to pay fees (25% off) is not factored in.\n\nUse this endpoint to get total trade volume for the past 30 days, calculated on a rolling basis every day at 0:00 AM (UTC).\n\nUse this endpoint to get your sub-account list.\n\nUse this endpoint to fetch sub-account asset transfer history.\n\nUse this endpoint to execute an asset transfer between the master account and a sub-account.\n\nUse this endpoint to fetch sub-account assets.\n\nUse this endpoint to get the total value of assets in the master account in USD.\n\nUse this endpoint to get a status list of sub-accounts.\n\nGet the current trade order count rate limits for all time intervals.\n\nUse this endpoint to place a new trade order.\n• Any or type order can be made an iceberg order by sending an .\n• Any order with an MUST have set to .\n• orders using will not break filter rules; the order will execute a with a notional value as close as possible to .\n\nTrigger order price rules against market price for both MARKET and LIMIT versions:\n\nUse this endpoint to test new order creation and signature/recvWindow long. The endpoint creates and validates a new order but does not send it into the matching engine.\n\nUse this endpoint to check a trade order's status.\n• Either or must be sent.\n• For some historical orders will be < 0, meaning the data is not available at this time.\n\nUse this endpoint to get all open trade orders for a token symbol. Do not access this without a token symbol as this would return all pair data.\n\nWeight: 3 for a single symbol; 40 when the symbol parameter is omitted\n• If the symbol is not sent, orders for all symbols will be returned in an array.\n\nUse this endpoint to cancel an active trade order.\n\nEither or must be sent.\n• None If the value is not any of the supported values, the error will be:\n• None If the order did not pass the conditions for , the error will be: { \"code\": -2011, \"msg\": \"Order was not canceled due to cancel restrictions.\" }\n\nUse this endpoint to cancels all active trade orders on a token symbol (this includes OCO orders).\n\nUse this endpoint to get trade data for a specific account and token symbol.\n• If is set, it will get orders >= than . Otherwise most recent orders are returned.\n• The time between and can't be longer than 24 hours.\n• These are the supported combinations of optional parameters:\n\nCancels an existing order and places a new order on the same symbol.\n\nFilters and Order Count are evaluated before the processing of the cancellation and order placement occurs.\n\nA new order that was not attempted (i.e. when ), will still increase the order count by 1.\n\nSimilar to POST , additional mandatory parameters are determined by type.\n\nResponse format varies depending on whether the processing of the message succeeded, partially succeeded, or failed.\n\nDisplays the list of orders that were expired because of STP. These are the combinations supported:\n\nGet all account orders: active, canceled, or filled.\n• If is set, it will get orders >= that . Otherwise most recent orders are returned.\n• For some historical orders will be < 0, meaning the data is not available at this time.\n• If and/or provided, is not required.\n\nUse this endpoint to place a new OCO(one-cancels-the-other) order.\n• Quantity Restrictions:\n• Both legs must have the same quantity.\n• quantities however do not have to be the same\n• Order Rate Limit\n• counts as 2 orders against the order rate limit.\n\nUse this endpoint to retrieve a specific OCO order based on provided optional parameters.\n\nUse this endpoint to retrieve all OCO orders based on provided optional parameters. Please note the maximum limit is 1,000 orders.\n\nUse this endpoint to query open OCO orders.\n\nUse this endpoint to cancel an entire order list.\n• Canceling an individual leg will cancel the entire OCO\n\nUse this endpoint to get a list of supported coin pairs.\n\nUse this endpoint to request a quote for a from-to coin pair.\n\nUse this endpoint to place an order using an acquired quote.\n\nUse this endpoint to query OTC trade order details.\n\nUse this endpoint to query OTC trade orders by condition.\n\nUse this endpoint to query all OCBS orders by condition.\n\nUse this endpoint to fetch the details of all crypto assets including fees, withdrawal limits, and network status.\n\nUse this endpoint to submit a USD withdraw request via BITGO\n\nUse this endpoint to submit a crypto withdrawal request.\n\nUse this endpoint to fetch your crypto withdrawal history.\n\nUse this endpoint to fetch your fiat (USD) withdrawal history.\n• Please pay attention to the default value of startTime and endTime.\n• If both startTime and endTime are sent, the duration between startTime and endTime must be greater than 0 day and less than 90 days.\n\nUse this endpoint to fetch a deposit address for a particular crypto asset.\n\nUse this endpoint to fetch your crypto deposit history.\n\nUse this endpoint to fetch your fiat (USD) deposit history.\n• Please pay attention to the default value of startTime and endTime.\n• If both startTime and endTime are sent, the duration between startTime and endTime must be greater than 0 day and less than 90 days.\n\nUse this endpoint to fetch a sub-account’s deposit address.\n\nUse this endpoint to fetch sub-account deposit history.\n\nUse this endpoint to convert dust assets to BNB/BTC/ETH/USDT.\n\nUse this endpoint to get dust conversion history.\n\nGet Assets That Can Be Converted\n\nUse this endpoint to get your dust assets that can be converted.\n\nUse this endpoint to get the user’s referral reward history.\n\nUse this endpoint to get staking information for a supported asset (or assets)\n\nUse this endpoint to stake a supported asset.\n\nUse this endpoint to unstake a staked asset.\n\nUse this endpoint to get the staking balance for an asset(or assets).\n\nUse this endpoint to get the staking history of an asset (or assets) within a given time range.\n\nUse this endpoint to get the staking rewards history for an asset(or assets) within a given time range.\n\nUse this endpoint to get balance information for Binance.US exchange wallet and Binance.US custodial sub-account.\n\nUse this endpoint to get a list of assets supported with custodial solutions including eligibility for transfer (from custodial partner) and settlement (to custodial partner).\n\nUse this endpoint to request an asset transfer from your Binance.US exchange wallet to your Binance.US custodial sub-account.\n\nUse this endpoint to request an asset transfer from a custodial partner account to the Binance.US custodial sub-account.\n\nUse this endpoint to undo a previous transfer from your custodial partner.\n\nUse this endpoint to check a Binance.US exchange wallet transfer status.\n\nUse this endpoint to check the status of a transfer from a custodial partner account, including ExpressTrade transfer, Custodian transfer and Undo Transfer.\n\nUse this endpoint to place a new trade order.\n\nUse this endpoint to place a new OCO(one-cancels-the-other) order.\n\nOther Info: Price Restrictions: SELL: Limit Price > Last Price > Stop Price BUY: Limit Price < Last Price < Stop Price Quantity Restrictions: Both legs must have the same quantity. ICEBERG quantities however do not have to be the same Order Rate Limit OCO counts as 2 orders against the order rate limit.\n\nUse this endpoint to get all open trade orders for a token symbol. Do not access this without a token symbol as this would return all pair data.\n\nUse this endpoint to check a trade order's status.\n\nUse this endpoint to check an order's status as well as past orders.\n\nIf the symbol is not sent, orders for all symbols will be returned in an array.\n\nUse this endpoint to get past trade data.\n\nNotes: If fromId is set, it will get orders >= than fromId. Otherwise most recent orders are returned.\n\nUse this endpoint to cancel an active trade order.\n\nUse this endpoint to cancel all active trade orders on a token symbol (this includes OCO orders).\n\nUse this endpoint to cancel an entire order list.\n\nUse this endpoint to get current settlement settings (status, schedule and next trigger time).\n\nUse this endpoint to check your settlement history.\n\nUse this endpoint to get current credit line account information.\n\nUse this endpoint to get your margin call and liquidation alert history.\n\nUse this endpoint to get your transfer history.\n\nUse this endpoint to transfer assets in or out of credit line account.\n\nUse this endpoint to check if the user is eligible for rebate or not.\n\nUse this endpoint to query the user's rebate history.\n\nFilters define trading rules for a symbol or an exchange.\n\nFilters come in two forms: and .\n\nThe defines the rules for a symbol. There are three parts:\n• defines the intervals that a / can be increased/decreased by; disabled on == 0.\n\nAny of the above variables can be set to 0, which disables that rule in the . In order to pass the , the following must be true for / of the enabled rules:\n\nThe filter defines valid range for a price based on the average of the previous trades. is the number of minutes the average price is calculated over. 0 means the last price is used.\n\nIn order to pass the , the following must be true for :\n\nThe filter defines the valid range for the price based on the average of the previous trades. is the number of minutes the average price is calculated over. 0 means the last price is used. There is a different range depending on whether the order is placed on the BUY side or the SELL side.\n\nBuy orders will succeed on this filter if:\n\nSell orders will succeed on this filter if:\n\nThe filter defines the (aka \"lots\" in auction terms) rules for a symbol. There are three parts:\n• defines the intervals that a / can be increased/decreased by.\n\nIn order to pass the , the following must be true for / :\n\nThe filter defines the acceptable notional range allowed for an order on a symbol.\n• determines whether the minNotional will be applied to orders.\n• determines whether the maxNotional will be applied to orders.\n\nIn order to pass this filter, the notional amount ( * ) has to meet the following conditions:\n\nFor orders, the average price used over the last minutes will be used for calculation. If the is 0, then the last price will be used.\n\nThe filter defines the minimum notional value allowed for an order on a symbol. An order's notional value is the * .\n\ndetermines whether or not the filter will also be applied to orders. Since orders have no price, the average price is used over the last minutes. is the number of minutes the average price is calculated over. 0 means the last price is used.\n\nThe filter defines the maximum parts an iceberg order can have. The number of is defined as .\n\nThe filter defines the (aka \"lots\" in auction terms) rules for orders on a symbol. There are three parts:\n• defines the intervals that a can be increased/decreased by.\n\nIn order to pass the , the following must be true for :\n\nThe filter defines the maximum number of orders an account is allowed to have open on a symbol. Note that both \"algo\" orders and normal orders are counted for this filter.\n\nThe filter defines the maximum number of \"algo\" orders an account is allowed to have open on a symbol. \"Algo\" orders are , , , and orders.\n\nThe filter defines the maximum number of orders an account is allowed to have open on a symbol. An order is any order where the is > 0.\n\nThe filter defines the allowed maximum position an account can have on the base asset of a symbol. An account's position is defined as the sum of the account's:\n• Sum of the qty of all open BUY orders\n\norders will be rejected if the account's position is greater than the maximum position allowed.\n\nThe filter defines the minimum and maximum value for the parameter .\n\nIn order for a to pass this filter, the following must be true:\n\nThe filter defines the maximum number of orders an account is allowed to have open on the exchange. Note that both \"algo\" orders and normal orders are counted for this filter.\n\nThe filter defines the maximum number of \"algo\" orders an account is allowed to have open on the exchange. \"Algo\" orders are , , , and orders.\n\nThe filter defines the maximum number of iceberg orders an account is allowed to have open on the exchange.\n• The base endpoint is:\n• If you experience issues with the standard 443 port, alternative port 9443 is also available.\n• A single connection to the API is only valid for 24 hours; expect to be disconnected after the 24-hour mark.\n• WebSocket server will send a ping frame every 3 minutes.\n• If the server does not receive a pong frame response within 10 minutes, you will be disconnected.\n• Unsolicited pong frames are allowed and will prevent disconnection.\n• Lists are returned in chronological order, unless noted otherwise.\n• All timestamps are in milliseconds in UTC, unless noted otherwise.\n• All field names and values are case-sensitive, unless noted otherwise.\n\nRequests must be sent as JSON in text frames, one request per frame.\n• Request is truly arbitrary. You can use UUIDs, sequential IDs, current timestamp, etc. The server does not interpret in any way, simply echoing it back in the response.\n\nYou can freely reuse IDs within a session. However, be careful to not send more than one request at a time with the same ID, since otherwise it might be impossible to tell the responses apart.\n• None Request method names may be prefixed with explicit version: e.g., .\n• None The order of is not significant.\n\nResponses are returned as JSON in text frames, one response per frame.\n\nStatus codes in the field are the same as in HTTP.\n\nHere are some common status codes that you might encounter:\n• status codes indicate invalid requests; the issue is on your side.\n• – your request failed, see for the reason.\n• – you have been blocked by the Web Application Firewall.\n• – your request partially failed but also partially succeeded, see for details.\n• – you have been auto-banned for repeated violation of rate limits.\n• – you have exceeded the API request rate limit, please slow down.\n• status codes indicate internal errors; the issue is on Binance US' side.\n• Important: If a response contains 5xx status code, it does not necessarily mean that your request has failed. Execution status is unknown and the request might have actually succeeded. Please use query methods to confirm the status. You might also want to establish a new WebSocket connection for that.\n\nSee Error codes for a list of error codes and messages.\n• Every method has a security type which determines how to call it.\n• Security type is stated below Data Source. For example, Place new order (WebSocket).\n• If no security type is stated, the security type is NONE.\n• Secure methods require a valid API key to be specified and authenticated.\n• API keys can be created on the API Management page of your Binance.US account.\n• Both API key and secret key are sensitive. Never share them with anyone. If you notice unusual activity in your account, immediately revoke all the keys and contact Binance.US support.\n• API keys can be configured to allow access only to certain types of secure methods.\n• For example, you can have an API key with permission for trading, while using a separate API key with permission to monitor your order status.\n• By default, an API key cannot . You need to enable trading in API Management first.\n• and requests are also known as requests.\n• The signature is computed using HMAC-SHA-256 algorithm. See computation example below.\n• requests also require a parameter which should be the current millisecond timestamp.\n• An additional optional parameter, , specifies for how long the request stays valid.\n• If is not sent, it defaults to 5000 milliseconds.\n\nSerious trading is about timing. Networks can be unstable and unreliable, which can lead to requests taking varying amounts of time to reach the servers. With , you can specify that the request must be processed within a certain number of milliseconds or be rejected by the server.\n\nIt is recommended to use a small of 5000 or less!\n\nHere is a step-by-step guide on how to sign requests.\n\nWARNING: DO NOT SHARE YOUR API KEY AND SECRET KEY WITH ANYONE.\n\nThe example keys are provided here only for illustrative purposes.\n\nAs you can see, the parameter is currently missing.\n\nTake all request except for the , sort them by name in alphabetical order:\n• Interpret as ASCII data, using it as a key for HMAC-SHA-256.\n\nNote that , , and the payload are case-sensitive, while resulting signature value is case-insensitive.\n\nYou can cross-check your signature algorithm implementation with OpenSSL.\n\nFinally, complete the request by adding the parameter with the signature string.\n• None The API system is asynchronous. Some delay in the response is normal and expected.\n• None Each method has a data source indicating where the data is coming from, and thus how up-to-date it is.\n• Some methods have more than one data source (e.g., Memory => Database).\n\nThis means that the API will look for the latest data in that order: first in the cache, then in the database.\n\nThese terms will be used throughout the documentation, so it is recommended especially for new users to read to help their understanding of the API.\n• refers to the asset that is the of a symbol. For the symbol BTCUSDT, BTC would be the .\n• refers to the asset that is the of a symbol. For the symbol BTCUSDT, USDT would be the .\n• Current API rate limits can be queried using the request.\n• There are multiple rate limit types across multiple intervals.\n• Responses can indicate current rate limit status in the optional field.\n• Requests fail with status when rate limits are violated.\n• REST API and WebSocket API are subject to the same Rate Limit rules.\n\nThe array describes all currently active rate limits affected by the request.\n\nFor example, a interval starts every minute. Request submitted at 00:01:23.456 counts towards the 00:01:00 minute's limit. Once the 00:02:00 minute starts, the count will reset to zero again.\n\nOther intervals behave in a similar manner. For example, rate limit resets at 00:00 UTC every day, and interval resets at 00, 10, 20... seconds of each minute.\n\nAPIs have multiple rate-limiting intervals. If you exhaust a shorter interval but the longer interval still allows requests, you will have to wait for the shorter interval to expire and reset. If you exhaust a longer interval, you will have to wait for that interval to reset, even if shorter rate limit count is zero.\n\nfield is included with every response by default.\n\nHowever, rate limit information can be quite bulky. If you are not interested in detailed rate limit status of every request, the field can be omitted from responses to reduce their size.\n\nUse parameter to control whether to include fields in response to individual requests.\n\nIf you wish to omit from all responses by default, use parameter in the query string instead:\n\nThis will make all requests made through this connection behave as if you have passed .\n\nIf you want to see rate limits for a particular request, you need to explicitly pass the parameter.\n\nNote: Your requests are still rate limited if you hide the field in responses.\n• Every request has a certain weight, added to your limit as you perform requests.\n• Most requests cost 1 unit of weight, heavier requests acting on multiple symbols cost more.\n• Current weight usage is indicated by the rate limit type.\n• Use the request to keep track of the current weight limits.\n• Weight is accumulated per IP address and is shared by all connections from that address.\n• If you go over the weight limit, requests fail with status .\n• This status code indicates you should back off and stop spamming the API.\n• Rate-limited responses include a field, indicating when you can retry the request.\n• Repeatedly violating rate limits and/or failing to back off after receiving 429s will result in an automated IP ban and you will be disconnected.\n• field indicates the timestamp when the ban will be lifted.\n• IP bans are tracked and scale in duration for repeat offenders, from 2 minutes to 3 days.\n\nSuccessful response indicating that in 1 minute you have used 70 weight out of your 1200 limit.\n\nFailed response indicating that you are banned and the ban will last until epoch .\n• Every request to place an order counts towards your order limit.\n• Rejected or unsuccessful orders might or might not update the count.\n• Use the request to keep track of the current order rate limits.\n• Order rate limit is maintained per account and is shared by all API keys of the account.\n• If you go over the order rate limit, requests fail with status .\n• This status code indicates you should back off and stop spamming the API.\n• Rate-limited responses include a field, indicating when you can retry the request.\n\nSuccessful response indicating that you have placed 12 orders in 10 seconds, and 4043 orders in the past 24 hours.\n\nNote: You can use regular WebSocket ping frames to test connectivity as well, WebSocket API will respond with pong frames as soon as possible. request along with is a safe way to test request-response handling in your application.\n\nTest connectivity to the WebSocket API and get the current server time.\n• None Only one of , , parameters can be specified.\n• None accepts either a list of permissions, or a single permission name: .\n\nIf you need to continuously monitor order book updates, please consider using WebSocket Streams:\n\nYou can use request together with streams to maintain a local order book.\n\nIf you need access to real-time trading activity, please consider using WebSocket Streams:\n• If is not specified, the most recent trades are returned.\n\nAn aggregate trade (aggtrade) represents one or more individual trades. Trades that fill at the same time, from the same taker order, with the same price – those trades are collected into an aggregate trade with total quantity of the individual trades.\n\nIf you need access to real-time trading activity, please consider using WebSocket Streams:\n• If is specified, return aggtrades with aggregate trade ID >= .\n\nUse and to page through all aggtrades.\n• If and/or are specified, aggtrades are filtered by execution time ( ).\n\ncannot be used together with and .\n• If no condition is specified, the most recent aggregate trades are returned.\n\nKlines are uniquely identified by their open & close time.\n\nIf you need access to real-time kline updates, please consider using WebSocket Streams:\n• If , are not specified, the most recent klines are returned.\n\nIf you need to continuously monitor trading statistics, please consider using WebSocket Streams:\n\nIf you need different window sizes, use the request.\n\nWeight: Adjusted based on the number of requested symbols:\n• None and cannot be used together.\n• None If no symbol is specified, returns information about all symbols currently trading on the exchange.\n\nThis request is similar to , but statistics are computed on demand using the arbitrary window you specify.\n\nNote: Window size precision is limited to 1 minute. While the is the current time of the request, always start on a minute boundary. As such, the effective window might be up to 59999 ms wider than the requested .\n\nFor example, a request for might result in the following window:\n\nTime of the request – – is 1660184865291 (August 11, 2022 02:27:45.291). Requested window size should put the 7 days before that – August 4, 02:27:45.291 – but due to limited precision it ends up a bit earlier: 1659580020000 (August 4, 2022 02:27:00), exactly at the start of a minute.\n\nIf you need to continuously monitor trading statistics, please consider using WebSocket Streams:\n\nWeight: Adjusted based on the number of requested symbols:\n• None Either or must be specified.\n• None Maximum number of symbols in one request: 100.\n• None Window size units cannot be combined. E.g., is not supported.\n\nGet the latest market price for a symbol.\n\nIf you need access to real-time price updates, please consider using WebSocket Streams:\n\nWeight: Adjusted based on the number of requested symbols:\n• None and cannot be used together.\n• None If no symbol is specified, returns information about all symbols currently trading on the exchange.\n\nGet the current best price and quantity on the order book.\n\nIf you need access to real-time order book ticker updates, please consider using WebSocket Streams:\n\nWeight: Adjusted based on the number of requested symbols:\n• None and cannot be used together.\n• None If no symbol is specified, returns information about all symbols currently trading on the exchange.\n\nCertain parameters (*) become mandatory based on the order :\n\nAvailable options, setting how long the order should be active before expiration:\n• specifies value for the order.\n\nA new order with the same is accepted only when the previous one is filled or expired.\n• Any or order can be made into an iceberg order by specifying the .\n\nAn order with an must have set to .\n• \n• must be above market price: ,\n• must be below market price: ,\n\nThe order will execute a quantity that has notional value as close as possible to requested .\n\nValidates new order parameters and verifies your signature but does not send the order into the matching engine.\n\nSame as for .\n• None If both and parameters are specified, only is used and is ignored.\n• None For some historical orders the response field may be negative, meaning the data is not available at this time.\n• None If both and parameters are specified, only is used and is ignored.\n• None will replace of the canceled order, freeing it up for new orders.\n• None If you cancel an order that is a part of an OCO pair, the entire OCO is canceled.\n\nCancel an existing order and immediately place a new order instead of the canceled one.\n\nSimilar to the request, additional mandatory parameters (*) are determined by the new order .\n• – if cancellation request fails, new order placement will not be attempted\n• – new order placement will be attempted even if the cancel request fails\n• None If both and parameters are specified, only is used and is ignored.\n• None will replace of the canceled order, freeing it up for new orders.\n• None specifies value for the placed order.\n\nA new order with the same is accepted only when the previous one is filled or expired.\n\nThe new order can reuse old of the canceled order.\n• This cancel-replace operation is not transactional.\n\nIf one operation succeeds but the other one fails, the successful operation is still executed.\n\nFor example, in mode, if the new order placement fails, the old order is still canceled.\n• None Filters and order count limits are evaluated before cancellation and order placement occurs.\n• None If new order placement is not attempted, your order count is still incremented.\n• None Like , if you cancel a leg of an OCO, the entire OCO is canceled.\n\nIf you need to continuously monitor order status updates, please consider using WebSocket Streams:\n\nWeight: Adjusted based on the number of requested symbols:\n\nStatus reports for open orders are identical to .\n\nNote that some fields are optional and included only for orders that set them.\n\nOpen orders are always returned as a flat list. If all symbols are requested, use the field to tell which symbol the orders belong to.\n\nCancellation reports for orders and OCOs have the same format as in .\n\nSend in a new one-cancels-the-other (OCO) pair: + / orders (called legs), where activation of one order immediately cancels the other.\n\nA new OCO with the same is accepted only when the previous one is filled or completely expired.\n\nis distinct from of individual orders.\n• and specify values for both legs of the OCO.\n\nA new order with the same is accepted only when the previous one is filled or expired.\n• Both legs have the same .\n\nHowever, you can set different iceberg quantity for individual legs.\n\nIf is used, must be .\n• None applies only to the / leg of the OCO.\n• None OCO counts as 2 orders against the order rate limit.\n\nResponse format for is selected using the parameter. The following example is for response type. See for more examples.\n\nFor execution status of individual orders, use .\n• None refers to of the OCO itself.\n• None If both and parameters are specified, only is used and is ignored.\n• None If both and parameters are specified, only is used and is ignored.\n• None Canceling an individual leg with will cancel the entire OCO as well.\n\nIf you need to continuously monitor order status updates, please consider using WebSocket Streams:\n\nQuery information about all your orders – active, canceled, filled – filtered by time range.\n• If and/or are specified, is ignored.\n\nOrders are filtered by of the last execution status update.\n• None If is specified, return orders with order ID >= .\n• None If no condition is specified, the most recent orders are returned.\n• None For some historical orders the response field may be negative, meaning the data is not available at this time.\n\nStatus reports for orders are identical to .\n\nNote that some fields are optional and included only for orders that set them.\n\nQuery information about all your OCOs, filtered by time range.\n• If and/or are specified, is ignored.\n\nOCOs are filtered by of the last OCO execution status update.\n• None If is specified, return OCOs with order list ID >= .\n• None If no condition is specified, the most recent OCOs are returned.\n\nStatus reports for OCOs are identical to .\n\nQuery information about all your trades, filtered by time range.\n• None If is specified, return trades with trade ID >= .\n• None If and/or are specified, trades are filtered by execution time ( ).\n\ncannot be used together with and .\n• If is specified, only trades related to that order are returned.\n\nand cannot be used together with .\n• If no condition is specified, the most recent trades are returned.\n\nDisplays the list of orders that were expired due to STP.\n\nThese are the combinations supported:\n\nNote: The user data can ONLY be retrieved by a separate Websocket connection via the User Data Streams url (i.e. ).\n\nNote: the stream will close in 60 minutes unless requests are sent regularly.\n\nSubscribe to the received listen key on WebSocket Stream afterwards.\n\nPing a user data stream to keep it alive.\n\nUser data streams close automatically after 60 minutes, even if you're listening to them on WebSocket Streams. In order to keep the stream open, you have to regularly send pings using the request.\n\nIt is recommended to send a ping once every 30 minutes.\n• Streams can be accessed either in a single raw stream or in a combined stream\n• Combined stream events are wrapped as follows: {\"stream\":\"<streamName>\",\"data\":<rawPayload>}\n• All symbols for streams are in lowercase\n• A single connection to stream.binance.us is only valid for 24-hours; expect to be disconnected at the 24 hour mark\n• The WebSocket server will send a every 3 minutes. If the WebSocket server does not receive a back from the connection within a 10-minute period, the connection will be disconnected. Unsolicited are allowed.\n• WebSocket connections have a limit of 5 incoming messages per second. A message is considered:\n• A connection that goes beyond the limit will be disconnected; IPs that are repeatedly disconnected may be banned.\n• A single connection can listen to a maximum of 1024 streams.\n• The following data can be sent through the WebSocket instance in order to subscribe/unsubscribe from streams. Examples can be seen below.\n• The used in the JSON payloads is an unsigned INT used as an identifier to uniquely identify the messages going back and forth.\n• In the response, if the received is which means the request sent was a success for non-query requests (e.g., subscribing/unsubscribing).\n\nCurrently, the only property that can be set is whether stream payloads are enabled or not. The combined property is set to when connecting using (\"raw streams\") and when connecting using .\n• Streams can be accessed either in a single raw stream or in a combined stream\n• Combined stream events are wrapped as follows: {\"stream\":\"<streamName>\",\"data\":<rawPayload>}\n• All symbols for streams are lowercase\n• A single connection to stream.binance.us is only valid for 24-hours; expect to be disconnected at the 24 hour mark\n• The WebSocket server will send a every 3 minutes. If the WebSocket server does not receive a back from the connection within a 10-minute period, the connection will be disconnected. Unsolicited are allowed.\n\nThe Aggregate Trade Streams push trade information that is aggregated for a single taker order.\n\nThe Trade Streams push raw trade information; each trade has a unique buyer and seller.\n\nThe Kline/Candlestick Stream pushes updates to the current klines/candlestick every second.\n\nNote: This stream is different from the stream. The open time always starts at the beginning of the minute, while the closing time is the current time of the update. As such, the effective window might be up to 59999ms wider than .\n\n24hr rolling window ticker statistics for all symbols that changed in an array. These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs. Note that only tickers that have changed will be present in the array.\n\nRolling window ticker statistics for all market symbols, computed over multiple windows. Note that only tickers that have changed will be present in the array.\n\n24hr rolling window ticker statistics for a single symbol. These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs.\n\n24hr rolling window mini-ticker statistics. These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs.\n\n24hr rolling window mini-ticker statistics for all symbols that changed in an array. These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs. Note that only tickers that have changed will be present in the array.\n\nPushes any update to the best bid or asks price or quantity in real-time for a specified symbol.\n\nTop <levels> bids and asks, pushed every second. Valid <levels> are 5, 10, or 20.\n\nOrder book price and quantity depth updates are used to manage an order book locally.\n• Buffer the events you receive from the stream\n• Drop any event where is <= in the snapshot\n• The first processed should have <= +1 AND >= +1\n• While listening to the stream, each new event's should be equal to the previous event's +1\n• The data in each event is the absolute quantity for a price level\n• If the quantity is 0, remove the price level\n• Receiving an event that removes a price level that is not in your local order book is normal\n• A User Data Stream is valid for 60 minutes after creation.\n• Doing a on a will extend its validity for 60 minutes.\n• Doing a on a will close the stream and invalidate the .\n• Doing a on an account with an active will return the currently active and extend its validity for 60 minutes.\n• User Data Streams are accessed at /ws/<listenKey> or /stream?streams=<listenKey>\n• A single connection to stream.binance.us is only valid for 24 hours; expect to be disconnected at the 24-hour mark\n\nStart a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active , that will be returned and its validity will be extended for 60 minutes.\n\nKeepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It's recommended to send a ping about every 30 minutes.\n\nThe event is sent any time an account balance has changed and contains the assets that were possibly changed by the event that generated the balance change.\n\nOrders are updated with the event.\n\nCheck the REST API Documentation and below for relevant enum definitions.\n\nAverage price can be found by doing divided by .\n• NEW - The order has been accepted into the engine\n• CANCELED - The order has been canceled by the user\n• REPLACED - This is currently unused\n• REJECTED - The order has been rejected and was not processed (this is never pushed into the User Data Stream)\n• TRADE - Part of the order or all of the order's quantity has been filled\n• EXPIRED - The order was canceled according to the order type's rules (e.g., LIMIT FOK orders with no fill, LIMIT IOC or MARKET orders that partially fill) or by the exchange, (e.g., orders canceled during liquidation, orders canceled during maintenance)\n• TRADE_PREVENTION - The order has expired due to STP.\n\nBalance Update occurs during deposits or withdrawals from the account."
    },
    {
        "link": "https://algotrading101.com/learn/binance-python-api-guide",
        "document": "\n• What is the Binance API?\n• Why should I use the Binance API?\n• Why shouldn’t I use the Binance API?\n• What are the alternatives to using the Binance API?\n• Are there any Python libraries available for the Binance API?\n• How do I get started with the Binance API?\n• How do I retrieve my account balance using the Binance API?\n• How can I retrieve the latest price for Bitcoin?\n• How can I get Bitcoin’s historical price data in CSV format?\n• Should I trade futures or spot? What is the difference?\n• How to access technical indicators such as the 20 SMA\n• How to fire an order for Ethereum using the Binance API\n• How to implement a stop loss or take profit using the Binance API\n• How to use Binance Coin (BNB) for discounted trading commissions\n• How to execute a trade on ETH when BTC hits a certain price\n• How to execute an ETH trade when BTC moves 5% in the last 5 minutes\n\nWhat is the Binance API?\n\nThe Binance API is a method that allows you to connect to the Binance servers via Python or several other programming languages. With it, you can automate your trading.\n\nMore specifically, Binance has a RESTful API that uses HTTP requests to send and receive data. Further, there is also a WebSocket available that enables the streaming of data such as price quotes and account updates.\n\nWhy should I use the Binance API?\n\nBinance has established itself as a market leader when it comes to cryptocurrency trading. It currently ranks number one for Bitcoin volume according to coinmarketcap.com and ranks well for many other currencies.\n\nCommissions are very competitive and you may be hard-pressed to find another exchange with lower fees.\n\nLastly, Binance has a good track record of security. There have only been a few instances of Binance getting hacked which is something that all exchanges are susceptible to due to the nature of the business.\n\nThe most important part, when Binance got hacked in 2019, and more than $40 million was stolen, Binance covered the users that were impacted.\n\nWhy shouldn’t I use the Binance API?\n\nWhile security is a big plus point for Binance when it comes to exchanges, there are better alternatives, depending on your needs.\n\nIf your primary interest is trading Bitcoin, you might be better off trading Bitcoin futures with a regulated broker like Interactive Brokers for example.\n\nThe benefit of a regulated broker is that they have insurance schemes in place to protect the consumer.\n\nIf trading futures is not your thing, there are several regulated brokers that offer CFD trading on cryptocurrencies which can be a good alternative.\n\nIt should be noted that these options don’t have nearly as extensive of an offering as Binance. And in most cases, the trading fees are significantly higher.\n\nAnother challenge with API trading at Binance is that API changes occur often.\n\nAPI changes are generally a good thing. It means the exchange is trying to update and improve their infrastructure (most of the time).\n\nHowever, this involves keeping a close eye on Binance’s API announcements and updating our trading algorithms as required. Not all changes will lead to our code breaking, but some of them certainly can.\n\nThere are also outages. In late 2020, Binance took its API offline roughly once a month for a few hours each time for planned updates. This requires manual intervention and additional position management for algo traders.\n\nIn early 2021, amidst a surge in crypto prices, Binance experienced outages during volatile times due to an influx of new users signing up and a sharp rise in trading volume.\n\nBinance CEO Changpeng Zhao, better known as CZ, has commented several times that outages are normal in a growing industry such as crypto, and that users should expect it could happen again in the future.\n\nWhat are the alternatives to using the Binance API?\n\nCoinmarketcap has more than 300 exchanges listed in its database, and many of them offer an API. So there isn’t a shortage of alternatives.\n\nSome of the names that stand out from their list as well-established exchanges include Coinbase, Kraken, Bitfinex, Bitstamp, and Bittrex.\n\nFutures traders may also want to take a look at Bitmex which is a popular exchange with competitive commissions. They even pay you for certain order types rather than charging a trading fee.\n\nAre there any Python libraries available for the Binance API?\n\nThere are several third-party libraries available, the most popular is python-binance.\n\nThere is an interesting story on how this library came to be the most popular Python library for Binance.\n\nWhen Binance launched in 2017, they held a contest to see who can come up with the best library for various different programming languages. The winners were each rewarded 1000 Binance coins (BNB).\n\nAt the time of the contest, BNB was trading below $2 but it surged to a high $691 in the first half of 2021!\n\nThere were several good submissions for the Python category but python-binance ultimately won.\n\nThis was a clever approach to ensure the best developers worked hard to create a good library.\n\nAnother popular library is CCXT. This library supports over a hundred different exchanges and is available in many different programming languages.\n\nA third and perhaps lesser known option is Binance Connector which appears like it could be an official library as it is hosted under Binance’s Github page. There is also a recommendation and link to it in the Binance API documentation.\n\nCCXT is a good option if you plan to trade on multiple exchanges, or want the flexibility of switching to another exchange down the road without having to fully relearn another library.\n\nThe advantage to Python Binance is that a lot of people use it so it’s easy to get support and help from other users.\n\nLastly, Binance connector seems like it is often updated and a great library all around. The downside, however, is that the learning curve for it might be steep as there isn’t a lot of documentation or usage examples available for it.\n\nHow do I get started with the Binance API?\n\nThe first step is to create an account with Binance. You only need to enter your email and create a password – https://accounts.binance.com/en/register\n\nOptionally, if you’re interested in using a Referral ID, you can use ZCYOCDMQ to receive a 10% discount off your trading fees.\n\nThat’s my Referral ID, thanks for supporting me! – Jignesh\n\nYou will be asked if you want to enable two-factor authentication for additional security. We highly recommend that you do. If you’ve never used it before, you will need to install Google Authenticator.\n\nThere are tutorials on getting started on things like your first deposit and much more on Binance Academy.\n\nAfter logging in to your Binance account, click on the profile icon on the top right-hand side of the screen. From there, select API Management.\n\nNext, you will be asked to create a label for the API key. If you plan to create multiple keys, it’s a good idea to use a descriptive name here so that you can easily distinguish it later on.\n\nIf you have two-factor authentication enabled, you will be asked to authenticate once again at this point.\n\nBinance will send you an email to confirm the API key creation. Click on the confirmation link from your confirmation email to proceed.\n\nYour API key should be created at this point. Note that this is the only time your API secret will be revealed. If you navigate away from this screen, you will not be able to see it again.\n\nIn such a scenario, you will need to delete your API key and start over again by creating a new one.\n\nGuard your API details as you would with any password as anyone can get access to your account if they were able to get a hold of this information.\n\nBefore moving forward, there are a few settings here that we need to take a look at.\n\nThe Read Only option is selected by default, and you likely won’t be able to uncheck it.\n\nThis permits the API to read your account details and is enabled by default. Perhaps it is a bit misleading since it includes the term Only, but you can still perform other operations with this option checked.\n\nThere is also an option to Enable Trading, Enable Withdrawals, and Enable Future.\n\nIf you’re still testing out the API, it might be a good idea to leave these unchecked. If you’re ready to start trading, then check off the Enable Trading box and the Enable Future box if you plan to trade futures.\n\nFor some people, the Enable Future box won’t be shown here. That means the account is not set up for trading futures.\n\nNote: if the Enable Futures box is shown, you should still set up your futures account first before attempting to create an API key (if you plan to trade futures). Otherwise, it may lead to API authentication errors.\n\nIt is easy to setup Futures trading on your account if it is not already enabled. From the main Binance login page, click on the Derivatives option in the top menu bar.\n\nFrom there, click on Futures which should take you to the Futures trading screen. There should be an option on that page to open a Futures account.\n\nIf you plan to make withdrawals from within your Python trading script, you will need to enable it. To do so, you have to specify the IP address from where the script will be accessing the API. This is for security purposes.\n\nIf you intend on running your script from a virtual private server such as AWS, this shouldn’t be a big problem. However, if you are running the script from your local machine, you could run into issues as most internet service providers do not offer static IP addresses.\n\nThere are third-party solutions, such as noip.com that provide a way around not having a static IP.\n\nThe easiest way to install the python-binance library is to use pip. From the command line, simply type:\n\nWe recommend storing your API keys as environment variables. That way, if you upload your code to GitHub, or send it to someone, you don’t run at the risk of revealing your credentials.\n\nThis can be done via the command prompt. Here is the syntax for Windows users.\n\nYou can verify that the keys are saved right from the command prompt by launching Python. Here is an example:\n\nAnd this is how you can store environment variables on a Mac or in a Linux environment using the terminal.\n\nWe can later retrieve these values from within our Python trading script by using the os library.\n\nBefore jumping into live trading with the Binance API, there is an option to test out your Python trading script on the Binance API testnet.\n\nStart by going to the Binance Spot Test Network website, you can find it here – https://testnet.binance.vision/\n\nFrom there, you will have to create an account, even if you already have an account with Binance.com. We only saw an option to log on with a GitHub account.\n\nOnce you’re logged on, you will have to create new API keys. These will be separate from the keys created in the previous step and will be used only to access your demo account.\n\nChoose the option to generate a HMAC key. In the next step, enter in descriptive name for your key.\n\nAfter clicking generate, you will be taken to a screen that displays your key. If you leave this screen, you won’t be able to access they secret key again, and will have to start over.\n\nOnce you’re setup with the keys, all of the endpoints in the live API will be the same as in the Testnet API. The only difference is that you have to use a different URL to access Testnet.\n\nAt the time of writing, the python-binance library, which we’ve used in all the examples, does not support the Test Network. However, we will discuss a workaround in the next step.\n\nPlease note, Test Network accounts get deleted typically at the start of each month. Any open trades will be wiped out. More details about the Spot Test Network can be found on the same page where you go to create your key.\n\nHow do I retrieve my account balance using the Binance API?\n\nNow that we’ve installed the library and obtained API keys, it’s time to test out a connection to the API. We will start up a client and check out four functions that detail different account balances.\n\nWe start with our imports. We will need the Client class from the python-binance library as well as the os library to retrieve the API keys that we stored as environment variables.\n\nNext, we store our API key and secret to local variables.\n\nAnd finally, we initialize our client and pass through the API key and secret. We are all set to start accessing the API at t his point.\n\nUnfortunately, the python-binance library does not have support for the demo environment previously discussed. However, we were able to connect by manually changing the API endpoint URL in the library like this:\n\nIf you decide to start with the demo API, make sure you are passing through your Test Network API credentials when initializing the Client and not the live API keys.\n\nThe above code will print out all of our account details for every currency available on the platform. It will also provide some other info such as the current commission rate and if your account is enabled for margin trading.\n\nThis might be a bit too much information. If we are only interested in our BTC balance, we can use another endpoint.\n\nIf you’re after the balance details of another asset, simply switch out BTC with the asset you are after.\n\nAccount balances for futures accounts are separate from the main balance and therefore require a different endpoint.\n\nSimilarly, margin account details are separated as well. Here is how you can access your margin account. Note that an exception will be raised if you have not activated a margin account.\n\nIf you’re not familiar with margin trading, you can check out the Binance guide: What is Margin Trading for more details and the Binance Margin Trading Guide for setup instructions.\n\nHow can I retrieve the latest price for Bitcoin?\n\nThere are several methods to get the latest price for Bitcoin. The simplest one involves using the function.\n\nYou can pass through any ticker here as opposed to BTCUSDT if you’re after another asset.\n\nThe code above will print out a dictionary that contains the symbol and the price. Here is an example output –\n\nWe can access just the price as follows.\n\nIn a live Python trading script, we would likely need up to date price information for the asset that we are trading. Fortunately, there is a better solution than constantly making requests to the API. It involves using Binance WebSocket.\n\nUsing the Binance WebSocket for the latest Bitcoin price\n\nThe Binance WebSocket requires us to only send a command once to open up a stream, and then data will automatically stream over as prices get updated.\n\nWe need to import the ThreadedSocketManager to use this function, along with the sleep function from the time module.\n\nNext we will create a dictionary that will hold our latest price data and also let us known if there is a problem with the websocket.\n\nThen, we will create a function that will tell the socket manager what to do when it receives new data.\n\nFor now, we will just print the last closing price to the screen.\n\nWe are also storing a few items to the dictionary file that we created earlier. This allows us to access the data outside the function and this is how you would typically access websocket data from your main trading script.\n\nAside from the latest price, bid, and ask, we also have error checking built in. This will let us know if there is an error with the Binance WebSocket, in which case we will need to restart it.\n\nA latter example involving the websocket expands on the error checking part.\n\nYou may have noticed that Binance doesn’t use full variable names. IE the close price comes over the websocket in a variable called ‘c’ rather than ‘close’. Binance probably did this to keep the overall size of the message minimal in an attempt to boost communication speed.\n\nIf you’re ever trying to program a new websocket connection and are unsure what the variables stand for, check out the Binance API documentation. They have a detailed explanation of what each component of the websocket message is used for.\n\nThe next step is to initialize the socket manager. When we do that, the library will create a new thread which we’ve started in the code snippet above.\n\nWe will call the which has similar output to the function of the API that we discussed earlier.\n\nWe need to pass through a symbol, which in this case is BTCUSDT. We also specify it to call our custom function every time a new message comes in.\n\nIf you’re following along, you should see a stream of prices on your screen if you run the above code. It should look similar to the Trade History box that is on the Binance webpage under the spot trading section.\n\nIn a live Python trading script, you will access the data from the dictionary file outside the function as opposed to printing the data to screen from the function.\n\nBinance has several websocket streams and we can easily add more.\n\nThe code snippet above subscribes to the ticker price for ETHUSDT. We kept the callback as btc_trade_history. That means when a new message arrives for ETHUSDT, it will get handled by the same btc_trade_history function we created.\n\nThis is just for example purposes, to show how you can easily add more streams. You can choose to create a separate function for other streams if need be.\n\nWhen you’re done with the WebSocket, use the following syntax to properly terminate it:\n\nThe WebSocket can deliver various data. To get a full view of what is available, type the following in your Python terminal.\n\nThis will list all the different methods available as well as give some information about the returned data.\n\nHere is an example for the start_symbol_ticker_socket:\n\nAs you can see it gives a brief description, a link to the official Binance documentation about that function, and some details about the returned data.\n\nThis is another way to figure out that returns the best bid, besides checking the documentation.\n\nHow can I get Bitcoin’s historical price data in CSV format?\n\nWe will request historical Bitcoin price data from the Binance API and then outline four options to save that data to a CSV file.\n\nWe want data that goes as far back as possible. Fortunately, there is a function within the library that allows us to determine the first available price point.\n\nIn the code snippet above, we’ve called the function and passed in BTCUSDT as our symbol and 1d as our timeframe. The output is saved to a variable.\n\nNext, we make the call for historical data. Once again we need to pass through the symbol and variable. Also, a starting date is required and we’ve used our timestamp variable for that.\n\nLastly, this function by default calls the last 500 points of data. The maximum is 1000 so we’ve increased the limit to the maximum.\n\nIn the background, this endpoint will continuously query the API in a loop, collecting 1000 price points at a time, until all data from the start point until today is returned.\n\nIn an effort to be ‘kind’ to the API, there is a sleep function built-in after every third call. So this could take a while if you’re looking for say 1-minute data from the very start.\n\nBinance began operations over the summer of 2017, so that will likely be the earliest price point available.\n\nHere is a definition of the data returned as per the Binance API documentation.\n\nNow that we have our date, let’s go through four different options to save it to a file.\n\nThe first involves using the JSON library. This will maintain the structure of the data which is a list of lists. If you want to keep this structure, this is the way to go. Make sure to .\n\nThe second method uses csv writer to save the list as a CSV file. Make sure to .\n\nThe third option doesn’t use any library. We’ve created an f string which is a native function of Python 3 and above.\n\nThere is a bit more flexibility here. We’ve taken advantage of it and only saved the first five columns: date, open, high, low, close.\n\nAlternatively, you can also delete the additional columns, if you don’t need them, like this:\n\nThe last option is to utilize the export to CSV function of Pandas. It makes sense to use this option if you plan on holding your data in a DataFrame anyway.\n\nWe’ve passed through our data into a DataFrame and defined the columns. Since we’ve deleted some unwanted columns, there are only five that need to be defined.\n\nThis is what our DataFrame looks like at this point –\n\nThe date column has been set as an index which makes it a time-series indexed DataFrame. This way, it’s easier to manipulate based on time frames later. It also removes an extra not needed index column when we go to save it as a CSV.\n\nLastly, we can export the DataFrame as a CSV file.\n\nUPDATE August 30, 2021: Binance has launched a new website that hosts historical market data for both the spot and futures markets.\n\nThe website can be accessed by clicking on the following URL – Binance Data Collection\n\nFrom there, choose the relevant market (spot or futures). And then, you can choose the time frame for the data. I.E. monthly or daily.\n\nAt this point, you can pick the type of data you’re after. The common data types are:\n• klines – Also known as candles or bars. This data has the OHLC format (Open, High, Low, Close)\n• Trades – A record of all the trades that took place. Also known as tick data\n\nThe data is in ZIP format. Once unzipped, it will be in CSV format.\n\nThe website is a good way to download market data in bulk. Binance created it to try and discourage API usage for downloading large amounts of data. This is so that API can be prioritized for other usage such as sending orders.\n\nIf you do use the API to download historical data in bulk, you may notice that it takes a long time. This is because Binance throttles these types of API requests.\n\nFurther, the python-binance library implements delays in certain market data requests (like tick data) to ensure you don’t accidentally receive an API ban by overloading the API.\n\nShould I trade futures or spot? What is the difference?\n\nIn the futures market, you can enter a contract to buy a cryptocurrency at a later date. This means you don’t take actual ownership if you enter in a trade to.\n\nIn fact, most futures traders never take ownership. Trading futures is mostly for speculative purposes, even though it was designed for other reasons.\n\nThe major advantage of trading futures is that you can short assets that you do not own. This can be useful in arbitrage and hedging strategies.\n\nAnother aspect of futures trading is that it is done on margin. This means you only need to put up a portion of the trade value, allowing you to employ leverage.\n\nBinance has a separate option to trade spot markets on margin. But there are fairly low limits to how much you can short, and the interest (borrowing costs) are much higher than trading futures.\n\nBecause of various carrying costs, the futures price usually differs from the main markets, or otherwise known as the spot price. However, the prices will usually converge by the expiration date of the futures contract.\n\nWith Binance, a big advantage of trading futures is that the trading fees are quite a bit lower compared to spot. So there are quite a few reasons to trade the futures markets.\n\nHere are a few reasons you may not want to trade futures:\n• You plan to trade many different crypto’s, possibly against each other – the current futures offering from Binance is currently limited to popular USDT pairs.\n• You want to own crypto and maybe store it in an offline wallet.\n\nThe Binance API uses a different endpoint for futures trading. But if you’re using the python-binance library, these endpoints are already configured in the library.\n\nFurther, the futures functions within the library have been appropriately labeled to distinguish them from the spot markets.\n\nAs an example, if you’re trading spot, you would use the following function to access your open orders:\n\nIf you’re trading futures, you would use:\n\nHow to access technical indicators such as the 20 SMA?\n\nThere are several libraries available that ease the process of calculating technical indicators.\n\nWe’ve already discussed how you can export a DataFrame as a CSV file. There’s a lot more you can do with Pandas and calculating a moving average is one of them.\n\nIn the above code, we loaded our data from the CSV file we created earlier. Then we use the mean() function to calculate the average on the close column.\n\nThe rolling function allows us to set a period for the moving average. This all gets appended to the existing DataFrame. This is what the result looks like.\n\nAs you can see, a new column has been created with the 20 moving average.\n\nLet’s say you only need to know where the moving average is as of right now. Or as of the last price point in the DataFrame.\n\nWe can use the same mean() function and just run it on the last 20 rows of the DataFrame like this:\n\nThere is a lot more Pandas can do. We can easily grab the highest price Bitcoin traded this year as follows –\n\nBut Pandas isn’t able to calculate other technical indicators such as RSI, or MACD. The Binance API does not provide this info either.\n\nTA-LIB has been a popular library for some time. We recently got a chance to test out a new library – bta-lib.\n\nThis library was created by the author of Backtrader. He discusses on his blog that TA-LIB has several indicators that were improperly implemented.\n\nFurther, TA-LIB wasn’t designed for Python. There is a wrapper available but there is much less overhead going with a solution designed for Python.\n\nBta-lib can be installed using PIP as follows.\n\nLet’s try calculating the same moving average with the library as a comparison –\n\nWe now have a separate DataFrame that contains the values for the moving average. It looks like this:\n\nNote that bta-lib will return an object to our sma variable. To access the DataFrame that is contained within it, simply type after the variable name.\n\nBy default, the library uses the 30 period moving average.\n\nWe can duplicate the same function we had before and calculate the 20 moving average and attach it as a column to our original DataFrame like this.\n\nLet’s create a few more indicators. Here is how we can calculate the RSI using the bta-lib library –\n\nOnce again, an object containing a df has been returned. We can access the very last value like this.\n\nIn a live environment, you might only need the very last value.\n\nHere is how we can calculate the MACD for Bitcoin in bta-lib.\n\nFinally, we will join our RSI and MACD values to our original Bitcoin price DataFrame\n\nAnd now we have all our calculations easily accessible from one DataFrame –\n\nHow to fire an order for Ethereum using the Binance API?\n\nThe library we are using has a function that allows us to create test orders. Here is an example:\n\nWe can make sure our syntax is correct without having to submit a live order. This is very useful when you are getting to know the API.\n\nIf we change the type in the above code to ‘MARKET’ for example, it will throw an exception. The reason being is that a timeInForce and price parameters are not used for market orders. Instead, a market order would look like this:\n\nOnce your satisfied the syntax is correct, simply swap out the for the .\n\nNote: If you’re following along with the example, you may get an API error when using the above limit order code for ETHUSDT if the price has moved significantly since this was written. Binance will only allow orders that are within a certain percentage distance of the price the coin is currently trading at.\n\nSince there could be an exception, we will wrap our code in a try/except block and also import some of the defined exceptions from the library.\n\nIn addition to the client and the custom exceptions, we have imported binance.enums, which we will discuss shortly.\n\nHere is the order code block.\n\nAn order confirmation will be sent back from the exchange and stored in our buy_limit variable. This is what it looks like:\n\nIt is in a dictionary format. Note that it contains an orderId. We can use this id to cancel the limit order like this –\n\nOnce again, we receive confirmation. We can print out the cancel variable to view it.\n\nThe function is the main method to place an order. We can pass through several parameters here.\n\nBut there are certain orders which are common, and helper functions have been created for them. They shorten the code required to place an order, making things a bit easier. Here are a few examples:\n\nHere are some of the helper functions you might want to use:\n\nThe last two are considered advanced order types. OCO stands for One Cancels the Other.\n\nA good example of this is when you’re using a stop loss and a take profit target. If one of these order got hit, you would want the other to get canceled.\n\nSome of the order types require string constants such as ‘MARKET‘ or ‘BUY‘. Another broker might use ‘MKT‘ instead and so there isn’t always a logical answer as to what you should use.\n\nYou can look these up in the documentation if needed. Alternatively, the library has hard coded strings into variables that you can use.\n\nThis is especially useful if your coding editor has autocomplete as you can quickly figure which parameters to use without having to pull up the documentation.\n\nHere is an example of an order without using the built-in variables:\n\nAnd here is the same thing using the built-in variables.\n\nIf you plan to go this route, you will need the enums import discussed earlier.\n\nA full list of all the hard coded strings can be found here .\n\nHow to implement a stop loss or take profit using the Binance API?\n\nThe method to place stop losses or take profits differs with cryptocurrencies compared to other markets such as stocks or Forex.\n\nThe reason being, with stocks, you have a base currency. This is often in USD. Once you buy a stock, you are in a ‘trade’. At some point, you will want to sell that stock and return to your base USD currency.\n\nWith crypto, there really isn’t a concept of a base currency. When you conduct a trade, you are swapping one currency for another. The system doesn’t view it as a ‘trade’ that you eventually want to get out of.\n\nFor this reason, Binance does not allow you to natively attach a stop loss and a take profit to your main order.\n\nBut we can still implement one manually.\n\nTo do this, we can place an OCO order. The idea is, that if either the stop loss or take profit gets hit, the other order should be canceled.\n\nGoing back to our ETH order, here is how we can implement a stop loss and take profit.\n\nNote that we are passing in both a stopPrice and a stopLimitPrice. Once the stopPrice level gets hit, a limit order will be placed using the stopLimitPrice. In most cases, the prices will be the same for both of these parameters.\n\nWhile most assets accept stop-loss limit order, not all of them do. Before placing your order, it’s a good idea to check if it is supported.\n\nYou can use the exchange info endpoint for this.\n\nHere is the response –\n\nUnder orderTypes, it shows that a stop-loss limit is indeed accepted for this asset.\n\nThere is other useful info here, such as whether the asset can be traded on margin or not, the minimum quantity, and the tick size.\n\nHow to use Binance Coin (BNB) for discounted trading commissions?\n\nCommissions add up quickly, but fortunately, there is a discount scheme.\n\nThe image above shows the fee schedule and discounts for trading the spot market. There are discounts for futures trading too.\n\nYou can either qualify for a discount depending on your trading volume or the quantity of Binance coin you own.\n\nBinance coin or BNB was created by Binance in 2017. It can be used as a currency although perhaps the more common usage for it is to pay trading fees.\n\nIf you’re not keen on owning BNB, it still makes sense to own just a little bit to pay your trading fees with. After all, any amount of BNB will qualify you for the first tier.\n\nKeep in mind, if you’re using BNB to pay for trading fees, your balance will reduce over time.\n\nThe function below ensures there is a minimum amount of BNB in your account and tops it up if there isn’t.\n\nTrading scripts are usually run in a loop, so periodically calling the above function will ensure there is enough BNB in the account to qualify for the minimum discount.\n\nAs an example, we can call the above function like this –\n\nThis would check for a balance of at least 1 BNB. If the amount of BNB has dropped below that, it will top it off to bring the account up to 2.5 BNB.\n\nTo use BNB to pay for trading fees and receive a discount, it needs to be enabled. From the main Binance page, click on the profile icon on the top right once logged in.\n\nThe first option should be your email address, click on that to get to your dashboard. From there, there will be a section that looks like this –\n\nThis is where you can enable and disable the option to pay for trading fees with BNB.\n\nHow to execute a trade on ETH when BTC hits a certain price?\n\nIn the next example, we will place a buy order in Ethereum when Bitcoin crosses above the $10,000 price point.\n\nWe will use the Binance WebSocket to track the price of Bitcoin.\n\nThe code above looks very similar to the prior example where we showed how to use the WebSocket.\n\nNext, we have our callback function. This is where all the WebSocket data will flow through. We could have programmed our trading logic here as well.\n\nHowever, since we need to use a try/except block for our order entry, it’s best not to as this could interfere with error checking that takes place on the back end, in the library.\n\nWe will start the WebSocket and direct it to the function we just created.\n\nBefore getting started, a quick check to make sure we have data.\n\nThe above infinite loop will break as soon as soon as the WebSocket populates our price dictionary with a new value.\n\nOn to the main trade logic.\n\nHere we are checking to see if the price is above our parameter, $10,000 in this case. If so, we send a market order to buy ETHUSDT.\n\nAfter a buy order is sent, we break out of the loop and our script completes.\n\nHow to execute an ETH trade when BTC moves 5% in the last 5 minutes?\n\nWe will once again make a trading decision for Ethereum based on Bitcoin. Although in this example, we are looking for a price move larger than 5% over the past five minutes.\n\nSo if Bitcoin rallies more than 5% we buy Ethereum. If it declines by more than 5%, we will sell Ethereum.\n\nSince we could be taking a short position here, we will be trading futures. In the spot market, you can only sell if you already own that cryptocurrency.\n\nOur imports and most of the initial part of our script have not changed. The main difference here is that we are using Pandas as we will store incoming data from the WebSocket into a DataFrame.\n\nTherefore, we have imported Pandas and created a blank DataFrame in our price dictionary. The DataFrame has two columns, one for the date, or rather time. And the other column will hold the price.\n\nThe callback function contains the code to populate the DataFrame from WebSocket data.\n\nWe are using the function to append data into the DataFrame via the last index value. We use the length of the DataFrame to determine the index value.\n\nAt that point, we are just inserting the current time, obtained by using the Timestamp function from Pandas, and the price from the socket stream.\n\nNow that we have our callback function created, we will start the WebSocket.\n\nOnce again, we will do a quick check to make sure data is streaming.\n\nBefore starting the main trade logic, we will put the script to sleep for five minutes since we need at least that much data.\n\nIn our main loop, we first grab our DataFrame from the dictionary file and assign it to the variable df. This step is not necessary but makes the code easier to read for our example.\n\nNext, we determine the time five minutes ago. We can do that by taking the last date value from our DataFrame and subtracting 5 minutes using the Timedelta function built into Pandas. We will assign this value to the variable start_time.\n\nWith the start_time value, we can filter our DataFrame down to contain only the last five minutes of data.\n\nFrom there, we can use max() and min() functions from Pandas to find the highest and lowest price.\n\nNow all we need to do is determine if there was a larger than 5% movement between the last price and either the maximum or minimum value.\n\nIf the latest price is 5% larger than the last value, we know Bitcoin is going up, and we will short Ethereum as part of our mean reversion strategy.\n\nIf the last price is 5% lower than the max price in our DataFrame, then we do the opposite.\n\nNote that the library does not have helper functions for orders in the futures market so we are using a method similar to the create_order function used for the spot markets.\n\nOnce again, if our order gets filled, we will break out of our main loop and properly terminate the WebSocket.\n\nThis strategy, however, might be one that could be run indefinitely. If you don’t plan to break out after placing an order, it is a good idea to put the script to sleep for a period of time.\n\nOtherwise, new orders will be sent on every tick until the 5% divergence gap closes.\n\nOur overall view of Binance is that it is a great exchange. It’s hard to beat their commissions, they have a good reputation, and having access to a WebSocket to stream data makes life a lot easier.\n\nIf you plan on using the Binance API, we highly recommend joining their Telegram groups. They have one group for API announcements which will keep you up to date on any planned or unplanned outages.\n\nThey also have another group for general API discussions. This group is moderated and the admins are usually good at answering any API specific questions.\n\nWe recommend that you further investigate error handling. Some people are fine with logging errors to a log file. However, if your trading strategy requires precision and could get negatively impacted on a failed API call, other measures can be taken.\n\nCheck out our article on the Interactive Brokers API where we discussed using the Telegram API as an alert system. This might be a good method to alert you if there is an error calling the API.\n\nLastly, if speed is a major factor in your trading script, and you plan on running it on a virtual server, consider using a server based in Asia.\n\nBinance uses AWS servers out of Tokyo so either using the same server or one nearby will yield faster speeds. We were able to cut our API request times down by nearly 200ms by running our scripts from AWS Tokyo compared to US based servers.\n\nIf you’ve never used AWS before, they offer a free server for one year for new customers. The promotion is for a server on the ‘micro’ tier which is more than sufficient to run a basic Python script.\n\nAll the code examples used here are available for download on GitHub. Please feel free to download them to get a first-hand experience with the API. Just be careful with some of the order scripts so as not to accidentally send a market order to a live account!"
    },
    {
        "link": "https://github.com/ccxt/ccxt/issues/11297",
        "document": "fetchPositions() on Binance COIN-M futures raises KeyError: 'precision', could not reproduce this error with a fresh application but an older running instance produce this error always. Issue might be related to the changes for #11123 ."
    },
    {
        "link": "https://github.com/ccxt/ccxt/issues/13162",
        "document": "When I run get_position especially fapiPrivateGetPositionRisk(), I got the error shown below. When I run different functions such as load_markets(), it succeeded. I'm pretty sure that the API is correct and I checked the options of \"Enable Margin Loan, Repay & Transfer\" in binance website."
    },
    {
        "link": "https://docs.ccxt.com",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/59788120/python-cryptocurrency-ccxt-ftx-fetch-my-trades-keyerror-symbol",
        "document": "I use the CCXT module to communicate with multiple cryptocurrency exchanges. However when trying to request my trades or other orders I get the error \"Key error symbol\" even tho i use a Valid symbol and other functions work.\n\nI have tried other symbols and markets but without succses"
    },
    {
        "link": "https://stackoverflow.com/questions/72175716/cannot-create-sell-order-python-ccxt-binance-does-not-have-market-symbol-usdt-b",
        "document": "I am using python ccxt module to create a sell order in some binance account. First I create the exchange client\n\nThen when I try to use its method to create a market sell order I get the following error:\n\nSo seems like there is no ticker for selling USDT for BTC, while it works for the BTC/USDT ticker.\n\nHow could I create a sell order to buy BTC with USD using this method? The same happens with MANA: there are no tickers!\n\nSo I can neither sell MANA.\n\nI don't want to create a buy order instead because calculating the amount I could buy with my available USDT is not straightforward."
    }
]