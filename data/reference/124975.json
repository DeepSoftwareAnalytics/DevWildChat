[
    {
        "link": "https://stackoverflow.com/questions/73991892/what-is-the-best-way-to-add-assimp-to-a-cmake-project",
        "document": "I'm trying to build assimp as a static library to link it with my executable in a CMakeFile.txt file. The executable builds just fine but problem with this is that it takes a long time to link every time I try to build the project.\n\nHere is my CMakeFile.txt:\n\nMy question is this: Is there a way to reduce the time it takes to link this static library, or would it better to compile assimp as a DLL?"
    },
    {
        "link": "https://stackoverflow.com/questions/73124455/the-best-way-to-include-assimp-library-using-cmake",
        "document": "I build my project using cmake (It is important for me to work both generators: Ninja and Visual Studio). And I need to add assimp library to my project. So, I added assimp from git to my project as git submodule and as suggested in the docs I added this lines to my CMake:\n• None By default assimp compiles as shared lib, so why I should use , if as far as i know it's link my executable with static library? And anyway after this linkage my .exe requires .dll.\n• None Also, as alternative, I tried to compile assimp as static lib, as specified in the documentation I should use . I added this flag to my main CMakeLists.txt. But it still compiles two files:\n\nI thought that I could choose one of them, but no: after linkage with static lib ( ) it's anyway requires .dll.\n\nNote: .dll is uncomfortable for me, because I don't want to move the .dll to my .exe directory everytime. Also, variants like donwloading assimp from vcpkg or adding .dll to PATH don't work to me, because my main goal is: the user should just clone my git repo and compile the whole project with all dependecies using only one my CMakeLists.txt without additional actions."
    },
    {
        "link": "https://github.com/assimp/assimp/blob/master/Build.md",
        "document": "You need to install\n\nMake sure you have a working git-installation. Open a command prompt and clone the Asset-Importer-Lib via:\n• For assimp.lib without any tools:\n• For assimp with the common tools like assimp-cmd\n\nNote that by default this builds a shared library into the directory. If you want to build it as a static library see the build options at the bottom of this file.\n\nFirst, you have to install Visual-Studio on your windows-system. You can get the Community-Version for free here: https://visualstudio.microsoft.com/de/downloads/ To generate the build environment for your IDE open a command prompt, navigate to your repo and type:\n\nThis will generate the project files for the visual studio. All dependencies used to build Asset-Importer-Lib shall be part of the repo. If you want to use you own zlib installation this is possible as well. Check the options for it.\n\nOlder versions of MinGW's compiler (e.g. 5.1.0) do not support the -mbig_obj flag required to compile some of assimp's files, especially for debug builds. Version 7.3.0 of g++-mingw-w64 & gcc-mingw-w64 appears to work.\n\nPlease see CMake Cross Compiling for general information on CMake Toolchains.\n\nSome users have had success building assimp using MinGW on Linux using polly.\n\nThe following toolchain, which is not maintained by assimp, seems to work on Linux: linux-mingw-w64-gnuxx11.cmake\n\nThe following toolchain may or may not be helpful for building assimp using MinGW on Windows (untested): mingw-cxx17.cmake\n\nBesides the toolchain, compilation should be the same as for Linux / Unix.\n\nThe cmake-build-environment provides options to configure the build. The following options can be used:\n• BUILD_SHARED_LIBS (default ON): Generation of shared libs (dll for windows, so for Linux). Set this to OFF to get a static lib.\n• ASSIMP_DOUBLE_PRECISION (default OFF): All data will be stored as double values.\n• ASSIMP_OPT_BUILD_PACKAGES (default OFF): Set to ON to generate CPack configuration files and packaging targets.\n• ASSIMP_BUILD_ZLIB (default OFF): Build our own zlib.\n• ASSIMP_BUILD_ALL_EXPORTERS_BY_DEFAULT (default ON): Build Assimp with all exporters enabled.\n• ASSIMP_BUILD_ALL_IMPORTERS_BY_DEFAULT (default ON): Build Assimp with all importers enabled.\n• ASSIMP_BUILD_ASSIMP_TOOLS (default OFF): If the supplementary tools for Assimp are built in addition to the library.\n• ASSIMP_BUILD_SAMPLES (default OFF): If the official samples are built as well (needs Glut).\n• ASSIMP_BUILD_TESTS (default ON): If the test suite for Assimp is built in addition to the library.\n• ASSIMP_COVERALLS (default OFF): Enable this to measure test coverage.\n• ASSIMP_INSTALL (default ON): Install Assimp library. Disable this if you want to use Assimp as a submodule.\n• ASSIMP_WARNINGS_AS_ERRORS (default ON): Treat all warnings as errors.\n• ASSIMP_BUILD_DOCS (default OFF): Build documentation using Doxygen. OBSOLETE, see https://github.com/assimp/assimp-docs\n• ASSIMP_IGNORE_GIT_HASH (default OFF): Don't call git to get the hash.\n• USE_STATIC_CRT (default OFF): Link against the static MSVC runtime libraries.\n• ASSIMP_BUILD_ASSIMP_VIEW (default ON, if DirectX found, OFF otherwise): Build Assimp view tool (requires DirectX).\n\nYou can download and install assimp using the vcpkg dependency manager:\n\nThe assimp port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please create an issue or pull request on the vcpkg repository.\n\nYou can install the Asset-Importer-Lib via apt:\n\nYou need to have pip installed:"
    },
    {
        "link": "https://learnopengl.com/Model-Loading/Assimp",
        "document": "In all the scenes so far we've been extensively playing with our little container friend, but over time, even our best friends can get a little boring. In bigger graphics applications, there are usually lots of complicated and interesting models that are much prettier to look at than a static container. However, unlike the container object, we can't really manually define all the vertices, normals, and texture coordinates of complicated shapes like houses, vehicles, or human-like characters. What we want instead, is to import these models into the application; models that were carefully designed by 3D artists in tools like Blender, 3DS Max or Maya.\n\nThese so called allow artists to create complicated shapes and apply textures to them via a process called . The tools then automatically generate all the vertex coordinates, vertex normals, and texture coordinates while exporting them to a model file format we can use. This way, artists have an extensive toolkit to create high quality models without having to care too much about the technical details. All the technical aspects are hidden in the exported model file. We, as graphics programmers, do have to care about these technical details though.\n\nIt is our job to parse these exported model files and extract all the relevant information so we can store them in a format that OpenGL understands. A common issue is that there are dozens of different file formats where each exports the model data in its own unique way. Model formats like the Wavefront .obj only contains model data with minor material information like model colors and diffuse/specular maps, while model formats like the XML-based Collada file format are extremely extensive and contain models, lights, many types of materials, animation data, cameras, complete scene information, and much more. The wavefront object format is generally considered to be an easy-to-parse model format. It is recommended to visit the Wavefront's wiki page at least once to see how such a file format's data is structured. This should give you a basic perception of how model file formats are generally structured.\n\nAll by all, there are many different file formats where a common general structure between them usually does not exist. So if we want to import a model from these file formats, we'd have to write an importer ourselves for each of the file formats we want to import. Luckily for us, there just happens to be a library for this.\n\nA very popular model importing library out there is called Assimp that stands for Open Asset Import Library. Assimp is able to import dozens of different model file formats (and export to some as well) by loading all the model's data into Assimp's generalized data structures. As soon as Assimp has loaded the model, we can retrieve all the data we need from Assimp's data structures. Because the data structure of Assimp stays the same, regardless of the type of file format we imported, it abstracts us from all the different file formats out there.\n\nWhen importing a model via Assimp it loads the entire model into a scene object that contains all the data of the imported model/scene. Assimp then has a collection of nodes where each node contains indices to data stored in the scene object where each node can have any number of children. A (simplistic) model of Assimp's structure is shown below:\n• All the data of the scene/model is contained in the object like all the materials and the meshes. It also contains a reference to the root node of the scene.\n• The of the scene may contain children nodes (like all other nodes) and could have a set of indices that point to mesh data in the scene object's array. The scene's array contains the actual objects, the values in the array of a node are only indices for the scene's meshes array.\n• A object itself contains all the relevant data required for rendering, think of vertex positions, normal vectors, texture coordinates, faces, and the material of the object.\n• A mesh contains several faces. A represents a render primitive of the object (triangles, squares, points). A face contains the indices of the vertices that form a primitive. Because the vertices and the indices are separated, this makes it easy for us to render via an index buffer (see Hello Triangle).\n• Finally a mesh also links to a object that hosts several functions to retrieve the material properties of an object. Think of colors and/or texture maps (like diffuse and specular maps).\n\nWhat we want to do is: first load an object into a object, recursively retrieve the corresponding objects from each of the nodes (we recursively search each node's children), and process each object to retrieve the vertex data, indices, and its material properties. The result is then a collection of mesh data that we want to contain in a single object.\n\nIn the next chapters we'll create our own and class that load and store imported models using the structure we've just described. If we then want to draw a model, we do not render the model as a whole, but we render all of the individual meshes that the model is composed of. However, before we can start importing models, we first need to actually include Assimp in our project.\n\nYou can download Assimp from their GitHub page and choose the corresponding version. For this writing, the Assimp version used was version . It is advised to compile the libraries by yourself, since their pre-compiled libraries don't always work on all systems. Review the Creating a window chapter if you forgot how to compile a library by yourself via CMake.\n\nA few issues can come up while building Assimp, so I'll note them down here with their solutions in case any of you get the same errors:\n• CMake continually gives errors while retrieving the configuration list about DirectX libraries missing, messages like: Could not locate DirectX CMake Error at cmake-modules/FindPkgMacros.cmake:110 (message): Required library DirectX not found! Install the library (including dev packages) and try again. If the library is already installed, set the missing variables manually in cmake. The solution here is to install the DirectX SDK in case you haven't installed this before. You can download the SDK from here.\n• While installing the DirectX SDK, a possible error code of could pop up. In that case you first want to de-install the C++ Redistributable package(s) before installing the SDK.\n\nOnce the configuration is completed, you can generate a solution file, open it, and compile the libraries (either as a release version or a debug version, whatever floats your boat). Be sure to compile it for 64-bit as all LearnOpenGL code is 64 bit.\n\nThe default configuration builds Assimp as a dynamic library so we need to include the resulting DLL named (or with some post-fix) alongside the application's binaries. You can simply copy the DLL to the same folder where your application's executable is located.\n\nAfter compiling the generated solution, the resulting library and DLL file are located in the or folder. Then simply move the lib and DLL to their appropriate locations, link them from your solution, and be sure to copy Assimp's headers to your directory (the header files are found in the folder in the files downloaded from Assimp).\n\nBy now you should have compiled Assimp and linked it to your application. If you still received any unreported error, feel free to ask for help in the comments."
    },
    {
        "link": "https://reddit.com/r/opengl/comments/y274id/compiling_assimp",
        "document": "I have tried compiling Assimp from source numerous times. No matter how I try to compile it: local installation with make install, tried different versions, even as a submodule of my project. It always fails with some compile error, every time a different one.\n\nThe only way I can use the library is through Msys2-mingw32-w64. Is it even worth using assimp as a submodule\n\nBtw I am using the mingw compiler.\n\nEdit: on Github I got the answer that assimp was never meant to be compiled with minGW. clang, msvc and regular gcc work."
    },
    {
        "link": "https://github.com/assimp/assimp",
        "document": "Open Asset Import Library is a library that loads various 3D file formats into a shared, in-memory format. It supports more than 40 file formats for import and a growing selection of file formats for export.\n\nAPIs are provided for C and C++. Various bindings exist to other languages (C#, Java, Python, Delphi, D). Assimp also runs on Android and iOS. Additionally, assimp features various mesh post-processing tools: normals and tangent space generation, triangulation, vertex cache locality optimization, removal of degenerate primitives and duplicate vertices, sorting by primitive type, merging of redundant materials and many more.\n• Ask questions at the Assimp Discussion Board.\n• Ask the Assimp community on Reddit.\n• Ask on StackOverflow with the assimp-tag.\n• Nothing has worked? File a question or an issue report at The Assimp-Issue Tracker\n\nSee the complete list of supported formats.\n\nStart by reading our build instructions. We are available in vcpkg, and our build system is CMake; if you used CMake before there is a good chance you know what to do.\n\nQt5-ModelViewer is a powerful viewer based on Qt5 and Assimp's import and export abilities.\n\n Assimp-Viewer is an experimental implementation for an Asset-Viewer based on ImGUI and Assimp (experimental).\n\nOpen Asset Import Library is implemented in C++. The directory structure looks like this:\n\nThe source code is organized in the following way:\n\nI would greatly appreciate contributing to assimp. The easiest way to get involved is to submit a pull request with your changes against the main repository's branch.\n\nThis project exists thanks to all the people who contribute. [Contribute].\n\nBecome a financial contributor and help us sustain our community. [Contribute]\n\nYou can support the project with your organization. Your logo will show up here with a link to your website. [Contribute]\n\nOur license is based on the modified, 3-clause BSD-License.\n\nAn informal summary is: do whatever you want, but include Assimp's license text with your product - and don't sue us if our code doesn't work. Note that, unlike LGPLed code, you may link statically to Assimp. For the legal details, see the file."
    },
    {
        "link": "https://github.com/assimp/assimp/discussions/5633",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://assimp-docs.readthedocs.io/en/latest/about/quickstart.html",
        "document": "When the importer successfully completed its job, the imported data is returned in an aiScene structure. This is the root point from where you can access all the various data types that a scene/model file can possibly contain. The:ref: describes how to interpret this data.\n\nThere are many 3d file formats in the world, and we’re happy to support as many as possible. If you need support for a particular file format, why not implement it yourself and add it to the library? Writing importer plugins for Assimp is considerably easy, as the whole postprocessing infrastructure is available and does much of the work for you. See the:ref: extend Extending the library page for more information.\n\nIf you have any questions/comments/suggestions/bug reports you’re welcome to post them in our Github-Issue-Tracker. Alternatively, there’s was a mailing list, assimp-discussions . This one is deprecated. Try to use Assimp on Stackoverflow or Assimp on Reddit instead. .\n\nUsing the pre-built libraries with Visual-Studio If you develop at Visual Studio 2015, 2017, 2019, or 2022 you can simply use the pre-built linker libraries provided in the distribution. Extract all files to a place of your choice. A directory called Assimp will be created there. Add the assimp/include path to your include paths (Menu->Extras->Options->Projects and Solutions->VC++ Directories->Include files) and the assimp/lib/<Compiler> path to your linker paths (Menu->Extras->Options->Projects and Solutions->VC++ Directories->Library files). This is necessary only once to set up all paths inside your IDE. To use the library in your C++ project you can simply generate a project file via cmake. One way is to add the Assimp folder as a subdirectory via the cmake-command: Now just add the Assimp dependency to your application: If done correctly you should now be able to compile, link, run, and use the application.\n\nBuild on all platforms using vcpkg You can download and install Assimp using the vcpkg dependency manager: The Assimp port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please <reate an issue or pull request on the vcpkg repository .\n\nFirst, you need to install cmake. Now just get the code from GitHub or download the latest version from the website. to build the library just open a command-prompt / bash, navigate into the repo folder, and run cmake via: A project file of your default make-system (like gnu-make on Linux or Visual-Studio on Windows) will be generated. Run the build and you are done. You can find the libs at assimp/lib and the dll’s / so’s at bin.\n\nThis module provides a facade for the io-stream-access to files behind the android-asset-management within an Android-native application. - It is built as a static library - It requires Android NDK with Android API > 9 support. To use this module please provide the following cmake defines: SOME_PATH is the path containing your cmake android-toolchain script. The build script for this port is based on Android-CMake. See its documentation for more Android-specific cmake options (e.g. -DANDROID_ABI for the target ABI). A small example of how to wrap Assimp for Android: The Assimp-package can be built as DLL. You just need to run the default cmake run."
    },
    {
        "link": "https://learnopengl.com/Model-Loading/Assimp",
        "document": "In all the scenes so far we've been extensively playing with our little container friend, but over time, even our best friends can get a little boring. In bigger graphics applications, there are usually lots of complicated and interesting models that are much prettier to look at than a static container. However, unlike the container object, we can't really manually define all the vertices, normals, and texture coordinates of complicated shapes like houses, vehicles, or human-like characters. What we want instead, is to import these models into the application; models that were carefully designed by 3D artists in tools like Blender, 3DS Max or Maya.\n\nThese so called allow artists to create complicated shapes and apply textures to them via a process called . The tools then automatically generate all the vertex coordinates, vertex normals, and texture coordinates while exporting them to a model file format we can use. This way, artists have an extensive toolkit to create high quality models without having to care too much about the technical details. All the technical aspects are hidden in the exported model file. We, as graphics programmers, do have to care about these technical details though.\n\nIt is our job to parse these exported model files and extract all the relevant information so we can store them in a format that OpenGL understands. A common issue is that there are dozens of different file formats where each exports the model data in its own unique way. Model formats like the Wavefront .obj only contains model data with minor material information like model colors and diffuse/specular maps, while model formats like the XML-based Collada file format are extremely extensive and contain models, lights, many types of materials, animation data, cameras, complete scene information, and much more. The wavefront object format is generally considered to be an easy-to-parse model format. It is recommended to visit the Wavefront's wiki page at least once to see how such a file format's data is structured. This should give you a basic perception of how model file formats are generally structured.\n\nAll by all, there are many different file formats where a common general structure between them usually does not exist. So if we want to import a model from these file formats, we'd have to write an importer ourselves for each of the file formats we want to import. Luckily for us, there just happens to be a library for this.\n\nA very popular model importing library out there is called Assimp that stands for Open Asset Import Library. Assimp is able to import dozens of different model file formats (and export to some as well) by loading all the model's data into Assimp's generalized data structures. As soon as Assimp has loaded the model, we can retrieve all the data we need from Assimp's data structures. Because the data structure of Assimp stays the same, regardless of the type of file format we imported, it abstracts us from all the different file formats out there.\n\nWhen importing a model via Assimp it loads the entire model into a scene object that contains all the data of the imported model/scene. Assimp then has a collection of nodes where each node contains indices to data stored in the scene object where each node can have any number of children. A (simplistic) model of Assimp's structure is shown below:\n• All the data of the scene/model is contained in the object like all the materials and the meshes. It also contains a reference to the root node of the scene.\n• The of the scene may contain children nodes (like all other nodes) and could have a set of indices that point to mesh data in the scene object's array. The scene's array contains the actual objects, the values in the array of a node are only indices for the scene's meshes array.\n• A object itself contains all the relevant data required for rendering, think of vertex positions, normal vectors, texture coordinates, faces, and the material of the object.\n• A mesh contains several faces. A represents a render primitive of the object (triangles, squares, points). A face contains the indices of the vertices that form a primitive. Because the vertices and the indices are separated, this makes it easy for us to render via an index buffer (see Hello Triangle).\n• Finally a mesh also links to a object that hosts several functions to retrieve the material properties of an object. Think of colors and/or texture maps (like diffuse and specular maps).\n\nWhat we want to do is: first load an object into a object, recursively retrieve the corresponding objects from each of the nodes (we recursively search each node's children), and process each object to retrieve the vertex data, indices, and its material properties. The result is then a collection of mesh data that we want to contain in a single object.\n\nIn the next chapters we'll create our own and class that load and store imported models using the structure we've just described. If we then want to draw a model, we do not render the model as a whole, but we render all of the individual meshes that the model is composed of. However, before we can start importing models, we first need to actually include Assimp in our project.\n\nYou can download Assimp from their GitHub page and choose the corresponding version. For this writing, the Assimp version used was version . It is advised to compile the libraries by yourself, since their pre-compiled libraries don't always work on all systems. Review the Creating a window chapter if you forgot how to compile a library by yourself via CMake.\n\nA few issues can come up while building Assimp, so I'll note them down here with their solutions in case any of you get the same errors:\n• CMake continually gives errors while retrieving the configuration list about DirectX libraries missing, messages like: Could not locate DirectX CMake Error at cmake-modules/FindPkgMacros.cmake:110 (message): Required library DirectX not found! Install the library (including dev packages) and try again. If the library is already installed, set the missing variables manually in cmake. The solution here is to install the DirectX SDK in case you haven't installed this before. You can download the SDK from here.\n• While installing the DirectX SDK, a possible error code of could pop up. In that case you first want to de-install the C++ Redistributable package(s) before installing the SDK.\n\nOnce the configuration is completed, you can generate a solution file, open it, and compile the libraries (either as a release version or a debug version, whatever floats your boat). Be sure to compile it for 64-bit as all LearnOpenGL code is 64 bit.\n\nThe default configuration builds Assimp as a dynamic library so we need to include the resulting DLL named (or with some post-fix) alongside the application's binaries. You can simply copy the DLL to the same folder where your application's executable is located.\n\nAfter compiling the generated solution, the resulting library and DLL file are located in the or folder. Then simply move the lib and DLL to their appropriate locations, link them from your solution, and be sure to copy Assimp's headers to your directory (the header files are found in the folder in the files downloaded from Assimp).\n\nBy now you should have compiled Assimp and linked it to your application. If you still received any unreported error, feel free to ask for help in the comments."
    },
    {
        "link": "https://stackoverflow.com/questions/45928202/assimp-model-loading-library-install-linking-troubles",
        "document": "I'm trying to install Assimp to use in my projects, but I'm having some trouble. I'm currently using win 10 pro and visual studio 15 2017.\n• None I have downloaded Assimp 4.0.1.zip, extracted it into a directory, loaded cmakeGui and ran configuration twice, then generated into Assimp/build directory.\n• None Next I went into Assimp/build and I ran the Assimp.sln and chose the ALL_BUILD I think it was. I then copied all the files in the /code/debug that were alongside the .lib and .dll and moved them all into the Debug directory of my project where my exe is built to. I copied the .lib into my opengl/libs directory and all the headers in /include from the originally extracted download into my opengl/includes/assimp directory.\n• None Finally, I adjusted my projects linker settings to include the assimp.lib and assimp.dll (alias for simplicity of this post)\n\nWhen I tried to build the project it said it could not open the dll and when experimenting I copied the dll into the project dir alongside main.cpp and my other files and ran again, it this time said \"invalid or corrupt file: cannot read at 0x378\"\n\nIt's safe to say I need to study up on compiling, linking and cmake but for now I started over.\n\nI thought I had it working(and maybe I do...) after I got it to stop complaining when I was including the headers into my project. To do so I started from fresh, built Assimp same as before, moved all the files with the dll into my libs directory, dumped all the includes from the download into my includes, also move the config.h from the build into this directory. Then I set the linker settings in the project and didn't move anything into my project directories.\n\nAfter that, it stopped complaining so I proceeded with the tutorial series I was following. I compiled, got a load of errors, fixed them down to 0 then suddenly I got 8 new ones in their place.\n\nThis error gave me the feeling it was probably due to the dll. Please advise."
    }
]