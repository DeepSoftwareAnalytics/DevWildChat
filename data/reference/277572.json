[
    {
        "link": "https://python-course.eu/numerical-programming/weighted-probabilities.php",
        "document": "In the previous chapter of our tutorial, we introduced the random module. We got to know the functions 'choice' and 'sample'. We used 'choice' to choose a random element from a non-empty sequence and 'sample' to chooses k unique random elements from a population sequence or set. The probality for all elements is evenly distributed, i.e. each element has of the sequences or sets have the same probability to be chosen.\n\nThis is exactly what we want, if we simulate the rolling of dice. But what about loaded dice? Loaded dice are designed to favor some results over others for whatever reasons.\n\nIn our previous chapter we had a look at the following examples:\n\nLike we said before, the chances for the elements of the sequence to be chosen are evenly distributed. So the chances for getting a 'scientist' as a return value of the call choice(professions) is 1/4. This is out of touch with reality. There are surely more scientists and engineers in the world than there are priests and philosophers. Just like with the loaded die, we have again the need of a weighted choice.\n\nWe will devise a function \"weighted_choice\", which returns a random element from a sequence like random.choice, but the elements of the sequence will be weighted.\n\nWe will define now the weighted choice function. Let's assume that we have three weights, e.g. 1/5, 1/2, 3/10. We can build the cumulative sum of the weights with np.cumsum(weights).\n\nIf we create a random number x between 0 and 1 by using random.random(), the probability for x to lie within the interval [0, cum_weights[0]) is equal to 1/5. The probability for x to lie within the interval [cum_weights[0], cum_weights[1]) is equal to 1/2 and finally, the probability for x to lie within the interval [cum_weights[1], cum_weights[2]) is 3/10.\n\nNow you are able to understand the basic idea of how weighted_choice operates:\n\nWe can use the function weighted_choice for the following task:\n\nSuppose, we have a \"loaded\" die with P(6)=3/12 and P(1)=1/12. The probability for the outcomes of all the other possibilities is equally likely, i.e. P(2) = P(3) = P(4) = P(5) = p.\n\nWe can calculate p with\n\nHow can we simulate this die with our weighted_choice function?\n\nWe call weighted_choice with 'faces_of_die' and the 'weights' list. Each call correspondents to a throw of the loaded die.\n\nWe can show that if we throw the die a large number of times, for example 10,000 times, we get roughly the probability values of the weights:\n\nWe can also use list of strings with our 'weighted_choice' function.\n\nWe define a list of cities and a list with their corresponding populations. The probability of a city to be chosen should be according to their size:\n\nTo produce a weighted choice of an array like object, we can also use the choice function of the numpy.random package. Actually, you should use functions from well-established module like 'NumPy' instead of reinventing the wheel by writing your own code. In addition the 'choice' function from NumPy can do even more. It generates a random sample from a given 1-D array or array like object like a list, tuple and so on. The function can be called with four parameters:\n\nWe will base our first exercise on the popularity of programming language as stated by the \"Tiobe index\"1:\n\nLet us use the function choice to create a sample from our professions. To get two professions chosen, we set the parameter to the shape . In this case multiple occurances are possible. The top ten programming languages in August 2019 were:\n\nIn the previous chapter on random numbers and probability, we introduced the function 'sample' of the module 'random' to randomly extract a population or sample from a group of objects liks lists or tuples. Every object had the same likelikhood to be drawn, i.e. to be part of the sample.\n\nIn real life situation there will be of course situation in which every or some objects will have different probabilities. We will start again by defining a function on our own. This function will use the previously defined 'weighted_choice' function.\n\nExample using the sample function:\n\nLet's assume we have eight candies, coloured \"red\", \"green\", \"blue\", \"yellow\", \"black\", \"white\", \"pink\", and \"orange\". Our friend Peter will have the \"weighted\" preference 1/24, 1/6, 1/6, 1/12, 1/12, 1/24, 1/8, 7/24 for thes colours. He is allowed to take 3 candies:\n\nLet's approximate the likelihood for an orange candy to be included in the sample:\n\nIt was completely unnecessary to write this function, because we can use the choice function of NumPy for this purpose as well. All we have to do is assign the shape '(2, )' to the optional parameter 'size'. Let us redo the previous example by substituting weighted_sampe with a call of np.random.choice:\n\nIn addition, the function 'np.random.choice' gives us the possibility to allow repetitions, as we can see in the following example:\n\nThe function cartesian_choice is named after the Cartesian product from set theory\n\nThe Cartesian product is an operation which returns a set from multiple sets. The result set from the Cartesian product is called a \"product set\" or simply the \"product\".\n\nFor two sets A and B, the Cartesian product A × B is the set of all ordered pairs (a, b) where a ∈ A and b ∈ B:\n\nIf we have n sets A , A , ... A , we can build the Cartesian product correspondingly:\n\nThe Cartesian product of n sets is sometimes called an n-fold Cartesian product.\n\nWe will write now a function cartesian_choice, which takes an arbitrary number of iterables as arguments and returns a list, which consists of random choices from each iterator in the respective order.\n\nMathematically, we can see the result of the function cartesian_choice as an element of the Cartesian product of the iterables which have been passed as arguments.\n\nWe define now a weighted version of the previously defined function:\n\nWe check in the following version, if the \"probabilities\" are all right:\n\nA random seed, - also called \"seed state\", or just \"seed\" - is a number used to initialize a pseudorandom number generator. When we called random.random() we expected and got a random number between 0 and 1. random.random() calculates a new random number by using the previously produced random number. What about the first time we use random in our program? Yes, there is no previously created random number. If a random number generator is called for the first time, it will have to create a first \"random\" number.\n\nIf we seed a pseudo-random number generator, we provide a first \"previous\" value. A seed value corresponds to a sequence of generated values for a given random number generator. If you use the same seed value again, you get and you can rely on getting the same sequence of numbers again.\n\nThe seed number itself doesn't need to be randomly chosen so that the algorithm creates values which follow a probability distribution in a pseudorandom manner. Yet, the seed matters in terms of security. If you know the seed, you could for example generate the secret encryption key which is based on this seed.\n\nRandom seeds are in many programming languages generated from the state of the computer system, which is in lots of cases the system time.\n\nThis is true for Python as well. Help on random.seed says that if you call the function with None or no argument it will seed \"from current time or from an operating system specific randomness source if available.\"\n\nThe seed functions allows you to get a determined sequence of random numbers. You can repeat this sequence, whenever you need it again, e.g. for debugging purposes.\n\nRandom Numbers in Python with Gaussian and Normalvariate Distribution\n\nWe want to create now 1000 random numbers between 130 and 230 that have a gaussian distribution with the mean value mu set to 550 and the standard deviation sigma is set to 30.\n\nThe following program plots the random values, which we have created before. We haven't covered matplotlib so far, so it's not necessary to understand the code:\n\nWe do the same now with normvariate instead of gauss:\n\nExercise With Zeros and Ones\n\nIt might be a good idea to write the following function as an exercise yourself. The function should be called with a parameter p, which is a probabilty value between 0 and 1. The function returns a 1 with a probability of p, i.e. ones in p percent and zeros in (1 - p) percent of the calls:\n\nIt might be a great idea to implement a task like this with a generator. If you are not familar with the way of working of a Python generator, we recommend to consult our chapter on generators and iterators of our Python tutorial.\n\nOur generator random_ones_and_zeros can be seen as a sender, which emits ones and zeros with a probability of p and (1-p) respectively.\n\nWe will write now another generator, which is receiving this bitstream. The task of this new generator is to read the incoming bitstream and yield another bitstream with ones and zeros with a probability of 0.5 without knowing or using the probability p. It should work for an arbitrary probability value p.2\n\nWe check now an arbitrary pair of consecutive Bits B , B , ...\n\nSuch a pair can have the values 01, 10, 00 or 11. The probability P(01) = (p-1) x p and probability P(10) = p x (p-1), so that the combined probabilty that the two consecutive bits are either 01 or 10 (or the sum of the two bits is 1) is 2 x (p-1) x p\n\nNow we look at another bit B . What is the probability that both\n\nThe possible outcomes satisfying these conditions and their corresponding probabilities can be found in the following table:\n\nWe will denote the outcome sum(B , B )=1 asX and correspondingly the outcome sum(B , B )=1 as X\n\nSo, the joint probability P(X , X ) = p2 x (1-p) + p x (1 - p)2 which can be rearranged to p x (1-p)\n\nThe conditional probability of X given X :\n\nIn this subchapter we want to create a data file with sales figures. Imagine that we have a chain of shops in various European and Canadian cities: Frankfurt, Munich, Berlin, Zurich, Hamburg, London, Toronto, Strasbourg, Luxembourg, Amsterdam, Rotterdam, The Hague\n\nWe start with an array 'sales' of sales figures for the year 1997:\n\nThe aim is to create a comma separated list like the ones you get from Excel. The file should contain the sales figures, we don't know, for all the shops, we don't have, spanning the year from 1997 to 2016.\n\nWe will add random values to our sales figures year after year. For this purpose we construct an array with growthrates. The growthrates can vary between a minimal percent value (min_percent) and maximum percent value (max_percent):\n\nTo get the new sales figures after a year, we multiply the sales array \"sales\" with the array \"growthrates\":\n\nTo get a more sustainable sales development, we change the growthrates only every four years.\n\nThis is our complete program, which saves the data in a file called sales_figures.csv:\n\nThe result is in the file sales_figures.csv.\n\nWe will use this file in our chapter on reading and writing in Numpy.\n• At first we will write the function \"process_datafile\" to process our data file: # get rid of descriptive first line Let's start our function and check the results: \"Total number of students onrolled in the UK: \" Open University in England: 123490 University of Manchester: 37925 University of Nottingham: 33270 Sheffield Hallam University: 33100 University of Birmingham: 32335 Manchester Metropolitan University: 32160 University of Leeds: 30975 Cardiff University: 30180 University of South Wales: 29195 University College London: 28430 King's College London: 27645 University of Edinburgh: 27625 Northumbria University: 27565 University of Glasgow: 27390 Total number of students onrolled in the UK: 2299380 We want to enroll now a virtual student randomly to one of the universities. To get a weighted list suitable for our weighted_choice function, we have to normalize the values in the list enrollments: We have been asked by the exercise to \"enroll\" 100,000 fictional students. This can be easily accomplished with a loop: [('Open University in England', 5456), ('University of Manchester', 1663), ('University of Birmingham', 1433), ('University of Nottingham', 1432), ('Sheffield Hallam University', 1421), ('Manchester Metropolitan University', 1381), ('University of South Wales', 1365), ('Cardiff University', 1311), ('University College London', 1291), ('University of Leeds', 1290), (\"King's College London\", 1251), ('Northumbria University', 1205), ('University of Sheffield', 1204), ('University of Edinburgh', 1195), ('Nottingham Trent University', 1184), ('University of Glasgow', 1182), ('University of Oxford', 1181), ('University of Central Lancashire', 1162), ('University of Plymouth', 1161), ('University of Warwick', 1147)]\n• The bunch of amazons is implemented as a list, while we choose a set for Pysseusses favorites. The weights at the beginning are 1/11 for all, i.e. 1/len(amazons). Every loop cycle corresponds to a new day. Every time we start a new loop cycle, we will draw \"n\" samples of Pythonistas to calculate the ratio of the number of times the sample is equal to the king's favorites divided by the number of times the sample doesn't match the king's idea of daughter-in-laws. This corresponds to the probability \"prob\". We stop the first time, the probability is equal or larger than 0.9. \"Number of days, he has to wait: \" 2.2348596939700656 Number of days, he has to wait: 32 Teh value for the number of days differs, if n is not large enough. The following is a solutions without round-off errors. We will use Fraction from the module fractions. \"Number of days, he has to wait: \" 52.22739774401998 Number of days, he has to wait: 32 We can see that the solution with fractions is beautiful but very slow. Whereas the greater precision doesn't play a role in our case. So far, we haven't used the power of Numpy. We will do this in the next implementation of our problem: \"Number of days, he has to wait: \" 2.709868110017851 Number of days, he has to wait: 32 1 The TIOBE index or The TIOBE Programming Community index is - according to the website \"an indicator of the popularity of programming languages. The index is updated once a month. The ratings are based on the number of skilled engineers world-wide, courses and third party vendors. Popular search engines such as Google, Bing, Yahoo!, Wikipedia, Amazon, YouTube and Baidu are used to calculate the ratings. It is important to note that the TIOBE index is not about the best programming language or the language in which most lines of code have been written.\" 2 I am thankful to Dr. Hanno Baehr who introduced me to the problem of \"Random extraction\" when participating in a Python training course in Nuremberg in January 2014. Hanno outlined some bits of the theoretical framework. During a night session in a pub called \"Zeit & Raum\" (english: \"Time & Space\") I implemented a corresponding Python program to back the theoretical solution empirically. Enjoying this page? We offer live Python training courses covering the content of this site. 07 Apr to 11 Apr 2025\n\n 23 Jun to 27 Jun 2025\n\n 28 Jul to 01 Aug 2025\n\n 08 Sep to 12 Sep 2025\n\n 09 Apr to 11 Apr 2025\n\n 04 Jun to 06 Jun 2025\n\n 30 Jul to 01 Aug 2025\n\n 10 Sep to 12 Sep 2025\n\n 07 Apr to 08 Apr 2025\n\n 02 Jun to 03 Jun 2025\n\n 23 Jun to 24 Jun 2025\n\n 28 Jul to 29 Jul 2025\n\n 08 Sep to 09 Sep 2025\n\n 09 Apr to 11 Apr 2025\n\n 04 Jun to 06 Jun 2025\n\n 10 Sep to 12 Sep 2025\n\n See our Machine Learning with Python training courses"
    },
    {
        "link": "https://stackoverflow.com/questions/58480183/how-to-calculate-weighted-permutation-probabilities-in-python",
        "document": "I have a string of numbers 0-12 with weights associated with them. The weights array is as follows: .\n\nI have simulated all combinations of numbers 0-12 in Python but I want to write some additional code to simulate the probabilities of picking a specific combination, without replacement. For example, the probability of choosing (1,2,5,3) should be\n\nI have no idea how to code this because of the \"without replacement\" part, I'm thinking of using a for loop that looks at the specific number in the position in the permutation and determine the probability of picking that number at that position but am hoping there is a way to look each individual permutation."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-get-weighted-random-choice-in-python",
        "document": "Weighted random choices mean selecting random elements from a list or an array by the probability of that element. We can assign a probability to each element and according to that element(s) will be selected. By this, we can select one or more than one element from the list, And it can be achieved in two ways.\n\nThe choices() method returns multiple random elements from the list with replacement. You can weigh the possibility of each result with the weights parameter or the cum_weights parameter.\n\nParameters :\n\n1. sequence is a mandatory parameter that can be a list, tuple, or string.\n\n2. weights is an optional parameter which is used to weigh the possibility for each value.\n\n3. cum_weights is an optional parameter which is used to weigh the possibility for each value but in this the possibility is accumulated\n\n4. k is an optional parameter that is used to define the length of the returned list.\n\nYou can also use cum_weight parameter. It stands for cumulative weight. By default, the function calculates cumulative weights from standard weights. So to expedite the program, use cum_weight. Cumulative weight is calculated by the formula:\n\nIf you are using Python older than 3.6 version, then you have to use the NumPy library to achieve weighted random numbers. With the help of the choice() method, we can get the random samples of a one-dimensional array and return the random samples of numpy array.\n\nList: It is the original list from you have select random numbers. k: It is the size of the returning list. i.e., the number of elements you want to select. p: A list containing the probability of each element.\n\nNote: the total sum of the probability of all the elements should be equal to 1. (i.e. sum(p)=1)"
    },
    {
        "link": "https://stackoverflow.com/questions/3679694/a-weighted-version-of-random-choice",
        "document": "This function seems overly complex to me, and ugly. I'm hoping everyone here can offer some suggestions on improving it or alternate ways of doing this. Efficiency isn't as important to me as code cleanliness and readability.\n\nI needed to write a weighted version of random.choice (each element in the list has a different probability for being selected). This is what I came up with:\n\nAs of Python , could be used to return a of elements of specified size from the given population with optional weights.\n• None k : size( ) of the to be outputted. (Default ) 1) It makes use of weighted sampling with replacement so the drawn items would be later replaced. The values in the weights sequence in itself do not matter, but their relative ratio does. Unlike which can only take on probabilities as weights and also which must ensure summation of individual probabilities upto 1 criteria, there are no such regulations here. As long as they belong to numeric types ( except type) , these would still perform. >>> import random # weights being integers >>> random.choices([\"white\", \"green\", \"red\"], [12, 12, 4], k=10) ['green', 'red', 'green', 'white', 'white', 'white', 'green', 'white', 'red', 'white'] # weights being floats >>> random.choices([\"white\", \"green\", \"red\"], [.12, .12, .04], k=10) ['white', 'white', 'green', 'green', 'red', 'red', 'white', 'green', 'white', 'green'] # weights being fractions >>> random.choices([\"white\", \"green\", \"red\"], [12/100, 12/100, 4/100], k=10) ['green', 'green', 'white', 'red', 'green', 'red', 'white', 'green', 'green', 'green'] 2) If neither weights nor cum_weights are specified, selections are made with equal probability. If a weights sequence is supplied, it must be the same length as the population sequence. Specifying both weights and cum_weights raises a . 3) cum_weights are typically a result of function which are really handy in such situations. Internally, the relative weights are converted to cumulative weights before making selections, so supplying the cumulative weights saves work. So, either supplying or for our contrived case produces the same outcome and the latter seems to be more faster / efficient.\n\nAnother way of doing this, assuming we have weights at the same index as the elements in the element array. import numpy as np weights = [0.1, 0.3, 0.5] #weights for the item at index 0,1,2 # sum of weights should be <=1, you can also divide each weight by sum of all weights to standardise it to <=1 constraint. trials = 1 #number of trials num_item = 1 #number of items that can be picked in each trial selected_item_arr = np.random.multinomial(num_item, weights, trials) # gives number of times an item was selected at a particular index # this assumes selection with replacement # one possible output # selected_item_arr # array([[0, 0, 1]]) # say if trials = 5, the the possible output could be # selected_item_arr # array([[1, 0, 0], # [0, 0, 1], # [0, 0, 1], # [0, 1, 0], # [0, 0, 1]]) Now let's assume, we have to sample out 3 items in 1 trial. You can assume that there are three balls R,G,B present in large quantity in ratio of their weights given by weight array, the following could be possible outcome: you can also think number of items to be selected as number of binomial/ multinomial trials within a set. So, the above example can be still work as num_binomial_trial = 5 weights = [0.1,0.9] #say an unfair coin weights for H/T num_experiment_set = 1 selected_item_arr = np.random.multinomial(num_binomial_trial, weights, num_experiment_set) # possible output # selected_item_arr # array([[1, 4]]) # i.e H came 1 time and T came 4 times in 5 binomial trials. And one set contains 5 binomial trails.\n\nIn Machine learning I need to not only randomly select an item from an array, but also make sure that the item is selected a stable number of times in a full round. The idea is to duplicate each index N times according to its chance of occurrence. The minimum chance is 0.001, so if there is an item with a chance of 0.001, an index with a chance of 1.0 will be duplicated 1000 times. So I made a Choicer class. It also supports nested Choicer. from __future__ import annotations from typing import Any, Sequence import numpy as np class Choicer: def __init__(self, items : Sequence[ Any|Choicer ], probs : Sequence[int|float]|np.ndarray ): \"\"\" probs [ 0.001 .. 1.0 ] \"\"\" self._items = items self._probs = probs = np.array(probs, np.float32).clip(0.001, 1.0) if len(probs) != len(items): raise ValueError('must len(probs) == len(items)') # how often each item will occur rates = (probs/probs.min()).astype(np.int32) # base idx sequence, for example Choicer(['a', 'b', 'c'], [1,1,0.5]) , idxs_base == [0,0,1,1,2] self._idxs_base = np.concatenate([np.full( (x,), i, dtype=np.uint32) for i,x in enumerate(rates)], 0) self._idxs = None self._idx_counter = 0 @property def items(self) -> Sequence[ Any|Choicer ]: return self._items @property def probs(self) -> np.ndarray: return self._probs def pick(self, count : int) -> Sequence[Any]: \"\"\"pick `count` items\"\"\" out = [] if len(self._items) != 0: while len(out) < count: if self._idx_counter == 0: self._idxs = self._idxs_base.copy() np.random.shuffle(self._idxs) self._idx_counter = len(self._idxs) self._idx_counter -= 1 idx = self._idxs[self._idx_counter] item = self._items[idx] if isinstance(item, Choicer): item = item.pick(1)[0] out.append(item) return out c = Choicer(['a', 'b', 'c'], [1,1,0.5]) print( c.pick(5) ) # ['c', 'a', 'b', 'a', 'b'] print( c.pick(5) ) # ['a', 'a', 'b', 'b', 'c'] print( c.pick(5) ) # ['a', 'c', 'a', 'b', 'b']"
    },
    {
        "link": "https://reddit.com/r/pythontips/comments/1df9u68/most_efficient_way_to_have_a_weighted_random",
        "document": "I spent two whole weeks creating a program that simulates up to four billions random choices based on probability.\n\nEvery single one is generated using the random.choices([elements], [probabilities]). Testing in smaller scale (10 millions) it takes 4 minutes. So I estimate it would take more than 5 hours to execute a single time.\n\nI've spent a long time optimizing other areas of the code, but I think the most time demanding process is the random part. I tried looking at the numpy, but it would take 3 hours of simulation.\n\nIs there any other way to have a probability choice? Should I just give up on python?"
    },
    {
        "link": "https://stackoverflow.com/questions/61552057/python-parsing-through-multiple-lines-of-data-from-stdin-to-store-in-standard",
        "document": "I have gone through the suggested similar questions, however appear to run into dead-ends; likely because perhaps I am not adequately explaining my problem. I am attempting to take some STDIN I have access to, which looks like so:\n\nWhat I am having trouble with is taking the integers after the first line and storing them all into a standard Python array.\n\nThe very first input on the first line will always be some integer 0 or 1, representing the disabling/enabling of some \"special feature\", any other integers are then input which must be stored to a standard array. As you can see, some integers have lines all to themselves while other lines may have several integers (blank lines should be completely ignored). I have been attempting to solve this using sys.stdin, since I know after stripping things it already makes the input into list objects, however to little avail. My code so far is as follows:\n\nThe 'quit' is my attempt at a backdoor I can type by hand since I also don't know how to check for EOF. I know this is very bare-bones (hardly much of anything), but what I effectively wish to produce as my output is this:\n\nThe lines marked with \">\" are not printed, I'm simply demonstrating how the input is conceptually supposed to be read. Of course, any and all help is appreciated, I look forward to your thoughts!"
    },
    {
        "link": "https://stackoverflow.com/questions/31816239/python3-using-input-how-to-read-multiple-lines-from-pipe-stdin",
        "document": "im just curious while learning python3 and didn't found any good explanation on the web, neither here to my question.\n\nreading about input() it says \"reads from stdin\" so i thought i might experiment and try to use it to read from pipe. and so it does! but only ONE LINE (till EOL). So the next question that came up was\n\nhow to read multiple lines from pipe (stdin) using input() ?\n\ni found sys.stdin and used sys.stdin.isatty() to determine if stdin is bound to a tty or not, assuming that if not bound to tty the data is coming from pipe. and so i also found and used successfully sys.stdin.readlines() too to read multiple lines.\n\nbut just for my curiosity , is there a way to achieve the same by using the plain input() function ?? so far i didn't found something \"to test\" if stdin contains more lines without blocking my program.\n\nsorry if all this makes no sense to you.\n\nthis is my experimenting code so far without input():"
    },
    {
        "link": "https://discuss.python.org/t/input-values-multpile-lines/45475",
        "document": "Hello everyone. how to input this text in python\n\nDo you mean you want the user to input multiple lines into a program using input()?\n\n If this is the case you need to write a loop calling input() multiple times: lines = [] while True: try: line = input() except EOFError: break lines.append(line) print(lines) Note that here, you need to hit “ctrl+D” (or ctrl+Z on Windows) to signal that the input is “finished”. You may as well use another solution, like passing a special word “END” to end the input:\n\nIf you are using an interactive input, this is not possible, because you need to tell your program that you are finished inputting things, so it can process your lines.\n\n What you can do is put your text into a file, then process that file.\n\nThanks. But I want without “END” or enter or any commands, l input multiline strings and python convert this string to list. For example:\n\n I like C\n\n very\n\n much\n\n [“I”, “like”, “C”, “very”, “much”] This is a contradiction, because, to get: [\"I\", \"like\", \"C\", \"very\", \"much\"] … your multi line strings would be: I like C very much … in which case, all you need is\n\nI think we or you are finding your “finish” constraint confusing. You\n\n want to end input text. For that text to be finite, Python needs to know\n\n when it ends. How do you to indicate when it ends?\n\nPython treats some things as ‘falsy’ (pretend it’s false) and everything else as ‘truthy’ (pretend it’s true). Zero is falsy, as are empty collections (empty list, empty tuple, empty dict, etc) and empty (i.e. zero-length) strings.\n\nTechnically speaking, is broader than == as the former applies to non-sizable falsy objects such as False. But if you that you have a collection object that is False when empty, then I agree with PEP 8 and Brian."
    },
    {
        "link": "https://reddit.com/r/learnpython/comments/1fr7dlg/how_do_i_process_a_multiple_line_input_from_for",
        "document": "I recently took a coding assessment where I was tasked to compute the square of the input which is relatively easy. The issue was that the input was a multiple line input:\n\n7\n\n16\n\nThe given code was\n\nI tried to do ls = list(line.split()) but ls[0] is\n\n['7']\n\n['16']\n\nand ls[1] is None\n\nI also tried ls = list(line.split('\n\n')) but ls is\n\n['7', '']\n\n['16', '']\n\nSo how was I supposed to process the input to get ['7', '16'] rather than a 2 dimensional list?\n\nFrom there I know how continue with make it an integer using map, creating a for loop for each item of the list and printing the square of each item.\n\nI dont have a picture of the question since I was monitored on webcam but this is roughly what I remembered from the question.\n\nedit: It was an online assessment platform so I am not sure exactly how the input was written as (like the raw input). Also I can only modify the code inside for line in sys.stdin:\n\nAlso, does anyone know how to write the input for sys.stdin using jupyternotebook such that I can practice this problem?"
    },
    {
        "link": "https://geeksforgeeks.org/take-input-from-stdin-in-python",
        "document": "In this article, we will read How to take input from stdin in Python.\n\nThere are a number of ways in which we can take input from stdin in Python.\n\nRead Input From stdin in Python using sys.stdin\n\nFirst we need to import sys module. sys.stdin can be used to get input from the command line directly. It used is for standard input. It internally calls the input() method. Furthermore, it, also, automatically adds ‘\n\n’ after each sentence.\n\nExample: Taking input using sys.stdin in a for-loop\n\nRead Input From stdin in Python using input()\n\nThe input() can be used to take input from the user while executing the program and also in the middle of the execution.\n\nRead Input From stdin in Python using fileinput.input()\n\nIf we want to read more than one file at a time, we use fileinput.input(). There are two ways to use fileinput.input(). To use this method, first, we need to import fileinput.\n\nExample 1: Reading multiple files by providing file names in fileinput.input() function argument\n\nHere, we pass the name of the files as a tuple in the “files” argument. Then we loop over each file to read it. “sample.txt” and “no.txt” are two files present in the same directory as the Python file.\n\nExample 2: Reading multiple files by passing file names from command line using fileinput module\n\nHere, we pass the file name as a positional argument in the command line. fileargument parses the argument and reads the file and displays the content of the file."
    }
]