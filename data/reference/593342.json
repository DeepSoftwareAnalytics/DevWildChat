[
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/Manual/writing-shader-writing-shader-programs-hlsl.html",
        "document": "Resources for writing HLSL shaderA program that runs on the GPU. More info\n\nSee in Glossary programs inside a block in a custom ShaderLabUnity’s language for defining the structure of Shader objects. More info\n\nSee in Glossary shader."
    },
    {
        "link": "https://docs.unity3d.com/Manual/SL-landing.html",
        "document": "Use a block to add one or more sections that define different GPU settings and shader programs for different hardware, render pipelines \n\n A series of operations that take the contents of a Scene, and displays them on a screen. Unity lets you choose from pre-built render pipelines, or write your own. More info , and runtime settings.\n\nInsert a named Pass from another Shader object \n\n An instance of the Shader class, a Shader object is container for shader programs and GPU instructions, and information that tells Unity how to use them. Use them with materials to determine the appearance of your scene. More info , to avoid reduce code duplication in shader source files."
    },
    {
        "link": "https://medium.com/@deaconline/the-basics-of-stencil-shaders-a888b2bd9bd4",
        "document": "Stencil Shaders are wild. \n\nThey can create bizarre “non-euclidean” magical effects like so:\n\nI sat for ages trying to learn stencil shaders. Now, I kinda get it. \n\n(And if I’m honest, the hardest part was finding out what they're called.)\n\nThis tutorial is what clicked for me, and I have too much love for Toocanzs\n\nhttps://www.youtube.com/watch?v=SySnHIhiVgM\n\nBasically, the effect is simply two shaders interacting with one another.\n\nShow me what you got\n\nHere’s my quick little demonstration.\n\nThe background image can only be viewed through the portal. \n\n(Technically, that’s not quite what’s happening, but we’ll get there.)\n\nLet me show you how it works. (TL;DR — Here’s a prefab.)\n\nThere are three main components:\n• A portal (blue) is just a mesh with the default standard unity material. This is here to contextualize and justify the visual effect. This could be a doorway, or a window, or whatever. (3D Asset: Igrium, Sketchfab)\n• The world beyond the portal (purple). \n\nI’m just using a flat quad with a sprite here, but it could be any mesh, really. (In fact, in my own scene, I’m applying this to a video player.)\n• The “window” or “lens” (red) through which we see the other side of the portal. This is kind of how the stencil shader trick works. In this example, I’m just using a flattened cylinder, but again, this could be any mesh.\n\nTo achieve the desired effect, we need to use two custom shaders. \n\nOne for the background and another for the window.\n\nLet’s start with the background. \n\nWe start with creating a standard surface shader.\n\nAdd the this tag to the sub shader.\n\nBy setting the queue to , we ensure that this object is drawn slightly later than other objects in the base transparent queue ( , which starts at 2501) but before objects with higher queue numbers (e.g., or ).\n\nIn HLSL (High-Level Shading Language), tags such as and are used to control rendering behavior, especially in Unity shader development. Let’s break down what the tag does in the context of your shader.\n\nBetween “LOD 200\" & “CGPROGRAM”, we add this cheeky little snippet.\n\nOkay, so what does this do?\n\nIn HLSL (High-Level Shading Language) for DirectX, the Stencil block is used to control stencil testing during rendering.\n\nThis line sets the reference value for the stencil test to 5. When the stencil test occurs, the current value in the stencil buffer will be compared against this reference value.\n\nThis line sets the stencil comparison function to Equal. The Comp keyword is short for “comparison.” In this case, it means that the stencil test will pass only if the value in the stencil buffer is equal to the reference value (which is 5, as set in the previous line). If the stencil value is not equal to 5, the pixel will not be drawn.\n\nIn essence, these lines set up a stencil test that compares the value in the stencil buffer to the reference value 5. Only pixels that have a stencil buffer value of 5 will pass the stencil test, and all others will be discarded or not rendered.\n\nThe full shader looks like this:\n\nWe create a new material in Unity and then apply the shader.\n\nHang on… I don't see it… Yup, you got it! \n\nNow it’s time for what I like to call the “window”.\n\nThis one is a bit more complicated.\n\nOkay, what's going on here?\n• Stencil Operation: This shader writes a reference value of 5 to the stencil buffer for any pixel it renders.\n• Rendering: Despite being marked as “Opaque,” the shader renders in the Transparent+4 queue, meaning it will be rendered after most transparent objects.\n• Depth Writing: Depth writing is disabled ( ), so this object doesn’t interfere with other depth-buffer operations, making it suitable for complex blending or post-processing effects.\n\nIt’s no secret that I love the Poiyomi shaders and I’m a proud patron. The main difference here, is that Poiyomi is a complex modular shader with many different options. We just pick and choose what we’ll use, instead of having multiple different shaders for each effect. I just figured out how to replicate this portal effect with poi_Pro_9.1.14. so I thought I’d share.\n\nThe “window” (remember, this is the lens through which we view the effect) needs to look like this:\n• First, we slap this at 3000 (transparent) on the render queue — we don't want it visible or opaque.\n• Then, we pop everything onto Stencil Reference Value = 5 \n\n(…Or any number. I chose 5 so that it’ll work alongside the custom shaders I made earlier in this tutorial)\n• Then, we Replace this shader if something else hits the Ref Value (of 5).\n• Finally, We don’t need a Stencil Compare function here, or to worry about failing the check for this example.\n\nAnd the background needs to look like this:\n• Again, pop everything onto Stencil Reference Value = 5 \n\n(as long as it’s the same as the above material)\n• Then, Replace everything on the Stencil Pass if it overlaps with something else on the same Ref Value.\n• If it fails the check (is not viewed through the window) then keep the shader as is (transparent + 10).\n• Finally, this shader needs to be rendered in the transparent range (3000+) and higher on the render queue (+10) than the window so that it appears on top of the window (in the space between your eyeball and the mesh with the window shader).\n\nI don’t wanna make this tutorial too long and tedious. We all learn better by getting our hands dirty and making mistakes, anyway. I’m just here to nudge you into making your own mistakes.\n\nEnjoy, and let me know if you use this to make something cool!\n\nIn case you missed it, here’s a hands-on prefab you can play with."
    },
    {
        "link": "https://discussions.unity.com/t/documentation-about-how-shader-graph-generated-code-works-and-shaders-in-general-in-hdrp/778497",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/Unity3D/comments/1ei98cg/shader_graph_is_more_tolerable_with_custom_hlsl",
        "document": "A subreddit for News, Help, Resources, and Conversation regarding Unity, the game engine. Do NOT use your phone to take screenshots. Video and photos of computer screens taken by phones are NOT allowed. All screenshots must be grabbed from the computer itself."
    },
    {
        "link": "https://discussions.unity.com/t/stencil-buffer-and-transparent-objects/763200",
        "document": ""
    },
    {
        "link": "https://docs.unity3d.com/Manual/SL-Stencil.html",
        "document": "Configures settings relating to the stencil bufferA memory store that holds an 8-bit per-pixel value. In Unity, you can use a stencil buffer to flag pixels, and then only render to pixels that pass the stencil operation. More info\n\nSee in Glossary on the GPU.\n\nIn C#, these values are represented by the Rendering.CompareFunction enum.\n\nIn C#, these values are represented by the Rendering.Rendering.StencilOp enum.\n• Check or write to the stencil buffer in a shader"
    },
    {
        "link": "https://discussions.unity.com/t/stencil-effect-shader/719005",
        "document": ""
    },
    {
        "link": "https://medium.com/@deaconline/the-basics-of-stencil-shaders-a888b2bd9bd4",
        "document": "Stencil Shaders are wild. \n\nThey can create bizarre “non-euclidean” magical effects like so:\n\nI sat for ages trying to learn stencil shaders. Now, I kinda get it. \n\n(And if I’m honest, the hardest part was finding out what they're called.)\n\nThis tutorial is what clicked for me, and I have too much love for Toocanzs\n\nhttps://www.youtube.com/watch?v=SySnHIhiVgM\n\nBasically, the effect is simply two shaders interacting with one another.\n\nShow me what you got\n\nHere’s my quick little demonstration.\n\nThe background image can only be viewed through the portal. \n\n(Technically, that’s not quite what’s happening, but we’ll get there.)\n\nLet me show you how it works. (TL;DR — Here’s a prefab.)\n\nThere are three main components:\n• A portal (blue) is just a mesh with the default standard unity material. This is here to contextualize and justify the visual effect. This could be a doorway, or a window, or whatever. (3D Asset: Igrium, Sketchfab)\n• The world beyond the portal (purple). \n\nI’m just using a flat quad with a sprite here, but it could be any mesh, really. (In fact, in my own scene, I’m applying this to a video player.)\n• The “window” or “lens” (red) through which we see the other side of the portal. This is kind of how the stencil shader trick works. In this example, I’m just using a flattened cylinder, but again, this could be any mesh.\n\nTo achieve the desired effect, we need to use two custom shaders. \n\nOne for the background and another for the window.\n\nLet’s start with the background. \n\nWe start with creating a standard surface shader.\n\nAdd the this tag to the sub shader.\n\nBy setting the queue to , we ensure that this object is drawn slightly later than other objects in the base transparent queue ( , which starts at 2501) but before objects with higher queue numbers (e.g., or ).\n\nIn HLSL (High-Level Shading Language), tags such as and are used to control rendering behavior, especially in Unity shader development. Let’s break down what the tag does in the context of your shader.\n\nBetween “LOD 200\" & “CGPROGRAM”, we add this cheeky little snippet.\n\nOkay, so what does this do?\n\nIn HLSL (High-Level Shading Language) for DirectX, the Stencil block is used to control stencil testing during rendering.\n\nThis line sets the reference value for the stencil test to 5. When the stencil test occurs, the current value in the stencil buffer will be compared against this reference value.\n\nThis line sets the stencil comparison function to Equal. The Comp keyword is short for “comparison.” In this case, it means that the stencil test will pass only if the value in the stencil buffer is equal to the reference value (which is 5, as set in the previous line). If the stencil value is not equal to 5, the pixel will not be drawn.\n\nIn essence, these lines set up a stencil test that compares the value in the stencil buffer to the reference value 5. Only pixels that have a stencil buffer value of 5 will pass the stencil test, and all others will be discarded or not rendered.\n\nThe full shader looks like this:\n\nWe create a new material in Unity and then apply the shader.\n\nHang on… I don't see it… Yup, you got it! \n\nNow it’s time for what I like to call the “window”.\n\nThis one is a bit more complicated.\n\nOkay, what's going on here?\n• Stencil Operation: This shader writes a reference value of 5 to the stencil buffer for any pixel it renders.\n• Rendering: Despite being marked as “Opaque,” the shader renders in the Transparent+4 queue, meaning it will be rendered after most transparent objects.\n• Depth Writing: Depth writing is disabled ( ), so this object doesn’t interfere with other depth-buffer operations, making it suitable for complex blending or post-processing effects.\n\nIt’s no secret that I love the Poiyomi shaders and I’m a proud patron. The main difference here, is that Poiyomi is a complex modular shader with many different options. We just pick and choose what we’ll use, instead of having multiple different shaders for each effect. I just figured out how to replicate this portal effect with poi_Pro_9.1.14. so I thought I’d share.\n\nThe “window” (remember, this is the lens through which we view the effect) needs to look like this:\n• First, we slap this at 3000 (transparent) on the render queue — we don't want it visible or opaque.\n• Then, we pop everything onto Stencil Reference Value = 5 \n\n(…Or any number. I chose 5 so that it’ll work alongside the custom shaders I made earlier in this tutorial)\n• Then, we Replace this shader if something else hits the Ref Value (of 5).\n• Finally, We don’t need a Stencil Compare function here, or to worry about failing the check for this example.\n\nAnd the background needs to look like this:\n• Again, pop everything onto Stencil Reference Value = 5 \n\n(as long as it’s the same as the above material)\n• Then, Replace everything on the Stencil Pass if it overlaps with something else on the same Ref Value.\n• If it fails the check (is not viewed through the window) then keep the shader as is (transparent + 10).\n• Finally, this shader needs to be rendered in the transparent range (3000+) and higher on the render queue (+10) than the window so that it appears on top of the window (in the space between your eyeball and the mesh with the window shader).\n\nI don’t wanna make this tutorial too long and tedious. We all learn better by getting our hands dirty and making mistakes, anyway. I’m just here to nudge you into making your own mistakes.\n\nEnjoy, and let me know if you use this to make something cool!\n\nIn case you missed it, here’s a hands-on prefab you can play with."
    },
    {
        "link": "https://docs.unity3d.com/550/Documentation/Manual/SL-Stencil.html",
        "document": "The stencil buffer can be used as a general purpose per pixel mask for saving or discarding pixels.\n\nThe stencil buffer is usually an 8 bit integer per pixel. The value can be written to, increment or decremented. Subsequent draw calls can test against the value, to decide if a pixel should be discarded before running the pixel shader.\n\nThe value to be compared against (if Comp is anything else than always) and/or the value to be written to the buffer (if either Pass, Fail or ZFail is set to replace). 0–255 integer.\n\nAn 8 bit mask as an 0–255 integer, used when comparing the reference value with the contents of the buffer (referenceValue & readMask) comparisonFunction (stencilBufferValue & readMask). Default: 255.\n\nAn 8 bit mask as an 0–255 integer, used when writing to the buffer. Note that, like other write masks, it specifies which bits of stencil buffer will be affected by write (i.e. WriteMask 0 means that no bits are affected and not that 0 will be written). Default: 255.\n\nThe function used to compare the reference value to the current contents of the buffer. Default: always.\n\nWhat to do with the contents of the buffer if the stencil test (and the depth test) passes. Default: keep.\n\nWhat to do with the contents of the buffer if the stencil test fails. Default: keep.\n\nWhat to do with the contents of the buffer if the stencil test passes, but the depth test fails. Default: keep.\n\nComp, Pass, Fail and ZFail will be applied to the front-facing geometry, unless Cull Front is specified, in which case it’s back-facing geometry. You can also explicitly specify the two-sided stencil state by defining CompFront, PassFront, FailFront, ZFailFront (for front-facing geometry), and CompBack, PassBack, FailBack, ZFailBack (for back-facing geometry).\n\nComparison function is one of the following:\n\nStencil operation is one of the following:\n\nStencil functionality for objects rendered in the deferred rendering path is somewhat limited, as during the base pass and lighting pass the stencil buffer is used for other purposes. During those two stages stencil state defined in the shader will be ignored and only taken into account during the final pass. Because of that it’s not possible to mask out these objects based on a stencil test, but they can still modify the buffer contents, to be used by objects rendered later in the frame. Objects rendered in the forward rendering path following the deferred path (e.g. transparent objects or objects without a surface shader) will set their stencil state normally again.\n\nThe deferred rendering path uses the three highest bits of the stencil buffer, plus up to four more highest bits - depending on how many light mask layers are used in the scene. It is possible to operate within the range of the “clean” bits using the stencil read and write masks, or you can force the camera to clean the stencil buffer after the lighting pass using Camera.clearStencilAfterLightingPass.\n\nThe first example shader will write the value ‘2’ wherever the depth test passes. The stencil test is set to always pass.\n\nThe second shader will pass only for the pixels which the first (red) shader passed, because it is checking for equality with the value ‘2’. It will also decrement the value in the buffer wherever it fails the Z test.\n\nThe third shader will only pass wherever the stencil value is ‘1’, so only pixels at the intersection of both red and green spheres - that is, where the stencil is set to ‘2’ by the red shader and decremented to ‘1’ by the green shader.\n\nAnother example of a more directed effect. The sphere is first rendered with this shader to mark-up the proper regions in the stencil buffer:\n\nAnd then rendered once more as a fairly standard surface shader, with the exception of front face culling, disabled depth test and stencil test discarding previously marked pixels:"
    }
]