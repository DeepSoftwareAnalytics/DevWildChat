[
    {
        "link": "https://docs.godotengine.org/en/stable/classes/class_node2d.html",
        "document": "A 2D game object, inherited by all 2D-related nodes. Has a position, rotation, scale, and skew.\n\nA 2D game object, with a transform (position, rotation, and scale). All 2D nodes, including physics objects and sprites, inherit from Node2D. Use Node2D as a parent node to move, scale and rotate children in a 2D project. Also gives control of the node's render order. Note: Since both Node2D and Control inherit from CanvasItem, they share several concepts from the class such as the CanvasItem.z_index and CanvasItem.visible properties.\n\nGlobal rotation in radians. See also rotation. Helper property to access global_rotation in degrees instead of radians. See also rotation_degrees. Global skew in radians. See also skew. Position, relative to the node's parent. See also global_position. Rotation in radians, relative to the node's parent. See also global_rotation. Note: This property is edited in the inspector in degrees. If you want to use degrees in a script, use rotation_degrees. Helper property to access rotation in degrees instead of radians. See also global_rotation_degrees. The node's scale, relative to the node's parent. Unscaled value: . See also global_scale. Note: Negative X scales in 2D are not decomposable from the transformation matrix. Due to the way scale is represented with transformation matrices in Godot, negative scales on the X axis will be changed to negative scales on the Y axis and a rotation of 180 degrees when decomposed. If set to a non-zero value, slants the node in one direction or another. This can be used for pseudo-3D effects. See also global_skew. Note: Skew is performed on the X axis only, and between rotation and scaling. Note: This property is edited in the inspector in degrees. If you want to use degrees in a script, use . The node's Transform2D, relative to the node's parent. See also global_transform.\n\nMultiplies the current scale by the vector. Returns the angle between the node and the in radians. Returns the Transform2D relative to this node's parent. Adds the vector to the node's global position. Rotates the node so that its local +X axis points towards the , which is expected to use global coordinates. should not be the same as the node's position, otherwise the node always looks to the right. Applies a local translation on the node's X axis based on the Node._process()'s . If is , normalizes the movement. Applies a local translation on the node's Y axis based on the Node._process()'s . If is , normalizes the movement. Applies a rotation to the node, in radians, starting from its current rotation. Transforms the provided local position into a position in global coordinate space. The input is expected to be local relative to the Node2D it is called on. e.g. Applying this method to the positions of child nodes will correctly transform their positions into the global coordinate space, but applying it to a node's own position will give an incorrect result, as it will incorporate the node's own transformation into its global position. Transforms the provided global position into a position in local coordinate space. The output will be local relative to the Node2D it is called on. e.g. It is appropriate for determining the positions of child nodes, but it is not appropriate for determining its own position relative to its parent. Translates the node by the given in local coordinates."
    },
    {
        "link": "https://docs.godotengine.org",
        "document": "Godot's documentation is available in various languages and versions. Expand the \"Read the Docs\" panel at the bottom of the sidebar to see the list.\n\nWelcome to the official documentation of Godot Engine, the free and open source community-driven 2D and 3D game engine! If you are new to this documentation, we recommend that you read the introduction page to get an overview of what this documentation has to offer.\n\nThe table of contents in the sidebar should let you easily access the documentation for your topic of interest. You can also use the search function in the top-left corner.\n\nGodot Engine is an open source project developed by a community of volunteers. The documentation team can always use your feedback and help to improve the tutorials and class reference. If you don't understand something, or cannot find what you are looking for in the docs, help us make the documentation better by letting us know! Submit an issue or pull request on the GitHub repository, help us translate the documentation into your language, or talk to us on the channel on the Godot Contributors Chat!\n\nTo browse the documentation offline, you can download an HTML copy (updated every Monday): stable, latest, 3.6. Extract the ZIP archive then open the top-level in a web browser. For mobile devices or e-readers, you can also download an ePub copy (updated every Monday): stable, latest, 3.6. Extract the ZIP archive then open the file in an e-book reader application."
    },
    {
        "link": "https://docs.godotengine.org/en/stable/getting_started/first_2d_game/index.html",
        "document": "In this step-by-step tutorial series, you will create your first complete 2D game with Godot. By the end of the series, you will have a simple yet complete game of your own, like the image below.\n\nYou will learn how the Godot editor works, how to structure a project, and build a 2D game.\n\nThe game is called \"Dodge the Creeps!\". Your character must move and avoid the enemies for as long as possible.\n\nYou will learn to:\n• None Move the player character and change its sprite.\n\nYou'll find another series where you'll create a similar game but in 3D. We recommend you to start with this one, though.\n\nIf you are new to game development or unfamiliar with Godot, we recommend starting with 2D games. This will allow you to become comfortable with both before tackling 3D games, which tend to be more complicated.\n\nYou can find a completed version of this project at this location:\n\nThis step-by-step tutorial is intended for beginners who followed the complete Step by step. If you're an experienced programmer, you can find the complete demo's source code here: Dodge the Creeps source code. We prepared some game assets you'll need to download so we can jump straight to the code. You can download them by clicking the link below."
    },
    {
        "link": "https://reddit.com/r/godot/comments/186l3ef/how_to_get_bounds_of_collisionshape2d_in_godot_4",
        "document": "I want to the the x and y of the bounds of my CollisionShape2D. In Unity I could just get this information with something along the lines of\n\nto get this information. I found an older post that says to use\n\nbut when I look it up in the docs for 4.1 it doesn't appear and I don't see what it's replacement was.\n\nCollisionShape2D.get_shape().size.x will just return the x value."
    },
    {
        "link": "https://docs.godotengine.org/en/stable/classes/class_collisionshape2d.html",
        "document": "A node that provides a Shape2D to a CollisionObject2D parent.\n\nA node that provides a Shape2D to a CollisionObject2D parent and allows to edit it. This can give a detection shape to an Area2D or turn a PhysicsBody2D into a solid object.\n\nThe collision shape color that is displayed in the editor, or in the running project if Debug > Visible Collision Shapes is checked at the top of the editor.\n\nNote: The default value is ProjectSettings.debug/shapes/collision/shape_color. The value documented here is a placeholder, and not the actual default debug color.\n\nA disabled collision shape has no effect in the world. This property should be changed with Object.set_deferred().\n\nSets whether this collision shape should only detect collision on one side (top or bottom).\n\nNote: This property has no effect if this CollisionShape2D is a child of an Area2D node.\n\nThe margin used for one-way collision (in pixels). Higher values will make the shape thicker, and work better for colliders that enter the shape at a high velocity.\n\nThe actual shape owned by this collision shape."
    },
    {
        "link": "https://docs.godotengine.org/en/stable/tutorials/2d/2d_movement.html",
        "document": "Every beginner has been there: \"How do I move my character?\" Depending on the style of game you're making, you may have special requirements, but in general the movement in most 2D games is based on a small number of designs. We'll use CharacterBody2D for these examples, but the principles will apply to other node types (Area2D, RigidBody2D) as well.\n\nEach example below uses the same scene setup. Start with a with two children: and . You can use the Godot icon (\"icon.png\") for the Sprite2D's texture or use any other 2D image you have. Open and select the \"Input Map\" tab. Add the following input actions (see InputEvent for details):\n\nIn this scenario, you want the user to press the four directional keys (up/left/down/right or W/A/S/D) and move in the selected direction. The name \"8-way movement\" comes from the fact that the player can move diagonally by pressing two keys at the same time. Add a script to the character body and add the following code: In the function, we use Input to check for the four key events and sum return a direction vector. We can then set our velocity by multiplying this direction vector, which has a length of , by our desired speed. If you've never used vector math before, or need a refresher, you can see an explanation of vector usage in Godot at Vector math. If the code above does nothing when you press the keys, double-check that you've set up input actions correctly as described in the Setup part of this tutorial.\n\nThis type of movement is sometimes called \"Asteroids-style\" because it resembles how that classic arcade game worked. Pressing left/right rotates the character, while up/down moves it forward or backward in whatever direction it's facing. Here we've added two variables to track our rotation direction and speed. The rotation is applied directly to the body's property. To set the velocity, we use the body's which is a vector pointing in the body's \"forward\" direction, and multiply that by the speed.\n\nThis style of movement is a variation of the previous one. This time, the direction is set by the mouse position instead of the keyboard. The character will always \"look at\" the mouse pointer. The forward/back inputs remain the same, however. Here we're using the Node2D method to point the player towards the mouse's position. Without this function, you could get the same effect by setting the angle like this:\n\nThis last example uses only the mouse to control the character. Clicking on the screen will cause the player to move to the target location. # Use is_action_pressed to only accept single taps as input instead of mouse drags. // Use IsActionPressed to only accept single taps as input instead of mouse drags. Note the check we make prior to movement. Without this test, the body would \"jitter\" upon reaching the target position, as it moves slightly past the position and tries to move back, only to move too far and repeat. Uncommenting the line will also turn the body to point in its direction of motion if you prefer. This technique can also be used as the basis of a \"following\" character. The position can be that of any object you want to move to.\n\nYou may find these code samples useful as starting points for your own projects. Feel free to use them and experiment with them to see what you can make. You can download this sample project here: 2d_movement_starter.zip"
    },
    {
        "link": "https://reddit.com/r/godot/comments/15nhkka/how_to_handle_movement",
        "document": "I've been following a tutorial after having done the Godot Creeps tutorial, and I noticed that movement is handled a little differently. I was wondering what the upshot is and if one is better/worse/whatever than the other.\n\nThe second doesn't normalize, but the diagonal speed doesn't seem faster. Is that right or just bad perception on my part? Similarly, it doesn't use at all. It seems like that is because locks frames to 60fps? Aside from those two things, the second way seems way cleaner"
    },
    {
        "link": "https://reddit.com/r/godot/comments/aw7qoj/hierarchy_and_control_best_practices_question",
        "document": "I'm kinda new to game development, let me ask a question in terms of handling input and character movement.\n\nOk - so let's say I have a basic hierarchy - a Level node and underneath that node I have a tilemap and a player character. Where is the best practice for handling input controls (like movement/shoot/jump)? Like should the level node handle all input and send instructions to other scenes to \"do something\"? Like the level node receives input for ui_right, it calls a method on the player scene to tell it to move right? Or is it better to let the player scene handle any input related to the player scene even if it's embedded into another scene?\n\nIn several videos I've seen it setup where the player scene actually is handling input and doing the various movement actions, but I wasn't sure if this was really a best practices or just an easy practices which is why everyone does it?"
    },
    {
        "link": "https://docs.godotengine.org/en/stable/tutorials/best_practices/index.html",
        "document": "© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)."
    },
    {
        "link": "https://medium.com/@christinec-dev/learn-godot-4-by-making-a-2d-platformer-part-2-player-setup-movement-input-bf036476369b",
        "document": "We now have our project set up, so now we can go ahead and start creating the blocks that will eventually turn our skeleton project into a complete game. In this part, we will create a new Scene that will contain the nodes to make up our Player. Our Player is the actual character that we will be controlling when we play the game — and its scene will contain all the nodes and scripts that will allow us to see this character and control them so that we can run around and interact with the world.\n\nIn our Main scene, we can go ahead and delete that Sprite2D node that we added in the previous part — since we only added that node to demonstrate our texture filtering change. We will create a whole new scene for our Player, and then we will instantiate (or instance) it in our Main scene. Instancing allows us to replicate an object from a template so that we can modify them separately. In other words, we will have our Player separate from our Main scene, so we can treat it as a separate object. This way our Player is its own entity — one which is not dependent on our level (or Main) scene.\n\nGo ahead and delete the Sprite2D node from your Main scene so that we are left with this:\n\nThen, let’s create a new scene. Let’s create a new scene. You can do so by clicking on the plus icon next to Main(*), which will create a new empty scene.\n\nIn the Scene Dock, add a new root node. We need this root node to be a CharacterBody2D node, which is a specialized 2D physics body node for characters that can be moved via scripts. We need this node to provide our player character with physics so that it can move around.\n\nDouble-click your newly added CharacterBody2D node to rename it to “Player”, then save the scene underneath your Scenes folder.\n\nYou will see a yellow triangle pop up next to your Player root node. If you hover over it, it will tell you that the node has no shape. The shape that it is referring to is a collision shape, which is the shape that will surround our character so that it can collide and interact with other items in the level.\n\nLet’s clear this warning by adding a CollisionShape2D node to our Player scene.\n\nThis will return another warning because even though we’ve added a collision node, we still have not assigned it a collision shape. We need to set the shape property to configure the shape. We can do this by clicking on our CollisionShape2D node and assigning it a shape in its Shape property in the Inspector panel. Let’s add a new RectangleShape2D shape.\n\nI’m choosing a RectangleShape2D shape because that is the shape of my character — we can also always change this shape later on to meet our needs. The type of shape that you choose for your object will depend on what you want them to accomplish (from where they need to collide), as well as their body shape. So, a circular character might have a CircleShape2D, and so on. Press F to focus on your node. You will see that your shape has been added.\n\nNext, we need to add a sprite to our Player scene so that we can visually see our node. If you want to have an item that does not move around or that has no animations, you can add a Sprite2D node to serve as this sprite. In our case, we want our Player to move around and do this with Animations. Therefore we will add an AnimatedSprite2D node instead. AnimatedSprite2D is similar to the Sprite2D node, except it carries multiple textures as animation frames.\n\nMake sure that you add this node with your root (Player) node selected and not your CollisionShape2D node selected. We want the AnimatedSprite2D node to be a child of the root node and not the collision shape!\n\nThis node will also return a warning since it requires a SpriteFrames resource. This resource allows you to import image files (or a folder containing said files) to provide the animation frames for the sprite. We can add a new SpriteFrames resource in the Inspector panel via the Sprite Frames property. Click on the <empty> option next to your Sprite Frames property and select “New SpriteFrames”.\n\nIf you click on this newly added resource, it will open up the Animations panel in our editor below. It is here where we can configure our SpriteFrames resource. The configurations include the ability to add new animations, delete animations, play animations, or edit animations. The default animation can be deleted or renamed. We will add all of our player’s animations in the next part so that we can explore this node in more detail. For now, let’s just assign a sprite to our default animation by clicking the “Add Frames from Sprite Sheet” option.\n\nA window will pop up so that we can select the Sprite Sheet. This spritesheet will contain the animation frames that will make up a complete animation. We want to add a basic idle animation, so head into “res://Assets/Kings and Pigs/Sprites/01-King Human/” and select the “Idle (78x58).png” sheet.\n\nFrom here, we need to crop out our animations. We need to change our Horizontal and Vertical values to the number of animations frames we can count. Horizontally (column-wise), we count 11 kings, and vertically (row-wise), we count 1 king.\n\nLet’s select each frame (select them in order) for our idle animation.\n\nLater on, you might notice that there is an odd gap when our player changes sides (turns left or right) because our Sprite has such a large gap next to it — i.e., the Sprite Frame is not centered. Since this is not a game that we will publish and the assets we acquired were free, we will not care too much about this, but if you are making a game that you want to publish make sure that the spritesheet that you make or obtain have sprites that are centered when you crop them out. If this is a dealbreaker for you, then I recommend you go on an adventure to find other assets on Itch.io!"
    }
]