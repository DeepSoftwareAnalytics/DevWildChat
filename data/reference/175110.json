[
    {
        "link": "https://vuejs.org/guide/essentials/component-basics",
        "document": "Components allow us to split the UI into independent and reusable pieces, and think about each piece in isolation. It's common for an app to be organized into a tree of nested components:\n\nThis is very similar to how we nest native HTML elements, but Vue implements its own component model that allows us to encapsulate custom content and logic in each component. Vue also plays nicely with native Web Components. If you are curious about the relationship between Vue Components and native Web Components, read more here.\n\nWhen using a build step, we typically define each Vue component in a dedicated file using the extension - known as a Single-File Component (SFC for short):\n\nWhen not using a build step, a Vue component can be defined as a plain JavaScript object containing Vue-specific options:\n\nThe template is inlined as a JavaScript string here, which Vue will compile on the fly. You can also use an ID selector pointing to an element (usually native elements) - Vue will use its content as the template source.\n\nThe example above defines a single component and exports it as the default export of a file, but you can use named exports to export multiple components from the same file.\n\nTo use a child component, we need to import it in the parent component. Assuming we placed our counter component inside a file called , the component will be exposed as the file's default export:\n\nIt's also possible to globally register a component, making it available to all components in a given app without having to import it. The pros and cons of global vs. local registration is discussed in the dedicated Component Registration section.\n\nComponents can be reused as many times as you want:\n\nNotice that when clicking on the buttons, each one maintains its own, separate . That's because each time you use a component, a new instance of it is created.\n\nIn SFCs, it's recommended to use tag names for child components to differentiate from native HTML elements. Although native HTML tag names are case-insensitive, Vue SFC is a compiled format so we are able to use case-sensitive tag names in it. We are also able to use to close a tag.\n\nIf you are authoring your templates directly in a DOM (e.g. as the content of a native element), the template will be subject to the browser's native HTML parsing behavior. In such cases, you will need to use and explicit closing tags for components:\n\nSee in-DOM template parsing caveats for more details.\n\nIf we are building a blog, we will likely need a component representing a blog post. We want all the blog posts to share the same visual layout, but with different content. Such a component won't be useful unless you can pass data to it, such as the title and content of the specific post we want to display. That's where props come in.\n\nProps are custom attributes you can register on a component. To pass a title to our blog post component, we must declare it in the list of props this component accepts, using the option macro:\n\nA component can have as many props as you like and, by default, any value can be passed to any prop.\n\nOnce a prop is registered, you can pass data to it as a custom attribute, like this:\n\nIn a typical app, however, you'll likely have an array of posts in your parent component:\n\nThen want to render a component for each one, using :\n\nNotice how syntax ( ) is used to pass dynamic prop values. This is especially useful when you don't know the exact content you're going to render ahead of time.\n\nThat's all you need to know about props for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Props.\n\nAs we develop our component, some features may require communicating back up to the parent. For example, we may decide to include an accessibility feature to enlarge the text of blog posts, while leaving the rest of the page at its default size.\n\nIn the parent, we can support this feature by adding a data propertyref:\n\nWhich can be used in the template to control the font size of all blog posts:\n\nNow let's add a button to the component's template:\n\nThe button doesn't do anything yet - we want clicking the button to communicate to the parent that it should enlarge the text of all posts. To solve this problem, components provide a custom events system. The parent can choose to listen to any event on the child component instance with or , just as we would with a native DOM event:\n\nThen the child component can emit an event on itself by calling the built-in method, passing the name of the event:\n\nThanks to the listener, the parent will receive the event and update the value of .\n\nWe can optionally declare emitted events using the option macro:\n\nThis documents all the events that a component emits and optionally validates them. It also allows Vue to avoid implicitly applying them as native listeners to the child component's root element.\n\nThat's all you need to know about custom component events for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Custom Events.\n\nJust like with HTML elements, it's often useful to be able to pass content to a component, like this:\n\nWhich might render something like:\n\nThis can be achieved using Vue's custom element:\n\nAs you'll see above, we use the as a placeholder where we want the content to go – and that's it. We're done!\n\nThat's all you need to know about slots for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Slots.\n\nSometimes, it's useful to dynamically switch between components, like in a tabbed interface:\n\nThe above is made possible by Vue's element with the special attribute:\n\nIn the example above, the value passed to can contain either:\n• the name string of a registered component, OR\n\nYou can also use the attribute to create regular HTML elements.\n\nWhen switching between multiple components with , a component will be unmounted when it is switched away from. We can force the inactive components to stay \"alive\" with the built-in component.\n\nIf you are writing your Vue templates directly in the DOM, Vue will have to retrieve the template string from the DOM. This leads to some caveats due to browsers' native HTML parsing behavior.\n\nHTML tags and attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That means when you’re using in-DOM templates, PascalCase component names and camelCased prop names or event names all need to use their kebab-cased (hyphen-delimited) equivalents:\n\nWe have been using self-closing tags for components in previous code samples:\n\nThis is because Vue's template parser respects as an indication to end any tag, regardless of its type.\n\nIn in-DOM templates, however, we must always include explicit closing tags:\n\nThis is because the HTML spec only allows a few specific elements to omit closing tags, the most common being and . For all other elements, if you omit the closing tag, the native HTML parser will think you never terminated the opening tag. For example, the following snippet:\n\nwill be parsed as:\n\nSome HTML elements, such as , , and have restrictions on what elements can appear inside them, and some elements such as , , and can only appear inside certain other elements.\n\nThis will lead to issues when using components with elements that have such restrictions. For example:\n\nThe custom component will be hoisted out as invalid content, causing errors in the eventual rendered output. We can use the special attribute as a workaround:\n\nThat's all you need to know about in-DOM template parsing caveats for now - and actually, the end of Vue's Essentials. Congratulations! There's still more to learn, but first, we recommend taking a break to play with Vue yourself - build something fun, or check out some of the Examples if you haven't already.\n\nOnce you feel comfortable with the knowledge you've just digested, move on with the guide to learn more about components in depth."
    },
    {
        "link": "https://vuejs.org/api/sfc-spec",
        "document": "A Vue Single-File Component (SFC), conventionally using the file extension, is a custom file format that uses an HTML-like syntax to describe a Vue component. A Vue SFC is syntactically compatible with HTML.\n\nEach file consists of three types of top-level language blocks: , , and , and optionally additional custom blocks:\n• None Each file can contain at most one top-level block.\n• None Contents will be extracted and passed on to , pre-compiled into JavaScript render functions, and attached to the exported component as its option.\n• None Each file can contain at most one block (excluding ).\n• None The script is executed as an ES Module.\n• None The default export should be a Vue component options object, either as a plain object or as the return value of defineComponent.\n• None Each file can contain at most one block (excluding normal ).\n• None The script is pre-processed and used as the component's function, which means it will be executed for each instance of the component. Top-level bindings in are automatically exposed to the template. For more details, see dedicated documentation on .\n• None A tag can have or attributes (see SFC Style Features for more details) to help encapsulate the styles to the current component. Multiple tags with different encapsulation modes can be mixed in the same component.\n\nAdditional custom blocks can be included in a file for any project-specific needs, for example a block. Some real-world examples of custom blocks include:\n\nHandling of Custom Blocks will depend on tooling - if you want to build your own custom block integrations, see the SFC custom block integrations tooling section for more details.\n\nAn SFC automatically infers the component's name from its filename in the following cases:\n• Recursive self-reference, e.g. a file named can refer to itself as in its template. This has lower priority than explicitly registered/imported components.\n\nBlocks can declare pre-processor languages using the attribute. The most common case is using TypeScript for the block:\n\ncan be applied to any block - for example we can use with Sass and with Pug:\n\nNote that integration with various pre-processors may differ by toolchain. Check out the respective documentation for examples:\n\nIf you prefer splitting up your components into multiple files, you can use the attribute to import an external file for a language block:\n\nBeware that imports follow the same path resolution rules as webpack module requests, which means:\n• Relative paths need to start with\n• You can import resources from npm dependencies:\n\nInside each block you shall use the comment syntax of the language being used (HTML, CSS, JavaScript, Pug, etc.). For top-level comments, use HTML comment syntax:"
    },
    {
        "link": "https://vue-styleguidist.github.io/docs/Documenting.html",
        "document": "Vue styleguidist generates documentation for your components based on the comments in your source code declarations and Readme files.\n\nVue styleguidist will display the contents of your components' JSDoc comment blocks.\n\nNote the use of the @displayName tag to change the displayed name of your component. This top-level comment block must come before the in your script tag.\n\nIf you want to document a custom v-model (opens new window), you have to add tag in comment\n\nYou can use the following tags when documenting components, props and methods.\n\nA common pattern in VueJs components is to have a limited number of valid values for a prop.\n\nFor instance, would only accept , and .\n\nTo document this in styleguidist, use the tag:\n\nProvide an example of how to use a documented item. The text that follows this tag will be displayed as highlighted code.\n• This is a JSDoc tag: @example\n\nThe @deprecated tag marks a symbol in your code as being deprecated:\n• This is a JSDoc tag: @see, @link\n• This is a JSDoc tag: @since\n\nBy default, all props your components have are considered to be public and are published. In some rare cases, you might want to remove a prop from the documentation while keeping it in the code. The tag allows you to do this. See here for more:\n\nFor events documentation, add a comment right above it. If your comment is at the start of the function, the event will not be picked up.\n\nIf the event is explicitly specified, no need to tell styleguidist what it is.\n\nConstants will be recognized too\n\nIf your event name comes from an object, precise the tag\n\nIf your event returns arguments/properties use the tag to describe them\n\nEvents emitted directly in expressions will be detected automatically. To document them further, in the template, add a comment above the line where the is called.\n\nThe comment block containing the documentation needs to contain one line with . The rest of the comment block will behave like the comment blocks described in the script.\n\nto describe an argument and no tag at all to set the description of the event.\n\nTo add a description, add a comment right before.\n\nIn addition to documenting the slots and giving them a description, you can document the bindings. They are documented like props or params using the keyword ,\n\nThe format will then be\n\nTo get a bit deeper, check out the component in the basic example. Read the code (opens new window) and see how it is rendered in the live example (opens new window)\n\nIf your component is rendered using jsx, tsx or is using the render function styleguidist will still try to detect your slots.\n\nHere are two examples that are detected and documented:\n\nIf vue-styleguidist does not detect your slots, you can explicitly tell it with a comment block before the render function:\n\nIf you have multiple slots, place multiple blocks one after another:\n\nIf you import a mixin (opens new window) or extends (opens new window) it will automatically be added to your main component\n\nVue styleguidist will look for any or files in the component's folder and display them. Any code block with a language tag of , , , or will be rendered as a Vue component with an interactive playground.\n\nIf you want to ignore the readme file for one component, use the doclet. Use this when multiple components in the same folder share a file. This will prevent the examples from being rendered multiple times.\n\nYou can also add the custom block (opens new window) inside files, so that vue styleguidist builds the readme. You can review the following example (opens new window)\n\nAdditional example files can be associated with components using doclet syntax.\n\nThe following component will also have an example loaded from the file:\n\nThe doclet can also be used to ignore the connected file. Use it to avoid rendering examples multiple times.\n\nBy default, any methods your components have are considered to be private and are not published. Mark your public methods with JSDoc (opens new window) tag to get them published in the docs:\n\nBy default, all props your components have are considered to be public and are published. In some rare cases, you might want to remove a prop from the documentation while keeping it in the code. To do so, mark the prop with JSDoc (opens new window) tag to remove it from the docs:\n\nIn addition to those tags, you can use to change the name displayed in your style guide. Know that since it's visual name has changed, it's calling name is now The letters of it, without space or punctuation.\n\nFor instance, if the display name is set as\n\nTo reference it in examples, one has to call . See to How to use component name in docs with a different displayName\n\nWhen documenting methods you can also use:\n\nYou can mark your public methods with JSDoc tag to get them published in the docs.\n\nWhen a component is a list or a table it is easier to write it using a composition API.\n\nFor example, a dropdown element would be easier to read this way\n\nHere is how Vue Styleguidist helps document this pattern: Add a doclet to the main component to signify what components documentation to include in the same page. In every example, the extra component will be automatically registered the same way the main component already is.\n\nIn the previous example we have a component that requires a component to render properly. Here is what the component should look like.\n\nVue Styleguidist understands TypeScript & Flow annotations. Write components in a typed language, types are documented automatically. It is compatible with class style components as well, with or without TypeScript.\n\nNotice how parameter does not need type documentation.\n\nvue styleguidist understands JSX component templates too. In this example, it will display the definition of the found slot.\n\nIn vue 3, VueJs introduced the setup syntax (opens new window). This greatly helps readability of components. It also makes a much more performant TypeScript type checking.\n\nFrom version 4.44.0, Vue Styleguidist allows to document the props & events defined with this syntax.\n\nIn JavaScript, add a comment above the property in the object passed to . In this comment, use the same principle as regular syntax Props.\n\nThe same goes for TypeScript components:\n\nEvents are all defined using the function. Document them in comments before your events entries.\n\nCode examples in Markdown use the ES6 syntax. They can access all the components of your style guide using global variables:\n\nYou can also other modules (e.g. mock data that you use in your unit tests) from examples in Markdown:\n\nTo make autocomplete and syntax highlighting practical, one can as well import examples from external files. In the following example will be used as an example."
    },
    {
        "link": "https://stackoverflow.com/questions/48727863/vue-export-default-vs-new-vue",
        "document": "I just installed Vue and have been following some tutorials to create a project using the vue-cli webpack template. When it creates the component, I notice it binds our data inside of the following:\n\nWhereas in other tutorials I see data being bound from:\n\nWhat is the difference, and why does it seem like the syntax between the two is different? I'm having trouble getting the 'new Vue' code to work from inside the tag I'm using from the App.vue generated by the vue-cli."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_first_component",
        "document": "Now it's time to dive deeper into Vue, and create our own custom component — we'll start by creating a component to represent each item in the todo list. Along the way, we'll learn about a few important concepts such as calling components inside other components, passing data to them via props, and saving data state. Note: If you need to check your code against our version, you can find a finished version of the sample Vue app code in our todo-vue repository. For a running live version, see https://mdn.github.io/todo-vue/. Familiarity with the core HTML, CSS, and JavaScript languages, knowledge of the terminal/command line. Vue components are written as a combination of JavaScript objects that manage the app's data and an HTML-based template syntax that maps to the underlying DOM structure. For installation, and to use some of the more advanced features of Vue (like Single File Components or render functions), you'll need a terminal with Node and npm installed. To learn how to create a Vue component, render it inside another component, pass data into it using props, and save its state.\n\nLet's create our first component, which will display a single todo item. We'll use this to build our list of todos.\n• In your directory, create a new file named . Open the file in your code editor.\n• Create the component's template section by adding to the top of the file.\n• Create a section below your template section. Inside the tags, add a default exported object , which is your component object. Your file should now look like this: We can now begin to add actual content to our . Vue templates are currently only allowed a single root element — one element needs to wrap everything inside the template section (this will change when Vue 3 comes out). We'll use a for that root element.\n• Add an empty inside your component template now.\n• Inside that , let's add a checkbox and a corresponding label. Add an to the checkbox, and a attribute mapping the checkbox to the label, as shown below.\n\nThis is all fine, but we haven't added the component to our app yet, so there's no way to test it and see if everything is working. Let's add it now.\n• At the top of your tag, add the following to import your component:\n• Inside your component object, add the property, and inside it add your component to register it. Your contents should now look like this: This is the same way that the component was registered by the Vue CLI earlier. To actually render the component in the app, you need to go up into your element and call it as a element. Note that the component file name and its representation in JavaScript is in PascalCase (e.g. ), and the equivalent custom element is in kebab-case (e.g. ). It's necessary to use this casing style if you're writing Vue templates in the DOM directly\n• Underneath the , create an unordered list ( ) containing a single list item ( ). The section of your file should now look something like this: If you check your rendered app again, you should now see your rendered , consisting of a checkbox and a label.\n\nWith these props defined inside the component object, we can now use these variable values inside our template. Let's start by adding the prop to the component template. In your , replace the contents of the element with . is a special template syntax in Vue, which lets us print the result of JavaScript expressions defined in our class, inside our template, including values and methods. It's important to know that content inside is displayed as text and not HTML. In this case, we're printing the value of the prop. Your component's template section should now look like this: Go back to your browser and you'll see the todo item rendered as before, but without a label (oh no!). Go to your browser's DevTools and you'll see a warning along these lines in the console: [Vue warn]: Missing required prop: \"label\" found in ---> <ToDoItem> at src/components/ToDoItem.vue <App> at src/App.vue <Root> This is because we marked the as a required prop, but we never gave the component that prop — we've defined where inside the template we want it used, but we haven't passed it into the component when calling it. Let's fix that. Inside your file, add a prop to the component, just like a regular HTML attribute: Now you'll see the label in your app, and the warning won't be spat out in the console again. So that's props in a nutshell. Next we'll move on to how Vue persists data state.\n\nIf you change the value of the prop passed into the call in your component, you should see it update. This is great. We have a checkbox, with an updatable label. However, we're currently not doing anything with the \"done\" prop — we can check the checkboxes in the UI, but nowhere in the app are we recording whether a todo item is actually done. To achieve this, we want to bind the component's prop to the attribute on the element, so that it can serve as a record of whether the checkbox is checked or not. However, it's important that props serve as one-way data binding — a component should never alter the value of its own props. There are a lot of reasons for this. In part, components editing props can make debugging a challenge. If a value is passed to multiple children, it could be hard to track where the changes to that value were coming from. In addition, changing props can cause components to re-render. So mutating props in a component would trigger the component to rerender, which may in-turn trigger the mutation again. To work around this, we can manage the state using Vue's property. The property is where you can manage local state in a component, it lives inside the component object alongside the property and has the following structure: You'll note that the property is a function. This is to keep the data values unique for each instance of a component at runtime — the function is invoked separately for each component instance. If you declared data as just an object, all instances of that component would share the same values. This is a side-effect of the way Vue registers components and something you do not want. You use to access a component's props and other properties from inside data, as you may expect. We'll see an example of this shortly. Note: Because of the way that works in arrow functions (binding to the parent's context), you wouldn't be able to access any of the necessary attributes from inside if you used an arrow function. So don't use an arrow function for the property. So let's add a property to our component. This will return an object containing a single property that we'll call , whose value is . Update the component object like so: Vue does a little magic here — it binds all of your props directly to the component instance, so we don't have to call . It also binds other attributes ( , which you've already seen, and others like , , etc.) directly to the instance. This is, in part, to make them available to your template. The down-side to this is that you need to keep the keys unique across these attributes. This is why we called our attribute instead of . So now we need to attach the property to our component. In a similar fashion to how Vue uses expressions to display JavaScript expressions inside templates, Vue has a special syntax to bind JavaScript expressions to HTML elements and components: . The expression looks like this: In other words, you prefix whatever attribute/prop you want to bind to with . In most cases, you can use a shorthand for the property, which is to just prefix the attribute/prop with a colon. So works the same as . So in the case of the checkbox in our component, we can use to map the property to the attribute on the element. Both of the following are equivalent: You're free to use whichever pattern you would like. It's best to keep it consistent though. Because the shorthand syntax is more commonly used, this tutorial will stick to that pattern. So let's do this. Update your element now to include . Test out your component by passing to the call in . Note that you need to use the syntax, because otherwise is passed as a string. The displayed checkbox should be checked. Try changing to and back again, reloading your app in between to see how the state changes.\n\nGreat! We now have a working checkbox where we can set the state programmatically. However, we can currently only add one component to the page because the is hardcoded. This would result in errors with assistive technology since the is needed to correctly map labels to their checkboxes. To fix this, we can programmatically set the in the component data. We can use the method to generate a unique string to keep component s unique. is built into modern browsers and provides a straightforward way to ensure uniqueness without relying on external libraries. Next, add an field to the property as shown below; this uses to return a unique string, which we then prefix with : Next, bind the to both our checkbox's attribute and the label's attribute, updating the existing and attributes as shown:\n\nAnd that will do for this article. At this point we have a nicely-working component that can be passed a label to display, will store its checked state, and will be rendered with a unique each time it is called. You can check if the unique s are working by temporarily adding more calls into , and then checking their rendered output with your browser's DevTools. Now we're ready to add multiple components to our app. In our next article we'll look at adding a set of todo item data to our component, which we'll then loop through and display inside components using the directive."
    },
    {
        "link": "https://vuejs.org/guide/essentials/component-basics",
        "document": "Components allow us to split the UI into independent and reusable pieces, and think about each piece in isolation. It's common for an app to be organized into a tree of nested components:\n\nThis is very similar to how we nest native HTML elements, but Vue implements its own component model that allows us to encapsulate custom content and logic in each component. Vue also plays nicely with native Web Components. If you are curious about the relationship between Vue Components and native Web Components, read more here.\n\nWhen using a build step, we typically define each Vue component in a dedicated file using the extension - known as a Single-File Component (SFC for short):\n\nWhen not using a build step, a Vue component can be defined as a plain JavaScript object containing Vue-specific options:\n\nThe template is inlined as a JavaScript string here, which Vue will compile on the fly. You can also use an ID selector pointing to an element (usually native elements) - Vue will use its content as the template source.\n\nThe example above defines a single component and exports it as the default export of a file, but you can use named exports to export multiple components from the same file.\n\nTo use a child component, we need to import it in the parent component. Assuming we placed our counter component inside a file called , the component will be exposed as the file's default export:\n\nIt's also possible to globally register a component, making it available to all components in a given app without having to import it. The pros and cons of global vs. local registration is discussed in the dedicated Component Registration section.\n\nComponents can be reused as many times as you want:\n\nNotice that when clicking on the buttons, each one maintains its own, separate . That's because each time you use a component, a new instance of it is created.\n\nIn SFCs, it's recommended to use tag names for child components to differentiate from native HTML elements. Although native HTML tag names are case-insensitive, Vue SFC is a compiled format so we are able to use case-sensitive tag names in it. We are also able to use to close a tag.\n\nIf you are authoring your templates directly in a DOM (e.g. as the content of a native element), the template will be subject to the browser's native HTML parsing behavior. In such cases, you will need to use and explicit closing tags for components:\n\nSee in-DOM template parsing caveats for more details.\n\nIf we are building a blog, we will likely need a component representing a blog post. We want all the blog posts to share the same visual layout, but with different content. Such a component won't be useful unless you can pass data to it, such as the title and content of the specific post we want to display. That's where props come in.\n\nProps are custom attributes you can register on a component. To pass a title to our blog post component, we must declare it in the list of props this component accepts, using the option macro:\n\nA component can have as many props as you like and, by default, any value can be passed to any prop.\n\nOnce a prop is registered, you can pass data to it as a custom attribute, like this:\n\nIn a typical app, however, you'll likely have an array of posts in your parent component:\n\nThen want to render a component for each one, using :\n\nNotice how syntax ( ) is used to pass dynamic prop values. This is especially useful when you don't know the exact content you're going to render ahead of time.\n\nThat's all you need to know about props for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Props.\n\nAs we develop our component, some features may require communicating back up to the parent. For example, we may decide to include an accessibility feature to enlarge the text of blog posts, while leaving the rest of the page at its default size.\n\nIn the parent, we can support this feature by adding a data propertyref:\n\nWhich can be used in the template to control the font size of all blog posts:\n\nNow let's add a button to the component's template:\n\nThe button doesn't do anything yet - we want clicking the button to communicate to the parent that it should enlarge the text of all posts. To solve this problem, components provide a custom events system. The parent can choose to listen to any event on the child component instance with or , just as we would with a native DOM event:\n\nThen the child component can emit an event on itself by calling the built-in method, passing the name of the event:\n\nThanks to the listener, the parent will receive the event and update the value of .\n\nWe can optionally declare emitted events using the option macro:\n\nThis documents all the events that a component emits and optionally validates them. It also allows Vue to avoid implicitly applying them as native listeners to the child component's root element.\n\nThat's all you need to know about custom component events for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Custom Events.\n\nJust like with HTML elements, it's often useful to be able to pass content to a component, like this:\n\nWhich might render something like:\n\nThis can be achieved using Vue's custom element:\n\nAs you'll see above, we use the as a placeholder where we want the content to go – and that's it. We're done!\n\nThat's all you need to know about slots for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Slots.\n\nSometimes, it's useful to dynamically switch between components, like in a tabbed interface:\n\nThe above is made possible by Vue's element with the special attribute:\n\nIn the example above, the value passed to can contain either:\n• the name string of a registered component, OR\n\nYou can also use the attribute to create regular HTML elements.\n\nWhen switching between multiple components with , a component will be unmounted when it is switched away from. We can force the inactive components to stay \"alive\" with the built-in component.\n\nIf you are writing your Vue templates directly in the DOM, Vue will have to retrieve the template string from the DOM. This leads to some caveats due to browsers' native HTML parsing behavior.\n\nHTML tags and attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That means when you’re using in-DOM templates, PascalCase component names and camelCased prop names or event names all need to use their kebab-cased (hyphen-delimited) equivalents:\n\nWe have been using self-closing tags for components in previous code samples:\n\nThis is because Vue's template parser respects as an indication to end any tag, regardless of its type.\n\nIn in-DOM templates, however, we must always include explicit closing tags:\n\nThis is because the HTML spec only allows a few specific elements to omit closing tags, the most common being and . For all other elements, if you omit the closing tag, the native HTML parser will think you never terminated the opening tag. For example, the following snippet:\n\nwill be parsed as:\n\nSome HTML elements, such as , , and have restrictions on what elements can appear inside them, and some elements such as , , and can only appear inside certain other elements.\n\nThis will lead to issues when using components with elements that have such restrictions. For example:\n\nThe custom component will be hoisted out as invalid content, causing errors in the eventual rendered output. We can use the special attribute as a workaround:\n\nThat's all you need to know about in-DOM template parsing caveats for now - and actually, the end of Vue's Essentials. Congratulations! There's still more to learn, but first, we recommend taking a break to play with Vue yourself - build something fun, or check out some of the Examples if you haven't already.\n\nOnce you feel comfortable with the knowledge you've just digested, move on with the guide to learn more about components in depth."
    },
    {
        "link": "https://ni4yja.medium.com/parent-child-communication-in-vue-from-child-to-parent-9d9d9d353a09",
        "document": "I chose the Star Wars theme just before the war started, kind of prophetic, don’t you think? Relation between Luke and his father is dramatic and recognizable, and I wanted to use it in my small project about components’ communication in Vue. There are two components — and . The child has a text field for a message, which should be sent to its parent and displayed in it. How to achieve this?\n\nWe need to use , which allows us to send custom events from a child component to its parent. Each Vue call can pass two arguments: the event name and a payload object (optional). Let’s check how it works on the real-world example. In my codesandbox (visit this link to play around with code), the parent component listens for a custom event and confers the received value to its data:\n\nNow we need our child component to listen for the native input event and then emit its event. To pass the value of our original change event, we need to send our custom event with the event payload — in this case, the — as a second parameter. It looks like this:\n\nThat’s all the magic. The message from the child component is displayed in its parent. Note, that this is an example of emitting inline events in Vue. If you are curious about other ways of using in your code, watch this video. Thanks for reading. Stay tuned."
    },
    {
        "link": "https://stackoverflow.com/questions/69525604/using-the-same-component-in-a-child-and-parent-in-vue",
        "document": "I have a VueJS project - which in one view there are parent and child components that are both using the same component called .\n\nWhen I trigger the modal from the child (to show it), it triggers both the child and parent modals (except no data is passed to the modal triggered by the parent). As I understand it, this is because I have used the component twice - in the parent and child - example below. To note, it works as expected from the paren\n\nI've researched and tried a few things: setting a key value for each of the components, changing the components name among other things. I have also tried using to only show component just before I trigger the parent model however, this solution is not ideal.\n\nHow can I only trigger the modal from the child?"
    },
    {
        "link": "https://stackoverflow.com/questions/73725505/vue3-parent-component-call-child-component-method",
        "document": "If not using it is directly callable at the parent component by\n\nOtherwise if a section must/should be declared at the child component, I learned that I had to declare it like this inside a section.\n\nIt cannot be declared as a separate section in a SFC (single file component) when having the component also declared in a section\n\nsince the context is not given here.\n\nIf I got something wrong please let me know since I am not a vue3 specialist and rather just beginning with vue3 ;-)"
    },
    {
        "link": "https://vueschool.io/articles/vuejs-tutorials/techniques-for-sharing-data-between-vue-js-components",
        "document": "In this example, we are passing the prop with a value of to our child component. We will then be able to access this value from inside of the by initializing our props object in the script tag of our child component file\n\nAs our application grows in size and complexity, passing data through components can become messy. We will have to pass data from a parent component to a child component which may be deeply nested in the component tree. Stores introduce an advanced method of passing data across components by eliminating the problem of prop drilling. Prop drilling refers to transporting data or states as props to the intended destination through intermediate components.\n\nWith stores, our states or data are stored in a centralized point to be accessed by any components irrespective of their hierarchy in the component tree. This is a common way of handling states for big Vue.js applications. Popular state management tools for Vue.js include Pinia and Vuex. For our basic example, we will use Pinia which is the official state management tool for Vue js 3.\n\nProvide and Inject technique is also another useful technique of preventing prop drilling when building complex Vue.js applications. With this technique the parent component can provide dependencies for all its child components. This means that any component in the component tree, regardless of how deep it is, can inject dependencies that are provided by components higher up in the component chain."
    }
]