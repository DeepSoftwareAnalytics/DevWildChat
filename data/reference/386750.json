[
    {
        "link": "https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nOne issue with anonymous classes is that if the implementation of your anonymous class is very simple, such as an interface that contains only one method, then the syntax of anonymous classes may seem unwieldy and unclear. In these cases, you're usually trying to pass functionality as an argument to another method, such as what action should be taken when someone clicks a button. Lambda expressions enable you to do this, to treat functionality as method argument, or code as data.\n\nThe previous section, Anonymous Classes, shows you how to implement a base class without giving it a name. Although this is often more concise than a named class, for classes with only one method, even an anonymous class seems a bit excessive and cumbersome. Lambda expressions let you express instances of single-method classes more compactly.\n\nThis section covers the following topics:\n• Ideal Use Case for Lambda Expressions\n• Approach 1: Create Methods That Search for Members That Match One Characteristic\n• Approach 4: Specify Search Criteria Code in an Anonymous Class\n• Approach 7: Use Lambda Expressions Throughout Your Application\n• Approach 9: Use Aggregate Operations That Accept Lambda Expressions as Parameters\n\nSuppose that you are creating a social networking application. You want to create a feature that enables an administrator to perform any kind of action, such as sending a message, on members of the social networking application that satisfy certain criteria. The following table describes this use case in detail:\n\nSuppose that members of this social networking application are represented by the following class:\n\nSuppose that the members of your social networking application are stored in a instance.\n\nThis section begins with a naive approach to this use case. It improves upon this approach with local and anonymous classes, and then finishes with an efficient and concise approach using lambda expressions. Find the code excerpts described in this section in the example .\n\nApproach 1: Create Methods That Search for Members That Match One Characteristic\n\nOne simplistic approach is to create several methods; each method searches for members that match one characteristic, such as gender or age. The following method prints members that are older than a specified age:\n\nNote: A is an ordered . A collection is an object that groups multiple elements into a single unit. Collections are used to store, retrieve, manipulate, and communicate aggregate data. For more information about collections, see the Collections trail.\n\nThis approach can potentially make your application brittle, which is the likelihood of an application not working because of the introduction of updates (such as newer data types). Suppose that you upgrade your application and change the structure of the class such that it contains different member variables; perhaps the class records and measures ages with a different data type or algorithm. You would have to rewrite a lot of your API to accommodate this change. In addition, this approach is unnecessarily restrictive; what if you wanted to print members younger than a certain age, for example?\n\nThe following method is more generic than ; it prints members within a specified range of ages:\n\nWhat if you want to print members of a specified sex, or a combination of a specified gender and age range? What if you decide to change the class and add other attributes such as relationship status or geographical location? Although this method is more generic than , trying to create a separate method for each possible search query can still lead to brittle code. You can instead separate the code that specifies the criteria for which you want to search in a different class.\n\nThe following method prints members that match search criteria that you specify:\n\nThis method checks each instance contained in the parameter whether it satisfies the search criteria specified in the parameter by invoking the method . If the method returns a value, then the method is invoked on the instance.\n\nTo specify the search criteria, you implement the interface:\n\nThe following class implements the interface by specifying an implementation for the method . This method filters members that are eligible for Selective Service in the United States: it returns a value if its parameter is male and between the ages of 18 and 25:\n\nTo use this class, you create a new instance of it and invoke the method:\n\nAlthough this approach is less brittle—you don't have to rewrite methods if you change the structure of the —you still have additional code: a new interface and a local class for each search you plan to perform in your application. Because implements an interface, you can use an anonymous class instead of a local class and bypass the need to declare a new class for each search.\n\nApproach 4: Specify Search Criteria Code in an Anonymous Class\n\nOne of the arguments of the following invocation of the method is an anonymous class that filters members that are eligible for Selective Service in the United States: those who are male and between the ages of 18 and 25:\n\nThis approach reduces the amount of code required because you don't have to create a new class for each search that you want to perform. However, the syntax of anonymous classes is bulky considering that the interface contains only one method. In this case, you can use a lambda expression instead of an anonymous class, as described in the next section.\n\nThe interface is a functional interface. A functional interface is any interface that contains only one abstract method. (A functional interface may contain one or more default methods or static methods.) Because a functional interface contains only one abstract method, you can omit the name of that method when you implement it. To do this, instead of using an anonymous class expression, you use a lambda expression, which is highlighted in the following method invocation:\n\nSee Syntax of Lambda Expressions for information about how to define lambda expressions.\n\nYou can use a standard functional interface in place of the interface , which reduces even further the amount of code required.\n\nThis is a very simple interface. It's a functional interface because it contains only one abstract method. This method takes one parameter and returns a value. The method is so simple that it might not be worth it to define one in your application. Consequently, the JDK defines several standard functional interfaces, which you can find in the package .\n\nFor example, you can use the interface in place of . This interface contains the method :\n\nThe interface is an example of a generic interface. (For more information about generics, see the Generics (Updated) lesson.) Generic types (such as generic interfaces) specify one or more type parameters within angle brackets ( ). This interface contains only one type parameter, . When you declare or instantiate a generic type with actual type arguments, you have a parameterized type. For example, the parameterized type is the following:\n\nThis parameterized type contains a method that has the same return type and parameters as . Consequently, you can use in place of as the following method demonstrates:\n\nAs a result, the following method invocation is the same as when you invoked in Approach 3: Specify Search Criteria Code in a Local Class to obtain members who are eligible for Selective Service:\n\nThis is not the only possible place in this method to use a lambda expression. The following approach suggests other ways to use lambda expressions.\n\nApproach 7: Use Lambda Expressions Throughout Your Application\n\nReconsider the method to see where else you could use lambda expressions:\n\nThis method checks each instance contained in the parameter whether it satisfies the criteria specified in the parameter . If the instance does satisfy the criteria specified by , the method is invoked on the instance.\n\nInstead of invoking the method , you can specify a different action to perform on those instances that satisfy the criteria specified by . You can specify this action with a lambda expression. Suppose you want a lambda expression similar to , one that takes one argument (an object of type ) and returns void. Remember, to use a lambda expression, you need to implement a functional interface. In this case, you need a functional interface that contains an abstract method that can take one argument of type and returns void. The interface contains the method , which has these characteristics. The following method replaces the invocation with an instance of that invokes the method :\n\nAs a result, the following method invocation is the same as when you invoked in Approach 3: Specify Search Criteria Code in a Local Class to obtain members who are eligible for Selective Service. The lambda expression used to print members is highlighted:\n\nWhat if you want to do more with your members' profiles than printing them out. Suppose that you want to validate the members' profiles or retrieve their contact information? In this case, you need a functional interface that contains an abstract method that returns a value. The interface contains the method . The following method retrieves the data specified by the parameter , and then performs an action on it specified by the parameter :\n\nThe following method retrieves the email address from each member contained in who is eligible for Selective Service and then prints it:\n\nReconsider the method . The following is a generic version of it that accepts, as a parameter, a collection that contains elements of any data type:\n\nTo print the e-mail address of members who are eligible for Selective Service, invoke the method as follows:\n\nThis method invocation performs the following actions:\n• Obtains a source of objects from the collection . In this example, it obtains a source of objects from the collection . Notice that the collection , which is a collection of type , is also an object of type .\n• Filters objects that match the object . In this example, the object is a lambda expression that specifies which members would be eligible for Selective Service.\n• Maps each filtered object to a value as specified by the object . In this example, the object is a lambda expression that returns the e-mail address of a member.\n• Performs an action on each mapped object as specified by the object . In this example, the object is a lambda expression that prints a string, which is the e-mail address returned by the object.\n\nYou can replace each of these actions with an aggregate operation.\n\nApproach 9: Use Aggregate Operations That Accept Lambda Expressions as Parameters\n\nThe following example uses aggregate operations to print the e-mail addresses of those members contained in the collection who are eligible for Selective Service:\n\nThe following table maps each of the operations the method performs with the corresponding aggregate operation:\n\nThe operations , , and are aggregate operations. Aggregate operations process elements from a stream, not directly from a collection (which is the reason why the first method invoked in this example is ). A stream is a sequence of elements. Unlike a collection, it is not a data structure that stores elements. Instead, a stream carries values from a source, such as collection, through a pipeline. A pipeline is a sequence of stream operations, which in this example is - - . In addition, aggregate operations typically accept lambda expressions as parameters, enabling you to customize how they behave.\n\nFor a more thorough discussion of aggregate operations, see the Aggregate Operations lesson.\n\nTo process events in a graphical user interface (GUI) application, such as keyboard actions, mouse actions, and scroll actions, you typically create event handlers, which usually involves implementing a particular interface. Often, event handler interfaces are functional interfaces; they tend to have only one method.\n\nIn the JavaFX example (discussed in the previous section Anonymous Classes), you can replace the highlighted anonymous class with a lambda expression in this statement:\n\nThe method invocation specifies what happens when you select the button represented by the object. This method requires an object of type . The interface contains only one method, . This interface is a functional interface, so you could use the following highlighted lambda expression to replace it:\n\nA lambda expression consists of the following:\n• None A comma-separated list of formal parameters enclosed in parentheses. The method contains one parameter, , which represents an instance of the class. Note: You can omit the data type of the parameters in a lambda expression. In addition, you can omit the parentheses if there is only one parameter. For example, the following lambda expression is also valid:\n• None A body, which consists of a single expression or a statement block. This example uses the following expression: If you specify a single expression, then the Java runtime evaluates the expression and then returns its value. Alternatively, you can use a return statement: A return statement is not an expression; in a lambda expression, you must enclose statements in braces ( ). However, you do not have to enclose a void method invocation in braces. For example, the following is a valid lambda expression:\n\nNote that a lambda expression looks a lot like a method declaration; you can consider lambda expressions as anonymous methods—methods without a name.\n\nThe following example, , is an example of lambda expressions that take more than one formal parameter:\n\nThe method performs a mathematical operation on two integer operands. The operation itself is specified by an instance of . The example defines two operations with lambda expressions, and . The example prints the following:\n\nLike local and anonymous classes, lambda expressions can capture variables; they have the same access to local variables of the enclosing scope. However, unlike local and anonymous classes, lambda expressions do not have any shadowing issues (see Shadowing for more information). Lambda expressions are lexically scoped. This means that they do not inherit any names from a supertype or introduce a new level of scoping. Declarations in a lambda expression are interpreted just as they are in the enclosing environment. The following example, , demonstrates this:\n\nThis example generates the following output:\n\nIf you substitute the parameter in place of in the declaration of the lambda expression , then the compiler generates an error:\n\nThe compiler generates the error \"Lambda expression's parameter x cannot redeclare another local variable defined in an enclosing scope\" because the lambda expression does not introduce a new level of scoping. Consequently, you can directly access fields, methods, and local variables of the enclosing scope. For example, the lambda expression directly accesses the parameter of the method . To access variables in the enclosing class, use the keyword . In this example, refers to the member variable .\n\nHowever, like local and anonymous classes, a lambda expression can only access local variables and parameters of the enclosing block that are final or effectively final. In this example, the variable is effectively final; its value is never changed after it's initialized. However, suppose that you add the following assignment statement in the the lambda expression :\n\nBecause of this assignment statement, the variable is not effectively final anymore. As a result, the Java compiler generates an error message similar to \"Local variable z defined in an enclosing scope must be final or effectively final\".\n\nHow do you determine the type of a lambda expression? Recall the lambda expression that selected members who are male and between the ages 18 and 25 years:\n\nThis lambda expression was used in the following two methods:\n• None in Approach 3: Specify Search Criteria Code in a Local Class\n• None in Approach 6: Use Standard Functional Interfaces with Lambda Expressions\n\nWhen the Java runtime invokes the method , it's expecting a data type of , so the lambda expression is of this type. However, when the Java runtime invokes the method , it's expecting a data type of , so the lambda expression is of this type. The data type that these methods expect is called the target type. To determine the type of a lambda expression, the Java compiler uses the target type of the context or situation in which the lambda expression was found. It follows that you can only use lambda expressions in situations in which the Java compiler can determine a target type:\n\nFor method arguments, the Java compiler determines the target type with two other language features: overload resolution and type argument inference.\n\nConsider the following two functional interfaces ( and ):\n\nThe method does not return a value, whereas does.\n\nSuppose that you have overloaded the method as follows (see Defining Methods for more information about overloading methods):\n\nWhich method will be invoked in the following statement?\n\nThe method will be invoked because that method returns a value; the method does not. In this case, the type of the lambda expression is .\n\nYou can serialize a lambda expression if its target type and its captured arguments are serializable. However, like inner classes, the serialization of lambda expressions is strongly discouraged."
    },
    {
        "link": "https://geeksforgeeks.org/effectively-final-variable-in-java-with-examples",
        "document": "A final variable is a variable that is declared with a keyword known as ‘final‘.\n\nThe Effectively Final variable is a local variable that follows the following properties are listed below as follows:\n• Assigned to ONLY once.\n\nAny local variable or parameter that’s assigned a worth just one occasion right now(or updated only once). It may not remain effectively final throughout the program. so this suggests that effectively final variable might lose its effectively final property after immediately the time it gets assigned/updated a minimum of another assignment. Additionally, an effectively final variable may be a variable whose value isn’t changed, but it isn’t declared with the ultimate keyword.\n\nOutput: An error will be thrown as expected which can be perceived from the terminal output as shown below:\n\nWhen a lambda expression uses an assigned local variable from its enclosing space there’s a crucial restriction. A lambda expression may only use a local variable whose value doesn’t change. That restriction is referred to as “variable capture” which is described as; lambda expression capture values, not variables.\n\nThe local variables that a lambda expression may use are referred to as “effectively final”.\n\nAn effectively final variable is one whose value doesn’t change after it’s first assigned. There is no need to explicitly declare such a variable as final, although doing so would not be an error.\n\nImplementation: Consider we do have an area variable let it be ‘i’ which is initialized with the worth say be ‘7’, with within the lambda expression we try to vary that value by assigning a new value to i. This will end in compiler error – “Local variable i defined in an enclosing scope must be final or effectively final”."
    },
    {
        "link": "https://medium.com/@nabeeltariqbhatti/final-vs-effectively-final-variables-with-lambda-expressions-83a865c7127b",
        "document": "These are two simple but very useful concepts. You might need to understand them to avoid compile time issues that occur while working with lambda expressions.\n\nEffectively final is the variable, which may not have final keyword, means not constant by nature but only be initialized once before its use. Whenever you use the variable in a lambda function expression its mandatory to keep it final or effectively final. I don’t think its necessary to explain the variable with final keyword because by nature they would never change and lambda expressions don’t complain.\n\nNow here we have one question, why a lambda expression needs the variable to be used in it to be final or effectively final? Lambda expressions work with the copy of the variable which are not declared in the body so they are small and only interact and modify the local variables other variables are passed as read only captured values as arguments.\n\nSo keeping this thing in mind it makes this easy for us to understand that if a variable was initialized and used in the lambda now you cannot change it because the value was sent at the time of execution and lambda does not keep track of latest mutations of the variable value not talking of the reference variable’s object which is a different scenario, value gets loaded to lambda method’s primitive or independent local stack. Local variables in the lambda behave as the local variables of the simple method and\n\nBelow are the few examples of valid use of variables which are effectively final straight from the documentation."
    },
    {
        "link": "https://javax0.wordpress.com/2021/12/08/lambda-and-final-variables",
        "document": "Lambda expressions can use the variables in the scope of the lambda expression, but only if they are final or effectively final. What is the reason for that? Why is that? It is an interesting question because the answer is not apparent and opinionated.\n\nThere is only one ultimate answer, though: because that is what the Java Language Specification says. But saying that is boring. True, but boring. I prefer the answer that says lambdas can only use final and effectively final local variables because lambdas are not closures.\n\nIn the following, I will discuss what final and effectively final mean, the differences between closures and lambdas, and finally, how we can create closures in Java using lambda expressions. I am not advocating the creation of lambda expression-based closures in Java, nor the abandonment of the idea.\n\nWhen declaring it, a local variable is final if we use the keyword. The compiler will also require that the variable get a value only once. This value assignment may happen at the location of the declaration but can be a bit later. There can be multiple lines that assign value to the final variable so long as long only one of them can execute for each method invocation. The typical case is when you declare a final variable without assigning value to it, and then you have an statement giving different values in the “then” and the “else” branch.\n\nNeedless to say that the variable has to be initialized before the lambda expression is created.\n\nA variable is effectively final if not final, but it could be. It gets an assigned value at the declaration or can get a given value only once.\n\nA lambda expression is a kind of anonymous class. The JVM handles it differently, and it is more efficient than an anonymous class, not to mention that it is more readable. However, from our point of view, we can think of it as an inner class.\n\nWhen the lambda expression is created, the JVM makes an instance of the lambda class that implements the interface.\n\nThe JVM will place this object on the heap. In some cases, the compiler may realize that the object cannot get out of the method’s scope, and in this case, it may store it in the stack. It is called local variable escape analysis, which can just put any object on the stack, which cannot escape from the method and may die together with the method return. However, for our discussion, we can forget this advanced feature of the Java environment.\n\nThe lambda is created in the method and stored in the heap. It is alive so long as long there is a hard reference to this object and is not collected. If a lambda expression could reference and use a local variable, which lives in the stack, it would need access to something gone after the method returns. It is not possible.\n\nThere are two solutions to overcome this discrepancy. One is what Java follows, creating a copy of the variable’s value. The other one is creating a closure.\n\nWe will look at Groovy examples when talking about closures. The reason to select Groovy is that it is very close to Java. We will look at some Groovy examples, and for the matter of demonstration, we will use Java-style as much as possible. Groovy is more or less compatible with Java; any Java code can be compiled as a Groovy source. The actual semantic may, however, be different slightly.\n\nGroovy solved the issue of local variable accessibility creating closures. The closure closes the functionality and the environment into a single object. For example, the following Groovy code:\n\ncreates a closure, similar to our lambda expression, but it also uses the local variable . This local variable is not final and not effectively final. What happens here is that the compiler creates a new class that contains a field for each local variable used in the closure. A new local variable references an instance of this new class, and the local variable uses all references to this object and its fields. This object, along with the “lambda expression” code, is the closure.\n\nSince the object is on the heap, it stays alive as long as there is a hard reference. The object, which holds the described function has one, so this object will be available so long as long the closure is alive.\n\nIt is clearly shown in the test execution where the closure increases the amount at each execution.\n\nJava approaches this problem differently. Instead of creating a new synthetic object to hold the referenced local variables, it simply uses the values of the variables. Lambdas seem to use the variables, but they don’t. They use only constants copying the value of the variables.\n\nWhen designing lambdas, there were two options. I was not part of the team making the decisions, so what I write here is only my opinion, guessing, but it may help you understand why the decision was made. One option could be to copy the variable’s value when the lambda is created, not caring about the later value change of the local variable. Could it work? Inevitably. Would it be readable? In many cases, it would not be. What if the variable changes later? Will the lambda use the changed value? No, it will use the copied, frozen value. It is different from how variables work usually.\n\nJava requires the variable to be final or effectively final to solve this discrepancy. The disturbing case having the different variable value when the lambda is used is avoided.\n\nWhen designing language elements, there are always tradeoffs. On one end, some constructs provide great power to the hands of the developers. However, great power requires great responsibility. Most of the developers are not mature enough to take on the responsibility.\n\nOn the other side of the scale are the simple constructs providing less functionality. It may not solve some problems so elegantly, but you also cannot create unreadable code so easily. Java is usually going this way. There has been an obfuscated C contest almost since the language C started. Who can write less readable code in that programming language? Since then, almost all languages started the contest, except two. Java and Perl. In the case of Java, the contest would be dull, as you cannot write obfuscated code in Java. In the case of Perl, the contest is pointless.\n\nIf you want to have a closure in Java, you can create one yourself. The good old way is to use anonymous, or for that matter, regular classes. The other is to mimic the behavior of the Groovy compiler and create a class that encapsulates the closure data.\n\nThe Groovy compiler creates the class for you to enclose the local variables, but nothing stops you from making it manually if you want it in Java. You have to do the same thing. Move every local variable that the closure uses into a class as an instance field.\n\nWe only had one local variable, , in our example. We need a class that can hold an int. The class for that is . It does many other things, and it is usually used when concurrent execution is an issue. Because of that, some overhead may slightly affect the performance, which I abjectly ignore for now.\n\nIf there are more than one local variables, we need to craft a class for them.\n\nAs you can see in this example, we can declare a class even inside the method, and for the cohesion of the code, it is the right place. Eventually, it is easy to see that this approach is working.\n\nIt is, however, questionable if you want to use this approach. Lambdas generally should be stateless. When you need a state that a lambda uses, in other words, when you need a closure, which the language does not directly support, you should use a class.\n• This article discussed why a lambda expression can access only final and effectively final local variables.\n• We also discussed the reason and how different languages approach this issue.\n• Finally, we looked at a Groovy example and how Java can mimic this.\n\nTherefore, if anyone asks you the interview question, why a lambda expression can access only final and effectively final local variables, you will know the answer. Because the Java Language Specification says so. Everything else is speculation.\n\nYou an find the code for this article along with the article text source code at https://github.com/verhas/demo/tree/master/LambdaFinal"
    },
    {
        "link": "https://baeldung.com/java-lambda-effectively-final-local-variables",
        "document": "Java 8 gives us lambdas, and by association, the notion of effectively final variables. Ever wondered why local variables captured in lambdas have to be final or effectively final?\n\nWell, the JLS gives us a bit of a hint when it says “The restriction to effectively final variables prohibits access to dynamically-changing local variables, whose capture would likely introduce concurrency problems.” But, what does it mean?\n\nIn the next sections, we’ll dig deeper into this restriction and see why Java introduced it. We’ll show examples to demonstrate how it affects single-threaded and concurrent applications, and we’ll also debunk a common anti-pattern for working around this restriction.\n\nLambda expressions can use variables defined in an outer scope. We refer to these lambdas as capturing lambdas. They can capture static variables, instance variables, and local variables, but only local variables must be final or effectively final.\n\nIn earlier Java versions, we ran into this when an anonymous inner class captured a variable local to the method that surrounded it – we needed to add the final keyword before the local variable for the compiler to be happy.\n\nAs a bit of syntactic sugar, now the compiler can recognize situations where, while the final keyword isn’t present, the reference isn’t changing at all, meaning it’s effectively final. We could say that a variable is effectively final if the compiler wouldn’t complain were we to declare it final.\n\nstart is a local variable, and we are trying to modify it inside of a lambda expression.\n\nThe basic reason this won’t compile is that the lambda is capturing the value of start, meaning making a copy of it. Forcing the variable to be final avoids giving the impression that incrementing start inside the lambda could actually modify the start method parameter.\n\nBut, why does it make a copy? Well, notice that we are returning the lambda from our method. Thus, the lambda won’t get run until after the start method parameter gets garbage collected. Java has to make a copy of start in order for this lambda to live outside of this method.\n\nFor fun, let’s imagine for a moment that Java did allow local variables to somehow remain connected to their captured values.\n\nWhat should we do here:\n\nWhile this looks innocent, it has the insidious problem of “visibility”. Recall that each thread gets its own stack, and so how do we ensure that our while loop sees the change to the run variable in the other stack? The answer in other contexts could be using synchronized blocks or the volatile keyword.\n\nHowever, because Java imposes the effectively final restriction, we don’t have to worry about complexities like this.\n\nThe examples before can raise some questions if we compare them with the use of static or instance variables in a lambda expression.\n\nWe can make our first example compile just by converting our start variable into an instance variable:\n\nBut, why can we change the value of start here?\n\nSimply put, it’s about where member variables are stored. Local variables are on the stack, but member variables are on the heap. Because we’re dealing with heap memory, the compiler can guarantee that the lambda will have access to the latest value of start.\n\nWe can fix our second example by doing the same:\n\nThe run variable is now visible to the lambda even when it’s executed in another thread since we added the volatile keyword.\n\nGenerally speaking, when capturing an instance variable, we could think of it as capturing the final variable this. Anyway, the fact that the compiler doesn’t complain doesn’t mean that we shouldn’t take precautions, especially in multithreading environments.\n\nIn order to get around the restriction on local variables, someone may think of using variable holders to modify the value of a local variable.\n\nLet’s see an example that uses an array to store a variable in a single-threaded application:\n\nWe could think that the stream is summing 2 to each value, but it’s actually summing 0 since this is the latest value available when the lambda is executed.\n\nLet’s go one step further and execute the sum in another thread:\n\nWhat value are we summing here? It depends on how long our simulated processing takes. If it’s short enough to let the execution of the method terminate before the other thread is executed it’ll print 6, otherwise, it’ll print 12.\n\nIn general, these kinds of workarounds are error-prone and can produce unpredictable results, so we should always avoid them.\n\nIn this article, we’ve explained why lambda expressions can only use final or effectively final local variables. As we’ve seen, this restriction comes from the different nature of these variables and how Java stores them in memory. We’ve also shown the dangers of using a common workaround."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html",
        "document": "A sequence of elements supporting sequential and parallel aggregate operations. The following example illustrates an aggregate operation using and In this example,is a. We create a stream ofobjects via , filter it to produce a stream containing only the red widgets, and then transform it into a stream ofvalues representing the weight of each red widget. Then this stream is summed to produce a total weight.\n\nIn addition to , which is a stream of object references, there are primitive specializations for , , and , all of which are referred to as \"streams\" and conform to the characteristics and restrictions described here.\n\nTo perform a computation, stream operations are composed into a stream pipeline. A stream pipeline consists of a source (which might be an array, a collection, a generator function, an I/O channel, etc), zero or more intermediate operations (which transform a stream into another stream, such as ), and a terminal operation (which produces a result or side-effect, such as or ). Streams are lazy; computation on the source data is only performed when the terminal operation is initiated, and source elements are consumed only as needed.\n\nCollections and streams, while bearing some superficial similarities, have different goals. Collections are primarily concerned with the efficient management of, and access to, their elements. By contrast, streams do not provide a means to directly access or manipulate their elements, and are instead concerned with declaratively describing their source and the computational operations which will be performed in aggregate on that source. However, if the provided stream operations do not offer the desired functionality, the and operations can be used to perform a controlled traversal.\n\nA stream pipeline, like the \"widgets\" example above, can be viewed as a query on the stream source. Unless the source was explicitly designed for concurrent modification (such as a ), unpredictable or erroneous behavior may result from modifying the stream source while it is being queried.\n\nMost stream operations accept parameters that describe user-specified behavior, such as the lambda expression passed to in the example above. To preserve correct behavior, these behavioral parameters:\n• must be non-interfering (they do not modify the stream source); and\n• in most cases must be stateless (their result should not depend on any state that might change during execution of the stream pipeline).\n\nSuch parameters are always instances of a functional interface such as , and are often lambda expressions or method references. Unless otherwise specified these parameters must be non-null.\n\nA stream should be operated on (invoking an intermediate or terminal stream operation) only once. This rules out, for example, \"forked\" streams, where the same source feeds two or more pipelines, or multiple traversals of the same stream. A stream implementation may throw if it detects that the stream is being reused. However, since some stream operations may return their receiver rather than a new stream object, it may not be possible to detect reuse in all cases.\n\nStreams have a method and implement , but nearly all stream instances do not actually need to be closed after use. Generally, only streams whose source is an IO channel (such as those returned by ) will require closing. Most streams are backed by collections, arrays, or generating functions, which require no special resource management. (If a stream does require closing, it can be declared as a resource in a -with-resources statement.)\n\nStream pipelines may execute either sequentially or in parallel. This execution mode is a property of the stream. Streams are created with an initial choice of sequential or parallel execution. (For example, creates a sequential stream, and creates a parallel one.) This choice of execution mode may be modified by the or methods, and may be queried with the method."
    },
    {
        "link": "https://baeldung.com/java-stream-filter-lambda",
        "document": "In this quick tutorial, we’ll explore the use of the Stream.filter() method when we work with Streams in Java.\n\nWe’ll look at how to use it, and how to handle special cases with checked exceptions.\n\nThe filter() method is an intermediate operation of the Stream interface that allows us to filter elements of a stream that match a given Predicate:\n\nTo see how this works, let’s create a Customer class:\n\nA common use case of the filter() method is processing collections.\n\nLet’s make a list of customers with more than 100 points. To do that, we can use a lambda expression:\n\nWe can also use a method reference, which is shorthand for a lambda expression:\n\nIn this case, we added the hasOverHundredPoints method to our Customer class:\n\nIn both cases, we get the same result:\n\nFurthermore, we can use multiple conditions with filter(). For example, we can filter by points and name:\n\nUntil now, we’ve been using the filter with predicates that don’t throw an exception. Indeed, the functional interfaces in Java don’t declare any checked or unchecked exceptions.\n\nNext we’re going to show some different ways to handle exceptions in lambda expressions.\n\nFirst, we’ll start by adding a profilePhotoUrl to our Customer:\n\nIn addition, let’s add a simple hasValidProfilePhoto() method to check the availability of the profile:\n\nWe can see that the hasValidProfilePhoto() method throws an IOException. Now if we try to filter the customers with this method:\n\nWe’ll see the following error:\n\nTo handle it, one of the alternatives we can use is wrapping it with a try-catch block:\n\nIf we need to throw an exception from our predicate, we can wrap it in an unchecked exception like RuntimeException.\n\nAlternatively, we can use the ThrowingFunction library.\n\nThrowingFunction is an open source library that allows us to handle checked exceptions in Java functional interfaces.\n\nLet’s start by adding the throwing-function dependency to our pom:\n\nTo handle exceptions in predicates, this library offers us the ThrowingPredicate class, which has the unchecked() method to wrap checked exceptions.\n\nLet’s see it in action:\n\nIn this article, we saw an example of how to use the filter() method to process streams. We also explored some alternatives to handle exceptions."
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nOne issue with anonymous classes is that if the implementation of your anonymous class is very simple, such as an interface that contains only one method, then the syntax of anonymous classes may seem unwieldy and unclear. In these cases, you're usually trying to pass functionality as an argument to another method, such as what action should be taken when someone clicks a button. Lambda expressions enable you to do this, to treat functionality as method argument, or code as data.\n\nThe previous section, Anonymous Classes, shows you how to implement a base class without giving it a name. Although this is often more concise than a named class, for classes with only one method, even an anonymous class seems a bit excessive and cumbersome. Lambda expressions let you express instances of single-method classes more compactly.\n\nThis section covers the following topics:\n• Ideal Use Case for Lambda Expressions\n• Approach 1: Create Methods That Search for Members That Match One Characteristic\n• Approach 4: Specify Search Criteria Code in an Anonymous Class\n• Approach 7: Use Lambda Expressions Throughout Your Application\n• Approach 9: Use Aggregate Operations That Accept Lambda Expressions as Parameters\n\nSuppose that you are creating a social networking application. You want to create a feature that enables an administrator to perform any kind of action, such as sending a message, on members of the social networking application that satisfy certain criteria. The following table describes this use case in detail:\n\nSuppose that members of this social networking application are represented by the following class:\n\nSuppose that the members of your social networking application are stored in a instance.\n\nThis section begins with a naive approach to this use case. It improves upon this approach with local and anonymous classes, and then finishes with an efficient and concise approach using lambda expressions. Find the code excerpts described in this section in the example .\n\nApproach 1: Create Methods That Search for Members That Match One Characteristic\n\nOne simplistic approach is to create several methods; each method searches for members that match one characteristic, such as gender or age. The following method prints members that are older than a specified age:\n\nNote: A is an ordered . A collection is an object that groups multiple elements into a single unit. Collections are used to store, retrieve, manipulate, and communicate aggregate data. For more information about collections, see the Collections trail.\n\nThis approach can potentially make your application brittle, which is the likelihood of an application not working because of the introduction of updates (such as newer data types). Suppose that you upgrade your application and change the structure of the class such that it contains different member variables; perhaps the class records and measures ages with a different data type or algorithm. You would have to rewrite a lot of your API to accommodate this change. In addition, this approach is unnecessarily restrictive; what if you wanted to print members younger than a certain age, for example?\n\nThe following method is more generic than ; it prints members within a specified range of ages:\n\nWhat if you want to print members of a specified sex, or a combination of a specified gender and age range? What if you decide to change the class and add other attributes such as relationship status or geographical location? Although this method is more generic than , trying to create a separate method for each possible search query can still lead to brittle code. You can instead separate the code that specifies the criteria for which you want to search in a different class.\n\nThe following method prints members that match search criteria that you specify:\n\nThis method checks each instance contained in the parameter whether it satisfies the search criteria specified in the parameter by invoking the method . If the method returns a value, then the method is invoked on the instance.\n\nTo specify the search criteria, you implement the interface:\n\nThe following class implements the interface by specifying an implementation for the method . This method filters members that are eligible for Selective Service in the United States: it returns a value if its parameter is male and between the ages of 18 and 25:\n\nTo use this class, you create a new instance of it and invoke the method:\n\nAlthough this approach is less brittle—you don't have to rewrite methods if you change the structure of the —you still have additional code: a new interface and a local class for each search you plan to perform in your application. Because implements an interface, you can use an anonymous class instead of a local class and bypass the need to declare a new class for each search.\n\nApproach 4: Specify Search Criteria Code in an Anonymous Class\n\nOne of the arguments of the following invocation of the method is an anonymous class that filters members that are eligible for Selective Service in the United States: those who are male and between the ages of 18 and 25:\n\nThis approach reduces the amount of code required because you don't have to create a new class for each search that you want to perform. However, the syntax of anonymous classes is bulky considering that the interface contains only one method. In this case, you can use a lambda expression instead of an anonymous class, as described in the next section.\n\nThe interface is a functional interface. A functional interface is any interface that contains only one abstract method. (A functional interface may contain one or more default methods or static methods.) Because a functional interface contains only one abstract method, you can omit the name of that method when you implement it. To do this, instead of using an anonymous class expression, you use a lambda expression, which is highlighted in the following method invocation:\n\nSee Syntax of Lambda Expressions for information about how to define lambda expressions.\n\nYou can use a standard functional interface in place of the interface , which reduces even further the amount of code required.\n\nThis is a very simple interface. It's a functional interface because it contains only one abstract method. This method takes one parameter and returns a value. The method is so simple that it might not be worth it to define one in your application. Consequently, the JDK defines several standard functional interfaces, which you can find in the package .\n\nFor example, you can use the interface in place of . This interface contains the method :\n\nThe interface is an example of a generic interface. (For more information about generics, see the Generics (Updated) lesson.) Generic types (such as generic interfaces) specify one or more type parameters within angle brackets ( ). This interface contains only one type parameter, . When you declare or instantiate a generic type with actual type arguments, you have a parameterized type. For example, the parameterized type is the following:\n\nThis parameterized type contains a method that has the same return type and parameters as . Consequently, you can use in place of as the following method demonstrates:\n\nAs a result, the following method invocation is the same as when you invoked in Approach 3: Specify Search Criteria Code in a Local Class to obtain members who are eligible for Selective Service:\n\nThis is not the only possible place in this method to use a lambda expression. The following approach suggests other ways to use lambda expressions.\n\nApproach 7: Use Lambda Expressions Throughout Your Application\n\nReconsider the method to see where else you could use lambda expressions:\n\nThis method checks each instance contained in the parameter whether it satisfies the criteria specified in the parameter . If the instance does satisfy the criteria specified by , the method is invoked on the instance.\n\nInstead of invoking the method , you can specify a different action to perform on those instances that satisfy the criteria specified by . You can specify this action with a lambda expression. Suppose you want a lambda expression similar to , one that takes one argument (an object of type ) and returns void. Remember, to use a lambda expression, you need to implement a functional interface. In this case, you need a functional interface that contains an abstract method that can take one argument of type and returns void. The interface contains the method , which has these characteristics. The following method replaces the invocation with an instance of that invokes the method :\n\nAs a result, the following method invocation is the same as when you invoked in Approach 3: Specify Search Criteria Code in a Local Class to obtain members who are eligible for Selective Service. The lambda expression used to print members is highlighted:\n\nWhat if you want to do more with your members' profiles than printing them out. Suppose that you want to validate the members' profiles or retrieve their contact information? In this case, you need a functional interface that contains an abstract method that returns a value. The interface contains the method . The following method retrieves the data specified by the parameter , and then performs an action on it specified by the parameter :\n\nThe following method retrieves the email address from each member contained in who is eligible for Selective Service and then prints it:\n\nReconsider the method . The following is a generic version of it that accepts, as a parameter, a collection that contains elements of any data type:\n\nTo print the e-mail address of members who are eligible for Selective Service, invoke the method as follows:\n\nThis method invocation performs the following actions:\n• Obtains a source of objects from the collection . In this example, it obtains a source of objects from the collection . Notice that the collection , which is a collection of type , is also an object of type .\n• Filters objects that match the object . In this example, the object is a lambda expression that specifies which members would be eligible for Selective Service.\n• Maps each filtered object to a value as specified by the object . In this example, the object is a lambda expression that returns the e-mail address of a member.\n• Performs an action on each mapped object as specified by the object . In this example, the object is a lambda expression that prints a string, which is the e-mail address returned by the object.\n\nYou can replace each of these actions with an aggregate operation.\n\nApproach 9: Use Aggregate Operations That Accept Lambda Expressions as Parameters\n\nThe following example uses aggregate operations to print the e-mail addresses of those members contained in the collection who are eligible for Selective Service:\n\nThe following table maps each of the operations the method performs with the corresponding aggregate operation:\n\nThe operations , , and are aggregate operations. Aggregate operations process elements from a stream, not directly from a collection (which is the reason why the first method invoked in this example is ). A stream is a sequence of elements. Unlike a collection, it is not a data structure that stores elements. Instead, a stream carries values from a source, such as collection, through a pipeline. A pipeline is a sequence of stream operations, which in this example is - - . In addition, aggregate operations typically accept lambda expressions as parameters, enabling you to customize how they behave.\n\nFor a more thorough discussion of aggregate operations, see the Aggregate Operations lesson.\n\nTo process events in a graphical user interface (GUI) application, such as keyboard actions, mouse actions, and scroll actions, you typically create event handlers, which usually involves implementing a particular interface. Often, event handler interfaces are functional interfaces; they tend to have only one method.\n\nIn the JavaFX example (discussed in the previous section Anonymous Classes), you can replace the highlighted anonymous class with a lambda expression in this statement:\n\nThe method invocation specifies what happens when you select the button represented by the object. This method requires an object of type . The interface contains only one method, . This interface is a functional interface, so you could use the following highlighted lambda expression to replace it:\n\nA lambda expression consists of the following:\n• None A comma-separated list of formal parameters enclosed in parentheses. The method contains one parameter, , which represents an instance of the class. Note: You can omit the data type of the parameters in a lambda expression. In addition, you can omit the parentheses if there is only one parameter. For example, the following lambda expression is also valid:\n• None A body, which consists of a single expression or a statement block. This example uses the following expression: If you specify a single expression, then the Java runtime evaluates the expression and then returns its value. Alternatively, you can use a return statement: A return statement is not an expression; in a lambda expression, you must enclose statements in braces ( ). However, you do not have to enclose a void method invocation in braces. For example, the following is a valid lambda expression:\n\nNote that a lambda expression looks a lot like a method declaration; you can consider lambda expressions as anonymous methods—methods without a name.\n\nThe following example, , is an example of lambda expressions that take more than one formal parameter:\n\nThe method performs a mathematical operation on two integer operands. The operation itself is specified by an instance of . The example defines two operations with lambda expressions, and . The example prints the following:\n\nLike local and anonymous classes, lambda expressions can capture variables; they have the same access to local variables of the enclosing scope. However, unlike local and anonymous classes, lambda expressions do not have any shadowing issues (see Shadowing for more information). Lambda expressions are lexically scoped. This means that they do not inherit any names from a supertype or introduce a new level of scoping. Declarations in a lambda expression are interpreted just as they are in the enclosing environment. The following example, , demonstrates this:\n\nThis example generates the following output:\n\nIf you substitute the parameter in place of in the declaration of the lambda expression , then the compiler generates an error:\n\nThe compiler generates the error \"Lambda expression's parameter x cannot redeclare another local variable defined in an enclosing scope\" because the lambda expression does not introduce a new level of scoping. Consequently, you can directly access fields, methods, and local variables of the enclosing scope. For example, the lambda expression directly accesses the parameter of the method . To access variables in the enclosing class, use the keyword . In this example, refers to the member variable .\n\nHowever, like local and anonymous classes, a lambda expression can only access local variables and parameters of the enclosing block that are final or effectively final. In this example, the variable is effectively final; its value is never changed after it's initialized. However, suppose that you add the following assignment statement in the the lambda expression :\n\nBecause of this assignment statement, the variable is not effectively final anymore. As a result, the Java compiler generates an error message similar to \"Local variable z defined in an enclosing scope must be final or effectively final\".\n\nHow do you determine the type of a lambda expression? Recall the lambda expression that selected members who are male and between the ages 18 and 25 years:\n\nThis lambda expression was used in the following two methods:\n• None in Approach 3: Specify Search Criteria Code in a Local Class\n• None in Approach 6: Use Standard Functional Interfaces with Lambda Expressions\n\nWhen the Java runtime invokes the method , it's expecting a data type of , so the lambda expression is of this type. However, when the Java runtime invokes the method , it's expecting a data type of , so the lambda expression is of this type. The data type that these methods expect is called the target type. To determine the type of a lambda expression, the Java compiler uses the target type of the context or situation in which the lambda expression was found. It follows that you can only use lambda expressions in situations in which the Java compiler can determine a target type:\n\nFor method arguments, the Java compiler determines the target type with two other language features: overload resolution and type argument inference.\n\nConsider the following two functional interfaces ( and ):\n\nThe method does not return a value, whereas does.\n\nSuppose that you have overloaded the method as follows (see Defining Methods for more information about overloading methods):\n\nWhich method will be invoked in the following statement?\n\nThe method will be invoked because that method returns a value; the method does not. In this case, the type of the lambda expression is .\n\nYou can serialize a lambda expression if its target type and its captured arguments are serializable. However, like inner classes, the serialization of lambda expressions is strongly discouraged."
    },
    {
        "link": "https://iampravo.medium.com/java-8-a-new-era-of-programming-with-lambdas-and-streams-cd9b31a23aa5",
        "document": "Java 8: A New Era of Programming with Lambdas and Streams\n\nJava 8, released in 2014, marked a significant milestone in the evolution of Java, introducing powerful features that have since become indispensable in modern Java development. This article will explore the most prominent features: Lambda Expressions, Streams API, Optional, and new Date and Time API.\n\nLambda expressions are a concise way to represent instances of functional interfaces, allowing developers to write cleaner and more readable code. A functional interface is an interface with only one abstract method. Let’s take a look at how lambda expressions work with a simple example.\n\nAs you can see, lambda expressions make the code more concise and expressive. The syntax for a lambda expression is as follows:\n\nLambda expressions can also be used with the new forEach method added to the Iterable interface:\n\nIn some cases, lambda expressions can be simplified even further with method references. Method references allow you to refer to an existing method by its name. There are four types of method references:\n• Instance method reference of an arbitrary object of a particular type:\n\nHere’s an example of using a method reference:\n\nJava 8 introduced several new functional interfaces in the package, including:\n• Function<T, R>: Represents a function that accepts one argument and produces a result.\n• Consumer<T>: Represents an operation that accepts a single input argument and returns no result.\n\nStreams API: A New Way to Process Collections\n\nJava 8’s Streams API brings a new way to process collections, making it easier to perform complex operations on data sets. It allows developers to write more functional, declarative, and parallelizable code. Let’s explore some of the most common operations:\n\nThe method is a terminal operation that transforms the result of a stream pipeline into a different data structure or a value. The class provides many useful collectors for common tasks:\n\nNote that infinite streams should be used with caution and must be limited using operations like `limit()` to avoid running out of memory.\n\nJava 8 introduced the `Optional<T>` class as a container that can hold a value of type `T` or be empty. It provides a better alternative to using `null` references, helping developers avoid `NullPointerException` and write safer code.\n\nJava 8 introduced the ability to define default method implementations in interfaces, allowing developers to add new methods to interfaces without breaking existing implementations.\n\nJava 8 introduced a new Date/Time API in the `java.time` package, addressing the shortcomings of the old `java.util.Date` and `java.util.Calendar` classes.\n\nIn Java 8, the package was further enhanced for smoother, safer, and easier concurrent programming. One noteworthy enhancement in Java 8 was related to the CompletableFuture class.\n\nThe CompletableFuture class provides a large number of operations that can be used to coordinate the activities of several asynchronous tasks. It introduced a broad set of methods that enable pipeline processing of the results of asynchronous tasks.\n\nAdditions were also made to define how tasks are performed, including support for delays and timeouts, more flexible subclassing, and interoperability with the Stream and the Future API.\n\nBelow, there is an example which creates a CompletableFuture, simulates a long-running task and finally returns the result:\n\nIn the example, is a blocking call and will wait until the future completes before continuing.\n\nA new common pool was introduced for parallel frameworks. This pool is used by all parallel streams and can be queried and controlled via static methods in the method.\n\nThe class was also introduced in Java 8 as a base class for creating more complex custom ForkJoinTasks that require completion actions triggered by the completion of others.\n\nBefore Java 8, the JVM divided its managed memory into several regions, one of which was the area known as the Permanent Generation (PermGen). The PermGen was used to store metadata information about the classes, methods in our application, and other runtime references. Memory allocation for PermGen was separate and had to be carefully monitored. If not appropriately managed, it could cause the dreaded .\n\nJava 8 brought a significant change to JVM’s memory management by removing the concept of PermGen. In its place, a new memory space called Metaspace was introduced. The Metaspace stores class definitions and other metadata in native memory, which is memory managed by the underlying operating system.\n\nWhile in PermGen space, classes metadata had a fixed maximum size limit, the metaspace, in theory, grows dynamically, limited only by the amount of native memory available to the JVM process.\n\nFurther, Java 8 introduced a new garbage collector called Garbage-First Collector (G1 GC). It is designed to avoid full GCs and target a consistent pause time. G1 GC performs collections in a manner that seems “mixed” in nature; some parts are paralyzed, and others are concurrent, making it an exceptionally efficient collector for applications that can afford to give up CPU cycles for GC work.\n\nTo make your application use the G1 GC, specify the following options in your command line:\n\nJava 8 features various security upgrades, including strong cryptographic algorithms and security primitives. Noteworthy additions are support for AEAD algorithms and stronger password-based encryption. For instance, the Java code to initialize a Cipher instance using the “AES/GCM/NoPadding” transformation, which uses an AEAD mode\n\nThis documentation offers guides to employing the JavaFX framework and 2D/3D graphics libraries added in Java 8. JavaFX is a software platform for creating and delivering desktop and rich internet applications (RIAs) that can run across a wide range of devices.\n\nJava 8 introduced enhancements to many Java technology tools, such as , , and JavaFX-related tools. These enhancements provide developers with improved productivity and greater ease of use.\n\nInternationalization capabilities in Java 8 got a significant uplift, including adding new locales and up-to-date Unicode support. For example, creating a Locale instance for the Northern Sami language in Sweden can be done as:\n\nThe document details updates to Applet technology and Java Web Start technology, aimed at enriching user experience and stepping up the heights of security measures in Java-based applications.\n\nImprovements to the Nashorn JavaScript engine and scripting API are detailed in this resource. In Java 8, you can execute JavaScript code like this:\n\nThe enhancements made to the Java’s PACK200 tool, a Packed File Format Implementation, are detailed in this documentation. PACK200 aids in creating network-friendly compressed JAR file formats. In Java 8, you can initialize a instance using .\n\nJava 8 introduced several improvements to the Java I/O system, most notably to the package, which provides extensive support for file I/O and for accessing file and file system attributes. You can create a Path instance like so:\n\nUsing the JDBC API, you can access virtually any data source, from relational databases to spreadsheets and flat files. JDBC technology also provides a common base on which tools and alternate interfaces can be built.\n\nJava 8 introduces improvements, especially for network interfaces and the Datagram Transport Layer Security(DTLS) API, which provides communication security for datagram protocols.\n\nJava 8 brought a new era of programming with the introduction of lambda expressions, the Streams API, Optional, default methods in interfaces, and the new Date/Time API. These features have made Java more expressive, functional, and efficient, allowing developers to write cleaner and more maintainable code. Embrace these powerful tools to elevate your Java programming skills to new heights!"
    },
    {
        "link": "https://stackoverflow.com/questions/47976942/filtering-a-list-using-java-8-lambda-expressions",
        "document": "Then I have another main function where I have a and have to filter that list of projects on the basis of year and get names list as the result.\n\nCan you please tell me how to do it using java 8 lambda expressions?"
    }
]