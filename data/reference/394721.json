[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 . * Some parts of this feature may have varying levels of support.\n\nThe interface, part of the Canvas API, provides the 2D rendering context for the drawing surface of a element. It is used for drawing shapes, text, images, and other objects. The interface's properties and methods are described in the reference section of this page. The Canvas tutorial has more explanation, examples, and resources, as well. For , there is an equivalent interface that provides the rendering context. The offscreen rendering context inherits most of the same properties and methods as the and is described in more detail in the reference page.\n\nTo get a instance, you must first have an HTML element to work with: To get the canvas' 2D rendering context, call on the element, supplying as the argument: With the context in hand, you can draw anything you like. This code draws a house: The resulting drawing looks like this:\n\nThe following methods can be used to manipulate paths of objects. Starts a new path by emptying the list of sub-paths. Call this method when you want to create a new path. Causes the point of the pen to move back to the start of the current sub-path. It tries to draw a straight line from the current point to the start. If the shape has already been closed or has only one point, this function does nothing. Moves the starting point of a new sub-path to the (x, y) coordinates. Connects the last point in the current sub-path to the specified (x, y) coordinates with a straight line. Adds an arc to the current path with the given control points and radius, connected to the previous point by a straight line. Adds an elliptical arc to the current path. Creates a path for a rectangle at position (x, y) with a size that is determined by width and height. Creates a path for a rounded rectangle with a specified position, width, height, and corner radii.\n\nObjects in the rendering context have a current transformation matrix and methods to manipulate it. The transformation matrix is applied when creating the current default path, painting text, shapes and objects. The methods listed below remain for historical and compatibility reasons as objects are used in most parts of the API nowadays and will be used in the future instead. Retrieves the current transformation matrix being applied to the context. Adds a rotation to the transformation matrix. The angle argument represents a clockwise rotation angle and is expressed in radians. Adds a scaling transformation to the canvas units by x horizontally and by y vertically. Adds a translation transformation by moving the canvas and its origin x horizontally and y vertically on the grid. Multiplies the current transformation matrix with the matrix described by its arguments. Resets the current transform to the identity matrix, and then invokes the method with the same arguments. Resets the current transform by the identity matrix.\n\nThe rendering context contains a variety of drawing style states (attributes for line styles, fill styles, shadow styles, text styles). The following methods help you to work with that state: Saves the current drawing style state using a stack so you can revert any change you make to it using . Restores the drawing style state to the last element on the 'state stack' saved by . A read-only back-reference to the . Might be if it is not associated with a element. Returns an object containing the context attributes used by the browser. Context attributes can be requested when using to create the 2D context. Resets the rendering context, including the backing buffer, the drawing state stack, path, and styles. Returns if the rendering context was lost."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API",
        "document": "The Canvas API provides a means for drawing graphics via JavaScript and the HTML element. Among other things, it can be used for animation, game graphics, data visualization, photo manipulation, and real-time video processing. The Canvas API largely focuses on 2D graphics. The WebGL API, which also uses the element, draws hardware-accelerated 2D and 3D graphics.\n\nThe method gets a reference to the HTML element. Next, the method gets that element's context—the thing onto which the drawing will be rendered. The actual drawing is done using the interface. The property makes the rectangle green. The method places its top-left corner at (10, 10), and gives it a size of 150 units wide by 100 tall.\n\nThe Canvas API is extremely powerful, but not always simple to use. The libraries listed below can make the creation of canvas-based projects faster and easier.\n• EaselJS is an open-source canvas library that makes creating games, generative art, and other highly graphical experiences easy.\n• Fabric.js is an open-source canvas library with SVG parsing capabilities.\n• heatmap.js is an open-source library for creating canvas-based data heat maps.\n• Konva.js is a 2D canvas library for desktop and mobile applications.\n• p5.js has a full set of canvas drawing functionality for artists, designers, educators, and beginners.\n• Paper.js is an open-source vector graphics scripting framework that runs on top of the HTML Canvas.\n• Phaser is a fast, free and fun open source framework for Canvas and WebGL powered browser games.\n• Pts.js is a library for creative coding and visualization in canvas and SVG.\n• Rekapi is an animation key-framing API for Canvas.\n• Scrawl-canvas is an open-source JavaScript library for creating and manipulating 2D canvas elements.\n• The ZIM framework provides conveniences, components, and controls for coding creativity on the canvas — includes accessibility and hundreds of colorful tutorials.\n• Sprig is a beginner-friendly, open-source, tile-based game development library that uses Canvas. Note: See the WebGL API for 2D and 3D libraries that use WebGL."
    },
    {
        "link": "https://w3schools.com/tags/ref_canvas.asp",
        "document": "You can add a canvas element anywhere in an HTML page with the tag:\n\nYou can access a element with the HTML DOM method .\n\nTo draw in the canvas you need to create a 2D context object:\n\nAfter you have created a 2D context, you can draw on the canvas.\n\nThe fillRect() method draws a black rectangle with a top-left corner at position 20,20. The rectangle is 150 pixel wide and 100 pixels high.\n\nThe fillStyle property sets the fill color of the drawing object:\n\nYou can also create a new element with the method, and add the element to an existing HTML page:\n\nThe common way to draw on the canvas is to:\n\nThere are only 3 methods to draw directly on the canvas:\n\nThe canvas object also supports the standard properties and events.\n\nThe element is an HTML5 standard (2014).\n\nis supported in all modern browsers:"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Basic_usage",
        "document": "Let's start this tutorial by looking at the HTML element itself. At the end of this page, you will know how to set up a canvas 2D context and have drawn a first example in your browser.\n\nAt first sight a looks like the element, with the only clear difference being that it doesn't have the and attributes. Indeed, the element has only two attributes, and . These are both optional and can also be set using DOM properties. When no and attributes are specified, the canvas will initially be 300 pixels wide and 150 pixels high. The element can be sized arbitrarily by CSS, but during rendering the image is scaled to fit its layout size: if the CSS sizing doesn't respect the ratio of the initial canvas, it will appear distorted. Note: If your renderings seem distorted, try specifying your and attributes explicitly in the attributes, and not using CSS. The attribute isn't specific to the element but is one of the global HTML attributes which can be applied to any HTML element (like for instance). It is always a good idea to supply an because this makes it much easier to identify it in a script. The element can be styled just like any normal image ( , , …). These rules, however, don't affect the actual drawing on the canvas. We'll see how this is done in a dedicated chapter of this tutorial. When no styling rules are applied to the canvas it will initially be fully transparent.\n\nThe element, like the , , , and elements, must be made accessible by providing fallback text to be displayed when the media doesn't load or the user is unable to experience it as intended. You should always provide fallback content, captions, and alternative text, as appropriate for the media type. Providing fallback content is very straightforward: just insert the alternate content inside the element to be accessed by screen readers, spiders, and other automated bots. Browsers, by default, will ignore the content inside the container, rendering the canvas normally unless isn't supported. For example, we could provide a text description of the canvas content or provide a static image of the dynamically rendered content. This can look something like this: Telling the user to use a different browser that supports canvas does not help users who can't read the canvas at all. Providing useful fallback text or sub DOM adds accessibility to an otherwise non-accessible element.\n\nAs a consequence of the way fallback is provided, unlike the element, the element requires the closing tag ( ). If this tag is not present, the rest of the document would be considered the fallback content and wouldn't be displayed. If fallback content is not needed, a simple is fully compatible with all browsers that support canvas at all. This should only be used if the canvas is purely presentational.\n\nThe element creates a fixed-size drawing surface that exposes one or more rendering contexts, which are used to create and manipulate the content shown. In this tutorial, we focus on the 2D rendering context. Other contexts may provide different types of rendering; for example, WebGL uses a 3D context based on OpenGL ES. The canvas is initially blank. To display something, a script first needs to access the rendering context and draw on it. The element has a method called , used to obtain the rendering context and its drawing functions. takes one parameter, the type of context. For 2D graphics, such as those covered by this tutorial, you specify to get a . The first line in the script retrieves the node in the DOM representing the element by calling the method. Once you have the element node, you can access the drawing context using its method.\n\nHere is a minimalistic template, which we'll be using as a starting point for later examples. Note: It is not good practice to embed a script inside HTML. We do it here to keep the example concise. The script includes a function called , which is executed once the page finishes loading; this is done by listening for the event on the document. This function, or one like it, could also be called using , , or any other event handler, as long as the page has been loaded first. Here is how a template would look in action. As shown here, it is initially blank."
    },
    {
        "link": "https://w3schools.com/jsref/api_canvas.asp",
        "document": "You access a element with the HTML DOM method .\n\nTo draw in the canvas you need to create a 2D context object:\n\nThe common way to draw on the canvas is to:\n\nThere are only 3 methods to draw directly on the canvas:\n\nThe canvas object also supports the standard properties and events.\n\nThe element is an HTML5 standard (2014).\n\nis supported in all modern browsers:"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas",
        "document": "The element is one of the most widely used tools for rendering 2D graphics on the web. However, when websites and apps push the Canvas API to its limits, performance begins to suffer. This article provides suggestions for optimizing your use of the canvas element to ensure that your graphics perform well.\n\nPre-render similar primitives or repeating objects on an offscreen canvas If you find yourself repeating some of the same drawing operations on each animation frame, consider offloading them to an offscreen canvas. You can then render the offscreen image to your primary canvas as often as needed, without unnecessarily repeating the steps needed to generate it in the first place.\n\nAvoid floating-point coordinates and use integers instead Sub-pixel rendering occurs when you render objects on a canvas without whole values. This forces the browser to do extra calculations to create the anti-aliasing effect. To avoid this, make sure to round all co-ordinates used in calls to using , for example.\n\nIn your application, you may find that some objects need to move or change frequently, while others remain relatively static. A possible optimization in this situation is to layer your items using multiple elements. For example, let's say you have a game with a UI on top, the gameplay action in the middle, and a static background on the bottom. In this case, you could split your game into three layers. The UI would change only upon user input, the gameplay layer would change with every new frame, and the background would remain generally unchanged.\n\nIf you have a static background image, you can draw it onto a plain element using the CSS property and position it under the canvas. This will negate the need to render the background to the canvas on every tick.\n\nCSS transforms are faster since they use the GPU. The best case is to not scale the canvas, or have a smaller canvas and scale up rather than a bigger canvas and scale down.\n\nYou may find that canvas items appear blurry on higher-resolution displays. While many solutions may exist, a simple first step is to scale the canvas size up and down simultaneously, using its attributes, styling, and its context's scale. // Get the DPR and size of the canvas const dpr = window.devicePixelRatio; const rect = canvas.getBoundingClientRect(); // Set the \"actual\" size of the canvas canvas.width = rect.width * dpr; canvas.height = rect.height * dpr; // Scale the context to ensure correct drawing operations ctx.scale(dpr, dpr); // Set the \"drawn\" size of the canvas canvas.style.width = `${rect.width}px`; canvas.style.height = `${rect.height}px`;"
    },
    {
        "link": "https://stackoverflow.com/questions/8205828/html5-canvas-performance-and-optimization-tips-tricks-and-coding-best-practices",
        "document": "DO YOU KNOW SOME MORE BEST PRACTICES FOR CANVAS??\n\nPlease add to this thread what you know, have learned, or have read online any and all Canvas best practices, tips/tricks for performance\n\nWith Canvas being still very new to internet, and no signs of it ever getting old that I can see in the future, there are not too many documented \"best practices\" or other really important tips that are a 'must know' for developing with it in any one particular place. Things like this are scattered around and many times on lesser known sites.\n\nThere's so many things that people need to know about, and still so much to learn about too.\n\nI wanted to share some things to help people who are learning Canvas and maybe some who already know it quite well and am hoping to get some feedback from others about what they feel are some best practices or other tips and tricks for working with Canvas in HTML5.\n\nI want to start off with one I personally found to be quite a useful yet surprisingly uncommon thing for developers to do.\n\nJust as you would any other time, in any other language whatever the case may be. It has been a best practice for everything else, and I have come to find that in a complex canvas app, things can get a little confusing when dealing with several different contexts and saved/restore states. Not to mention the code is just more readable and overall cleaner looking too.\n\nIs the IF statement not easier and cleaner to read and know what is what immediately going on than the ELSE statement in this? Can you see what I'm saying here? I think this should be a method that developers should continue to practice just as they would when writing plain 'ol javascript or any other language even.\n\nUse requestAnimationFrame instead of setInterval / setTimeout\n\nsetInterval and setTimeout were never intended to be used as animation timers, they're just generic methods for calling functions after a time delay. If you set an interval for 20ms in the future, but your queue of functions takes longer than that to execute, your timer won't fire until after these functions have completed. That could be a while, which isn't ideal where animation is concerned. RequestAnimationFrame is a method which tells the browser that an animation is taking place, so it can optimize repaints accordingly. It also throttles the animation for inactive tabs, so it won't kill your mobile device's battery if you leave it open in the background.\n\nNicholas Zakas wrote a hugely detailed and informative article about requestAnimationFrame on his blog which is well worth reading. If you want some hard and fast implementation instructions, then Paul Irish has written a requestAnimationFrame shim – this is what I've used in every one of the Canvas apps I have made until recently.\n\nEven better than using requestAnimationFrame in place of setTimeout and setInterval, Joe Lambert has written a NEW and improved shim called requestInterval and requestTimeout, which he explains what issues exist when using requestAnimFrame. You can view the gist of the script.\n\nNow that all the browsers have caught up on the spec for this, there has been an update to the requestAnimFrame() polyfill, one which will probably remain the one to use to cover all vendors.\n\nUse more than one canvas\n\nA technique for animation-heavy games which @nicolahibbert wrote about in a post of hers on optimizing Canvas games mentions that it may be better to use multiple canvasses layered on top of one another rather than do everything in a single canvas. Nicola explains that \"drawing too many pixels to the same canvas at the same time will cause your frame rate to fall through the floor. Take Breakout for example. Trying to draw the bricks, the ball, the paddle, any power-ups or weapons, and then each star in the background – this simply won't work, it takes too long to execute each of these instructions in turn. By splitting the starfield and the rest of the game onto separate canvases, you are able to ensure a decent framerate.\"\n\nI have had to do this for a few apps I've made including Samsung's Olympic Genome Project facebook app. It's an extremely useful thing to know and to make use of whether it's needed or not. It decreases load time immensely, plus it can be a really useful technique to load images off screen since they can sometimes take a while.\n\nNotice that the src of the image is set after it is loaded. This is a key thing to remember to do too. Once the images are done loading and drawn into these temp canvases, you can then draw them to your main canvas by using the same ctx.drawImage(), but instead of putting the image as the first argument, you use 'tmpCtx.canvas' to reference the temp canvas.\n• Some more canvas and JS tests\n\nThe 2d context has a back reference to it's associated DOM element:\n\nI'd love to hear more from other people on this. I am working on making a list of things that we should standardize to add a new section to my company's Front-end Code Standards and Best Practices. I'd love to get as much feedback on this as I can."
    },
    {
        "link": "https://gist.github.com/jaredwilli/5469626",
        "document": "HTML5 canvas Performance and Optimization Tips, Tricks and Coding Best Practices With canvas being still very new to internet, and no signs of it ever getting old that I can see in the future, there are not too many documented best practices or other really important tips that are a must know for developing with it in any one particular place. Things like this are scattered around and many times on lesser known sites.\n\nThere's so many things that people need to know about, and still so much to learn about, so I wanted to share some things to help people who are learning canvas and maybe some who already know it quite well and am hoping to get some feedback from others about what they feel are some best practices or other tips and tricks for working with canvas in HTML5.\n\nI want to start off with one I personally found to be quite a useful yet surprisingly uncommon thing for developers to do. Indent your code Just as you would any other time, in any other language whatever the case may be. It has been a best practice for everything else, and I have come to find that in a complex canvas app, things can get a little confusing when dealing with several different contexts and saved/restore states. Not to mention the code is just more readable and overall cleaner looking too.\n\nThe if statement not easier and cleaner to read and know what is what immediately going on than the else statement in this, is it not? I think this should be a method that developers should continue to practice just as they would when writing plain 'ol javascript or any other language even.\n\nUse requestAnimationFrame instead of setInterval / setTimeout setInterval and setTimeout were never intended to be used as animation timers, they're just generic methods for calling functions after a time delay. If you set an interval for 20ms in the future, but your queue of functions takes longer than that to execute, your timer won't fire until after these functions have completed. That could be a while, which isn't ideal where animation is concerned. RequestAnimationFrame is a method which tells the browser that an animation is taking place, so it can optimize repaints accordingly. It also throttles the animation for inactive tabs, so it won't kill your mobile device's battery if you leave it open in the background.\n\nNicholas Zakas wrote a hugely detailed and informative article about requestAnimationFrame on his blog which is well worth reading. If you want some hard and fast implementation instructions, then Paul Irish has written a requestAnimationFrame shim which I've used in every one of the canvas apps I have made just about.\n\nUpdate: Even better than using requestAnimationFrame in place of setTimeout and setInterval, Joe Lambert has written a new and improved shim called requestInterval and requestTimeout, which he explains what issues exist when using requestAnimFrame. You can view the gist of the script here.\n\nUpdate #2: Now that all the browsers have caught up on the spec for this, there has been an update to the requestAnimFrame polyfill, one which will probably remain the one to use to cover all vendors.\n\nUse more than one canvas This is a technique for animation-heavy games which @nicolahibbert wrote about in a post of hers on optimizing canvas games. She explains how it may be better to use multiple canvases layered on top of one another rather than do everything in a single canvas.\n\n\"Drawing too many pixels to the same canvas at the same time will cause your frame rate to fall through the floor. Take Breakout for example. Trying to draw the bricks, the ball, the paddle, any power-ups or weapons, and then each star in the background – this simply won't work, it takes too long to execute each of these instructions in turn. By splitting the starfield and the rest of the game onto separate canvases, you are able to ensure a decent framerate.\" Nicola says.\n\nRender Elements Off-screen I have had to do this for a few canvas apps I've made including Samsung's Olympic Genome Project facebook app. It's an extremely useful thing to know and to make use of whether it's needed or not. It decreases load time immensely, plus it can be a really useful technique to load images off screen since they can sometimes take a while.\n\nNotice that the src of the image is set after it is loaded. This is a key thing to remember to do too. Once the images are done loading and drawn into these temp canvases, you can then draw them to your main canvas by using the same ctx.drawImage(), but instead of putting the image as the first argument, you use tmpCtx.canvas to reference the temporary canvas.\n\nOther Resources Canvas test cases Some more canvas and JS tests HTML5Rocks Performance Improving requestAnimFrame to Optimize Dragging Events\n\nCanvas Has a Back Reference The 2d Context has a back reference to it's associated DOM element that you can use for quick referencing of the context which is HTMLCanvasElemen.\n\nI would like to get more information on this and other shortcut references that may exist in canvas as well, but this is one that is pretty straightforward I think.\n\nRedraw Regions One of the best canvas optimization techniques for animations is to limit the amount of pixels that get cleared/painted on each frame. The easiest solution to implement is resetting the entire canvas element and drawing everything over again but that is an expensive operation for your browser to process.\n\nThe idea is to reuse as many pixels as possible between frames. What that means is the fewer pixels that need to be processed each frame, the faster your program will run. For example, when erasing pixels with the clearRect(x, y, w, h)method, it is very beneficial to clear and redraw only the pixels that have changed and not the full canvas.\n\nDrawing with Procedural Sprites Generating graphics procedurally is often the way to go, but sometimes that's not the most efficient one. If you're drawing simple shapes with solid fills, then drawing them procedurally is the best way do so. However, if you're drawing more detailed entities with strokes, gradient fills and other performance sensitive make-up you'd be better off using image sprites.\n\nIt is possible to get away with a mix of both. Draw graphical entities procedurally on the canvas once as your application starts up. After that you can reuse the same sprites by painting copies of them instead of generating the same drop-shadow, gradient and strokes repeatedly.\n\nState Stack & Transformation The canvas can be manipulated via transformations such as rotation and scaling, resulting in a change to the canvas coordinate system. This is where it's important to know about the state stack for which two methods are available:\n\ncontext.save() - pushes the current state to the stack context.restore() - reverts to the previous state\n\nThese enable you to apply transformation to a drawing and then restore back to the previous state to make sure the next shape is not affected by any earlier transformation. The states also include properties such as the fill and stroke colors.\n\nCompositing A very powerful tool at hand when working with canvas is compositing modes which, amongst other things, allow for masking and layering. There's a wide array of available composite modes and they are all set through the canvas context's globalCompositeOperation property. The composite modes are also part of the state stack properties, so you can apply a composite operation, stack the state and apply a different one, and restore back to the state before where you made the first one. So it can be especially useful for this reason.\n\nAnti-Aliasing To allow for sub-pixel drawings, all browser implementations of canvas employ anti-aliasing (although this does not seem to be a requirement in the HTML5 spec). Anti-aliasing can be important to keep in mind if you want to draw crisp lines and notice the result looks blurred. This occurs because the browser will interpolate the image as though it was actually between those pixels. It results in a much smoother animation (you can genuinely move at half a pixel per update) but it'll make your images appear fuzzy.\n\nTo work around this you will need to either round to whole integer values or offset by half a pixel depending on if you're drawing fills or strokes.\n\nUsing Whole Numbers for drawImage() x and y Positions If you call drawImage()on the canvas element, it's much faster if you round the x and y position to a whole number.\n\nHere's a test case on jsperf showing how much faster using whole numbers is compared to using decimals. So it is a good idea to round your x and y position to whole numbers before rendering.\n\nFaster than Math.round() Another jsperf test shows that Math.round()is not necessarily the fastest method for rounding numbers. Using a bitwise hack actually turns out to be faster than the built in method.\n\nClearing the canvas To clear the entire canvas of any existing pixels context.clearRect(x, y, w, h) is typically used – but there is another option available. Whenever the width and height of the canvas are set (even if they are set to the same value repeatedly) the canvas is reset. This is good to know when working with a dynamically sized canvas as you will notice drawings disappearing.\n\nComputation Distribution The Chrome Developer Tools profiler is very useful for finding out what your performance bottlenecks are. Depending on your application you may need to refactor some parts of your program to improve the performance and how browsers handle specific parts of your code.\n\nHere's some more tips and suggestions I put into a list worth sharing:\n\nDon't include jQuery unless you need to do more than just selecting the . I've managed to get by without it for almost everything I've made in canvas Create abstracted functions and decouple your code. Separating functionality from appearance or initial draw state as much as possible can be very helpful in the long run and is just good practice in general. Make common functions reusable as much as possible. Ideally, you should use a module pattern or some sort of abstracted API that breaks up code that you can reuse. I like to make a separate object that contains common functions and utilities. Use single and double letter variable names only when it makes sense (x, y, z). The coordinate system in canvas adds more single letters that are commonly declared as variables. Which can lead to creating multiple single/double variables (dX, dY, aX, aY, vX, vY) as part of an element. It’s better to be verbose and type out or at least abbreviate the variable names (dirX, accelX, velX) otherwise things could get pretty confusing for you later on. I’ve seen many people not doing this and it should be reiterated as a best practice. Make constructor functions for generating anything that you will need more than one of. These can be useful for anything, whether you want to make multiples of the same shape, or at a lower level make vectors which add actions or other things to the prototype.\n\nAn example of a constructor I made for creating circles:\n\nThen to create a ball you would do:\n\nA good base to work with is to create 3 functions init() - do all the initial work, and setup the base vars and event handlers etc. draw() - called once to begin the game and draws the first frame of the game, including the creation of elements that may be changing or need constructing. update() - called at the end of draw() and within itself via requestAnimFrame. Updates properties of changing elements, only do what you need to do here. Do the least amount of work within the loop updating and drawing only the changing pixels. Create the game elements and do any other UI work outside the animation loop. The animation loop is often a recursive function, which means it calls itself rapidly and repeatedly during the animation to draw each frame. If there are many elements being animated at once, you might want to first create the elements using a constructor function if you’re not already, and then within the constructor make a timer method that has requestAnimFrame/setTimeout sing it just how you would normally within any animation loop, but effects this element specifically only. Consider adding timer(), draw() and animate() methods on each of your constructors for things that need to animate and for varying amounts of time. Doing this gives you full separation of control for each element and one big animation loop will not be necessary at all since the loop is broken up into each element and you start/stop at will. Alternatively, create a Timer() constructor which you can use and give each animating element individually, thereby minimizing workload within animation loops.\n\nAfter having worked on a large Facebook app which a canvas data-visualization as the primary focus and incorporated each users Facebook profile information (a massive amount of data for some people) to match you (and friends of yours also using the app) to Olympic athletes (a 6 degrees of separation type of thing) there's quite a lot I have learned in my extensive efforts to do everything I could possibly try for increasing performance within the app.\n\nI literally spent months, and days at a time just working to refactor the code which I knew already so well, and believed it to be the most optimal way to do things. As it turned out in the end a valuable lesson I learned brings me to this last thing.\n\nUse DOM Elements Whenever Possible The fact is, browsers are still just not ready to handle more intensive running applications in canvas, especially if you're required to develop the app with support for Internet Explorer 8. There are sometimes cases where the DOM is faster than the current implementation of the canvas API at the time of writing this. At least I've found it to be while working on a massively complex single page animating html5 and canvas application for Samsung.\n\nWe were able to do quite well at improving the performance of things while still using canvas to do some complex work to crop images into circles, which would've probably been ok to stick with how we were doing it.\n\nDays before the launch, we decided to try a different technique, and rather than create temporary canvases off-screen which were placed on the visible canvas once cropped into circles etc., we just appended Image DOM elements on the canvas, using the x and y coordinates that we had been using for placing the temp canvases before.\n\nFor cropping the images into circles, well that was simple, we just used the CSS3 border-radius property to do it which was far less work than the complex series of state changes and while ingenious and creative yet over-use of the clip() method.\n\nOnce they are placed in the DOM, the animation of images the occurs, and the DOM nodes for each image are animated as separate entities of the canvas. Ones that we can have full control over the styling off easily through CSS.\n\nThis technique is similar to another method for doing this type of work that is quite good to know as well, which involves layering canvases on top of each other, rather than draw them to one context."
    },
    {
        "link": "https://stackoverflow.com/questions/63683024/optimise-javascript-canvas-for-mass-drawing-of-tiny-objects",
        "document": "You are very close to the max throughput using the 2D API and a single thread, however there are some minor points that can improve performance.\n\nFirst though, if you are after the best performance possible using javascript you must use WebGL\n\nWith WebGL2 you can draw 8 or more times as many 2D sprites than with the 2D API and have a larger range of FX (eg color, shadow, bump, single call smart tile maps...)\n\nWebGL is VERY worth the effort\n• None is applied every call, values other than 1 do not affect performance.\n• None Avoid the call to The two math calls (including a scale) are a tiny bit quicker than the . eg\n• None Rather than use many images, put all the images in a single image (sprite sheet). Not applicable in this case\n• None Don`t litter the global scope. Keep object close as possible to functions scope and pass object by reference. Access to global scoped variable is MUCH slower the local scoped variables. Best to use modules as they hove their own local scope\n• None Use radians. Converting angles to deg and back is a waste of processing time. Learn to use radians and so on\n• None For positive integers don't use use a bit-wise operator as they automatically convert Doubles to Int32 eg is faster as ( is OR ) Be aware of the Number type in use. Converting to an integer will cost cycles if every time you use it you convert it back to double.\n• None Always Pre-calculate when ever possible. Eg each time you render an image you negate and divide both the width and height. These values can be pre calculated.\n• None Avoid array lookup (indexing). Indexing an object in an array is slower than direct reference. Eg the main loop indexes 11 times. Use a loop so there is only one array lookup per iteration and the counter is a more performant internal counter. (See example)\n• None Though there is a performance penalty for this, if you separate update and render loops on slower rendering devices you will gain performance, by updating game state twice for every rendered frame. eg Slow render device drops to 30FPS and game slows to half speed, if you detect this update state twice, and render once. The game will still present at 30FPS but still play and normal speed (and may even save the occasional drooped frame as you have halved the rendering load) Do not be tempted to use delta time, there are some negative performance overheads (Forces doubles for many values that can be Ints) and will actually reduce animation quality.\n• None When ever possible avoid conditional branching, or use the more performant alternatives. EG in your example you loop object across boundaries using if statements. This can be done using the remainder operator (see example) You check . This is not needed as rotation is cyclic A value of 360 is the same as 44444160. ( is same rotation as )\n\nEach animation call you are preparing a frame for the next (upcoming) display refresh. In your code you are displaying the game state then updating. That means your game state is one frame ahead of what the client sees. Always update state, then display.\n\nThis example has added some additional load to the objects\n• can got in any direction\n• don`t blink in and out at edges.\n\nThe example includes a utility that attempts to balance the frame rate by varying the number of objects.\n\nEvery 15 frames the (work) load is updated. Eventually it will reach a stable rate.\n\nDON`T NOT gauge the performance by running this snippet, SO snippets sits under all the code that runs the page, the code is also modified and monitored (to protect against infinite loops). The code you see is not the code that runs in the snippet. Just moving the mouse can cause dozens of dropped frames in the SO snippet\n\nFor accurate results copy the code and run it alone on a page (remove any extensions that may be on the browser while testing)\n\nUse this or similar to regularly test your code and help you gain experience in knowing what is good and bad for performance.\n• 1 +/- Number Objects added or removed for next period\n• 2 Total number of objects rendered per frame during previous period\n• 3 Number Running mean of render time in ms (this is not frame rate)\n• 4 Number FPS is best mean frame rate.\n• 5 Number Frames dropped during period. A dropped frame is the length of the reported frame rate. I.E. the five drop frames are at 30fps, the total time of dropped frames is"
    },
    {
        "link": "https://blog.ag-grid.com/optimising-html5-canvas-rendering-best-practices-and-techniques",
        "document": "This blog post is based on a talk by Mana Peirov, Senior Engineer for AG Charts:\n\nThe HTML5 Canvas element allows developers to draw 2D shapes, images, and text directly in the browser. At AG Grid, we use the Canvas to render charts in AG Charts, our JavaScript Charting Library. We initially built AG Charts to power the Integrated Charts feature in AG Grid (our React Table library). Given that AG Grid is often used for large (100,000+) data sets, we knew we'd have to build a solution that could handle a large amount of data, without compromising performance.\n\nLike most charting libraries, we faced a choice between SVG and Canvas. We chose Canvas because rendering hundreds of thousands of SVG elements would degrade performance, whereas the Canvas allows for more efficient drawing of shapes and lines. Despite this, Canvas isn't a silver bullet and still comes with its own performance challenges. This blog explores some of the techniques we applied when building AG Charts to get the best performance possible out of the Canvas.\n\nBefore we dive into specific optimizations, let's take a look at how the Canvas works. If you're already familiar with how it works, you can skip this bit.\n\nTo draw on a , you need to access its rendering context. The most common context is 2D ( ), but Canvas also supports WebGL for 3D rendering. We don't use 3D rendering in AG Charts, so this blog is focused on the 2D rendering context.\n\nNext, after accessing the 2D context, you can use various methods to draw shapes, lines, arcs, images and text. For example:\n\nAfter calling these methods to draw on the canvas, you can then manage its state with methods like and which let you save and revert to a previous state. This is useful for handling transformations and styles without affecting subsequent drawings.\n\nFinally, the Canvas also provides methods to help with image manipulation, such as to render and manipulate images, ideal for tasks like cropping, resizing, or applying effects. This will be important later on.\n\nBringing this together, a simple canvas example might look something like this:\n\nwhich would produce an image like this:\n\nIn the real world, Canvas rendering involves lots of repeated calls to methods like , , , and , as well as frequent use of and commands. These commands are simple to use, but when called thousands (or hundreds of thousands) of times per frame, this can significantly impact performance. Given that these methods run on the main thread, any performance issues here are painfully visible to the user and can quickly become a bottleneck as data scales up.\n\nTo put this into context, imagine we want to plot number of data points to create a chart like this:\n\nA simple way to do this is to loop over each data point, figure out its location, and then draw it onto the Canvas:\n\nDoing this means we make number of calls to every Canvas API method, resulting in a linear time complexity (O(n)). In other words, the larger our data set, the slower the rendering will be.\n\nBenchmarking the above example in Chrome results in a rendering time of 287.1ms for 100,000 data points:\n\nThankfully, there are a few things that we can do to help improve this performance...\n\nLet's start with Batch Rendering. Simply put, Batch Rendering is an optimization technique where multiple draw calls or rendering operations are grouped together and executed in a single pass.\n\nUsing the example above, instead of drawing each point separately we can group them all into a single path, and apply and just once, like so:\n\nWhilst the time complexity of this function is still O(n), because we still need to iterate over the entire data array, the majority of our drawing operations, such as , , setting styles, and the final / calls occur outside the loop and are performed once, which takes constant time (O(1)).\n\nThis approach can cut rendering times dramatically. Using our example from earlier, implementing batch rendering alone can reduce rendering time down to just 15.4ms for 100,000 data points:\n\nIt's important to note that, as with most things in software development, Batch Rendering also comes with a downside: Rendering multiple overlapping shapes can result in an unintended \"blob\" effect, as all shapes are treated as one large path:\n\nTo address this, we can use the Offscreen Canvas API...\n\nUnlike the Canvas API, the interface provides a canvas that can be rendered off-screen, decoupling the DOM and the Canvas API so that the element is no longer entirely dependent on the DOM. Rendering operations can also be run inside a worker context, allowing you to run some tasks in a separate thread and avoid heavy work on the main thread.\n\nIn the code above, we're using an offscreen canvas to create a single point (circle), and then use the method to draw it onto the main canvas at various coordinates. Essentially, we're reducing the time complexity of every , , and call to O(1), in favour of O(n) calls to , which is a faster way of rendering content onto the canvas. Additionally, much like we did with batch rendering, we now only need to call and once as well.\n\nWhen applied to our example, this technique reduces the rendering time for 100,000 data points down to 65.7ms:\n\nCrucially, this technique does not have any impact on the quality of the output, albeit at a slight performance cost when compared to Batch Rendering:\n\nIn another blog post, we discussed how we use a tree-based scene graph to optimise the performance of our canvas rendering in AG Charts. In short, our scene graph consists of nodes representing different chart elements, with a base node class that includes properties for positioning, styling, and rendering. Each node type—whether a line, shape, or marker—inherits from this base class and implements its own rendering logic.\n\nWhen it comes to updating the chart elements, the naive approach would be to redraw everything, even the nodes that aren't affected by the change. That means starting at the root node, traversing through the scene graph, top down, re-rendering every group and its children. This involves invoking the canvas render methods and calls to update the state, which can be expensive. To tackle this, we implemented a flag that gets set to true when certain properties change, such as the fill, stroke, size, or position of a marker. This flag percolates up the tree to the parent nodes, meaning the associated parent group can be marked as 'dirty'. Each of these groups acts as a 'layer', which is essentially a graphic element with a . We can then create an Offscreen Canvas for each layer so that it can be rendered independently of other layers. This means that during re-renders, we know which groups are dirty and need to be redrawn, and if they are unchanged, we use the cached bitmap image from the previous render instead. This approach greatly enhances the overall performance of our rendering.\n\nLong story short, when working with the canvas, it's important to minimise the number of redundant drawing operations by tracking state changes and only redrawing what is necessary.\n\nIn the table below, you can clearly see the differences in performance of each approach when drawing 100,000 data points onto the canvas:\n\nWhilst the batched method is by far the fastest, it comes at the cost of reduced quality when compared to Simple / Offscreen rendering:\n\nAs always, there's never a one-size-fits-all solution when it comes to optimisation. It's important to consider your use case and decide where to make the trade-offs, namely in performance vs. quality.\n\nOf course, if you're looking to create beautiful, high-performance charts without doing all this work yourself, you can just use AG Charts instead."
    }
]