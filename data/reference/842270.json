[
    {
        "link": "https://nix.dev/manual/nix/2.17/command-ref/new-cli/nix3-develop",
        "document": "- run a bash shell that provides the build environment of a derivation\n• Start a shell with the build environment of the default package of the flake in the current directory: Typical commands to run inside this shell are: Alternatively, you can run whatever build tools your project uses directly, e.g. for a typical Unix project:\n• Start a shell with the build environment of GNU Hello:\n• Replace all occurrences of the store path corresponding to with a writable directory: Note that this is useful if you're running a shell for in and want to compile another package against it.\n\nstarts a shell that provides an interactive build environment nearly identical to what Nix would use to build installable. Inside this shell, environment variables and shell functions are set up so that you can interactively and incrementally build your package.\n\nNix determines the build environment by building a modified version of the derivation installable that just records the environment initialised by and exits. This build environment can be recorded into a profile using .\n\nThe prompt used by the shell can be customised by setting the , , and settings in or in the flake's attribute.\n\nIf no flake output attribute is given, tries the following flake output attributes:\n\nIf a flake output name is given, tries the following flake output attributes:\n• Instead of starting an interactive shell, start the specified command and arguments.\n• Clear the entire environment (except those specified with ).\n• Keep the environment variable name.\n• The stdenv phase to run (e.g. or ).\n• The profile to operate on.\n• Pass the value expr as the argument name to Nix functions.\n• Pass the string string as the argument name to Nix functions.\n• The URL of the Nix store to use for evaluation, i.e. to store derivations ( files) and inputs referenced by them.\n• Allow access to mutable paths and repositories.\n• Add path to the Nix search path. The Nix search path is initialized from the colon-separated environment variable, and is used to look up the location of Nix expressions using paths enclosed in angle brackets (i.e., ). will cause Nix to look for paths relative to and , in that order. This is equivalent to setting the environment variable to It is also possible to match paths against a prefix. For example, passing will cause Nix to search for in and . If a path in the Nix search path starts with or , it is interpreted as the URL of a tarball that will be downloaded and unpacked to a temporary location. The tarball must consist of a single top-level directory. For example, passing tells Nix to download and use the current contents of the branch in the repository. The URLs of the tarballs from the official channels (see the manual page for ) can be abbreviated as . For instance, the following two flags are equivalent: You can also fetch source trees using flake URLs and add them to the search path. For instance, specifies that the prefix shall refer to the source tree downloaded from the entry in the flake registry. Similarly, makes refer to a particular branch of the repository on GitHub.\n• Commit changes to the flake's lock file.\n• Use the inputs of the specified flake as registry entries.\n• Don't allow lookups in the flake registries. This option is deprecated; use .\n• Do not allow any updates to the flake's lock file.\n• Do not write the flake's newly generated lock file.\n• Write the given lock file instead of within the top-level flake.\n• Read the given lock file instead of within the top-level flake.\n• Update a specific flake input (ignoring its previous entry in the lock file).\n• Set the format of log output; one of , , or .\n• Disable substituters and consider all previously downloaded files up-to-date.\n• Set the Nix configuration setting name to value (overriding ).\n• During evaluation, rewrite missing or corrupted files in the Nix store. During building, rebuild missing or corrupted store paths.\n\nOptions that change the interpretation of installables:\n• Interpret installables as attribute paths relative to the Nix expression expr.\n• Interpret installables as attribute paths relative to the Nix expression stored in file. If file is the character -, then a Nix expression will be read from standard input. Implies .\n• Enable sandboxing, but allow builds to disable it."
    },
    {
        "link": "https://nix.dev/manual/nix/2.24/command-ref/new-cli/nix3-develop",
        "document": "- run a bash shell that provides the build environment of a derivation\n• Start a shell with the build environment of the default package of the flake in the current directory: Typical commands to run inside this shell are: Alternatively, you can run whatever build tools your project uses directly, e.g. for a typical Unix project:\n• Start a shell with the build environment of GNU Hello:\n• Replace all occurrences of the store path corresponding to with a writable directory: Note that this is useful if you're running a shell for in and want to compile another package against it.\n\nstarts a shell that provides an interactive build environment nearly identical to what Nix would use to build installable. Inside this shell, environment variables and shell functions are set up so that you can interactively and incrementally build your package.\n\nNix determines the build environment by building a modified version of the derivation installable that just records the environment initialised by and exits. This build environment can be recorded into a profile using .\n\nThe prompt used by the shell can be customised by setting the , , and settings in or in the flake's attribute.\n\nIf no flake output attribute is given, tries the following flake output attributes:\n\nIf a flake output name is given, tries the following flake output attributes:\n• Instead of starting an interactive shell, start the specified command and arguments.\n• Clear the entire environment (except those specified with ).\n• Keep the environment variable name.\n• The stdenv phase to run (e.g. or ).\n• The profile to operate on.\n• Pass the value expr as the argument name to Nix functions.\n• Pass the contents of file path as the argument name to Nix functions.\n• Pass the contents of stdin as the argument name to Nix functions.\n• Pass the string string as the argument name to Nix functions.\n• The URL of the Nix store to use for evaluation, i.e. to store derivations ( files) and inputs referenced by them.\n• Allow access to mutable paths and repositories.\n• Add path to search path entries used to resolve lookup paths This option may be given multiple times. Paths added through take precedence over the configuration setting and the environment variable.\n• Commit changes to the flake's lock file.\n• Use the inputs of the specified flake as registry entries.\n• Don't allow lookups in the flake registries.\n• Do not allow any updates to the flake's lock file.\n• Do not write the flake's newly generated lock file.\n• Write the given lock file instead of within the top-level flake.\n• Read the given lock file instead of within the top-level flake.\n• Update a specific flake input (ignoring its previous entry in the lock file).\n• Set the format of log output; one of , , or .\n• Disable substituters and consider all previously downloaded files up-to-date.\n• Set the Nix configuration setting name to value (overriding ).\n• During evaluation, rewrite missing or corrupted files in the Nix store. During building, rebuild missing or corrupted store paths.\n\nOptions that change the interpretation of installables\n• Interpret installables as attribute paths relative to the Nix expression expr.\n• Interpret installables as attribute paths relative to the Nix expression stored in file. If file is the character -, then a Nix expression will be read from standard input. Implies ."
    },
    {
        "link": "https://unix.stackexchange.com/questions/784659/how-to-specify-ignore-environment-for-nix-develop-by-configuration",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://nixos.org/nixpkgs/manual",
        "document": ""
    },
    {
        "link": "https://releases.nixos.org/nix/nix-2.19.1/manual/command-ref/new-cli/nix3-develop.html",
        "document": "- run a bash shell that provides the build environment of a derivation\n• Start a shell with the build environment of the default package of the flake in the current directory: Typical commands to run inside this shell are: Alternatively, you can run whatever build tools your project uses directly, e.g. for a typical Unix project:\n• Start a shell with the build environment of GNU Hello:\n• Replace all occurrences of the store path corresponding to with a writable directory: Note that this is useful if you're running a shell for in and want to compile another package against it.\n\nstarts a shell that provides an interactive build environment nearly identical to what Nix would use to build installable. Inside this shell, environment variables and shell functions are set up so that you can interactively and incrementally build your package.\n\nNix determines the build environment by building a modified version of the derivation installable that just records the environment initialised by and exits. This build environment can be recorded into a profile using .\n\nThe prompt used by the shell can be customised by setting the , , and settings in or in the flake's attribute.\n\nIf no flake output attribute is given, tries the following flake output attributes:\n\nIf a flake output name is given, tries the following flake output attributes:\n• Instead of starting an interactive shell, start the specified command and arguments.\n• Clear the entire environment (except those specified with ).\n• Keep the environment variable name.\n• The stdenv phase to run (e.g. or ).\n• The profile to operate on.\n• Pass the value expr as the argument name to Nix functions.\n• Pass the string string as the argument name to Nix functions.\n• The URL of the Nix store to use for evaluation, i.e. to store derivations ( files) and inputs referenced by them.\n• Allow access to mutable paths and repositories.\n• Add path to the Nix search path. The Nix search path is initialized from the colon-separated environment variable, and is used to look up the location of Nix expressions using paths enclosed in angle brackets (i.e., ). will cause Nix to look for paths relative to and , in that order. This is equivalent to setting the environment variable to It is also possible to match paths against a prefix. For example, passing will cause Nix to search for in and . If a path in the Nix search path starts with or , it is interpreted as the URL of a tarball that will be downloaded and unpacked to a temporary location. The tarball must consist of a single top-level directory. For example, passing tells Nix to download and use the current contents of the branch in the repository. The URLs of the tarballs from the official channels (see the manual page for ) can be abbreviated as . For instance, the following two flags are equivalent: You can also fetch source trees using flake URLs and add them to the search path. For instance, specifies that the prefix shall refer to the source tree downloaded from the entry in the flake registry. Similarly, makes refer to a particular branch of the repository on GitHub.\n• Commit changes to the flake's lock file.\n• Use the inputs of the specified flake as registry entries.\n• Don't allow lookups in the flake registries. This option is deprecated; use .\n• Do not allow any updates to the flake's lock file.\n• Do not write the flake's newly generated lock file.\n• Write the given lock file instead of within the top-level flake.\n• Read the given lock file instead of within the top-level flake.\n• Set the format of log output; one of , , or .\n• Disable substituters and consider all previously downloaded files up-to-date.\n• Set the Nix configuration setting name to value (overriding ).\n• During evaluation, rewrite missing or corrupted files in the Nix store. During building, rebuild missing or corrupted store paths.\n\nOptions that change the interpretation of installables\n• Interpret installables as attribute paths relative to the Nix expression expr.\n• Interpret installables as attribute paths relative to the Nix expression stored in file. If file is the character -, then a Nix expression will be read from standard input. Implies ."
    },
    {
        "link": "https://discourse.nixos.org/t/trouble-setting-environment-variables-in-home-manager/43734",
        "document": "I’m trying to set environment variables for home manager. I have this block in home.nix: I saw a post on reddit, suggesting this was zsh/shell related, but I have both zsh (default) and bash enabled both in configuration.nix and home.nix, and neither have the variable set. (Also the auto-generated rc files clearly don’t have the settings, so…) Possibly irrelevant info below:\n\n I don’t want to ask two questions in the same thread, but I’m having a problem of a similar nature, which could be relevant and lead me to discover that the Env variables were not being set. When I try for example I get the long error about setting allowUnfree to true, even though I have done so (packages.nix is imported to home.nix): I have no problem installing unfree software declaratively in a module…just not from a shell apparently, which made me think it could be related. How can I append a path to my PATH with home-manager for new shells using home.sessionPath without needing reboot?\n\nI think this happens because writes variables to , but shells don’t source this by default. However, you can source it with : This is only necessary for bash as zsh re-sources for new instances (see the zsh docs) Alternatively, you can set the variables in the shell config. With this, you don’t have to re-login for changes to take effect. You just have to open a new terminal: On another note, some environment variables can be set by home-manager. For example, the option in the following example will automatically set the env variable to :\n\nAwesome, thank you. I chose the second option for clarity. I was enabling zsh in configuration.nix since it is the default shell, so I just added the variable declarations in home.nix. Is there any point leaving variable declaration in the “home” block still in addition to the programs block? Seems redundant, but then what is its purpose? Much to learn… A note for other noobs, after doing this I needed to log out and log back in. It was not enough to source .zshrc, nor .profile (which actually points to a file in .nix-profile/etc…) I thought it wasn’t working at first. (I probably could have done but I didn’t think to do so.)\n\n# Environment variables . \"/etc/profiles/per-user/user/etc/profile.d/hm-session-vars.sh\" # Only source this once if [[ -z \"$__HM_ZSH_SESS_VARS_SOURCED\" ]]; then export __HM_ZSH_SESS_VARS_SOURCED=1 export EDITOR=\"nano\" fi When I add to then re-build my configs, I see it added to . It’s true that you can’t source again from the same shell session since env variables are only sourced once with . However, if you run a new zsh tab/terminal then it should source it without re-login. Is there any point leaving variable declaration in the “home” block still in addition to the programs block? You can use for variables that all shells will use, then use for zsh-specific ones, etc… A note for other noobs, after doing this I needed to log out and log back in. It was not enough to source .zshrc, nor .profile Actually, where home-manager puts shell variables is different (at least for the version of home-manager I have which is compatible with NixOS 23.11): So for zsh, you don’t have to manually source with , but with bash you have to if you want your shell to read the variables without re-login. Here are some useful links regarding the matter:\n\nI’m grateful for the time you spent writing this. I actually tried to source the hm-session-vars.sh, and profile (same thing really) and it didn’t work until I logged out and in (or launched a new login shell with su -). I had a similar experience installing home manager from the Home Manager Manual. After adding and updating the channel, I needed to log out and in (or su - for a new login shell), in order to run the install command . Also, appreciate the link for Z-Shell"
    },
    {
        "link": "https://reddit.com/r/NixOS/comments/1adfw25/using_the_user_environment_variable_in_nix_flake",
        "document": "Just as the title says, I'm over here wracking my brain trying to figure out how I can use either the environment variable, or a globally defined in a Nix flake, to declare my username globally in my config.\n\nMy flake looks like so (some irrelevant logic omitted for brevity):\n\nThen in any other file, where at the top of the file I would declare something like this:\n\nI would love to be able to add into that, in the sense that I would actually be importing a username defined in my Nix flake. I hope this explanation makes sense.\n\nI woulda thought this was pretty straightforward from some other configs that I saw along the way, but then when examining them more closely, there is some convoluted logic that seems like overkill, so thought I'd ask here, cause I just couldn't wrap my head around what I was seeing.\n\nThanks for any insight anyone can offer.....\n\nEDIT: If it wasn't obvious, the flake does not build, throwing errors of not being able to find/detect/see/locate/etc. pieces of the configuration related to a user."
    },
    {
        "link": "https://discourse.nixos.org/t/problems-with-flake-nix-and-home-manager/26546",
        "document": "I am trying to get my first NixOS build with flakes and Home Manager.\n\nHere is my relevant flake.nix session:\n\nThen my is something like:\n\nand for example :\n\nI am getting the following error:\n\nThis is really cryptic I have no idea what to do. Been watching a bunch of videos, and also going over documentation and topics here; but to no avail."
    },
    {
        "link": "https://jvns.ca/blog/2023/11/11/notes-on-nix-flakes",
        "document": "I’ve been using nix for about 9 months now. For all of that time I’ve been steadfastly ignoring flakes, but everyone keeps saying that flakes are great and the best way to use nix, so I decided to try to figure out what the deal is with them.\n\nI found it very hard to find simple examples of flake files and I ran into a few problems that were very confusing to me, so I wanted to write down some very basic examples and some of the problems I ran into in case it’s helpful to someone else who’s getting started with flakes.\n\nFirst, let’s talk about what a flake is a little.\n\naddition from a couple months later: I still do not actually understand flakes, but a couple of months after I wrote this post, Jade wrote Flakes aren’t real and cannot hurt you: a guide to using Nix flakes the non-flake way which I still haven’t fully processed but is the closest thing I’ve found to an explanation of flakes that I can understand\n\nEvery explanation I’ve found of flakes explains them in terms of other nix concepts (“flakes simplify nix usability”, “flakes are processors of Nix code”). Personally I really needed a way to think about flakes in terms of other non-nix things and someone made an analogy to Docker containers that really helped me, so I’ve been thinking about flakes a little like Docker container images.\n\nHere are some ways in which flakes are like Docker containers:\n• you can install and compile any software you want in them\n• you can use them as a dev environment (the flake sets up all your dependencies)\n• you can share your flake with other people with a file and then they can build the software exactly the same way you built it (a little like how you can share a , though flakes are MUCH better at the “exactly the same way you built it” thing)\n\nflakes are also different from Docker containers in a LOT of ways:\n• with a , you’re not actually guaranteed to get the exact same results as another user. With and you are.\n• they run natively on Mac (you don’t need to use Linux / a Linux VM the way you do with Docker)\n• different flakes can share dependencies very easily (you can technically share layers between Docker images, but flakes are MUCH better at this)\n• flakes can depend on other flakes and pick and choose which parts they want to take from their dependencies\n• files are programs in the nix programming language instead of mostly a bunch of shell commands\n• the way they do isolation is completely different (nix uses dynamic linker/rpath tricks instead of filesystem overlays, and there are no cgroups or namespaces or VMs or anything with nix)\n\nObviously this analogy breaks down pretty quickly (the list of differences is VERY long), but they do share the “you can share a dev environment with a single configuration file” design goal.\n\nTo me one of the biggest advantages of nix is that I’m on a Mac and nix has a repository with a lot of pre-compiled binaries of various packages for Mac. I mostly mention this because people always say that nix is good because it’s “declarative” or “reproducible” or “functional” or whatever but my main motivation for using nix personally is that it has a lot of binary packages. I do appreciate that it makes it easier for me to build a 5-year-old version of hugo on mac though.\n\nMy impression is that nix has more binary packages than Homebrew does, so installing things is faster and I don’t need to build as much from source.\n\nmy goal: make a flake with every package I want installed on my system\n\nPreviously I was using nix as a Homebrew replacement like this (which I talk about more in this blog post):\n\nThis worked great (except that it randomly broke occasionally, but someone helped me find a workaround for that so the random breaking wasn’t a big issue).\n\nI thought it might be fun to have a single file where I could maintain a list of all the packages I wanted installed and then put all that stuff in a directory in my . This isn’t very well motivated: my previous setup was generally working just fine, but I have a long history of fiddling with my computer setup (Arch Linux ftw) and so I decided to have a Day Of Fiddling.\n\nI think the only practical advantages of flakes for me are:\n• I could theoretically use the file to set up a new computer more easily\n• I can never remember how to uninstall software in nix, deleting a line in a configuration file is maybe easier to remember\n\nThese are pretty minor though.\n\nhow do we make a flake?\n\nOkay, so I want to make a flake with a bunch of packages installed in it, let’s say Ruby and cowsay to start. How do I do that? I went to zero-to-nix and copied and pasted some things and ended up with this file (here it is in a gist):\n\nThis has a little bit of boilerplate so let’s list the things I understand about this:\n• is my machine’s architecture, this is important because I’m asking nix to download binaries\n• I’ve been thinking of an “input” as a sort of dependency. is my one input. I get to pick and choose which bits of it I want to bring into my flake though.\n• the url scheme is a bit unusual: the format is . So this is looking at the tag in the repository.\n• is a nix function that’s apparently useful if you want to run . I stopped using it after this so I don’t know more than that.\n• is the name of the output. Apparently I need to give it that exact name or else will yell at me\n• and are the things I’m taking from nixpkgs to put in my output\n• I don’t know what is doing here or what is about\n\nOkay, cool. Let’s try to build it:\n\nThis error is VERY mysterious – what is and why does nix think it should exist???\n\nI was totally stuck until a very nice person on Mastodon helped me. So let’s talk about what’s going wrong here.\n\nApparently nix flakes have some Weird Rules about git. The way it works is:\n• if your current directory isn’t a git repo, everything is fine\n• if your are in a git repository, and all your files have been ed to git, everything is fine\n• but if you’re in a git directory and your file isn’t tracked by git yet (because you just created it and are trying to get it to work), nix will COMPLETELY IGNORE YOUR FILE\n\nAfter someone kindly told me what was happening, I found that this is mentioned in this blog post about flakes, which says:\n\nThere’s also a github issue discussing what to do about this.\n\nSo we need to the file to get nix to pay attention to it. Cool. Let’s keep going.\n\nTo get any of the commands we’re going to talk about to work (like ), you need to enable two nix features:\n\nI set this up by putting in my , but you can also run instead of .\n\nThe instructions I was following told me that I could now run and get a shell inside my new environment. I tried it and it works:\n\nCool! I was curious about how the PATH was set up inside this environment so I took a look:\n\nIt looks like every dependency has been added to the PATH separately: for example there’s for and for . That’s fine but it’s not how I wanted my setup to work: I wanted a single directory of symlinks that I could just put in my PATH in my normal shell.\n\ngetting a directory of symlinks with\n\nI asked in the Nix discord and someone told me I could use to turn my flake into a directory of symlinks. As far as I can tell it’s just a way to take nix packages and copy their symlinks into another directory.\n\nAfter some fiddling, I ended up with this: (here’s a gist)\n\nThis put a bunch of symlinks in :\n\nSweet! Now I have a thing I can theoretically put in my PATH – this directory. Next I mostly just needed to add every other package I wanted to install to this file (I got the list from ).\n\nnext step: add all the packages\n\nI ran into a bunch of weird problems adding all the packges I already had installed to my nix, so let’s talk about them.\n\nI wanted to install a non-free package called . Nix gave me 3 options for how I could do this. Option C seemed the most promising:\n\nBut adding to didn’t do anything for some reason so instead I went with option A, which did seem to work:\n\nI made a couple of flakes for custom Nix packages I’d made (which I wrote about in my first nix blog post, and I wanted to set them up like this (you can see the full configuration here):\n\nThis worked fine the first time I ran , but when I reran again later I got some totally inscrutable error.\n\nMy workaround was just to run everytime before running , which seemed to fix the problem.\n\nI don’t really understand what’s going on here but there’s a very long github issue thread about it.\n\nproblem 4 : “error while reading the response from the build hook”\n\nFor a while, every time I ran , I got this error:\n\nI spent a lot of time poking at my trying to guess at what I could have gone wrong.\n\nA very nice person on Mastodon also helped me with this one and it turned out that what I needed to do was find the process and kill it. I still have no idea what happened here or what that error message means, I did upgrade nix at some point during this whole process so I guess the upgrade went wonky somehow.\n\nI don’t think this one is a common problem.\n\nI wanted to install the package for Java, but when I tried to add it to my list of packages I got this error complaining about a broken symlink:\n\nI think what’s going on here is that the package in was just broken (looks like it’s since been fixed in the unstable version).\n\nI decided I didn’t feel like dealing with that and it turned out I already had Java installed another way outside nix, so I just removed from my list and moved on.\n\nputting it in my PATH\n\nNow that I knew how to fix all of the weird problems I’d run into, I wrote a little shell script called to build my flake and symlink it to the very unimaginitively named . The idea was that then I could put in my and have all my programs available.\n\nI think people usually use nix flakes in a per-project way instead of “a single global flake”, but this is how I wanted my setup to work so that’s what I did.\n\nHere’s the script. The is because of that relative path issue, and the is so I could install ngrok.\n\nI put at the beginning of my (not at the end), but I might revisit that, we’ll see.\n\nAt the end of all this, I wanted to run a garbage collection because I’d installed a bunch of random stuff that was taking about 20GB of extra hard drive space in my . I think there are two different ways to collect garbage in nix:\n\nI have no idea what the difference between them is, but seemed to delete more stuff for some reason.\n\nI wanted to check that my directory was actually a GC root, so that all my stuff wouldn’t get deleted when I ran a GC.\n\nI ran to print out all the GC roots and my was in there so everything was good! This command also runs a GC so it was kind of a dangerous way to check if a GC was going to delete everything, but luckily it worked.\n\nThe last problem I ran into is speed. Previously, installing a new small package took me 2 seconds with :\n\nInstalling the same package with flakes takes 7 seconds, plus the time to edit the config file:\n\nI don’t know what to do about this so I’ll just live with it. We’ll see if this ends up being annoying or not\n\nNow my new nix workflow is:\n• edit my to add or remove packages (this file)\n• rerun my script after editing it\n\nThe last thing I wanted to do was run\n\nso that if I want to ad-hoc run a flake with , it’ll take the version from the 23.05 version of nixpkgs. Mostly I just wanted this so I didn’t have to download new versions of the nixpkgs repository all the time – I just wanted to pin the 23.05 version.\n\nI think is the default which I’m sure is fine too if you want to have more up-to-date software.\n\nmy solutions are probably not the best\n\nMy solutions to all the nix problems I described are maybe not The Best (tm), but I’m happy that I figured out a way to install stuff that just involves one relatively simple file and a 6-line bash script and not a lot of other machinery.\n\nPersonally I still feel extremely uncomfortable with nix and so it’s important to me to keep my configuration as simple as possible without a lot of extra abstraction layers that I don’t understand. I might try out flakey-profile at some point though because it seems extremely simple.\n\nyou can do way fancier stuff\n\nYou can manage a lot more stuff with nix, like:\n• your npm / ruby / python / etc packages (I just do and and )\n\nThere are all kind of tools that build on top of nix and flakes like home-manager. Like I said before though, it’s important to me to keep my configuration super simple so that I can have any hope of understanding how it works and being able to fix problems when it breaks so I haven’t paid attention to any of that stuff.\n\nI’ve been complaining about nix a little in this post, but as usual with open source projects I assume that nix has all of these papercuts because it’s a complicated system run by a small team of volunteers with very limited time.\n\nFolks on the unofficial nix discord have been helpful, I’ve had a somewhat mixed experience there but they have a “support forum” section in there and I’ve gotten answers to a lot of my questions.\n\nthe main resources I’ve found for understanding nix flakes are:\n• Nix Flakes, Part 1: An introduction and tutorial, I think by their creator\n\nAlso Kamal (my partner) uses nix and that really helps, I think using nix with an experienced friend around is a lot easier.\n\nI still kind of like nix after using it for 9 months despite how confused I am about it all the time, I feel like once I get things working they don’t usually break.\n\nWe’ll see if that’s continues to be the case with flakes! Maybe I’ll go back to just using ing everything if it goes badly."
    },
    {
        "link": "https://reddit.com/r/NixOS/comments/1bkgws9/problems_with_flakenix_and_modules_path",
        "document": "I have some trouble setting up my flake.nix config file. The problem is with the path of the properties.\n\nThis is my: https://github.com/cooparo/dotfiles/blob/main/flake.nix\n\nBut when I do this, for me doesn't work\n\nI've tried with the absolute path with the flag, like this\n\nand it works, but obvs I loose all the modularity. I have the same problem with the home.nix file.\n\nThe folder hierarchy setup to me seems right (don't look at the github repo hierarchy, I'm not gonna push some broken code) :\n\nI done some search, but I can't find any docs about it."
    }
]