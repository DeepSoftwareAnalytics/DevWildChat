[
    {
        "link": "https://leetcode.com/problems/card-flipping-game",
        "document": ""
    },
    {
        "link": "https://algo.monster/liteproblems/822",
        "document": "You have a collection of cards, each with a number on the front and back. We call these two numbers \"fronts\" and \"backs\", and they are provided in two arrays where each array is of length . The arrangement is such that corresponds to the number on the front of the i-th card, and corresponds to the number on the back of the i-th card. At the start, all cards are laid out in a way that only the fronts are visible. Your task is to flip over any number of cards such that there's at least one number that appears only on the backs of the cards and not on any front. If such an arrangement is possible, the goal is to make sure the \"good\" number is as small as possible. If you cannot achieve this (i.e., all numbers appear on at least one front), then you return . The problem is challenging because you need to decide which cards to flip (if any) to minimize the \"good\" number that remains hidden on the backside, without it appearing on any visible front at the same time. To solve this problem, the key intuition is to identify numbers that appear on both sides of the same card. These numbers can never be \"good\" numbers, regardless of how we flip the cards, because flipping a card would just move the number from the back to the front. Therefore, we begin by creating a set of all numbers that are present on both the front and back of the same card. None of these numbers can be considered for our \"good\" number. Once we have this set, the next step is to search for the smallest number that is not in this exclusion set . We need to check both the and arrays for potential \"good\" numbers because only flipping cards will reveal some back numbers and hide some front numbers. The function can be used to find the smallest number fulfilling these criteria. We use a generator expression that goes through all the numbers in both and but only yields the ones not in the exclusion set . We use from the module to go through both lists in sequence without having to concatenate them into a new list, which would be less efficient. By specifying , we handle the case where no such \"good\" number exists (if all numbers are in the exclusion set ), and the minimum value can't be found; in that situation, the function will return as required by the problem description.\n\nThe solution approach uses the Python set as a primary data structure and the generator expression for finding the minimum \"good\" number. Firstly, we create a set that consists of all numbers which appear on both sides of the same card. In Python, a set is an unordered collection of distinct hashable objects, and it's specifically designed to quickly check for membership, which is exactly what's needed here. This line uses a set comprehension along with . The function takes two or more sequences (like our and arrays) and creates a new iterator that yields tuples containing elements from each sequence in parallel. The set comprehension then adds the front number to the set only if it matches the corresponding back number , indicating the number is present on both sides of the same card. Next, we need to find the minimum number that's not in the set . To achieve this without creating additional temporary lists, a generator expression coupled with from the module is used. The function allows us to iterate over multiple sequences in a single loop, effectively treating them as one continuous sequence. This is done without the overhead of combining the lists. Here, the generator expression generates numbers from both and , but filters out any number that is found in the set . The function then calculates the minimum of these numbers. The use of is a safety net that specifies what to return if the generator yields no values - which happens if we found all numbers in both and are also in the set . This approach efficiently utilizes memory and only calculates the required minimum, without additional processing of the two lists.\n• A set is used for its fast membership testing to exclude numbers that can't be \"good\".\n• is used to iterate two lists in parallel.\n• seamlessly concatenates our two lists for single-pass processing.\n• finds the smallest \"good\" number, with to handle edge cases where no \"good\" number exists. Using this combination of techniques results in a neat and efficient solution that cleverly avoids the necessity for nested loops or extra data manipulation that could complicate or slow down the algorithm.\n\nLet's say we have the following and arrays for our cards: We are given 5 cards, and the numbers on the fronts and backs of these cards are listed in the arrays. We want to flip some of these cards to meet the condition stated in the problem. Now, we follow the solution approach described:\n• Create the set of numbers that are present on both sides of the same card. Here, the numbers and fit this condition: # Since cards 1 and 3 have the same number on front and back\n• It's clear that neither nor can be our \"good\" number, as they appear on both sides of certain cards.\n• We need to find the smallest number that is not in the set . We will look at both and but only consider the numbers that are not in . # Filtering numbers not in `s` and finding the minimum In this step, are potential \"good\" numbers after filtering out and .\n• Calculate the minimum of these remaining numbers: The minimum \"good\" number here is , which is the smallest number from the potential \"good\" numbers list. Therefore, the smallest \"good\" number that can be achieved by flipping the cards such that it appears only on the backs and not on any front is . This is the final solution for the provided example arrays.\n\n# Create a set of numbers that appear on both sides of the same card # Go through all numbers that appear on either front or back, # and select the smallest one that doesn't appear on both sides of the same card. # If there's no such card, return 0 as the default value. ) // The flipgame function returns the minimum number that is not on both sides of any card. // Set for storing numbers that are the same on both sides of a card. // Store all numbers that are the same on both sides into the set. sameNumbers.add(fronts[i]); } } // The initial answer is set high to ensure any number lower than this will replace it. // Check numbers on the front of the cards. answer = Math.min(answer, front); } } // Check numbers on the back of the cards. answer = Math.min(answer, back); } } // If the answer has not been updated, return 0, otherwise return the answer. } } // Method to find the smallest number that appears on one side of a card but not both. // Stores numbers that appear on both sides of the same card. // Find all the numbers that are the same on both sides of a card and add them to the set. } } // Initialize the answer with a high value. // Check each number on the front. If it is not in the set, it's a candidate for the answer. } } // Check each number on the back. If it is not in the set, it's a candidate for the answer. } } // If the answer remains INT_MAX, all numbers appear on both sides, so return 0. // Otherwise, return the answer, ensuring that if it's equal to 9999 it should return 0. } }; // Create a set to store numbers that are the same on both the front and back of cards. // Identify cards with the same number on both sides and add to the set. identicalNumbers.add(fronts[i]); } } // Initialize the minimum number to a very high value. // Iterate through the front of cards to find the minimum number that isn't the same on both sides. } } // Iterate through the back of cards to find the minimum number that isn't the same on both sides. } } // If the smallest number is less than Number.MAX_SAFE_INTEGER, return it. Otherwise, return 0. // This assumes there's no valid flip game number to be returned if the minimum hasn't changed. }\n\nThe time complexity of the provided code can be analyzed by examining each operation:\n• : This operation goes through the lists and once, creating an iterable comprised of tuples containing corresponding elements from both lists. The time complexity of this operation is , where is the number of cards.\n• : This is a comparison operation inside the set comprehension that is applied to each of the elements, and hence does not add more than a constant factor to the overall time complexity.\n• {a for a, b in zip(fronts, backs) if a == b} : Creating a set of elements where cards show the same number on both sides requires iterating over all pairs and inserting into a set, which is average time complexity for each insertion. Hence, the complexity for this part is .\n• : The function from the module is used to iterate over both and without creating a new list in memory. This operation itself is , but iterating over it will be since the and are both of size .\n• min((x for x in chain(fronts, backs) if x not in s), default=0) : Here, we generate an iterator that filters out all numbers present in set from the chained list of and . The operation in a set is , so this filter operation is . Finding the minimum value is also because, in the worst case, it has to inspect each element of the combined and . Therefore, the overall time complexity is , where is the number of cards. However, we generally consider as because constant factors are dropped in Big O notation. The space complexity can be analyzed similarly:\n• Set : In the worst case, if all cards have the same number on both sides, the set will store every card number, yielding a space complexity of .\n• The operation doesn't consume additional space since it's only combining two iterators, so it does not contribute to space complexity. Consequently, the space complexity of the algorithm is . In summary, the time complexity is and the space complexity is . Learn more about how to find time and space complexity quickly using problem constraints.\n\nDiscover Your Strengths and Weaknesses: Take Our 2-Minute Quiz to Tailor Your Study Plan:\n\nWant a Structured Path to Master System Design Too? Don’t Miss This!"
    },
    {
        "link": "https://stackoverflow.com/questions/78121174/i-was-trying-to-solve-card-flipping-problem-with-randomized-algorithm-but-i-can",
        "document": "Think of this as a network flow problem.\n\nCreate a source & sink node, and a node for each card, and a node for each distinct value on either side of any card (so the set of unique possible values).\n\nCreate an arc with capacity 1 from the source to each card, and an arc with capacity 1 from each card to the two numbers available to it (or the 1 if they're the same), and an arc with capacity 1 from each number-node to the sink.\n\nThen find the max (integer) flow through the graph, say via Ford Fulkerson. The numbers this passes through are one of potentially several valid answers.\n\nIt's not easy to draw a network in text; but if we imagine all the lines as arrows pointing to the right, and the 'X' as a pair of crossing arrows, then this is a representation of the above example:\n\nThen, the max flow is:"
    },
    {
        "link": "https://geeksforgeeks.org/minimum-score-after-flipping-the-cards",
        "document": "Given N cards having positive integers printed on the front and the back of each card (possibly different). Any number of cards can be flipped, and after that we choose one card from the deck. If the number X written on the back of the chosen card is not in the front of any card, then we say number X is good. The task is to find the smallest number that is good. If no number is good, then print 0.\n\nNote: A flip swaps the front and back numbers present on the card i.e. the value on the front is now on the back and vice versa.\n\nInput: fronts = [1, 2, 4, 4, 7, 8], backs = [1, 3, 4, 1, 3, 9] \n\nOutput: 2 If we flip the second card, the fronts are [1, 3, 4, 4, 7, 8] and the backs are [1, 2, 4, 1, 3, 9]. Now, we choose the second card, having number 2 on the back, and it isn’t on the front of any other card, so 2 is good.\n• If a card has the same value K written on the front and the back then K cannot be the answer as no matter how many times you flip the card the result will be the same.\n• Every other card that has different numbers written on the front and backs are candidates for the answer as no matter how many times the number K repeats in the front array, just flip all the cards then there will no longer be a card that has K written on the front then we can simply choose any card (minimum) that has K written on it’s back and it is the answer.\n• Now the problem reduces to finding all the numbers K1, K2, …, Kn such that they are not repeated on any card and then among all the numbers written on the backs of K1, K2, …, Kn find the minimum.\n• If the result is not possible then print 0.\n\nBelow is the implementation of the above approach:"
    },
    {
        "link": "https://codechef.com/practice/course/logical-problems/DIFF800/problems/FLIPCARDS",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/swap-all-odd-and-even-bits",
        "document": "Given an unsigned integer N. The task is to swap all odd bits with adjacent even bits.\n\nNaive Approach: Below is the idea to solve the problem\n\nFollow the steps below to implement the idea:\n• Find the bit at i and i+1 index.\n• To swap the bits subtract and add corresponding values.\n• To remove bit at ith bit to i+1. subtract i_bit<<i and add it at i+1 index for that we need to add i_bit<<(i+1).\n• Similarly subtract (i+1)th bit and add it to ith index.\n\nBelow is the implementation of above approach.\n\nEfficient Approach: Below is the idea to solve the problem.\n\nThe value even_bits obtained by even bits of N and Right shifted (>>) by 1 on even_bits and similarly obtain value odd_bits of odd bits of N and perform left shift (<<) by 1 operation on odd_bits. Now (odd_bits | even_bits) will give the desired value.\n\nFollow the below steps to implement the approach:\n• Initialize variable even_bits with bitwise and of N with 0xAAAAAAAA(32 bit number with all even bits set as 1 and all odd bits as 0).\n• Initialize variable odd_bits with bitwise and of N with 0x55555555. The number 0x55555555 is a 32 bit number with all odd bits set as 1 and all even bits as 0.\n• Right shift even_bits by 1 and Left shift odd_bits by 1.\n• Return or of even_bits with odd_bits .\n\nBelow is the Implementation of above approach."
    },
    {
        "link": "https://stackoverflow.com/questions/28645145/move-odd-and-even-numbers-in-list-to-odd-and-even-positions",
        "document": "I have a list with an equal number of odd and even integers. The goal is to modify the list to have odd integers at odd indices and even integers at the even indices.\n\nHere is my approach:\n\nI find out the numbers at even indexes and odd indexes. Then find out odd numbers at even indexes and even numbers at odd indexes. Finally swap the misplaced numbers.\n\nI am not very happy with the solution though it works. Is there any better efficient solution to my problem? My aim was to make like possibly sorted in the same odd-even format."
    },
    {
        "link": "https://stackoverflow.com/questions/74367322/python-program-to-make-a-list-even-odd-parity",
        "document": "This seems like more of a math/logic problem than a Python problem.\n\nTo make a list's elements alternate between odd and even, either all the elements at even indices should be even and the rest odd, or all the elements at even indices should be odd and the rest even.\n\nIt appears you're not looking to change the order of elements, but to add or subtract one to make them comply.\n\nSo, to make the list comply, either you need to change all even elements at odd indices and all odd elements at even indices, or vice versa.\n\nThe solution adds each element to its index, and then takes the mod 2 of it, so that each element becomes either 1 if the index or the value is odd, or 0 if both are odd, or both are even. As a result, the sum of those 1's will be the number of elements that need to be changed - but if that number is more than half, you could just change the rest of the elements instead, which is what the last lines decides.\n\nEdit: From your comment it became clear that operations allowed are limited and the only operation allowed is . This complicates the issue because this operation only results in an even outcome for every other two numbers. The pattern looks like this:\n\nSo, each 4th number will be both odd, and its will also be odd. If you apply the operation again, only half of those results will be even, etc.\n\nAnother way to look at the problem then: if a number's binary representation ends in a , it is even. If you take the of a number, you're really just performing a \"shift right\" operation. So, if an number's binary representation has a as the second least significant bit, performing the operation will make it even. And so on.\n\nSo, a solution using only that operation:\n\nOr, if you don't like building a whole new list and want the solution to save space:"
    },
    {
        "link": "https://programiz.com/python-programming/examples/reverse-a-number",
        "document": "Example 1: Reverse a Number using a while loop\n\nIn this program, while loop is used to reverse a number as given in the following steps:\n• First, the remainder of the divided by 10 is stored in the variable . Now, the contains the last digit of , i.e. 4.\n\n is then added to the variable reversed after multiplying it by 10. Multiplication by 10 adds a new place in the reversed number. One-th place multiplied by 10 gives you tenth place, tenth gives you hundredth, and so on. In this case, contains .\n\n is then divided by 10 so that now it only contains the first three digits: 123.\n• After second iteration, equals 3, reversed equals and .\n• After third iteration, equals 2, reversed equals and .\n• Now , so the test expression fails and while loop exits. reversed already contains the reversed number 4321.\n\nUsing the string slicing concept, you can get reverse the string. corresponds to . When you pass -1 as , the point goes to the end and at the front.\n• Python Program to Check Whether a String is Palindrome or Not"
    },
    {
        "link": "https://realpython.com/python-bitwise-operators",
        "document": "Computers store all kinds of information as a stream of binary digits called bits. Whether you’re working with text, images, or videos, they all boil down to ones and zeros. Python’s bitwise operators let you manipulate those individual bits of data at the most granular level.\n\nYou can use bitwise operators to implement algorithms such as compression, encryption, and error detection as well as to control physical devices in your Raspberry Pi project or elsewhere. Often, Python isolates you from the underlying bits with high-level abstractions. You’re more likely to find the overloaded flavors of bitwise operators in practice. But when you work with them in their original form, you’ll be surprised by their quirks!\n\nIn this tutorial, you’ll learn how to:\n• Read and write binary data in a platform-agnostic way\n• Use bitmasks to pack information on a single byte\n\nTo get the complete source code of the digital watermarking example, and to extract a secret treat hidden in an image, click the link below:\n\nBefore moving on, take a moment to brush up your knowledge of the binary system, which is essential to understanding bitwise operators. If you’re already comfortable with it, then go ahead and jump to the Bitwise Logical Operators section below. There are an infinite number of ways to represent numbers. Since ancient times, people have developed different notations, such as Roman numerals and Egyptian hieroglyphs. Most modern civilizations use positional notation, which is efficient, flexible, and well suited for doing arithmetic. A notable feature of any positional system is its base, which represents the number of digits available. People naturally favor the base-ten numeral system, also known as the decimal system, because it plays nicely with counting on fingers. Computers, on the other hand, treat data as a bunch of numbers expressed in the base-two numeral system, more commonly known as the binary system. Such numbers are composed of only two digits, zero and one. Note: In math books, the base of a numeric literal is commonly denoted with a subscript that appears slightly below the baseline, such as 42 . For example, the binary number 10011100 is equivalent to 156 in the base-ten system. Because there are ten numerals in the decimal system—zero through nine—it usually takes fewer digits to write the same number in base ten than in base two. Note: You can’t tell a numeral system just by looking at a given number’s digits. For example, the decimal number 101 happens to use only binary digits. But it represents a completely different value than its binary counterpart, 101 , which is equivalent to 5 . The binary system requires more storage space than the decimal system but is much less complicated to implement in hardware. While you need more building blocks, they’re easier to make, and there are fewer types of them. That’s like breaking down your code into more modular and reusable pieces. More importantly, however, the binary system is perfect for electronic devices, which translate digits into different voltage levels. Because voltage likes to drift up and down due to various kinds of noise, you want to keep sufficient distance between consecutive voltages. Otherwise, the signal might end up distorted. By employing only two states, you make the system more reliable and resistant to noise. Alternatively, you could jack up the voltage, but that would also increase the power consumption, which you definitely want to avoid. Imagine for a moment that you had only two fingers to count on. You could count a zero, a one, and a two. But when you ran out of fingers, you’d need to note how many times you had already counted to two and then start over until you reached two again: Every time you wrote down another pair of fingers, you’d also need to group them by powers of two, which is the base of the system. For example, to count up to thirteen, you would have to use both of your fingers six times and then use one more finger. Your fingers could be arranged as one eight, one four, and one one. These powers of two correspond to digit positions in a binary number and tell you exactly which bits to switch on. They grow right to left, starting at the least-significant bit, which determines if the number is even or odd. Positional notation is like the odometer in your car: Once a digit in a particular position reaches its maximum value, which is one in the binary system, it rolls over to zero and the one carries over to the left. This can have a cascading effect if there are already some ones to the left of the digit. Now that you know the basic principles of the binary system and why computers use it, you’re ready to learn how they represent data with it. Before any piece of information can be reproduced in digital form, you have to break it down into numbers and then convert them to the binary system. For example, plain text can be thought of as a string of characters. You could assign an arbitrary number to each character or pick an existing character encoding such as ASCII, ISO-8859-1, or UTF-8. In Python, strings are represented as arrays of Unicode code points. To reveal their ordinal values, call on each of the characters: The resulting numbers uniquely identify the text characters within the Unicode space, but they’re shown in decimal form. You want to rewrite them using binary digits: Notice that bit-length, which is the number of binary digits, varies greatly across the characters. The euro sign ( ) requires fourteen bits, while the rest of the characters can comfortably fit on seven bits. Note: Here’s how you can check the bit-length of any integer number in Python: Without a pair of parentheses around the number, it would be treated as a floating-point literal with a decimal point. Variable bit-lengths are problematic. If you were to put those binary numbers next to one another on an optical disc, for example, then you’d end up with a long stream of bits without clear boundaries between the characters: One way of knowing how to interpret this information is to designate fixed-length bit patterns for all characters. In modern computing, the smallest unit of information, called an octet or a byte, comprises eight bits that can store 256 distinct values. You can pad your binary code points with leading zeros to express them in terms of bytes: Now each character takes two bytes, or 16 bits. In total, your original text almost doubled in size, but at least it’s encoded reliably. You can use Huffman coding to find unambiguous bit patterns for every character in a particular text or use a more suitable character encoding. For example, to save space, UTF-8 intentionally favors Latin letters over symbols that you’re less likely to find in an English text: Encoded according to the UTF-8 standard, the entire text takes six bytes. Since UTF-8 is a superset of ASCII, the letters , , and occupy one byte each, whereas the euro symbol takes three bytes in this encoding: Other types of information can be digitized similarly to text. Raster images are made of pixels, with every pixel having channels that represent color intensities as numbers. Sound waveforms contain numbers corresponding to air pressure at a given sampling interval. Three-dimensional models are built from geometric shapes defined by their vertices, and so forth. At the end of the day, everything is a number.\n\nYou can use bitwise operators to perform Boolean logic on individual bits. That’s analogous to using logical operators such as , , and , but on a bit level. The similarities between bitwise and logical operators go beyond that. It’s possible to evaluate Boolean expressions with bitwise operators instead of logical operators, but such overuse is generally discouraged. If you’re interested in the details, then you can expand the box below to find out more. The ordinary way of specifying compound Boolean expressions in Python is to use the logical operators that connect adjacent predicates, like this: Here, you check if the user is at least eighteen years old and if they haven’t opted out of gambling. You can rewrite that condition using bitwise operators: Although this expression is syntactically correct, there are a few problems with it. First, it’s arguably less readable. Second, it doesn’t work as expected for all groups of data. You can demonstrate that by choosing specific operand values: The expression made of the bitwise operators evaluates to , while the same expression built from the logical operators evaluates to . That’s because bitwise operators take precedence over the comparison operators, changing how the whole expression is interpreted: It’s as if someone put implicit parentheses around the wrong operands. To fix this, you can put explicit parentheses, which will enforce the correct order of evaluation: However, you no longer get a Boolean result. Python bitwise operators were designed primarily to work with integers, so their operands automatically get casted if needed. This may not always be possible, though. While you can use truthy and falsy integers in a Boolean context, it’s a known antipattern that can cost you long hours of unnecessary debugging. You’re better off following the Zen of Python to save yourself the trouble. Last but not least, you may deliberately want to use bitwise operators to disable the short-circuit evaluation of Boolean expressions. Expressions using logical operators are evaluated lazily from left to right. In other words, the evaluation stops as soon as the result of the entire expression is known: In the second example, the right operand isn’t called at all because the value of the entire expression has already been determined by the value of the left operand. No matter what the right operand is, it won’t affect the result, so there’s no point in calling it unless you rely on side effects. There are idioms, such as falling back to a default value, that take advantage of this peculiarity: A Boolean expression takes the value of the last evaluated operand. The operand becomes truthy or falsy inside the expression but retains its original type and value afterward. In particular, a positive integer on the left gets propagated, while a zero gets discarded. Even though knowing the left operand is sufficient to determine the value of the entire expression, all operands are always evaluated unconditionally. Unless you have a strong reason and know what you’re doing, you should use bitwise operators only for controlling bits. It’s too easy to get it wrong otherwise. In most cases, you’ll want to pass integers as arguments to the bitwise operators. The bitwise AND operator ( ) performs logical conjunction on the corresponding bits of its operands. For each pair of bits occupying the same position in the two numbers, it returns a one only when both bits are switched on: The resulting bit pattern is an intersection of the operator’s arguments. It has two bits turned on in the positions where both operands are ones. In all other places, at least one of the inputs has a zero bit. Arithmetically, this is equivalent to a product of two bit values. You can calculate the bitwise AND of numbers a and b by multiplying their bits at every index i: A one multiplied by one gives one, but anything multiplied by zero will always result in zero. Alternatively, you can take the minimum of the two bits in each pair. Notice that when operands have unequal bit-lengths, the shorter one is automatically padded with zeros to the left. The bitwise OR operator ( ) performs logical disjunction. For each corresponding pair of bits, it returns a one if at least one of them is switched on: The resulting bit pattern is a union of the operator’s arguments. It has five bits turned on where either of the operands has a one. Only a combination of two zeros gives a zero in the final output. The arithmetic behind it is a combination of a sum and a product of the bit values. To calculate the bitwise OR of numbers a and b, you need to apply the following formula to their bits at every index i: It’s almost like a sum of two bits but clamped at the higher end so that it never exceeds the value of one. You could also take the maximum of the two bits in each pair to get the same result. Unlike bitwise AND, OR, and NOT, the bitwise XOR operator ( ) doesn’t have a logical counterpart in Python. However, you can simulate it by building on top of the existing operators: It evaluates two mutually exclusive conditions and tells you whether exactly one of them is met. For example, a person can be either a minor or an adult, but not both at the same time. Conversely, it’s not possible for a person to be neither a minor nor an adult. The choice is mandatory. The name XOR stands for “exclusive or” since it performs exclusive disjunction on the bit pairs. In other words, every bit pair must contain opposing bit values to produce a one: Visually, it’s a symmetric difference of the operator’s arguments. There are three bits switched on in the result where both numbers have different bit values. Bits in the remaining positions cancel out because they’re the same. Similarly to the bitwise OR operator, the arithmetic of XOR involves a sum. However, while the bitwise OR clamps values at one, the XOR operator wraps them around with a sum modulo two: Modulo is a function of two numbers—the dividend and the divisor—that performs a division and returns its remainder. In Python, there’s a built-in modulo operator denoted with the percent sign ( ). Once again, you can confirm the formula by looking at an example: The sum of two zeros or two ones yields a whole number when divided by two, so the result has a remainder of zero. However, when you divide the sum of two different bit values by two, you get a fraction with a remainder of one. A more straightforward formula for the XOR operator is the difference between the maximum and the minimum of both bits in each pair. The last of the bitwise logical operators is the bitwise NOT operator ( ), which expects just one argument, making it the only unary bitwise operator. It performs logical negation on a given number by flipping all of its bits: The inverted bits are a complement to one, which turns zeros into ones and ones into zeros. It can be expressed arithmetically as the subtraction of individual bit values from one: Here’s an example showing one of the numbers used before: While the bitwise NOT operator seems to be the most straightforward of them all, you need to exercise extreme caution when using it in Python. Everything you’ve read so far is based on the assumption that numbers are represented with unsigned integers. Note: Unsigned data types don’t let you store negative numbers such as -273 because there’s no space for a sign in a regular bit pattern. Trying to do so would result in a compilation error, a runtime exception, or an integer overflow depending on the language used. Although there are ways to simulate unsigned integers, Python doesn’t support them natively. That means all numbers have an implicit sign attached to them whether you specify one or not. This shows when you do a bitwise NOT of any number: Instead of the expected 99 , you get a negative value! The reason for this will become clear once you learn about the various binary number representations. For now, the quick-fix solution is to take advantage of the bitwise AND operator: That’s a perfect example of a bitmask, which you’ll explore in one of the upcoming sections.\n\nBitwise shift operators are another kind of tool for bit manipulation. They let you move the bits around, which will be handy for creating bitmasks later on. In the past, they were often used to improve the speed of certain mathematical operations. The bitwise left shift operator ( ) moves the bits of its first operand to the left by the number of places specified in its second operand. It also takes care of inserting enough zero bits to fill the gap that arises on the right edge of the new bit pattern: Shifting a single bit to the left by one place doubles its value. For example, instead of a two, the bit will indicate a four after the shift. Moving it two places to the left will quadruple the resulting value. When you add up all the bits in a given number, you’ll notice that it also gets doubled with every place shifted: In general, shifting bits to the left corresponds to multiplying the number by a power of two, with an exponent equal to the number of places shifted: The left shift used to be a popular optimization technique because bit shifting is a single instruction and is cheaper to calculate than exponent or product. Today, however, compilers and interpreters, including Python’s, are quite capable of optimizing your code behind the scenes. Note: Don’t use the bit shift operators as a means of premature optimization in Python. You won’t see a difference in execution speed, but you’ll most definitely make your code less readable. On paper, the bit pattern resulting from a left shift becomes longer by as many places as you shift it. That’s also true for Python in general because of how it handles integers. However, in most practical cases, you’ll want to constrain the length of a bit pattern to be a multiple of eight, which is the standard byte length. For example, if you’re working with a single byte, then shifting it to the left should discard all the bits that go beyond its left boundary: It’s sort of like looking at an unbounded stream of bits through a fixed-length window. There are a few tricks that let you do this in Python. For example, you can apply a bitmask with the bitwise AND operator: Shifting 39 by three places to the left returns a number higher than the maximum value that you can store on a single byte. It takes nine bits, whereas a byte has only eight. To chop off that one extra bit on the left, you can apply a bitmask with the appropriate value. If you’d like to keep more or fewer bits, then you’ll need to modify the mask value accordingly. The bitwise right shift operator ( ) is analogous to the left one, but instead of moving bits to the left, it pushes them to the right by the specified number of places. The rightmost bits always get dropped: Every time you shift a bit to the right by one position, you halve its underlying value. Moving the same bit by two places to the right produces a quarter of the original value, and so on. When you add up all the individual bits, you’ll see that the same rule applies to the number they represent: Halving an odd number such as 157 would produce a fraction. To get rid of it, the right shift operator automatically floors the result. It’s virtually the same as a floor division by a power of two: Again, the exponent corresponds to the number of places shifted to the right. In Python, you can leverage a dedicated operator to perform a floor division: The bitwise right shift operator and the floor division operator both work the same way, even for negative numbers. However, the floor division lets you choose any divisor and not just a power of two. Using the bitwise right shift was a common way of improving the performance of some arithmetic divisions. Note: You might be wondering what happens when you run out of bits to shift. For example, when you try pushing by more places than there are bits in a number: Once there are no more bits switched on, you’re stuck with a value of zero. Zero divided by anything will always return zero. However, things get trickier when you right shift a negative number because the implicit sign bit gets in the way: The rule of thumb is that, regardless of the sign, the result will be the same as a floor division by some power of two. The floor of a small negative fraction is always minus one, and that’s what you’ll get. Read on for a more detailed explanation. Just like with the left shift operator, the bit pattern changes its size after a right shift. While moving bits to the right makes the binary sequence shorter, it usually won’t matter because you can put as many zeros in front of a bit sequence as you like without changing the value. For example, 101 is the same as 0101 , and so is 00000101 , provided that you’re dealing with nonnegative numbers. Sometimes you’ll want to keep a given bit-length after doing a right shift to align it against another value or to fit in somewhere. You can do that by applying a bitmask: It carves out only those bits you’re interested in and fills the bit pattern with leading zeros if necessary. The handling of negative numbers in Python is slightly different from the traditional approach to bitwise shifting. In the next section, you’ll examine this in more detail. You can further categorize the bitwise shift operators as arithmetic and logical shift operators. While Python only lets you do the arithmetic shift, it’s worthwhile to know how other programming languages implement the bitwise shift operators to avoid confusion and surprises. This distinction comes from the way they handle the sign bit, which ordinarily lies at the far left edge of a signed binary sequence. In practice, it’s relevant only to the right shift operator, which can cause a number to flip its sign, leading to integer overflow. Note: Java and JavaScript, for example, distinguish the logical right shift operator with an additional greater-than sign ( ). Since the left shift operator behaves consistently across both kinds of shifts, these languages don’t define a logical left shift counterpart. Conventionally, a turned-on sign bit indicates negative numbers, which helps keep the arithmetic properties of a binary sequence: Looking from the left at these two binary sequences, you can see that their first bit carries the sign information, while the remaining part consists of the magnitude bits, which are the same for both numbers. Note: The specific decimal values will depend on how you decide to express signed numbers in binary. It varies between languages and gets even more complicated in Python, so you can ignore it for the moment. You’ll have a better picture once you get to the binary number representations section below. A logical right shift, also known as an unsigned right shift or a zero-fill right shift, moves the entire binary sequence, including the sign bit, and fills the resulting gap on the left with zeros: Notice how the information about the sign of the number is lost. Regardless of the original sign, it’ll always produce a nonnegative integer because the sign bit gets replaced by zero. As long as you aren’t interested in the numeric values, a logical right shift can be useful in processing low-level binary data. However, because signed binary numbers are typically stored on a fixed-length bit sequence in most languages, it can make the result wrap around the extreme values. You can see this in an interactive Java Shell tool: The resulting number changes its sign from negative to positive, but it also overflows, ending up very close to Java’s maximum integer: This number may seem arbitrary at first glance, but it’s directly related to the number of bits that Java allocates for the data type: It uses 32 bits to store signed integers in two’s complement representation. When you take the sign bit out, you’re left with 31 bits, whose maximum decimal value is equal to 231 - 1, or 2147483647 . Python, on the other hand, stores integers as if there were an infinite number of bits at your disposal. Consequently, a logical right shift operator wouldn’t be well defined in pure Python, so it’s missing from the language. You can still simulate it, though. One way of doing so is to take advantage of the unsigned data types available in C that are exposed through the built-in module: They let you pass in a negative number but don’t attach any special meaning to the sign bit. It’s treated like the rest of the magnitude bits. While there are only a few predefined unsigned integer types in C, which differ in bit-length, you can create a custom function in Python to handle arbitrary bit-lengths: This converts a signed bit sequence to an unsigned one and then performs the regular arithmetic right shift. However, since bit sequences in Python aren’t fixed in length, they don’t really have a sign bit. Moreover, they don’t use the traditional two’s complement representation like in C or Java. To mitigate that, you can take advantage of the modulo operation, which will keep the original bit patterns for positive integers while appropriately wrapping around the negative ones. An arithmetic right shift ( ), sometimes called the signed right shift operator, maintains the sign of a number by replicating its sign bit before moving bits to the right: In other words, it fills the gap on the left with whatever the sign bit was. Combined with the two’s complement representation of signed binary, this results in an arithmetically correct value. Regardless of whether the number is positive or negative, an arithmetic right shift is equivalent to floor division. As you’re about to find out, Python doesn’t always store integers in plain two’s complement binary. Instead, it follows a custom adaptive strategy that works like sign-magnitude with an unlimited number of bits. It converts numbers back and forth between their internal representation and two’s complement to mimic the standard behavior of the arithmetic shift.\n\nYou’ve experienced firsthand the lack of unsigned data types in Python when using the bitwise negation ( ) and the right shift operator ( ). You’ve seen hints about the unusual approach to storing integers in Python, which makes handling negative numbers tricky. To use bitwise operators effectively, you need to know about the various representations of numbers in binary. In programming languages like C, you choose whether to use the signed or unsigned flavor of a given numeric type. Unsigned data types are more suitable when you know for sure that you’ll never need to deal with negative numbers. By allocating that one extra bit, which would otherwise serve as a sign bit, you practically double the range of available values. It also makes things a little safer by increasing the maximum limit before an overflow happens. However, overflows happen only with fixed bit-lengths, so they’re irrelevant to Python, which doesn’t have such constraints. The quickest way to get a taste of the unsigned numeric types in Python is to use the previously mentioned module: Since there’s no sign bit in such integers, all their bits represent the magnitude of a number. Passing a negative number forces Python to reinterpret the bit pattern as if it had only the magnitude bits. The sign of a number has only two states. If you ignore zero for a moment, then it can be either positive or negative, which translates nicely to the binary system. Yet there are a few alternative ways to represent signed integers in binary, each with its own pros and cons. Probably the most straightforward one is the sign-magnitude, which builds naturally on top of unsigned integers. When a binary sequence is interpreted as sign-magnitude, the most significant bit plays the role of a sign bit, while the rest of the bits work the same as usual: A zero on the leftmost bit indicates a positive ( ) number, and a one indicates a negative ( ) number. Notice that a sign bit doesn’t contribute to the number’s absolute value in sign-magnitude representation. It’s there only to let you flip the sign of the remaining bits. It keeps bit indexing intact, which, in turn, helps maintain backward compatibility of the bit weights used to calculate the decimal value of a binary sequence. However, not everything about sign-magnitude is so great. Note: Binary representations of signed integers only make sense on fixed-length bit sequences. Otherwise, you couldn’t tell where the sign bit was. In Python, however, you can represent integers with as many bits as you like: Whether it’s four bits or eight, the sign bit will always be found in the leftmost position. The range of values that you can store in a sign-magnitude bit pattern is symmetrical. But it also means that you end up with two ways to convey zero: Zero doesn’t technically have a sign, but there’s no way not to include one in sign-magnitude. While having an ambiguous zero isn’t ideal in most cases, it’s not the worst part of the story. The biggest downside of this method is cumbersome binary arithmetic. When you apply standard binary arithmetic to numbers stored in sign-magnitude, it may not give you the expected results. For example, adding two numbers with the same magnitude but opposite signs won’t make them cancel out: The sum of 42 and -42 doesn’t produce zero. Also, the carryover bit can sometimes propagate from magnitude to the sign bit, inverting the sign and yielding an unexpected result. To address these problems, some of the early computers employed one’s complement representation. The idea was to change how decimal numbers are mapped to particular binary sequences so that they can be added up correctly. For a deeper dive into one’s complement, you can expand the section below. In one’s complement, positive numbers are the same as in sign-magnitude, but negative numbers are obtained by flipping the positive number’s bits using a bitwise NOT: This preserves the original meaning of the sign bit, so positive numbers still begin with a binary zero, while negative ones start with a binary one. Likewise, the range of values remains symmetrical and continues to have two ways to represent zero. However, the binary sequences of negative numbers in one’s complement are arranged in reverse order as compared to sign-magnitude: Thanks to that, you can now add two numbers more reliably because the sign bit doesn’t need special treatment. If a carryover originates from the sign bit, it’s fed back at the right edge of the binary sequence instead of just being dropped. This ensures the correct result. Nevertheless, modern computers don’t use one’s complement to represent integers because there’s an even better way called two’s complement. By applying a small modification, you can eliminate double zero and simplify the binary arithmetic in one go. To explore two’s complement in more detail, you can expand the section below. When finding bit sequences of negative values in two’s complement, the trick is to add one to the result after negating the bits: This pushes the bit sequences of negative numbers down by one place, eliminating the notorious minus zero. A more useful minus one will take over its bit pattern instead. As a side effect, the range of available values in two’s complement becomes asymmetrical, with a lower bound that’s a power of two and an odd upper bound. For example, an 8-bit signed integer will let you store numbers from -128 to 127 in two’s complement: Another way to put it is that the most significant bit carries both the sign and part of the number magnitude: Notice the minus sign next to the leftmost bit weight. Deriving a decimal value from a binary sequence like that is only a matter of adding appropriate columns. For example, the value of 11010110 in 8-bit two’s complement representation is the same as the sum: -128 + 64 + 16 + 4 + 2 = -42 . With the two’s complement representation, you no longer need to worry about the carryover bit unless you want to use it as an overflow detection mechanism, which is kind of neat. There are a few other variants of signed number representations, but they’re not as popular. The IEEE 754 standard defines a binary representation for real numbers consisting of the sign, exponent, and mantissa bits. Without getting into too many technical details, you can think of it as the scientific notation for binary numbers. The decimal point “floats” around to accommodate a varying number of significant figures, except it’s a binary point. Two data types conforming to that standard are widely supported: Python’s data type is equivalent to the double-precision type. Note that some applications require more or fewer bits. For example, the OpenEXR image format takes advantage of half precision to represent pixels with a high dynamic range of colors at a reasonable file size. The number Pi (π) has the following binary representation in single precision when rounded to five decimal places: The sign bit works just like with integers, so zero denotes a positive number. For the exponent and mantissa, however, different rules can apply depending on a few edge cases. First, you need to convert them from binary to the decimal form: The exponent is stored as an unsigned integer, but to account for negative values, it usually has a bias equal to 127 in single precision. You need to subtract it to recover the actual exponent. Mantissa bits represent a fraction, so they correspond to negative powers of two. Additionally, you need to add one to the mantissa because it assumes an implicit leading bit before the radix point in this particular case. Putting it all together, you arrive at the following formula to convert a floating-point binary number into a decimal one: When you substitute the variables for the actual values in the example above, you’ll be able to decipher the bit pattern of a floating-point number stored in single precision: There it is, granted that Pi has been rounded to five decimal places. You’ll learn how to display such numbers in binary later on. While floating-point numbers are a good fit for engineering purposes, they fail in monetary calculations due to their limited precision. For example, some numbers with a finite representation in decimal notation have only an infinite representation in binary. That often results in a rounding error, which can accumulate over time: In such cases, you’re better off using Python’s module, which implements fixed-point arithmetic and lets you specify where to put the decimal point on a given bit-length. For example, you can tell it how many digits you want to preserve: However, it includes all digits, not just the fractional ones. Note: If you’re working with rational numbers, then you might be interested in checking out the module, which is part of Python’s standard library. If you can’t or don’t want to use a fixed-point data type, a straightforward way to reliably store currency values is to scale the amounts to the smallest unit, such as cents, and represent them with integers.\n\nIn the old days of programming, computer memory was at a premium. Therefore, languages would give you pretty granular control over how many bytes to allocate for your data. Let’s take a quick peek at a few integer types from C as an example: These values might vary from platform to platform. However, such an abundance of numeric types allows you to arrange data in memory compactly. Remember that these don’t even include unsigned types! On the other end of the spectrum are languages such as JavaScript, which have just one numeric type to rule them all. While this is less confusing for beginning programmers, it comes at the price of increased memory consumption, reduced processing efficiency, and decreased precision. When talking about bitwise operators, it’s essential to understand how Python handles integer numbers. After all, you’ll use these operators mainly to work with integers. There are a couple of wildly different representations of integers in Python that depend on their values. In CPython, very small integers between -5 and 256 are interned in a global cache to gain some performance because numbers in that range are commonly used. In practice, whenever you refer to one of those values, which are singletons created at the interpreter startup, Python will always provide the same instance: Both variables have the same identity because they refer to the exact same object in memory. That’s typical of reference types but not immutable values such as integers. However, when you go beyond that range of cached values, Python will start creating distinct copies during variable assignment: Despite having equal values, these variables point to separate objects now. But don’t let that fool you. Python will occasionally jump in and optimize your code behind the scenes. For example, it’ll cache a number that occurs on the same line multiple times regardless of its value: Variables and are independent objects because they reside at different memory locations, while the numbers used literally in are, in fact, the same object. Note: Interning is an implementation detail of the CPython interpreter, which might change in future versions, so don’t rely on it in your programs. Interestingly, there’s a similar string interning mechanism in Python, which kicks in for short texts comprised of ASCII letters only. It helps speed up dictionary lookups by allowing their keys to be compared by memory addresses, or C pointers, instead of by the individual string characters. Integers that you’re most likely to find in Python will leverage the C data type. They use the classic two’s complement binary representation on a fixed number of bits. The exact bit-length will depend on your hardware platform, operating system, and Python interpreter version. Modern computers typically use 64-bit architecture, so this would translate to decimal numbers between -263 and 263 - 1. You can check the maximum value of a fixed-precision integer in Python in the following way: It’s huge! Roughly 9 million times the number of stars in our galaxy, so it should suffice for everyday use. While the maximum value that you could squeeze out of the type in C is even bigger, on the order of 1019, integers in Python have no theoretical limit. To allow this, numbers that don’t fit on a fixed-length bit sequence are stored differently in memory. Do you remember that popular K-pop song “Gangnam Style” that became a worldwide hit in 2012? The YouTube video was the first to break a billion views. Soon after that, so many people had watched the video that it made the view counter overflow. YouTube had no choice but to upgrade their counter from 32-bit signed integers to 64-bit ones. That might give plenty of headroom for a view counter, but there are even bigger numbers that aren’t uncommon in real life, notably in the scientific world. Nonetheless, Python can deal with them effortlessly: This number has fifty-two decimal digits. It would take at least 170 bits to represent it in binary with the traditional approach: Since they’re well over the limits that any of the C types have to offer, such astronomical numbers are converted into a sign-magnitude positional system, whose base is 230. Yes, you read that correctly. Whereas you have ten fingers, Python has over a billion! Again, this may vary depending on the platform you’re currently using. When in doubt, you can double-check: This will tell you how many bits are used per digit and what the size in bytes is of the underlying C structure. To get the same namedtuple in Python 2, you’d refer to the attribute instead. While this conversion between fixed- and arbitrary-precision integers is done seamlessly under the hood in Python 3, there was a time when things were more explicit. For more information, you can expand the box below. In the past, Python explicitly defined two distinct integer types: The first one was modeled after the C type, which typically occupied 32 or 64 bits and offered a limited range of values: For bigger numbers, you were supposed to use the second type that didn’t come with a limit. Python would automatically promote plain integers to long ones if needed: This feature prevented the integer overflow error. Notice the letter at the end of a literal, which could be used to enforce the given type by hand: Eventually, both types were unified so that you wouldn’t have to think about it anymore. Such a representation eliminates integer overflow errors and gives the illusion of infinite bit-length, but it requires significantly more memory. Additionally, performing bignum arithmetic is slower than with fixed precision because it can’t run directly in hardware without an intermediate layer of emulation. Another challenge is keeping a consistent behavior of the bitwise operators across alternative integer types, which is crucial in handling the sign bit. Recall that fixed-precision integers in Python use the standard two’s complement representation from C, while large integers use sign-magnitude. To mitigate that difference, Python will do the necessary binary conversion for you. It might change how a number is represented before and after applying a bitwise operator. Here’s a relevant comment from the CPython source code, which explains this in more detail: Bitwise operations for negative numbers operate as though on a two’s complement representation. So convert arguments from sign-magnitude to two’s complement, and convert the result back to sign-magnitude at the end. (Source) In other words, negative numbers are treated as two’s complement bit sequences when you apply the bitwise operators on them, even though the result will be presented to you in sign-magnitude form. There are ways to emulate the sign bit and some of the unsigned types in Python, though.\n\nYou’re welcome to use pen and paper throughout the rest of this article. It may even serve as a great exercise! However, at some point, you’ll want to verify whether your binary sequences or bit strings correspond to the expected numbers in Python. Here’s how. To reveal the bits making up an integer number in Python, you can print a formatted string literal, which optionally lets you specify the number of leading zeros to display: Alternatively, you can call with the number as an argument: This global built-in function returns a string consisting of a binary literal, which starts with the prefix and is followed by ones and zeros. It always shows the minimum number of digits without the leading zeros. You can use such literals verbatim in your code, too: Other integer literals available in Python are the hexadecimal and octal ones, which you can obtain with the and functions, respectively: Notice how the hexadecimal system, which is base sixteen, takes advantage of letters through to augment the set of available digits. The octal literals in other programming languages are usually prefixed with plain zero, which might be confusing. Python explicitly forbids such literals to avoid making a mistake: File , line : leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers You can express the same value in different ways using any of the mentioned integer literals: Choose the one that makes the most sense in context. For example, it’s customary to express bitmasks with hexadecimal notation. On the other hand, the octal literal is rarely seen these days. All numeric literals in Python are case insensitive, so you can prefix them with either lowercase or uppercase letters: This also applies to floating-point number literals that use scientific notation as well as complex number literals. Once you have your bit string ready, you can get its decimal representation by taking advantage of a binary literal: This is a quick way to do the conversion while working inside the interactive Python interpreter. Unfortunately, it won’t let you convert bit sequences synthesized at runtime because all literals need to be hard-coded in the source code. Note: You might be tempted to evaluate Python code with , but that’s an easy way to compromise the security of your program, so don’t do it! Calling with two arguments will work better in the case of dynamically generated bit strings: The first argument is a string of digits, while the second one determines the base of the numeral system. Unlike a binary literal, a string can come from anywhere, even a user typing on the keyboard. For a deeper look at , you can expand the box below. Other Uses of Show/Hide There are other ways to call . For example, it returns zero when called without arguments: This feature makes it a common pattern in the collection, which needs a default value provider. Take this as an example: Here, helps to count words in a sentence. It’s called automatically whenever needs to initialize the value of a missing key in the dictionary. Another popular use of is typecasting. For example, when you pass a floating-point value, it truncates the value by removing the fractional component: When you give it a string, it tries to parse out a number from it: In general, will accept an object of any type as long as it defines a special method that can handle the conversion. So far, so good. But what about negative numbers? When you call on a negative integer, it merely prepends the minus sign to the bit string obtained from the corresponding positive value: Changing the sign of a number doesn’t affect the underlying bit string in Python. Conversely, you’re allowed to prefix a bit string with the minus sign when transforming it to decimal form: That makes sense in Python because, internally, it doesn’t use the sign bit. You can think of the sign of an integer number in Python as a piece of information stored separately from the modulus. However, there are a few workarounds that let you emulate fixed-length bit sequences containing the sign bit: You know from earlier sections that to ensure a certain bit-length of a number, you can use a nifty bitmask. For example, to keep one byte, you can use a mask composed of exactly eight turned-on bits: Masking forces Python to temporarily change the number’s representation from sign-magnitude to two’s complement and then back again. If you forget about the decimal value of the resulting binary literal, which is equal to 214 , then it’ll represent -42 in two’s complement. The leftmost bit will be the sign bit. Alternatively, you can take advantage of the modulo operation that you used previously to simulate the logical right shift in Python: If that looks too convoluted for your taste, then you can use one of the modules from the standard library that express the same intent more clearly. For example, using will have an identical effect: You’ve seen it before, but just as a reminder, it’ll piggyback off the unsigned integer types from C. Another standard module that you can use for this kind of conversion in Python is the module. It defines a data structure that’s similar to a but is only allowed to hold elements of the same numeric type. When declaring an array, you need to indicate its type up front with a corresponding letter: For example, stands for an 8-bit signed byte, while stands for its unsigned equivalent. There are a few other predefined types, such as a signed 16-bit integer or a 32-bit floating-point number. Copying raw bytes between these two arrays changes how bits are interpreted. However, it takes twice the amount of memory, which is quite wasteful. To perform such a bit rewriting in place, you can rely on the module, which uses a similar set of format characters for type declarations: Packing lets you lay objects in memory according to the given C data type specifiers. It returns a read-only object, which contains raw bytes of the resulting block of memory. Later, you can read back those bytes using a different set of type codes to change how they’re translated into Python objects. Up to this point, you’ve used different techniques to obtain fixed-length bit strings of integers expressed in two’s complement representation. If you want to convert these types of bit sequences back to Python integers instead, then you can try this function: The function accepts a string composed of binary digits. First, it converts the digits to a plain unsigned integer, disregarding the sign bit. Next, it uses two bitmasks to extract the sign and magnitude bits, whose locations depend on the specified bit-length. Finally, it combines them using regular arithmetic, knowing that the value associated with the sign bit is negative. You can try it out against the trusty old bit string from earlier examples: Python’s treats all the bits as the magnitude, so there are no surprises there. However, this new function assumes a 32-bit long string by default, which means the sign bit is implicitly equal to zero for shorter strings. When you request a bit-length that matches your bit string, then you’ll get the expected result. While integer is the most appropriate data type for working with bitwise operators in most cases, you’ll sometimes need to extract and manipulate fragments of structured binary data, such as image pixels. The and modules briefly touch upon this topic, so you’ll explore it in more detail next. You know how to read and interpret individual bytes. However, real-world data often consists of more than one byte to convey information. Take the data type as an example. A single floating-point number in Python occupies as many as eight bytes in memory. How do you see those bytes? You can’t simply use bitwise operators because they don’t work with floating-point numbers: You have to forget about the particular data type you’re dealing with and think of it in terms of a generic stream of bytes. That way, it won’t matter what the bytes represent outside the context of them being processed by the bitwise operators. To get the of a floating-point number in Python, you can pack it using the familiar module: Ignore the format characters passed through the first argument. They won’t make sense until you get to the byte order section below. Behind this rather obscure textual representation hides a list of eight integers: Their values correspond to the subsequent bytes used to represent a floating-point number in binary. You can combine them to produce a very long bit string: These 64 bits are the sign, exponent, and mantissa in double precision that you read about earlier. To synthesize a from a similar bit string, you can reverse the process: returns a tuple because it allows you to read more than one value at a time. For example, you could read the same bit string as four 16-bit signed integers: As you can see, the way a bit string should be interpreted must be known up front to avoid ending up with garbled data. One important question you need to ask yourself is which end of the byte stream you should start reading from—left or right. Read on to find out.\n\nThere’s no dispute about the order of bits in a single byte. You’ll always find the least-significant bit at index zero and the most-significant bit at index seven, regardless of how they’re physically laid out in memory. The bitwise shift operators rely on this consistency. However, there’s no consensus for the byte order in multibyte chunks of data. A piece of information comprising more than one byte can be read from left to right like an English text or from right to left like an Arabic one, for example. Computers see bytes in a binary stream like humans see words in a sentence. It doesn’t matter which direction computers choose to read the bytes from as long as they apply the same rules everywhere. Unfortunately, different computer architectures use different approaches, which makes transferring data between them challenging. Let’s take a 32-bit unsigned integer corresponding to the number 1969 , which was the year when Monty Python first appeared on TV. With all the leading zeros, it has the following binary representation 00000000000000000000011110110001 . How would you store such a value in computer memory? If you imagine memory as a one-dimensional tape consisting of bytes, then you’d need to break that data down into individual bytes and arrange them in a contiguous block. Some find it natural to start from the left end because that’s how they read, while others prefer starting at the right end: When bytes are placed from left to right, the most-significant byte is assigned to the lowest memory address. This is known as the big-endian order. Conversely, when bytes are stored from right to left, the least-significant byte comes first. That’s called little-endian order. Note: These humorous names draw inspiration from the eighteenth-century novel Gulliver’s Travels by Jonathan Swift. The author describes a conflict between the Little-Endians and the Big-Endians over the correct way to break the shell of a boiled egg. While Little-Endians prefer to start with the little pointy end, Big-Endians like the big end more. From a practical standpoint, there’s no real advantage of using one over the other. There might be some marginal gains in performance at the hardware level, but you won’t notice them. Major network protocols use the big-endian order, which allows them to filter data packets more quickly given the hierarchical design of IP addressing. Other than that, some people may find it more convenient to work with a particular byte order when debugging. Either way, if you don’t get it right and mix up the two standards, then bad things start to happen: When you serialize some value to a stream of bytes using one convention and try reading it back with another, you’ll get a completely useless result. This scenario is most likely when data is sent over a network, but you can also experience it when reading a local file in a specific format. For example, the header of a Windows bitmap always uses little-endian, while JPEG can use both byte orders. To find out your platform’s endianness, you can use the module: You can’t change endianness, though, because it’s an intrinsic feature of your CPU architecture. It’s impossible to mock it for testing purposes without hardware virtualization such as QEMU, so even the popular VirtualBox won’t help. Notably, the x86 family of processors from Intel and AMD, which power most modern laptops and desktops, are little-endian. Mobile devices are based on low-energy ARM architecture, which is bi-endian, while some older architectures such as the ancient Motorola 68000 were big-endian only. For information on determining endianness in C, expand the box below. Historically, the way to get your machine’s endianness in C was to declare a small integer and then read its first byte with a pointer: If the value comes out higher than zero, then the byte stored at the lowest memory address must be the least-significant one. Once you know the native endianness of your machine, you’ll want to convert between different byte orders when manipulating binary data. A universal way to do so, regardless of the data type at hand, is to reverse a generic object or a sequence of integers representing those bytes: However, it’s often more convenient to use the module, which lets you define standard C data types. In addition to this, it allows you to request a given byte order with an optional modifier: The greater-than sign ( ) indicates that bytes are laid out in the big-endian order, while the less-than symbol ( ) corresponds to little-endian. If you don’t specify one, then native endianness is assumed. There are a few more modifiers, like the exclamation mark ( ), which signifies the network byte order. Computer networks are made of heterogeneous devices such as laptops, desktops, tablets, smartphones, and even light bulbs equipped with a Wi-Fi adapter. They all need agreed-upon protocols and standards, including the byte order for binary transmission, to communicate effectively. At the dawn of the Internet, it was decided that the byte order for those network protocols would be big-endian. Programs that want to communicate over a network can grab the classic C API, which abstracts away the nitty-gritty details with a socket layer. Python wraps that API through the built-in module. However, unless you’re writing a custom binary protocol, you’ll probably want to take advantage of an even higher-level abstraction, such as the HTTP protocol, which is text-based. Where the module can be useful is in the byte order conversion. It exposes a few functions from the C API, with their distinctive, tongue-twisting names: If your host already uses the big-endian byte order, then there’s nothing to be done. The values will remain the same.\n\nThe primary domain of bitwise operators is integer numbers. That’s where they make the most sense. However, you’ve also seen them used in a Boolean context, in which they replaced the logical operators. Python provides alternative implementations for some of its operators and lets you overload them for new data types. Although the proposal to overload the logical operators in Python was rejected, you can give new meaning to any of the bitwise operators. Many popular libraries, and even the standard library, take advantage of it. Python bitwise operators are defined for the following built-in data types: It’s not a widely known fact, but bitwise operators can perform operations from set algebra, such as union, intersection, and symmetric difference, as well as merge and update dictionaries. Note: At the time of writing, Python 3.9 hadn’t been released, but you could take a sneak peek at the upcoming language features using Docker or pyenv. When and are Python sets, then bitwise operators correspond to the following methods: They do virtually the same thing, so it’s up to you which syntax to use. Apart from that, there’s also an overloaded minus operator ( ), which implements a difference of two sets. To see them in action, assume you have the following two sets of fruits and vegetables: They share one common member, which is hard to classify, but the rest of their elements are disjoint. One thing to watch out for is the immutable , which is missing the methods for in-place updates. However, when you use their bitwise operator counterparts, the meaning is slightly different: It looks like isn’t so immutable after all when you use the bitwise operators, but the devil is in the details. Here’s what actually happens: The reason it works the second time is that you don’t change the original immutable object. Instead, you create a new one and assign it to the same variable again. Python supports only bitwise OR, which works like a union operator. You can use it to update a dictionary in place or merge two dictionaries into a new one: The augmented version of the bitwise operator is equivalent to . Many popular libraries, including NumPy, pandas, and SQLAlchemy, overload the bitwise operators for their specific data types. This is the most likely place you’ll find bitwise operators in Python because they aren’t used very often in their original meaning anymore. For example, NumPy applies them to vectorized data in a pointwise fashion: This way, you don’t need to manually apply the same bitwise operator to each element of the array. But you can’t do the same thing with ordinary lists in Python. pandas uses NumPy behind the scenes, and it also provides overloaded versions of the bitwise operators for its and objects. However, they behave as you’d expect. The only difference is that they do their usual job on vectors and matrices of numbers instead of on individual scalars. Things get more interesting with libraries that give the bitwise operators entirely new meanings. For example, SQLAlchemy provides a compact syntax for querying the database: The bitwise AND operator ( ) will eventually translate to a piece of SQL query. However, that’s not very obvious, at least not to my IDE, which complains about the unpythonic use of bitwise operators when it sees them in this type of expression. It immediately suggests replacing every occurrence of with a logical , not knowing that doing so would make the code stop working! This type of operator overloading is a controversial practice that relies on implicit magic you have to know up front. Some programming languages like Java prevent such abuse by disallowing operator overloading altogether. Python is more liberal in that regard and trusts that you know what you’re doing. To customize the behavior of Python’s bitwise operators, you have to define a class and then implement the corresponding magic methods in it. At the same time, you can’t redefine the behavior of the bitwise operators for the existing types. Operator overloading is possible only on new data types. Here’s a quick rundown of special methods that let you overload the bitwise operators: You don’t need to define all of them. For example, to have a slightly more convenient syntax for appending and prepending elements to a deque, it’s sufficient to implement only and : This user-defined class wraps a deque to reuse its implementation and augment it with two additional methods that allow for adding items to the left or right end of the collection.\n\nWhew, that was a lot to process! If you’re still scratching your head, wondering why you’d want to use bitwise operators, then don’t worry. It’s time to showcase what you can do with them in a fun way. To follow along with the examples in this section, you can download the source code by clicking the link below: Get the Source Code: Click here to get the source code you’ll use to learn about Python’s bitwise operators in this tutorial. You’re going to learn about steganography and apply this concept to secretly embed arbitrary files in bitmap images. Cryptography is about changing a message into one that is readable only to those with the right key. Everyone else can still see the encrypted message, but it won’t make any sense to them. One of the first forms of cryptography was the substitution cipher, such as the Caesar cipher named after Julius Caesar. Steganography is similar to cryptography because it also allows you to share secret messages with your desired audience. However, instead of using encryption, it cleverly hides information in a medium that doesn’t attract attention. Examples include using invisible ink or writing an acrostic in which the first letter of every word or line forms a secret message. Unless you knew that a secret message was concealed and the method to recover it, you’d probably ignore the carrier. You can combine both techniques to be even safer, hiding an encrypted message rather than the original one. There are plenty of ways to smuggle secret data in the digital world. In particular, file formats carrying lots of data, such as audio files, videos, or images, are a great fit because they give you a lot of room to work with. Companies that release copyrighted material might use steganography to watermark individual copies and trace the source of a leak, for example. Below, you’ll inject secret data into a plain bitmap, which is straightforward to read and write in Python without the need for external dependencies. The word bitmap usually refers to the Windows bitmap ( ) file format, which supports a few alternative ways of representing pixels. To make life easier, you’re going to assume that pixels are stored in 24-bit uncompressed RGB (red, green, and blue) format. A pixel will have three color channels that can each hold values from 0 to 255 . Every bitmap begins with a file header, which contains metadata such as the image width and height. Here are a few interesting fields and their positions relative to the start of the header: You can infer from this header that the corresponding bitmap is 1,954 pixels wide and 1,301 pixels high. It doesn’t use compression, nor does it have a color palette. Every pixel occupies 24 bits, or 3 bytes, and the raw pixel data starts at offset 122 . You can open the bitmap in binary mode, seek the desired offset, read the given number of bytes, and deserialize them using like before: Note that all integer fields in bitmaps are stored in the little-endian byte order. You might have noticed a small discrepancy between the number of pixel bytes declared in the header and the one that would result from the image size. When you multiply 1,954 pixels × 1,301 pixels × 3 bytes, you get a value that is 2,602 bytes less than 7,629,064. This is because pixel bytes are padded with zeros so that every row is a multiple of four bytes. If the width of the image times three bytes happens to be a multiple of four, then there’s no need for padding. Otherwise, empty bytes are added at the end of every row. Note: To avoid raising suspicion, you’ll need to take that padding into account by skipping the empty bytes. Otherwise, it would be a clear giveaway to someone who knows what to look for. Bitmaps store pixel rows upside down, starting from the bottom rather than the top. Also, every pixel is serialized to a vector of color channels in a somewhat odd BGR order rather than RGB. However, this is irrelevant to the task of hiding secret data. You can use the bitwise operators to spread custom data over consecutive pixel bytes. The idea is to overwrite the least-significant bit in each of them with bits coming from the next secret byte. This will introduce the least amount of noise, but you can experiment with adding more bits to strike a balance between the size of injected data and pixel distortion. Note: Using the least-significant bit steganography doesn’t affect the file size of the resulting bitmap. It’ll remain the same as the original file. In some cases, the corresponding bits will be the same, resulting in no change in pixel value whatsoever. However, even in the worst-case scenario, a pixel color will differ only by a fraction of a percent. Such a tiny anomaly will remain invisible to the human eye but can be detected with steganalysis, which uses statistics. Take a look at these cropped images: The one on the left comes from the original bitmap, while the image on the right depicts a processed bitmap with an embedded video stored on the least-significant bits. Can you spot the difference? The following piece of code encodes the secret data onto the bitmap: For every byte of secret data and the corresponding eight bytes of pixel data, excluding the pad bytes, it prepares a list of bits to be spread over. Next, it overwrites the least-significant bit in each of the eight bytes using a relevant bitmask. The result is converted to a object and assigned back to the part of the bitmap that it originally came from. To decode a file from the same bitmap, you need to know how many secret bytes were written to it. You could allocate a few bytes at the beginning of the data stream to store this number, or you could use the reserved fields from the bitmap header: This jumps to the right offset in the file, serializes the Python to raw bytes, and writes them down. You might also want to store the name of your secret file. Since it can have an arbitrary length, it makes sense to serialize it using a null-terminated string, which would precede the file contents. To create such a string, you need to encode a Python object to bytes and manually append the null byte at the end: Also, it doesn’t hurt to drop the redundant parent directory from the path using . The sample code supplementing this article will let you encode, decode, and erase a secret file from the given bitmap with the following commands: python -m stegano example.bmp -d python -m stegano example.bmp -x python -m stegano example.bmp -e pdcast.mp4 Secret file was embedded in the bitmap This is a runnable module that can be executed by calling its encompassing directory. You could also make a portable ZIP-format archive out of its contents to take advantage of the Python ZIP application support. This program relies on modules from the standard library mentioned in the article and a few others that you might not have heard about before. A critical module is , which exposes a Python interface to memory-mapped files. They let you manipulate huge files using both the standard file API and the sequence API. It’s as if the file were one big mutable list that you could slice. Go ahead and play around with the bitmap attached to the supporting materials. It contains a little surprise for you!"
    }
]