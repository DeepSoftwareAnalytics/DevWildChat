[
    {
        "link": "https://docs.oracle.com/javase/tutorial/uiswing/painting/index.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nThis lesson describes custom painting in Swing. Many programs will get by just fine without writing their own painting code; they will simply use the standard GUI components that are already available in the Swing API. But if you need specific control over how your graphics are drawn, then this lesson is for you. We will explore custom painting by creating a simple GUI application that draws a shape in response to the user's mouse activity. By intentionally keeping its design simple, we can focus on the underlying painting concepts, which in turn will relate to other GUI applications that you develop in the future.\n\nThis lesson explains each concept in steps as you construct the demo application. It presents the code as soon as possible with a minimum amount of background reading. Custom painting in Swing is similar to custom painting in AWT, but since we do not recommend writing your applications entirely with the AWT, its painting mechanism is not specifically discussed here. You may find it useful to read this lesson followed by the in-depth discussion in the article, Painting in AWT and Swing."
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/uiswing/painting/step2.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nNext, we will add a custom drawing surface to the frame. For this we will create a subclass of (a generic lightweight container) which will supply the code for rendering our custom painting.\n\nClick the Launch button to run SwingPaintDemo2 using Java™ Web Start (download JDK 7 or later). Alternatively, to compile and run the example yourself, consult the example index.\n\nThe first change you will notice is that we are now importing a number of additional classes, such as , , and . Since some of the older AWT classes are still used in modern Swing applications, it is normal to see the package in a few of the import statements. We have also defined a custom subclass, called , which comprises the majority of the new code.\n\nThe class definition has a constructor that sets a black border around its edges. This is a subtle detail that might be difficult to see at first (if it is, just comment out the invocation of and then recompile.) also overrides , which returns the desired width and height of the panel (in this case 250 is the width, 200 is the height.) Because of this, the class no longer needs to specify the size of the frame in pixels. It simply adds the panel to the frame and then invokes .\n\nThe method is where all of your custom painting takes place. This method is defined by and then overridden by your subclasses to provide their custom behavior. Its sole parameter, a object, exposes a number of methods for drawing 2D shapes and obtaining information about the application's graphics environment. In most cases the object that is actually received by this method will be an instance of (a subclass), which provides support for sophisticated 2D graphics rendering.\n\nMost of the standard Swing components have their look and feel implemented by separate \"UI Delegate\" objects. The invocation of passes the graphics context off to the component's UI delegate, which paints the panel's background. For a closer look at this process, see the section entitled \"Painting and the UI Delegate\" in the aforementioned SDN article.\n• Now that you have drawn some custom text to the screen, try minimizing and restoring the application as you did before.\n• Obscure a part of the text with another window, then move that window out of the way to re-expose the custom text. In both cases, the painting subsystem will determine that the component is damaged and will ensure that your method is invoked."
    },
    {
        "link": "https://stackoverflow.com/questions/3734500/custom-painting-of-jpanel",
        "document": "I'm not very good at this and I hope to get some help from people who understands the issue a lot more that I do.\n\nSo here's the deal. In my application there is background JPanel with Image drawn over it. Then there is a small JPanel which I'm trying to create custom painting for. I wanted to have JPanel with rounded corners and semi-transparent background so I modified paintComponent method to fill semi-transparent rounded rectangle. But when I place components inside like say JComboBox, the list of items appears and I click somewhere else to close it JPanel paints itself in original way making it semitransparent all around but with small rectangle painted with original grey background color. I see that it has to do something with invoking paintComponent on its parrent or paintChildren but I don't know how to organize those methods or where to put them. I also have proble with transparent colors overlaping each other.\n\nHere is an example source code:\n\nI hope some of will help me out :-) thanks\n\nEDIT: I found out that JComboBox (and its pop-up menu) draws correctly if pop-up menu overlaps outside the JPanel that contains JComboBox and has the custom paintComponent method."
    },
    {
        "link": "https://stackoverflow.com/questions/55354814/how-to-put-1-jpanel-and-1-custom-jpanel-in-a-jframe",
        "document": "I want to have 2 JPanels in my app, side by side. One that will have some info about my custom board on the right and one about painting that custom board on the left. The first JPanel is a classic, but the second is a custom panel. It seems that im having problems with putting my custom panel into the frame.\n\nI've created a class named BoardPanel within my gui class to draw my custom board. I don't know if this is the best approach. Should i create a separate class instead?\n\nThis is the code of the gui class:\n\nAnd this is the code of the inner class for the custom painting\n\nAside from all these, i have a question. If i want to have a custom painting, is it possible to work along side with the WindowsBuilderPro? I begun using that tool at first. But, i saw that i cant draw something custom with the tool and i had to write code to do that. Is it possible to write code for a custom paint AND use the tool at the same time for different purposes, like adding a simple text label, or even to edit that custon paint? The expected result that i want to see, appears when i run the program. My frame with the two panels. But when i open the WindowsBuilderPro, my custom panel does not appear and the result is a bit wrong. Thit is the reason why i have a question about my approach and if i can write code and use the tool at the same time. Thank you and sorry for the long text guys. I am too confused about this."
    },
    {
        "link": "https://reddit.com/r/javahelp/comments/muyegq/how_do_i_make_custom_painted_components_with",
        "document": "I created a frame with swing, then I made a class extend jpanel, overrided the paint method, and made it draw a buffered image, which all works fine. I used the same method to add two of my own buttons, but the buttons don't draw, and I'm not sure why.\n\nThis here is my window code: https://hatebin.com/hnjsbnfqmz\n\nAnd here is my button code: https://hatebin.com/afeoiaelhv\n\nEdit: I solved it. The issue was you need to draw all the children components, but not draw the actual component itself, so in my jpanel, I just looped through all the components in getComponents and used the paint method on them."
    },
    {
        "link": "https://stackoverflow.com/questions/20335814/java-custom-drawing-with-paintcomponent-and-paint",
        "document": "I come from an Objective-C background and I have been developing on the iOS and Mac OS platform for a number of years now. I love the concept of custom drawing and therefore I would like to replicate what had been done by me on the aforementioned platform.\n\nIn iOS I would call to draw a custom view and then, I could go ahead and add other visual components on top of that drawing. I know that there are equivalents in java swing and awt called and . However, I am not quite sure how the drawing goes about. I do not know when to call the super method (beginning or end ?) and how to add other components to the custom drawn component (custom drawing sometimes appears on top, sometimes beneath).\n\nCan someone shed some light on this ?\n\nI have already read up a little bit on when to use what, but I am still not 100% sure, so can anybody explain when exactly to use and when ?"
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/uiswing/painting/step2.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nNext, we will add a custom drawing surface to the frame. For this we will create a subclass of (a generic lightweight container) which will supply the code for rendering our custom painting.\n\nClick the Launch button to run SwingPaintDemo2 using Java™ Web Start (download JDK 7 or later). Alternatively, to compile and run the example yourself, consult the example index.\n\nThe first change you will notice is that we are now importing a number of additional classes, such as , , and . Since some of the older AWT classes are still used in modern Swing applications, it is normal to see the package in a few of the import statements. We have also defined a custom subclass, called , which comprises the majority of the new code.\n\nThe class definition has a constructor that sets a black border around its edges. This is a subtle detail that might be difficult to see at first (if it is, just comment out the invocation of and then recompile.) also overrides , which returns the desired width and height of the panel (in this case 250 is the width, 200 is the height.) Because of this, the class no longer needs to specify the size of the frame in pixels. It simply adds the panel to the frame and then invokes .\n\nThe method is where all of your custom painting takes place. This method is defined by and then overridden by your subclasses to provide their custom behavior. Its sole parameter, a object, exposes a number of methods for drawing 2D shapes and obtaining information about the application's graphics environment. In most cases the object that is actually received by this method will be an instance of (a subclass), which provides support for sophisticated 2D graphics rendering.\n\nMost of the standard Swing components have their look and feel implemented by separate \"UI Delegate\" objects. The invocation of passes the graphics context off to the component's UI delegate, which paints the panel's background. For a closer look at this process, see the section entitled \"Painting and the UI Delegate\" in the aforementioned SDN article.\n• Now that you have drawn some custom text to the screen, try minimizing and restoring the application as you did before.\n• Obscure a part of the text with another window, then move that window out of the way to re-expose the custom text. In both cases, the painting subsystem will determine that the component is damaged and will ensure that your method is invoked."
    },
    {
        "link": "https://stackoverflow.com/questions/34182239/post-overriding-the-paint-method-of-the-components-in-java",
        "document": "In java awt or swing when you want to change painting of some component you usually have to override the method paint(Graphics g) (in awt) or paintComponent(Graphics g) (in swing). \n\n This is usually (maybe allways - I'm not sure) done when you are creating the component for example:\n\nImagine that you have container of components which could for example consists of some JLabels, some JTextFields, some image. Which will be all put on one component. By container I mean you have some list or map with ids or some similar structure in which are all components you will put on one JFrame. \n\n The question is if I can change the painting method after creating with all of the components which are in this list in the moment when all of them are already created. For example I want do the rotation action (rotate), which is defined in Graphisc2D, with all of them. \n\n So basicaly what I want is that I throught the list of componets I have and say: \"All of you (components) which are in the list will be rotated by some angle\". Is that possible? If yes how?\n\nEdit: \n\n This is my not correctly working solution:"
    },
    {
        "link": "https://bogotobogo.com/Java/tutorials/javagraphics3.php",
        "document": "When we want to draw our own graphics on the screen, we should put our graphics code inside the paintComponent() method. But we never call this method directly. The system calls it.\n\nA Graphics object is the argument to this method. It is the actual drawing canvas that will be displayed. We should give it to the system. However, we can ask the system to refresh the display by calling repaint(). The repaint() call eventually leads to paintComponent() being called.\n\nIn the following code, we make a subclass of JPanel and override one method, paintComponent().\n\nApplications that have components with any custom rendering may need to override this method to perform that custom rendering. This rendering may include drawing graphics inside a canvas, but it also include doing anything custom to a standard component, such as rendering a gradient for the background of a button. Standard Swing components already handle this functionality for their graphics, so it is only for the case of custom components with specialized rendering that this method must be overridden.\n\nOverriding paintComponent() is arguably the most important concept to understand in writing custom Swing components.\n\nHere, we're making a subclass of JPanel which is a widget that we can add to a frame:\n\nThe following block of code Graphics method which is the key in this section. We'll never call this directly. The system calls it:\n\nInside that block of code, we have:\n\nThe Graphics.g is a kind of painting tool. We're telling it what color to paint with and then what shape to paint, where it goes, and how big it is.\n\nThe argument for paintComponent() is a type Graphics which is from java.awt.Graphics:\n\nThe parameter g is a Graphics object. Actually, the object referenced by g is an instance of the Graphics2D class.\n\nSo, if we need to use a method from the Graphics2D class, we can' use the g in paintComponent(Graphics g) directly. However, we can cast it with a new Graphics2D variable:\n\nWhy do we care?\n\n That's because there are things we can do with a Graphics2D reference that we can't do with a Graphics reference. Actually, a Graphics2D object can do more than a Graphics object.\n\nHere are the methods we can call on a Graphics reference:\n\nHere are the methods we can call on a Graphics2D object:\n\nThe following example has a drawing panel at the center with two buttons to control the shape and color. When we click one of the two buttons, however, the program does not know what we want. That's because we have only one actionPerformed(ActionEvent event) method. Clearly, there is a problem.\n\nUsing the Same Listener\n\nHow do we get action events for two different buttons so that each button can do perform its own task?\n\n\n\nThe following code register the same listener for both buttons:\n\nIt's querying the event object to find out which button has been clicked:\n\nThis works!\n\n However, when we need to change the task for one event, we are actually touching the task for other events, because the one event handler doing things for others as well. So, it has some issues related to the maintainability and extensibility.\n\nThe following code create two separate ActionListener classes. It instantiate the two listeners and register one with the color button and the other with the shape button.\n\nSo, instead of pass this to the button's listener registration method, we pass a new instance of the new class:\n\nHowever, we cannot use the reference variables such as messageColor and messageShape of the WhichOne class. These classes (ColorButtonListener and ShapeButtonListener) won't have access to the variables they need to act on, in the example, messages.\n\nThe access problem in the previous example can be resolved by using inner classes. By putting two ActionListers inside the WhichOne classes, we have an access to the reference variables."
    },
    {
        "link": "https://oracle.com/java/technologies/painting.html",
        "document": ""
    }
]