[
    {
        "link": "https://en.wikipedia.org/wiki/C_file_input/output",
        "document": "Input/output functionality in the C programming language\n\nThe C programming language provides many standard library functions for file input and output. These functions make up the bulk of the C standard library header <stdio.h>.[1] The functionality descends from a \"portable I/O package\" written by Mike Lesk at Bell Labs in the early 1970s,[2] and officially became part of the Unix operating system in Version 7.[3]\n\nThe I/O functionality of C is fairly low-level by modern standards; C abstracts all file operations into operations on streams of bytes, which may be \"input streams\" or \"output streams\". Unlike some earlier programming languages, C has no direct support for random-access data files; to read from a record in the middle of a file, the programmer must create a stream, seek to the middle of the file, and then read bytes in sequence from the stream.\n\nThe stream model of file I/O was popularized by Unix, which was developed concurrently with the C programming language itself. The vast majority of modern operating systems have inherited streams from Unix, and many languages in the C programming language family have inherited C's file I/O interface with few if any changes (for example, PHP).\n\nThis library uses what are called streams to operate with physical devices such as keyboards, printers, terminals or with any other type of files supported by the system. Streams are an abstraction to interact with these in a uniform way. All streams have similar properties independent of the individual characteristics of the physical media they are associated with.[4]\n\nMost of the C file input/output functions are defined in <stdio.h> (or in the C++ header cstdio, which contains the standard C functionality but in the std namespace).\n• – also known as a file handle or a , this is an opaque pointer containing the information about a file or text stream needed to perform input or output operations on it, including:\n• platform-specific identifier of the associated I/O device, such as a file descriptor\n• the current stream position and multibyte conversion state (an object of type mbstate_t)\n• – a non-array type capable of uniquely identifying the position of every byte in a file and every conversion state that can occur in all supported multibyte character encodings\n• – an unsigned integer type which is the type of the result of the operator.\n\nThe POSIX standard defines several extensions to stdio in its Base Definitions, among which are a readline function that allocates memory, the fileno and fdopen functions that establish the link between FILE objects and file descriptors, and a group of functions for creating FILE objects that refer to in-memory buffers.[5]\n\nThe following C program opens a binary file called myfile, reads five bytes from it, and then closes the file.\n\nSeveral alternatives to stdio have been developed. Among these is the C++ iostream library, part of the ISO C++ standard. ISO C++ still requires the stdio functionality.\n\nOther alternatives include the Sfio[6] (A Safe/Fast I/O Library) library from AT&T Bell Laboratories. This library, introduced in 1991, aimed to avoid inconsistencies, unsafe practices and inefficiencies in the design of stdio. Among its features is the possibility to insert callback functions into a stream to customize the handling of data read from or written to the stream.[7] It was released to the outside world in 1997, and the last release was 1 February 2005.[8]\n• Media related to C file input/output at Wikimedia Commons"
    },
    {
        "link": "https://programiz.com/c-programming/library-function",
        "document": "C Standard library functions or simply C Library functions are inbuilt functions in C programming.\n\nThe prototype and data definitions of these functions are present in their respective header files. To use these functions we need to include the header file in our program. For example,\n\nIf you want to use the function, the header file should be included.\n\nIf you try to use without including the header file, you will get an error.\n\nAdvantages of Using C library functions\n\nOne of the most important reasons you should use library functions is simply because they work. These functions have gone through multiple rigorous testing and are easy to use.\n\n2. The functions are optimized for performance\n\nSince, the functions are \"standard library\" functions, a dedicated group of developers constantly make them better. In the process, they are able to create the most efficient code optimized for maximum performance.\n\nSince the general functions like printing to a screen, calculating the square root, and many more are already written. You shouldn't worry about creating them once again.\n\nWith ever-changing real-world needs, your application is expected to work every time, everywhere. And, these library functions help you in that they do the same thing on every computer.\n\nSuppose, you want to find the square root of a number.\n\nTo compute the square root of a number, you can use the sqrt() library function. The function is defined in the header file.\n\nWhen you run the program, the output will be:"
    },
    {
        "link": "https://geeksforgeeks.org/c-file-io",
        "document": "In this article, we will learn how to operate over files using a C program. A single C file can read, write, move, and create files in our computer easily using a few functions and elements included in the C File I/O system. We can easily manipulate data in a file regardless of whether the file is a text file or a binary file using functions like fopen(), fclose(), fprintf(), fscanf(), getc(), putc(), getw(), fseek(), etc.\n\nWhat are files in C?\n\nA file is used to store huge data. C provides multiple file management functions like file creation, opening and reading files, Writing to the file, and closing a file. The file is used to store relevant data and file handling in C is used to manipulate the data.\n\nTypes of Files in C\n\nThere are mainly two types of files that can be handled using File Handling in C as mentioned below:\n\nThese are simple text files that are saved by the (.txt) extension and can be created or modified by any text editor. Text file stores data in the form of ASCII characters and is used to store a stream of characters.\n\nIt is stored in binary format instead of ASCII characters. Binary files are normally used to store numeric Information (int, float, double). Here data is stored in binary form i.e, (0’s and 1’s).\n\nC Files can perform multiple useful operations that are mentioned below:\n\nFor performing operations on the file, a special pointer called File pointer is used that can be declared as:\n\nWe can open the file as\n\nThe second parameter i.e, “w” can be changed according to the table below:\n\nSearches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the first character in it. If the file cannot be opened fopen( ) then it returns NULL. Open for reading in binary mode. If the file does not exist then fopen( ) will return NULL. Searches file. Contents are overwritten if the file exists. A new file is created if the file doesn’t exist. Returns NULL, if unable to open the file. Open for writing in binary mode. Its contents are overwritten if the file exists, else the file will be created. Searches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the last character in it. If the file doesn’t exist, a new file is created. Returns NULL, if unable to open the file. Open for append in binary mode. Data is added to the end of the file. A file will be created if it does not exist. Searches file. It is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the first character in it. If it is unable to open the file it Returns NULL. Open for both reading and writing in binary mode. fopen( ) returns NULL if the file does not exist. Searches file. Its contents are overwritten if the file exists. A new file is created if the file doesn’t exist. Returns NULL, if unable to open the file. Open for both reading and writing in binary mode. Contents are overwritten if the file exists. It will be created if the file does not exist. Searches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the last character in it. If the file doesn’t exist, a new file is created. Returns NULL, if unable to open the file. Open for both reading and appending in binary mode. A file will be created if the file does not exist.\n\nIf you want to handle binary files then access modes like “rb”, “wb”, “ab”, “rb+”, r+b”, “wb+”, “w+b”, “ab+”, “a+b” will be used mostly.\n\nTo perform the opening and creation of a file in c we can use the fopen() function which comes under stdio.h header file.\n\nAs now we know how to open a file using fopen() now the question arises about creation. The creation of a file is as simple as opening a file. As, if the while opening a file for writing or appending is done with either write(“w”) or append(“a”) mode then in the case where the file doesn’t exist a new file is created.\n\n1. Writing to a text file in C\n\nfprintf() and fscanf() are used to read and write in a text file in C programming. They expect a pointer to the structure FILE since they are file versions of print() and scanf().\n\nThe above program takes a string from a user and stores it in text_file.text.After compiling this program a text file named temp_text.txt will be created in the C_Program folder. Inside the file, we can see the string that we entered.\n\nfwrite() function takes four arguments address of data, size of the data which is to be written on the disk, number of data types, and a pointer to the file where we want to write.\n\nBelow is the C program to write to a binary file:\n\nBelow is the C program to read the contents from the file:\n\nfread() function also takes four arguments that are similar to fwrite() function in C Programming.\n\nBelow is the C program to read from a binary file:\n\nExplanation: In the above program, we have read the same file GFG.bin and are looping through records one by one. We read a single Num record of Num size from the file pointed by *fptr into the structure Num. We’ll get the same record that we inserted in the previous program.\n\nfseek() and rewind() are the two methods in C programming that can be used to move the file pointer. Let us check both methods:\n\nfseek() function is used to set the file pointer to the specified offset and write data into the file.\n• whence can be SEEK_SET, SEEK_CUR and SEEK_END.\n• SEEK_END: It denotes the end of the file.\n• SEEK_SET: It denotes starting of the file.\n\nBelow is the C program to implement fseek():\n\nrewind() function sets the file pointer to the beginning of the file.\n\nBelow is the C Program to implement rewind():\n\nHow to open a file in C?\n\nHow to create a file in C?\n\nHow to read a file in C?\n\nHow to write to a file in C?\n\nWhat are modes in C file io?\n\nWhat are different operations which can be performed on a file in C?"
    },
    {
        "link": "https://ibm.com/docs/en/i/7.5?topic=extensions-standard-c-library-functions-table-by-name",
        "document": "1 This function is not supported for files opened with type=record. 2 This function is not supported for files opened with type=record and mode=ab+, rb+, or wb+. 3 The ILE C compiler only supports fully buffered and line-buffered streams. Since a block and a line are equal to the record length of the opened file, fully buffered and line-buffered streams are supported in the same way. The and functions have no effect. 4 This function is not available when LOCALETYPE(*CLD) is specified on the compilation command. 5 This function is available only when SYSIFCOPT(*IFSIO) is specified on the CRTCMOD or CRTBNDC command. 6 This function is not available when either LOCALETYPE(*CLD) or SYSIFCOPT(*NOIFSIO) is specified on the compilation command."
    },
    {
        "link": "https://tutorialspoint.com/c_standard_library/stdio_h.htm",
        "document": "The stdio.h header defines three variable types, several macros, and various functions for performing input and output.\n\nFollowing are the variable types defined in the header stdio.h −\n\nFollowing are the macros defined in the header stdio.h −\n\nThis macro is the value of a null pointer constant. These are the macros which expand to integral constant expressions with distinct values and suitable for the use as third argument to the setvbuf function. This macro is an integer, which represents the size of the buffer used by the setbuf function. This macro is a negative integer, which indicates that the end-of-file has been reached. This macro is an integer, which represents the maximum number of files that the system can guarantee to be opened simultaneously. This macro is an integer, which represents the longest length of a char array suitable for holding the longest possible filename. If the implementation imposes no limit, then this value should be the recommended maximum value. This macro is an integer, which represents the longest length of a char array suitable for holding the longest possible temporary filename created by the tmpnam function. These macros are used in the fseek function to locate different positions in a file. This macro is the maximum number of unique filenames that the function tmpnam can generate. These macros are pointers to FILE types which correspond to the standard error, standard input, and standard output streams.\n\nFollowing are the functions defined in the header stdio.h −"
    },
    {
        "link": "https://en.wikipedia.org/wiki/BMP_file_format",
        "document": "The BMP file format, or bitmap, is a raster graphics image file format used to store bitmap digital images, independently of the display device (such as a graphics adapter), especially on Microsoft Windows[2] and OS/2[3] operating systems.\n\nThe BMP file format is capable of storing two-dimensional digital images in various color depths, and optionally with data compression, alpha channels, and color profiles. The Windows Metafile (WMF) specification covers the BMP file format.[4]\n\nMicrosoft has defined a particular representation of color bitmaps of different color depths, as an aid to exchanging bitmaps between devices and applications with a variety of internal representations. They called these device-independent bitmaps or DIBs, and the file format for them is called DIB file format or BMP image file format.\n\nThe following sections discuss the data stored in the BMP file or DIB in detail. This is the standard BMP file format.[5] Some applications create bitmap image files which are not compliant with the Microsoft documentation. Also, not all fields are used; a value of 0 will be found in these unused fields.\n\nThe bitmap image file consists of fixed-size structures (headers) as well as variable-sized structures appearing in a predetermined sequence. Many different versions of some of these structures can appear in the file, due to the long evolution of this file format.\n\nReferring to the diagram 1, the bitmap file is composed of structures in the following order:\n\nA bitmap image file loaded into memory becomes a DIB data structure – an important component of the Windows GDI API. The in-memory DIB data structure is almost the same as the BMP file format, but it does not contain the 14-byte bitmap file header and begins with the DIB header. For DIBs loaded in memory, the color table can also consist of 16-bit entries that constitute indexes to the currently realized palette[8] (an additional level of indirection), instead of explicit RGB color definitions. In all cases, the pixel array must begin at a memory address that is a multiple of 4 bytes. In non-packed DIBs loaded in memory, the optional color profile data should be located immediately after the color table and before the gap1 and pixel array[7] (unlike in diag. 1).\n\nWhen the size of gap1 and gap2 is zero, the in-memory DIB data structure is customarily referred to as \"packed DIB\" and can be referred to by a single pointer pointing to the beginning of the DIB header. In all cases, the pixel array must begin at a memory address that is a multiple of 4 bytes. In some cases it may be necessary to adjust the number of entries in the color table in order to force the memory address of the pixel array to a multiple of 4 bytes.[8] For \"packed DIBs\" loaded in memory, the optional color profile data should immediately follow the pixel array, as depicted in diag. 1 (with gap1=0 and gap2=0).[7]\n\n \"Packed DIBs\" are required by Windows clipboard API functions as well as by some Windows patterned brush and resource functions.[9]\n\nThis block of bytes is at the start of the file and is used to identify the file. A typical application reads this block first to ensure that the file is actually a BMP file and that it is not damaged. The first 2 bytes of the BMP file format are the character \"B\" then the character \"M\" in ASCII encoding. All of the integer values are stored in little-endian format (i.e. least-significant byte first).\n\nThis block of bytes tells the application detailed information about the image, which will be used to display the image on the screen. The block also matches the header used internally by Windows and OS/2 and has several different variants. All of them contain a dword (32-bit) field, specifying their size, so that an application can easily determine which header is used in the image. The reason that there are different headers is that Microsoft extended the DIB format several times. The new extended headers can be used with some GDI functions instead of the older ones, providing more functionality. Since the GDI supports a function for loading bitmap files, typical Windows applications use that functionality. One consequence of this is that for such applications, the BMP formats that they support match the formats supported by the Windows version being run. See the table below for more information.\n\nThe Windows 2.x BITMAPCOREHEADER differs from the OS/2 1.x BITMAPCOREHEADER (shown in the table above) in the one detail that the image width and height fields are signed integers, not unsigned.[13]\n\nVersions after BITMAPINFOHEADER only add fields to the end of the header of the previous version. For example: BITMAPV2INFOHEADER adds fields to BITMAPINFOHEADER, and BITMAPV3INFOHEADER adds fields to BITMAPV2INFOHEADER.\n\nAn integrated alpha channel has been introduced with the undocumented BITMAPV3INFOHEADER and with the documented BITMAPV4HEADER (since Windows 95) and is used within Windows XP logon and theme system as well as Microsoft Office (since v2000); it is supported by some image editing software, such as Adobe Photoshop since version 7 and Adobe Flash since version MX 2004 (then known as Macromedia Flash). It is also supported by GIMP, Google Chrome, Microsoft PowerPoint and Microsoft Word.\n\nFor compatibility reasons, most applications use the older DIB headers for saving files. With OS/2 no longer supported after Windows 2000, for now the common Windows format is the BITMAPINFOHEADER header. See next table for its description. All values are stored as unsigned integers, unless explicitly noted.\n\nThe compression method (offset 30) can be:\n\nAn OS/2 2.x OS22XBITMAPHEADER ( BITMAPINFOHEADER2 in IBM's documentation) contains 24 additional bytes:[3]\n\nThe halftoning algorithm (offset 60) can be:\n\nThe color table (palette) occurs in the BMP image file directly after the BMP file header, the DIB header, and after the optional three or four bitmasks if the BITMAPINFOHEADER header with BI_BITFIELDS (12 bytes) or BI_ALPHABITFIELDS (16 bytes) option is used. Therefore, its offset is the size of the BITMAPFILEHEADER plus the size of the DIB header (plus optional 12-16 bytes for the three or four bit masks).\n\n Note: On Windows CE the BITMAPINFOHEADER header can be used with the BI_ALPHABITFIELDS[6] option in the biCompression member.\n\nThe number of entries in the palette is either 2n (where n is the number of bits per pixel) or a smaller number specified in the header (in the OS/2 BITMAPCOREHEADER header format, only the full-size palette is supported).[3][5] In most cases, each entry in the color table occupies 4 bytes, in the order blue, green, red, 0x00 (see below for exceptions). This is indexed in the BITMAPINFOHEADER in the structure member biBitCount.\n\nThe color table is a block of bytes (a table) listing the colors used by the image. Each pixel in an indexed color image is described by a number of bits (1, 4, or 8) which is an index of a single color described by this table. The purpose of the color palette in indexed color bitmaps is to inform the application about the actual color that each of these index values corresponds to. The purpose of the color table in non-indexed (non-palettized) bitmaps is to list the colors used by the bitmap for the purposes of optimization on devices with limited color display capability and to facilitate future conversion to different pixel formats and palettization.\n\nThe colors in the color table are usually specified in the 4-byte per entry ARGB32 format. The color table used with the OS/2 BITMAPCOREHEADER uses the 3-byte per entry RGB24 format.[3][5] For DIBs loaded in memory, the color table can optionally consist of 2-byte entries – these entries constitute indexes to the currently realized palette[8] instead of explicit RGB color definitions.\n\nMicrosoft does not disallow the presence of a valid alpha channel bit mask[15] in BITMAPV4HEADER and BITMAPV5HEADER for 1bpp, 4bpp and 8bpp indexed color images, which indicates that the color table entries can also specify an alpha component using the 8.8.8.[0-8].[0-8] format via the RGBQUAD.rgbReserved[16] member. However, some versions of Microsoft's documentation disallow this feature by stating that the RGBQUAD.rgbReserved member \"must be zero\".\n\nAs mentioned above, the color table is normally not used when the pixels are in the 16-bit per pixel (16bpp) format (and higher); there are normally no color table entries in those bitmap image files. However, the Microsoft documentation (on the MSDN web site as of Nov. 16, 2010[17]) specifies that for 16bpp (and higher), the color table can be present to store a list of colors intended for optimization on devices with limited color display capability, while it also specifies, that in such cases, no indexed palette entries are present in this Color Table. This may seem like a contradiction if no distinction is made between the mandatory palette entries and the optional color list.\n\nThe bits representing the bitmap pixels are packed in rows (also known as strides or scan lines). The size of each row is rounded up to a multiple of 4 bytes (a 32-bit DWORD) by padding.[18]\n\nFor images with height above 1, multiple padded rows are stored consecutively, forming a Pixel Array.\n\nThe total number of bytes necessary to store one row of pixels can be calculated as:\n\nThe total number of bytes necessary to store an array of pixels in an bits per pixel (bpp) image, with 2 colors, can be calculated by accounting for the effect of rounding up the size of each row to a multiple of 4 bytes, as follows:\n\nImageHeight is expressed in pixels. The absolute value is necessary because ImageHeight is expressed as a negative number for top-down images.\n\nThe pixel array is a block of 32-bit DWORDs, that describes the image pixel by pixel. Usually pixels are stored \"bottom-up\", starting in the lower left corner, going from left to right, and then row by row from the bottom to the top of the image.[5] Unless BITMAPCOREHEADER is used, uncompressed Windows bitmaps also can be stored from the top to bottom, when the Image Height value is negative.\n\nIn the original OS/2 DIB, the only four legal values of color depth were 1, 4, 8, and 24 bits per pixel (bpp).[5] Contemporary DIB Headers allow pixel formats with 1, 2, 4, 8, 16, 24 and 32 bits per pixel (bpp).[19] GDI+ also permits 64 bits per pixel.[20]\n\nPadding bytes (not necessarily 0) must be appended to the end of the rows in order to bring up the length of the rows to a multiple of four bytes. When the pixel array is loaded into memory, each row must begin at a memory address that is a multiple of 4. This address/offset restriction is mandatory only for Pixel Arrays loaded in memory. For file storage purposes, only the size of each row must be a multiple of 4 bytes while the file offset can be arbitrary.[5] A 24-bit bitmap with Width=1, would have 3 bytes of data per row (blue, green, red) and 1 byte of padding, while Width=2 would have 6 bytes of data and 2 bytes of padding, Width=3 would have 9 bytes of data and 3 bytes of padding, and Width=4 would have 12 bytes of data and no padding.\n• Indexed color images may be compressed with 4-bit or 8-bit RLE or Huffman 1D algorithm.\n• OS/2 2 24bpp images may be compressed with the 24-bit RLE algorithm.\n• The 16bpp and 32bpp images are always stored uncompressed.\n• Note that images in all color depths can be stored without compression if so desired.\n• The 1-bit per pixel (1bpp) format supports 2 distinct colors, (for example: black and white). The pixel values are stored in each bit, with the first (left-most) pixel in the most-significant bit of the first byte. 5 Each bit is an index into a table of 2 colors. An unset bit will refer to the first color table entry, and a set bit will refer to the last (second) color table entry.\n• The 2-bit per pixel (2bpp) format supports 4 distinct colors and stores 4 pixels per 1 byte, the left-most pixel being in the two most significant bits (Windows CE only: 21 ). Each pixel value is a 2-bit index into a table of up to 4 colors.\n• The 4-bit per pixel (4bpp) format supports 16 distinct colors and stores 2 pixels per 1 byte, the left-most pixel being in the more significant nibble. 5 Each pixel value is a 4-bit index into a table of up to 16 colors.\n• The 8-bit per pixel (8bpp) format supports 256 distinct colors and stores 1 pixel per 1 byte. Each byte is an index into a table of up to 256 colors.\n• The 16-bit per pixel (16bpp) format supports 65536 distinct colors and stores 1 pixel per 2-byte WORD. Each WORD can define the alpha, red, green and blue samples of the pixel.\n• The 24-bit per pixel (24bpp) format supports 16,777,216 distinct colors and stores 1 pixel value per 3 bytes. Each pixel value defines the red, green and blue samples of the pixel (8.8.8.0.0 in RGBAX notation). Specifically, in the order: blue, green and red (8 bits per each sample). 5\n• The 32-bit per pixel (32bpp) format supports 4,294,967,296 distinct colors and stores 1 pixel per 4-byte DWORD. Each DWORD can define the alpha, red, green and blue samples of the pixel.\n\nIn order to resolve the ambiguity of which bits define which samples, the DIB headers provide certain defaults as well as specific BITFIELDS, which are bit masks that define the membership of particular group of bits in a pixel to a particular channel. The following diagram defines this mechanism:\n\nThe sample fields defined by the BITFIELDS bit masks have to be contiguous and non-overlapping, but the order of the sample fields is arbitrary. The most ubiquitous field order is: Alpha, Blue, Green, Red (MSB to LSB). The red, green and blue bit masks are valid only when the Compression member of the DIB header is set to BI_BITFIELDS. The alpha bit mask is valid whenever it is present in the DIB header or when the Compression member of the DIB header is set to BI_ALPHABITFIELDS[6] (Windows CE only).\n\nThe BITFIELD mechanism described above allows for the definition of tens of thousands of different pixel formats, however only several of them are used in practice,[22] all palettized formats RGB8, RGB4, and RGB1 (marked in yellow in the table above, defined in .MEDIASUBTYPE names):\n\nIn version 2.1.4 FFmpeg supported (in its own terminology) the BMP pixel formats bgra, bgr24, rgb565le, rgb555le, rgb444le, rgb8, bgr8, rgb4_byte, bgr4_byte, gray, pal8, and monob; i.e., bgra was the only supported pixel format with transparency.[24]\n\nFollowing is an example of a 2×2 pixel, 24-bit bitmap (Windows DIB header BITMAPINFOHEADER) with pixel format RGB24.\n\nFollowing is an example of a 4×2 pixel, 32-bit bitmap with opacity values in the alpha channel (Windows DIB Header BITMAPV4HEADER) with pixel format ARGB32.\n\nNote that the bitmap data starts with the lower left hand corner of the image.\n\nThe simplicity of the BMP file format, and its widespread familiarity in Windows and elsewhere, as well as the fact that this format is relatively well documented and has an open format, makes BMP a very common format that image processing programs from many operating systems can read and write. ICO and CUR files contain bitmaps starting with a BITMAPINFOHEADER.\n\nMany older graphical user interfaces used bitmaps in their built-in graphics subsystems;[25] for example, the Microsoft Windows and OS/2 platforms' GDI subsystem, where the specific format used is the Windows and OS/2 bitmap file format, usually named with the file extension of .[26]\n\nWhile most BMP files have a relatively large file size due to lack of any compression (or generally low-ratio run-length encoding on palletized images), many BMP files can be considerably compressed with lossless data compression algorithms such as ZIP because they contain redundant data. Some formats, such as RAR, even include routines specifically targeted at efficient compression of such data.\n\nThe X Window System uses a similar XBM format for black-and-white images, and XPM (pixelmap) for color images. There are also a variety of \"raw\" formats, which save raw data with no other information. The Portable Pixmap (PPM) and Truevision TGA formats also exist, but are less often used – or only for special purposes; for example, TGA can contain transparency information.\n• An introduction to DIBs (Device Independent Bitmaps), at herdsoft.com\n• A simple bitmap loader C++ class, at kalytta.com (A2R10G10B10 not yet supported)\n• The BMP File Format, Part 1 By David Charlap at Dr. Dobb's journal of software tools (drdobbs.com), March 1995"
    },
    {
        "link": "https://engineering.purdue.edu/ece264/16au/hw/HW13",
        "document": "This is for Fall 2016 (9 years ago)\n\n// Credit: Prof. Yung-Hsiang Lu and Prof. Cheng-Kok Koh created earlier assignments upon which this one is based. Text from that assignment has been copied with permission.\n\nIn this exercise, you will write code to read, write, and crop BMP image files.\n\nA BMP file has the following format:\n\nThe header has 54 bytes, which are divided into the following fields. Note that the #pragma directive ensures that the header structure is really 54-byte long by using 1-byte alignment.\n\nNote that the number of bytes each field occupies can be obtained by dividing the number 16 or 32 by 8. For example, the field \"type\" occupies 2 bytes. These fields are all integers. An \"uint\" means unsigned, and \"int\" means signed. For example the fields \"width\" and \"height\" are signed integers. However, for simplicity, all the BMP files we have will contain only positive integers. You may assume that in your code. Also, we are dealing wih uncompressed BMP format (compression field is 0).\n\nBecause of the packing specified in the bmp.h file, you should be able to use fread to read in the first 54 bytes of a BMP file and store 54 bytes in a BMPHeader structure.\n\nAmong all these fields in the BMPHeader structure, you have to pay attention to the following fields:\n\nWe will further explain bits, width, height, and imagesize later. You should use the following structure to store a BMP file, the header for the first 54 bytes of a given BMP file, and data should point to a location that is big enough (of imagesize) to store the image data (color information of each pixel).\n\nNow, let's examine the fields bits, width, height, and imagesize in greater details. The bits field records the number of bits used to represent a pixel. For this exercise (and the next exercise and assignment), we are dealing with BMP files with only 24 bits per pixel or 16 bits per pixel. For 24-bit representation, 8 bits (1 byte) for RED, 8 bits for GREEN, and 8 bits for BLUE. For 16-bit representation, each color is represented using 5 bits (the most significant bit is not used). For this exercise, we will use only 24-bit BMP files to test your functions. However, your code should be able to handle 16-bit format as well. (Note that the header format is actually more complicated for 16-bit format. However, for this exercise and the next exercise and assignment, we will use the same header format for both 24-bit and 16-bit BMP files for simplicity. So yes, we are abusing the format!)\n\nThe width field gives you the number of pixels per row. Therefore, the total number of bytes required to represent a row of pixel for a 24-bit representation is width * 3. However, the BMP format requires each row to be padded at the end such that each row is represented by multiples of 4 bytes of data. For example, if there is only one pixel in each row, we need an additional byte to pad a row. If there are two pixels per row, 2 additional bytes. If there are three pixels per row, 3 additional bytes. If there are four pixels per row, we don't have too perform padding. We require you to assign value 0 to each of the padding byte.\n\nThe height field gives you the number of rows. Row 0 is the bottom of the image. The file is organized such that the bottom row follows the header, and the top row is at the end of the file. Within each row, the left most pixel has a lower index. Therefore, the first byte in data, i.e., data[0], belongs to the bottom left pixel.\n\nThe imagesize field is height * amount of data per row. Note that the amount of date per row includes padding at the end of each row.\n\nYou can visualize the one-dimensional data as a three-dimensional array, which is organized as rows of pixels, with each pixel represented by 3 bytes of colors (24-bit representation) or 2 bytes of colors (16-bit representation). However, because of padding, you cannot easily typecast the one-dimensional data as a 3-dimensional array. Instead, you can first typecast it as a two dimensional array, rows of pixels. For each row of data, you can typecast it as a two-dimensional array, where the first dimension captures pixels from left to right, the second dimension is the color of each pixel (3 bytes or 2 bytes).\n\nThe Wikipedia article on the BMP file format has a nice diagram and more complete details about this format.\n\nIn this assignment, you will need to handle run-time errors. These are not the same as bugs in your code. These are problems (or special conditions) that might arise due to the inputs from the caller of a function that you write. For example, a file may be inaccessible or corrupt, or may fail and return NULL.\n\nFor purposes of this assignment, the error-handling strategy will be two-pronged:\n• Return a special value if the operation failed. For functions that return a , you will return NULL if the operation failed.\n• Return an error message via pass-by-address. Normally, the caller will pass the address of . If the operation is successful, the callee will do nothing with it. However, if there is a failure, the callee will return a newly heap-allocated string. It is the caller's responsibility to free it.\n\nYou will do this for all functions in this assignment that take a parameter called .\n\nHere is a sketch of the basic pattern we are describing:\n\nEXIT_SUCCESS and EXIT_FAILURE are constants defined as 0 and 1, respectively, in stdlib.h. Although we haven't been using these so far in ECE 264, they are actually better than simply returning 0 and 1.\n\nThis assignment includes a warm-up exercise to help you get ready. This accounts for 20% of your score for HW13. Scoring will be relatively light, but the usual base requirements apply.\n• Read a text file\n\n Create a function that reads the contents of a file and returns it as a string on the heap. The caller is responsible for freeing that memory. Use , , and .\n• Write a text file\n\n Create a function that writes the given content to a file at the specified path. Use , , and .\n• Write a Point \n\n Write a function that writes a single Point to a file at the specified path. Use , , and . For the class, please copy-paste the following struct type into your file: This will be a binary file. This is preparation for working with binary files for images, which work the same way. In general, you will use for binary files.\n• Read a Point \n\n Create a function that reads a from the file at the specified path into a on the stack. No or are necessary for this one. Use , , and .\n\nThe structure of the warmup.c file is described in the Requirements table below. You should write your own warmup.c. You may add helper functions, if you wish.\n\nIn a hurry, and don't need the practice? This warm-up is here to help you learn what you need to succeed on the rest of this assignment—not to add additional work. Therefore, we give you an option. Those who feel that they do not need the practice may \"opt out\". by modifying warmup.c so that it does nothing but print the following message exactly and then exit:\n\nIf you do that, then your score for HW13 will be based solely on the rest of this assignment. If you leave the warmup.c undone, if you do not turn in a warmup.c, or if the message it prints does not match perfectly, then you will receive 0 for the warmup portion of this assignment (20%).\n\nUse test-driven development to do this assignment incrementally. At least 12 stages must be explicitly marked with comments in your in test_bmp.c. It will look similar to this:\n\nThis aspect of the assignment will be checked, but only to the degree that we can do so efficiently (i.e., possibly very lightly). Nevertheless, you should follow it in earnest for your own benefit.\n\nRemember: Your code should never be broken for more than about 10-15 minutes at a time.\n\nWe have provided a bmp.h file and some test image files. You must use our bmp.h. To obtain these, run . You may use other BMP image files of your choice*, but not all BMP files will work with this code (e.g., grayscale, other color depths, etc.), so your may wish to stick with the supplied files to test.\n\nAny image files that you turn in must be G-rated and not violate any copyrights (i.e., your own images or else freely licensed). Provide credit in your bmp.c file in the form of a comment like:\n\nHow much work is this?\n\nThis assignment is designed to be of similar difficulty to HW12. As usual… Do not depend on this estimate. Your mileage may vary in either direction.\n• How can I view the contents of a BMP directly?\n\n The best way to inspect binary data is with a hex dump. From bash, you can type . Since it will probably be long, you will want to view in vim. One way to do that is type from bash. Another way is to open the file in vim and then type . (Do not save!)\n\n \n\n Suppose you have the following tiny 6x6 BMP image: . (Yes, it really is only 6 pixels by 6 pixels. Don't worry. A larger version is included in one of the diagrams below.)\n\n \n\n To get a hex dump right on the command line, you could type this at bash: It will be more convenient to view in vim, so we type this from bash instead. (Don't forget the \"-\" at the end!) Here is the hex dump, a you will see it. Don't worry if this looks cryptic. Read on and you will understand it completely.\n\n \n\n \n\n You can break this apart using the information about the BMP file format above. Here is the same hex dump, this time with some annotations. \n\n \n\n For this and other binary file formats, you can understand what value goes where by simply looking at the specification and a hex dump of the binary file."
    },
    {
        "link": "https://stackoverflow.com/questions/11004868/creating-a-bmp-file-bitmap-in-c",
        "document": "I'm trying to make a bitmap in C, just from code. I'm currently trying to make a very easy .bmp image, with a height of 1px and a width of 4 pixels, with all white pixels. I have read the format description and tried to apply it. This resulted in the following code:\n\nWhen I try to open this image, it says that the image is damaged. Am I missing something here?\n\nI also noticed that the encoding of the .bmp integers is little endian. I thought that this mean that I have to reverse the order of the bytes. For example, 256 in four bytes is: 00000000 00000000 00000001 00000000, and I think in little endian this would be: 00000000 00000001 00000000 00000000\n\nCan anyone give me a hand here? Am I using a right approach? Any help would be appreciated!"
    },
    {
        "link": "https://reddit.com/r/C_Programming/comments/15bvek9/bmp_file_format_and_c",
        "document": "Is it true that BMP file is written in C programming language? While the displayed image of BMP file remains same irrespective of the platform (be it accessed through Microsoft Word or Image Viewer), the content of the image can be manipulated in C. Can the same BMP image be accessed and manipulated in Python? I mean if the same can be manipulated in Python, then BMP file is neither specifically written in C nor Python.\n\nAfter going through the comments, smiley.bmp is the actual bmp file while helpers.c and colorize.c are C files. But what about bmp.h and helpers.h? I understand they are sort of library files appended before the main function. But are these .h files written in C?"
    },
    {
        "link": "https://homepages.inf.ed.ac.uk/rbf/BOOKS/PHILLIPS/cips2ed.pdf",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/57061429/running-c-bilinear-interpolation",
        "document": "Your problem here is probably less so figuring out how to call , and more so figuring out how to load your images. I recommend the SOIL library, it handles most common formats and gets you the raw pixel data.\n\nYou'll also most likely need some function to create the actual instances from the raw image. SOIL and other image libraries should be able to provide you the width and height, as well as some kind of byte or int array for the image itself. image_t appears to be row-major in your example, so something like this could work:\n\nJust remember to free your image's pixel data after you're done using it."
    },
    {
        "link": "https://stackoverflow.com/questions/35518845/image-rotation-bi-linear-interpolation-and-nearest-neighbor",
        "document": "You don't do anything to your target image . Basically, the code should go something like this:\n\nwhere and are pixel coordinates of the target image and and are pixel coordinates of the source image .\n\nYour code has many peculiarities:\n• You allocate a two-level vector of 1000000 × 4 doubles in order to hold a 3×3 rotation matrix. Why do you want to use a 3d rotation matrix anyway? (I gather the third column is the translation vector.)\n• What are and `image2? Are they global arrays? Shouldn't the pixel values be part of the image struct?\n• Your code yould benefit from modularisation: Write a function to read a matrix; another function to invert it and so on. At the moment, you have a lot of duplicated code."
    },
    {
        "link": "https://geeksforgeeks.org/what-is-bilinear-interpolation",
        "document": "Bilinear interpolation is an extension of linear interpolation to a two-dimensional space. It approximates the value at a certain point within a grid by sampling the coordinates with values of four other grid points. The outstanding thing about the interpolation is that this is done in one direction (x or y) and then in the other direction, making it bilinear.\n\nIn simple terms, while bearing basic values in the four vertices of a rectangle, for any point within the rectangular, bilinear interpolation indicates the expected value.\n\nThe bilinear interpolation formula combines two linear interpolations to compute an estimate in a 2D space. Suppose you have a rectangular grid with points (x y ), (x , y ), (x , y ), (x , y ), and you want to estimate the value at point (x, y) where x ≤ x ≤ x and y ≤ y ≤ y . The known values at these points are:\n\nThis formula involves a weighted average of the four surrounding points, ensuring that the closer a point is to the target, the more influence it has on the interpolated result.\n\nHere’s a breakdown of the steps involved in bilinear interpolation:\n\n1. Identify the four surrounding points: Given a point (x,y), locate the four grid points that form a rectangle around it. These points have known values.\n\n2. Interpolate in the x-direction: You can still guess linear values at the x-coordinate of the points in questions, using only the y-coordinates of the two points in question.\n• Estimate value at (x,y ) using Q and Q\n• Estimate value at (x,y ) using Q and Q22\n\n3. Interpolate in the y-direction: Again, use the same linear interpolation and calculate two more values, one that is interpolated using the x-direction and the other interpolated using the y-direction. After that, do another interpolation between the two above-mentioned values to get the final value at point (x,y).\n\n4. Combine the results: The last estimated value can be calculated as a linear combination of the four known values with respective to the four corners of the rectangle.\n\nBilinear interpolation is widely used in image processing for tasks like:\n• Image Resizing: Bilinear interpolation is another technique that is used when an image is either enlarged or reduced in size; it calculates the pixel values for the new size; changes are smoother than in the nearest neighbor method.\n• Image Rotation: When an image is rotated, then the new pixel locations must be calculated using some values of their neighbors, and bilinear interpolation provides a much better quality of image with no jagged edges.\n• Texture Mapping in Computer Graphics: Bilinear interpolation is very useful in translating textures on 3D models and the visual quality is enhanced in comparison with other simpler techniques.\n• Zooming: Interpolation makes an image appear natural without producing sharp or blocky transitions, and bilinear interpolation is used in zooming to estimate the value of pixels in a zoomed image.\n• Smoother Results: Bilinear interpolation creates a more gradual change of pixel values as opposed to nearest-neighbor interpolation; there are fewer sharp corners, fewer pivot points, and no blurring.\n• Simplicity: Therefore, it is relatively simpler and computationally favorable, which raises the possibility of making it apt for real-time use.\n• Widely Applicable: The bilinear interpolation technique has general use in a number of fields including image processing and computer graphics, as well as in Geographic Information Systems (GIS).\n• Blurring: Although bilinear interpolation eases transitions between pixels, they often result in a certain amount of blurring particularly in areas that require sharp change in intensity, such as an edge or any high frequency region in an image.\n• Less Accurate than Higher-Order Methods: Bilinear interpolation is less accurate than some of the enhanced methods such as bicubic interpolation, which uses more points in the neighboring area.\n• Loss of Detail: The method can sometimes lead to blurred or loss of some features or borders of the picture especially if the smaller portion of the picture is being considered.\n\nBilinear interpolation is a fundamental technique for estimating values in a 2D grid. Its combination of simplicity, efficiency, and reasonable accuracy makes it an essential tool in fields such as image processing, computer graphics, and geographic information systems. Although it has its limitations, bilinear interpolation strikes a balance between speed and precision, making it a versatile and widely used method in various applications."
    },
    {
        "link": "https://meghal-darji.medium.com/implementing-bilinear-interpolation-for-image-resizing-357cbb2c2722",
        "document": "There are several editing tools that we can use to resize any image to any desired size. Apart from that, if you’re coding there are plenty of libraries available for every programming language where you can resize an image with just a single line of code without worrying about the details. You might be thinking, “why should I waste time on thinking and writing a code to resize images when I can have an editing application or a robust library take care of it”. However, I am guessing you’re here because you are probably curious about what goes on behind the scenes when you resize an image and you’d like to implement the resizing algorithm from scratch to understand it better. I decided to work on Image Resizing for the same reasons. So let’s get started.\n\nOne of the key aspects of image resizing is Interpolation. If you look up the meaning of the term Interpolation you’ll learn that it means estimating unknown values using related known values. This is exactly what we need to do when resizing an image. Using the known pixel values we estimate the pixel value at any particular location in the resized image. There are several interpolation techniques that can be used when resizing images such as Nearest Neighbour Interpolation, Bilinear Interpolation, and Bicubic Interpolation. Here, I will walk you through the implementation of Bilinear Interpolation to resize images and we’ll also discuss some problems that we might face on the way, and the solutions as well.\n\nBefore we proceed with the implementation, I would like to mention that this post will solely focus on the implementation of bilinear interpolation. Hence, I am assuming that you are already familiar with the concept of bilinear interpolation. However, if you’re not, I have your back. Here is the link to a youtube video: https://www.youtube.com/watch?v=hpqrDUuk7HY&list=PLjMXczUzEYcHvw5YYSU92WrY8IwhTuq7p&index=3&t=3074s. Open it and skip to 56:20. You will find a crystal clear explanation of the bilinear interpolation method.\n\nOkay, so now let’s start coding to implement it. We will implement the algorithm in python3 and use Numpy. It is better to create a function for bilinear interpolation and resizing. The block of code below creates a function called bl_resize and takes 3 arguments:\n\noriginal_img : Original Image array,\n\nnew_h: desired height of the resized image, and\n\nnew_w : desired width of the resized image.\n• Inside the function, we need to get the dimensions of the original image which can be obtained using .shape method.\n• In the next step, we create an empty array named resized of shape (new_h, new_w, c) containing all 0s.\n• Now we calculate the scaling factors along the two dimensions. It contains an if/else check to avoid division by 0 in case new_h or new_w is equal to 0.\n\n4. To fill in the pixel values of the empty array we will iterate through the pixels using 2 for loops that run along the 2 dimensions.\n\n5. To estimate the pixel value in the new array we need to map its coordinate values back into the original image array. This is done by multiplying the coordinate values i,j with the scaling factors of the corresponding dimensions to obtain x and y values.\n\n6. Recall that to estimate a pixel value using Bilinear Interpolation we need the values of 4 neighboring pixels from the original image. Hence, now we calculate the coordinate values for the 4 neighboring pixels.\n\n(Note: while calculating the ceiling values, it is important to ensure that its value remains in the range (0 to old_h-1) and (0 to old_w-1) to avoid IndexError.\n\n7. Using the coordinate values, we get pixel values (v1, v2, v3, and v4) of these 4 neighboring pixels.\n\n8. Using the neighboring pixel values we estimate the pixel value q and assign it to the pixel at coordinates (i,j) in the new image array.\n\nThat’s it! We’ve implemented Bilinear Interpolation to resize an Image. But wait, before we wrap it up let us check whether we get what we want. Copy the code and try to resize an image of your choice.\n\nThis is what I see when I try to shrink an image:\n\nWell, this is not what we want. Why is there a grid-like structure on top of the image?\n\nGo back to the code inside the nested for loops. What would happen if either x or y or both have integer values? In such a case, what would be the values of q1, q2, and q?\n\nThis happens when either x or y is an integer resulting in q=0. When x is an integer, x_floor and x_ceil will have the same value as x. As a result, both q1 and q2 will be 0 and finally, q will be 0 as well. On the other hand, if y is an integer, y_floor and y_ceil will have the same value as y. Consequently, we will get non-zero values for q1 and q2 but q will be 0 since \n\ny = y_floor = y_ceil.\n\nTo avoid this issue, we just need to add some additional checks in the form of if/else loops before calculating q1, q2, and q values to handle such cases. There can be three possible cases:\n\nCase 1:When both x and y have integer values\n\nWhen both x and y are integers, it means that the coordinates of a pixel in the resized image coincide with a particular pixel of the original image. In such a case, there is no need to estimate the pixel value. We can straightaway assign the value of the coinciding pixel.\n\nCase 2 and 3: When either one of them is an integer.\n\nWhen either one is an integer, bilinear interpolation turns into linear interpolation as shown in the figure below.\n\nWith these additional checks in the form of if/else loops we can be sure that no pixel will be wrongly assigned 0 value when x and y are integers.\n\nHere is the final code to resize images using Bilinear Interpolation:\n\nWell, that’s it. We have successfully implemented Bilinear Interpolation to resize images. You can use OpenCV to read, write and display resized images.\n\nResizing modern-day images, that are very high in resolution, using this code will take some time as its runtime complexity is O(n²) because of the two nested for loops."
    },
    {
        "link": "https://dsp.stackexchange.com/questions/82295/how-to-implement-interpolation-by-convolution-for-rotation-of-an-image-by-an-ang",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    }
]