[
    {
        "link": "https://geeksforgeeks.org/sed-command-in-linux-unix-with-examples",
        "document": "The SED (Stream Editor) command is one of the most powerful tools used during text processing in Linux/Unix systems. The SED command is generally used to perform tasks such as search and replace, text manipulation, and stream editing.\n\nUsing SED, you can easily handle text files without opening them in an editor, and that’s what makes it a perfect choice to edit batch files, manage log files, and perform quick transformations on large files.\n\nIn this guide, we will walk you through the SED command syntax, use cases and most commonly used SED options to help you master this power tool. You’ll also learn how to securely manipulate text, replace strings, delete lines, and automate tasks seamlessly in Linux/Unix environments.\n\nWhat is the Sed Command\n\nThe SED command (Stream Editor) is a text manipulation tool used to perform basic text transformations and advanced operations such as find and replace, text insertion, deletion, and substitution. It is commonly used in bscripts to automate tasks (such as file editing).\n\nThe basic syntax for using the SED command in Linux is:\n• ‘OPTIONS’: These are optional flags that modify the behavior of the sed command.\n• ‘COMMAND’ : This defines the command or sequence of commands to execute on the input file.\n• ‘INPUTFILE’ : One or more input files to be processed.\n\nBelow are some of the most frequently used SED command options, let’s check them out:\n\nHere are some basic SED commands that will help you get started with text manipulation.\n\nConsider the below text file as an input.\n\nReplacing or substituting string: Sed command is mostly used to replace the text in a file. The below simple sed command replaces the word “unix” with “linux” in the file.\n\nHere the “s” specifies the substitution operation. The “/” are delimiters. The “unix” is the search pattern and the “linux” is the replacement string. By default, the sed command replaces the first occurrence of the pattern in each line and it won’t replace the second, third…occurrence in the line.\n\n2. Replacing the nth Occurrence of a Pattern in a Line\n\nTo replace only the nth occurance of a word in a line, use the following syntax:\n\nUse the ‘/1’, ‘/2’ etc. flags to replace the first, second occurrence of a pattern in a line. The below command replaces the second occurrence of the word “unix” with “linux” in a line.\n\n3. Replacing all the Occurrence of the Pattern in a Line\n\nHere, we will use the g flag to replace all the occurances of a pattern in a line. Let’s check out the syntax below:\n\nThe substitute flag /g (global replacement) specifies the sed command to replace all the occurrences of the string in the line.\n\n4. Replacing from nth Occurrence to all Occurrences in a Line\n\nUse the combination of /1, /2 etc and /g to replace all the patterns from the nth occurrence of a pattern in a line. The following sed command replaces the third, fourth, fifth… “unix” word with “linux” word in a line.\n\n5. Parenthesize First Character of Each Word\n\nThis sed example prints the first character of every word in parenthesis.\n\nYou can restrict the sed command to replace the string on a specific line number. An example is\n\nThe above sed command replaces the string only on the third line.\n\nThe /p print flag prints the replaced line twice on the terminal. If a line does not have the search pattern and is not replaced, then the /p prints that line only once.\n\nUse the -n option along with the /p print flag to display only the replaced lines. Here the -n option suppresses the duplicate rows generated by the /p flag and prints the replaced lines only one time.\n\nIf you use -n alone without /p, then the sed does not print anything.\n\nYou can specify a range of line numbers to the sed command for replacing a string.\n\nHere the sed command replaces the lines with range from 1 to 3. Another example is\n\nHere $ indicates the last line in the file. So the sed command replaces the text from second line to last line in the file.\n\nSED command can also be used for deleting lines from a particular file. SED command is used for performing deletion operation without even opening the file\n\n1. To Delete a particular line say n in this example\n\n3. To Delete line from range x to y\n\n4. To Delete from nth to last line\n\nBelow are some of the advanced SED commands that can be used for handling various editing tasks. let’s check them out:\n\nSED supports regular expressions that allows it to handle more complex pattern matching. To enable regular expressions, you need to use -r option.\n\nHere, we have matched any word start with ‘u’ and replacing it with “Linux”. Let’s check this out in the provided syntax below:\n\nYou can use this option to insert any text before or after any specific line. Here’s the syntax provided below:\n\nExample: To insert a new line before line2 in geekfile.txt\n\n1. Ensure to back up your files before applying for the changes. (especially while using -i)\n\n2. Be cautious before using the extended reular expressions to avoid any unintended substitutions.\n\n3. Always test your SED command on sample file first (to avoid unintentional changes).\n\nThe SED command in Linux/Unix is a versatile and powerful tool for automating text editing tasks, from simple find-and-replace operations to more complex pattern matching. Whether you’re working with a single file or need to process multiple files in a script, sed offers an efficient solution for text manipulation.\n\nBy using the above provided examples of basic and advanced, you can easily utilize the full capacity of SED to manipulate and process text files directly.\n\nWhat is the\n\nWhat are examples of\n\nWhat is the correct syntax for using\n\nHow to use\n\nWhat is the purpose of\n\nHow to use SED to replace text in a file?"
    },
    {
        "link": "https://gnu.org/software/sed/manual/sed.html",
        "document": "is a stream editor. A stream editor is used to perform basic text transformations on an input stream (a file or input from a pipeline). While in some ways similar to an editor which permits scripted edits (such as ), works by making only one pass over the input(s), and is consequently more efficient. But it is ’s ability to filter text in a pipeline which particularly distinguishes it from other types of editors.\n\nThis chapter covers how to run . Details of scripts and individual commands are discussed in the next chapter.\n\nNormally is invoked like this:\n\nFor example, to replace all occurrences of ‘ ’ to ‘ ’ in the file :\n\nIf you do not specify , or if is , filters the contents of the standard input. The following commands are equivalent:\n\nwrites output to standard output. Use to edit files in-place instead of printing to standard output. See also the and commands for writing output to other files. The following command modifies and does not produce any output:\n\nBy default prints all processed input (except input that has been modified/deleted by commands such as ). Use to suppress output, and the command to print specific lines. The following command prints only line 45 of the input file:\n\ntreats multiple input files as one long stream. The following example prints the first line of the first file ( ) and the last line of the last file ( ). Use to reverse this behavior.\n\nWithout or options, uses the first non-option parameter as the , and the following non-option parameters as input files. If or options are used to specify a , all non-option parameters are taken as input files. Options and can be combined, and can appear multiple times (in which case the final effective will be concatenation of all the individual s).\n\nThe following examples are equivalent:\n\nThe full format for invoking is:\n\nmay be invoked with the following command-line options:\n\nIf no , , , or options are given on the command-line, then the first non-option argument on the command line is taken to be the to be executed.\n\nIf any command-line parameters remain after processing the above, these parameters are interpreted as the names of input files to be processed. A file name of ‘ ’ refers to the standard input stream. The standard input will be processed if no file names are specified.\n\nAn exit status of zero indicates success, and a nonzero value indicates failure. GNU returns the following exit status error values:\n\nAdditionally, the commands and can be used to terminate with a custom exit code value (this is a GNU extension):\n\nA program consists of one or more commands, passed in by one or more of the , , , and options, or the first non-option argument if zero of these options are used. This document will refer to “the” script; this is understood to mean the in-order concatenation of all of the s and s passed in. See Overview.\n\nis a single-letter command. is an optional line address. If is specified, the command will be executed only on the matched lines. can be a single line number, a regular expression, or a range of lines (see sed addresses). Additional are used for some commands.\n\nThe following example deletes lines 30 to 35 in the input. is an address range. is the delete command:\n\nThe following example prints all input until a line starting with the word ‘ ’ is found. If such line is found, will terminate with exit status 42. If such line was not found (and no other error occurred), will exit with status 0. is a regular-expression address. is the quit command. is the command option.\n\nCommands within a or can be separated by semicolons ( ) or newlines (ASCII 10). Multiple scripts can be specified with or options.\n\nThe following examples are all equivalent. They perform two operations: deleting any lines matching the regular expression , and replacing all occurrences of the string ‘ ’ with ‘ ’:\n\nCommands , , , due to their syntax, cannot be followed by semicolons working as command separators and thus should be terminated with newlines or be placed at the end of a or . Commands can also be preceded with optional non-significant whitespace characters. See Multiple commands syntax.\n\nThe following commands are supported in GNU . Some are standard POSIX commands, while other are GNU extensions. Details and examples for each command are in the following sections. (Mnemonics) are shown in parentheses.\n\nThe command (as in substitute) is probably the most important in and has a lot of different options. The syntax of the command is ‘ ’.\n\nIts basic concept is simple: the command attempts to match the pattern space against the supplied regular expression ; if the match is successful, then that portion of the pattern space which was matched is replaced with .\n\nFor details about syntax see Regular Expression Addresses.\n\nThe can contain ( being a number from 1 to 9, inclusive) references, which refer to the portion of the match which is contained between the th and its matching . Also, the can contain unescaped characters which reference the whole matched portion of the pattern space.\n\nThe characters may be uniformly replaced by any other single character within any given command. The character (or whatever other character is used in its stead) can appear in the or only if it is preceded by a character.\n\nFinally, as a GNU extension, you can include a special sequence made of a backslash and one of the letters , , , , or . The meaning is as follows:\n\nWhen the flag is being used, case conversion does not propagate from one occurrence of the regular expression to another. For example, when the following command is executed with ‘ ’ in pattern space:\n\nthe output is ‘ ’. When replacing the first ‘ ’, the ‘ ’ sequence only affects the empty replacement of ‘ ’. It does not affect the character that is added to pattern space when replacing with .\n\nOn the other hand, and do affect the remainder of the replacement text if they are followed by an empty substitution. With ‘ ’ in pattern space, the following command:\n\nwill replace ‘ ’ with ‘ ’ (uppercase) and ‘ ’ with ‘ ’. If this behavior is undesirable, you can prevent it by adding a ‘ ’ sequence—after ‘ ’ in this case.\n\nTo include a literal , , or newline in the final replacement, be sure to precede the desired , , or newline in the with a .\n\nThe command can be followed by zero or more of the following :\n\nIf you use at all, you will quite likely want to know these commands.\n\nThough perhaps less frequently used than those in the previous section, some very small yet useful scripts can be built with these commands.\n\nIn most cases, use of these commands indicates that you are probably better off programming in something like or Perl. But occasionally one is committed to sticking with , and these commands can enable one to write quite convoluted scripts.\n\nThese commands are specific to GNU , so you must use them with care and only when you are sure that hindering portability is not evil. They allow you to check for GNU extensions or to do tasks that are required quite often, yet are unsupported by standard s.\n\nThere are several methods to specify multiple commands in a program.\n\nUsing newlines is most natural when running a sed script from a file (using the option).\n\nOn the command line, all commands may be separated by newlines. Alternatively, you may specify each command as an argument to an option:\n\nA semicolon (‘ ’) may be used to separate most simple commands:\n\nThe , , , , , commands can be separated with a semicolon (this is a non-portable GNU extension).\n\nLabels used in , , , commands are read until a semicolon. Leading and trailing whitespace is ignored. In the examples below the label is ‘ ’. The first example works with GNU . The second is a portable equivalent. For more information about branching and labels see Branching and flow control.\n\nThe following commands cannot be separated by a semicolon and require a newline:\n\nAddresses determine on which line(s) the command will be executed. The following command replaces the word ‘ ’ with ‘ ’ only on line 144:\n\nIf no addresses are given, the command is performed on all lines. The following command replaces the word ‘ ’ with ‘ ’ on all lines in the input file:\n\nAddresses can contain regular expressions to match lines based on content instead of line numbers. The following command replaces the word ‘ ’ with ‘ ’ only in lines containing the word ‘ ’:\n\nAn address range is specified with two addresses separated by a comma ( ). Addresses can be numeric, regular expressions, or a mix of both. The following command replaces the word ‘ ’ with ‘ ’ only in lines 4 to 17 (inclusive):\n\nAppending the character to the end of an address specification (before the command letter) negates the sense of the match. That is, if the character follows an address or an address range, then only lines which do not match the addresses will be selected. The following command replaces the word ‘ ’ with ‘ ’ only in lines not containing the word ‘ ’:\n\nThe following command replaces the word ‘ ’ with ‘ ’ only in lines 1 to 3 and 18 till the last line of the input file (i.e. excluding lines 4 to 17):\n\nAddresses in a script can be in any of the following forms:\n\nGNU supports the following regular expression addresses. The default regular expression is Basic Regular Expression (BRE). If or options are used, The regular expression should be in Extended Regular Expression (ERE) syntax. See BRE vs ERE.\n\nRegex addresses operate on the content of the current pattern space. If the pattern space is changed (for example with command) the regular expression matching will operate on the changed text.\n\nIn the following example, automatic printing is disabled with . The command changes lines containing ‘ ’ to ‘ ’. The command matches lines with digits and prints them. Because the second line is changed before the regex, it will not match and will not be printed:\n\nAn address range can be specified by specifying two addresses separated by a comma ( ). An address range matches lines starting from where the first address matches, and continues until the second address matches (inclusively):\n\nIf the second address is a , then checking for the ending match will start with the line following the line which matched the first address: a range will always span at least two lines (except of course if the input stream ends).\n\nIf the second address is a less than (or equal to) the line matching the first address, then only the one line is matched:\n\nGNU also supports some special two-address forms; all these are GNU extensions:\n\nTo know how to use , people should understand regular expressions (regexp for short). A regular expression is a pattern that is matched against a subject string from left to right. Most characters are ordinary: they stand for themselves in a pattern, and match the corresponding characters. Regular expressions in are specified between two slashes.\n\nThe following command prints lines containing the word ‘ ’:\n\nThe above example is equivalent to this command:\n\nThe power of regular expressions comes from the ability to include alternatives and repetitions in the pattern. These are encoded in the pattern by the use of special characters, which do not stand for themselves but instead are interpreted in some special way.\n\nThe character (caret) in a regular expression matches the beginning of the line. The character (dot) matches any single character. The following command matches and prints lines which start with the letter ‘ ’, followed by any single character, followed by the letter ‘ ’:\n\nThe following sections explain the meaning and usage of special characters in regular expressions.\n\nBasic and extended regular expressions are two variations on the syntax of the specified pattern. Basic Regular Expression (BRE) syntax is the default in (and similarly in ). Use the POSIX-specified option ( , ) to enable Extended Regular Expression (ERE) syntax.\n\nIn GNU , the only difference between basic and extended regular expressions is in the behavior of a few special characters: ‘ ’, ‘ ’, parentheses, braces (‘ ’), and ‘ ’.\n\nWith basic (BRE) syntax, these characters do not have special meaning unless prefixed with a backslash (‘ ’); While with extended (ERE) syntax it is reversed: these characters are special unless they are prefixed with backslash (‘ ’).\n\nHere is a brief description of regular expression syntax as used in .\n\nNote that the regular expression matcher is greedy, i.e., matches are attempted from left to right and, if two or more matches are possible starting at the same character, it selects the longest.\n\nThe only difference between basic and extended regular expressions is in the behavior of a few characters: ‘ ’, ‘ ’, parentheses, braces (‘ ’), and ‘ ’. While basic regular expressions require these to be escaped if you want them to behave as special characters, when using extended regular expressions you must escape them if you want them to match a literal character. ‘ ’ is special here because ‘ ’ is a GNU extension – standard basic regular expressions do not provide its functionality.\n\nA bracket expression is a list of characters enclosed by ‘ ’ and ‘ ’. It matches any single character in that list; if the first character of the list is the caret ‘ ’, then it matches any character not in the list. For example, the following command replaces the words ‘ ’ or ‘ ’ with ‘ ’:\n\nBracket expressions can be used in both basic and extended regular expressions (that is, with or without the / options).\n\nWithin a bracket expression, a range expression consists of two characters separated by a hyphen. It matches any single character that sorts between the two characters, inclusive. In the default C locale, the sorting sequence is the native character order; for example, ‘ ’ is equivalent to ‘ ’.\n\nFinally, certain named classes of characters are predefined within bracket expressions, as follows.\n\nThese named classes must be used inside brackets themselves. Correct usage:\n\nIncorrect usage is rejected by newer versions. Older versions accepted it but treated it as a single bracket expression (which is equivalent to ‘ ’, that is, only the characters ):\n\nNote that the brackets in these class names are part of the symbolic names, and must be included in addition to the brackets delimiting the bracket expression.\n\nThe characters , , , , and are normally not special within . For example, matches either ‘ ’ or ‘ ’, because the is not special here. However, strings like , , and are special within and represent collating symbols, equivalence classes, and character classes, respectively, and is therefore special within when it is followed by , , or . Also, when not in mode, special escapes like and are recognized within . See Escapes.\n\nThe following sequences have special meaning inside regular expressions (used in addresses and the command).\n\nThese can be used in both basic and extended regular expressions (that is, with or without the / options).\n\nback-references are regular expression commands which refer to a previous part of the matched regular expression. Back-references are specified with backslash and a single digit (e.g. ‘ ’). The part of the regular expression they refer to is called a subexpression, and is designated with parentheses.\n\nBack-references and subexpressions are used in two cases: in the regular expression search pattern, and in the part of the command (see Regular Expression Addresses and The \"s\" Command).\n\nIn a regular expression pattern, back-references are used to match the same content as a previously matched subexpression. In the following example, the subexpression is ‘ ’ - any single character (being surrounded by parentheses makes it a subexpression). The back-reference ‘ ’ asks to match the same content (same character) as the sub-expression.\n\nThe command below matches words starting with any character, followed by the letter ‘ ’, followed by the same character as the first.\n\nMultiple subexpressions are automatically numbered from left-to-right. This command searches for 6-letter palindromes (the first three letters are 3 subexpressions, followed by 3 back-references in reverse order):\n\nIn the command, back-references can be used in the part to refer back to subexpressions in the part.\n\nThe following example uses two subexpressions in the regular expression to match two space-separated words. The back-references in the part prints the words in a different order:\n\nWhen used with alternation, if the group does not participate in the match then the back-reference makes the whole match fail. For example, ‘ ’ will not match ‘ ’. When multiple regular expressions are given with or from a file (‘ ’), back-references are local to each expression.\n\nUntil this chapter, we have only encountered escapes of the form ‘ ’, which tell not to interpret the circumflex as a special character, but rather to take it literally. For example, ‘ ’ matches a single asterisk rather than zero or more backslashes.\n\nThis chapter introduces another kind of escape6—that is, escapes that are applied to a character or sequence of characters that ordinarily are taken literally, and that replaces with a special character. This provides a way of encoding non-printable characters in patterns in a visible manner. There is no restriction on the appearance of non-printing characters in a script but when a script is being prepared in the shell or by text editing, it is usually easier to use one of the following escape sequences than the binary character it represents:\n\nThe list of these escapes is:\n\n‘ ’ (backspace) was omitted because of the conflict with the existing “word boundary” meaning.\n\nGNU processes escape sequences before passing the text onto the regular-expression matching of the command and Address matching. Thus the follwing two commands are equivalent (‘ ’ is the hexadecimal ASCII value of the character ‘ ’):\n\nAs are the following (‘ ’,‘ ’ are the hexadecimal ASCII values of ‘ ’,‘ ’, respectively):\n\nHowever it is recommended to avoid such special characters due to unexpected edge-cases. For example, the following are not equivalent:\n\nThe following example uses the Greek letter Capital Sigma (Σ, Unicode code point ). In a locale, correctly processes the Sigma as one character despite it being 2 octets (bytes):\n\nTo force to process octets separately, use the locale (also known as the locale):\n\n’s regular expressions do not match invalid multibyte sequences in a multibyte locale.\n\nIn the following examples, the ascii value is an incomplete multibyte character (shown here as �). The regular expression ‘ ’ does not match it:\n\nSimilarly, the ’catch-all’ regular expression ‘ ’ does not match the entire line:\n\nGNU offers the special command to clear the current pattern space regardless of invalid multibyte characters (i.e. it works like but also removes invalid multibyte characters):\n\nAlternatively, force the locale to process each octet separately (every octet is a valid character in the locale):\n\n’s inability to process invalid multibyte characters can be used to detect such invalid sequences in a file. In the following examples, the is an invalid multibyte sequence, while is a valid multibyte sequence (of the Greek Sigma character).\n\nThe following program removes all valid characters using . Any content left in the pattern space (the invalid characters) are added to the hold space using the command. On the last line ( ), the hold space is retrieved ( ), newlines are removed ( ), and any remaining octets are printed unambiguously ( ). Thus, any invalid multibyte sequences are printed as octal values:\n\nWith a few more commands, can print the exact line number corresponding to each invalid characters (line 3). These characters can then be removed by forcing the locale and using octal escape sequences:\n\nIn other locales, the sorting sequence is not specified, and ‘ ’ might be equivalent to ‘ ’ or to ‘ ’, or it might fail to match any character, or the set of characters that it matches might even be erratic. To obtain the traditional interpretation of bracket expressions, you can use the ‘ ’ locale by setting the environment variable to the value ‘ ’.\n\nTheir interpretation depends on the locale; for example, ‘ ’ means the character class of numbers and letters in the current locale.\n\nmaintains two data buffers: the active pattern space, and the auxiliary hold space. Both are initially empty.\n\noperates by performing the following cycle on each line of input: first, reads one line from the input stream, removes any trailing newline, and places it in the pattern space. Then commands are executed; each command can have an address associated to it: addresses are a kind of condition code, and a command is only executed if the condition is verified before the command is to be executed.\n\nWhen the end of the script is reached, unless the option is in use, the contents of pattern space are printed out to the output stream, adding back the trailing newline if it was removed.8 Then the next cycle starts for the next input line.\n\nUnless special commands (like ‘ ’) are used, the pattern space is deleted between two cycles. The hold space, on the other hand, keeps its data between cycles (see commands ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’ to move data between both buffers).\n\nMultiple lines can be processed as one buffer using the , , , , . They are similar to their lowercase counterparts ( , , , , ), except that these commands append or subtract data while respecting embedded newlines - allowing adding and removing lines from the pattern and hold spaces.\n\nThey operate as follows:\n\nThe following example illustrates the operation of and commands:\n• starts by reading the first line into the pattern space (i.e. ‘ ’).\n• At the beginning of every cycle, the command appends a newline and the next line to the pattern space (i.e. ‘ ’, ‘ ’, ‘ ’ in the first cycle).\n• The command prints the content of the pattern space unambiguously.\n• The command then removes the content of pattern space up to the first newline (leaving ‘ ’ at the end of the first cycle).\n• At the next cycle the command appends a newline and the next input line to the pattern space (e.g. ‘ ’, ‘ ’, ‘ ’).\n\nA common technique to process blocks of text such as paragraphs (instead of line-by-line) is using the following construct:\n• The first expression, operates on all non-empty lines, and adds the current line (in the pattern space) to the hold space. On all lines except the last, the pattern space is deleted and the cycle is restarted.\n• The other expressions and are executed only on empty lines (i.e. paragraph separators). The command fetches the accumulated lines from the hold space back to the pattern space. The command then operates on all the text in the paragraph (including the embedded newlines).\n\nThe following example demonstrates this technique:\n\nFor more annotated examples, see Text search across multiple lines and Line length adjustment.\n\nThe branching commands , , and enable changing the flow of programs.\n\nBy default, reads an input line into the pattern buffer, then continues to processes all commands in order. Commands without addresses affect all lines. Commands with addresses affect only matching lines. See Execution Cycle and Addresses overview.\n\ndoes not support a typical construct. Instead, some commands can be used as conditionals or to change the default flow control:\n\nThe following two programs are equivalent. The first (contrived) example uses the command to skip the command on lines containing ‘ ’. The second example uses an address with negation (‘ ’) to perform substitution only on desired lines. The command is still executed on all lines:\n\nThe , and commands can be followed by a label (typically a single letter). Labels are defined with a colon followed by one or more letters (e.g. ‘ ’). If the label is omitted the branch commands restart the cycle. Note the difference between branching to a label and restarting the cycle: when a cycle is restarted, first prints the current content of the pattern space, then reads the next input line into the pattern space; Jumping to a label (even if it is at the beginning of the program) does not print the pattern space and does not read the next input line.\n\nThe following program is a no-op. The command (the only command in the program) does not have a label, and thus simply restarts the cycle. On each cycle, the pattern space is printed and the next input line is read:\n\nThe following example is an infinite-loop - it doesn’t terminate and doesn’t print anything. The command jumps to the ‘ ’ label, and a new cycle is never started:\n\nBranching is often complemented with the or commands: both commands read the next input line into the pattern space without waiting for the cycle to restart. Before reading the next input line, prints the current pattern space then empties it, while appends a newline and the next input line to the pattern space.\n\nConsider the following two examples:\n• Both examples do not inf-loop, despite never starting a new cycle.\n• In the first example, the commands first prints the content of the pattern space, empties the pattern space then reads the next input line.\n• In the second example, the commands appends the next input line to the pattern space (with a newline). Lines are accumulated in the pattern space until there are no more input lines to read, then the command terminates the program. When the program terminates, the end-of-cycle actions are performed, and the entire pattern space is printed.\n• The second example requires GNU , because it uses the non-POSIX-standard behavior of . See the “ command on the last line” paragraph in Reporting Bugs.\n• To further examine the difference between the two examples, try the following commands:\n\nAs a real-world example of using branching, consider the case of quoted-printable files, typically used to encode email messages. In these files long lines are split and marked with a soft line break consisting of a single ‘ ’ character at the end of the line:\n\nThe following program uses an address match ‘ ’ as a conditional: If the current pattern space ends with a ‘ ’, it reads the next input line using , replaces all ‘ ’ characters which are followed by a newline, and unconditionally branches ( ) to the beginning of the program without restarting a new cycle. If the pattern space does not ends with ‘ ’, the default action is performed: the pattern space is printed and a new cycle is started:\n\nHere’s an alternative program with a slightly different approach: On all lines except the last, appends the line to the pattern space. A substitution command then removes soft line breaks (‘ ’ at the end of a line, i.e. followed by a newline) by replacing them with an empty string. if the substitution was successful (meaning the pattern space contained a line which should be joined), The conditional branch command jumps to the beginning of the program without completing or restarting the cycle. If the substitution failed (meaning there were no soft line breaks), The command will not branch. Then, will print the pattern space content until the first newline, and will delete the pattern space content until the first new line. (To learn more about , and commands see Multiline techniques).\n\nFor more line-joining examples see Joining lines.\n\nHere are some scripts to guide you in the art of mastering .\n\nThis section uses , and commands to process multiple lines, and the and commands for branching. See Multiline techniques and Branching and flow control.\n\nJoin specific lines (e.g. if lines 2 and 3 need to be joined):\n\nThis script centers all lines of a file on a 80 columns width. To change that width, the number in must be replaced, and the number of added spaces also must be changed.\n\nNote how the buffer commands are used to separate parts in the regular expressions to be matched—this is a common technique.\n\nThis script is one of a few that demonstrate how to do arithmetic in . This is indeed possible,9 but must be done manually.\n\nTo increment one number you just add 1 to last digit, replacing it by the following digit. There is one exception: when the digit is a nine the previous digits must be also incremented until you don’t have a nine.\n\nThis solution by Bruno Haible is very clever and smart because it uses a single buffer; if you don’t have this limitation, the algorithm used in Numbering lines, is faster. It works by replacing trailing nines with an underscore, then using multiple commands to increment the last digit, and then again substituting underscores with zeros.\n\nThis is a pretty strange use of . We transform text, and transform it to be shell commands, then just feed them to shell. Don’t worry, even worse hacks are done when using ; I have seen a script converting the output of into a program!\n\nThe main body of this is the script, which remaps the name from lower to upper (or vice-versa) and even checks out if the remapped name is the same as the original name. Note how the script is parameterized using shell variables and proper quoting.\n\nThis script strips the definition of the shell functions from the output of the Bourne-shell command.\n\nThis script can be used to reverse the position of characters in lines. The technique moves two characters at a time, hence it is faster than more intuitive implementations.\n\nNote the command before the definition of the label. This is often needed to reset the flag that is tested by the command.\n\nImaginative readers will find uses for this script. An example is reversing the output of .10\n\nThis section uses and commands to search for consecutive words spanning multiple lines. See Multiline techniques.\n\nThese examples deal with finding doubled occurrences of words in a document.\n\nFinding doubled words in a single line is easy using GNU and similarly with GNU :\n• The regular expression ‘ ’ searches for word-boundary (‘ ’), followed by one-or-more word-characters (‘ ’), followed by whitespace (‘ ’). See regexp extensions.\n• Adding parentheses around the ‘ ’ expression creates a subexpression. The regular expression pattern ‘ ’ defines a subexpression (in the parentheses) followed by a back-reference, separated by whitespace. A successful match means the was repeated twice in succession. See Back-references and Subexpressions.\n• The word-boundery expression (‘ ’) at both ends ensures partial words are not matched (e.g. ‘ ’ is not a desired match).\n• The option enables extended regular expression syntax, alleviating the need to add backslashes before the parenthesis. See ERE syntax.\n\nWhen the doubled word span two lines the above regular expression will not find them as and operate line-by-line.\n\nBy using and commands, can apply regular expressions on multiple lines (that is, multiple lines are stored in the pattern space, and the regular expression works on it):\n• The command appends the next line to the pattern space (thus ensuring it contains two consecutive lines in every cycle).\n• The regular expression uses ‘ ’ for word separator which matches both spaces and newlines.\n• The regular expression matches, the entire pattern space is printed with . No lines are printed by default due to the option.\n• The removes the first line from the pattern space (up until the first newline), readying it for the next cycle.\n\nSee the GNU manual for an alternative solution using and at https://gnu.org/s/coreutils/manual/html_node/Squeezing-and-deleting.html.\n\nThis section uses and commands to search for consecutive words spanning multiple lines, and the command for branching. See Multiline techniques and Branching and flow control.\n\nThis (somewhat contrived) example deal with formatting and wrapping lines of text of the following input file:\n\nThe following sed program wraps lines at 40 characters:\n\nThis one begins a series of totally useless (yet interesting) scripts emulating various Unix commands. This, in particular, is a workalike.\n\nNote that on implementations other than GNU this script might easily overflow internal buffers.\n\nThis script replaces ‘ ’; in fact it formats its output exactly like GNU does.\n\nOf course this is completely useless and for two reasons: first, because somebody else did it in C, second, because the following Bourne-shell script could be used for the same purpose and would be much faster:\n\nIt uses to print the line number, then groups lines two by two using . Of course, this script does not teach as much as the one presented below.\n\nThe algorithm used for incrementing uses both buffers, so the line is printed as soon as possible and then discarded. The number is split so that changing digits go in a buffer and unchanged ones go in the other; the changed digits are modified in a single step (using a command). The line number for the next line is then composed and stored in the hold space, to be used in the next iteration.\n\nEmulating ‘ ’ is almost the same as ‘ ’—we only have to select which lines are to be numbered and which are not.\n\nThe part that is common to this script and the previous one is not commented to show how important it is to comment scripts properly...\n\nThis script shows another way to do arithmetic with . In this case we have to add possibly large numbers, so implementing this by successive increments would not be feasible (and possibly even more complicated to contrive than this script).\n\nThe approach is to map numbers to letters, kind of an abacus implemented with . ‘ ’s are units, ‘ ’s are tens and so on: we simply add the number of characters on the current line as units, and then propagate the carry to tens, hundreds, and so on.\n\nAs usual, running totals are kept in hold space.\n\nOn the last line, we convert the abacus form back to decimal. For the sake of variety, this is done with a loop rather than with some 80 commands11: first we convert units, removing ‘ ’s from the number; then we rotate letters so that tens become ‘ ’s, and so on until no more letters remain.\n\nThis script is almost the same as the previous one, once each of the words on the line is converted to a single ‘ ’ (in the previous script each letter was changed to an ‘ ’).\n\nIt is interesting that real programs have optimized loops for ‘ ’, so they are much slower at counting words rather than characters. This script’s bottleneck, instead, is arithmetic, and hence the word-counting one is faster (it has to manage smaller numbers).\n\nAgain, the common parts are not commented to show the importance of commenting scripts.\n\nNo strange things are done now, because gives us ‘ ’ functionality for free!!! Look:\n\nThis script is probably the simplest useful script. It displays the first 10 lines of input; the number of displayed lines is right before the command.\n\nPrinting the last lines rather than the first is more complex but indeed possible. is encoded in the second line, before the bang character.\n\nThis script is similar to the script in that it keeps the final output in the hold space and prints it at the end:\n\nMainly, the scripts keeps a window of 10 lines and slides it by adding a line and deleting the oldest (the substitution command on the second line works like a command but does not restart the loop).\n\nThe “sliding window” technique is a very powerful way to write efficient and complex scripts, because commands like would require a lot of work if implemented manually.\n\nTo introduce the technique, which is fully demonstrated in the rest of this chapter and is based on the , and commands, here is an implementation of using a simple “sliding window.”\n\nThis looks complicated but in fact the working is the same as the last script: after we have kicked in the appropriate number of lines, however, we stop using the hold space to keep inter-line state, and instead use and to slide pattern space by one line:\n\nNote how the first, second and fourth line are inactive after the first ten lines of input. After that, all the script does is: exiting on the last line of input, appending the next input line to pattern space, and removing the first line.\n\nThis is an example of the art of using the , and commands, probably the most difficult to master.\n\nAs you can see, we maintain a 2-line window using and . This technique is often used in advanced scripts.\n\nThis script prints only duplicated lines, like ‘ ’.\n\nThis script prints only unique lines, like ‘ ’.\n\nAs a final example, here are three scripts, of increasing complexity and speed, that implement the same function as ‘ ’, that is squeezing blank lines.\n\nThe first leaves a blank line at the beginning and end if there are some already.\n\nThis one is a bit more complex and removes all empty lines at the beginning. It does leave a single blank line at end if one was there.\n\nThis removes leading and trailing blank lines. It is also the fastest. Note that loops are completely done with and , without relying on to restart the script automatically at the end of a line.\n\nFor those who want to write portable scripts, be aware that some implementations have been known to limit line lengths (for the pattern and hold spaces) to be no more than 4000 bytes. The POSIX standard specifies that conforming implementations shall support at least 8192 byte line lengths. GNU has no built-in limit on line length; as long as it can more (virtual) memory, you can feed or construct lines as long as you like.\n\nHowever, recursion is used to handle subpatterns and indefinite repetition. This means that the available stack space may limit the size of the buffer that can be processed by certain patterns.\n\n9 Other Resources for Learning About\n\nFor up to date information about GNU please visit https://www.gnu.org/software/sed/.\n\nSend general questions and suggestions to sed-devel@gnu.org. Visit the mailing list archives for past discussions at https://lists.gnu.org/archive/html/sed-devel/.\n\nThe following resources provide information about (both GNU and other variations). Note these not maintained by GNU developers.\n• The mailing list maintained by Sven Guckes: http://groups.yahoo.com/group/sed-users/ (note this is not the GNU mailing list).\n\nEmail bug reports to bug-sed@gnu.org. Also, please include the output of ‘ ’ in the body of your report if at all possible.\n\nPlease do not send a bug report like this:\n\nIf GNU doesn’t configure your favorite package, take a few extra minutes to identify the specific problem and make a stand-alone test case. Unlike other programs such as C compilers, making such test cases for is quite simple.\n\nA stand-alone test case includes all the data necessary to perform the test, and the specific invocation of that causes the problem. The smaller a stand-alone test case is, the better. A test case should not involve something as far removed from as “try to configure frobme-1.3.4”. Yes, that is in principle enough information to look for the bug, but that is not a very practical prospect.\n\nHere are a few commonly reported bugs that are not bugs.\n• PREAMBLE The purpose of this License is to make a manual, textbook, or other functional and useful document free in the sense of freedom: to assure everyone the effective freedom to copy and redistribute it, with or without modifying it, either commercially or noncommercially. Secondarily, this License preserves for the author and publisher a way to get credit for their work, while not being considered responsible for modifications made by others. This License is a kind of “copyleft”, which means that derivative works of the document must themselves be free in the same sense. It complements the GNU General Public License, which is a copyleft license designed for free software. We have designed this License in order to use it for manuals for free software, because free software needs free documentation: a free program should come with manuals providing the same freedoms that the software does. But this License is not limited to software manuals; it can be used for any textual work, regardless of subject matter or whether it is published as a printed book. We recommend this License principally for works whose purpose is instruction or reference.\n• APPLICABILITY AND DEFINITIONS This License applies to any manual or other work, in any medium, that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License. Such a notice grants a world-wide, royalty-free license, unlimited in duration, to use that work under the conditions stated herein. The “Document”, below, refers to any such manual or work. Any member of the public is a licensee, and is addressed as “you”. You accept the license if you copy, modify or distribute the work in a way requiring permission under copyright law. A “Modified Version” of the Document means any work containing the Document or a portion of it, either copied verbatim, or with modifications and/or translated into another language. A “Secondary Section” is a named appendix or a front-matter section of the Document that deals exclusively with the relationship of the publishers or authors of the Document to the Document’s overall subject (or to related matters) and contains nothing that could fall directly within that overall subject. (Thus, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.) The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them. The “Invariant Sections” are certain Secondary Sections whose titles are designated, as being those of Invariant Sections, in the notice that says that the Document is released under this License. If a section does not fit the above definition of Secondary then it is not allowed to be designated as Invariant. The Document may contain zero Invariant Sections. If the Document does not identify any Invariant Sections then there are none. The “Cover Texts” are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is released under this License. A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words. A “Transparent” copy of the Document means a machine-readable copy, represented in a format whose specification is available to the general public, that is suitable for revising the document straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some widely available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text formatters. A copy made in an otherwise Transparent file format whose markup, or absence of markup, has been arranged to thwart or discourage subsequent modification by readers is not Transparent. An image format is not Transparent if used for any substantial amount of text. A copy that is not “Transparent” is called “Opaque”. Examples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input format, LaTeX input format, SGML or XML using a publicly available DTD, and standard-conforming simple HTML, PostScript or PDF designed for human modification. Examples of transparent image formats include PNG, XCF and JPG. Opaque formats include proprietary formats that can be read and edited only by proprietary word processors, SGML or XML for which the DTD and/or processing tools are not generally available, and the machine-generated HTML, PostScript or PDF produced by some word processors for output purposes only. The “Title Page” means, for a printed book, the title page itself, plus such following pages as are needed to hold, legibly, the material this License requires to appear in the title page. For works in formats which do not have any title page as such, “Title Page” means the text near the most prominent appearance of the work’s title, preceding the beginning of the body of the text. The “publisher” means any person or entity that distributes copies of the Document to the public. A section “Entitled XYZ” means a named subunit of the Document whose title either is precisely XYZ or contains XYZ in parentheses following text that translates XYZ in another language. (Here XYZ stands for a specific section name mentioned below, such as “Acknowledgements”, “Dedications”, “Endorsements”, or “History”.) To “Preserve the Title” of such a section when you modify the Document means that it remains a section “Entitled XYZ” according to this definition. The Document may include Warranty Disclaimers next to the notice which states that this License applies to the Document. These Warranty Disclaimers are considered to be included by reference in this License, but only as regards disclaiming warranties: any other implication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License.\n• VERBATIM COPYING You may copy and distribute the Document in any medium, either commercially or noncommercially, provided that this License, the copyright notices, and the license notice saying this License applies to the Document are reproduced in all copies, and that you add no other conditions whatsoever to those of this License. You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute. However, you may accept compensation in exchange for copies. If you distribute a large enough number of copies you must also follow the conditions in section 3. You may also lend copies, under the same conditions stated above, and you may publicly display copies.\n• COPYING IN QUANTITY If you publish printed copies (or copies in media that commonly have printed covers) of the Document, numbering more than 100, and the Document’s license notice requires Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover. Both covers must also clearly and legibly identify you as the publisher of these copies. The front cover must present the full title with all words of the title equally prominent and visible. You may add other material on the covers in addition. Copying with changes limited to the covers, as long as they preserve the title of the Document and satisfy these conditions, can be treated as verbatim copying in other respects. If the required texts for either cover are too voluminous to fit legibly, you should put the first ones listed (as many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages. If you publish or distribute Opaque copies of the Document numbering more than 100, you must either include a machine-readable Transparent copy along with each Opaque copy, or state in or with each Opaque copy a computer-network location from which the general network-using public has access to download using public-standard network protocols a complete Transparent copy of the Document, free of added material. If you use the latter option, you must take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at the stated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public. It is requested, but not required, that you contact the authors of the Document well before redistributing any large number of copies, to give them a chance to provide you with an updated version of the Document.\n• MODIFICATIONS You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it. In addition, you must do these things in the Modified Version:\n• Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from those of previous versions (which should, if there were any, be listed in the History section of the Document). You may use the same title as a previous version if the original publisher of that version gives permission.\n• List on the Title Page, as authors, one or more persons or entities responsible for authorship of the modifications in the Modified Version, together with at least five of the principal authors of the Document (all of its principal authors, if it has fewer than five), unless they release you from this requirement.\n• State on the Title page the name of the publisher of the Modified Version, as the publisher.\n• Preserve all the copyright notices of the Document.\n• Add an appropriate copyright notice for your modifications adjacent to the other copyright notices.\n• Include, immediately after the copyright notices, a license notice giving the public permission to use the Modified Version under the terms of this License, in the form shown in the Addendum below.\n• Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the Document’s license notice.\n• Include an unaltered copy of this License.\n• Preserve the section Entitled “History”, Preserve its Title, and add to it an item stating at least the title, year, new authors, and publisher of the Modified Version as given on the Title Page. If there is no section Entitled “History” in the Document, create one stating the title, year, authors, and publisher of the Document as given on its Title Page, then add an item describing the Modified Version as stated in the previous sentence.\n• Preserve the network location, if any, given in the Document for public access to a Transparent copy of the Document, and likewise the network locations given in the Document for previous versions it was based on. These may be placed in the “History” section. You may omit a network location for a work that was published at least four years before the Document itself, or if the original publisher of the version it refers to gives permission.\n• For any section Entitled “Acknowledgements” or “Dedications”, Preserve the Title of the section, and preserve in the section all the substance and tone of each of the contributor acknowledgements and/or dedications given therein.\n• Preserve all the Invariant Sections of the Document, unaltered in their text and in their titles. Section numbers or the equivalent are not considered part of the section titles.\n• Delete any section Entitled “Endorsements”. Such a section may not be included in the Modified Version.\n• Do not retitle any existing section to be Entitled “Endorsements” or to conflict in title with any Invariant Section. If the Modified Version includes new front-matter sections or appendices that qualify as Secondary Sections and contain no material copied from the Document, you may at your option designate some or all of these sections as invariant. To do this, add their titles to the list of Invariant Sections in the Modified Version’s license notice. These titles must be distinct from any other section titles. You may add a section Entitled “Endorsements”, provided it contains nothing but endorsements of your Modified Version by various parties—for example, statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard. You may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity. If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one. The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version.\n• COMBINING DOCUMENTS You may combine the Document with other documents released under this License, under the terms defined in section 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined work in its license notice, and that you preserve all their Warranty Disclaimers. The combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced with a single copy. If there are multiple Invariant Sections with the same name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number. Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work. In the combination, you must combine any sections Entitled “History” in the various original documents, forming one section Entitled “History”; likewise combine any sections Entitled “Acknowledgements”, and any sections Entitled “Dedications”. You must delete all sections Entitled “Endorsements.”\n• COLLECTIONS OF DOCUMENTS You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included in the collection, provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects. You may extract a single document from such a collection, and distribute it individually under this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document.\n• AGGREGATION WITH INDEPENDENT WORKS A compilation of the Document or its derivatives with other separate and independent documents or works, in or on a volume of a storage or distribution medium, is called an “aggregate” if the copyright resulting from the compilation is not used to limit the legal rights of the compilation’s users beyond what the individual works permit. When the Document is included in an aggregate, this License does not apply to the other works in the aggregate which are not themselves derivative works of the Document. If the Cover Text requirement of section 3 is applicable to these copies of the Document, then if the Document is less than one half of the entire aggregate, the Document’s Cover Texts may be placed on covers that bracket the Document within the aggregate, or the electronic equivalent of covers if the Document is in electronic form. Otherwise they must appear on printed covers that bracket the whole aggregate.\n• TRANSLATION Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section 4. Replacing Invariant Sections with translations requires special permission from their copyright holders, but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections. You may include a translation of this License, and all the license notices in the Document, and any Warranty Disclaimers, provided that you also include the original English version of this License and the original versions of those notices and disclaimers. In case of a disagreement between the translation and the original version of this License or a notice or disclaimer, the original version will prevail. If a section in the Document is Entitled “Acknowledgements”, “Dedications”, or “History”, the requirement (section 4) to Preserve its Title (section 1) will typically require changing the actual title.\n• TERMINATION You may not copy, modify, sublicense, or distribute the Document except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, or distribute it is void, and will automatically terminate your rights under this License. However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, receipt of a copy of some or all of the same material does not give you any rights to use it.\n• FUTURE REVISIONS OF THIS LICENSE The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. See https://www.gnu.org/copyleft/. Each version of the License is given a distinguishing version number. If the Document specifies that a particular numbered version of this License “or any later version” applies to it, you have the option of following the terms and conditions either of that specified version or of any later version that has been published (not as a draft) by the Free Software Foundation. If the Document does not specify a version number of this License, you may choose any version ever published (not as a draft) by the Free Software Foundation. If the Document specifies that a proxy can decide which future versions of this License can be used, that proxy’s public statement of acceptance of a version permanently authorizes you to choose that version for the Document.\n• RELICENSING “Massive Multiauthor Collaboration Site” (or “MMC Site”) means any World Wide Web server that publishes copyrightable works and also provides prominent facilities for anybody to edit those works. A public wiki that anybody can edit is an example of such a server. A “Massive Multiauthor Collaboration” (or “MMC”) contained in the site means any set of copyrightable works thus published on the MMC site. “CC-BY-SA” means the Creative Commons Attribution-Share Alike 3.0 license published by Creative Commons Corporation, a not-for-profit corporation with a principal place of business in San Francisco, California, as well as future copyleft versions of that license published by that same organization. “Incorporate” means to publish or republish a Document, in whole or in part, as part of another Document. An MMC is “eligible for relicensing” if it is licensed under this License, and if all works that were first published under this License somewhere other than this MMC, and subsequently incorporated in whole or in part into the MMC, (1) had no cover texts or invariant sections, and (2) were thus incorporated prior to November 1, 2008. The operator of an MMC Site may republish an MMC contained in the site under CC-BY-SA on the same site at any time before August 1, 2009, provided the MMC is eligible for relicensing.\n\nADDENDUM: How to use this License for your documents\n\nTo use this License in a document you have written, include a copy of the License in the document and put the following copyright and license notices just after the title page:\n\nIf you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace the “with…Texts.” line with this:\n\nIf you have Invariant Sections without Cover Texts, or some other combination of the three, merge those two alternatives to suit the situation.\n\nIf your document contains nontrivial examples of program code, we recommend releasing these examples in parallel under your choice of free software license, such as the GNU General Public License, to permit their use in free software.\n\nThis is a general index of all issues discussed in this manual, with the exception of the commands and command-line options.\n\nThis is an alphabetical list of all commands and command-line options."
    },
    {
        "link": "https://linode.com/docs/guides/manipulate-text-from-the-command-line-with-sed",
        "document": "This credit will be applied to any valid services used during your first days.\n\nThe traditional Unix utility makes it possible to manipulate strings and streams of text from the command line without using a text editing application. is useful in a number of different contexts, including finding and replacing strings of text in a large number of files, manipulating text for Stack Scripts and other kinds of scripts, as well as a component in basic shell scripting.\n\nThis document provides a gentle overview of usage, accompanied by a number of practical applications of . If you find this guide helpful, please consider our guide to basic administration practices or the rest of the Tools & Reference section.\n\nIn this guide, refers to recent versions of “GNU sed” which are included by default in all images provided by Linode, and as part of the common “base” selection of packages provided in nearly all distributions of Linux-based operating systems.\n\ncommands take a particular form. Consider the following example:\n\nThis command begins with the invocation ( ) followed by the option. allows sed to perform the modification “in place” on the file specified. The option forces to use an extended regular syntax. The next argument enclosed in single quotes (e.g. ) specifies the “substitution” or search and replace function. The final term of a command specifies the file object that the substitution function will be applied to.\n\ncan also be used to modify streams of text rather than files, so often a command might take the form of:\n\nIn this case, the contents of the stream of data which is created by running the command on the is filtered through the operation. The result is written to the . Generally, the left-hand side of the pipe would contain some other form of input, but you do not need to files into as the above command is equivalent to the following:\n\nUnless otherwise directed, will output the transformed text to standard output.\n\nThe basic form provides the core of functionality in common use. The indicates that the script will perform a substitution. The next character introduces a character to separate the “find” and “replace” strings and to terminate the substitution script. By convention the separation characters are characters, but in cases where you are searching for data that contains characters, it is possible to use another separating character. Thus, the following two strings are functionally identical:\n\nSed uses regular expressions in the “search” part of the substitution syntax. Most characters in regular expressions match with input data literally; however, there are some sequences that carry special significance. If you want to match these characters literally you can use the escape character to transform the next character into a literal match. Consider the following characters with special significance in substitution scripts:\n• The symbol causes the character immediately proceeding this character to successfully match to zero or more instances of that character in the data set.\n• The symbol causes the character immediately proceeding this character to successfully match to one or more instances of that character in the data set.\n• Square brackets ( ) enclose a set of characters that match against any member of the set of specified characters. When prefaced with a caret, as in , it matches none of the characters specified in the set.\n• Parenthetical characters (left or right ) both allow you to write more complex expressions and also create “captures” that allow you to use sequences from the matched text in the replacement string. Captured sequences are available in the order that they were captured with where corresponds to the number of the capture.\n• The character matches the beginning of a line.\n• The character matches the end of a line.\n• The character, as previously stated, escapes the following character for literal matching if it caries additional meaning.\n• The character provides an “OR” operator, so the sequence would match a line that began with the characters or .\n\nWhile these characters provide the foundation of writing matching patterns, there are other significant characters and powerful matching abstractions. Documenting the full capabilities of the regular expression syntax is beyond the scope of this guide; however you can learn more about commands using the command.\n\nFinding and Replacing Strings within files Using Sed\n\nIn some cases, the “in place” substitution with the argument provides the desired behavior. However, if you want to test a sed operation, or provide a “safety net”, consider the following command:\n\nIn this case, the existing file is copied to and the replacements are made automatically to . If you want to reverse the changes, issue a command similar to .\n\nThe option appended to the substitution statement sets a “global” mode that forces to replace multiple instances of the match on the same line.\n\nIt’s possible to use to modify streams of text in shell scripts. Consider the following bash function:\n\nWhen this function is called, the following operations are performed: for every item (the file names in the current directory,) the move command ( ) is issued with the existing file name and the old file name filtered through a function. The function matches for the string of characters at the end of the file name, and replaces that with . If the sed script fails to match, the original file name will be output and the move will fail.\n\nConsider the following expression:\n\nIn this command, the 56th line of the ssh “known hosts” file will be deleted. Commands in this form are useful for deleting a host key for a host that has changed from the file, as is the case after redeploying a system or moving an IP or domain to a new host.\n\nYou may wish to consult the following resources for additional information on this topic. While these are provided in the hope that they will be useful, please note that we cannot vouch for the accuracy or timeliness of externally hosted materials."
    },
    {
        "link": "https://pubs.opengroup.org/onlinepubs/009695299/utilities/sed.html",
        "document": ""
    },
    {
        "link": "https://docs.rockylinux.org/books/sed_awk_grep/3_sed_command",
        "document": "Working principle: The command will read the currently processed row and place it in the \"pattern space\" for processing. After processing, the result will be output and the \"pattern space\" will be cleared. Next, read the next line and place it in the \"pattern space\" for processing, and so on, until the last line. Some documents also mention a term called \"hold space\" (also known as \"temporary-storage space\"), which can temporarily store some processed data and output it through \"pattern space\".\n\n\"pattern space\" and \"hold space\": An area of memory where data is processed and stored.\n\nFor information not covered, review the manual.\n\nThe usage of the command is:\n• None As we all know, double and single quotation marks in a shell play different roles. The $, `, and \\ in double quotes have a special meaning. The recommendation is to use single quotes more often when using the command.\n• Print the text from lines 23 to 26 Shell > cat -n /etc/services sed -n # Note that it is presently the policy of IANA to assign a single well-known # even if the protocol doesn't support UDP operations. # are included, only the more common ones. # The latest IANA port assignments can be gotten from # The Well Known Ports are those from 0 through 1023. # The Dynamic and/or Private Ports are those from 49152 through 65535 # Each line describes one service, and is of the form: ...\n• Print line 10 to the last line Shell > cat -n /etc/services sed -n # Updated from RFC 1700, ``Assigned Numbers'' (October 1994). Not all ports # are included, only the more common ones. # The latest IANA port assignments can be gotten from # The Well Known Ports are those from 0 through 1023. # The Registered Ports are those from 1024 through 49151 # The Dynamic and/or Private Ports are those from 49152 through 65535 ...\n• Lines 10 to the last do not print Shell > cat -n /etc/services sed -n # Note that it is presently the policy of IANA to assign a single well-known # port number for both TCP and UDP; hence, most entries here have two entries # even if the protocol doesn't support UDP operations.\n• Print the line number and content of the matched string Start of range: Match the line where the string is located, only matching the first string that appears. End of range: Match the line where the string is located, only matching the first string that appears. In other words, the content printed above is lines 123 to 129\n• Print the line where the string is located and until the last line\n• None It is similar to printing, except that the operation command is replaced with and the -n option is not required.\n• Delete all lines that match the udp string, and delete all comment lines, and delete all Blank line Shell > cat -n /etc/services sed # Note that it is presently the policy of IANA to assign a single well-known # port number for both TCP and UDP; hence, most entries here have two entries # even if the protocol doesn't support UDP operations.\n• None s: All lines representing the content of the file. You can also specify the range of lines, for example: \n\ng (Global): If there is no g, This means that when multiple matching strings appear on a single line, only the first matching string will be replaced.\n\n/: Delimiter style. You can also specify other styles, for example: Example in the bash script:\n• Use the \"&\" symbol to reference a string\n• Use a string to locate one or more lines and replace the specified string within the line range In regular expressions, a \"()\" is a grouping. \\1 represents reference group 1, \\2 represents reference group 2, and so on.\n• Replace one of the lowercase letters of a word with a capital letter We can divide this file into five parts:\n• None The following example:\n• None Add content above or below a specific line ( and )\n• Add two lines of content above the specified line number\n• Add three lines below the specified line number\n• Match a specific line based on a string and add 2 lines of content above it\n• None\n• Locate one or more lines based on a string and replace these lines of text\n• None Read the contents of the file and append its contents below the matching line ( )\n• None Read/append the next line of input into the \"pattern space\" ( and )\n• Print the next line of the matching line Multiple operation commands may affect each other, and you can use \"{ }\" to reduce this effect. First, read the first line, as an n command is present; the second line will be printed out, and so on. Read the first line and append one line after encountering the command. In this example, the \"pattern space\" is \"1\n\n2\". Finally, execute the command to exit. Because there is no additional line after line 9, the output is as follows: When the last line is read, the command is not executed and the output is as follows: Merge two lines into one line. Replace the \"\n\n\" of the \"pattern space\" with a blank character.\n• None There seems to be no information about ignoring case in .\n• None Gets the total number of lines in a file"
    },
    {
        "link": "https://stackoverflow.com/questions/12696125/sed-edit-file-in-place",
        "document": "How do I edit a file in a single command? Currently, I have to manually stream the edited content into a new file and then rename the new file to the original file name. I tried , but my Solaris system said that is an illegal option. Is there a different way?"
    },
    {
        "link": "https://stackoverflow.com/questions/2585438/redirect-output-from-sed-s-c-d-myfile-to-myfile",
        "document": "I am using sed in a script to do a replace and I want to have the replaced file overwrite the file. Normally I think that you would use this:\n\nHowever as you can see my sed does not have that command.\n\nBut this just turns manipulate into an empty file (makes sense).\n\nBut I was wondering if there was a standard way to redirect output into the same file that input was taken from."
    },
    {
        "link": "https://unix.stackexchange.com/questions/207893/how-to-use-sed-command-to-modify-a-files-entry-line-by-line-in-shell-script",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://learnbyexample.github.io/learn_gnused/in-place-file-editing.html",
        "document": "In the examples presented so far, the output from was displayed on the terminal or redirected to another file. This chapter will discuss how to write back the changes to the input files using the command line option. This option can be configured to make changes to the input files with or without creating a backup of original contents. When backups are needed, the original filename can get a prefix or a suffix or both. And the backups can be placed in the same directory or some other directory as needed.\n\nWhen an extension is provided as an argument to the option, the original contents of the input file gets preserved as per the extension given. For example, if the input file is and is used, the backup file will be named as .\n\nSometimes backups are not desirable. In such cases, you can use the option without an argument. Be careful though, as changes made cannot be undone. It is recommended to test the command with sample inputs before applying the option on the actual file. You could also use the option with backup, compare the differences with a program and then delete the backup.\n\nMultiple input files are treated individually and the changes are written back to respective files.\n\nA character in the argument to the option is special. It will get replaced with the input filename. This is helpful if you need to use a prefix instead of a suffix for the backup filename. Or any other combination that may be needed.\n\nThe trick can also be used to place the backups in another directory instead of the parent directory of input files. The backup directory should already exist for this to work.\n\nThis chapter discussed about the option which is useful when you need to edit a file in-place. This is particularly useful in automation scripts. But, do ensure that you have tested the command before applying to actual files if you need to use this option without creating backups. In the next chapter, you'll learn filtering features of and how that helps to apply commands to only certain input lines instead of all the lines.\n\n1) For the input file , replace all occurrences of with and write back the changes to itself. The original contents should get saved to\n\n2) For the input file , replace all occurrences of with and write back the changes to itself. Do not create backups for this exercise. Note that you should have solved the previous exercise before starting this one.\n\n3) For the input file , replace with and write back the changes to itself. The original contents should get saved to\n\n4) In the code sample shown below, two files are created by redirecting the output of the command. Then a command is used to edit in-place as well as create a backup named . Will the command work as expected? If not, why?\n\n5) For the input file , remove the first occurrence of from each line and write back the changes to itself. The original contents should get saved with the same filename inside the directory. Assume that you do not know whether exists or not in the current working directory."
    },
    {
        "link": "https://redhat.com/en/blog/manipulating-text-sed",
        "document": "In a previous article, I covered how to manipulate text with . Now, turn your attention to the (Stream Editor), which is best suited to be used in pipelines (data that comes from a pipe). The utility can be used to print the contents of a file, substitute a line (or multiple lines), and then save the file. In contrast to , can substitute a line or multiple lines in a file and perform an in-place update of that file.\n\nThe simplest invocation when substituting for is:\n\nWhile can format output on screen, it is unable to modify a file in place. To do this, you’d need a file editor like . Since is not part of this article, use to achieve the same thing you did with in the previous article's first example. This time modify the file in-place passing the flag to . Without the flag , you'd only see what would have been modified.\n\nYou are encouraged to always run without the flag, just to make sure that the result it produces is expected. The utility also offers the flag, which creates a backup file before editing.\n\nThe final command for this example was:\n\nWith , you have:\n\nIn the example, you printed only usernames from the file with the following:\n\nYou can do the same using as follows:\n\nIn the above example, you group a match by parentheses , and then print the matched group with (back-reference), which dictates the first group. For a second group, you’d use , and so on.\n\nExample: Replace all with\n\nIn , you can search for a pattern and then replace only the occurrence matching the pattern. To replace all occurrences in the file from to globally, run:\n\nTake the file , which has the following contents:\n\nSay that you want to replace with , but only for the second line. This command breaks down as follows:\n\nThis output is sent to standard output rather than replacing the file's contents. The result looks like this:\n\nThe command is case-sensitive. The following won’t work when you try to replace with :\n\nGNU introduced a new flag, , which ignores the case and will perform the replacement with the same command:\n\nExample: Print a range of lines and quit\n\nWith , you can also print lines and quit after your criteria are met. The following commands will print three lines and quit. This command:\n\nThe following would be wrong:\n\nRegular expressions can also be used with , as demonstrated earlier. For example, you have the following small script:\n\nYou now have to skip the first line, starting with , and comment out the third and fourth lines, but not the fifth because that line is already commented.\n\nIn , you can use something like the following:\n\nIn the above command, the following is performed:\n• defines a range, from line three down to line six.\n• matches everything that is a character and does not start with a hash ( ).\n• replaces a part, in this case it puts a in front of the line dictated by the sign.\n\nDifferent applications generate data in different formats. With , you can keep only the data you can use. For example, you have the following file ( ) in this format:\n\nMaybe a program generated the wrong format, or it concatenated the fields to one. What if you were only interested in keeping the alpha characters and wanted to discard the digits? How would you achieve this goal with ?\n\nThe answer is probably easier than you think:\n\nFurthermore, can also handle ranges by pattern, which means you can specify a start and an end string and manipulate the range. For example:\n\nThe following command will comment lines starting with start and ending with end:\n\nGet rid of the empty lines as well.\n\nThere is much more to and its rich features. To be able to fully utilize ’s abilities, please see its documentation page, which you can find here. Also, a great source of information on can be found here.\n\nAs I covered previously, you'll use when you want to search for a pattern, either in a file or multiple directories recursively. Use if you are receiving data from a pipeline, or want to manipulate data on the fly.\n\nThe command is scripted and it’s easy to learn to perform basic operations. All you need is practice, especially with regular expressions."
    },
    {
        "link": "https://geeksforgeeks.org/sed-command-in-linux-unix-with-examples",
        "document": "The SED (Stream Editor) command is one of the most powerful tools used during text processing in Linux/Unix systems. The SED command is generally used to perform tasks such as search and replace, text manipulation, and stream editing.\n\nUsing SED, you can easily handle text files without opening them in an editor, and that’s what makes it a perfect choice to edit batch files, manage log files, and perform quick transformations on large files.\n\nIn this guide, we will walk you through the SED command syntax, use cases and most commonly used SED options to help you master this power tool. You’ll also learn how to securely manipulate text, replace strings, delete lines, and automate tasks seamlessly in Linux/Unix environments.\n\nWhat is the Sed Command\n\nThe SED command (Stream Editor) is a text manipulation tool used to perform basic text transformations and advanced operations such as find and replace, text insertion, deletion, and substitution. It is commonly used in bscripts to automate tasks (such as file editing).\n\nThe basic syntax for using the SED command in Linux is:\n• ‘OPTIONS’: These are optional flags that modify the behavior of the sed command.\n• ‘COMMAND’ : This defines the command or sequence of commands to execute on the input file.\n• ‘INPUTFILE’ : One or more input files to be processed.\n\nBelow are some of the most frequently used SED command options, let’s check them out:\n\nHere are some basic SED commands that will help you get started with text manipulation.\n\nConsider the below text file as an input.\n\nReplacing or substituting string: Sed command is mostly used to replace the text in a file. The below simple sed command replaces the word “unix” with “linux” in the file.\n\nHere the “s” specifies the substitution operation. The “/” are delimiters. The “unix” is the search pattern and the “linux” is the replacement string. By default, the sed command replaces the first occurrence of the pattern in each line and it won’t replace the second, third…occurrence in the line.\n\n2. Replacing the nth Occurrence of a Pattern in a Line\n\nTo replace only the nth occurance of a word in a line, use the following syntax:\n\nUse the ‘/1’, ‘/2’ etc. flags to replace the first, second occurrence of a pattern in a line. The below command replaces the second occurrence of the word “unix” with “linux” in a line.\n\n3. Replacing all the Occurrence of the Pattern in a Line\n\nHere, we will use the g flag to replace all the occurances of a pattern in a line. Let’s check out the syntax below:\n\nThe substitute flag /g (global replacement) specifies the sed command to replace all the occurrences of the string in the line.\n\n4. Replacing from nth Occurrence to all Occurrences in a Line\n\nUse the combination of /1, /2 etc and /g to replace all the patterns from the nth occurrence of a pattern in a line. The following sed command replaces the third, fourth, fifth… “unix” word with “linux” word in a line.\n\n5. Parenthesize First Character of Each Word\n\nThis sed example prints the first character of every word in parenthesis.\n\nYou can restrict the sed command to replace the string on a specific line number. An example is\n\nThe above sed command replaces the string only on the third line.\n\nThe /p print flag prints the replaced line twice on the terminal. If a line does not have the search pattern and is not replaced, then the /p prints that line only once.\n\nUse the -n option along with the /p print flag to display only the replaced lines. Here the -n option suppresses the duplicate rows generated by the /p flag and prints the replaced lines only one time.\n\nIf you use -n alone without /p, then the sed does not print anything.\n\nYou can specify a range of line numbers to the sed command for replacing a string.\n\nHere the sed command replaces the lines with range from 1 to 3. Another example is\n\nHere $ indicates the last line in the file. So the sed command replaces the text from second line to last line in the file.\n\nSED command can also be used for deleting lines from a particular file. SED command is used for performing deletion operation without even opening the file\n\n1. To Delete a particular line say n in this example\n\n3. To Delete line from range x to y\n\n4. To Delete from nth to last line\n\nBelow are some of the advanced SED commands that can be used for handling various editing tasks. let’s check them out:\n\nSED supports regular expressions that allows it to handle more complex pattern matching. To enable regular expressions, you need to use -r option.\n\nHere, we have matched any word start with ‘u’ and replacing it with “Linux”. Let’s check this out in the provided syntax below:\n\nYou can use this option to insert any text before or after any specific line. Here’s the syntax provided below:\n\nExample: To insert a new line before line2 in geekfile.txt\n\n1. Ensure to back up your files before applying for the changes. (especially while using -i)\n\n2. Be cautious before using the extended reular expressions to avoid any unintended substitutions.\n\n3. Always test your SED command on sample file first (to avoid unintentional changes).\n\nThe SED command in Linux/Unix is a versatile and powerful tool for automating text editing tasks, from simple find-and-replace operations to more complex pattern matching. Whether you’re working with a single file or need to process multiple files in a script, sed offers an efficient solution for text manipulation.\n\nBy using the above provided examples of basic and advanced, you can easily utilize the full capacity of SED to manipulate and process text files directly.\n\nWhat is the\n\nWhat are examples of\n\nWhat is the correct syntax for using\n\nHow to use\n\nWhat is the purpose of\n\nHow to use SED to replace text in a file?"
    },
    {
        "link": "https://digitalocean.com/community/tutorials/linux-sed-command",
        "document": "The (Stream Editor) command in Linux is a powerful utility for text manipulation. It enables users to perform various operations such as searching, replacing, inserting, and deleting text in files. This tutorial provides a comprehensive guide to mastering the command with practical examples, syntax explanations, and advanced use cases.\n\nWhat is the sed Command?\n\nThe command is a stream editor that processes text in a line-by-line fashion. This allows you to modify file content without directly opening the file in a text editor. It is widely used in shell scripting and system administration to automate text-processing tasks.\n\n1.Pattern matching and replacement 2.In-place file editing 3.Text filtering and manipulation 4.Support for regular expressions 5.Multiline operations\n\nThe basic syntax of the command consists of three main components: the command options, a script defining the editing instructions, and the file to be processed.\n\nThis structure allows users to specify the command’s behavior, define the text transformations, and apply them to the desired file.\n• Command Options: These are used to specify the command’s behavior. For example, the option is used for in-place file editing i.e to overwrite the file.\n• Script: The script defines the editing instructions. It can be enclosed in single quotes ( ) or double quotes ( ). The script can contain one or more editing commands, each separated by a semicolon ( ).\n• Input File: This is the file to be processed. It can be a single file or a list of files separated by spaces. If no file is specified, reads from the standard input.\n\nThe basic syntax of the command is as follows:\n\nIn this syntax, is the command, is the command options, contains the editing commands, and is the file to be processed.\n\nYou will understand it better with the examples below.\n\nThis replaces the first occurrence of “hello” with “world” in each line of .\n\nMost Common Use Cases of\n\nBelow are some of the most practical use cases of the command.\n\nFirst, let’s create a sample text file and write the below text to it, for ease of understanding and follow along-\n\nIn the below command the specifies the substitution operation and the are delimiters. The is the search pattern and the is the replacement string.\n\nThis command replaces the first occurrence of “Linux” with “Unix” in each line.\n\nThe substitute flag (global replacement) specifies the command to replace all the occurrences of the string in the line.\n\nThis command replaces all occurrences of “Linux” with “Unix” in each line.\n\nThe `-i enables in-place editing of the file. In simple words it overwrites the file.\n\nThis command edits the file in place, replacing “Linux” with “Unix” directly in . Without , the insertion occurs only in the output and doesn’t modify the file content. To make the change persistent, you need to use the option.\n\nThis command will delete the second line from .\n\nThe suppresses automatic printing of pattern space and is the print command.\n\nThis command prints lines 1 through 2 from .\n\nThe matches lines containing the pattern and the flag deletes matched lines.\n\nThis command will delete all the lines containing the word “kernel”.\n\nThe below command will replace all the instances of “Unix” with “Linux” and create a backup file named with older file content before replacing. The enables in-place editing and creates a backup file.\n\nAnd, here is the file content of the backup file .\n\nThe below command will replace each tab character with four spaces. The flag matches tab characters and the flag is for the global replacement across the line.\n\nThe below command will delete all the empty lines from . The matches empty lines and flag deletes matched lines.\n\nYou can edit the file using text editor and add some empty lines to test this command.\n\nThe below command prints only the lines containing “Ubuntu”.\n\nThe option suppresses automatic printing. matches lines containing the pattern. and the prints matched lines.\n\nThis section consists of some advanced and more complicated use cases of the command.\n\nThe below command inserts “This is inserted text.” before the second line in .\n\nThe option is for in-place editing and the flag inserts text before the 2nd line.\n\nReplacing the nth occurrence of a pattern in a line\n\nUse the or flags to replace the first, second occurrence of a pattern in a line. The below command replaces the second occurrence of the word “Linux” with “Unix” in a line.\n\nThe below command appends “This is appended text.” after the third line in . THe option makes sure the changes are saved and the appends text after the specified third line.\n\nReplace String at the Beginning of a Line\n\nThe flag is used to match a specific pattern at the start of a line. The below command replaces “Linux” with “Unix” only if “Linux” appears at the start of a line.\n\nReplace String at the End of a Line\n\nThe below command replaces “distros.” with “distributions” only if it appears at the end of a line. The flag is used to match a specific pattern to the end of a line.\n\nThe below command replaces “linux” with “Unix” ignoring case sensitivity. The flag makes the match case-insensitive.\n\nThe below command prints all lines between “inserted” and “appended”, inclusive.\n• : Range operator to match lines between two patterns.\n\nAnd the option to suppress automatic printing of lines.\n\nThe following command replaces “Linux” with “Unix” in both and and overwrites the file.\n\nThe below command adds line numbers to non-empty lines in .\n• : Appends the next line to the pattern space.\n\nYou can restrict the command to replace the string on a specific line number. The below command replaces the string “distros” with “distributions” only on the third line.\n\nYou can also specify a range of line numbers to the command for replacing a string. The below command replaces only the first occurences of “Linux” with “Unix” between lines 1 to 3.\n\nProcessing large files with can become resource-intensive, especially when dealing with numerous operations or very large datasets. Here are some tips to optimize performance and ensure efficient use of the command:\n\n1.Use to minimize unnecessary output - The option suppresses automatic printing of each line and ensures only the desired output is displayed. This reduces overhead when working with large files.\n\n2.Simplify Scripts - Minimize the number of operations in a single command. For instance, instead of applying multiple commands sequentially, combine them into a single script to reduce file reads.\n\n3.Stream Input with Pipes: - When processing data from other commands or streams, use pipes to avoid intermediate file creation and reduce disk I/O.\n\n4.Avoid In-Place Editing on Large Files - Instead of directly modifying large files, write output to a new file and replace the original after verifying correctness.\n\n5.Benchmark Alternatives - For very large files, consider using tools like , , or , which may offer better performance for certain tasks.\n\nYou can refer to these tutorials on AWK command in Linux and How To Use the AWK language to Manipulate Text in Linux to learn more about using command in linux.\n\nThe command is commonly used in shell scripts to automate repetitive text manipulation tasks. Here’s an example:\n\nThis script processes and writes the modified output to .\n\nWhile is an effective and lightweight tool for basic text processing, modern alternatives such as and offer additional functionality, making them better suited for specific tasks. Here’s a breakdown of key differences and when to use each:\n\nWhen to Use\n\nWhen to Use\n• Handling structured data such as CSV or TSV files.\n\nThis extracts and prints the first and third fields from a CSV file.\n\nWhen to Use\n\nThis adds a “WARNING:” prefix to lines containing the word “error”.\n\nMastering the command enhances your ability to manipulate and process text efficiently in Linux. Its powerful features and seamless integration into scripts make it a valuable tool for text-based manipulation tasks.\n\nAfter mastering the basics of , you can learn more advanced techniques and use cases. You can use the below series of tutorials on and related topics that can help you deepen your understanding and improve your text processing skills:\n• The Basics of Using the Stream Editor to Manipulate Text in Linux\n\nThese tutorials cover various topics, from basic operations to more complex text manipulation techniques. They are a valuable resource for anyone looking to become proficient in text processing on the command line.\n\nWhat is command in Linux?\n\nThe (Stream Editor) command in Linux is a powerful text processing tool used to perform basic text transformations on an input stream (a file or input from a pipeline). It allows you to search, replace, delete, and insert text, making it highly useful for automating text manipulation tasks.\n\nWhen to use ?\n\nYou can use in the following scenarios:\n• Text Replacement: Replace words, phrases, or patterns in files or streams.\n• Batch Processing: Perform the same operation on multiple files using scripts.\n• Text Insertion/Extraction: Insert or extract specific text in structured files like configuration files or logs.\n\nHow to use properly?\n\nTo use effectively, follow these steps:\n• : The operation (e.g., for substitute, for delete).\n\nTest Before Applying In-place: First, run the command without the ’ option to see the output before modifying files directly.\n\nUse Regular Expressions: Leverage sed’s support for regular expressions to match and manipulate complex patterns.\n\nChain Multiple Commands: Use or to execute multiple commands in a single operation.\n\nHow to use sed to replace text?\n\nTo replace text, use the substitute command with this syntax:\n• Replace the first occurrence of “foo” with “bar” on each line:\n• Replace all occurrences of “foo” with “bar” globally:\n\nYou can run a command directly from the terminal using this basic syntax:\n\nTo print lines containing the word “error” and replace “error” with “warning” in a file named :\n\nWhat is the difference between and commands in Linux?\n• Using to search for “error” in :\n• Using to replace “error” with “warning” in :\n\nHow to remove an empty line using ?\n\nTo remove empty lines from a file, use the following command:\n\nBefore running the command, a file might look like this:\n\nThe output will be:"
    },
    {
        "link": "https://medium.com/@saikumaresh/a-comprehensive-guide-to-the-sed-command-in-linux-%EF%B8%8F-db4c38150ec7",
        "document": "The (Stream Editor) command is one of the most powerful and frequently used utilities in Unix/Linux for text manipulation. Whether you're working with large text files, system logs, or configuration files, helps automate the editing of text by applying operations directly to streams of data. In this blog, we'll dive deep into the basics, syntax, and usage of , including practical examples to help you master this command.\n\nstands for Stream Editor. It is used for transforming text in a file or input stream through a series of commands. Unlike other text editors, operates in a non-interactive manner, making it useful for batch processing and automation. It processes text line by line, allowing users to perform substitutions, deletions, insertions, and other manipulations.\n\nThe basic syntax of the command is:\n• : Additional options to modify the behavior of (e.g., for in-place editing).\n• : The operation or set of operations to perform on the text.\n• : The input file on which the command will operate. If no file is provided, processes…"
    },
    {
        "link": "https://computerhope.com/unix/used.htm",
        "document": "On Unix-like operating systems, sed is a stream editor: it filters and transforms text.\n\nThis page covers the GNU/Linux version of sed.\n\nThe sed stream editor performs basic text transformations on an input stream (a file, or input from a pipeline). While in some ways similar to an editor which permits scripted edits (such as ed), sed works by making only one pass over the input(s), and is consequently more efficient. But it is sed's ability to filter text in a pipeline which particularly distinguishes it from other types of editors.\n\nIf you do not specify INPUTFILE, or if INPUTFILE is \"-\", sed filters the contents of the standard input. The script is actually the first non-option parameter, which sed specially considers a script and not an input file if and only if none of the other options specifies a script to be executed (that is, if neither of the -e and -f options is specified).\n\nA sed program consists of one or more sed commands, passed in by one or more of the -e, -f, --expression, and --file options, or the first non-option argument if none of these options are used. This documentation frequently refers to \"the\" sed script; this should be understood to mean the in-order catenation of all of the scripts and script-files passed in.\n\nCommands within a script or script-file can be separated by semicolons (\";\") or newlines (ASCII code 10). Some commands, due to their syntax, cannot be followed by semicolons working as command separators and thus should be terminated with newlines or be placed at the end of a script or script-file. Commands can also be preceded with optional non-significant whitespace characters.\n\nEach sed command consists of an optional address or address range (for instance, line numbers specifying what part of the file to operate on; see selecting lines for details), followed by a one-character command name and any additional command-specific code.\n\nsed maintains two data buffers: the active pattern space, and the auxiliary hold space. Both are initially empty.\n\nsed operates by performing the following cycle on each line of input: first, sed reads one line from the input stream, removes any trailing newline, and places it in the pattern space. Then commands are executed; each command can have an address associated to it: addresses are a kind of condition code, and a command is only executed if the condition is verified before the command is to be executed.\n\nWhen the end of the script is reached, unless the -n option is in use, the contents of pattern space are printed out to the output stream, adding back the trailing newline if it was removed. Then the next cycle starts for the next input line.\n\nUnless special commands (like 'D') are used, the pattern space is deleted between two cycles. The hold space, on the other hand, keeps its data between cycles (see commands 'h', 'H', 'x', 'g', 'G' to move data between both buffers).\n\nAddresses in a sed script can be in any of the following forms:\n\nIf no addresses are given, then all lines are matched; if one address is given, then only lines matching that address are matched.\n\nAn address range can be specified by specifying two addresses separated by a comma (\",\"). An address range matches lines starting from where the first address matches, and continues until the second address matches (inclusively).\n\nIf the second address is a regexp, then checking for the ending match starts with the line following the line which matched the first address: a range always spans at least two lines (except of course if the input stream ends).\n\nIf the second address is a number less than (or equal to) the line matching the first address, then only the one line is matched.\n\nGNU sed also supports some special two-address forms; all these are GNU extensions:\n\nAppending the ! character to the end of an address specification negates the sense of the match. That is, if the ! character follows an address range, then only lines which do not match the address range will be selected. This also works for singleton addresses, and, perhaps perversely, for the null address.\n\nTo know how to use sed, understand regular expressions (\"regexp\" for short). A regular expression is a pattern that is matched against a subject string from left to right. Most characters are ordinary: they stand for themselves in a pattern, and match the corresponding characters in the subject. As a simple example, the pattern\n\n...matches a portion of a subject string that is identical to itself. The power of regular expressions comes from the ability to include alternatives and repetitions in the pattern. These are encoded in the pattern by the use of special characters, which do not stand for themselves but instead are interpreted in some special way. Here is a brief description of regular expression syntax as used in sed:\n\nNote that the regular expression matcher is greedy, i.e., matches are attempted from left to right and, if two or more matches are possible starting at the same character, it selects the longest.\n\nIf you use sed at all, you will probably want to know these commands.\n\nThe syntax of the s command (which stands for \"substitute\") is: 's/regexp/replacement/flags'. The / characters may be uniformly replaced by any other single character within any given s command. The / character (or whatever other character is used in its stead) can appear in the regexp or replacement only if it's preceded by a \\ character.\n\nThe s command is probably the most important in sed and has a lot of different options. Its basic concept is simple: the s command attempts to match the pattern space against the supplied regexp; if the match is successful, then that portion of the pattern space which was matched is replaced with replacement.\n\nThe replacement can contain \n\n (n being a number from 1 to 9, inclusive) references, which refer to the portion of the match that is contained between the nth \\( and its matching \\). Also, the replacement can contain unescaped & characters which reference the whole matched portion of the pattern space. Finally, as a GNU sed extension, you can include a special sequence made of a backslash and one of the letters L, l, U, u, or E. The meaning is as follows:\n\nTo include a literal \\, &, or newline in the final replacement, precede the desired \\, &, or newline in the replacement with a \\.\n\nThe s command can be followed by zero or more of the following flags:\n\nThough perhaps less frequently used than those in the previous section, some very small yet useful sed scripts can be built with these commands.\n\nIn most cases, use of these commands indicates that you are probably better off programming in something like awk or Perl. But occasionally one is committed to sticking with sed, and these commands can enable one to write quite convoluted scripts.\n\nThese commands are specific to GNU sed, so you must use them with care and only when you are sure that the script doesn't need to be ported. They allow you to check for GNU sed extensions or do tasks that are required quite often, yet are unsupported by standard seds.\n\nUntil now (on this page, anyway), we have only encountered escapes of the form '\\^', for example, which tell sed not to interpret the circumflex (caret) as a special character, but rather to take it literally. For another example, '\\*' matches a single asterisk rather than zero or more backslashes.\n\nThis section introduces another kind of escape—that is, escapes that are applied to a character or sequence of characters that ordinarily are taken literally, and that sed replaces with a special character. This provides a way of encoding non-printable characters in patterns in a visible manner. There is no restriction on the appearance of non-printing characters in a sed script, but when a script is being prepared in the shell or by text editing, it is usually easier to use one of the following escape sequences than the binary character it represents:\n\n'\\b' (backspace) was omitted because of the conflict with the existing \"word boundary\" meaning.\n\nOther escapes match a particular character class and are valid only in regular expressions:\n\nHere are some sed scripts to guide you in the art of mastering sed.\n\nThis script centers all lines of a file on 80 columns width. To change that width, the number in \\{...\\} must be replaced, and the number of added spaces also must be changed.\n\nNote how the buffer commands are used to separate parts in the regular expressions to be matched, which is a common technique.\n\nThis script is one of a few that demonstrate how to do arithmetic in sed. This script is indeed possible, but must be done manually.\n\nTo increment one number you add 1 to last digit, replacing it by the following digit. There is one exception: when the digit is a nine the previous digits must be also incremented until you don't have a nine.\n\nThis solution is very clever and smart because it uses a single buffer; if you don't have this limitation, the algorithm used in Numbering Lines is faster. It works by replacing trailing nines with an underscore, then using multiple s commands to increment the last digit, and then again substituting underscores with zeros.\n\nThis script is a pretty strange use of sed. We transform text, and transform it to be shell commands, then feed them to shell. Don't worry, even worse hacks are done when using sed. Scripts have even been written converting the output of date into a bc program... So, stranger things have happened.\n\nThe main body of this is the sed script, which remaps the name from lower to upper (or vice versa) and even checks out if the remapped name is the same as the original name. Note how the script is parameterized using shell variables and proper quoting.\n\nThis script strips the definition of the shell functions from the output of the set command in the Bourne-Again shell (bash).\n\nThis script can reverse the position of characters in lines. The technique moves two characters at a time, hence it is faster than more intuitive implementations.\n\nNote the tx command before the definition of the label. This command is often needed to reset the flag that is tested by the t command.\n\nThis one begins a series of totally useless (yet interesting) scripts emulating various Unix commands. This, in particular, is a tac workalike.\n\nNote that on implementations other than GNU sed this script might easily overflow internal buffers.\n\nThis script replaces 'cat -n'; in fact it formats its output exactly like GNU cat does.\n\nOf course this is completely useless for two reasons: first, because somebody else did it in C (the cat command), and second, because the following Bourne-shell script could be used for the same purpose and would be much faster:\n\nIt uses sed to print the line number, then groups lines two by two using N. Of course, this script does not teach as much as the one presented below.\n\nThe algorithm used for incrementing uses both buffers, so the line is printed as soon as possible and then discarded. The number is split so that changing digits go in a buffer and unchanged ones go in the other; the changed digits are modified in a single step (using a y command). The line number for the next line is then composed and stored in the hold space, to be used in the next iteration.\n\nEmulating 'cat -b' is almost the same as 'cat -n': we only have to select which lines are to be numbered and which are not.\n\nThe part that is common to this script and the previous one is not commented to show how important it is to comment sed scripts properly...\n\nThis script shows another way to do arithmetic with sed. In this case, we have to add possibly large numbers, so implementing this by successive increments would not be feasible (and possibly even more complicated to contrive than this script).\n\nThe approach is to map numbers to letters, kind of an abacus implemented with sed. 'a's are units, 'b's are tens and so on: we add the number of characters on the current line as units, and then propagate the carry to tens, hundreds, and so on.\n\nAs usual, running totals are kept in hold space.\n\nOn the last line, we convert the abacus form back to decimal. For the sake of variety, this is done with a loop rather than with some 80 s commands: first we convert units, removing 'a's from the number; then we rotate letters so that tens become 'a's, and so on until no more letters remain.\n\nThis script is almost the same as the previous one, once each of the words on the line is converted to a single 'a' (in the previous script each letter was changed to an 'a').\n\nIt is interesting that real wc programs have optimized loops for 'wc -c', so they are much slower at counting words rather than characters. This script's bottleneck, instead, is arithmetic, and hence the word-counting one is faster (it has to manage smaller numbers).\n\nAgain, the common parts are not commented to show the importance of commenting sed scripts.\n\nSed gives us 'wc -l' functionality for free. Here is the code:\n\nThis script is probably the simplest useful sed script. It displays the first 10 lines of input; the number of displayed lines is right before the q command.\n\nPrinting the last n lines rather than the first is more complex but indeed possible. The n is encoded in the second line, before the bang (\"!\") character.\n\nThis script is similar to the tac script (above) in that it keeps the final output in the hold space and prints it at the end:\n\nMainly, the scripts keeps a window of 10 lines and slides it by adding a line and deleting the oldest (the substitution command on the second line works like a D command but does not restart the loop).\n\nThe \"sliding window\" technique is a very powerful way to write efficient and complex sed scripts, because commands like P would require a lot of work if implemented manually.\n\nTo introduce the technique, which is fully demonstrated in the rest of this chapter and is based on the N, P and D commands, here is an implementation of tail using a simple \"sliding window.\"\n\nThis looks complicated but in fact the working concept is the same as the last script: after we have kicked in the appropriate number of lines, however, we stop using the hold space to keep inter-line state, and instead use N and D to slide pattern space by one line:\n\nNote how the first, second and fourth line are inactive after the first ten lines of input. After that, all the script does is: exiting on the last line of input, appending the next input line to pattern space, and removing the first line.\n\nThis script is an example of the art of using the N, P and D commands, probably the most difficult to master.\n\nAs you can see, we maintain a 2-line window using P and D. This technique is often used in advanced sed scripts.\n\nThis script prints only duplicated lines, like 'uniq -d'.\n\nThis script prints only unique lines, like 'uniq -u'.\n\nAs a final example, here are three scripts, of increasing complexity and speed, that implement the same function as 'cat -s', that is squeezing blank lines.\n\nThe first leaves a blank line at the beginning and end if there are some already.\n\nThis one is a bit more complex and removes all empty lines at the beginning. It does leave a single blank line at end if one was there.\n\nThis removes leading and trailing blank lines. It is also the fastest. Note that loops are completely done with n and b, without relying on sed to restart the script automatically at the end of a line.\n\nFor those who want to write portable sed scripts, be aware that some implementations are known to limit line lengths (for the pattern and hold spaces) to be no more than 4000 bytes. The POSIX standard specifies that conforming sed implementations shall support at least 8192 byte line lengths. GNU sed has no built-in limit on line length; as long as it can allocate more (virtual) memory, you can feed or construct lines as long as you like.\n\nHowever, recursion is used to handle subpatterns and indefinite repetition. This indicates the available stack space may limit the size of the buffer that can be processed by certain patterns.\n\nThe only difference between basic and extended regular expressions is in the behavior of a few characters: '?', '+', parentheses, and braces ('{}'). While basic regular expressions require these to be escaped if you want them to behave as special characters, when using extended regular expressions you must escape them if you want them to match a literal character.\n\nDouble-spaces the contents of file myfile.txt, and writes the output to the file newfile.txt.\n\nPrefixes each line of myfile.txt with a line number, a period, and a space, and displays the output.\n\nSearches for the word \"test\" in myfile.txt and replaces every occurrence with the word \"example\".\n\nCounts the number of lines in myfile.txt and displays the results.\n\nawk — Interpreter for the AWK text processing programming language.\n\ned — A simple text editor.\n\ngrep — Filter text which matches a regular expression.\n\nreplace — A string-replacement utility."
    },
    {
        "link": "https://gnu.org/software/sed/manual/sed.html",
        "document": "is a stream editor. A stream editor is used to perform basic text transformations on an input stream (a file or input from a pipeline). While in some ways similar to an editor which permits scripted edits (such as ), works by making only one pass over the input(s), and is consequently more efficient. But it is ’s ability to filter text in a pipeline which particularly distinguishes it from other types of editors.\n\nThis chapter covers how to run . Details of scripts and individual commands are discussed in the next chapter.\n\nNormally is invoked like this:\n\nFor example, to replace all occurrences of ‘ ’ to ‘ ’ in the file :\n\nIf you do not specify , or if is , filters the contents of the standard input. The following commands are equivalent:\n\nwrites output to standard output. Use to edit files in-place instead of printing to standard output. See also the and commands for writing output to other files. The following command modifies and does not produce any output:\n\nBy default prints all processed input (except input that has been modified/deleted by commands such as ). Use to suppress output, and the command to print specific lines. The following command prints only line 45 of the input file:\n\ntreats multiple input files as one long stream. The following example prints the first line of the first file ( ) and the last line of the last file ( ). Use to reverse this behavior.\n\nWithout or options, uses the first non-option parameter as the , and the following non-option parameters as input files. If or options are used to specify a , all non-option parameters are taken as input files. Options and can be combined, and can appear multiple times (in which case the final effective will be concatenation of all the individual s).\n\nThe following examples are equivalent:\n\nThe full format for invoking is:\n\nmay be invoked with the following command-line options:\n\nIf no , , , or options are given on the command-line, then the first non-option argument on the command line is taken to be the to be executed.\n\nIf any command-line parameters remain after processing the above, these parameters are interpreted as the names of input files to be processed. A file name of ‘ ’ refers to the standard input stream. The standard input will be processed if no file names are specified.\n\nAn exit status of zero indicates success, and a nonzero value indicates failure. GNU returns the following exit status error values:\n\nAdditionally, the commands and can be used to terminate with a custom exit code value (this is a GNU extension):\n\nA program consists of one or more commands, passed in by one or more of the , , , and options, or the first non-option argument if zero of these options are used. This document will refer to “the” script; this is understood to mean the in-order concatenation of all of the s and s passed in. See Overview.\n\nis a single-letter command. is an optional line address. If is specified, the command will be executed only on the matched lines. can be a single line number, a regular expression, or a range of lines (see sed addresses). Additional are used for some commands.\n\nThe following example deletes lines 30 to 35 in the input. is an address range. is the delete command:\n\nThe following example prints all input until a line starting with the word ‘ ’ is found. If such line is found, will terminate with exit status 42. If such line was not found (and no other error occurred), will exit with status 0. is a regular-expression address. is the quit command. is the command option.\n\nCommands within a or can be separated by semicolons ( ) or newlines (ASCII 10). Multiple scripts can be specified with or options.\n\nThe following examples are all equivalent. They perform two operations: deleting any lines matching the regular expression , and replacing all occurrences of the string ‘ ’ with ‘ ’:\n\nCommands , , , due to their syntax, cannot be followed by semicolons working as command separators and thus should be terminated with newlines or be placed at the end of a or . Commands can also be preceded with optional non-significant whitespace characters. See Multiple commands syntax.\n\nThe following commands are supported in GNU . Some are standard POSIX commands, while other are GNU extensions. Details and examples for each command are in the following sections. (Mnemonics) are shown in parentheses.\n\nThe command (as in substitute) is probably the most important in and has a lot of different options. The syntax of the command is ‘ ’.\n\nIts basic concept is simple: the command attempts to match the pattern space against the supplied regular expression ; if the match is successful, then that portion of the pattern space which was matched is replaced with .\n\nFor details about syntax see Regular Expression Addresses.\n\nThe can contain ( being a number from 1 to 9, inclusive) references, which refer to the portion of the match which is contained between the th and its matching . Also, the can contain unescaped characters which reference the whole matched portion of the pattern space.\n\nThe characters may be uniformly replaced by any other single character within any given command. The character (or whatever other character is used in its stead) can appear in the or only if it is preceded by a character.\n\nFinally, as a GNU extension, you can include a special sequence made of a backslash and one of the letters , , , , or . The meaning is as follows:\n\nWhen the flag is being used, case conversion does not propagate from one occurrence of the regular expression to another. For example, when the following command is executed with ‘ ’ in pattern space:\n\nthe output is ‘ ’. When replacing the first ‘ ’, the ‘ ’ sequence only affects the empty replacement of ‘ ’. It does not affect the character that is added to pattern space when replacing with .\n\nOn the other hand, and do affect the remainder of the replacement text if they are followed by an empty substitution. With ‘ ’ in pattern space, the following command:\n\nwill replace ‘ ’ with ‘ ’ (uppercase) and ‘ ’ with ‘ ’. If this behavior is undesirable, you can prevent it by adding a ‘ ’ sequence—after ‘ ’ in this case.\n\nTo include a literal , , or newline in the final replacement, be sure to precede the desired , , or newline in the with a .\n\nThe command can be followed by zero or more of the following :\n\nIf you use at all, you will quite likely want to know these commands.\n\nThough perhaps less frequently used than those in the previous section, some very small yet useful scripts can be built with these commands.\n\nIn most cases, use of these commands indicates that you are probably better off programming in something like or Perl. But occasionally one is committed to sticking with , and these commands can enable one to write quite convoluted scripts.\n\nThese commands are specific to GNU , so you must use them with care and only when you are sure that hindering portability is not evil. They allow you to check for GNU extensions or to do tasks that are required quite often, yet are unsupported by standard s.\n\nThere are several methods to specify multiple commands in a program.\n\nUsing newlines is most natural when running a sed script from a file (using the option).\n\nOn the command line, all commands may be separated by newlines. Alternatively, you may specify each command as an argument to an option:\n\nA semicolon (‘ ’) may be used to separate most simple commands:\n\nThe , , , , , commands can be separated with a semicolon (this is a non-portable GNU extension).\n\nLabels used in , , , commands are read until a semicolon. Leading and trailing whitespace is ignored. In the examples below the label is ‘ ’. The first example works with GNU . The second is a portable equivalent. For more information about branching and labels see Branching and flow control.\n\nThe following commands cannot be separated by a semicolon and require a newline:\n\nAddresses determine on which line(s) the command will be executed. The following command replaces the word ‘ ’ with ‘ ’ only on line 144:\n\nIf no addresses are given, the command is performed on all lines. The following command replaces the word ‘ ’ with ‘ ’ on all lines in the input file:\n\nAddresses can contain regular expressions to match lines based on content instead of line numbers. The following command replaces the word ‘ ’ with ‘ ’ only in lines containing the word ‘ ’:\n\nAn address range is specified with two addresses separated by a comma ( ). Addresses can be numeric, regular expressions, or a mix of both. The following command replaces the word ‘ ’ with ‘ ’ only in lines 4 to 17 (inclusive):\n\nAppending the character to the end of an address specification (before the command letter) negates the sense of the match. That is, if the character follows an address or an address range, then only lines which do not match the addresses will be selected. The following command replaces the word ‘ ’ with ‘ ’ only in lines not containing the word ‘ ’:\n\nThe following command replaces the word ‘ ’ with ‘ ’ only in lines 1 to 3 and 18 till the last line of the input file (i.e. excluding lines 4 to 17):\n\nAddresses in a script can be in any of the following forms:\n\nGNU supports the following regular expression addresses. The default regular expression is Basic Regular Expression (BRE). If or options are used, The regular expression should be in Extended Regular Expression (ERE) syntax. See BRE vs ERE.\n\nRegex addresses operate on the content of the current pattern space. If the pattern space is changed (for example with command) the regular expression matching will operate on the changed text.\n\nIn the following example, automatic printing is disabled with . The command changes lines containing ‘ ’ to ‘ ’. The command matches lines with digits and prints them. Because the second line is changed before the regex, it will not match and will not be printed:\n\nAn address range can be specified by specifying two addresses separated by a comma ( ). An address range matches lines starting from where the first address matches, and continues until the second address matches (inclusively):\n\nIf the second address is a , then checking for the ending match will start with the line following the line which matched the first address: a range will always span at least two lines (except of course if the input stream ends).\n\nIf the second address is a less than (or equal to) the line matching the first address, then only the one line is matched:\n\nGNU also supports some special two-address forms; all these are GNU extensions:\n\nTo know how to use , people should understand regular expressions (regexp for short). A regular expression is a pattern that is matched against a subject string from left to right. Most characters are ordinary: they stand for themselves in a pattern, and match the corresponding characters. Regular expressions in are specified between two slashes.\n\nThe following command prints lines containing the word ‘ ’:\n\nThe above example is equivalent to this command:\n\nThe power of regular expressions comes from the ability to include alternatives and repetitions in the pattern. These are encoded in the pattern by the use of special characters, which do not stand for themselves but instead are interpreted in some special way.\n\nThe character (caret) in a regular expression matches the beginning of the line. The character (dot) matches any single character. The following command matches and prints lines which start with the letter ‘ ’, followed by any single character, followed by the letter ‘ ’:\n\nThe following sections explain the meaning and usage of special characters in regular expressions.\n\nBasic and extended regular expressions are two variations on the syntax of the specified pattern. Basic Regular Expression (BRE) syntax is the default in (and similarly in ). Use the POSIX-specified option ( , ) to enable Extended Regular Expression (ERE) syntax.\n\nIn GNU , the only difference between basic and extended regular expressions is in the behavior of a few special characters: ‘ ’, ‘ ’, parentheses, braces (‘ ’), and ‘ ’.\n\nWith basic (BRE) syntax, these characters do not have special meaning unless prefixed with a backslash (‘ ’); While with extended (ERE) syntax it is reversed: these characters are special unless they are prefixed with backslash (‘ ’).\n\nHere is a brief description of regular expression syntax as used in .\n\nNote that the regular expression matcher is greedy, i.e., matches are attempted from left to right and, if two or more matches are possible starting at the same character, it selects the longest.\n\nThe only difference between basic and extended regular expressions is in the behavior of a few characters: ‘ ’, ‘ ’, parentheses, braces (‘ ’), and ‘ ’. While basic regular expressions require these to be escaped if you want them to behave as special characters, when using extended regular expressions you must escape them if you want them to match a literal character. ‘ ’ is special here because ‘ ’ is a GNU extension – standard basic regular expressions do not provide its functionality.\n\nA bracket expression is a list of characters enclosed by ‘ ’ and ‘ ’. It matches any single character in that list; if the first character of the list is the caret ‘ ’, then it matches any character not in the list. For example, the following command replaces the words ‘ ’ or ‘ ’ with ‘ ’:\n\nBracket expressions can be used in both basic and extended regular expressions (that is, with or without the / options).\n\nWithin a bracket expression, a range expression consists of two characters separated by a hyphen. It matches any single character that sorts between the two characters, inclusive. In the default C locale, the sorting sequence is the native character order; for example, ‘ ’ is equivalent to ‘ ’.\n\nFinally, certain named classes of characters are predefined within bracket expressions, as follows.\n\nThese named classes must be used inside brackets themselves. Correct usage:\n\nIncorrect usage is rejected by newer versions. Older versions accepted it but treated it as a single bracket expression (which is equivalent to ‘ ’, that is, only the characters ):\n\nNote that the brackets in these class names are part of the symbolic names, and must be included in addition to the brackets delimiting the bracket expression.\n\nThe characters , , , , and are normally not special within . For example, matches either ‘ ’ or ‘ ’, because the is not special here. However, strings like , , and are special within and represent collating symbols, equivalence classes, and character classes, respectively, and is therefore special within when it is followed by , , or . Also, when not in mode, special escapes like and are recognized within . See Escapes.\n\nThe following sequences have special meaning inside regular expressions (used in addresses and the command).\n\nThese can be used in both basic and extended regular expressions (that is, with or without the / options).\n\nback-references are regular expression commands which refer to a previous part of the matched regular expression. Back-references are specified with backslash and a single digit (e.g. ‘ ’). The part of the regular expression they refer to is called a subexpression, and is designated with parentheses.\n\nBack-references and subexpressions are used in two cases: in the regular expression search pattern, and in the part of the command (see Regular Expression Addresses and The \"s\" Command).\n\nIn a regular expression pattern, back-references are used to match the same content as a previously matched subexpression. In the following example, the subexpression is ‘ ’ - any single character (being surrounded by parentheses makes it a subexpression). The back-reference ‘ ’ asks to match the same content (same character) as the sub-expression.\n\nThe command below matches words starting with any character, followed by the letter ‘ ’, followed by the same character as the first.\n\nMultiple subexpressions are automatically numbered from left-to-right. This command searches for 6-letter palindromes (the first three letters are 3 subexpressions, followed by 3 back-references in reverse order):\n\nIn the command, back-references can be used in the part to refer back to subexpressions in the part.\n\nThe following example uses two subexpressions in the regular expression to match two space-separated words. The back-references in the part prints the words in a different order:\n\nWhen used with alternation, if the group does not participate in the match then the back-reference makes the whole match fail. For example, ‘ ’ will not match ‘ ’. When multiple regular expressions are given with or from a file (‘ ’), back-references are local to each expression.\n\nUntil this chapter, we have only encountered escapes of the form ‘ ’, which tell not to interpret the circumflex as a special character, but rather to take it literally. For example, ‘ ’ matches a single asterisk rather than zero or more backslashes.\n\nThis chapter introduces another kind of escape6—that is, escapes that are applied to a character or sequence of characters that ordinarily are taken literally, and that replaces with a special character. This provides a way of encoding non-printable characters in patterns in a visible manner. There is no restriction on the appearance of non-printing characters in a script but when a script is being prepared in the shell or by text editing, it is usually easier to use one of the following escape sequences than the binary character it represents:\n\nThe list of these escapes is:\n\n‘ ’ (backspace) was omitted because of the conflict with the existing “word boundary” meaning.\n\nGNU processes escape sequences before passing the text onto the regular-expression matching of the command and Address matching. Thus the follwing two commands are equivalent (‘ ’ is the hexadecimal ASCII value of the character ‘ ’):\n\nAs are the following (‘ ’,‘ ’ are the hexadecimal ASCII values of ‘ ’,‘ ’, respectively):\n\nHowever it is recommended to avoid such special characters due to unexpected edge-cases. For example, the following are not equivalent:\n\nThe following example uses the Greek letter Capital Sigma (Σ, Unicode code point ). In a locale, correctly processes the Sigma as one character despite it being 2 octets (bytes):\n\nTo force to process octets separately, use the locale (also known as the locale):\n\n’s regular expressions do not match invalid multibyte sequences in a multibyte locale.\n\nIn the following examples, the ascii value is an incomplete multibyte character (shown here as �). The regular expression ‘ ’ does not match it:\n\nSimilarly, the ’catch-all’ regular expression ‘ ’ does not match the entire line:\n\nGNU offers the special command to clear the current pattern space regardless of invalid multibyte characters (i.e. it works like but also removes invalid multibyte characters):\n\nAlternatively, force the locale to process each octet separately (every octet is a valid character in the locale):\n\n’s inability to process invalid multibyte characters can be used to detect such invalid sequences in a file. In the following examples, the is an invalid multibyte sequence, while is a valid multibyte sequence (of the Greek Sigma character).\n\nThe following program removes all valid characters using . Any content left in the pattern space (the invalid characters) are added to the hold space using the command. On the last line ( ), the hold space is retrieved ( ), newlines are removed ( ), and any remaining octets are printed unambiguously ( ). Thus, any invalid multibyte sequences are printed as octal values:\n\nWith a few more commands, can print the exact line number corresponding to each invalid characters (line 3). These characters can then be removed by forcing the locale and using octal escape sequences:\n\nIn other locales, the sorting sequence is not specified, and ‘ ’ might be equivalent to ‘ ’ or to ‘ ’, or it might fail to match any character, or the set of characters that it matches might even be erratic. To obtain the traditional interpretation of bracket expressions, you can use the ‘ ’ locale by setting the environment variable to the value ‘ ’.\n\nTheir interpretation depends on the locale; for example, ‘ ’ means the character class of numbers and letters in the current locale.\n\nmaintains two data buffers: the active pattern space, and the auxiliary hold space. Both are initially empty.\n\noperates by performing the following cycle on each line of input: first, reads one line from the input stream, removes any trailing newline, and places it in the pattern space. Then commands are executed; each command can have an address associated to it: addresses are a kind of condition code, and a command is only executed if the condition is verified before the command is to be executed.\n\nWhen the end of the script is reached, unless the option is in use, the contents of pattern space are printed out to the output stream, adding back the trailing newline if it was removed.8 Then the next cycle starts for the next input line.\n\nUnless special commands (like ‘ ’) are used, the pattern space is deleted between two cycles. The hold space, on the other hand, keeps its data between cycles (see commands ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’ to move data between both buffers).\n\nMultiple lines can be processed as one buffer using the , , , , . They are similar to their lowercase counterparts ( , , , , ), except that these commands append or subtract data while respecting embedded newlines - allowing adding and removing lines from the pattern and hold spaces.\n\nThey operate as follows:\n\nThe following example illustrates the operation of and commands:\n• starts by reading the first line into the pattern space (i.e. ‘ ’).\n• At the beginning of every cycle, the command appends a newline and the next line to the pattern space (i.e. ‘ ’, ‘ ’, ‘ ’ in the first cycle).\n• The command prints the content of the pattern space unambiguously.\n• The command then removes the content of pattern space up to the first newline (leaving ‘ ’ at the end of the first cycle).\n• At the next cycle the command appends a newline and the next input line to the pattern space (e.g. ‘ ’, ‘ ’, ‘ ’).\n\nA common technique to process blocks of text such as paragraphs (instead of line-by-line) is using the following construct:\n• The first expression, operates on all non-empty lines, and adds the current line (in the pattern space) to the hold space. On all lines except the last, the pattern space is deleted and the cycle is restarted.\n• The other expressions and are executed only on empty lines (i.e. paragraph separators). The command fetches the accumulated lines from the hold space back to the pattern space. The command then operates on all the text in the paragraph (including the embedded newlines).\n\nThe following example demonstrates this technique:\n\nFor more annotated examples, see Text search across multiple lines and Line length adjustment.\n\nThe branching commands , , and enable changing the flow of programs.\n\nBy default, reads an input line into the pattern buffer, then continues to processes all commands in order. Commands without addresses affect all lines. Commands with addresses affect only matching lines. See Execution Cycle and Addresses overview.\n\ndoes not support a typical construct. Instead, some commands can be used as conditionals or to change the default flow control:\n\nThe following two programs are equivalent. The first (contrived) example uses the command to skip the command on lines containing ‘ ’. The second example uses an address with negation (‘ ’) to perform substitution only on desired lines. The command is still executed on all lines:\n\nThe , and commands can be followed by a label (typically a single letter). Labels are defined with a colon followed by one or more letters (e.g. ‘ ’). If the label is omitted the branch commands restart the cycle. Note the difference between branching to a label and restarting the cycle: when a cycle is restarted, first prints the current content of the pattern space, then reads the next input line into the pattern space; Jumping to a label (even if it is at the beginning of the program) does not print the pattern space and does not read the next input line.\n\nThe following program is a no-op. The command (the only command in the program) does not have a label, and thus simply restarts the cycle. On each cycle, the pattern space is printed and the next input line is read:\n\nThe following example is an infinite-loop - it doesn’t terminate and doesn’t print anything. The command jumps to the ‘ ’ label, and a new cycle is never started:\n\nBranching is often complemented with the or commands: both commands read the next input line into the pattern space without waiting for the cycle to restart. Before reading the next input line, prints the current pattern space then empties it, while appends a newline and the next input line to the pattern space.\n\nConsider the following two examples:\n• Both examples do not inf-loop, despite never starting a new cycle.\n• In the first example, the commands first prints the content of the pattern space, empties the pattern space then reads the next input line.\n• In the second example, the commands appends the next input line to the pattern space (with a newline). Lines are accumulated in the pattern space until there are no more input lines to read, then the command terminates the program. When the program terminates, the end-of-cycle actions are performed, and the entire pattern space is printed.\n• The second example requires GNU , because it uses the non-POSIX-standard behavior of . See the “ command on the last line” paragraph in Reporting Bugs.\n• To further examine the difference between the two examples, try the following commands:\n\nAs a real-world example of using branching, consider the case of quoted-printable files, typically used to encode email messages. In these files long lines are split and marked with a soft line break consisting of a single ‘ ’ character at the end of the line:\n\nThe following program uses an address match ‘ ’ as a conditional: If the current pattern space ends with a ‘ ’, it reads the next input line using , replaces all ‘ ’ characters which are followed by a newline, and unconditionally branches ( ) to the beginning of the program without restarting a new cycle. If the pattern space does not ends with ‘ ’, the default action is performed: the pattern space is printed and a new cycle is started:\n\nHere’s an alternative program with a slightly different approach: On all lines except the last, appends the line to the pattern space. A substitution command then removes soft line breaks (‘ ’ at the end of a line, i.e. followed by a newline) by replacing them with an empty string. if the substitution was successful (meaning the pattern space contained a line which should be joined), The conditional branch command jumps to the beginning of the program without completing or restarting the cycle. If the substitution failed (meaning there were no soft line breaks), The command will not branch. Then, will print the pattern space content until the first newline, and will delete the pattern space content until the first new line. (To learn more about , and commands see Multiline techniques).\n\nFor more line-joining examples see Joining lines.\n\nHere are some scripts to guide you in the art of mastering .\n\nThis section uses , and commands to process multiple lines, and the and commands for branching. See Multiline techniques and Branching and flow control.\n\nJoin specific lines (e.g. if lines 2 and 3 need to be joined):\n\nThis script centers all lines of a file on a 80 columns width. To change that width, the number in must be replaced, and the number of added spaces also must be changed.\n\nNote how the buffer commands are used to separate parts in the regular expressions to be matched—this is a common technique.\n\nThis script is one of a few that demonstrate how to do arithmetic in . This is indeed possible,9 but must be done manually.\n\nTo increment one number you just add 1 to last digit, replacing it by the following digit. There is one exception: when the digit is a nine the previous digits must be also incremented until you don’t have a nine.\n\nThis solution by Bruno Haible is very clever and smart because it uses a single buffer; if you don’t have this limitation, the algorithm used in Numbering lines, is faster. It works by replacing trailing nines with an underscore, then using multiple commands to increment the last digit, and then again substituting underscores with zeros.\n\nThis is a pretty strange use of . We transform text, and transform it to be shell commands, then just feed them to shell. Don’t worry, even worse hacks are done when using ; I have seen a script converting the output of into a program!\n\nThe main body of this is the script, which remaps the name from lower to upper (or vice-versa) and even checks out if the remapped name is the same as the original name. Note how the script is parameterized using shell variables and proper quoting.\n\nThis script strips the definition of the shell functions from the output of the Bourne-shell command.\n\nThis script can be used to reverse the position of characters in lines. The technique moves two characters at a time, hence it is faster than more intuitive implementations.\n\nNote the command before the definition of the label. This is often needed to reset the flag that is tested by the command.\n\nImaginative readers will find uses for this script. An example is reversing the output of .10\n\nThis section uses and commands to search for consecutive words spanning multiple lines. See Multiline techniques.\n\nThese examples deal with finding doubled occurrences of words in a document.\n\nFinding doubled words in a single line is easy using GNU and similarly with GNU :\n• The regular expression ‘ ’ searches for word-boundary (‘ ’), followed by one-or-more word-characters (‘ ’), followed by whitespace (‘ ’). See regexp extensions.\n• Adding parentheses around the ‘ ’ expression creates a subexpression. The regular expression pattern ‘ ’ defines a subexpression (in the parentheses) followed by a back-reference, separated by whitespace. A successful match means the was repeated twice in succession. See Back-references and Subexpressions.\n• The word-boundery expression (‘ ’) at both ends ensures partial words are not matched (e.g. ‘ ’ is not a desired match).\n• The option enables extended regular expression syntax, alleviating the need to add backslashes before the parenthesis. See ERE syntax.\n\nWhen the doubled word span two lines the above regular expression will not find them as and operate line-by-line.\n\nBy using and commands, can apply regular expressions on multiple lines (that is, multiple lines are stored in the pattern space, and the regular expression works on it):\n• The command appends the next line to the pattern space (thus ensuring it contains two consecutive lines in every cycle).\n• The regular expression uses ‘ ’ for word separator which matches both spaces and newlines.\n• The regular expression matches, the entire pattern space is printed with . No lines are printed by default due to the option.\n• The removes the first line from the pattern space (up until the first newline), readying it for the next cycle.\n\nSee the GNU manual for an alternative solution using and at https://gnu.org/s/coreutils/manual/html_node/Squeezing-and-deleting.html.\n\nThis section uses and commands to search for consecutive words spanning multiple lines, and the command for branching. See Multiline techniques and Branching and flow control.\n\nThis (somewhat contrived) example deal with formatting and wrapping lines of text of the following input file:\n\nThe following sed program wraps lines at 40 characters:\n\nThis one begins a series of totally useless (yet interesting) scripts emulating various Unix commands. This, in particular, is a workalike.\n\nNote that on implementations other than GNU this script might easily overflow internal buffers.\n\nThis script replaces ‘ ’; in fact it formats its output exactly like GNU does.\n\nOf course this is completely useless and for two reasons: first, because somebody else did it in C, second, because the following Bourne-shell script could be used for the same purpose and would be much faster:\n\nIt uses to print the line number, then groups lines two by two using . Of course, this script does not teach as much as the one presented below.\n\nThe algorithm used for incrementing uses both buffers, so the line is printed as soon as possible and then discarded. The number is split so that changing digits go in a buffer and unchanged ones go in the other; the changed digits are modified in a single step (using a command). The line number for the next line is then composed and stored in the hold space, to be used in the next iteration.\n\nEmulating ‘ ’ is almost the same as ‘ ’—we only have to select which lines are to be numbered and which are not.\n\nThe part that is common to this script and the previous one is not commented to show how important it is to comment scripts properly...\n\nThis script shows another way to do arithmetic with . In this case we have to add possibly large numbers, so implementing this by successive increments would not be feasible (and possibly even more complicated to contrive than this script).\n\nThe approach is to map numbers to letters, kind of an abacus implemented with . ‘ ’s are units, ‘ ’s are tens and so on: we simply add the number of characters on the current line as units, and then propagate the carry to tens, hundreds, and so on.\n\nAs usual, running totals are kept in hold space.\n\nOn the last line, we convert the abacus form back to decimal. For the sake of variety, this is done with a loop rather than with some 80 commands11: first we convert units, removing ‘ ’s from the number; then we rotate letters so that tens become ‘ ’s, and so on until no more letters remain.\n\nThis script is almost the same as the previous one, once each of the words on the line is converted to a single ‘ ’ (in the previous script each letter was changed to an ‘ ’).\n\nIt is interesting that real programs have optimized loops for ‘ ’, so they are much slower at counting words rather than characters. This script’s bottleneck, instead, is arithmetic, and hence the word-counting one is faster (it has to manage smaller numbers).\n\nAgain, the common parts are not commented to show the importance of commenting scripts.\n\nNo strange things are done now, because gives us ‘ ’ functionality for free!!! Look:\n\nThis script is probably the simplest useful script. It displays the first 10 lines of input; the number of displayed lines is right before the command.\n\nPrinting the last lines rather than the first is more complex but indeed possible. is encoded in the second line, before the bang character.\n\nThis script is similar to the script in that it keeps the final output in the hold space and prints it at the end:\n\nMainly, the scripts keeps a window of 10 lines and slides it by adding a line and deleting the oldest (the substitution command on the second line works like a command but does not restart the loop).\n\nThe “sliding window” technique is a very powerful way to write efficient and complex scripts, because commands like would require a lot of work if implemented manually.\n\nTo introduce the technique, which is fully demonstrated in the rest of this chapter and is based on the , and commands, here is an implementation of using a simple “sliding window.”\n\nThis looks complicated but in fact the working is the same as the last script: after we have kicked in the appropriate number of lines, however, we stop using the hold space to keep inter-line state, and instead use and to slide pattern space by one line:\n\nNote how the first, second and fourth line are inactive after the first ten lines of input. After that, all the script does is: exiting on the last line of input, appending the next input line to pattern space, and removing the first line.\n\nThis is an example of the art of using the , and commands, probably the most difficult to master.\n\nAs you can see, we maintain a 2-line window using and . This technique is often used in advanced scripts.\n\nThis script prints only duplicated lines, like ‘ ’.\n\nThis script prints only unique lines, like ‘ ’.\n\nAs a final example, here are three scripts, of increasing complexity and speed, that implement the same function as ‘ ’, that is squeezing blank lines.\n\nThe first leaves a blank line at the beginning and end if there are some already.\n\nThis one is a bit more complex and removes all empty lines at the beginning. It does leave a single blank line at end if one was there.\n\nThis removes leading and trailing blank lines. It is also the fastest. Note that loops are completely done with and , without relying on to restart the script automatically at the end of a line.\n\nFor those who want to write portable scripts, be aware that some implementations have been known to limit line lengths (for the pattern and hold spaces) to be no more than 4000 bytes. The POSIX standard specifies that conforming implementations shall support at least 8192 byte line lengths. GNU has no built-in limit on line length; as long as it can more (virtual) memory, you can feed or construct lines as long as you like.\n\nHowever, recursion is used to handle subpatterns and indefinite repetition. This means that the available stack space may limit the size of the buffer that can be processed by certain patterns.\n\n9 Other Resources for Learning About\n\nFor up to date information about GNU please visit https://www.gnu.org/software/sed/.\n\nSend general questions and suggestions to sed-devel@gnu.org. Visit the mailing list archives for past discussions at https://lists.gnu.org/archive/html/sed-devel/.\n\nThe following resources provide information about (both GNU and other variations). Note these not maintained by GNU developers.\n• The mailing list maintained by Sven Guckes: http://groups.yahoo.com/group/sed-users/ (note this is not the GNU mailing list).\n\nEmail bug reports to bug-sed@gnu.org. Also, please include the output of ‘ ’ in the body of your report if at all possible.\n\nPlease do not send a bug report like this:\n\nIf GNU doesn’t configure your favorite package, take a few extra minutes to identify the specific problem and make a stand-alone test case. Unlike other programs such as C compilers, making such test cases for is quite simple.\n\nA stand-alone test case includes all the data necessary to perform the test, and the specific invocation of that causes the problem. The smaller a stand-alone test case is, the better. A test case should not involve something as far removed from as “try to configure frobme-1.3.4”. Yes, that is in principle enough information to look for the bug, but that is not a very practical prospect.\n\nHere are a few commonly reported bugs that are not bugs.\n• PREAMBLE The purpose of this License is to make a manual, textbook, or other functional and useful document free in the sense of freedom: to assure everyone the effective freedom to copy and redistribute it, with or without modifying it, either commercially or noncommercially. Secondarily, this License preserves for the author and publisher a way to get credit for their work, while not being considered responsible for modifications made by others. This License is a kind of “copyleft”, which means that derivative works of the document must themselves be free in the same sense. It complements the GNU General Public License, which is a copyleft license designed for free software. We have designed this License in order to use it for manuals for free software, because free software needs free documentation: a free program should come with manuals providing the same freedoms that the software does. But this License is not limited to software manuals; it can be used for any textual work, regardless of subject matter or whether it is published as a printed book. We recommend this License principally for works whose purpose is instruction or reference.\n• APPLICABILITY AND DEFINITIONS This License applies to any manual or other work, in any medium, that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License. Such a notice grants a world-wide, royalty-free license, unlimited in duration, to use that work under the conditions stated herein. The “Document”, below, refers to any such manual or work. Any member of the public is a licensee, and is addressed as “you”. You accept the license if you copy, modify or distribute the work in a way requiring permission under copyright law. A “Modified Version” of the Document means any work containing the Document or a portion of it, either copied verbatim, or with modifications and/or translated into another language. A “Secondary Section” is a named appendix or a front-matter section of the Document that deals exclusively with the relationship of the publishers or authors of the Document to the Document’s overall subject (or to related matters) and contains nothing that could fall directly within that overall subject. (Thus, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.) The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them. The “Invariant Sections” are certain Secondary Sections whose titles are designated, as being those of Invariant Sections, in the notice that says that the Document is released under this License. If a section does not fit the above definition of Secondary then it is not allowed to be designated as Invariant. The Document may contain zero Invariant Sections. If the Document does not identify any Invariant Sections then there are none. The “Cover Texts” are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is released under this License. A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words. A “Transparent” copy of the Document means a machine-readable copy, represented in a format whose specification is available to the general public, that is suitable for revising the document straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some widely available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text formatters. A copy made in an otherwise Transparent file format whose markup, or absence of markup, has been arranged to thwart or discourage subsequent modification by readers is not Transparent. An image format is not Transparent if used for any substantial amount of text. A copy that is not “Transparent” is called “Opaque”. Examples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input format, LaTeX input format, SGML or XML using a publicly available DTD, and standard-conforming simple HTML, PostScript or PDF designed for human modification. Examples of transparent image formats include PNG, XCF and JPG. Opaque formats include proprietary formats that can be read and edited only by proprietary word processors, SGML or XML for which the DTD and/or processing tools are not generally available, and the machine-generated HTML, PostScript or PDF produced by some word processors for output purposes only. The “Title Page” means, for a printed book, the title page itself, plus such following pages as are needed to hold, legibly, the material this License requires to appear in the title page. For works in formats which do not have any title page as such, “Title Page” means the text near the most prominent appearance of the work’s title, preceding the beginning of the body of the text. The “publisher” means any person or entity that distributes copies of the Document to the public. A section “Entitled XYZ” means a named subunit of the Document whose title either is precisely XYZ or contains XYZ in parentheses following text that translates XYZ in another language. (Here XYZ stands for a specific section name mentioned below, such as “Acknowledgements”, “Dedications”, “Endorsements”, or “History”.) To “Preserve the Title” of such a section when you modify the Document means that it remains a section “Entitled XYZ” according to this definition. The Document may include Warranty Disclaimers next to the notice which states that this License applies to the Document. These Warranty Disclaimers are considered to be included by reference in this License, but only as regards disclaiming warranties: any other implication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License.\n• VERBATIM COPYING You may copy and distribute the Document in any medium, either commercially or noncommercially, provided that this License, the copyright notices, and the license notice saying this License applies to the Document are reproduced in all copies, and that you add no other conditions whatsoever to those of this License. You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute. However, you may accept compensation in exchange for copies. If you distribute a large enough number of copies you must also follow the conditions in section 3. You may also lend copies, under the same conditions stated above, and you may publicly display copies.\n• COPYING IN QUANTITY If you publish printed copies (or copies in media that commonly have printed covers) of the Document, numbering more than 100, and the Document’s license notice requires Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover. Both covers must also clearly and legibly identify you as the publisher of these copies. The front cover must present the full title with all words of the title equally prominent and visible. You may add other material on the covers in addition. Copying with changes limited to the covers, as long as they preserve the title of the Document and satisfy these conditions, can be treated as verbatim copying in other respects. If the required texts for either cover are too voluminous to fit legibly, you should put the first ones listed (as many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages. If you publish or distribute Opaque copies of the Document numbering more than 100, you must either include a machine-readable Transparent copy along with each Opaque copy, or state in or with each Opaque copy a computer-network location from which the general network-using public has access to download using public-standard network protocols a complete Transparent copy of the Document, free of added material. If you use the latter option, you must take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at the stated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public. It is requested, but not required, that you contact the authors of the Document well before redistributing any large number of copies, to give them a chance to provide you with an updated version of the Document.\n• MODIFICATIONS You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it. In addition, you must do these things in the Modified Version:\n• Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from those of previous versions (which should, if there were any, be listed in the History section of the Document). You may use the same title as a previous version if the original publisher of that version gives permission.\n• List on the Title Page, as authors, one or more persons or entities responsible for authorship of the modifications in the Modified Version, together with at least five of the principal authors of the Document (all of its principal authors, if it has fewer than five), unless they release you from this requirement.\n• State on the Title page the name of the publisher of the Modified Version, as the publisher.\n• Preserve all the copyright notices of the Document.\n• Add an appropriate copyright notice for your modifications adjacent to the other copyright notices.\n• Include, immediately after the copyright notices, a license notice giving the public permission to use the Modified Version under the terms of this License, in the form shown in the Addendum below.\n• Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the Document’s license notice.\n• Include an unaltered copy of this License.\n• Preserve the section Entitled “History”, Preserve its Title, and add to it an item stating at least the title, year, new authors, and publisher of the Modified Version as given on the Title Page. If there is no section Entitled “History” in the Document, create one stating the title, year, authors, and publisher of the Document as given on its Title Page, then add an item describing the Modified Version as stated in the previous sentence.\n• Preserve the network location, if any, given in the Document for public access to a Transparent copy of the Document, and likewise the network locations given in the Document for previous versions it was based on. These may be placed in the “History” section. You may omit a network location for a work that was published at least four years before the Document itself, or if the original publisher of the version it refers to gives permission.\n• For any section Entitled “Acknowledgements” or “Dedications”, Preserve the Title of the section, and preserve in the section all the substance and tone of each of the contributor acknowledgements and/or dedications given therein.\n• Preserve all the Invariant Sections of the Document, unaltered in their text and in their titles. Section numbers or the equivalent are not considered part of the section titles.\n• Delete any section Entitled “Endorsements”. Such a section may not be included in the Modified Version.\n• Do not retitle any existing section to be Entitled “Endorsements” or to conflict in title with any Invariant Section. If the Modified Version includes new front-matter sections or appendices that qualify as Secondary Sections and contain no material copied from the Document, you may at your option designate some or all of these sections as invariant. To do this, add their titles to the list of Invariant Sections in the Modified Version’s license notice. These titles must be distinct from any other section titles. You may add a section Entitled “Endorsements”, provided it contains nothing but endorsements of your Modified Version by various parties—for example, statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard. You may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity. If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one. The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version.\n• COMBINING DOCUMENTS You may combine the Document with other documents released under this License, under the terms defined in section 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined work in its license notice, and that you preserve all their Warranty Disclaimers. The combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced with a single copy. If there are multiple Invariant Sections with the same name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number. Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work. In the combination, you must combine any sections Entitled “History” in the various original documents, forming one section Entitled “History”; likewise combine any sections Entitled “Acknowledgements”, and any sections Entitled “Dedications”. You must delete all sections Entitled “Endorsements.”\n• COLLECTIONS OF DOCUMENTS You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included in the collection, provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects. You may extract a single document from such a collection, and distribute it individually under this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document.\n• AGGREGATION WITH INDEPENDENT WORKS A compilation of the Document or its derivatives with other separate and independent documents or works, in or on a volume of a storage or distribution medium, is called an “aggregate” if the copyright resulting from the compilation is not used to limit the legal rights of the compilation’s users beyond what the individual works permit. When the Document is included in an aggregate, this License does not apply to the other works in the aggregate which are not themselves derivative works of the Document. If the Cover Text requirement of section 3 is applicable to these copies of the Document, then if the Document is less than one half of the entire aggregate, the Document’s Cover Texts may be placed on covers that bracket the Document within the aggregate, or the electronic equivalent of covers if the Document is in electronic form. Otherwise they must appear on printed covers that bracket the whole aggregate.\n• TRANSLATION Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section 4. Replacing Invariant Sections with translations requires special permission from their copyright holders, but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections. You may include a translation of this License, and all the license notices in the Document, and any Warranty Disclaimers, provided that you also include the original English version of this License and the original versions of those notices and disclaimers. In case of a disagreement between the translation and the original version of this License or a notice or disclaimer, the original version will prevail. If a section in the Document is Entitled “Acknowledgements”, “Dedications”, or “History”, the requirement (section 4) to Preserve its Title (section 1) will typically require changing the actual title.\n• TERMINATION You may not copy, modify, sublicense, or distribute the Document except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, or distribute it is void, and will automatically terminate your rights under this License. However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, receipt of a copy of some or all of the same material does not give you any rights to use it.\n• FUTURE REVISIONS OF THIS LICENSE The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. See https://www.gnu.org/copyleft/. Each version of the License is given a distinguishing version number. If the Document specifies that a particular numbered version of this License “or any later version” applies to it, you have the option of following the terms and conditions either of that specified version or of any later version that has been published (not as a draft) by the Free Software Foundation. If the Document does not specify a version number of this License, you may choose any version ever published (not as a draft) by the Free Software Foundation. If the Document specifies that a proxy can decide which future versions of this License can be used, that proxy’s public statement of acceptance of a version permanently authorizes you to choose that version for the Document.\n• RELICENSING “Massive Multiauthor Collaboration Site” (or “MMC Site”) means any World Wide Web server that publishes copyrightable works and also provides prominent facilities for anybody to edit those works. A public wiki that anybody can edit is an example of such a server. A “Massive Multiauthor Collaboration” (or “MMC”) contained in the site means any set of copyrightable works thus published on the MMC site. “CC-BY-SA” means the Creative Commons Attribution-Share Alike 3.0 license published by Creative Commons Corporation, a not-for-profit corporation with a principal place of business in San Francisco, California, as well as future copyleft versions of that license published by that same organization. “Incorporate” means to publish or republish a Document, in whole or in part, as part of another Document. An MMC is “eligible for relicensing” if it is licensed under this License, and if all works that were first published under this License somewhere other than this MMC, and subsequently incorporated in whole or in part into the MMC, (1) had no cover texts or invariant sections, and (2) were thus incorporated prior to November 1, 2008. The operator of an MMC Site may republish an MMC contained in the site under CC-BY-SA on the same site at any time before August 1, 2009, provided the MMC is eligible for relicensing.\n\nADDENDUM: How to use this License for your documents\n\nTo use this License in a document you have written, include a copy of the License in the document and put the following copyright and license notices just after the title page:\n\nIf you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace the “with…Texts.” line with this:\n\nIf you have Invariant Sections without Cover Texts, or some other combination of the three, merge those two alternatives to suit the situation.\n\nIf your document contains nontrivial examples of program code, we recommend releasing these examples in parallel under your choice of free software license, such as the GNU General Public License, to permit their use in free software.\n\nThis is a general index of all issues discussed in this manual, with the exception of the commands and command-line options.\n\nThis is an alphabetical list of all commands and command-line options."
    }
]