[
    {
        "link": "https://docs.python.org/3/tutorial/index.html",
        "document": "Python is an easy to learn, powerful programming language. It has efficient high-level data structures and a simple but effective approach to object-oriented programming. Python’s elegant syntax and dynamic typing, together with its interpreted nature, make it an ideal language for scripting and rapid application development in many areas on most platforms.\n\nThe Python interpreter and the extensive standard library are freely available in source or binary form for all major platforms from the Python web site, https://www.python.org/, and may be freely distributed. The same site also contains distributions of and pointers to many free third party Python modules, programs and tools, and additional documentation.\n\nThe Python interpreter is easily extended with new functions and data types implemented in C or C++ (or other languages callable from C). Python is also suitable as an extension language for customizable applications.\n\nThis tutorial introduces the reader informally to the basic concepts and features of the Python language and system. It helps to have a Python interpreter handy for hands-on experience, but all examples are self-contained, so the tutorial can be read off-line as well.\n\nFor a description of standard objects and modules, see The Python Standard Library. The Python Language Reference gives a more formal definition of the language. To write extensions in C or C++, read Extending and Embedding the Python Interpreter and Python/C API Reference Manual. There are also several books covering Python in depth.\n\nThis tutorial does not attempt to be comprehensive and cover every single feature, or even every commonly used feature. Instead, it introduces many of Python’s most noteworthy features, and will give you a good idea of the language’s flavor and style. After reading it, you will be able to read and write Python modules and programs, and you will be ready to learn more about the various Python library modules described in The Python Standard Library.\n\nThe Glossary is also worth going through."
    },
    {
        "link": "https://docs.python.org/3/tutorial/controlflow.html",
        "document": ""
    },
    {
        "link": "https://learnpython.org/en/Variables_and_Types",
        "document": "Get started learning Python with DataCamp's free Intro to Python tutorial. Learn Data Science by completing interactive coding challenges and watching videos by expert instructors. Start Now! This site is generously supported by DataCamp. DataCamp offers online interactive Python Tutorials for Data Science. Join 11 million other learners and get started learning Python for data science today! Good news! You can save 25% off your Datacamp annual subscription with the code LEARNPYTHON23ALE25 - Click here to redeem your discount\n\nPython is completely object oriented, and not \"statically typed\". You do not need to declare variables before using them, or declare their type. Every variable in Python is an object. This tutorial will go over a few basic types of variables. Python supports two types of numbers - integers(whole numbers) and floating point numbers(decimals). (It also supports complex numbers, which will not be explained in this tutorial). To define an integer, use the following syntax: To define a floating point number, you may use one of the following notations: Strings are defined either with a single quote or a double quotes. The difference between the two is that using double quotes makes it easy to include apostrophes (whereas these would terminate the string if using single quotes) There are additional variations on defining strings that make it easier to include things such as carriage returns, backslashes and Unicode characters. These are beyond the scope of this tutorial, but are covered in the Python documentation. Simple operators can be executed on numbers and strings: one = 1 two = 2 three = one + two print(three) hello = \"hello\" world = \"world\" helloworld = hello + \" \" + world print(helloworld) Assignments can be done on more than one variable \"simultaneously\" on the same line like this Mixing operators between numbers and strings is not supported: # This will not work! one = 1 two = 2 hello = \"hello\" print(one + two + hello) The target of this exercise is to create a string, an integer, and a floating point number. The string should be named and should contain the word \"hello\". The floating point number should be named and should contain the number 10.0, and the integer should be named and should contain the number 20.\n\n# change this code mystring = None myfloat = None myint = None # testing code if mystring == \"hello\": print(\"String: %s\" % mystring) if isinstance(myfloat, float) and myfloat == 10.0: print(\"Float: %f\" % myfloat) if isinstance(myint, int) and myint == 20: print(\"Integer: %d\" % myint) # change this code mystring = \"hello\" myfloat = 10.0 myint = 20 # testing code if mystring == \"hello\": print(\"String: %s\" % mystring) if isinstance(myfloat, float) and myfloat == 10.0: print(\"Float: %f\" % myfloat) if isinstance(myint, int) and myint == 20: print(\"Integer: %d\" % myint) test_object('mystring', incorrect_msg=\"Don't forget to change `mystring` to the correct value from the exercise description.\") test_object('myfloat', incorrect_msg=\"Don't forget to change `myfloat` to the correct value from the exercise description.\") test_object('myint', incorrect_msg=\"Don't forget to change `myint` to the correct value from the exercise description.\") test_output_contains(\"String: hello\",no_output_msg= \"Make sure your string matches exactly to the exercise desciption.\") test_output_contains(\"Float: 10.000000\",no_output_msg= \"Make sure your float matches exactly to the exercise desciption.\") test_output_contains(\"Integer: 20\",no_output_msg= \"Make sure your integer matches exactly to the exercise desciption.\") success_msg(\"Great job!\")"
    },
    {
        "link": "https://docs.python.org/3/library/stdtypes.html",
        "document": "The following sections describe the standard types that are built into the interpreter.\n\nThe principal built-in types are numerics, sequences, mappings, classes, instances and exceptions.\n\nSome collection classes are mutable. The methods that add, subtract, or rearrange their members in place, and don’t return a specific item, never return the collection instance itself but .\n\nSome operations are supported by several object types; in particular, practically all objects can be compared for equality, tested for truth value, and converted to a string (with the function or the slightly different function). The latter function is implicitly used when an object is written by the function.\n\nThere are three distinct numeric types: integers, floating-point numbers, and complex numbers. In addition, Booleans are a subtype of integers. Integers have unlimited precision. Floating-point numbers are usually implemented using double in C; information about the precision and internal representation of floating-point numbers for the machine on which your program is running is available in . Complex numbers have a real and imaginary part, which are each a floating-point number. To extract these parts from a complex number z, use and . (The standard library includes the additional numeric types , for rationals, and , for floating-point numbers with user-definable precision.) Numbers are created by numeric literals or as the result of built-in functions and operators. Unadorned integer literals (including hex, octal and binary numbers) yield integers. Numeric literals containing a decimal point or an exponent sign yield floating-point numbers. Appending or to a numeric literal yields an imaginary number (a complex number with a zero real part) which you can add to an integer or float to get a complex number with real and imaginary parts. Python fully supports mixed arithmetic: when a binary arithmetic operator has operands of different numeric types, the operand with the “narrower” type is widened to that of the other, where integer is narrower than floating point, which is narrower than complex. A comparison between numbers of different types behaves as though the exact values of those numbers were being compared. The constructors , , and can be used to produce numbers of a specific type. All numeric types (except complex) support the following operations (for priorities of the operations, see Operator precedence): absolute value or magnitude of x a complex number with real part re, imaginary part im. im defaults to zero. conjugate of the complex number c\n• None Also referred to as integer division. For operands of type , the result has type . For operands of type , the result has type . In general, the result is a whole integer, though the result’s type is not necessarily . The result is always rounded towards minus infinity: is , is , is , and is .\n• None Not for complex numbers. Instead convert to floats using if appropriate.\n• None Conversion from to truncates, discarding the fractional part. See functions and for alternative conversions.\n• None float also accepts the strings “nan” and “inf” with an optional prefix “+” or “-” for Not a Number (NaN) and positive or negative infinity.\n• None Python defines and to be , as is common for programming languages.\n• None The numeric literals accepted include the digits to or any Unicode equivalent (code points with the property). See the Unicode Standard for a complete list of code points with the property. All types ( and ) also include the following operations: x rounded to n digits, rounding half to even. If n is omitted, it defaults to 0. For additional numeric operations see the and modules. Bitwise operations only make sense for integers. The result of bitwise operations is calculated as though carried out in two’s complement with an infinite number of sign bits. The priorities of the binary bitwise operations are all lower than the numeric operations and higher than the comparisons; the unary operation has the same priority as the other unary numeric operations ( and ). This table lists the bitwise operations sorted in ascending priority: bitwise exclusive or of x and y\n• None Negative shift counts are illegal and cause a to be raised.\n• None A left shift by n bits is equivalent to multiplication by .\n• None A right shift by n bits is equivalent to floor division by .\n• None Performing these calculations with at least one extra sign extension bit in a finite two’s complement representation (a working bit-width of or more) is sufficient to get the same result as if there were an infinite number of sign bits. The int type implements the abstract base class. In addition, it provides a few more methods: Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: More precisely, if is nonzero, then is the unique positive integer such that . Equivalently, when is small enough to have a correctly rounded logarithm, then . If is zero, then returns . Return the number of ones in the binary representation of the absolute value of the integer. This is also known as the population count. Example: Return an array of bytes representing an integer. The integer is represented using length bytes, and defaults to 1. An is raised if the integer is not representable with the given number of bytes. The byteorder argument determines the byte order used to represent the integer, and defaults to . If byteorder is , the most significant byte is at the beginning of the byte array. If byteorder is , the most significant byte is at the end of the byte array. The signed argument determines whether two’s complement is used to represent the integer. If signed is and a negative integer is given, an is raised. The default value for signed is . The default values can be used to conveniently turn an integer into a single byte object: However, when using the default arguments, don’t try to convert a value greater than 255 or you’ll get an . \"byteorder must be either 'little' or 'big'\" Changed in version 3.11: Added default argument values for and . Return the integer represented by the given array of bytes. The argument bytes must either be a bytes-like object or an iterable producing bytes. The byteorder argument determines the byte order used to represent the integer, and defaults to . If byteorder is , the most significant byte is at the beginning of the byte array. If byteorder is , the most significant byte is at the end of the byte array. To request the native byte order of the host system, use as the byte order value. The signed argument indicates whether two’s complement is used to represent the integer. \"byteorder must be either 'little' or 'big'\" Changed in version 3.11: Added default argument value for . Return a pair of integers whose ratio is equal to the original integer and has a positive denominator. The integer ratio of integers (whole numbers) is always the integer as the numerator and as the denominator. The float type implements the abstract base class. float also has the following additional methods. Return a pair of integers whose ratio is exactly equal to the original float. The ratio is in lowest terms and has a positive denominator. Raises on infinities and a on NaNs. Return if the float instance is finite with integral value, and otherwise: Two methods support conversion to and from hexadecimal strings. Since Python’s floats are stored internally as binary numbers, converting a float to or from a decimal string usually involves a small rounding error. In contrast, hexadecimal strings allow exact representation and specification of floating-point numbers. This can be useful when debugging, and in numerical work. Return a representation of a floating-point number as a hexadecimal string. For finite floating-point numbers, this representation will always include a leading and a trailing and exponent. Class method to return the float represented by a hexadecimal string s. The string s may have leading and trailing whitespace. Note that is an instance method, while is a class method. where the optional may by either or , and are strings of hexadecimal digits, and is a decimal integer with an optional leading sign. Case is not significant, and there must be at least one hexadecimal digit in either the integer or the fraction. This syntax is similar to the syntax specified in section 6.4.4.2 of the C99 standard, and also to the syntax used in Java 1.5 onwards. In particular, the output of is usable as a hexadecimal floating-point literal in C or Java code, and hexadecimal strings produced by C’s format character or Java’s are accepted by . Note that the exponent is written in decimal rather than hexadecimal, and that it gives the power of 2 by which to multiply the coefficient. For example, the hexadecimal string represents the floating-point number , or : Applying the reverse conversion to gives a different hexadecimal string representing the same number: For numbers and , possibly of different types, it’s a requirement that whenever (see the method documentation for more details). For ease of implementation and efficiency across a variety of numeric types (including , , and ) Python’s hash for numeric types is based on a single mathematical function that’s defined for any rational number, and hence applies to all instances of and , and all finite instances of and . Essentially, this function is given by reduction modulo for a fixed prime . The value of is made available to Python as the attribute of . CPython implementation detail: Currently, the prime used is on machines with 32-bit C longs and on machines with 64-bit C longs. Here are the rules in detail:\n• None If is a nonnegative rational number and is not divisible by , define as , where gives the inverse of modulo .\n• None If is a nonnegative rational number and is divisible by (but is not) then has no inverse modulo and the rule above doesn’t apply; in this case define to be the constant value .\n• None If is a negative rational number define as . If the resulting hash is , replace it with .\n• None The particular values and are used as hash values for positive infinity or negative infinity (respectively).\n• None For a number , the hash values of the real and imaginary parts are combined by computing , reduced modulo so that it lies in . Again, if the result is , it’s replaced with . To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, , or : Assumes m and n are integers, with n positive. # Remove common factors of P. (Unnecessary if m and n already coprime.) # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P.\n\nThere are three basic sequence types: lists, tuples, and range objects. Additional sequence types tailored for processing of binary data and text strings are described in dedicated sections. The operations in the following table are supported by most sequence types, both mutable and immutable. The ABC is provided to make it easier to correctly implement these operations on custom sequence types. This table lists the sequence operations sorted in ascending priority. In the table, s and t are sequences of the same type, n, i, j and k are integers and x is an arbitrary object that meets any type and value restrictions imposed by s. The and operations have the same priorities as the comparison operations. The (concatenation) and (repetition) operations have the same priority as the corresponding numeric operations. if an item of s is equal to x, else if an item of s is equal to x, else the concatenation of s and t equivalent to adding s to itself n times slice of s from i to j with step k index of the first occurrence of x in s (at or after index i and before index j) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Forward and reversed iterators over mutable sequences access values using an index. That index will continue to march forward (or backward) even if the underlying sequence is mutated. The iterator terminates only when an or a is encountered (or when the index drops below zero).\n• None While the and operations are used only for simple containment testing in the general case, some specialised sequences (such as , and ) also use them for subsequence testing:\n• None Values of n less than are treated as (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: What has happened is that is a one-element list containing an empty list, so all three elements of are references to this single empty list. Modifying any of the elements of modifies this single list. You can create a list of different lists this way: Further explanation is available in the FAQ entry How do I create a multidimensional list?.\n• None If i or j is negative, the index is relative to the end of sequence s: or is substituted. But note that is still .\n• None The slice of s from i to j is defined as the sequence of items with index k such that . If i or j is greater than , use . If i is omitted or , use . If j is omitted or , use . If i is greater than or equal to j, the slice is empty.\n• None The slice of s from i to j with step k is defined as the sequence of items with index such that . In other words, the indices are , , , and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to if they are greater. When k is negative, i and j are reduced to if they are greater. If i or j are omitted or , they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is , it is treated like .\n• None Concatenating immutable sequences always results in a new object. This means that building up a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length. To get a linear runtime cost, you must switch to one of the alternatives below:\n• None if concatenating objects, you can build a list and use at the end or else write to an instance and retrieve its value when complete\n• None if concatenating objects, you can similarly use or , or you can do in-place concatenation with a object. objects are mutable and have an efficient overallocation mechanism\n• None for other types, investigate the relevant class documentation\n• None Some sequence types (such as ) only support item sequences that follow specific patterns, and hence don’t support sequence concatenation or repetition.\n• None raises when x is not found in s. Not all implementations support passing the additional arguments i and j. These arguments allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using , only without copying any data and with the returned index being relative to the start of the sequence rather than the start of the slice. The only operation that immutable sequence types generally implement that is not also implemented by mutable sequence types is support for the built-in. This support allows immutable sequences, such as instances, to be used as keys and stored in and instances. Attempting to hash an immutable sequence that contains unhashable values will result in . The operations in the following table are defined on mutable sequence types. The ABC is provided to make it easier to correctly implement these operations on custom sequence types. In the table s is an instance of a mutable sequence type, t is any iterable object and x is an arbitrary object that meets any type and value restrictions imposed by s (for example, only accepts integers that meet the value restriction ). item i of s is replaced by x slice of s from i to j is replaced by the contents of the iterable t the elements of are replaced by those of t removes the elements of from the list appends x to the end of the sequence (same as ) removes all items from s (same as ) creates a shallow copy of s (same as ) extends s with the contents of t (for the most part the same as ) inserts x into s at the index given by i (same as ) retrieves the item at i and also removes it from s removes the first item from s where is equal to x reverses the items of s in place\n• None If k is not equal to , t must have the same length as the slice it is replacing.\n• None The optional argument i defaults to , so that by default the last item is removed and returned.\n• None raises when x is not found in s.\n• None The method modifies the sequence in place for economy of space when reversing a large sequence. To remind users that it operates by side effect, it does not return the reversed sequence.\n• None and are included for consistency with the interfaces of mutable containers that don’t support slicing operations (such as and ). is not part of the ABC, but most concrete mutable sequence classes provide it.\n• None The value n is an integer, or an object implementing . Zero and negative values of n clear the sequence. Items in the sequence are not copied; they are referenced multiple times, as explained for under Common Sequence Operations. Lists are mutable sequences, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application). Lists may be constructed in several ways:\n• None Using a pair of square brackets to denote the empty list:\n• None Using the type constructor: or The constructor builds a list whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a list, a copy is made and returned, similar to . For example, returns and returns . If no argument is given, the constructor creates a new empty list, . Many other operations also produce lists, including the built-in. Lists implement all of the common and mutable sequence operations. Lists also provide the following additional method: This method sorts the list in place, using only comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, ). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of means that list items are sorted directly without calculating a separate key value. The utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to , then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use to explicitly request a new sorted list instance). The method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting Techniques. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises if it can detect that the list has been mutated during a sort. Tuples are immutable sequences, typically used to store collections of heterogeneous data (such as the 2-tuples produced by the built-in). Tuples are also used for cases where an immutable sequence of homogeneous data is needed (such as allowing storage in a or instance). Tuples may be constructed in a number of ways:\n• None Using a pair of parentheses to denote the empty tuple:\n• None Using a trailing comma for a singleton tuple: or\n• None Using the built-in: or The constructor builds a tuple whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a tuple, it is returned unchanged. For example, returns and returns . If no argument is given, the constructor creates a new empty tuple, . Note that it is actually the comma which makes a tuple, not the parentheses. The parentheses are optional, except in the empty tuple case, or when they are needed to avoid syntactic ambiguity. For example, is a function call with three arguments, while is a function call with a 3-tuple as the sole argument. Tuples implement all of the common sequence operations. For heterogeneous collections of data where access by name is clearer than access by index, may be a more appropriate choice than a simple tuple object. The type represents an immutable sequence of numbers and is commonly used for looping a specific number of times in loops. The arguments to the range constructor must be integers (either built-in or any object that implements the special method). If the step argument is omitted, it defaults to . If the start argument is omitted, it defaults to . If step is zero, is raised. For a positive step, the contents of a range are determined by the formula where and . For a negative step, the contents of the range are still determined by the formula , but the constraints are and . A range object will be empty if does not meet the value constraint. Ranges do support negative indices, but these are interpreted as indexing from the end of the sequence determined by the positive indices. Ranges containing absolute values larger than are permitted but some features (such as ) may raise . Ranges implement all of the common sequence operations except concatenation and repetition (due to the fact that range objects can only represent sequences that follow a strict pattern and repetition and concatenation will usually violate that pattern). The value of the start parameter (or if the parameter was not supplied) The value of the stop parameter The value of the step parameter (or if the parameter was not supplied) The advantage of the type over a regular or is that a object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the , and values, calculating individual items and subranges as needed). Range objects implement the ABC, and provide features such as containment tests, element index lookup, slicing and support for negative indices (see Sequence Types — list, tuple, range): Testing range objects for equality with and compares them as sequences. That is, two range objects are considered equal if they represent the same sequence of values. (Note that two range objects that compare equal might have different , and attributes, for example or .) Changed in version 3.2: Implement the Sequence ABC. Support slicing and negative indices. Test objects for membership in constant time instead of iterating through all items. Changed in version 3.3: Define ‘==’ and ‘!=’ to compare range objects based on the sequence of values they define (instead of comparing based on object identity).\n• None The linspace recipe shows how to implement a lazy version of range suitable for floating-point applications."
    },
    {
        "link": "https://indico.global/event/6155/attachments/25456/43759/beginners_python_cheat_sheet_pcc_all.pdf",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/reading-writing-text-files-python",
        "document": "Python provides built-in functions for creating, writing, and reading files. Two types of files can be handled in Python, normal text files and binary files (written in binary language, 0s, and 1s).\n• Text files: In this type of file, Each line of text is terminated with a special character called EOL (End of Line), which is the new line character (‘\n\n’) in Python by default.\n• Binary files: In this type of file, there is no terminator for a line, and the data is stored after converting it into machine-understandable binary language.\n\nThis article will focus on opening, closing, reading, and writing data in a text file. Here, we will also see how to get Python output in a text file.\n\nIt is done using the open() function. No module is required to be imported for this function.\n\nExample: Here, file1 is created as an object for MyFile1 and file2 as object for MyFile2.\n\nThere are three ways to read txt file in Python:\n\nread(): Returns the read bytes in form of a string. Reads n bytes, if no n specified, reads the entire file.\n\nreadline(): Reads a line of the file and returns in form of a string.For specified n, reads at most n bytes. However, does not reads more than one line, even if n exceeds the length of the line.\n\nreadlines(): Reads all the lines and return them as each line a string element in a list.\n\nNote: ‘\n\n’ is treated as a special character of two bytes.\n\nIn this example, a file named “myfile.txt” is created and opened in write mode ( ). Data is written to the file using and methods. The file is then reopened in read and append mode ( ). Various read operations, including , , , and the use of , demonstrate different ways to retrieve data from the file. Finally, the file is closed.\n\nThere are two ways to write in a file:\n\nwrite(): Inserts the string str1 in a single line in the text file.\n\nwritelines(): For a list of string elements, each string is inserted in the text file.Used to insert multiple strings at a single time.\n\nIn this example, a file named “myfile.txt” is initially opened in write mode ( ) to write lines of text. The file is then reopened in append mode ( ), and “Today” is added to the existing content. The output after appending is displayed using . Subsequently, the file is reopened in write mode, overwriting the content with “Tomorrow”. The final output after writing is displayed using\n\nPython close() function closes the file and frees the memory space acquired by that file. It is used at the time when the file is no longer needed or if it is to be opened in a different file mode. File_object.close()\n\nReading and Writing to text files in Python – FAQs\n\nAccess modes govern the type of operations possible in the opened file. It refers to how the file will be used once it’s opened. These modes also define the location of the File Handle in the file. The file handle is like a cursor, which defines from where the data has to be read or written in the file and we can get Python output in text file. There are 6 access modes in Python:\n• Read Only (‘r’): Open text file for reading. The handle is positioned at the beginning of the file. If the file does not exist, raises the I/O error. This is also the default mode in which a file is opened.\n• Read and Write (‘r+’): Open the file for reading and writing. The handle is positioned at the beginning of the file. Raises I/O error if the file does not exist.\n• Write Only (‘w’): Open the file for writing. For the existing files, the data is truncated and over-written. The handle is positioned at the beginning of the file. Creates the file if the file does not exist.\n• Write and Read (‘w+’) : Open the file for reading and writing. For an existing file, data is truncated and over-written. The handle is positioned at the beginning of the file.\n• Append Only (‘a’) : Open the file for writing. The file is created if it does not exist. The handle is positioned at the end of the file. The data being written will be inserted at the end, after the existing data.\n• Append and Read (‘a+’): Open the file for reading and writing. The file is created if it does not exist. The handle is positioned at the end of the file. The data being written will be inserted at the end, after the existing data.\n\nHow to read a file and write to another file in Python?\n\nHow Files are Loaded into Primary Memory?\n\nThere are two kinds of memory in a computer i.e. Primary and Secondary memory every file that you saved or anyone saved is on secondary memory causing any data in primary memory to be deleted when the computer is powered off. So when you need to change any text file or just to work with them in Python you need to load that file into primary memory. Python interacts with files loaded in primary memory or main memory through “file handlers” ( This is how your operating system gives access to Python to interact with the file you opened by searching the file in its memory if found it returns a file handler and then you can work with the file).\n\nWhat is the difference between reading and writing files in Python?\n\nWhich function is used to read data from a text file?"
    },
    {
        "link": "https://geeksforgeeks.org/file-handling-python",
        "document": "File handling refers to the process of performing operations on a file such as creating, opening, reading, writing and closing it, through a programming interface. It involves managing the data flow between the program and the file system on the storage device, ensuring that data is handled safely and efficiently.\n\nTo open a file we can use function, which requires file path and mode as arguments:\n\nWhen opening a file, we must specify the mode we want to which specifies what we want to do with the file. Here’s a table of the different modes available:\n\nOpens the file for reading. File must exist; otherwise, it raises an error. Opens the file for reading binary data. File must exist; otherwise, it raises an error. Opens the file for both reading and writing. File must exist; otherwise, it raises an error. Opens the file for both reading and writing binary data. File must exist; otherwise, it raises an error. Opens the file for writing. Creates a new file or truncates the existing file. Opens the file for writing binary data. Creates a new file or truncates the existing file. Opens the file for both writing and reading. Creates a new file or truncates the existing file. Opens the file for both writing and reading binary data. Creates a new file or truncates the existing file. Opens the file for appending data. Creates a new file if it doesn’t exist. Opens the file for appending binary data. Creates a new file if it doesn’t exist. Opens the file for appending and reading. Creates a new file if it doesn’t exist. Opens the file for appending and reading binary data. Creates a new file if it doesn’t exist. Creates a new file. Raises an error if the file already exists. Creates a new binary file. Raises an error if the file already exists. Creates a new file for reading and writing. Raises an error if the file exists. Exclusive creation with read and write in binary mode. Creates a new binary file for reading and writing. Raises an error if the file exists.\n\nFor this article we are using text file with text:\n\nReading a file can be achieved by file.read() which reads the entire content of the file. After reading the file we can close the file using file.close() which closes the file after reading it, which is necessary to free up system resources.\n\nWriting to a file is done using file.write() which writes the specified string to the file. If the file exists, its content is erased. If it doesn’t exist, a new file is created.\n\nExample: Writing to a File in Write Mode (w)\n\nIt is done using adds the specified string to the end of the file without erasing its existing content.\n\nExample: For this example, we will use the Python file created in the previous example.\n\nClosing a file is essential to ensure that all resources used by the file are properly released. loses the file and ensures that any changes made to the file are saved.\n\nstatement is used for resource management. It ensures that file is properly closed after its suite finishes, even if an exception is raised. with open() as method automatically handles closing the file once the block of code is exited, even if an error occurs. This reduces the risk of file corruption and resource leakage.\n\nIt’s important to handle exceptions to ensure that files are closed properly, even if an error occurs during file operations.\n• None Versatility : File handling in Python allows us to perform a wide range of operations, such as creating, reading, writing, appending, renaming and deleting files.\n• Flexibility : File handling in Python is highly flexible, as it allows us to work with different file types (e.g. text files, binary files, CSV files , etc.) and to perform different operations on files (e.g. read, write, append, etc.).\n• User – friendly : Python provides a user-friendly interface for file handling, making it easy to create, read and manipulate files.\n• Cross-platform : Python file-handling functions work across different platforms (e.g. Windows, Mac, Linux), allowing for seamless integration and compatibility.\n• Error-prone: File handling operations in Python can be prone to errors, especially if the code is not carefully written or if there are issues with the file system (e.g. file permissions, file locks, etc.).\n• Security risks : File handling in Python can also pose security risks, especially if the program accepts user input that can be used to access or modify sensitive files on the system.\n• Complexity : File handling in Python can be complex, especially when working with more advanced file formats or operations. Careful attention must be paid to the code to ensure that files are handled properly and securely.\n• Performance : File handling operations in Python can be slower than other programming languages, especially when dealing with large files or performing complex operations.\n\nWhat are the types of files in Python?\n\nWhat are the 4 file handling functions?\n\nWhy is file handling useful?\n\nIn Python file handling, is a method of file objects that returns the current position of the file pointer (cursor) within the file. It returns an integer representing the byte offset from the beginning of the file where the next read or write operation will occur. # Open a file in read mode file = open('example.txt', 'r') # Read the first 10 characters content = file.read(10) print(content) # Check the current position of the file pointer position = file.tell() print(\"Current position:\", position) # Close the file file.close()\n• None reads the first 10 characters from the file.\n• None returns the current position of the file pointer after reading."
    },
    {
        "link": "https://freecodecamp.org/news/file-handling-in-python",
        "document": "In this tutorial, you will learn how to open a file, write to the file, and close it. You will also learn how to read from the file using Python.\n\nBy the end of this tutorial, you should know the basics of how to use files in Python.\n\nFile handling is an important activity in every web app. The types of activities that you can perform on the opened file are controlled by Access Modes. These describe how the file will be used after it has been opened.\n\nThese modes also specify where the file handle should be located within the file. Similar to a pointer, a file handle indicates where data should be read or put into the file.\n\nIn Python, there are six methods or access modes, which are:\n• Read Only ('r’): This mode opens the text files for reading only. The start of the file is where the handle is located. It raises the I/O error if the file does not exist. This is the default mode for opening files as well.\n• Read and Write ('r+’): This method opens the file for both reading and writing. The start of the file is where the handle is located. If the file does not exist, an I/O error gets raised.\n• Write Only ('w’): This mode opens the file for writing only. The data in existing files are modified and overwritten. The start of the file is where the handle is located. If the file does not already exist in the folder, a new one gets created.\n• Write and Read ('w+’): This mode opens the file for both reading and writing. The text is overwritten and deleted from an existing file. The start of the file is where the handle is located.\n• Append Only ('a’): This mode allows the file to be opened for writing. If the file doesn't yet exist, a new one gets created. The handle is set at the end of the file. The newly written data will be added at the end, following the previously written data.\n• Append and Read (‘a+’): Using this method, you can read and write in the file. If the file doesn't already exist, one gets created. The handle is set at the end of the file. The newly written text will be added at the end, following the previously written data.\n\nBelow is the code required to create, write to, and read text files using the Python file handling methods or access modes.\n\nHow to Create Files in Python\n\nIn Python, you use the function with one of the following options – \"x\" or \"w\" – to create a new file:\n• \"x\" – Create: this command will create a new file if and only if there is no file already in existence with that name or else it will return an error.\n\nExample of creating a file in Python using the \"x\" command:\n\nWe've now created a new empty text file! But if you retry the code above – for example, if you try to create a new file with the same name as you used above (if you want to reuse the filename above) you will get an error notifying you that the file already exists. It'll look like the image below:\n• \"w\" – Write: this command will create a new text file whether or not there is a file in the memory with the new specified name. It does not return an error if it finds an existing file with the same name – instead it will overwrite the existing file.\n\nExample of how to create a file with the \"w\" command:\n\nWith the code above, whether the file exists or the file doesn't exist in the memory, you can still go ahead and use that code. Just keep in mind that it will overwrite the file if it finds an existing file with the same name.\n\nHow to Write to a File in Python\n\nThere are two methods of writing to a file in Python, which are:\n\nThis function inserts the string into the text file on a single line.\n\nBased on the file we have created above, the below line of code will insert the string into the created text file, which is \"myfile.txt.”\n\nThis function inserts multiple strings at the same time. A list of string elements is created, and each string is then added to the text file.\n\nUsing the previously created file above, the below line of code will insert the string into the created text file, which is \"myfile.txt.”\n\nHow to Read From a Text File in Python\n\nThere are three methods of reading data from a text file in Python. They are:\n\nThis function returns the bytes read as a string. If no n is specified, it then reads the entire file.\n\nThis function reads a line from a file and returns it as a string. It reads at most n bytes for the specified n. But even if n is greater than the length of the line, it does not read more than one line.\n\nThis function reads all of the lines and returns them as string elements in a list, one for each line.\n\nYou can read the first two lines by calling twice, reading the first two lines of the file:\n\nHow to Close a Text File in Python\n\nIt is good practice to always close the file when you are done with it.\n\nThis function closes the text file when you are done modifying it:\n\nThe close() function at the end of the code tells Python that well, I am done with this section of either creating or reading – it is just like saying End.\n\nThe program below shows more examples of ways to read and write data in a text file. Each line of code has comments to help you understand what's going on:\n\nThis is the output of the above code when run in the shell. I assigned \"This is Lagos\", \"This is Python\", and \"This is Fcc\" to \"L\" and then asked it to print using the ''file.read'' function.\n\nThe code above shows that the \"readline()\" function is returning the letter based on the number specified to it, while the \"readlines()\" function is returning every string assigned to \"L\" including the \n\n. That is, the \"readlines()\" function will print out all data in the file.\n\nHopefully, after going through this tutorial, you should understand what file handling is in Python. We also learned the modes/methods required to create, write, read, and close() a text file using some basic examples from Python."
    },
    {
        "link": "https://realpython.com/read-write-files-python",
        "document": "One of the most common tasks that you can do with Python is reading and writing files. Whether it’s writing to a simple text file, reading a complicated server log, or even analyzing raw byte data, all of these situations require reading or writing a file.\n• What makes up a file and why that’s important in Python\n• The basics of reading and writing files in Python\n• Some basic scenarios of reading and writing files\n\nThis tutorial is mainly for beginner to intermediate Pythonistas, but there are some tips in here that more advanced programmers may appreciate as well.\n\nBefore we can go into how to work with files in Python, it’s important to understand what exactly a file is and how modern operating systems handle some of their aspects. At its core, a file is a contiguous set of bytes used to store data. This data is organized in a specific format and can be anything as simple as a text file or as complicated as a program executable. In the end, these byte files are then translated into binary and for easier processing by the computer. Files on most modern file systems are composed of three main parts:\n• Header: metadata about the contents of the file (file name, size, type, and so on)\n• Data: contents of the file as written by the creator or editor\n• End of file (EOF): special character that indicates the end of the file What this data represents depends on the format specification used, which is typically represented by an extension. For example, a file that has an extension of most likely conforms to the Graphics Interchange Format specification. There are hundreds, if not thousands, of file extensions out there. For this tutorial, you’ll only deal with or file extensions. When you access a file on an operating system, a file path is required. The file path is a string that represents the location of a file. It’s broken up into three major parts:\n• Folder Path: the file folder location on the file system where subsequent folders are separated by a forward slash (Unix) or backslash (Windows)\n• File Name: the actual name of the file\n• Extension: the end of the file path pre-pended with a period ( ) used to indicate the file type Here’s a quick example. Let’s say you have a file located within a file structure like this: Let’s say you wanted to access the file, and your current location was in the same folder as . In order to access the file, you need to go through the folder and then the folder, finally arriving at the file. The Folder Path is . The File Name is . The File Extension is . So the full path is . Now let’s say that your current location or current working directory (cwd) is in the folder of our example folder structure. Instead of referring to the by the full path of , the file can be simply referenced by the file name and extension . / │ ├── path/ | │ | ├── to/ ← Your current working directory (cwd) is here | │ └── cats.gif ← Accessing this file | │ | └── dog_breeds.txt | └── animals.csv But what about ? How would you access that without using the full path? You can use the special characters double-dot ( ) to move one directory up. This means that will reference the file from the directory of : / │ ├── path/ ← Referencing this parent folder | │ | ├── to/ ← Current working directory (cwd) | │ └── cats.gif | │ | └── dog_breeds.txt ← Accessing this file | └── animals.csv The double-dot ( ) can be chained together to traverse multiple directories above the current directory. For example, to access from the folder, you would use . One problem often encountered when working with file data is the representation of a new line or line ending. The line ending has its roots from back in the Morse Code era, when a specific pro-sign was used to communicate the end of a transmission or the end of a line. Later, this was standardized for teleprinters by both the International Organization for Standardization (ISO) and the American Standards Association (ASA). ASA standard states that line endings should use the sequence of the Carriage Return ( or ) and the Line Feed ( or ) characters ( or ). The ISO standard however allowed for either the characters or just the character. Windows uses the characters to indicate a new line, while Unix and the newer Mac versions use just the character. This can cause some complications when you’re processing files on an operating system that is different than the file’s source. Here’s a quick example. Let’s say that we examine the file that was created on a Windows system: This same output will be interpreted on a Unix device differently: This can make iterating over each line problematic, and you may need to account for situations like this. Another common problem that you may face is the encoding of the byte data. An encoding is a translation from byte data to human readable characters. This is typically done by assigning a numerical value to represent a character. The two most common encodings are the ASCII and UNICODE Formats. ASCII can only store 128 characters, while Unicode can contain up to 1,114,112 characters. ASCII is actually a subset of Unicode (UTF-8), meaning that ASCII and Unicode share the same numerical to character values. It’s important to note that parsing a file with the incorrect character encoding can lead to failures or misrepresentation of the character. For example, if a file was created using the UTF-8 encoding, and you try to parse it using the ASCII encoding, if there is a character that is outside of those 128 values, then an error will be thrown.\n\nWhen you want to work with a file, the first thing to do is to open it. This is done by invoking the built-in function. has a single required argument that is the path to the file. has a single return, the file object: After you open a file, the next thing to learn is how to close it. Warning: You should always make sure that an open file is properly closed. To learn why, check out the Why Is It Important to Close Files in Python? tutorial. It’s important to remember that it’s your responsibility to close the file. In most cases, upon termination of an application or script, a file will be closed eventually. However, there is no guarantee when exactly that will happen. This can lead to unwanted behavior including resource leaks. It’s also a best practice within Python (Pythonic) to make sure that your code behaves in a way that is well defined and reduces any unwanted behavior. When you’re manipulating a file, there are two ways that you can use to ensure that a file is closed properly, even when encountering an error. The first way to close a file is to use the block: # Further file processing goes here If you’re unfamiliar with what the block is, check out Python Exceptions: An Introduction. The second way to close a file is to use the statement: # Further file processing goes here The statement automatically takes care of closing the file once it leaves the block, even in cases of error. I highly recommend that you use the statement as much as possible, as it allows for cleaner code and makes handling any unexpected errors easier for you. Most likely, you’ll also want to use the second positional argument, . This argument is a string that contains multiple characters to represent how you want to open the file. The default and most common is , which represents opening the file in read-only mode as a text file: # Further file processing goes here Other options for modes are fully documented online, but the most commonly used ones are the following: Open for writing, truncating (overwriting) the file first Let’s go back and talk a little about file objects. A file object is: “an object exposing a file-oriented API (with methods such as or ) to an underlying resource.” (Source) There are three different categories of file objects: Each of these file types are defined in the module. Here’s a quick rundown of how everything lines up. A text file is the most common file that you’ll encounter. Here are some examples of how these files are opened: With these types of files, will return a file object: This is the default file object returned by . A buffered binary file type is used for reading and writing binary files. Here are some examples of how these files are opened: With these types of files, will return either a or file object: “generally used as a low-level building-block for binary and text streams.” (Source) It is therefore not typically used. Here’s an example of how these files are opened: With these types of files, will return a file object:\n\nOnce you’ve opened up a file, you’ll want to read or write to the file. First off, let’s cover reading a file. There are multiple methods that can be called on a file object to help you out: What It Does This reads from the file based on the number of bytes. If no argument is passed or or is passed, then the entire file is read. This reads at most number of characters from the line. This continues to the end of the line and then wraps back around. If no argument is passed or or is passed, then the entire line (or rest of the line) is read. This reads the remaining lines from the file object and returns them as a list. Using the same file you used above, let’s go through some examples of how to use these methods. Here’s an example of how to open and read the entire file using : Here’s an example of how to read 5 bytes of a line each time using the Python method: # Read & print the first 5 characters of the line 5 times # Notice that line is greater than the 5 chars and continues # down the line, reading 5 chars each time until the end of the # line and then \"wraps\" around Here’s an example of how to read the entire file as a list using the Python method: The above example can also be done by using to create a list out of the file object: Iterating Over Each Line in the File A common thing to do while reading a file is to iterate over each line. Here’s an example of how to use the Python method to perform that iteration: # Read and print the entire file line by line # The EOF char is an empty string Another way you could iterate over each line in the file is to use the Python method of the file object. Remember, returns a list where each element in the list represents a line in the file: However, the above examples can be further simplified by iterating over the file object itself: # Read and print the entire file line by line This final approach is more Pythonic and can be quicker and more memory efficient. Therefore, it is suggested you use this instead. Note: Some of the above examples contain . The is to prevent Python from adding an additional newline to the text that is being printed and only print what is being read from the file. Now let’s dive into writing files. As with reading files, file objects have multiple methods that are useful for writing to a file: What It Does This writes the string to the file. This writes the sequence to the file. No line endings are appended to each sequence item. It’s up to you to add the appropriate line ending(s). Here’s a quick example of using and : # Alternatively you could use # Write the dog breeds to the file in reversed order Sometimes, you may need to work with files using byte strings. This is done by adding the character to the argument. All of the same methods for the file object apply. However, each of the methods expect and return a object instead: Opening a text file using the flag isn’t that interesting. Let’s say we have this cute picture of a Jack Russell Terrier ( ): You can actually open that file in Python and examine the contents! Since the file format is well defined, the header of the file is 8 bytes broken up like this: A “magic” number to indicate that this is the start of a Sure enough, when you open the file and read these bytes individually, you can see that this is indeed a header file: Let’s bring this whole thing home and look at a full example of how to read and write to a file. The following is a like tool that will convert a file that contains line endings of to . This tool is broken up into three major sections. The first is , which converts a string from line endings to . The second is , which converts a string that contains characters into . calls internally. Finally, there’s the block, which is called only when the file is executed as a script. Think of it as the function found in other programming languages. A simple script and library to convert files or strings from dos like Converts the string from \\r\n\n line endings to \n\n The string whose line endings will be converted Converts a file that contains Dos like line endings into Unix like The path to the source file to be converted The path to the converted file for output # Create our Argument parser and set its description \"Script that converts a DOS like file to an Unix like file\" # - source_file: the source file we want to convert # - dest_file: the destination where the output should go # Note: the use of the argument type of argparse.FileType could 'The location of the source ' # Parse the args (argparse automatically grabs the values from # If the destination file wasn't passed, then assume we want to # create a new file based on the old one\n\nNow that you’ve mastered the basics of reading and writing files, here are some tips and tricks to help you grow your skills. The attribute is a special attribute of modules, similar to . It is: “the pathname of the file from which the module was loaded, if it was loaded from a file.” (Source Note: To re-iterate, returns the path relative to where the initial Python script was called. If you need the full system path, you can use to get the current working directory of your executing code. Here’s a real world example. In one of my past jobs, I did multiple tests for a hardware device. Each test was written using a Python script with the test script file name used as a title. These scripts would then be executed and could print their status using the special attribute. Here’s an example folder structure: I was able to run and get the status of all my tests dynamically through use of the special attribute. Sometimes, you may want to append to a file or start writing at the end of an already populated file. This is easily done by using the character for the argument: When you examine again, you’ll see that the beginning of the file is unchanged and is now added to the end of the file: Working With Two Files at the Same Time There are times when you may want to read a file and write to another file at the same time. If you use the example that was shown when you were learning how to write to a file, it can actually be combined into the following: There may come a time when you’ll need finer control of the file object by placing it inside a custom class. When you do this, using the statement can no longer be used unless you add a few magic methods: and . By adding these, you’ll have created what’s called a context manager. is invoked when calling the statement. is called upon exiting from the statement block. Here’s a template that you can use to make your custom class: Now that you’ve got your custom class that is now a context manager, you can use it similarly to the built-in: Here’s a good example. Remember the cute Jack Russell image we had? Perhaps you want to open other files but don’t want to parse the header file each time. Here’s an example of how to do this. This example also uses custom iterators. If you’re not familiar with them, check out Python Iterators: # Every .png file contains this in the header. Use it to verify # the file is indeed a .png. # Ensure the file has the right extension \"The File is not a properly formatted .png file!\" # This and __next__() are used to create a custom iterator # The file hasn't been opened or reached EOF. This means we # can't go any further so stop the iteration by raising the # Each chunk has a len, type, data (based on len) and crc # Grab these values and return them as a tuple You can now open files and properly parse them using your custom context manager:"
    },
    {
        "link": "https://blog.logrocket.com/python-file-handling-guide",
        "document": "Python is a popular interpreted and dynamically typed programming language for building web services, desktop apps, automation scripts, and machine learning projects. Programmers often have to access the operating system’s file system when they work with Python-based software projects.\n\nFor example, we use text files as inputs, write text files as outputs, and process binary files often. Like any other popular, general-purpose programming language, Python also offers cross-platform file handling features. Python provides file handling features via several inbuilt functions and standard modules.\n\nIn this article, I will explain everything you need to know about Python file handling, including:\n\nBefore getting started with the tutorial, make sure that you have the Python 3 interpreter installed. Otherwise, install the latest Python interpreter from the official releases. You can use this tutorial’s code snippets in your existing Python projects, too.\n\nAs the first activity, let’s write some code to read a text file. We need to create a file object first to read files.\n\nPython offers the inbuilt function to create a file object with several modes, such as read mode, write mode, etc. Create a text file named and input the following content.\n\nNow, create a new file named and add the following code snippet.\n\nThe above code snippet’s first line creates the file object with the given filename. The inbuilt function creates a file handler using read mode because we have provided the flag via the second parameter.\n\nMake sure to call the method to free up resources after using the file. The method returns the file content, so you will see the content once you execute the above code, as shown below.\n\nThe method reads the entire file at once. If you don’t want to read all at once, you can specify a byte size with the method’s parameter. For example, the following code snippet reads only the first 11 bytes.\n\nYou will see the first word (“Programming”) as the output — because the first word has 11 letters and a letter’s size is equal to one byte in ASCII encoding. If you print the result of again, you will see the next 11 bytes (“ languages\n\n”) because the file cursor moved 11 places with the previous method call. You can reset the file cursor back to the beginning by using the method, as shown in the following example.\n\nIn most scenarios, it’s easy to process file content line by line. You don’t need to implement a lines-oriented file reading mechanism by yourself — Python provides inbuilt features to read a file line by line. You can read a file line by line with a loop and the method, as shown below.\n\nIt’s possible to get the current line number with a loop because the method will return lines using the list type. The following code snippet will print the line content with its respective line number.\n\nEarlier, we created file objects with the read mode by using the flag. Writing files is not possible with the read mode, so we have to use the write mode ( ) for writing files.\n\nIt is also possible to enable both read and write modes together using the or flag; we will use the flag in upcoming examples.\n\nTo get started with file writing, let’s input the following text to the current by writing some Python code.\n\nUse the following script to update with the above content.\n\nHere, we defined the text file content using the Python multiline string syntax, and we wrote the content to file using the method. Make sure to use the write mode with the flag — otherwise, the write operation will fail with the exception.\n\nSometimes, we often have to append new content to an existing file. In those scenarios, reading and writing the entire content is not a good approach due to the higher resources consumption. Instead, we can use the append mode ( ).\n\nLook at the following code. It will add a new programming language to the list in .\n\nThe above code snippet adds a new line character ( ) and a new word to the existing file without writing the entire file content. As a result, we will see a new entry in our programming languages list. Try adding more entries and see what happens!\n\nApart from the original file content, a file on the disk will contain some metadata, or file attributes, which include things like size, last modified time, last accessed time, etc.\n\nLook at the file code below, which displays file size, the last accessed time, and the last modified time.\n\nThe function returns a stat results object with many file attribute details. Here we used to get the file size, to get the last file accessed timestamp, and to get the last modified timestamp. The stat results object can be different according to your operating system. For example, on the Windows operating system, you can retrieve Windows-specific file attributes via the key.\n\nIf you need to get only file size, you can use the method without retrieving all metadata, as shown in the following code.\n\nPython offers the function to create a single directory. The following code snippet creates in the current working directory.\n\nIf you try to make multiple directories recursively with the above code, it will fail. For example, you can’t create at once because it requires the creation of multiple directories. In those scenarios, the function will help us, as shown below.\n\nPython also provides an easy API to list directory contents via the function. The following code snippet lists all files and directories in your current working directory.\n\nOnce you execute the above script, it will show your current directory’s entries, as shown below.\n\nTry executing the script from a different directory. Then it will display entries of that specific directory because we use the function to get the current working directory.\n\nSometimes we need to list directory content recursively. The function helps us with the recursive directory listing. The following code lists all entries of the current working directory recursively.\n\nThe function has a recursive implementation internally. It returns three values for each entry:\n\nHere we used , , and variables respectively, with a for-loop to capture all entries.\n\nWe can use the function to remove a file. It’s possible to use the function before to prevent exceptions. Look at the following example code snippet.\n\nThe Python standard library also offers the function to remove a single directory. It behaves similar to and won’t remove a directory if the particular directory has some entries. First, try to remove a single directory with the following code.\n\nThe above code will throw an error if contains subfolders or files. Use the following code snippet to remove a directory recursively.\n\nWhen we work with automation scripts, sometimes we need to perform file searches on the disk. For example, programmers often need to find log files, image files, and various text files via their Python scripts. There are a few different approaches to performing file searches in Python:\n• Finding all entries with the function and checking each entry with an condition inside a loop\n• Finding all entries recursively with the function and validating each entry with an condition inside a loop.\n• Querying all entries with the function and obtaining only entries you need\n\nOverall, the third approach is best for most scenarios because it has inbuilt filtering support, very good performance, and requires minimal code from the developer’s end (more Pythonic). Let’s implement a file search with the Python glob module.\n\nThe above code lists all Python source files in the current directory recursively. The first two asterisks ( ) in the query variable instruct Python to search every sub-directory, while the last asterisk refers to any filename.\n\nRun the above script. You will see Python source files, as shown below.\n\nTry to search different file types by changing the variable.\n\nEarlier, we processed text files. The inbuilt function creates file objects with the text mode ( ) by default. Non-text files such as image files, zip files, and video files cannot be viewed as plain-text files — because there are no readable English sentence binary files. Therefore, we have to treat binary files as non-text files via byte-level (or bit-level) processing.\n\nTo get started with binary file handling, let’s write a binary file with some bytes. We are going to save the following bytes into .\n\nFor simplicity, we can represent the above bytes with the following decimal values respectively.\n\nNow, add the following code to your Python source file and execute it to create the binary file.\n\nHere, we passed a byte array instance to the file object’s method. Also, note that we used binary mode ( ) to create the file object. After executing the above code snippet, open the newly created with your favorite text editor. You will see the following result.\n\nWe have received “Python” as the output because the byte array’s bytes represent known ASCII characters. For example, ( ) represents letter in ASCII encoding. Even though we saved readable text inside a binary file, almost all binary files contain unreadable byte streams. Try opening an image file via a text editor.\n\nNow we can see the binary file read operation in the following example code.\n\nPython returns bytes with the method for the binary mode. Here we converted bytes to a instance using the constructor.\n\nProgrammers often use archive files with Python-based web applications, web services, desktop applications, and utility programs to output or input multiple files at once. For example, if you are building a web-based file manager, you may offer a feature for users to download multiple files at once via a programmatically generated zip file.\n\nPython standard library offers archive file processing APIs via the module. First, let’s make an archive with ’s content. Look at the following code. Make sure to create and add some files into it before running the code snippet.\n\nYou can extract the archive file into with the following code.\n\nThe module offers cross-platform API functions to copy and move files as well. Look at the following examples.\n\nProgrammers follow various coding practices. Similarly, Python programmers also follow different coding practices when they handle files.\n\nFor example, some programmers use try-finally block and close file handlers manually. Some programmers let the garbage collector close the file handler by omitting the method call — which is not a good practice. Meanwhile, other programmers use the syntax to work with file handlers.\n\nIn this section, I will summarize some best practices for file handling in Python. First, look at the following code that follows file handling best practices.\n\nHere, we used the keyword to implicitly close the file handler. Also, we handle possible exceptions with a try-except block. While you are working with Python file handling, may sure that your code has the following points.\n• Never ignore exceptions — especially with long-running Python processes. However, it’s okay to ignore exceptions for simple utility scripts because unhandled exceptions halt utility scripts from continuing further\n• If you are not using the syntax, make sure to close opened file handlers properly. The Python garbage collector will clean the unclosed file handlers, but it’s always good to close a file handler via our code to avoid unwanted resource usages\n• Make sure to unify file handling syntaxes in your codebase. For example, if you use keyword for handling files, make sure to use the same syntax for all places where you are handling file\n• Avoid reopening the same file again when you read or write with multiple handlers. Instead, use the and methods, as shown below:\n\nThe above content saves a string to the file first. After that, it reads the newly added content again by resetting the internal buffer. The method clears the temporarily saved data in memory, so the next read will return the newly added content. Also, we need to use the method call to reset the cursor to the beginning because the method sets it to the end.\n\nPython offers a simple syntax for programmers. Therefore, almost all file operations are easy to implement. But, Python has some issues with the standard library design, so there are multiple API functions to the same thing. Therefore, you have to select the most suitable standard module according to your requirement.\n\nAlso, Python is a slow language compared to other popular programming languages. With this in mind, make sure to optimize your Python script without using too many resources. For example, you can optimize performance by processing large text files line by line without processing the entire content at once.\n\nIn this tutorial, we discussed generic text file handling and binary file handling. If you need to process specific file formats, it may be worth it to select a better library or standard module. For example, you can use the csv standard module for processing CSV files and the PyPDF2 library for processing PDF files. Also, the pickle standard module helps you to store (and load) Python data objects with files."
    },
    {
        "link": "https://realpython.com/python3-object-oriented-programming",
        "document": "Object-oriented programming (OOP) in Python helps you structure your code by grouping related data and behaviors into objects. You start by defining classes, which act as blueprints, and then create objects from them. OOP simplifies modeling real-world concepts in your programs and enables you to build systems that are more reusable and scalable.\n\nBy the end of this tutorial, you’ll understand that:\n• Object-oriented programming in Python involves creating classes as blueprints for objects. These objects contain data and the methods needed to manipulate that data.\n• The four key concepts of OOP in Python are encapsulation, inheritance, abstraction, and polymorphism.\n• You create an object in Python by instantiating a class, which involves calling the class name followed by parentheses.\n• Class inheritance in Python allows a class to inherit attributes and methods from another class, known as the parent class.\n• You use super() in Python to call a method from the parent class, allowing you to extend or modify inherited behavior.\n\nYou’ll explore how to define classes, instantiate classes to create objects, and leverage inheritance to build robust systems in Python.\n\nWhat Is Object-Oriented Programming in Python? Object-oriented programming is a programming paradigm that provides a means of structuring programs so that properties and behaviors are bundled into individual objects. For example, an object could represent a person with properties like a name, age, and address and behaviors such as walking, talking, breathing, and running. Or it could represent an email with properties like a recipient list, subject, and body and behaviors like adding attachments and sending. Put another way, object-oriented programming is an approach for modeling concrete, real-world things, like cars, as well as relations between things, like companies and employees or students and teachers. OOP models real-world entities as software objects that have some data associated with them and can perform certain operations. OOP also exists in other programming languages and is often described to center around the four pillars, or four tenants of OOP:\n• Encapsulation allows you to bundle data (attributes) and behaviors (methods) within a class to create a cohesive unit. By defining methods to control access to attributes and its modification, encapsulation helps maintain data integrity and promotes modular, secure code.\n• Inheritance enables the creation of hierarchical relationships between classes, allowing a subclass to inherit attributes and methods from a parent class. This promotes code reuse and reduces duplication.\n• Abstraction focuses on hiding implementation details and exposing only the essential functionality of an object. By enforcing a consistent interface, abstraction simplifies interactions with objects, allowing developers to focus on what an object does rather than how it achieves its functionality.\n• Polymorphism allows you to treat objects of different types as instances of the same base type, as long as they implement a common interface or behavior. Python’s duck typing make it especially suited for polymorphism, as it allows you to access attributes and methods on objects without needing to worry about their actual class. In this tutorial you’ll take a practical approach to understanding OOP in Python. But keeping these four concepts of object-oriented programming in mind may help you to remember the information that you gather. The key takeaway is that objects are at the center of object-oriented programming in Python. In other programming paradigms, objects only represent the data. In OOP, they additionally inform the overall structure of the program.\n\nHow Do You Define a Class in Python? In Python, you define a class by using the keyword followed by a name and a colon. Then you use to declare which attributes each instance of the class should have: But what does all of that mean? And why do you even need classes in the first place? Take a step back and consider using built-in, primitive data structures as an alternative. Primitive data structures—like numbers, strings, and lists—are designed to represent straightforward pieces of information, such as the cost of an apple, the name of a poem, or your favorite colors, respectively. What if you want to represent something more complex? For example, you might want to track employees in an organization. You need to store some basic information about each employee, such as their name, age, position, and the year they started working. One way to do this is to represent each employee as a list: There are a number of issues with this approach. First, it can make larger code files more difficult to manage. If you reference several lines away from where you declared the list, will you remember that the element with index is the employee’s name? Second, it can introduce errors if employees don’t have the same number of elements in their respective lists. In the list above, the age is missing, so will return instead of Dr. McCoy’s age. A great way to make this type of code more manageable and more maintainable is to use classes. Classes allow you to create user-defined data structures. Classes define functions called methods, which identify the behaviors and actions that an object created from the class can perform with its data. In this tutorial, you’ll create a class that stores some information about the characteristics and behaviors that an individual dog can have. A class is a blueprint for how to define something. It doesn’t actually contain any data. The class specifies that a name and an age are necessary for defining a dog, but it doesn’t contain the name or age of any specific dog. While the class is the blueprint, an instance is an object that’s built from a class and contains real data. An instance of the class is not a blueprint anymore. It’s an actual dog with a name, like Miles, who’s four years old. Put another way, a class is like a form or questionnaire. An instance is like a form that you’ve filled out with information. Just like many people can fill out the same form with their own unique information, you can create many instances from a single class. You start all class definitions with the keyword, then add the name of the class and a colon. Python will consider any code that you indent below the class definition as part of the class’s body. Here’s an example of a class: The body of the class consists of a single statement: the keyword. Python programmers often use as a placeholder indicating where code will eventually go. It allows you to run this code without Python throwing an error. Note: Python class names are written in CapitalizedWords notation by convention. For example, a class for a specific breed of dog, like the Jack Russell Terrier, would be written as . The class isn’t very interesting right now, so you’ll spruce it up a bit by defining some properties that all objects should have. There are several properties that you can choose from, including name, age, coat color, and breed. To keep the example small in scope, you’ll just use name and age. You define the properties that all objects must have in a method called . Every time you create a new object, sets the initial state of the object by assigning the values of the object’s properties. That is, initializes each new instance of the class. You can give any number of parameters, but the first parameter will always be a variable called . When you create a new class instance, then Python automatically passes the instance to the parameter in so that Python can define the new attributes on the object. Update the class with an method that creates and attributes: Make sure that you indent the method’s signature by four spaces, and the body of the method by eight spaces. This indentation is vitally important. It tells Python that the method belongs to the class. In the body of , there are two statements using the variable:\n• creates an attribute called and assigns the value of the parameter to it.\n• creates an attribute called and assigns the value of the parameter to it. Attributes created in are called instance attributes. An instance attribute’s value is specific to a particular instance of the class. All objects have a name and an age, but the values for the and attributes will vary depending on the instance. On the other hand, class attributes are attributes that have the same value for all class instances. You can define a class attribute by assigning a value to a variable name outside of . For example, the following class has a class attribute called with the value : You define class attributes directly beneath the first line of the class name and indent them by four spaces. You always need to assign them an initial value. When you create an instance of the class, then Python automatically creates and assigns class attributes to their initial values. Use class attributes to define properties that should have the same value for every class instance. Use instance attributes for properties that vary from one instance to another. Now that you have a class, it’s time to create some dogs!\n\nHow Do You Instantiate a Class in Python? Creating a new object from a class is called instantiating a class. You can create a new object by typing the name of the class, followed by opening and closing parentheses: You first create a new class with no attributes or methods, and then you instantiate the class to create a object. In the output above, you can see that you now have a new object at . This funny-looking string of letters and numbers is a memory address that indicates where Python stores the object in your computer’s memory. Note that the address on your screen will be different. Now instantiate the class a second time to create another object: The new instance is located at a different memory address. That’s because it’s an entirely new instance and is completely unique from the first object that you created. To see this another way, type the following: In this code, you create two new objects and assign them to the variables and . When you compare and using the operator, the result is . Even though and are both instances of the class, they represent two distinct objects in memory. Now create a new class with a class attribute called and two instance attributes called and : To instantiate this class, you need to provide values for and . If you don’t, then Python raises a : To pass arguments to the and parameters, put values into the parentheses after the class name: This creates two new instances—one for a four-year-old dog named Miles and one for a nine-year-old dog named Buddy. The class’s method has three parameters, so why are you only passing two arguments to it in the example? When you instantiate the class, Python creates a new instance of and passes it to the first parameter of . This essentially removes the parameter, so you only need to worry about the and parameters. Note: Behind the scenes, Python both creates and initializes a new object when you use this syntax. If you want to dive deeper, then you can read the dedicated tutorial about the Python class constructor. After you create the instances, you can access their instance attributes using dot notation: You can access class attributes the same way: One of the biggest advantages of using classes to organize data is that instances are guaranteed to have the attributes you expect. All instances have , , and attributes, so you can use those attributes with confidence, knowing that they’ll always return a value. Although the attributes are guaranteed to exist, their values can change dynamically: In this example, you change the attribute of the object to . Then you change the attribute of the object to , which is a species of cat. That makes Miles a pretty strange dog, but it’s valid Python! The key takeaway here is that custom objects are mutable by default. An object is mutable if you can alter it dynamically. For example, lists and dictionaries are mutable, but strings and tuples are immutable. Instance methods are functions that you define inside a class and can only call on an instance of that class. Just like , an instance method always takes as its first parameter. Open a new editor window in IDLE and type in the following class: This class has two instance methods:\n• returns a string displaying the name and age of the dog.\n• has one parameter called and returns a string containing the dog’s name and the sound that the dog makes. Save the modified class to a file called and press to run the program. Then open the interactive window and type the following to see your instance methods in action: In the above class, returns a string containing information about the instance . When writing your own classes, it’s a good idea to have a method that returns a string containing useful information about an instance of the class. However, isn’t the most Pythonic way of doing this. When you create a object, you can use to display a string that looks like the list: Go ahead and print the object to see what output you get: When you print , you get a cryptic-looking message telling you that is a object at the memory address . This message isn’t very helpful. You can change what gets printed by defining a special instance method called . In the editor window, change the name of the class’s method to : Save the file and press . Now, when you print , you get a much friendlier output: Methods like and are called dunder methods because they begin and end with double underscores. There are many dunder methods that you can use to customize classes in Python. Understanding dunder methods is an important part of mastering object-oriented programming in Python, but for your first exploration of the topic, you’ll stick with these two dunder methods. Note: Check out When Should You Use vs in Python? to learn more about and its cousin . If you want to reinforce your understanding with a practical exercise, then you can click on the block below and work on solving the challenge:\n• , which stores the name of the car’s color as a string\n• , which stores the number of miles on the car as an integer Then create two objects—a blue car with twenty thousand miles and a red car with thirty thousand miles—and print out their colors and mileage. Your output should look like this: There are multiple ways to solve this challenge. To effectively practice what you’ve learned so far, try to solve the task with the information about classes in Python that you’ve gathered in this section. When you’re done with your own implementation of the challenge, then you can expand the block below to see a possible solution: First, create a class with and instance attributes, and a method to format the display of objects when you pass them to : The and parameters of are assigned to and , which creates the two instance attributes. The method interpolates both instance attributes into an f-string and uses the format specifier to print the mileage grouped by thousands and separated with a comma. Now you can create the two instances: You create the instance by passing the value to the parameter and to the parameter. Similarly, you create with the values and . To print the color and mileage of each object, you can loop over a containing both objects and print each object: Because you’ve defined their string representation in , printing the objects gives you the desired text output. When you’re ready, you can move on to the next section. There, you’ll see how to take your knowledge one step further and create classes from other classes.\n\nHow Do You Inherit From Another Class in Python? Inheritance is the process by which one class takes on the attributes and methods of another. Newly formed classes are called child classes, and the classes that you derive child classes from are called parent classes. You inherit from a parent class by creating a new class and putting the name of the parent class into parentheses: In this minimal example, the child class inherits from the parent class . Because child classes take on the attributes and methods of parent classes, is also without your explicitly defining that. Note: This tutorial is adapted from the chapter “Object-Oriented Programming (OOP)” in Python Basics: A Practical Introduction to Python 3. If you enjoy what you’re reading, then be sure to check out the rest of the book and the learning path. You can also check out the Python Basics: Building Systems With Classes video course to reinforce the skills that you’ll develop in this section of the tutorial. Child classes can override or extend the attributes and methods of parent classes. In other words, child classes inherit all of the parent’s attributes and methods but can also specify attributes and methods that are unique to themselves. Although the analogy isn’t perfect, you can think of object inheritance sort of like genetic inheritance. You may have inherited your hair color from your parents. It’s an attribute that you were born with. But maybe you decide to color your hair purple. Assuming that your parents don’t have purple hair, you’ve just overridden the hair color attribute that you inherited from your parents: If you change the code example like this, then will be . You also inherit, in a sense, your language from your parents. If your parents speak English, then you’ll also speak English. Now imagine you decide to learn a second language, like German. In this case, you’ve extended your attributes because you’ve added an attribute that your parents don’t have: You’ll learn more about how the code above works in the sections below. But before you dive deeper into inheritance in Python, you’ll take a walk to a dog park to better understand why you might want to use inheritance in your own code. Pretend for a moment that you’re at a dog park. There are many dogs of different breeds at the park, all engaging in various dog behaviors. Suppose now that you want to model the dog park with Python classes. The class that you wrote in the previous section can distinguish dogs by name and age but not by breed. You could modify the class in the editor window by adding a attribute: Press to save the file. Now you can model the dog park by creating a bunch of different dogs in the interactive window: Each breed of dog has slightly different behaviors. For example, bulldogs have a low bark that sounds like woof, but dachshunds have a higher-pitched bark that sounds more like yap. Using just the class, you must supply a string for the argument of every time you call it on a instance: Passing a string to every call to is repetitive and inconvenient. Moreover, the attribute should determine the string representing the sound that each instance makes, but here you have to manually pass the correct string to every time you call it. You can simplify the experience of working with the class by creating a child class for each breed of dog. This allows you to extend the functionality that each child class inherits, including specifying a default argument for . In this section, you’ll create a child class for each of the three breeds mentioned above: Jack Russell terrier, dachshund, and bulldog. For reference, here’s the full definition of the class that you’re currently working with: After doing the dog park example in the previous section, you’ve removed again. You’ll now write code to keep track of a dog’s breed using child classes instead. To create a child class, you create a new class with its own name and then put the name of the parent class in parentheses. Add the following to the file to create three new child classes of the class: Press to save and run the file. With the child classes defined, you can now create some dogs of specific breeds in the interactive window: Instances of child classes inherit all of the attributes and methods of the parent class: To determine which class a given object belongs to, you can use the built-in : What if you want to determine if is also an instance of the class? You can do this with the built-in : Notice that takes two arguments, an object and a class. In the example above, checks if is an instance of the class and returns . The , , , and objects are all instances, but isn’t a instance, and isn’t a instance: More generally, all objects created from a child class are instances of the parent class, although they may not be instances of other child classes. Now that you’ve created child classes for some different breeds of dogs, you can give each breed its own sound. Since different breeds of dogs have slightly different barks, you want to provide a default value for the argument of their respective methods. To do this, you need to override in the class definition for each breed. To override a method defined on the parent class, you define a method with the same name on the child class. Here’s what that looks like for the class: Now is defined on the class with the default argument for set to . Update with the new class and press to save and run the file. You can now call on a instance without passing an argument to : Sometimes dogs make different noises, so if Miles gets angry and growls, you can still call with a different sound: One thing to keep in mind about class inheritance is that changes to the parent class automatically propagate to child classes. This occurs as long as the attribute or method being changed isn’t overridden in the child class. For example, in the editor window, change the string returned by in the class: Save the file and press . Now, when you create a new instance named , returns the new string: However, calling on a instance won’t show the new style of output: Sometimes it makes sense to completely override a method from a parent class. But in this case, you don’t want the class to lose any changes that you might make to the formatting of the output string. To do this, you still need to define a method on the child class. But instead of explicitly defining the output string, you need to call the class’s from inside the child class’s using the same arguments that you passed to . You can access the parent class from inside a method of a child class by using : When you call inside , Python searches the parent class, , for a method and calls it with the variable . Update with the new class. Save the file and press so you can test it in the interactive window: Now when you call , you’ll see output reflecting the new formatting in the class. Note: In the above examples, the class hierarchy is very straightforward. The class has a single parent class, . In real-world examples, the class hierarchy can get quite complicated. The function does much more than just search the parent class for a method or an attribute. It traverses the entire class hierarchy for a matching method or attribute. If you aren’t careful, can have surprising results. If you want to check your understanding of the concepts that you learned about in this section with a practical exercise, then you can click on the block below and work on solving the challenge: Start with the following code for your parent class: Create a class that inherits from the class. Give the argument of a default value of . When you’re done with your own implementation of the challenge, then you can expand the block below to see a possible solution: Create a class called that inherits from the class and overrides the method: You give as the default value to the parameter in . Then you use to call the method of the parent class with the same argument passed to as the class’s method. Nice work! In this section, you’ve learned how to override and extend methods from a parent class, and you worked on a small practical example to cement your new skills."
    },
    {
        "link": "https://geeksforgeeks.org/python-oops-concepts",
        "document": "Object Oriented Programming is a fundamental concept in Python, empowering developers to build modular, maintainable, and scalable applications. By understanding the core OOP principles (classes, objects, inheritance, encapsulation, polymorphism, and abstraction), programmers can leverage the full potential of Python OOP capabilities to design elegant and efficient solutions to complex problems.\n\nOOPs is a way of organizing code that uses objects and classes to represent real-world entities and their behavior. In OOPs, object has attributes thing that has specific data and can perform certain actions using methods.\n\nA class is a collection of objects. Classes are blueprints for creating objects. A class defines a set of attributes and methods that the created objects (instances) can have.\n• None Attributes are the variables that belong to a class.\n• None Attributes are always public and can be accessed using the dot (.) operator. Example: Myclass.Myattribute\n\nHere, the class keyword indicates that we are creating a class followed by name of the class (Dog in this case).\n• species: A class attribute shared by all instances of the class.\n• __init__ method: Initializes the name and age attributes when a new object is created.\n\nAn Object is an instance of a Class. It represents a specific implementation of the class and holds its own data.\n• State: It is represented by the attributes and reflects the properties of an object.\n• Behavior: It is represented by the methods of an object and reflects the response of an object to other objects.\n• Identity: It gives a unique name to an object and enables one object to interact with other objects.\n\nCreating an object in Python involves instantiating a class to create a new instance of that class. This process is also referred to as object instantiation.\n• dog1 = Dog(“Buddy”, 3): Creates an object of the Dog class with name as “Buddy” and age as 3.\n• dog1.name: Accesses the instance attribute name of the dog1 object.\n• dog1.species: Accesses the class attribute species of the dog1 object.\n\nself parameter is a reference to the current instance of the class. It allows us to access the attributes and methods of the object.\n• self.name: Refers to the name attribute of the object (dog1) calling the method.\n\n__init__ method is the constructor in Python, automatically called when a new object is created. It initializes the attributes of the class.\n\nIn Python, variables defined in a class can be either class variables or instance variables, and understanding the distinction between them is crucial for object-oriented programming.\n\nThese are the variables that are shared across all instances of a class. It is defined at the class level, outside any methods. All objects of the class share the same value for a class variable unless explicitly overridden in an object.\n\nVariables that are unique to each instance (object) of a class. These are defined within the __init__ method or other instance methods. Each object maintains its own copy of instance variables, independent of other objects.\n• Class Variable (species): Shared by all instances of the class. Changing Dog.species affects all objects, as it’s a property of the class itself.\n• Instance Variables (name, age): Defined in the __init__ method. Unique to each instance (e.g., dog1.name and dog2.name are different).\n• Accessing Variables: Class variables can be accessed via the class name (Dog.species) or an object (dog1.species). Instance variables are accessed via the object (dog1.name).\n• Updating Variables: Changing Dog.species affects all instances. Changing dog1.name only affects dog1 and does not impact dog2.\n\nInheritance allows a class (child class) to acquire properties and methods of another class (parent class). It supports hierarchical classification and promotes code reuse.\n• Multiple Inheritance: A child class inherits from more than one parent class.\n• Multilevel Inheritance: A child class inherits from a parent class, which in turn inherits from another class.\n• Hybrid Inheritance: A combination of two or more types of inheritance.\n• Multiple Inheritance: GoldenRetriever inherits from both Dog and Friendly.\n\nPolymorphism allows methods to have the same name but behave differently based on the object’s context. It can be achieved through method overriding or overloading.\n• Compile-Time Polymorphism : This type of polymorphism is determined during the compilation of the program. It allows methods or operators with the same name to behave differently based on their input parameters or usage. It is commonly referred to as method or operator overloading.\n• Run-Time Polymorphism : This type of polymorphism is determined during the execution of the program. It occurs when a subclass provides a specific implementation for a method already defined in its parent class, commonly known as method overriding.\n• None Demonstrated using method overriding in the Dog class and its subclasses (Labrador and Beagle).\n• None The correct sound method is invoked at runtime based on the actual type of the object in the list.\n• None Python does not natively support method overloading. Instead, we use a single method (add) with default arguments to handle varying numbers of parameters.\n• None Different behaviors (adding two or three numbers) are achieved based on how the method is called.\n\nEncapsulation is the bundling of data (attributes) and methods (functions) within a class, restricting access to some components to control interactions.\n\nA class is an example of encapsulation as it encapsulates all the data that is member functions, variables, etc.\n• Protected Members : Accessible within the class and its subclasses.\n• Private Members : Accessible only within the class.\n• Public Members: Easily accessible, such as name.\n• Protected Members : Used with a single _, such as _breed. Access is discouraged but allowed in subclasses.\n• Private Members: Used with __, such as __age. Access requires\n\nAbstraction hides the internal implementation details while exposing only the necessary functionality. It helps focus on “what to do” rather than “how to do it.”\n• Partial Abstraction: Abstract class contains both abstract and concrete methods.\n• Full Abstraction: Abstract class contains only abstract methods (like interfaces).\n• Why Use It : Abstraction ensures consistency in derived classes by enforcing the implementation of abstract methods.\n\nWhat are the 4 pillars of OOP Python?\n\nIs OOP used in Python?"
    },
    {
        "link": "https://kinsta.com/blog/python-object-oriented-programming",
        "document": "Programming is an art. And as in art, selecting the proper brushes and paints is essential to produce the best works. Python Object-Oriented Programming is one such skill.\n\nChoosing the right programming language is a crucial part of any project, and it can lead either to a fluid and enjoyable development or a complete nightmare. Hence, it would be best if you used the best-fit language for your use case.\n\nThat’s the primary reason to learn object-oriented programming in Python, which is also one of the most popular programming languages.\n\nBefore digging into the matter, let us pose a question: have you ever written a Python program like the one below?\n\nThis code is a simple number guesser. Try to copy it in a Python file and run it in your system. It perfectly accomplishes its purpose.\n\nBut here comes a huge problem: what if we asked you to implement a new feature? It could be something simple — for instance:\n\n“If the input is a multiple of the secret number, give the user a hint.”\n\nThe program would quickly grow complex and heavy as you increase the number of features and, therefore, the total number of nested conditionals.\n\nThat’s precisely the problem object-oriented programming tries to solve.\n\nBefore heading into object-oriented programming, we strongly recommend you have a firm grasp of Python basics.\n\nClassifying topics considered “basic” can be difficult. Because of this, we’ve designed a cheat sheet with all the main concepts needed to learn Object-Oriented programming in Python.\n• Variable: Symbolic name that points to a specific object (we’ll see what objects mean through the article).\n• Boolean expressions: Expressions in which the result is True or False.\n• Conditional: Evaluates a boolean expression and does some process depending on the result. Handled by if/else statements.\n• Loop: Repeated execution of code blocks. It can be for or while loops.\n• Functions: Block of organized and reusable code. You create them with the keyword def.\n• Run a Python script: Open a terminal or command line and type “python <name of the file>.”\n• Open a Python Shell: Open a terminal and type or depending on your system.\n\nNow you have these concepts crystal clear, you can move forward with understanding object-oriented programming.\n\nWhat Is Object-Oriented Programming in Python?\n\nObject-Oriented Programming (OOP) is a programming paradigm in which we can think about complex problems as objects.\n\nA paradigm is a theory that supplies the base for solving problems.\n\nSo when we’re talking about OOP, we’re referring to a set of concepts and patterns we use to solve problems with objects.\n\nAn object in Python is a single collection of data (attributes) and behavior (methods). You can think of objects as real things around you. For example, consider calculators:\n\nAs you may notice, the data (attributes) are always nouns, while the behaviors (method) are always verbs.\n\nThis compartmentalization is the central concept of Object-Oriented Programming. You build objects that store data and contain specific kinds of functionality.\n\nWhy Do We Use Object-Oriented Programming in Python?\n\nOOP allows you to create secure and reliable software. Many Python frameworks and libraries use this paradigm to build their codebase. Some examples are Django, Kivy, pandas, NumPy, and TensorFlow.\n\nLet’s see the main advantages of using OOP in Python.\n\nThe following reasons will make you opt for using object-oriented programming in Python.\n\nThis paradigm is language-independent. If you learn OOP in Python, you’ll be able to use it in the following:\n• PHP (make sure to read the comparison between PHP and Python)\n\nAll of these languages are either natively object-oriented or include options for object-oriented functionality. If you want to learn any of them after Python, it’ll be easier — you’ll find many similarities between languages working with objects.\n\nOOP Allows You to Code Faster\n\nCoding faster doesn’t mean writing fewer lines of code. It means you can implement more features in less time without compromising the stability of a project.\n\nObject-Oriented programming allows you to reuse code by implementing abstraction. This principle makes your code more concise and legible.\n\nAs you may know, programmers spend much more time reading code than writing it. It’s the reason legibility is always more important than getting features out as quickly as possible.\n\nYou’ll see more about the abstraction principle later.\n\nDo you remember the number guesser program at the start of this article?\n\nIf you keep adding features, you’ll have many nested if statements in the future. This tangle of endless lines of code is called spaghetti code, and you should avoid it as much as possible.\n\nOOP gives us the possibility of compressing all the logic in objects, therefore avoiding long pieces of nested if’s.\n\nOOP Improves Your Analysis of Any Situation\n\nOnce you get some experience with OOP, you’ll be able to think of problems as small and specific objects.\n\nStructured programming is the most-used paradigm by beginners because it is the simplest way to build a small program.\n\nIt involves running a Python program sequentially. That means you’re giving the computer a list of tasks and then executing them from top to bottom.\n\nLet’s see an example of structured programming with a coffee shop program.\n\nThe code above acts as a coffee shop vendor. It’ll ask you for a budget, then “sell” you the biggest coffee you’re capable of buying.\n\nTry to run it in the terminal. It’ll execute step by step, depending on your input.\n\nThis code works perfectly, but we have three problems:\n• It has a lot of repeated logic.\n• It uses many nested if conditionals.\n• It’ll be hard to read and modify.\n\nOOP was invented as a solution to all of these problems.\n\nLet’s see the above program implemented with OOP. Don’t worry if you don’t understand it yet. It’s only for comparing structured programming and object-oriented programming.\n\nNote: All the following concepts will be explained deeper through the article.\n\nThe above code represents a class named “Coffee.” It has two attributes — “name” and “price” — and they’re both used in the methods. The primary method is “sell,” which processes all the logic needed to complete the selling process.\n\nIf you try to run that class, you won’t get any output. It primarily occurs because we’re just declaring the “template” for the coffees, not the coffees themselves.\n\nLet’s implement that class with the following code:\n\nHere we’re making instances, or coffee objects, of the class “Coffee,” then calling the “sell” method of each coffee until the user can afford any option.\n\nWe’ll get the same output with both approaches, but we can extend the program functionality far better with OOP.\n\nBelow is a table comparing object-oriented programming and structured programming:\n• Neither paradigm is perfect (OOP can be overwhelming to use in simple projects).\n• These are just two ways of solving a problem; there are others out there.\n• OOP is used in large codebases, while structured programming is mainly for simple projects.\n\nLet’s move on to built-in objects in Python.\n\nEverything Is an Object in Python\n\nWe’ll tell you a secret: you’ve been using OOP all the time without noticing it.\n\nEven when using other paradigms in Python, you still use objects to do almost everything.\n\nThat’s because, in Python, everything is an object.\n\nRemember the definition of object: An object in Python is a single collection of data (attributes) and behavior (methods).\n\nThat matches any data type in Python.\n\nA string is a collection of data (characters) and behaviors (upper(), lower(), etc..). The same applies to integers, floats, booleans, lists, and dictionaries.\n\nBefore continuing, let’s review the meaning of attributes and methods.\n\nAttributes are internal variables inside objects, while methods are functions that produce some behavior.\n\nLet’s do a simple exercise in the Python shell. You can open it by typing or in your terminal.\n\nNow, let’s work with the Python shell to discover methods and types.\n\nIn the second line, we’re calling a string method, upper(). It returns the content of the string all in uppercase. However, it doesn’t change the original variable.\n\nLet’s delve into valuable functions when working with objects.\n\nThe type() function allows you to get the type of an object. The “type” is the class to which the object belongs.\n\nThe dir() function returns all the attributes and methods of an object. Let’s test it out with the kinsta variable.\n\nNow, try to print some of the hidden attributes of this object.\n\nThis will output the class the object kinsta belongs to. So we can say the only thing the type function returns is the __class__ attribute of an object.\n\nYou can experiment with all the data types, discovering all of their attributes and methods directly on the terminal. You can learn more about the built-in data types in the official documentation.\n\nYour First Object in Python\n\nA class is like a template. It allows you to create custom objects based on the attributes and methods you define.\n\nYou can think of it as a cookie-cutter that you modify to bake the perfect cookies (objects, not tracking cookies), with defined characteristics: Shape, Size, and more.\n\nOn the other hand, we have instances. An instance is an individual object of a class, which has a unique memory address.\n\nNow that you know what classes and instances are, let’s define some!\n\nTo define a class in Python, you use the class keyword, followed by its name. In this case, you’ll create a class named Cookie.\n\nNote: In Python, we use the camel case name convention to name classes.\n\nOpen your Python shell and type the code above. To create an instance of a class, just type its name and parenthesis after it. It’s the same process as invoking a function.\n\nCongratulations — you’ve just created your first object in Python! You can check its id and type with the following code:\n\nAs you can see, this cookie has a unique identifier in memory, and its type is Cookie.\n\nYou can also check if an object is an instance of a class with the isinstance() function.\n\nThe __init__() method is also named “constructor.” It’s called Python each time we instantiate an object.\n\nThe constructor creates the object’s initial state with the minimum set of parameters it needs to exist. Let’s modify the Cookie class, so it accepts parameters in its constructor.\n\nIn the Cookie class, every cookie must have a name, shape, and chips. We’ve defined the last one as “Chocolate.”\n\nOn the other hand, self refers to the instance of the class (the object itself).\n\nTry to paste the class in the shell and create an instance of the cookie as usual.\n\nYou’ll get an error. That’s because you must provide the minimal set of data the object needs to live — in this case, name and shape since we’ve already set chips to “Chocolate.”\n\nTo access the attributes of an instance, you must use the dot notation.\n\nFor now, the Cookie class doesn’t have anything too juicy. Let’s add a sample method bake() to make things more interesting.\n\nTo call a method, use the dot notation and invoke it as a function.\n\nThe 4 Pillars of OOP in Python\n\nAbstraction hides the internal functionality of an application from the user. The user could be either the end client or other developers.\n\nWe can find abstraction in our daily lives. For example, you know how to use your phone, but you probably don’t know exactly what’s happening inside it each time you open an app.\n\nAnother example is Python itself. You know how to use it to build functional software, and you can do it even if you don’t understand Python’s inner workings.\n\nApplying the same to code allows you to collect all the objects in a problem and abstract standard functionality into classes.\n\nInheritance allows us to define multiple subclasses from an already defined class.\n\nThe primary purpose of it is to follow the DRY principle. You’ll be able to reuse a lot of code by implementing all the sharing components into superclasses.\n\nYou can think of it as the real-life concept of genetic inheritance. Children (subclass) are the result of inheritance between two parents (superclasses). They inherit all the physical characteristics (attributes) and some common behaviors (methods).\n\nPolymorphism lets us slightly modify methods and attributes of the subclasses previously defined in the superclass.\n\nThe literal meaning is “many forms.” That’s because we build methods with the same name but different functionality.\n\nGoing back to the previous idea, children are also a perfect example of polymorphism. They can inherit a defined behavior get_hungry() but in a slightly different way, for instance, getting hungry every 4 hours instead of every 6.\n\nEncapsulation is the process in which we protect the internal integrity of data in a class.\n\nAlthough there isn’t a private statement in Python, you can apply encapsulation by using mangling in Python. There are special methods named getters and setters that allow us to access unique attributes and methods.\n\nLet’s imagine a Human class that has a unique attribute named _height. You can modify this attribute only within certain constraints (it’s nearly impossible to be higher than 3 meters).\n\nOne of the best things about Python is that it lets us create a wide variety of software, from a CLI (command-line interface) program to a complex web app.\n\nNow that you’ve learned the pillar concepts of OOP, it’s time to apply them to an actual project.\n\nNote: All of the following code will be available inside this GitHub repository. A code revision tool that helps us to manage code versions with Git.\n\nYour task is to create an area calculator of the following shapes:\n\nFirstly, create a file calculator.py and open it. Since we already have the objects to work with, it’ll be easy to abstract them in a class.\n\nYou can analyze the common characteristics and find out that all of these are 2D shapes. Therefore, the best option is to create a class Shape with a method get_area() from which each shape will inherit.\n\nNote: All the methods should be verbs. That’s because this method is named get_area() and not area().\n\nThe code above defines the class; however, there isn’t anything interesting in it yet.\n\nLet’s implement the standard functionality of most of these shapes.\n\nLet’s break down what we’re doing with this code:\n• In the __init__ method, we’re requesting two parameters, side1 and side2. These will remain as instance attributes.\n• The get_area() function returns the area of the shape. In this case, it’s using the formula of area of a rectangle since it’ll be easier to implement with other shapes.\n• The __str__() method is a “magic method” just as __init__(). It allows you to modify the way an instance will print.\n• The self.__class__.__name__ hidden attribute refers to the name of the class. If you were working with a Triangle class, that attribute would be “Triangle.”\n\nSince we implemented the formula of area of the Rectangle, we could create a simple Rectangle class that does nothing but inherit from the Shape class.\n\nTo apply inheritance in Python, you’ll create a class as usual and surround the superclass you want to inherit from by parenthesis.\n\nWe can take an excellent approach to polymorphism with the Square class.\n\nRemember that a square is just a rectangle whose four sides are all equal. That means we can use the same formula to get the area.\n\nWe can do this by modifying the init method, accepting only a side as a parameter, and passing that side value to the constructor of the Rectangle class.\n\nAs you can see, the super function passes the side parameter twice to the superclass. In other words, it’s passing side both as side1 and side2 to the previously defined constructor.\n\nA triangle is half as big as the rectangle that surrounds it.\n\nTherefore, we can inherit from the Rectangle class and modify the get_area method to match the triangle area formula, which is one-half of the base multiplied by the height.\n\nAnother use case of the super() function is to call a method defined in the superclass and store the result as a variable. That’s what’s happening inside the get_area() method.\n\nYou can find the circle area with the formula πr², where r is the circle’s radius. That means we have to modify the get_area() method to implement that formula.\n\nNote: We can import the approximate value of π from the math module\n\nThe code above defines the Circle class, which uses a different constructor and get_area() methods.\n\nAlthough Circle inherits from the Shape class, you can redefine every single method and attribute it to your liking.\n\nWe only need the length of a side of a regular hexagon to calculate its area. It’s similar to the Square class, where we only pass an argument to the constructor.\n\nHowever, the formula is quite different, and it implies the use of a square root. That’s why you’ll use the sqrt() function from the math module.\n\nYou can enter an interactive mode when running a Python file using a debugger. The simplest way to do this is by using the built-in breakpoint function.\n\nNote: This function is only available in Python 3.7 or newer.\n\nNow, run the Python file and play around with the classes you created.\n\nCreate a class with a method run where the user can choose a shape and calculate its area.\n\nWhen you’ve completed the challenge, you can send a pull request to the GitHub repo or publish your solution in the comment section.\n\nObject-oriented programming is a paradigm in which we solve problems by thinking of them as objects. If you understand Python OOP, you can also apply it easily in languages like Java, PHP, Javascript, and C#.\n\nIn this article, you’ve learned about:\n• The concept of object-oriented in Python\n• Concept of classes and how to use them in Python\n• The constructor of a class in Python\n• The four pillars of OOP\n\nNow it’s over to you!\n\nIf you liked this guide, check out our post on Python Tutorials.\n\nLet us know your solution to the challenge below in the comments! And don’t forget to check out our comparison guide between Python and PHP."
    },
    {
        "link": "https://medium.com/@taylorberukoff/object-oriented-principles-in-python-ffb44453270c",
        "document": "OOP is an important programming paradigm that has revolutionized the way developers think about software design. By creating objects that encapsulate both data and behavior, developers can more easily model complex systems and create reusable code. OOP has become increasingly popular in recent years as more and more developers embrace its benefits. One of the key advantages of OOP is its ability to create modular, reusable code. By breaking a system down into objects, developers can create smaller, more manageable pieces of code that can be reused in different parts of the system. This can lead to significant time savings and reduce the risk of bugs or errors in the code. At the heart of OOP is the concept of a class, which is a blueprint for creating objects. A class defines a set of attributes and methods that describe the behavior and characteristics of an object. To create an object from a class, you must first instantiate it using the method, which is a special method that is called when the object is created. This method allows you to initialize the object's attributes with default values. Here is an example of a simple class in Python: class Person:\n\n def __init__(self, name, age):\n\n self.name = name\n\n self.age = age\n\n\n\n def greet(self):\n\n print(f\"Hello, my name is {self.name} and I am {self.age} years old.\") In this example, we have defined a class with two attributes, and , and one method, . The method is used to initialize the and attributes with values passed in as arguments. It will be run any time you try to instantiate (make an actual object from) your class. The method (a function associated with an object) is used to print a message that includes the person's name and age. To create an instance of the class, we can simply call the class with the desired arguments: In this case, we have created a new object named with the attribute set to \"Alice\" and the attribute set to 25. We can now call the method on this object to print a message: Hello, my name is Alice and I am 25 years old.\n\nEncapsulation is one of the four fundamental principles of Object-Oriented Programming (OOP), alongside inheritance, polymorphism, and abstraction. It is the practice of hiding the implementation details of an object and allowing access to only the essential features that need to be used by other parts of the program. Encapsulation helps maintain the integrity of the object’s data and ensures that it is used only in the intended way. In Python, encapsulation is achieved through the use of access modifiers. Access modifiers are keywords that determine the visibility of a variable or method. The two most common access modifiers in Python are public and private. A public variable or method can be accessed from anywhere in the program, while a private variable or method can only be accessed within the class that defines it. Here’s an example of encapsulation in action: In this example, we have a class with two variables, and . The variable is declared as private by prefixing it with two underscores. This means that it can only be accessed within the class . We have also defined two methods and which allow us to retrieve and modify the value of respectively. When we create a new object, we pass in values for both and . We can access the variable using dot notation, as it is a public variable. However, when we try to access the variable directly, we get an error because it is private. Instead, we use the method to retrieve its value. We can also modify the value of using the method. However, we have added a check to make sure that the new value is greater than zero before assigning it to . This helps maintain the integrity of the object's data and ensures that it is used only in the intended way. Overall, encapsulation is an essential aspect of OOP as it allows us to create objects with well-defined interfaces and maintain the integrity of their data. By using access modifiers to control the visibility of variables and methods, we can ensure that our objects are used only in the intended way.\n\nInheritance is a powerful Object-Oriented Programming concept that allows us to create a new class based on an existing class. The new class is called the child class or subclass, and the existing class is called the parent class or superclass. Inheritance is an essential aspect of OOP as it allows us to reuse code and establish a hierarchical relationship between classes. In Python, inheritance is implemented using the syntax . The child class inherits all the attributes and methods of the parent class, and it can also have additional attributes and methods that are specific to it. The child class can also override or extend the methods of the parent class. Here is an example of inheritance in Python: class Animal:\n\n def __init__(self, name, species):\n\n self.name = name\n\n self.species = species\n\n \n\n def speak(self):\n\n print(f\"{self.name} says hi!\")\n\n\n\nclass Dog(Animal):\n\n def __init__(self, name, breed):\n\n super().__init__(name, \"Dog\")\n\n self.breed = breed\n\n \n\n def speak(self):\n\n print(f\"{self.name} barks!\") In this example, we have a parent class called , which has an method that takes a name and a species and sets them as instance variables. The class also has a method that prints out a message. We then create a child class called , which inherits from the class. The class has its own method that takes a name and a breed and calls the parent class's method to set the name and species. The class also overrides the method to print out a different message. Notice that we did not have to type out the initialization of the instance variables and for the subclass Dog. This is because Dog inherits all the attributes of the Animal class, and these instance variables are create upon running the function. We can now create instances of the and classes and call their methods: As we can see, the class has inherited the method from the class, but it has overridden it to print out a different message. This is an example of how inheritance can help us reuse code and create a hierarchy of classes.\n\nPolymorphism is another essential feature of Object-Oriented Programming. It is the ability of objects to take on different forms or behaviors. In Python, polymorphism allows objects to share the same interface, but with different implementations. One way to achieve polymorphism in Python is through the use of method overriding. Method overriding is when a subclass provides a different implementation of a method that is already defined in its superclass. When the method is called on an object of the subclass, the implementation in the subclass is used instead of the one in the superclass. Here is an example of method overriding in Python: class Animal:\n\n def speak(self):\n\n print(\"Animal is speaking...\")\n\n\n\nclass Dog(Animal):\n\n def speak(self):\n\n print(\"Dog is barking...\")\n\n\n\nclass Cat(Animal):\n\n def speak(self):\n\n print(\"Cat is meowing...\")\n\n\n\n# Create objects of the different classes\n\nanimal = Animal()\n\ndog = Dog()\n\ncat = Cat()\n\n\n\n# Call the speak() method on each object\n\nanimal.speak() # Output: Animal is speaking...\n\ndog.speak() # Output: Dog is barking...\n\ncat.speak() # Output: Cat is meowing... In this example, we have a superclass and two subclasses and . The and classes both have a method that overrides the method in the class. When we create objects of the different classes and call the method on them, the appropriate implementation is used based on the type of the object. Another way to achieve polymorphism in Python is through the use of duck typing. Duck typing is a concept in dynamic programming languages where the type of an object is less important than the methods it implements. If an object has a method with a certain name and signature, it is considered to be of a certain type, regardless of its actual class. Here is an example of duck typing in Python: class Duck:\n\n def quack(self):\n\n print(\"Quack!\")\n\n\n\nclass Person:\n\n def quack(self):\n\n print(\"I'm quacking like a duck...\")\n\n\n\ndef make_quack(obj):\n\n obj.quack()\n\n\n\n# Create objects of the Duck and Person classes\n\nduck = Duck()\n\nperson = Person()\n\n\n\n# Call the make_quack() function with the different objects\n\nmake_quack(duck) # Output: Quack!\n\nmake_quack(person) # Output: I'm quacking like a duck... In this example, we have a class and a class, both of which have a method. We also have a function that takes an object as a parameter and calls its method. When we call the function with objects of the and classes, the appropriate implementation is used based on the methods that are available on the objects, rather than their actual class.\n\nAbstraction is an important concept in Object-Oriented Programming (OOP) that allows programmers to create simplified and generalized models of complex systems. The idea is to define a set of common characteristics or behaviors that multiple objects share, and then group them together into a higher-level class that can be used to represent them all. One way to think of abstraction is to imagine a car. From a high level, we know that a car has certain common characteristics, such as wheels, an engine, and a steering wheel. However, the specifics of each car can vary greatly — some cars have four doors, some have two, some have sunroofs, etc. Abstraction allows us to focus on the common characteristics and behaviors of all cars while ignoring the specific details of each individual car. In Python, abstraction is often achieved through the use of abstract classes or interfaces. These are classes that define a set of methods that must be implemented by any class that inherits from them. For example, consider the following abstract class: This class defines two abstract methods, and , that must be implemented by any subclass of . Note that the decorator is used to indicate that these methods are abstract and should not be called directly. Instead, they are meant to be overridden by subclasses. Here is an example of a subclass of that implements the and methods: By inheriting from and implementing the abstract methods, is able to share the common characteristics and behaviors of all objects while still being able to define its own specific functionality. Abstraction can be a powerful tool in OOP because it allows programmers to create generalized models that can be easily extended and modified. By focusing on the common characteristics of objects, abstraction can make code more flexible and easier to maintain over time.\n\nObject-oriented programming provides a powerful and flexible way to organize and structure your code. To ensure your code is maintainable, scalable, and easy to understand, it’s important to follow best practices when developing your programs. Here are some key best practices to keep in mind when working with object-oriented programming in Python. 1.Keep Classes Focused. Each class should have a single responsibility and should be focused on one specific task. This principle, known as the Single Responsibility Principle (SRP), helps to keep your code organized and maintainable. It also makes it easier to reuse and test your code. For example, if you have a class that handles database connections, you should avoid adding methods that handle file I/O. Instead, you should create a separate class for file I/O operations. This keeps your code organized and ensures that each class has a clear and specific purpose. Here’s an example of a class that handles database connections: class DatabaseConnection:\n\n def __init__(self, host, port, username, password):\n\n self.host = host\n\n self.port = port\n\n self.username = username\n\n self.password = password\n\n self.connection = None\n\n \n\n def connect(self):\n\n # connect to the database using the provided credentials\n\n pass\n\n \n\n def disconnect(self):\n\n # disconnect from the database\n\n pass\n\n \n\n def execute_query(self, query):\n\n # execute the provided SQL query and return the results\n\n pass 2. Use Meaningful Names. The names you choose for your classes, methods, and variables should be descriptive and meaningful. This makes your code easier to read and understand. It also helps other developers who may need to work with your code in the future. For example, if you have a class that represents a user, you should name it User rather than something generic like Object. Similarly, you should use descriptive names for methods and variables. For instance, a variable that stores a user’s age should be named user_age instead of something like x or y. Here’s an example of a class with meaningful names: class User:\n\n def __init__(self, name, age, email):\n\n self.name = name\n\n self.age = age\n\n self.email = email\n\n \n\n def send_email(self, message):\n\n # send an email to the user using the provided message\n\n pass 3.Avoid Overusing inheritance. Inheritance can be a powerful tool in OOP, but it should be used judiciously. One common mistake is to create deep inheritance hierarchies that become difficult to manage and maintain. This can lead to issues such as tight coupling between classes, increased complexity, and reduced flexibility. Instead, strive for a flatter inheritance structure and consider other techniques such as composition to achieve the desired functionality. Here’s an example of overusing inheritance: class Animal:\n\n def __init__(self, name, species):\n\n self.name = name\n\n self.species = species\n\n \n\nclass Mammal(Animal):\n\n def __init__(self, name, species):\n\n super().__init__(name, species)\n\n \n\nclass Reptile(Animal):\n\n def __init__(self, name, species):\n\n super().__init__(name, species)\n\n \n\nclass Fish(Animal):\n\n def __init__(self, name, species):\n\n super().__init__(name, species)\n\n \n\nclass Dog(Mammal):\n\n def __init__(self, name):\n\n super().__init__(name, \"Canine\")\n\n \n\nclass Cat(Mammal):\n\n def __init__(self, name):\n\n super().__init__(name, \"Feline\")\n\n \n\nclass Snake(Reptile):\n\n def __init__(self, name):\n\n super().__init__(name, \"Serpent\")\n\n \n\nclass Goldfish(Fish):\n\n def __init__(self, name):\n\n super().__init__(name, \"Goldfish\") In this example, we have a class hierarchy that goes several levels deep, with each subclass adding very little functionality to the parent class. This can make the code difficult to understand and maintain, especially if there are many more subclasses added over time. Instead, it may be better to use composition or interfaces to achieve the desired behavior, without creating a complex class hierarchy."
    },
    {
        "link": "https://200oksolutions.com/blog/object-oriented-programming-in-python",
        "document": "A key idea in Python is object-oriented programming, or OOP, which lets programmers design intricate, modular, and scalable applications. OOP encourages more readable and maintainable code by organizing it into reusable components. We will explore the fundamental ideas of object-oriented programming (OOP) in Python, in this blog and demonstrate their practical implementation.\n\nObject-Oriented Programming (OOP) is a paradigm where everything is treated as an object that combines data (attributes) and behavior (methods). The primary goal of OOP is to simplify software development and make code more modular, flexible, and scalable.\n\nOOP in Python revolves around creating classes, which act as blueprints for objects. Classes define properties and behaviors, while objects are instances of these classes, each with unique attributes and shared methods.\n\nPython’s OOP system is based on four core concepts:\n• Class: A blueprint for creating objects. It defines attributes (variables) and methods (functions).\n• Object: An instance of a class containing data and behaviors.\n• Inheritance: A mechanism for creating a new class based on an existing class.\n• Polymorphism: The ability to use a function or an object in different ways.\n\n\n\nA class is a collection of objects. It defines the attributes (variables) and behaviors (methods) that the objects created from the class will have. Think of a class as a general template for objects that follow similar structures.\n\nIn this example:\n• Car is the class, and it has attributes like name and model, which you set in the constructor.\n• The __str__ method provides a custom string representation for the object, so when you print an instance like toyota, it outputs “Toyota Corolla”.\n\n\n\nAn object is an instance of a class. While a class is a blueprint, an object is the actual implementation of that class with specific values for its attributes. Each object can have unique attribute values but will share the class’s structure.\n\nHere, toyota is an object of the Car class with unique values for name (“Honda”) and model (“Odyssey”).\n\nInheritance is the mechanism of creating a new class from an existing class. The new class, called the subclass, inherits attributes and methods of the existing class, known as the superclass. This helps in reusing and extending existing code without duplication.\n\nIn this example, Car is the base class (parent class) and ElectricCar is inherited from the Car class. We are creating an electric car as a specialized version of a car with additional functionality specific to cars, like describing battery size.\n• describe_battery: This method prints the size of the battery, which is specific to electric cars.\n• start_engine: This method is inherited from the parent class. So, ElectricCar has access to both attributes and methods of the Car class.\n\nPolymorphism allows methods to be used interchangeably between different classes, making code more flexible. Polymorphism is commonly achieved through method overriding, where a subclass provides a specific implementation of a method that already exists in its superclass.\n\nHere, both Car and Bike have a drive method, but each behaves differently. Polymorphism allows us to call drive() on each vehicle without needing to know its specific class\n\n\n\nEncapsulation is the practice of hiding internal details of an object and only exposing what’s necessary. This is often achieved by making attributes private (using an underscore prefix) and providing getter and setter methods to access or modify these attributes safely.\n\nIn this example:\n• The __balance attribute is private and can’t be accessed directly outside of the class.\n• It can only be accessed or modified through get_balance and deposit methods, ensuring the balance is managed correctly.\n\nAbstraction is the concept of simplifying complex systems by modeling classes with only essential attributes and methods. It hides unnecessary details and focuses on functionality, making code cleaner and easier to understand.\n\nIn Python, we often use abstract classes to create a common interface for subclasses.\n\nIn this example:\n• The __radius attribute is private, so it can’t be accessed directly outside the Circle class.\n• The area and circumference can only be calculated through the area() and circumference() methods, ensuring the radius is used properly without exposing its details.\n\nObject-Oriented Programming (OOP) is a powerful paradigm that enhances code organization, readability, and maintainability. By employing the six core concepts—Class, Object, Inheritance, Polymorphism, Encapsulation, and Abstraction— you can write code that is more organized, efficient, and easier to debug, making it ideal for complex, scalable applications.\n\nWhat are the four main concepts of object-oriented programming in Python?\n• The four main concepts are classes, objects, inheritance, and polymorphism.\n\nHow does inheritance work in Python OOP?\n• Inheritance allows a class to use properties and methods of another class, creating a subclass from a superclass.\n\nWhat is the difference between encapsulation and abstraction?\n• Encapsulation hides data within a class to restrict access, while abstraction simplifies code by focusing on relevant properties and methods.\n\nHow do you create a class in Python?\n• Use the keyword followed by the class name, defining attributes and methods within the block.\n\nWhy is OOP beneficial for Python development?\n• OOP helps structure code in a way that makes it modular, easier to maintain, and scalable for complex projects.\n\nWhat are some real-world examples of Python OOP?\n• Examples include game development with character classes, banking applications, and user management in software.\n\n\n\nRefer to these resources for additional information"
    }
]