[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.web.httpresponse.redirect?view=netframework-4.8.1",
        "document": "The following example forces an unconditional redirection to another Web site.\n\nCalling Redirect is equivalent to calling Redirect with the second parameter set to .\n\nRedirect calls End which throws a ThreadAbortException exception upon completion. This exception has a detrimental effect on Web application performance. Therefore, we recommend that instead of this overload you use the HttpResponse.Redirect(String, Boolean) overload and pass for the parameter, and then call the CompleteRequest method. For more information, see the End method.\n\nFor mobile pages only, if your application relies on cookieless sessions, or might receive requests from mobile devices that require cookieless sessions, using a tilde (~) in a path can result in creating a new session and potentially losing session data. To set a property on a mobile control with a path such as \"~/path\", resolve the path using ResolveUrl \"~/path\" before assigning it to the property.\n\nASP.NET performs the redirection by returning a 302 HTTP status code. An alternative way to transfer control to another page is the Transfer method. The Transfer method is typically more efficient because it does not cause a round trip to the client. For more information, see How to: Redirect Users to Another Page."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpresponse.redirect?view=aspnetcore-9.0",
        "document": "Some information relates to prerelease product that may be substantially modified before it’s released. Microsoft makes no warranties, express or implied, with respect to the information provided here.\n\nReturns a redirect response (HTTP 301 or HTTP 302) to the client.\n\nThe URL to redirect the client to. This must be properly encoded for use in http headers where only ASCII characters are allowed.\n\nReturns a redirect response (HTTP 301 or HTTP 302) to the client. Public MustOverride Sub Redirect (location As String, permanent As Boolean) The URL to redirect the client to. This must be properly encoded for use in http headers where only ASCII characters are allowed. if the redirect is permanent (301), otherwise (302)."
    },
    {
        "link": "https://stackoverflow.com/questions/19294568/redirect-to-new-url-c-sharp-mvc-with-httpresponse-redirect",
        "document": "I am struggling with the method. I thought it would be included in but I am getting the\n\nThe name 'Response' does not exist in the current context\" error.\n\nThis is the entire controller:"
    },
    {
        "link": "https://stackoverflow.com/questions/11324711/redirect-from-asp-net-web-api-post-action",
        "document": "I'm very new to ASP.NET 4.0 Web API. Can we redirect to another URL at the end of the POST action?, something like ...\n\nActually I upload file from a MVC application (say ) through Web API (say )\n\nHere is the POST action. I post a multi-part form to Web API upload controller's post action. After uploading I would like to redirect back to .\n\nIs this possible?"
    },
    {
        "link": "https://infoworld.com/article/2259646/how-to-redirect-a-request-in-aspnet-core-mvc.html",
        "document": "ASP.NET Core is a cross-platform, open source, lean, fast, and modular framework for building high-performance web applications. ASP.NET Core MVC applications enable you to redirect a request to a specified URL in several different ways. This article talks about how we can accomplish this with code examples wherever appropriate.\n\nTo work with the code examples provided in this article, you should have Visual Studio 2019 installed in your system. If you don’t already have a copy, you can download Visual Studio 2019 here.\n\n[ Also on InfoWorld: How to refactor God objects in C# ]\n\nFirst off, let’s create an ASP.NET Core project in Visual Studio 2019. Assuming Visual Studio 2019 is installed in your system, follow the steps outlined below to create a new ASP.NET Core project in Visual Studio.\n• In the “Create new project” window, select “ASP.NET Core Web Application” from the list of templates displayed.\n• In the “Configure your new project” window, specify the name and location for the new project.\n• Optionally check the “Place solution and project in the same directory” check box, depending on your preferences.\n• In the “Create a New ASP.NET Core Web Application” window shown next, select .NET Core as the runtime and ASP.NET Core 3.1 (or later) from the drop-down list at the top.\n• Select “Web Application (Model-View-Controller)” as the project template to create a new ASP.NET Core MVC application.\n• Ensure that the check boxes “Enable Docker Support” and “Configure for HTTPS” are unchecked as we won’t be using those features here.\n• Ensure that Authentication is set to “No Authentication” as we won’t be using authentication either.\n\nFollowing these steps will create a new ASP.NET Core MVC project in Visual Studio 2019. We’ll use this project in the sections below to illustrate how we can redirect requests when working with action methods in ASP.NET Core 3.1.\n\nThere are several types of action results in ASP.NET Core MVC such as RedirectResult, RedirectToActionResult, RedirectToRouteResult, and LocalRedirectResult. All of these classes extend the ActionResult class and the IActionResult and IKeepTempDataResult interfaces and return Found (Http Status Code 302), Moved Permanently (Http Status Code 301), Temporary Redirect (Http Status Code 307), or Permanent Redirect (Http Status Code 308).\n\nWe’ll examine how we can work with each of these in this section.\n\nYou can use any of the following methods to return a RedirectResult:\n• Redirect – Http Status Code 302 Found (temporarily moved to the URL provided in the location header)\n\nThe following lines of code show how you can use each of these methods.\n\nAlternatively, you can return an instance of RedirectResult as shown in the code snippet given below.\n\nNote that the Redirect method can be used to redirect a request to a specified URL. This method is available in the abstract base class called ControllerBase.\n\nIt should be noted that the controllers you create in ASP.NET Core MVC extend the Controller class. This class in turn extends the ControllerBase class and implements the IActionFilter, IFilterMetadata, IAsyncActionFilter, and IDisposable interfaces.\n\nThis action result can be used to redirect to the specified action and controller. If no controller is specified it redirects to the specified action within the current controller. You can use any of the following methods to redirect to the specified action and return an instance of RedirectToActionResult from your action method.\n• RedirectToAction – Http Status Code 302 Found (temporarily moved to the URL provided in the location header)\n\nThe following code snippet illustrates how the RedirectToAction method can be used.\n\nYou can skip the controller name if you want to redirect the request to an action method in the current controller. The following code snippet shows how this can be achieved.\n\nThis is yet another action result that can be used to redirect the request to the specified route. You can use any of the following methods to return an instance of RedirectToRouteResult from your action method.\n• RedirectToRoute – Http Status Code 302 Found (temporarily moved to the URL provided in the location header)\n\nThe following code snippet shows how the RedirectToRoute method can be used.\n\nYou can also specify the route value when redirecting as shown in the code snippet given below.\n\nThis action result is used when you want to redirect to a local URL. It throws an InvalidOperationException if you use an external URL with it. You can use any of the following methods to return an instance of LocalRedirectResult from your action method.\n• LocalRedirect – Http Status Code 302 Found (temporarily moved to the URL provided in the location header)\n\nFinally, note that you can even redirect to razor pages using the RedirectToPage method, specifying the target razor page to redirect the request to. The RedirectToPage method returns a RedirectToPageResult instance together with a HTTP Status Code 302.\n\nIf you have a page named Author, where you want the request to be redirected, you can use the following code snippet.\n\nHow to do more in ASP.NET Core:\n• How to use attribute routing in ASP.NET Core\n• How to pass parameters to action methods in ASP.NET Core MVC\n• How to use API Analyzers in ASP.NET Core\n• How to use route data tokens in ASP.NET Core\n• How to use API versioning in ASP.NET Core\n• How to use Data Transfer Objects in ASP.NET Core 3.1\n• How to handle 404 errors in ASP.NET Core MVC\n• How to use dependency injection in action filters in ASP.NET Core 3.1\n• How to use the options pattern in ASP.NET Core\n• How to use endpoint routing in ASP.NET Core 3.0 MVC\n• How to export data to Excel in ASP.NET Core 3.0\n• How to use LoggerMessage in ASP.NET Core 3.0\n• How to send emails in ASP.NET Core\n• How to log data to SQL Server in ASP.NET Core\n• How to schedule jobs using Quartz.NET in ASP.NET Core\n• How to return data from ASP.NET Core Web API\n• How to format response data in ASP.NET Core\n• How to consume an ASP.NET Core Web API using RestSharp\n• How to perform async operations using Dapper\n• How to use feature flags in ASP.NET Core\n• How to use the FromServices attribute in ASP.NET Core\n• How to work with cookies in ASP.NET Core\n• How to work with static files in ASP.NET Core\n• How to use URL Rewriting Middleware in ASP.NET Core\n• How to implement rate limiting in ASP.NET Core\n• How to use Azure Application Insights in ASP.NET Core\n• How to handle errors in ASP.NET Web API\n• How to implement global exception handling in ASP.NET Core MVC\n• How to handle null values in ASP.NET Core MVC\n• How to work with worker services in ASP.NET Core\n• How to use the Data Protection API in ASP.NET Core\n• How to use conditional middleware in ASP.NET Core\n• How to work with session state in ASP.NET Core\n• How to write efficient controllers in ASP.NET Core"
    },
    {
        "link": "https://stackoverflow.com/questions/30356235/what-is-the-best-approach-for-redirecting-user-in-asp-net",
        "document": "I am new to asp.net development.I am currently working of asp.net web application. While resolving an issue came across exception \"thread is being aborted\". I went through several article to get deep understanding for the exception.\n\nI read this great article on codeproject by Shivprasad koirala which explained me about the use of and .\n\nThen I went to this post by Thomas Marquardt which made me conclude but better to use\n\nBut again this article by Imrambaloch says there is a security concern using , and to instead use\n\nNow in the end I am a bit confused as which is the recommended way to redirect.\n\nMy question: What is the best way to redirect user eliminating the security concerns and performance issues?\n\nIs really that bad as compared to ?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.web.httpresponse.redirect?view=netframework-4.8.1",
        "document": "The following example forces an unconditional redirection to another Web site.\n\nCalling Redirect is equivalent to calling Redirect with the second parameter set to .\n\nRedirect calls End which throws a ThreadAbortException exception upon completion. This exception has a detrimental effect on Web application performance. Therefore, we recommend that instead of this overload you use the HttpResponse.Redirect(String, Boolean) overload and pass for the parameter, and then call the CompleteRequest method. For more information, see the End method.\n\nFor mobile pages only, if your application relies on cookieless sessions, or might receive requests from mobile devices that require cookieless sessions, using a tilde (~) in a path can result in creating a new session and potentially losing session data. To set a property on a mobile control with a path such as \"~/path\", resolve the path using ResolveUrl \"~/path\" before assigning it to the property.\n\nASP.NET performs the redirection by returning a 302 HTTP status code. An alternative way to transfer control to another page is the Transfer method. The Transfer method is typically more efficient because it does not cause a round trip to the client. For more information, see How to: Redirect Users to Another Page."
    },
    {
        "link": "https://stackoverflow.com/questions/1917594/asp-net-best-practice-for-redirecting-to-https",
        "document": "I am working on a project that has one page that needs to make use of the SSL certificate. All of the links in the site to this page make use of https instead of http, but in the case that a user may navigate directly to the page I want the http version of the page to redirect to itself but use https.\n\nI can do a Response.Redirect in the page_load event. I can write javascript that will update the location.href which will cause the postback. I'm sure there are more ways to skin this cat.\n\nMy question is, what is the best practice for an ASP.NET site on IIS 6 or 7 to redirect an http page to https? Is there a best practice or are all alternatives equal?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/aspnet/core/fundamentals/url-rewriting?view=aspnetcore-9.0",
        "document": "This article introduces URL rewriting with instructions on how to use URL Rewriting Middleware in ASP.NET Core apps. URL rewriting is the act of modifying request URLs based on one or more predefined rules. URL rewriting creates an abstraction between resource locations and their addresses so that the locations and addresses aren't tightly linked. URL rewriting is valuable in several scenarios to:\n• Move or replace server resources temporarily or permanently and maintain stable locators for those resources.\n• Split request processing across different apps or across areas of one app.\n• Permit the use of friendly public URLs to help visitors predict the content returned by requesting a resource.\n• Prevent hotlinking, where an external site uses a hosted static asset on another site by linking the asset into its own content. URL rewriting can reduce the performance of an app. Limit the number and complexity of rules. The difference in wording between URL redirect and URL rewrite is subtle but has important implications for providing resources to clients. ASP.NET Core's URL Rewriting Middleware is capable of meeting the need for both. A URL redirect involves a client-side operation, where the client is instructed to access a resource at a different address than the client originally requested. This requires a round trip to the server. The redirect URL returned to the client appears in the browser's address bar when the client makes a new request for the resource. If is redirected to , the server responds that the client should obtain the resource at with a status code indicating that the redirect is either temporary or permanent. When redirecting requests to a different URL, indicate whether the redirect is permanent or temporary by specifying the status code with the response:\n• None The status code is used where the resource has a new, permanent URL and that all future requests for the resource should use the new URL. The client may cache and reuse the response when a 301 status code is received.\n• None The status code is used where the redirection is temporary or generally subject to change. The 302 status code indicates to the client not to store the URL and use it in the future. For more information on status codes, see RFC 9110: Status Code Definitions. A URL rewrite is a server-side operation that provides a resource from a different resource address than the client requested. Rewriting a URL doesn't require a round trip to the server. The rewritten URL isn't returned to the client and doesn't appear in the browser's address bar. If is rewritten to , the server internally fetches and returns the resource at . Although the client might be able to retrieve the resource at the rewritten URL, the client isn't informed that the resource exists at the rewritten URL when it makes its request and receives the response. Explore the features of the URL Rewriting Middleware with the sample app. The app applies redirect and rewrite rules and shows the redirected or rewritten URL for several scenarios. When to use URL rewriting middleware Use URL Rewriting Middleware when the following approaches aren't satisfactory: Use the URL rewriting middleware when the app is hosted on HTTP.sys server. The main reasons to use the server-based URL rewriting technologies in IIS, Apache, and Nginx are:\n• None The middleware doesn't support the full features of these modules. Some of the features of the server modules don't work with ASP.NET Core projects, such as the and constraints of the IIS Rewrite module. In these scenarios, use the middleware instead.\n• None The performance of the middleware probably doesn't match that of the modules. Benchmarking is the only way to know with certainty which approach degrades performance the most or if degraded performance is negligible. Establish URL rewrite and redirect rules by creating an instance of the RewriteOptions class with extension methods for each of the rewrite rules. Chain multiple rules in the order that they should be processed. The are passed into the URL Rewriting Middleware as it's added to the request pipeline with UseRewriter: using Microsoft.AspNetCore.Rewrite; using RewriteRules; var builder = WebApplication.CreateBuilder(args); var app = builder.Build(); using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); app.Run(); In the preceding code, is a user defined class. See in this article for more information. Three options permit the app to redirect non- requests to :\n• None AddRedirectToWwwPermanent: Permanently redirect the request to the subdomain if the request is non- . Redirects with a Status308PermanentRedirect status code.\n• None AddRedirectToWww: Redirect the request to the subdomain if the incoming request is non- . Redirects with a Status307TemporaryRedirect status code. An overload permits providing the status code for the response. Use a field of the StatusCodes class for a status code assignment. Use AddRedirect to redirect requests. The first parameter contains the .NET regular expression (Regex) for matching on the path of the incoming URL. The second parameter is the replacement string. The third parameter, if present, specifies the status code. If the status code isn't specified, the status code defaults to 302 - Found, which indicates that the resource is temporarily moved or replaced. using Microsoft.AspNetCore.Rewrite; using RewriteRules; var builder = WebApplication.CreateBuilder(args); var app = builder.Build(); using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); app.Run(); In a browser with developer tools enabled, make a request to the sample app with the path . The regular expression matches the request path on , and the path is replaced with . The redirect URL is sent back to the client with a 302 - Found status code. The browser makes a new request at the redirect URL, which appears in the browser's address bar. Since no rules in the sample app match on the redirect URL:\n• The second request receives a 200 - OK response from the app.\n• The body of the response shows the redirect URL. A round trip is made to the server when a URL is redirected. Be cautious when establishing redirect rules. Redirect rules are evaluated on every request to the app, including after a redirect. It's easy to accidentally create a loop of infinite redirects. The part of the expression contained within parentheses is called a capture group. The dot ( ) of the expression means match any character. The asterisk ( ) indicates match the preceding character zero or more times. Therefore, the last two path segments of the URL, , are captured by capture group . Any value provided in the request URL after is captured by this single capture group. In the replacement string, captured groups are injected into the string with the dollar sign ( ) followed by the sequence number of the capture. The first capture group value is obtained with , the second with , and they continue in sequence for the capture groups in the regular expression. There's only one captured group in the redirect rule regular expression in , so there's only one injected group in the replacement string, which is . When the rule is applied, the URL becomes . Try with the browser tools on the network tab. Use AddRedirectToHttps to redirect HTTP requests to the same host and path using the HTTPS protocol. If the status code isn't supplied, the middleware defaults to 302 - Found. If the port isn't supplied:\n• The scheme changes to (HTTPS protocol), and the client accesses the resource on port 443. The following example shows how to set the status code to and change the port to the HTTPS port used by Kestrel on localhost. In production, the HTTPS port is set to null: using Microsoft.AspNetCore.Rewrite; using RewriteRules; var builder = WebApplication.CreateBuilder(args); var app = builder.Build(); int? localhostHTTPSport = null; if (app.Environment.IsDevelopment()) { localhostHTTPSport = Int32.Parse(Environment.GetEnvironmentVariable( \"ASPNETCORE_URLS\")!.Split(new Char[] { ':', ';' })[2]); } using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() // localhostHTTPport not needed for production, used only with localhost. .AddRedirectToHttps(301, localhostHTTPSport) .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); app.Run(); Use AddRedirectToHttpsPermanent to redirect insecure requests to the same host and path with secure HTTPS protocol on port 443. The middleware sets the status code to . using Microsoft.AspNetCore.Rewrite; using RewriteRules; var builder = WebApplication.CreateBuilder(args); var app = builder.Build(); using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirectToHttpsPermanent() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); app.Run(); When redirecting to a secure endpoint without the requirement for additional redirect rules, we recommend using HTTPS Redirection Middleware. For more information, see Enforce HTTPS. The sample app demonstrates how to use or . Make an insecure HTTP request to the app at . When testing HTTP to HTTPS redirection with localhost:\n• Use the HTTP URL, which has a different port than the HTTPS URL. The HTTP URL is in the file.\n• Removing the from fails because localhost doesn't respond on HTTP to the HTTPS port. The following image shows the F12 browser tools image of a request to using the preceding code: Use AddRewrite to create a rule for rewriting URLs. The first parameter contains the regular expression for matching on the incoming URL path. The second parameter is the replacement string. The third parameter, , indicates to the middleware whether or not to skip additional rewrite rules if the current rule is applied. using Microsoft.AspNetCore.Rewrite; using RewriteRules; var builder = WebApplication.CreateBuilder(args); var app = builder.Build(); using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirectToHttpsPermanent() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); app.Run(); Try the request to The caret ( ) at the beginning of the expression means that matching starts at the beginning of the URL path. In the earlier example with the redirect rule, , there's no caret ( ) at the start of the regular expression. Therefore, any characters may precede in the path for a successful match. The rewrite rule, , only matches paths if they start with . In the following table, note the difference in matching. Following the portion of the expression, there are two capture groups, . The signifies match a digit (number). The plus sign ( ) means match one or more of the preceding character. Therefore, the URL must contain a number followed by a forward-slash followed by another number. These capture groups are injected into the rewritten URL as and . The rewrite rule replacement string places the captured groups into the query string. The requested path is rewritten to return the resource at . If a query string is present on the original request, it's preserved when the URL is rewritten. There's no round trip to the server to return the resource. If the resource exists, it's fetched and returned to the client with a 200 - OK status code. Because the client isn't redirected, the URL in the browser's address bar doesn't change. Clients can't detect that a URL rewrite operation occurred on the server.\n• Order rewrite rules from the most frequently matched rule to the least frequently matched rule.\n• Use whenever possible because matching rules is computationally expensive and increases app response time. Skip the processing of the remaining rules when a match occurs and no additional rule processing is required. A malicious user can provide expensive to process input to causing a Denial-of-Service attack. ASP.NET Core framework APIs that use pass a timeout. For example, the RedirectRule and RewriteRule classes both pass in a one second timeout. Apply Apache mod_rewrite rules with AddApacheModRewrite. Make sure that the rules file is deployed with the app. For more information and examples of mod_rewrite rules, see Apache mod_rewrite. A StreamReader is used to read the rules from the ApacheModRewrite.txt rules file: using Microsoft.AspNetCore.Rewrite; using RewriteRules; var builder = WebApplication.CreateBuilder(args); var app = builder.Build(); using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirectToHttpsPermanent() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); app.Run(); The sample app redirects requests from to . The response status code is 302 - Found. Try the request to The Apache middleware supports the following Apache mod_rewrite server variables: To use the same rule set that applies to the IIS URL Rewrite Module, use AddIISUrlRewrite. Make sure that the rules file is deployed with the app. Don't direct the middleware to use the app's web.config file when running on Windows Server IIS. With IIS, these rules should be stored outside of the app's web.config file in order to avoid conflicts with the IIS Rewrite module. For more information and examples of IIS URL Rewrite Module rules, see Using Url Rewrite Module 2.0 and URL Rewrite Module Configuration Reference. A StreamReader is used to read the rules from the rules file: using Microsoft.AspNetCore.Rewrite; using RewriteRules; var builder = WebApplication.CreateBuilder(args); var app = builder.Build(); using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirectToHttpsPermanent() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); app.Run(); The sample app rewrites requests from to . The response is sent to the client with a 200 - OK status code. Try the request to Apps that have an active IIS Rewrite Module with server-level rules configured that impacts the app in undesirable ways:\n• Consider disabling the IIS Rewrite Module for the app.\n• For more information, see Disabling IIS modules. The middleware doesn't support the following IIS URL Rewrite Module features: The middleware supports the following IIS URL Rewrite Module server variables: IFileProvider can be obtained via a PhysicalFileProvider. This approach may provide greater flexibility for the location of rewrite rules files. Make sure that the rewrite rules files are deployed to the server at the path provided. Use Add to implement custom rule logic in a method. exposes the RewriteContext, which makes available the HttpContext for use in redirect methods. The RewriteContext.Result property determines how additional pipeline processing is handled. Set the value to one of the RuleResult fields described in the following table. Stop applying rules and send the context to the next middleware. using Microsoft.AspNetCore.Rewrite; using RewriteRules; var builder = WebApplication.CreateBuilder(args); var app = builder.Build(); using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirectToHttpsPermanent() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); app.Run(); The sample app demonstrates a method that redirects requests for paths that end with . When a request is made for :\n• The request is redirected to\n• The status code is set to . When the browser makes a new request for , Static File Middleware serves the file to the client from the wwwroot/xmlfiles folder. For a redirect, explicitly set the status code of the response. Otherwise, a 200 - OK status code is returned, and the redirect doesn't occur on the client. public static void RedirectXmlFileRequests(RewriteContext context) { var request = context.HttpContext.Request; // Because the client is redirecting back to the same app, stop // processing if the request has already been redirected. if (request.Path.StartsWithSegments(new PathString(\"/xmlfiles\")) || request.Path.Value==null) { return; } if (request.Path.Value.EndsWith(\".xml\", StringComparison.OrdinalIgnoreCase)) { var response = context.HttpContext.Response; response.StatusCode = (int) HttpStatusCode.MovedPermanently; context.Result = RuleResult.EndResponse; response.Headers[HeaderNames.Location] = \"/xmlfiles\" + request.Path + request.QueryString; } } This approach can also rewrite requests. The sample app demonstrates rewriting the path for any text file request to serve the file.txt text file from the wwwroot folder. Static File Middleware serves the file based on the updated request path: using Microsoft.AspNetCore.Rewrite; using RewriteRules; var builder = WebApplication.CreateBuilder(args); var app = builder.Build(); using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirectToHttpsPermanent() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); app.Run(); Use Add to use rule logic in a class that implements the IRule interface. provides greater flexibility over using the method-based rule approach. The implementation class may include a constructor that allows passing in parameters for the ApplyRule method. using Microsoft.AspNetCore.Rewrite; using RewriteRules; var builder = WebApplication.CreateBuilder(args); var app = builder.Build(); using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirectToHttpsPermanent() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); app.Run(); The values of the parameters in the sample app for the and the are checked to meet several conditions. The must contain a value, and the value must be , , or . If the isn't valid, an ArgumentException is thrown. If a request is made for , the request is redirected to . If a request is made for , the request is redirected to . The status code is set to , and the is set to stop processing rules and send the response. public class RedirectImageRequests : IRule { private readonly string _extension; private readonly PathString _newPath; public RedirectImageRequests(string extension, string newPath) { if (string.IsNullOrEmpty(extension)) { throw new ArgumentException(nameof(extension)); } if (!Regex.IsMatch(extension, @\"^\\.(png|jpg|gif)$\")) { throw new ArgumentException(\"Invalid extension\", nameof(extension)); } if (!Regex.IsMatch(newPath, @\"(/[A-Za-z0-9]+)+?\")) { throw new ArgumentException(\"Invalid path\", nameof(newPath)); } _extension = extension; _newPath = new PathString(newPath); } public void ApplyRule(RewriteContext context) { var request = context.HttpContext.Request; // Because we're redirecting back to the same app, stop // processing if the request has already been redirected if (request.Path.StartsWithSegments(new PathString(_newPath)) || request.Path.Value == null) { return; } if (request.Path.Value.EndsWith(_extension, StringComparison.OrdinalIgnoreCase)) { var response = context.HttpContext.Response; response.StatusCode = (int) HttpStatusCode.MovedPermanently; context.Result = RuleResult.EndResponse; response.Headers[HeaderNames.Location] = _newPath + request.Path + request.QueryString; } } } The links in the preceding table use the following code deployed to Azure: using Microsoft.AspNetCore.Rewrite; using RewriteRules; var builder = WebApplication.CreateBuilder(args); var app = builder.Build(); using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirectToHttpsPermanent() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) // Rewrite path to QS. .AddRewrite(@\"^path/(.*)/(.*)\", \"path?var1=$1&var2=$2\", skipRemainingRules: true) // Skip trailing slash. .AddRewrite(@\"^path2/(.*)/$\", \"path2/$1\", skipRemainingRules: true) // Enforce trailing slash. .AddRewrite(@\"^path3/(.*[^/])$\", \"path3/$1/\", skipRemainingRules: true) // Avoid rewriting specific requests. .AddRewrite(@\"^path4/(.*)(?<!\\.axd)$\", \"rewritten/$1\", skipRemainingRules: true) // Rearrange URL segments .AddRewrite(@\"^path5/(.*)/(.*)/(.*)\", \"path5/$3/$2/$1\", skipRemainingRules: true) // Replace a URL segment .AddRewrite(@\"^path6/(.*)/segment2/(.*)\", \"path6/$1/replaced/$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); app.Run(); In most of the preceding regular expression samples, the literal is used to make unique testable rewrite rules for the deployed sample. Typically the regular expression wouldn't include . For example, see these regular expression examples table.\n\nThis document introduces URL rewriting with instructions on how to use URL Rewriting Middleware in ASP.NET Core apps. URL rewriting is the act of modifying request URLs based on one or more predefined rules. URL rewriting creates an abstraction between resource locations and their addresses so that the locations and addresses aren't tightly linked. URL rewriting is valuable in several scenarios to:\n• Move or replace server resources temporarily or permanently and maintain stable locators for those resources.\n• Split request processing across different apps or across areas of one app.\n• Permit the use of friendly public URLs to help visitors predict the content returned by requesting a resource.\n• Prevent hotlinking, where an external site uses a hosted static asset on another site by linking the asset into its own content. URL rewriting can reduce the performance of an app. Where feasible, limit the number and complexity of rules. View or download sample code (how to download) The difference in wording between URL redirect and URL rewrite is subtle but has important implications for providing resources to clients. ASP.NET Core's URL Rewriting Middleware is capable of meeting the need for both. A URL redirect involves a client-side operation, where the client is instructed to access a resource at a different address than the client originally requested. This requires a round trip to the server. The redirect URL returned to the client appears in the browser's address bar when the client makes a new request for the resource. If is redirected to , the server responds that the client should obtain the resource at with a status code indicating that the redirect is either temporary or permanent. When redirecting requests to a different URL, indicate whether the redirect is permanent or temporary by specifying the status code with the response:\n• None The status code is used where the resource has a new, permanent URL and you wish to instruct the client that all future requests for the resource should use the new URL. The client may cache and reuse the response when a 301 status code is received.\n• None The 302 - Found status code is used where the redirection is temporary or generally subject to change. The 302 status code indicates to the client not to store the URL and use it in the future. For more information on status codes, see RFC 9110: Status Code Definitions. A URL rewrite is a server-side operation that provides a resource from a different resource address than the client requested. Rewriting a URL doesn't require a round trip to the server. The rewritten URL isn't returned to the client and doesn't appear in the browser's address bar. If is rewritten to , the server internally fetches and returns the resource at . Although the client might be able to retrieve the resource at the rewritten URL, the client isn't informed that the resource exists at the rewritten URL when it makes its request and receives the response. You can explore the features of the URL Rewriting Middleware with the sample app. The app applies redirect and rewrite rules and shows the redirected or rewritten URL for several scenarios. When to use URL rewriting middleware Use URL Rewriting Middleware when you're unable to use the following approaches: Use the URL rewriting middleware when the app is hosted on HTTP.sys server. The main reasons to use the server-based URL rewriting technologies in IIS, Apache, and Nginx are:\n• None The middleware doesn't support the full features of these modules. Some of the features of the server modules don't work with ASP.NET Core projects, such as the and constraints of the IIS Rewrite module. In these scenarios, use the middleware instead.\n• None The performance of the middleware probably doesn't match that of the modules. Benchmarking is the only way to know for sure which approach degrades performance the most or if degraded performance is negligible. URL Rewriting Middleware is provided by the Microsoft.AspNetCore.Rewrite package, which is implicitly included in ASP.NET Core apps. Establish URL rewrite and redirect rules by creating an instance of the RewriteOptions class with extension methods for each of your rewrite rules. Chain multiple rules in the order that you would like them processed. The are passed into the URL Rewriting Middleware as it's added to the request pipeline with UseRewriter: public void Configure(IApplicationBuilder app) { using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); } Three options permit the app to redirect non- requests to :\n• None AddRedirectToWwwPermanent: Permanently redirect the request to the subdomain if the request is non- . Redirects with a Status308PermanentRedirect status code.\n• None AddRedirectToWww: Redirect the request to the subdomain if the incoming request is non- . Redirects with a Status307TemporaryRedirect status code. An overload permits you to provide the status code for the response. Use a field of the StatusCodes class for a status code assignment. Use AddRedirect to redirect requests. The first parameter contains your Regex for matching on the path of the incoming URL. The second parameter is the replacement string. The third parameter, if present, specifies the status code. If you don't specify the status code, the status code defaults to 302 - Found, which indicates that the resource is temporarily moved or replaced. public void Configure(IApplicationBuilder app) { using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); } In a browser with developer tools enabled, make a request to the sample app with the path . The regex matches the request path on , and the path is replaced with . The redirect URL is sent back to the client with a 302 - Found status code. The browser makes a new request at the redirect URL, which appears in the browser's address bar. Since no rules in the sample app match on the redirect URL:\n• The second request receives a 200 - OK response from the app.\n• The body of the response shows the redirect URL. A round trip is made to the server when a URL is redirected. Be cautious when establishing redirect rules. Redirect rules are evaluated on every request to the app, including after a redirect. It's easy to accidentally create a loop of infinite redirects. The part of the expression contained within parentheses is called a capture group. The dot ( ) of the expression means match any character. The asterisk ( ) indicates match the preceding character zero or more times. Therefore, the last two path segments of the URL, , are captured by capture group . Any value you provide in the request URL after is captured by this single capture group. In the replacement string, captured groups are injected into the string with the dollar sign ( ) followed by the sequence number of the capture. The first capture group value is obtained with , the second with , and they continue in sequence for the capture groups in your regex. There's only one captured group in the redirect rule regex in the sample app, so there's only one injected group in the replacement string, which is . When the rule is applied, the URL becomes . Use AddRedirectToHttps to redirect HTTP requests to the same host and path using the HTTPS protocol. If the status code isn't supplied, the middleware defaults to 302 - Found. If the port isn't supplied:\n• The scheme changes to (HTTPS protocol), and the client accesses the resource on port 443. The following example shows how to set the status code to and change the port to 5001. Use AddRedirectToHttpsPermanent to redirect insecure requests to the same host and path with secure HTTPS protocol on port 443. The middleware sets the status code to . When redirecting to a secure endpoint without the requirement for additional redirect rules, we recommend using HTTPS Redirection Middleware. For more information, see the Enforce HTTPS topic. The sample app is capable of demonstrating how to use or . Add the extension method to the . Make an insecure request to the app at any URL. Dismiss the browser security warning that the self-signed certificate is untrusted or create an exception to trust the certificate. Use AddRewrite to create a rule for rewriting URLs. The first parameter contains the regex for matching on the incoming URL path. The second parameter is the replacement string. The third parameter, , indicates to the middleware whether or not to skip additional rewrite rules if the current rule is applied. public void Configure(IApplicationBuilder app) { using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); } The carat ( ) at the beginning of the expression means that matching starts at the beginning of the URL path. In the earlier example with the redirect rule, , there's no carat ( ) at the start of the regex. Therefore, any characters may precede in the path for a successful match. The rewrite rule, , only matches paths if they start with . In the following table, note the difference in matching. Following the portion of the expression, there are two capture groups, . The signifies match a digit (number). The plus sign ( ) means match one or more of the preceding character. Therefore, the URL must contain a number followed by a forward-slash followed by another number. These capture groups are injected into the rewritten URL as and . The rewrite rule replacement string places the captured groups into the query string. The requested path of is rewritten to obtain the resource at . If a query string is present on the original request, it's preserved when the URL is rewritten. There's no round trip to the server to obtain the resource. If the resource exists, it's fetched and returned to the client with a 200 - OK status code. Because the client isn't redirected, the URL in the browser's address bar doesn't change. Clients can't detect that a URL rewrite operation occurred on the server. Use whenever possible because matching rules is computationally expensive and increases app response time. For the fastest app response:\n• Order rewrite rules from the most frequently matched rule to the least frequently matched rule.\n• Skip the processing of the remaining rules when a match occurs and no additional rule processing is required. Apply Apache mod_rewrite rules with AddApacheModRewrite. Make sure that the rules file is deployed with the app. For more information and examples of mod_rewrite rules, see Apache mod_rewrite. A StreamReader is used to read the rules from the ApacheModRewrite.txt rules file: public void Configure(IApplicationBuilder app) { using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); } The sample app redirects requests from to . The response status code is 302 - Found. The middleware supports the following Apache mod_rewrite server variables: To use the same rule set that applies to the IIS URL Rewrite Module, use AddIISUrlRewrite. Make sure that the rules file is deployed with the app. Don't direct the middleware to use the app's web.config file when running on Windows Server IIS. With IIS, these rules should be stored outside of the app's web.config file in order to avoid conflicts with the IIS Rewrite module. For more information and examples of IIS URL Rewrite Module rules, see Using Url Rewrite Module 2.0 and URL Rewrite Module Configuration Reference. A StreamReader is used to read the rules from the rules file: public void Configure(IApplicationBuilder app) { using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); } The sample app rewrites requests from to . The response is sent to the client with a 200 - OK status code. If you have an active IIS Rewrite Module with server-level rules configured that would impact your app in undesirable ways, you can disable the IIS Rewrite Module for an app. For more information, see Disabling IIS modules. The middleware doesn't support the following IIS URL Rewrite Module features: The middleware supports the following IIS URL Rewrite Module server variables: You can also obtain an IFileProvider via a PhysicalFileProvider. This approach may provide greater flexibility for the location of your rewrite rules files. Make sure that your rewrite rules files are deployed to the server at the path you provide. Use Add to implement your own rule logic in a method. exposes the RewriteContext, which makes available the HttpContext for use in your method. The RewriteContext.Result determines how additional pipeline processing is handled. Set the value to one of the RuleResult fields described in the following table. Stop applying rules and send the context to the next middleware. public void Configure(IApplicationBuilder app) { using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); } The sample app demonstrates a method that redirects requests for paths that end with . If a request is made for , the request is redirected to . The status code is set to . When the browser makes a new request for , Static File Middleware serves the file to the client from the wwwroot/xmlfiles folder. For a redirect, explicitly set the status code of the response. Otherwise, a 200 - OK status code is returned, and the redirect doesn't occur on the client. public static void RedirectXmlFileRequests(RewriteContext context) { var request = context.HttpContext.Request; // Because the client is redirecting back to the same app, stop // processing if the request has already been redirected. if (request.Path.StartsWithSegments(new PathString(\"/xmlfiles\"))) { return; } if (request.Path.Value.EndsWith(\".xml\", StringComparison.OrdinalIgnoreCase)) { var response = context.HttpContext.Response; response.StatusCode = (int) HttpStatusCode.MovedPermanently; context.Result = RuleResult.EndResponse; response.Headers[HeaderNames.Location] = \"/xmlfiles\" + request.Path + request.QueryString; } } This approach can also rewrite requests. The sample app demonstrates rewriting the path for any text file request to serve the file.txt text file from the wwwroot folder. Static File Middleware serves the file based on the updated request path: public void Configure(IApplicationBuilder app) { using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); } Use Add to use rule logic in a class that implements the IRule interface. provides greater flexibility over using the method-based rule approach. Your implementation class may include a constructor that allows you can pass in parameters for the ApplyRule method. public void Configure(IApplicationBuilder app) { using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); } The values of the parameters in the sample app for the and the are checked to meet several conditions. The must contain a value, and the value must be , , or .gif. If the isn't valid, an ArgumentException is thrown. If a request is made for , the request is redirected to . If a request is made for , the request is redirected to . The status code is set to , and the is set to stop processing rules and send the response. public class RedirectImageRequests : IRule { private readonly string _extension; private readonly PathString _newPath; public RedirectImageRequests(string extension, string newPath) { if (string.IsNullOrEmpty(extension)) { throw new ArgumentException(nameof(extension)); } if (!Regex.IsMatch(extension, @\"^\\.(png|jpg|gif)$\")) { throw new ArgumentException(\"Invalid extension\", nameof(extension)); } if (!Regex.IsMatch(newPath, @\"(/[A-Za-z0-9]+)+?\")) { throw new ArgumentException(\"Invalid path\", nameof(newPath)); } _extension = extension; _newPath = new PathString(newPath); } public void ApplyRule(RewriteContext context) { var request = context.HttpContext.Request; // Because we're redirecting back to the same app, stop // processing if the request has already been redirected if (request.Path.StartsWithSegments(new PathString(_newPath))) { return; } if (request.Path.Value.EndsWith(_extension, StringComparison.OrdinalIgnoreCase)) { var response = context.HttpContext.Response; response.StatusCode = (int) HttpStatusCode.MovedPermanently; context.Result = RuleResult.EndResponse; response.Headers[HeaderNames.Location] = _newPath + request.Path + request.QueryString; } } }\n\nThis document introduces URL rewriting with instructions on how to use URL Rewriting Middleware in ASP.NET Core apps. URL rewriting is the act of modifying request URLs based on one or more predefined rules. URL rewriting creates an abstraction between resource locations and their addresses so that the locations and addresses aren't tightly linked. URL rewriting is valuable in several scenarios to:\n• Move or replace server resources temporarily or permanently and maintain stable locators for those resources.\n• Split request processing across different apps or across areas of one app.\n• Permit the use of friendly public URLs to help visitors predict the content returned by requesting a resource.\n• Prevent hotlinking, where an external site uses a hosted static asset on another site by linking the asset into its own content. URL rewriting can reduce the performance of an app. Where feasible, limit the number and complexity of rules. View or download sample code (how to download) The difference in wording between URL redirect and URL rewrite is subtle but has important implications for providing resources to clients. ASP.NET Core's URL Rewriting Middleware is capable of meeting the need for both. A URL redirect involves a client-side operation, where the client is instructed to access a resource at a different address than the client originally requested. This requires a round trip to the server. The redirect URL returned to the client appears in the browser's address bar when the client makes a new request for the resource. If is redirected to , the server responds that the client should obtain the resource at with a status code indicating that the redirect is either temporary or permanent. When redirecting requests to a different URL, indicate whether the redirect is permanent or temporary by specifying the status code with the response:\n• None The status code is used where the resource has a new, permanent URL and you wish to instruct the client that all future requests for the resource should use the new URL. The client may cache and reuse the response when a 301 status code is received.\n• None The 302 - Found status code is used where the redirection is temporary or generally subject to change. The 302 status code indicates to the client not to store the URL and use it in the future. For more information on status codes, see RFC 9110: Status Code Definitions. A URL rewrite is a server-side operation that provides a resource from a different resource address than the client requested. Rewriting a URL doesn't require a round trip to the server. The rewritten URL isn't returned to the client and doesn't appear in the browser's address bar. If is rewritten to , the server internally fetches and returns the resource at . Although the client might be able to retrieve the resource at the rewritten URL, the client isn't informed that the resource exists at the rewritten URL when it makes its request and receives the response. You can explore the features of the URL Rewriting Middleware with the sample app. The app applies redirect and rewrite rules and shows the redirected or rewritten URL for several scenarios. When to use URL Rewriting Middleware Use URL Rewriting Middleware when you're unable to use the following approaches: Also, use the middleware when the app is hosted on HTTP.sys server (formerly called WebListener). The main reasons to use the server-based URL rewriting technologies in IIS, Apache, and Nginx are:\n• None The middleware doesn't support the full features of these modules. Some of the features of the server modules don't work with ASP.NET Core projects, such as the and constraints of the IIS Rewrite module. In these scenarios, use the middleware instead.\n• None The performance of the middleware probably doesn't match that of the modules. Benchmarking is the only way to know for sure which approach degrades performance the most or if degraded performance is negligible. To include the middleware in your project, add a package reference to the Microsoft.AspNetCore.App metapackage in the project file, which contains the Microsoft.AspNetCore.Rewrite package. When not using the metapackage, add a project reference to the package. Establish URL rewrite and redirect rules by creating an instance of the RewriteOptions class with extension methods for each of your rewrite rules. Chain multiple rules in the order that you would like them processed. The are passed into the URL Rewriting Middleware as it's added to the request pipeline with UseRewriter: public void Configure(IApplicationBuilder app) { using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); } Three options permit the app to redirect non- requests to :\n• None AddRedirectToWwwPermanent: Permanently redirect the request to the subdomain if the request is non- . Redirects with a Status308PermanentRedirect status code.\n• None AddRedirectToWww: Redirect the request to the subdomain if the incoming request is non- . Redirects with a Status307TemporaryRedirect status code. An overload permits you to provide the status code for the response. Use a field of the StatusCodes class for a status code assignment. Use AddRedirect to redirect requests. The first parameter contains your regex for matching on the path of the incoming URL. The second parameter is the replacement string. The third parameter, if present, specifies the status code. If you don't specify the status code, the status code defaults to 302 - Found, which indicates that the resource is temporarily moved or replaced. public void Configure(IApplicationBuilder app) { using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); } In a browser with developer tools enabled, make a request to the sample app with the path . The regex matches the request path on , and the path is replaced with . The redirect URL is sent back to the client with a 302 - Found status code. The browser makes a new request at the redirect URL, which appears in the browser's address bar. Since no rules in the sample app match on the redirect URL:\n• The second request receives a 200 - OK response from the app.\n• The body of the response shows the redirect URL. A round trip is made to the server when a URL is redirected. Be cautious when establishing redirect rules. Redirect rules are evaluated on every request to the app, including after a redirect. It's easy to accidentally create a loop of infinite redirects. The part of the expression contained within parentheses is called a capture group. The dot ( ) of the expression means match any character. The asterisk ( ) indicates match the preceding character zero or more times. Therefore, the last two path segments of the URL, , are captured by capture group . Any value you provide in the request URL after is captured by this single capture group. In the replacement string, captured groups are injected into the string with the dollar sign ( ) followed by the sequence number of the capture. The first capture group value is obtained with , the second with , and they continue in sequence for the capture groups in your regex. There's only one captured group in the redirect rule regex in the sample app, so there's only one injected group in the replacement string, which is . When the rule is applied, the URL becomes . Use AddRedirectToHttps to redirect HTTP requests to the same host and path using the HTTPS protocol. If the status code isn't supplied, the middleware defaults to 302 - Found. If the port isn't supplied:\n• The scheme changes to (HTTPS protocol), and the client accesses the resource on port 443. The following example shows how to set the status code to and change the port to 5001. Use AddRedirectToHttpsPermanent to redirect insecure requests to the same host and path with secure HTTPS protocol on port 443. The middleware sets the status code to . When redirecting to a secure endpoint without the requirement for additional redirect rules, we recommend using HTTPS Redirection Middleware. For more information, see the Enforce HTTPS topic. The sample app is capable of demonstrating how to use or . Add the extension method to the . Make an insecure request to the app at any URL. Dismiss the browser security warning that the self-signed certificate is untrusted or create an exception to trust the certificate. Use AddRewrite to create a rule for rewriting URLs. The first parameter contains the regex for matching on the incoming URL path. The second parameter is the replacement string. The third parameter, , indicates to the middleware whether or not to skip additional rewrite rules if the current rule is applied. public void Configure(IApplicationBuilder app) { using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); } The carat ( ) at the beginning of the expression means that matching starts at the beginning of the URL path. In the earlier example with the redirect rule, , there's no carat ( ) at the start of the regex. Therefore, any characters may precede in the path for a successful match. The rewrite rule, , only matches paths if they start with . In the following table, note the difference in matching. Following the portion of the expression, there are two capture groups, . The signifies match a digit (number). The plus sign ( ) means match one or more of the preceding character. Therefore, the URL must contain a number followed by a forward-slash followed by another number. These capture groups are injected into the rewritten URL as and . The rewrite rule replacement string places the captured groups into the query string. The requested path of is rewritten to obtain the resource at . If a query string is present on the original request, it's preserved when the URL is rewritten. There's no round trip to the server to obtain the resource. If the resource exists, it's fetched and returned to the client with a 200 - OK status code. Because the client isn't redirected, the URL in the browser's address bar doesn't change. Clients can't detect that a URL rewrite operation occurred on the server. Use whenever possible because matching rules is computationally expensive and increases app response time. For the fastest app response:\n• Order rewrite rules from the most frequently matched rule to the least frequently matched rule.\n• Skip the processing of the remaining rules when a match occurs and no additional rule processing is required. Apply Apache mod_rewrite rules with AddApacheModRewrite. Make sure that the rules file is deployed with the app. For more information and examples of mod_rewrite rules, see Apache mod_rewrite. A StreamReader is used to read the rules from the ApacheModRewrite.txt rules file: public void Configure(IApplicationBuilder app) { using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); } The sample app redirects requests from to . The response status code is 302 - Found. The middleware supports the following Apache mod_rewrite server variables: To use the same rule set that applies to the IIS URL Rewrite Module, use AddIISUrlRewrite. Make sure that the rules file is deployed with the app. Don't direct the middleware to use the app's web.config file when running on Windows Server IIS. With IIS, these rules should be stored outside of the app's web.config file in order to avoid conflicts with the IIS Rewrite module. For more information and examples of IIS URL Rewrite Module rules, see Using Url Rewrite Module 2.0 and URL Rewrite Module Configuration Reference. A StreamReader is used to read the rules from the rules file: public void Configure(IApplicationBuilder app) { using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); } The sample app rewrites requests from to . The response is sent to the client with a 200 - OK status code. If you have an active IIS Rewrite Module with server-level rules configured that would impact your app in undesirable ways, you can disable the IIS Rewrite Module for an app. For more information, see Disabling IIS modules. The middleware released with ASP.NET Core 2.x doesn't support the following IIS URL Rewrite Module features: The middleware supports the following IIS URL Rewrite Module server variables: You can also obtain an IFileProvider via a PhysicalFileProvider. This approach may provide greater flexibility for the location of your rewrite rules files. Make sure that your rewrite rules files are deployed to the server at the path you provide. Use Add to implement your own rule logic in a method. exposes the RewriteContext, which makes available the HttpContext for use in your method. The RewriteContext.Result determines how additional pipeline processing is handled. Set the value to one of the RuleResult fields described in the following table. Stop applying rules and send the context to the next middleware. public void Configure(IApplicationBuilder app) { using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); } The sample app demonstrates a method that redirects requests for paths that end with . If a request is made for , the request is redirected to . The status code is set to . When the browser makes a new request for , Static File Middleware serves the file to the client from the wwwroot/xmlfiles folder. For a redirect, explicitly set the status code of the response. Otherwise, a 200 - OK status code is returned, and the redirect doesn't occur on the client. public static void RedirectXmlFileRequests(RewriteContext context) { var request = context.HttpContext.Request; // Because the client is redirecting back to the same app, stop // processing if the request has already been redirected. if (request.Path.StartsWithSegments(new PathString(\"/xmlfiles\"))) { return; } if (request.Path.Value.EndsWith(\".xml\", StringComparison.OrdinalIgnoreCase)) { var response = context.HttpContext.Response; response.StatusCode = (int) HttpStatusCode.MovedPermanently; context.Result = RuleResult.EndResponse; response.Headers[HeaderNames.Location] = \"/xmlfiles\" + request.Path + request.QueryString; } } This approach can also rewrite requests. The sample app demonstrates rewriting the path for any text file request to serve the file.txt text file from the wwwroot folder. Static File Middleware serves the file based on the updated request path: public void Configure(IApplicationBuilder app) { using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); } Use Add to use rule logic in a class that implements the IRule interface. provides greater flexibility over using the method-based rule approach. Your implementation class may include a constructor that allows you can pass in parameters for the ApplyRule method. public void Configure(IApplicationBuilder app) { using (StreamReader apacheModRewriteStreamReader = File.OpenText(\"ApacheModRewrite.txt\")) using (StreamReader iisUrlRewriteStreamReader = File.OpenText(\"IISUrlRewrite.xml\")) { var options = new RewriteOptions() .AddRedirect(\"redirect-rule/(.*)\", \"redirected/$1\") .AddRewrite(@\"^rewrite-rule/(\\d+)/(\\d+)\", \"rewritten?var1=$1&var2=$2\", skipRemainingRules: true) .AddApacheModRewrite(apacheModRewriteStreamReader) .AddIISUrlRewrite(iisUrlRewriteStreamReader) .Add(MethodRules.RedirectXmlFileRequests) .Add(MethodRules.RewriteTextFileRequests) .Add(new RedirectImageRequests(\".png\", \"/png-images\")) .Add(new RedirectImageRequests(\".jpg\", \"/jpg-images\")); app.UseRewriter(options); } app.UseStaticFiles(); app.Run(context => context.Response.WriteAsync( $\"Rewritten or Redirected Url: \" + $\"{context.Request.Path + context.Request.QueryString}\")); } The values of the parameters in the sample app for the and the are checked to meet several conditions. The must contain a value, and the value must be , , or .gif. If the isn't valid, an ArgumentException is thrown. If a request is made for , the request is redirected to . If a request is made for , the request is redirected to . The status code is set to , and the is set to stop processing rules and send the response. public class RedirectImageRequests : IRule { private readonly string _extension; private readonly PathString _newPath; public RedirectImageRequests(string extension, string newPath) { if (string.IsNullOrEmpty(extension)) { throw new ArgumentException(nameof(extension)); } if (!Regex.IsMatch(extension, @\"^\\.(png|jpg|gif)$\")) { throw new ArgumentException(\"Invalid extension\", nameof(extension)); } if (!Regex.IsMatch(newPath, @\"(/[A-Za-z0-9]+)+?\")) { throw new ArgumentException(\"Invalid path\", nameof(newPath)); } _extension = extension; _newPath = new PathString(newPath); } public void ApplyRule(RewriteContext context) { var request = context.HttpContext.Request; // Because we're redirecting back to the same app, stop // processing if the request has already been redirected if (request.Path.StartsWithSegments(new PathString(_newPath))) { return; } if (request.Path.Value.EndsWith(_extension, StringComparison.OrdinalIgnoreCase)) { var response = context.HttpContext.Response; response.StatusCode = (int) HttpStatusCode.MovedPermanently; context.Result = RuleResult.EndResponse; response.Headers[HeaderNames.Location] = _newPath + request.Path + request.QueryString; } } }\n• View or download sample code (how to download)\n• To slash or not to slash"
    },
    {
        "link": "https://binaryintellect.net/articles/2cde4c7c-b43d-4c67-acc2-614ae9b0fcf5.aspx",
        "document": ""
    }
]