[
    {
        "link": "https://retrogamestart.com/answers/learn-commodore-64-basic-programming-type-text-based-games",
        "document": "When I bought my C64 Mini, I was very interested to discover that it didn’t just have pre-loaded games, but also included C64 BASIC. BASIC is the original programming language designed for the average person, and it’s still a great way to play some fun games while you learn about coding logic.\n\nWant to learn how to actually program your C64 Mini or Commodore 64, and type in some games? BASIC is easy to learn, and was created to make it simple for regular people to learn programming. I will teach you classic BASIC programming, with a selection of text-based games you can type in.\n\nIn the late 70s, and early 80s, BASIC was the go-to answer for programming on any number of popular home computers that started coming out. In fact, most of them just went straight to BASIC as soon as you turned them on. It was so unavoidable, that at some point, everyone dabbled and did a little something like:\n\nDon’t have BASIC handy? Use this online C64 emulator. Hit ESC to stop running the program.\n\nAlready know BASIC? Jump straight to the resources.\n\nIn the Beginning Was Text (-Based Games)\n\nBefore we had the firepower to do game graphics, we had text-only interfaces. Naturally, the geeks using these machines weren’t satisfied to just do serious computation work. They wanted to have some fun, too. This meant creating games that worked within that text-based paradigm. They used words and numbers to describe things, ask questions, and respond back with results to decisions made by players. It was what people had, and they made some clever and fun games. For those raised on games that represent everything with onscreen graphics, this throwback to text-based games can be a surprising new way to look at things.\n\nThe 1977 Trinity - comprised of the TRS-80 Model I, Apple II, Commodore PET\n\nThis early text-based gaming created a culture where people wrote and freely shared their games. Since one of the promises of the early home computers (from the Commodore PET to the C64, to the Ataris, Apple II, TRS-80s, and more) was that you could learn, an explosion of text-based BASIC games was the result. BASIC is easy, games are fun, and you can get some free entertainment combined with the joy of learning something cool (and impressing friends!).\n\nIt’s also important to realize that text-based games strip games down to their essence - concept and gameplay. They let you really focus on what the point of the game is, and how it works. And because there is no complicated apparatus for the things that graphical games require, the workings are much simpler to tinker with. Think you can make a game better? Get inspired by something and want to hash out your own take on it? Programming text-based BASIC games means there’s very little in your way if you want to dive in. Just have at it!\n\nWorth noting here: With the increasing technical complexity that characterizes today’s world, many people are returning to simpler, oldschool ways of doing things. Playing a simple board game with friends helps you to slow down, and enjoy something uncomplicated. Playing vinyl records has a ritualistic quality to it that is imposed by its inherently less-efficient way of playing music. Typing in, playing, and modifying BASIC games has a similar quality. Find the beauty of simplicity as you dig into this oldschool pursuit (and be the hipster all your friends envy).\n\nPictured is the Commodore PET I have in my home office. This thing is all retro charm, and sports a text-only interface. On the right is the source for a sweet little BASIC program you can type into your C64 Mini to produce a very cool generated pattern.\n\nThe Benefits of Learning the Hard Way\n\nIn the early days, there was no downloading, or internet to download from. If you were lucky, you had a cassette drive for data storage, or if you had some money, you might have had a floppy disk drive. The most popular way to share these games though (and yes, they were shared, and open source, since that was the way we rolled) was in print.\n\nYeah. Magazines and books regularly published pages upon pages of BASIC code printed out. Want to play the game? You have to type that baby in, bug check (no one is a perfect typist), and then you can play. It took some focus, and a little time, but at the end, you found BASIC was rubbing off on you. You started to see how the game creators were doing things, and you started modifying the games… then making your own from scratch. Making games? Yep. And because it’s just text, it’s not complicated to do.\n\nKeep in mind, that while I will teach you how to download BASIC programs and get them onto your C64 Mini, you learn nothing from just downloading. As tedious as it might feel, the act of typing the stuff in by hand is where the learning happens (you absorb it better by doing, not just looking). It’s also where that quiet focus comes in. Slowness in itself can be a great thing in a hurried world.\n\nThe Basics of Starting in Commodore BASIC\n\nLet’s jump in now. Most of what we’ll talk about here should work for anything you have that runs BASIC, but there were sometimes variations in how to do things between say Commodore’s BASIC, and Atari’s, or IBM’s. All of this code should function with just a few (or maybe no) tweaks on something other than a Commodore, but for the sake of focusing, I am going to concentrate specifically on the Commodore 64, and the C64 Mini.\n• To get started on the Commodore 64, just turn it on. There. Now you’re in BASIC, and can start typing in a game. Please wait a moment though, while the rest of us catch up.\n• To get started on the C64 Mini, turn it on, then scroll through the carousel of games until you find C64 BASIC. Select that like you would any other game, and start it. Now plug a USB keyboard into the C64 Mini, and you’re ready to go.\n\nBefore we start typing in games, I want to cover a few things that will help you out.\n\nBASIC uses line numbers, as seen above in the example with lines 10 and 20. The instructions are executed line-by-line in numbered order. You can type them out in any order you like though. (No one types in game listings out of sequence, but it means you can go back and add or change lines after the fact.) You type in a line from a listing, like:\n\nAnd then hit ENTER at the end. That enters the line, and BASIC now remembers it. Type LIST, and watch BASIC kick out what you typed. This lets you review what you have so far. You can also tell it to list only a section of your code when your game grows longer. Just type LIST 100 - 200, and it will list the code from line 100 through 200.\n\nBy the way - it’s just a convention to type BASIC code out in all caps. Early computers had no lowercase, and BASIC on new computers is not case sensitive. Just type. C64s will output PETSCII characters on the screen if you hit SHIFT or CAPS LOCK when typing. If you see lots of little graphical shapes that are not letters or numbers, it’s because you’ve tried inputting capital letters.\n\nIf you need to change a line, you can just type it over again, and it will overwrite the old one. You can also LIST a line (LIST 120 to see line 120), and use arrow keys to go back up to it and make changes. Be sure to hit ENTER at the end of the line.\n\nHave you totally blown it and just want to start over? Type NEW.\n\nIt’s not necessary for each line to go by tens like 10, 20, 30, etc. It’s just convention for cleaner reading, and so you can go back and insert extra lines between things, if needed, like: 10, 15, 20, 25, 27, 30.\n\nA line with REM is a remark - it has no instructions to the computer, just notes to people looking at the program code. PRINT tells BASIC to output something to the screen. INPUT tells BASIC to wait for a user to type something in.\n\nA variable is something that can hold a value, like a bit of text, or a number. This is assigned like POWER = 5. Now if you have a line with PRINT POWER + POWER, you get 10. If you have NAME$ = \"DAVE\" and then a line with PRINT NAME$ + NAME$, you get DAVEDAVE written out on the screen.\n\nIt’s worth taking a moment to briefly explain a programming concept that is a little weird to the non-programmer. A string can be a single letter/number/punctuation/etc or many, and is treated by the computer as a sequence of characters. It can be a single character, or many. Variables that hold strings are marked with a $. Hence the NAME$ variable above. And the strings themselves that you assign to a string variable must be marked with double quotes (\"). Understand that this is NOT the same as the typographic curly quotes you get in a word processor (”).\n\nSo then any of the following are allowed:\n\nSooooo... and this is the bit that makes non-programmers think we’re crazy, but it makes perfect sense if you think about it... if NUMBER$ = \"5\" and you do PRINT NUMBER$ + NUMBER$, you get 55. While if NUMBER (no $) is set to 5 (not the string \"5\"), then NUMBER + NUMBER gives you 10. The first example is treated as an arbitrary set of characters, the second example is numbers that can have mathematical operations performed. Understand this, and save yourself frustration down the road.\n\nA FOR loop tells BASIC to run through a set of instructions multiple times. GOTO tells it to redirect and start running code on another line number.\n\nWith that, the following should be at least vaguely understandable.\n\nFor a more in-depth understanding and detailed language reference:\n\nTime to Program That Commodore and Type In Your First Text-Based Game\n\nMake sure your machine is fired up and ready to go. If you don’t have one handy at the moment, don’t let that stop you. Launch this snazzy little Commodore 64 BASIC emulator, and get coding on your first game.\n\nPRO TIP: This whole typing thing can be streamlined if you use two people. Have one read off the lines of code, and the other one type. It can make things smoother, and improve accuracy.\n\n10 REM - THIS NUMBER GUESSING GAME IS BASED ON GUESS AND HI-LO\n\n70 PRINT \"YOU MUST ZERO IN ON IT IN 7 GUESSES.\":PRINT\n\n80 PRINT \"I TELL YOU TO GUESS HIGHER, OR LOWER.\":PRINT\n\n220 PRINT:PRINT \"YOU'VE USED ALL OF YOUR GUESSES.\"\n\n250 PRINT \"YOU GOT IT IN \";COUNT;\n\nWhen you’ve got it all in, type RUN, and play the game. To stop the game, hit ESC, and it will quit (saying “BREAK IN 10” or whatever line number) and then say READY. You’re back in BASIC, and can start coding again. You’ll likely need to do this as you run into unexpected behaviors dues to typos (A software bug! Squash it!). It’s also handy as you decide you want to make modifications to try something new.\n\n10 Great Text-Based BASIC Games to Get Started With\n\nRemember that the real value here is sitting down and typing things in. Consider this: woodcarving can be an enjoyable hobby. But buying a carving is not at all the same thing. We’ll get to the process of downloading BASIC games in a little bit. That can be handy for trying things out quickly. But take your time now, and have fun learning.\n\nNote that these are all selected from David Ahl’s immensely popular BASIC Computer Games books, which were written expecting that the computer would have an 80 column (80 characters wide) screen. The Commodore 64 has a 40 column screen. This means that if used as-is, some will format strangely, with the long lines wrapping around. This is usually easy to fix, and good practice for making modifications. To fix long lines of text, break the PRINT statements into multiple lines like so:\n\n240 PRINT \"THE BOARD IS A BIG COOKIE - R ROWS HIGH AND C COLUMNS\"\n\n250 PRINT \"WIDE. YOU INPUT R AND C AT THE START.\"\n\n250 PRINT \"YOU INPUT R AND C AT THE START.\"\n\nThe first few are from his first book BASIC Computer Games, published in 1978, which was the first computer book to sell over a million copies. Lyle Kopnicky over at the Vintage BASIC site (with express permission from Mr. Ahl), has converted these over to text files (not just scans of the book pages), and tightened them up a bit to run in his own version of BASIC. I have tried out several of these, and they’ve all run cleanly, except for the aforementioned 80 column/40 column screen formatting,\n\nAnd before we get going, I must mention that half the charm of Ahl’s books is the very cool robot illustrations done by George Beker. I have included two here.\n\nThe games will start off with some simpler ones, and then mix in more sophisticated ones. Super Star Trek and Eliza at the end are both rather involved.\n\nThe following games are from David Ahl’s follow-up book More BASIC Computer Games, published in 1979. Note that these are just the scanned book pages, and do not have accompanying text files. Maybe you can share after typing them in?\n\nOne final note about these games. These programs hail from the 1970s, and are sourced from different contributors that sent them in to Mr. Ahl. Styles, structure, and line number as well as other conventions vary. Some are pretty tight, and others have little oddities in how they were created. This is long before the present day, in which programmers are often OCD about their adherence to detailed coding styles. Consider any wackiness you find in your digital archaeology just artifacts of the era.\n\nThese final two are long programs. Type them in for the full experience of going oldschool, or use the instructions below to download them and get them into your C64 Mini.\n• This is a great place to start. Like many of these games, it’s a combination of strategy and logic. This one is based on a mathematically-inspired game published by Martin Gardner in Scientific American. In a nutshell, you choose a grid size up to 9 X 9, and the grid is filled in, with the top left space being “poison.” The goal is for two players to alternate back and forth, each chomping part of the grid, trying to force the other player to take the last chomp that includes the poison space. Battle back and forth to work out your strategy. See the original book page, with explanation and BASIC code listing (use NEXT to see 2nd page) [ See how to get it on your C64 Mini ]\n• You’re in a lunar lander that is descending toward the moon’s surface. You have a certain amount of fuel in your engines, and you’re falling at a certain rate. The game starts with you at a certain height, and you must try to use fuel in a way that lets you land safely, by reaching near zero in speed as you arrive at the surface. The built-in calculations make it very realistic and challenging. Do you go all out? Wait till the last minute? Test your strategy. Then try adjusting variables, like capsule weight and fuel amount. See the original book page, with explanation and BASIC code listing [ See how to get it on your C64 Mini ]\n• This is the classic resource management game. You are in charge of handling the people, land, and grain for a city in ancient Sumeria. You can buy and sell land for grain at varying prices, while also planting grain, and making sure you feed your growing population. It’s a tricky juggling act to keep it all in balance. Think of this game like Sim City’s grandpappy. See the original book page, with explanation and BASIC code listing (use NEXT to see 2nd page) [ See how to get it on your C64 Mini ]\n• Another absolute classic. This isn’t a game so much as a fascinating simulation where you seed organisms into a simple environment, and then watch the population grow, shrink, and change form over time. It all runs according to a simple rule set published in Scientific American by Martin Gardner (again!). Once you understand the rules of how the organisms change, try different starting configurations to see how your results change. It’s kind of addictive. See the original book page, with explanation and BASIC code listing (use NEXT to see 2nd page) [ See how to get it on your C64 Mini ]\n• Everyone knows this game. Guess letters to solve the word before you are hanged. But because it’s so familiar, this is a great one to examine and take apart. Start with changing the data statements at the end to put in your own words. If you’re feeling clever, try adding an option to have another player enter a word, instead of using the built in ones. Can you do it? See the original book page, with explanation and BASIC code listing [ See how to get it on your C64 Mini ]\n• Another strategy game, this one is similar in concept to the old Minesweeper in Microsoft Windows (but this came first). Target squares in a 10 X 10 grid in pursuit of 4 mugwumps. Get feedback on how close you are, then refine to nail them. Kind of like Battleship, with feedback. See the original book page, with explanation and BASIC code listing (use NEXT to see 2nd page) [ See how to get it on your C64 Mini ]\n\nThe following games are from David Ahl’s follow-up book More BASIC Computer Games, published in 1979. Note that these are just the scanned book pages, and do not have accompanying text files. Maybe you can share after typing them in?\n• Up to 3 players can compete by using speed, muzzle velocity, and angle top lob artillery shells at one another. Who will be the last one standing? See the original book page, with explanation and BASIC code listing (use NEXT to see 2nd page) [ See how to get it on your C64 Mini ]\n• This simulation has you commanding a military space ship, and seeking out the enemy ship to destroy it. Choose your ship, select weaponry from the armory, then find the enemy ship. Get closer to fire more accurately, but risk getting shot yourself. Make tactical decisions as your ship takes on more damage. Who will go down in defeat? See the original book page, with explanation and BASIC code listing (use NEXT to see 2nd page) [ See how to get it on your C64 Mini ]\n\nThese final two are long programs. Type them in for the full experience of going oldschool, or use the instructions below to download them and get them into your C64 Mini.\n• As captain of the Starship Enterprise, you fly around through the quadrants of the galaxy and do battle with Klingon warships. This game is much more ambitious and sophisticated in depth and scope than most of the others. The code listing is a lot longer, and BASIC Computer Games even has two separate listings for it - one for the game, and one for the instructions. This game was one of the first I ever played, on a computer the size of a desk, in the late 70s. It’s been around for a long time, and was very popular back in the day (and consider that it was pretty contemporary back in the day, what with Kirk, Spock, and Bones being pretty new back then). See the original book page, with explanation and BASIC code listing (use NEXT to see subsequent pages) [ See how to get it on your C64 Mini ]\n• This is an absolute classic. It was EVERYWHERE back in the day. It’s not really a game, but a simplistic, pseudo-AI. It basically babbles responses back to whatever you type in, rephrasing your statements back as new questions. The whole setup is that it claims to be a psychiatrist, so it’s helping you work through your “problems.” Responses are often funny, due to their awkward weirdness. Can you hack the Eliza code to tailor her responses? See the original book page, with explanation and BASIC code listing (use NEXT to see subsequent pages) [ See how to get it on your C64 Mini ]\n\nSee all of David Ahl’s BASIC Computer Games\n\nSee all of the BASIC Computer Games text files\n\nSee all of David Ahl’s More BASIC Computer Games\n\nHow to Save and Load Your Typed-In BASIC Games on the C64 Mini\n\nIf you’re going to type in some games, you’re going to need a way to save your work. Who wants to turn the machine off and lose what you did?\n\nOn the C64 Mini, you have two handy ways to save your BASIC programs. We’ll skip the first, since it’s limited to just four save slots (like the built in save game slots). The better way to save is to have a USB thumb drive formatted to FAT 32 (see my other post on C64 Mini Homebrew Games for how to format in FAT 32). Plug in the USB drive, and once you have your program the way you want it, type:\n\nThat 8 at the end is the Commodore way of telling it which device it should save to - in this case, the main (virtual) floppy drive. It should respond with:\n\nIf it doesn’t already exist, the C64 Mini will create a disk image (a file that looks like a floppy disk to the C64) and call it THEC64-drive8.d64. That .d64 extension on the end is the C64 disk image file type. Keep in mind - this file is NOT your program you just saved. It’s a virtual disk that has your program in it. You can (and will, of course) save multiple things to this virtual floppy disk.\n\nIf you ever need to create a disk image just so you can import some stuff you downloaded from the internet (see below), just save a simple 1 line program in order to make the C64 Mini create the disk image that you can open on your computer, and then save your downloaded stuff to.\n\nIt’s important to be able to see what’s in your disk image. If you come back in the future after saving a few things, you may not remember exactly what’s in there, or what everything is called. Type:\n\nAgain, that 8 tells it to look at the main (virtual) floppy disk drive. Telling it to LOAD”$” is the command to get a listing of the drive’s contents. It will say:\n\nNow it has the list of the disk contents, but you have to tell it to show it to you:\n\nExcellent. Now that you know it’s saved for you, let’s practice loading.\n\nLoading Your BASIC Game Back Into the C64 Mini\n\nOnce you have confirmed your work is saved, type:\n\nYou should see that the NEW command has wiped your program from memory. You are now clear to load it back in with:\n\nThe Mini should respond with:\n\nAnd you should see that your program is back.\n\nOther Handy Tricks for Saving Your Work\n\nDo you want to save some revisions you made over an existing file? Add @0: to the front of the file name to tell the Mini to replace the existing.\n\nIf you want to verify a saved program, you can type:\n\nAnd it will respond with:\n\nGet Downloaded Text-Based BASIC Games Onto Your C64 Mini Using VICE\n\nThis will not be a tutorial on using VICE (the desktop Commodore 64 emulator), but just the steps necessary to get downloaded games into the virtual disk image you created on a USB thumb drive. Haven’t done that yet? Jump back up to to that part of the post and create your disk image by saving something to your USB thumb drive. If you already have a thumb drive with a disk image on it, then proceed to the next step.\n\nYou’ll need to download and unzip the appropriate version for your operating system:\n\nDownload VICE for OSX - I used the one called vice-macosx-cocoa-x86_64-10.12-3.1.dmg, since I am on OSX 10.12, and the SDL version would not even open for me. Your experience may be different. When you try this, there may be a newer version.\n\nDownload VICE for Windows - I used the one called WinVICE-3.1-x64.7z since my Windows machine is 64-bit. I got the native one, and not the SDL version, since the SDL one for OSX didn’t work. Note that the file ends in .7z, which tells you it’s a 7-Zip file, not a regular zip file. When you double click it to open it, you may be told you don’t have an application to open it. In the little notice that comes up, double click the option to find an application in the Windows store. From there, I just picked a free app that opens 7-Zip files. Run your new 7-Zip application, and open the VICE file you just downloaded.\n\nRun the VICE Commodore 64 emulator by double clicking on the x64 icon (x64.app on OSX). Now mount the virtual disk from your USB thumb drive like so:\n\nFile > Attach Disk Image > #8… and locate the THEC64-drive8.d64 file on your thumb drive. If you recall from before, we load and save with a ,8 on the end to tell it the device to work with - our main (virtual) floppy drive. This is the same reason we just opened this THEC64-drive8.d64 virtual disk image using Unit #8. We’re putting the virtual floppy into the virtual main floppy drive.\n\nOnce you’ve done that, use the commands you learned above to get the listing of the disk’s contents:\n\nYou’ll see the contents of your virtual disk - whatever you saved in order to create the disk image (see above again for more details).\n\nNow grab the source of what you want to import. Let’s grab the CHOMP game we talked about above. You’ll see that link takes you to a plain text file called chomp.bas. This is not an HTML page, but plain text, which is what we want. Click on the code, and hit CMD+A (OSX) or CTRL+A (Windows) to select everything. Now hit CMD+C (OSX) or CTRL+C (Windows) to copy it.\n\nNow here’s the tricky bit. We’re going to paste this into the VICE window, only there’s one problem. Try it, and you’ll see that you get a gobbledy-gook of special characters, not the program. What’s the problem? Even though VICE shows everything in ALL CAPS, it does that just because that’s what C64s do. If you put in real caps by pasting or holding shift and typing, you get these C64 special characters. What it wants is lower case. Ugh. Does that mean you have to retype this? Nope - just use ConvertCase.net or similar tool. Paste your ALL CAPS code into the window on ConvertCase (CMD+V or CTRL+V), and then click the “lower case” tab. Voila! Now click the “copy to clipboard” tab, and go back to the VICE window.\n\nClick into the VICE window, and paste in your copied text. Be sure to hit ENTER at the end to enter the last line.\n\nNow use what we learned before to save this to our virtual disk:\n\nBAM! You’ve got it. Now close VICE, and properly eject your USB drive. Take it to your C64 Mini, plug it in, and then in BASIC, type:\n\nLIST it, and see that you’ve got it! Now run that baby.\n\nPro tip: If you find you’re enjoying modifying or writing your own BASIC programs, you may find it more efficient to work on your computer in a text editor, and then save out your work and move it to the C64 Mini. If you’re getting really serious, and want to test on your computer, so you only take it to the C64 Mini when it’s all finished, then load up Chipmunk BASIC using the instructions below. Need a good text editor (you can’t use a word processor, it has to do plain text)? Try Atom.\n\nWhile BASIC was nearly unavoidable in 80s personal computing, you’re unlikely to find it on contemporary computers. But that doesn’t mean you’re out of luck. There are new implementations of BASIC that have been created for your present day machine. Chipmunk BASIC is a great option that’s easy to set up and use. First, grab the appropriate download for your machine, and unzip it (double click).\n\nYou can double-click Chipmunk Basic.app like any other application, and it will open a window where you can go ahead and start typing. To exit a running program, use CMD+C.\n\nThe file simply called basic is for use on the command line. Open Terminal, navigate to the folder where it is, and run it by typing ./basic at the command prompt. To exit a running program, use CTRL+C. Handy tip: use the free Go2Shell to open a Terminal at the current folder you have open in Finder.\n\nYou can double-click the chipmunkbasic application like any other application, and it will open a window where you can go ahead and start typing. To exit a running program, use CTRL+C.\n\nThe file simply called basic (or basic.exe if file extensions are turned on) is for use on the command line. Open the command line in Windows 10 by hitting WINDOWS KEY+R to get a run box, and type cmd into the box and hit ENTER. Navigate to the folder where basic.exe is, and run it by typing basic.exe at the command prompt. To exit a running program, use CTRL+C.\n\nIf I’m writing in the Chipmunk BASIC app, I can save my work by typing:\n\nSAVE “AWESOME.BAS” (or it could be in lower, or mixed case, since you’re on a modern computer, but I’ll stick with all caps for consistency)\n\nOn OSX, this saves AWESOME.BAS to the current user’s Documents folder. Now I can open that in my text editor, and edit to my heart’s content, resave (or save a new version), and then reload the changes into Chipmunk BASIC by typing:\n\nSo now you can easily work in a modern text editor with all of its conveniences, and then test locally in Chipmunk BASIC. When you have your work perfected, you can use the process outlined above to import your work into the C64 Mini via VICE.\n\nNote that in Windows, saving your file saves it out to the same folder basic is in, which actually makes more sense.\n\nVintage BASIC is an application from Lyle Kopnicky, the fellow who provided the BASIC source code text files we used above. It works a bit differently. It doesn’t provide an editing interface the way Chipmunk BASIC does, but is designed with the idea that you will be using a modern text editor, and then just using vintage BASIC to run your programs. Download and unzip the proper version for your operating system, and then at the command line, type:\n\nIt’s a different way of working, aimed at modern workflows.\n\nKeep in mind that there can be variations between some of the details in different BASIC version. When in doubt, check documentation on the sites.\n\nBONUS 2: Because You’re Still Reading This\n\nHere are a couple of special somethings for you since you’re still here:\n\nAnother of David Ahl’s books, BASIC Computer Adventures, unpacks how to create various adventure games, with complete source code for typing in. These aren’t what are normally referred to as text adventures, but they are a different and interesting take on an adventure premise within a BASIC game.\n\nAhl’s book Big Computer Games goes in for larger, more complex game programs. If you want to see how they used to code up more sophisticated BASIC games, this is the place to look.\n\nFeeling a desire for some computer history? Check out a PDF of the original BASIC manual from Dartmouth, in 1964 (the birth place and year of BASIC)."
    },
    {
        "link": "https://reddit.com/r/gamedev/comments/i8w73d/starting_programming_and_gamedev_with_commodore_64",
        "document": "I'm 42, a programmer of 20+ years and this is what I would recommend to teens and young adults, interested in programming and/or gamedev.\n\nBASIC is a very small and simple language, it's a great first language to pick up the programming \"basics\".\n\nGet the Vice C64 emulator, and download a few free BASIC books, these books are made for kids, and the C64 still has a dev scene and gamer scene.\n\nProgramming isn't about how pretty the graphics are, but what you can do with what you learn, follow a few books and finish something simple.If you can't follow that and enjoy making something simple, then I would say programming isn't for you.\n\nAfter following a few books, try making something new from scratch and share it around, the C64 community will enjoy it!\n\nWhy start with C64 dev? It's a relatively simple and very popular machine. It has a lot of free documentation and books, mostly targeted at teenagers and young adults.\n\nMore advance books are here: https://archive.org/details/books?and%5B%5D=Commodore+64&sin=\n\nIt's limitation is it's strength, coding, art and sound are very simple and small compared to modern gamedev (ie Unity3D), which you'll be lost in GUI's (menus and screens).\n\nAlso learning maths (linear algebra, trigonometry, simple physics and artificial intelligence) is really more important then learning BASIC.\n\nIf you want the authentic experience (I wouldn't recommend it) you can still buy them online, kinda getting up there in price now, or you can get \"TheC64\" which is a new, full-size Commodore 64 keyboard with joystick and 64 games, that is emulated but has support for programming (saving/loading).\n\nThe jump from BASIC C64 programming to assembly might seem daunting, and it is more complex, but BASIC refers to the hardware a lot and that's part of the learning, assembly can be mixed with BASIC to optimise slower routines.\n\nAnyway, just some thoughts..."
    },
    {
        "link": "https://commodore.ca/manuals/c64_programmers_reference/c64-programmers_reference_guide-02-basic_language_vocabulary.pdf",
        "document": ""
    },
    {
        "link": "https://retrogamecoders.com/commodore64-basic-programming",
        "document": "Commodore 64 basic – How to get started and why you should.\n\nWhat do all these programmers have in common? Now, most of them are dudes, but they’re not all dudes.\n\nWhat they have in common is they all got started with BASIC (Beginners, All-purpose, Symbolic Instruction Code), and BASIC was a programming language that was intended for people to learn programming, which is a fancy way of saying that it’s human readable.\n\nNow, Carol Shaw is the first female game programmer ever. The first recorded, documented female game programmer. She learned basic in high school, on a teletype. She developed a game called polo, which was the first documented video game developed. By a woman develop the Atari basic reference manual along with a guy called Keith Brewster.\n\nHer 3D Tic-Tac-Toe was the first commercial video game by a woman – programming the sound and all the graphics.\n\nOne of my favorite all-time games, River Raid was also developed by her. A best-selling game, won loads of awards.\n\nPartly off the back of that she retired at the age of 35 … and it all started with basic in high school.\n\nNext we’ve got, Steve Wozniak. The famous was of Apple fame. He first started with basic to also with a terminal connected up at the school over their modem\n\nBill Gates also started with basic started at school\n\nHe learned Atari BASIC first from his dad and then his Dad saw that he had potential and hired a private tutor for him.\n\nJohn Carmack of Oculus and ID software fame. He started out with basic, amongst other things. He also taught basic. At age 11 and it was such a foundational experience for him that he’s now teaching his kids, computer programming, using basic on an Apple to see, he says it’s like Kung Fu training, in the primitive wilderness,\n\nHe started just like me Commodore Vic 20, using the. Basic manual that came with it. And his first commercial program, he sold his game blaster for $500. And you can actually play that game right now,\n\nLinus Torvalds of Linux fame, and also the inventor of Git the version control software. He started out age 10, again, Vic 20 writing basic programs and his sister claims his first basic program repeated “Sarah is the best”.\n\nSo, what is programming?\n\nProgramming is teaching your computer how to do new things. All computer programs involve some form of input, whether that’s from the keyboard or from storage, it involves processing that input. It could involve writing back to short term storage, which is your memory, your Ram or long-term storage, which could be.\n\nDisk, it could be tape and then some form of output, which in terms of a video game, the input and output might be joystick and sprites on screen.\n\nSo why Commodore 64 basic one of the advantages that Commodore 64 basic and a lot of the basics of the era have you don’t need. Anything extra other than the computer or an emulator, because it’s instantly on, you don’t have to wait for it to boot up.\n\nYou don’t have to configure anything. You don’t have to install anything as soon as you turn the computer on. You’re actually in basic because it is the operating system. It’s also easy to learn. All of these famous programmers started when they were kids. Unaided. They had the manual that came with the computer.\n\nThat was pretty much it. And you can see immediate results and for learning immediate results and being able to iterate quickly, fix your mistakes. That’s really vital. You don’t want to have to do a lot of things before you can see any results because people lose interest. They get frustrated because they’re not good at it right away, or even they might not understand what they’ve done wrong.\n\nEven though my community is called Retro Game CODERS. It’s really all about programming. Once you’ve learned how to do programming, it doesn’t matter which language you use. You’ve got those foundational principles that you can take anywhere.\n\nWhy NOT Program in BASIC?\n\nA guy called Dijkstra said “it’s practically impossible to teach good programming to students that have prior exposure to basic.”\n\nHe is wrong. Most of us sort of a certain age did start with basic. Commercial programmers who do it for our day jobs. Most of us self-taught. We might’ve started with a Commodore 64 or the BBC, Vic 20 the ZX81. We learned basic and now are professional programmers, it doesn’t matter what age you are.\n\nThe reason he had a thing against basic was because some of the hacky things that used to have to do back in the day, but basic actually does contain. Everything you need to do what is “Structured Programming”.\n• You need routines. That means breaking your program down into smaller pieces.\n• You need sequences, which is do one thing after another.\n• You need to selection, which is if this is the case, do this, other choice do this other thing.\n• And you need iteration, which is doing something continuously until a value is set or a condition is met.\n\nBasic is a high level language. It means that it’s actually easier to understand.\n\nSo when people say they’re programming in machine code, usually what they actually mean is the programming in assembly, which is then converted into machine code. It is pretty much almost English, but it’s still less readable than those on the far right hand side, which were more abstracted from machine code, but more easy for people to grok.\n\nSo basic and things like scratch are at the easiest end to understand the easiest way to code and those on the far left low level languages, are closest to the hardware, but harder for humans to understand, and then many languages fall somewhere in the middle.\n\nLearn programming, the principles of solving a problem with computer programming, going lower level if you need that performance, you don’t have to make things hard for yourself. If it gets the job done.\n\nTo start with Commodore 64 basic we need a Commodore 64. Even if you don’t have a Commodore 64 or anything like it, you can get started straight away by opening your web browser to Retro Game Coders.com/ C64-emulator/\n\nUp will pop the screen on the right and the first commands you need to learn are\n\nList allows you to show the basic program that’s currently in memory.\n\nSo enter list and it’ll show you the currently stored basic program.\n\nLoad allows you to load a program from tape or disk. If you using a tape, then you just have to enter load, but we’re not using a tape we are using a virtual disk. So we need to first look to see what is on this disk. So we use the dollar sign and our device, which is the number of the disk drive, which is eight.\n\nAnd that allows us to list the currently stored programs that are on disk. And we just have one program called “readme” and the disk itself is called “Blank”. Now we can load readme also by specifying drive 8.\n\nWe can see that this is the program that was on disk called “readme” and the reason why this started up as soon as we started the emulator, which I’ll show you again.\n\nAs you can see, it’s been told to load the first program from this into memory where it was stored. And the first program on disk is that readme. So with the comma 1, it will load into memory where it was originally saved without the comma 1 it’ll load into BASIC.\n\nAs well as listing it back to read it as a program, we can also execute it by typing RUN.\n\nJust as we can list individual lines, or we can list a set of lines, just the same we can actually just run from a certain point.\n\nIf we want to start a new program, we can just type NEW. And that means we have nothing in memory and can start over.\n\nWe can save it away again using device eight, which is the first disk drive. And to make sure it’s saved, we have a VERIFY command, again using Device 8.\n\nNow you saw that I used RUN STOP to stop the currently running program. That is one of the special keys. In the emulator. It’s mapped to the escape key on a PC or Mac keyboard, but we’ve also got this virtual keyboard here that allows you to do Run Stop.\n\nAnother special key is the Commodore key. As you can see in the emulator allows you to click it, to mimic holding it down, and then we can do a clear home to clear the screen. Can also changed upper and lower case. The weird thing about the Commodore 64 is that it has two character sets. You have to choose between them upper case with graphics or lowercase.\n\nInput and Output – What’s Your Name?\n\nSo the first line is going to output “what is your name” and you notice that semi-colon, that means we don’t want to start a new line afterwards because the next line is going to be what actually asks the question. And that automatically puts a question mark in there.\n\nOnce it’s got the input, it puts it into the variable (or name string).\n\nThen we can output a kind response, again using semi-colon, to give you a greeting.\n\nSo if we run that and I put in my name is Chris, it will say “well hello, Chris”.\n\nThese special keys can do quite a lot and one of the things that you might want to do is use the text colors and Reverse Text.\n\nSo for example, if I do control and then I choose 2, and then I hit control again, I’m going to get some white text. Hit Reverse, I get reverse text, and then we can turn reverse off again.\n\nNow, if I was going to put this into a program, you’ll notice something weird happens instead of it actually being reverse. It puts that funny letter R and then a different symbol for when it’s turned off. But when it’s output, it is reversed. And that’s because these are special symbols that are interpreted by basic to do the same thing as these special keys.\n\nFor a final example, let’s do some math. What we’ll do is we’ll convert Celsius into Fahrenheit. We want our program to start on a blank screen with the cursor in the top left-hand corner so we can use clear home. And it puts this heart symbol in its place. You’ll notice that when we get to the right-hand side, it will loop around to the left-hand side, but we still need to press return after each line.\n\nAgain, as before we don’t want to put a question mark, but we do need the semi-colon so that the question mark appears straight after.\n\nUnlike before, where we had or Name String, this time it’s a number, so it doesn’t have the dollar. It doesn’t have that symbol after, it’s just\n\nThen we display the result, putting in spaces for readability.\n\nThat will output whatever the variable C contains, which is our Celsius number, and it’ll output the Fahrenheit F at the end.\n\nIf we run it, 20 C is 68 Fahrenheit.\n\nUsing the Commodore BASIC Editor to Fix Mistakes\n\nThe good thing is this editor, this basic editor that comes to the Commodore 64, does have the ability to be able to change and edit, our mistakes.\n\nWhat we do is we cursor up to where we made the mistake, change it, and then make sure we press return.\n\nThen we can list again, and we should have a correct spelling.\n\nSo that’s the end of part one. I did go quite long, so I’ll stop there, but look out for next time where we start building the foundations of knowledge so we can build an actual game PLUS get a free Commodore BASIC Command List Cheat Sheet."
    },
    {
        "link": "https://zimmers.net/cbmpics/cbm/c64/c64prg.txt",
        "document": ""
    },
    {
        "link": "https://retrogamestart.com/answers/learn-commodore-64-basic-programming-type-text-based-games",
        "document": "When I bought my C64 Mini, I was very interested to discover that it didn’t just have pre-loaded games, but also included C64 BASIC. BASIC is the original programming language designed for the average person, and it’s still a great way to play some fun games while you learn about coding logic.\n\nWant to learn how to actually program your C64 Mini or Commodore 64, and type in some games? BASIC is easy to learn, and was created to make it simple for regular people to learn programming. I will teach you classic BASIC programming, with a selection of text-based games you can type in.\n\nIn the late 70s, and early 80s, BASIC was the go-to answer for programming on any number of popular home computers that started coming out. In fact, most of them just went straight to BASIC as soon as you turned them on. It was so unavoidable, that at some point, everyone dabbled and did a little something like:\n\nDon’t have BASIC handy? Use this online C64 emulator. Hit ESC to stop running the program.\n\nAlready know BASIC? Jump straight to the resources.\n\nIn the Beginning Was Text (-Based Games)\n\nBefore we had the firepower to do game graphics, we had text-only interfaces. Naturally, the geeks using these machines weren’t satisfied to just do serious computation work. They wanted to have some fun, too. This meant creating games that worked within that text-based paradigm. They used words and numbers to describe things, ask questions, and respond back with results to decisions made by players. It was what people had, and they made some clever and fun games. For those raised on games that represent everything with onscreen graphics, this throwback to text-based games can be a surprising new way to look at things.\n\nThe 1977 Trinity - comprised of the TRS-80 Model I, Apple II, Commodore PET\n\nThis early text-based gaming created a culture where people wrote and freely shared their games. Since one of the promises of the early home computers (from the Commodore PET to the C64, to the Ataris, Apple II, TRS-80s, and more) was that you could learn, an explosion of text-based BASIC games was the result. BASIC is easy, games are fun, and you can get some free entertainment combined with the joy of learning something cool (and impressing friends!).\n\nIt’s also important to realize that text-based games strip games down to their essence - concept and gameplay. They let you really focus on what the point of the game is, and how it works. And because there is no complicated apparatus for the things that graphical games require, the workings are much simpler to tinker with. Think you can make a game better? Get inspired by something and want to hash out your own take on it? Programming text-based BASIC games means there’s very little in your way if you want to dive in. Just have at it!\n\nWorth noting here: With the increasing technical complexity that characterizes today’s world, many people are returning to simpler, oldschool ways of doing things. Playing a simple board game with friends helps you to slow down, and enjoy something uncomplicated. Playing vinyl records has a ritualistic quality to it that is imposed by its inherently less-efficient way of playing music. Typing in, playing, and modifying BASIC games has a similar quality. Find the beauty of simplicity as you dig into this oldschool pursuit (and be the hipster all your friends envy).\n\nPictured is the Commodore PET I have in my home office. This thing is all retro charm, and sports a text-only interface. On the right is the source for a sweet little BASIC program you can type into your C64 Mini to produce a very cool generated pattern.\n\nThe Benefits of Learning the Hard Way\n\nIn the early days, there was no downloading, or internet to download from. If you were lucky, you had a cassette drive for data storage, or if you had some money, you might have had a floppy disk drive. The most popular way to share these games though (and yes, they were shared, and open source, since that was the way we rolled) was in print.\n\nYeah. Magazines and books regularly published pages upon pages of BASIC code printed out. Want to play the game? You have to type that baby in, bug check (no one is a perfect typist), and then you can play. It took some focus, and a little time, but at the end, you found BASIC was rubbing off on you. You started to see how the game creators were doing things, and you started modifying the games… then making your own from scratch. Making games? Yep. And because it’s just text, it’s not complicated to do.\n\nKeep in mind, that while I will teach you how to download BASIC programs and get them onto your C64 Mini, you learn nothing from just downloading. As tedious as it might feel, the act of typing the stuff in by hand is where the learning happens (you absorb it better by doing, not just looking). It’s also where that quiet focus comes in. Slowness in itself can be a great thing in a hurried world.\n\nThe Basics of Starting in Commodore BASIC\n\nLet’s jump in now. Most of what we’ll talk about here should work for anything you have that runs BASIC, but there were sometimes variations in how to do things between say Commodore’s BASIC, and Atari’s, or IBM’s. All of this code should function with just a few (or maybe no) tweaks on something other than a Commodore, but for the sake of focusing, I am going to concentrate specifically on the Commodore 64, and the C64 Mini.\n• To get started on the Commodore 64, just turn it on. There. Now you’re in BASIC, and can start typing in a game. Please wait a moment though, while the rest of us catch up.\n• To get started on the C64 Mini, turn it on, then scroll through the carousel of games until you find C64 BASIC. Select that like you would any other game, and start it. Now plug a USB keyboard into the C64 Mini, and you’re ready to go.\n\nBefore we start typing in games, I want to cover a few things that will help you out.\n\nBASIC uses line numbers, as seen above in the example with lines 10 and 20. The instructions are executed line-by-line in numbered order. You can type them out in any order you like though. (No one types in game listings out of sequence, but it means you can go back and add or change lines after the fact.) You type in a line from a listing, like:\n\nAnd then hit ENTER at the end. That enters the line, and BASIC now remembers it. Type LIST, and watch BASIC kick out what you typed. This lets you review what you have so far. You can also tell it to list only a section of your code when your game grows longer. Just type LIST 100 - 200, and it will list the code from line 100 through 200.\n\nBy the way - it’s just a convention to type BASIC code out in all caps. Early computers had no lowercase, and BASIC on new computers is not case sensitive. Just type. C64s will output PETSCII characters on the screen if you hit SHIFT or CAPS LOCK when typing. If you see lots of little graphical shapes that are not letters or numbers, it’s because you’ve tried inputting capital letters.\n\nIf you need to change a line, you can just type it over again, and it will overwrite the old one. You can also LIST a line (LIST 120 to see line 120), and use arrow keys to go back up to it and make changes. Be sure to hit ENTER at the end of the line.\n\nHave you totally blown it and just want to start over? Type NEW.\n\nIt’s not necessary for each line to go by tens like 10, 20, 30, etc. It’s just convention for cleaner reading, and so you can go back and insert extra lines between things, if needed, like: 10, 15, 20, 25, 27, 30.\n\nA line with REM is a remark - it has no instructions to the computer, just notes to people looking at the program code. PRINT tells BASIC to output something to the screen. INPUT tells BASIC to wait for a user to type something in.\n\nA variable is something that can hold a value, like a bit of text, or a number. This is assigned like POWER = 5. Now if you have a line with PRINT POWER + POWER, you get 10. If you have NAME$ = \"DAVE\" and then a line with PRINT NAME$ + NAME$, you get DAVEDAVE written out on the screen.\n\nIt’s worth taking a moment to briefly explain a programming concept that is a little weird to the non-programmer. A string can be a single letter/number/punctuation/etc or many, and is treated by the computer as a sequence of characters. It can be a single character, or many. Variables that hold strings are marked with a $. Hence the NAME$ variable above. And the strings themselves that you assign to a string variable must be marked with double quotes (\"). Understand that this is NOT the same as the typographic curly quotes you get in a word processor (”).\n\nSo then any of the following are allowed:\n\nSooooo... and this is the bit that makes non-programmers think we’re crazy, but it makes perfect sense if you think about it... if NUMBER$ = \"5\" and you do PRINT NUMBER$ + NUMBER$, you get 55. While if NUMBER (no $) is set to 5 (not the string \"5\"), then NUMBER + NUMBER gives you 10. The first example is treated as an arbitrary set of characters, the second example is numbers that can have mathematical operations performed. Understand this, and save yourself frustration down the road.\n\nA FOR loop tells BASIC to run through a set of instructions multiple times. GOTO tells it to redirect and start running code on another line number.\n\nWith that, the following should be at least vaguely understandable.\n\nFor a more in-depth understanding and detailed language reference:\n\nTime to Program That Commodore and Type In Your First Text-Based Game\n\nMake sure your machine is fired up and ready to go. If you don’t have one handy at the moment, don’t let that stop you. Launch this snazzy little Commodore 64 BASIC emulator, and get coding on your first game.\n\nPRO TIP: This whole typing thing can be streamlined if you use two people. Have one read off the lines of code, and the other one type. It can make things smoother, and improve accuracy.\n\n10 REM - THIS NUMBER GUESSING GAME IS BASED ON GUESS AND HI-LO\n\n70 PRINT \"YOU MUST ZERO IN ON IT IN 7 GUESSES.\":PRINT\n\n80 PRINT \"I TELL YOU TO GUESS HIGHER, OR LOWER.\":PRINT\n\n220 PRINT:PRINT \"YOU'VE USED ALL OF YOUR GUESSES.\"\n\n250 PRINT \"YOU GOT IT IN \";COUNT;\n\nWhen you’ve got it all in, type RUN, and play the game. To stop the game, hit ESC, and it will quit (saying “BREAK IN 10” or whatever line number) and then say READY. You’re back in BASIC, and can start coding again. You’ll likely need to do this as you run into unexpected behaviors dues to typos (A software bug! Squash it!). It’s also handy as you decide you want to make modifications to try something new.\n\n10 Great Text-Based BASIC Games to Get Started With\n\nRemember that the real value here is sitting down and typing things in. Consider this: woodcarving can be an enjoyable hobby. But buying a carving is not at all the same thing. We’ll get to the process of downloading BASIC games in a little bit. That can be handy for trying things out quickly. But take your time now, and have fun learning.\n\nNote that these are all selected from David Ahl’s immensely popular BASIC Computer Games books, which were written expecting that the computer would have an 80 column (80 characters wide) screen. The Commodore 64 has a 40 column screen. This means that if used as-is, some will format strangely, with the long lines wrapping around. This is usually easy to fix, and good practice for making modifications. To fix long lines of text, break the PRINT statements into multiple lines like so:\n\n240 PRINT \"THE BOARD IS A BIG COOKIE - R ROWS HIGH AND C COLUMNS\"\n\n250 PRINT \"WIDE. YOU INPUT R AND C AT THE START.\"\n\n250 PRINT \"YOU INPUT R AND C AT THE START.\"\n\nThe first few are from his first book BASIC Computer Games, published in 1978, which was the first computer book to sell over a million copies. Lyle Kopnicky over at the Vintage BASIC site (with express permission from Mr. Ahl), has converted these over to text files (not just scans of the book pages), and tightened them up a bit to run in his own version of BASIC. I have tried out several of these, and they’ve all run cleanly, except for the aforementioned 80 column/40 column screen formatting,\n\nAnd before we get going, I must mention that half the charm of Ahl’s books is the very cool robot illustrations done by George Beker. I have included two here.\n\nThe games will start off with some simpler ones, and then mix in more sophisticated ones. Super Star Trek and Eliza at the end are both rather involved.\n\nThe following games are from David Ahl’s follow-up book More BASIC Computer Games, published in 1979. Note that these are just the scanned book pages, and do not have accompanying text files. Maybe you can share after typing them in?\n\nOne final note about these games. These programs hail from the 1970s, and are sourced from different contributors that sent them in to Mr. Ahl. Styles, structure, and line number as well as other conventions vary. Some are pretty tight, and others have little oddities in how they were created. This is long before the present day, in which programmers are often OCD about their adherence to detailed coding styles. Consider any wackiness you find in your digital archaeology just artifacts of the era.\n\nThese final two are long programs. Type them in for the full experience of going oldschool, or use the instructions below to download them and get them into your C64 Mini.\n• This is a great place to start. Like many of these games, it’s a combination of strategy and logic. This one is based on a mathematically-inspired game published by Martin Gardner in Scientific American. In a nutshell, you choose a grid size up to 9 X 9, and the grid is filled in, with the top left space being “poison.” The goal is for two players to alternate back and forth, each chomping part of the grid, trying to force the other player to take the last chomp that includes the poison space. Battle back and forth to work out your strategy. See the original book page, with explanation and BASIC code listing (use NEXT to see 2nd page) [ See how to get it on your C64 Mini ]\n• You’re in a lunar lander that is descending toward the moon’s surface. You have a certain amount of fuel in your engines, and you’re falling at a certain rate. The game starts with you at a certain height, and you must try to use fuel in a way that lets you land safely, by reaching near zero in speed as you arrive at the surface. The built-in calculations make it very realistic and challenging. Do you go all out? Wait till the last minute? Test your strategy. Then try adjusting variables, like capsule weight and fuel amount. See the original book page, with explanation and BASIC code listing [ See how to get it on your C64 Mini ]\n• This is the classic resource management game. You are in charge of handling the people, land, and grain for a city in ancient Sumeria. You can buy and sell land for grain at varying prices, while also planting grain, and making sure you feed your growing population. It’s a tricky juggling act to keep it all in balance. Think of this game like Sim City’s grandpappy. See the original book page, with explanation and BASIC code listing (use NEXT to see 2nd page) [ See how to get it on your C64 Mini ]\n• Another absolute classic. This isn’t a game so much as a fascinating simulation where you seed organisms into a simple environment, and then watch the population grow, shrink, and change form over time. It all runs according to a simple rule set published in Scientific American by Martin Gardner (again!). Once you understand the rules of how the organisms change, try different starting configurations to see how your results change. It’s kind of addictive. See the original book page, with explanation and BASIC code listing (use NEXT to see 2nd page) [ See how to get it on your C64 Mini ]\n• Everyone knows this game. Guess letters to solve the word before you are hanged. But because it’s so familiar, this is a great one to examine and take apart. Start with changing the data statements at the end to put in your own words. If you’re feeling clever, try adding an option to have another player enter a word, instead of using the built in ones. Can you do it? See the original book page, with explanation and BASIC code listing [ See how to get it on your C64 Mini ]\n• Another strategy game, this one is similar in concept to the old Minesweeper in Microsoft Windows (but this came first). Target squares in a 10 X 10 grid in pursuit of 4 mugwumps. Get feedback on how close you are, then refine to nail them. Kind of like Battleship, with feedback. See the original book page, with explanation and BASIC code listing (use NEXT to see 2nd page) [ See how to get it on your C64 Mini ]\n\nThe following games are from David Ahl’s follow-up book More BASIC Computer Games, published in 1979. Note that these are just the scanned book pages, and do not have accompanying text files. Maybe you can share after typing them in?\n• Up to 3 players can compete by using speed, muzzle velocity, and angle top lob artillery shells at one another. Who will be the last one standing? See the original book page, with explanation and BASIC code listing (use NEXT to see 2nd page) [ See how to get it on your C64 Mini ]\n• This simulation has you commanding a military space ship, and seeking out the enemy ship to destroy it. Choose your ship, select weaponry from the armory, then find the enemy ship. Get closer to fire more accurately, but risk getting shot yourself. Make tactical decisions as your ship takes on more damage. Who will go down in defeat? See the original book page, with explanation and BASIC code listing (use NEXT to see 2nd page) [ See how to get it on your C64 Mini ]\n\nThese final two are long programs. Type them in for the full experience of going oldschool, or use the instructions below to download them and get them into your C64 Mini.\n• As captain of the Starship Enterprise, you fly around through the quadrants of the galaxy and do battle with Klingon warships. This game is much more ambitious and sophisticated in depth and scope than most of the others. The code listing is a lot longer, and BASIC Computer Games even has two separate listings for it - one for the game, and one for the instructions. This game was one of the first I ever played, on a computer the size of a desk, in the late 70s. It’s been around for a long time, and was very popular back in the day (and consider that it was pretty contemporary back in the day, what with Kirk, Spock, and Bones being pretty new back then). See the original book page, with explanation and BASIC code listing (use NEXT to see subsequent pages) [ See how to get it on your C64 Mini ]\n• This is an absolute classic. It was EVERYWHERE back in the day. It’s not really a game, but a simplistic, pseudo-AI. It basically babbles responses back to whatever you type in, rephrasing your statements back as new questions. The whole setup is that it claims to be a psychiatrist, so it’s helping you work through your “problems.” Responses are often funny, due to their awkward weirdness. Can you hack the Eliza code to tailor her responses? See the original book page, with explanation and BASIC code listing (use NEXT to see subsequent pages) [ See how to get it on your C64 Mini ]\n\nSee all of David Ahl’s BASIC Computer Games\n\nSee all of the BASIC Computer Games text files\n\nSee all of David Ahl’s More BASIC Computer Games\n\nHow to Save and Load Your Typed-In BASIC Games on the C64 Mini\n\nIf you’re going to type in some games, you’re going to need a way to save your work. Who wants to turn the machine off and lose what you did?\n\nOn the C64 Mini, you have two handy ways to save your BASIC programs. We’ll skip the first, since it’s limited to just four save slots (like the built in save game slots). The better way to save is to have a USB thumb drive formatted to FAT 32 (see my other post on C64 Mini Homebrew Games for how to format in FAT 32). Plug in the USB drive, and once you have your program the way you want it, type:\n\nThat 8 at the end is the Commodore way of telling it which device it should save to - in this case, the main (virtual) floppy drive. It should respond with:\n\nIf it doesn’t already exist, the C64 Mini will create a disk image (a file that looks like a floppy disk to the C64) and call it THEC64-drive8.d64. That .d64 extension on the end is the C64 disk image file type. Keep in mind - this file is NOT your program you just saved. It’s a virtual disk that has your program in it. You can (and will, of course) save multiple things to this virtual floppy disk.\n\nIf you ever need to create a disk image just so you can import some stuff you downloaded from the internet (see below), just save a simple 1 line program in order to make the C64 Mini create the disk image that you can open on your computer, and then save your downloaded stuff to.\n\nIt’s important to be able to see what’s in your disk image. If you come back in the future after saving a few things, you may not remember exactly what’s in there, or what everything is called. Type:\n\nAgain, that 8 tells it to look at the main (virtual) floppy disk drive. Telling it to LOAD”$” is the command to get a listing of the drive’s contents. It will say:\n\nNow it has the list of the disk contents, but you have to tell it to show it to you:\n\nExcellent. Now that you know it’s saved for you, let’s practice loading.\n\nLoading Your BASIC Game Back Into the C64 Mini\n\nOnce you have confirmed your work is saved, type:\n\nYou should see that the NEW command has wiped your program from memory. You are now clear to load it back in with:\n\nThe Mini should respond with:\n\nAnd you should see that your program is back.\n\nOther Handy Tricks for Saving Your Work\n\nDo you want to save some revisions you made over an existing file? Add @0: to the front of the file name to tell the Mini to replace the existing.\n\nIf you want to verify a saved program, you can type:\n\nAnd it will respond with:\n\nGet Downloaded Text-Based BASIC Games Onto Your C64 Mini Using VICE\n\nThis will not be a tutorial on using VICE (the desktop Commodore 64 emulator), but just the steps necessary to get downloaded games into the virtual disk image you created on a USB thumb drive. Haven’t done that yet? Jump back up to to that part of the post and create your disk image by saving something to your USB thumb drive. If you already have a thumb drive with a disk image on it, then proceed to the next step.\n\nYou’ll need to download and unzip the appropriate version for your operating system:\n\nDownload VICE for OSX - I used the one called vice-macosx-cocoa-x86_64-10.12-3.1.dmg, since I am on OSX 10.12, and the SDL version would not even open for me. Your experience may be different. When you try this, there may be a newer version.\n\nDownload VICE for Windows - I used the one called WinVICE-3.1-x64.7z since my Windows machine is 64-bit. I got the native one, and not the SDL version, since the SDL one for OSX didn’t work. Note that the file ends in .7z, which tells you it’s a 7-Zip file, not a regular zip file. When you double click it to open it, you may be told you don’t have an application to open it. In the little notice that comes up, double click the option to find an application in the Windows store. From there, I just picked a free app that opens 7-Zip files. Run your new 7-Zip application, and open the VICE file you just downloaded.\n\nRun the VICE Commodore 64 emulator by double clicking on the x64 icon (x64.app on OSX). Now mount the virtual disk from your USB thumb drive like so:\n\nFile > Attach Disk Image > #8… and locate the THEC64-drive8.d64 file on your thumb drive. If you recall from before, we load and save with a ,8 on the end to tell it the device to work with - our main (virtual) floppy drive. This is the same reason we just opened this THEC64-drive8.d64 virtual disk image using Unit #8. We’re putting the virtual floppy into the virtual main floppy drive.\n\nOnce you’ve done that, use the commands you learned above to get the listing of the disk’s contents:\n\nYou’ll see the contents of your virtual disk - whatever you saved in order to create the disk image (see above again for more details).\n\nNow grab the source of what you want to import. Let’s grab the CHOMP game we talked about above. You’ll see that link takes you to a plain text file called chomp.bas. This is not an HTML page, but plain text, which is what we want. Click on the code, and hit CMD+A (OSX) or CTRL+A (Windows) to select everything. Now hit CMD+C (OSX) or CTRL+C (Windows) to copy it.\n\nNow here’s the tricky bit. We’re going to paste this into the VICE window, only there’s one problem. Try it, and you’ll see that you get a gobbledy-gook of special characters, not the program. What’s the problem? Even though VICE shows everything in ALL CAPS, it does that just because that’s what C64s do. If you put in real caps by pasting or holding shift and typing, you get these C64 special characters. What it wants is lower case. Ugh. Does that mean you have to retype this? Nope - just use ConvertCase.net or similar tool. Paste your ALL CAPS code into the window on ConvertCase (CMD+V or CTRL+V), and then click the “lower case” tab. Voila! Now click the “copy to clipboard” tab, and go back to the VICE window.\n\nClick into the VICE window, and paste in your copied text. Be sure to hit ENTER at the end to enter the last line.\n\nNow use what we learned before to save this to our virtual disk:\n\nBAM! You’ve got it. Now close VICE, and properly eject your USB drive. Take it to your C64 Mini, plug it in, and then in BASIC, type:\n\nLIST it, and see that you’ve got it! Now run that baby.\n\nPro tip: If you find you’re enjoying modifying or writing your own BASIC programs, you may find it more efficient to work on your computer in a text editor, and then save out your work and move it to the C64 Mini. If you’re getting really serious, and want to test on your computer, so you only take it to the C64 Mini when it’s all finished, then load up Chipmunk BASIC using the instructions below. Need a good text editor (you can’t use a word processor, it has to do plain text)? Try Atom.\n\nWhile BASIC was nearly unavoidable in 80s personal computing, you’re unlikely to find it on contemporary computers. But that doesn’t mean you’re out of luck. There are new implementations of BASIC that have been created for your present day machine. Chipmunk BASIC is a great option that’s easy to set up and use. First, grab the appropriate download for your machine, and unzip it (double click).\n\nYou can double-click Chipmunk Basic.app like any other application, and it will open a window where you can go ahead and start typing. To exit a running program, use CMD+C.\n\nThe file simply called basic is for use on the command line. Open Terminal, navigate to the folder where it is, and run it by typing ./basic at the command prompt. To exit a running program, use CTRL+C. Handy tip: use the free Go2Shell to open a Terminal at the current folder you have open in Finder.\n\nYou can double-click the chipmunkbasic application like any other application, and it will open a window where you can go ahead and start typing. To exit a running program, use CTRL+C.\n\nThe file simply called basic (or basic.exe if file extensions are turned on) is for use on the command line. Open the command line in Windows 10 by hitting WINDOWS KEY+R to get a run box, and type cmd into the box and hit ENTER. Navigate to the folder where basic.exe is, and run it by typing basic.exe at the command prompt. To exit a running program, use CTRL+C.\n\nIf I’m writing in the Chipmunk BASIC app, I can save my work by typing:\n\nSAVE “AWESOME.BAS” (or it could be in lower, or mixed case, since you’re on a modern computer, but I’ll stick with all caps for consistency)\n\nOn OSX, this saves AWESOME.BAS to the current user’s Documents folder. Now I can open that in my text editor, and edit to my heart’s content, resave (or save a new version), and then reload the changes into Chipmunk BASIC by typing:\n\nSo now you can easily work in a modern text editor with all of its conveniences, and then test locally in Chipmunk BASIC. When you have your work perfected, you can use the process outlined above to import your work into the C64 Mini via VICE.\n\nNote that in Windows, saving your file saves it out to the same folder basic is in, which actually makes more sense.\n\nVintage BASIC is an application from Lyle Kopnicky, the fellow who provided the BASIC source code text files we used above. It works a bit differently. It doesn’t provide an editing interface the way Chipmunk BASIC does, but is designed with the idea that you will be using a modern text editor, and then just using vintage BASIC to run your programs. Download and unzip the proper version for your operating system, and then at the command line, type:\n\nIt’s a different way of working, aimed at modern workflows.\n\nKeep in mind that there can be variations between some of the details in different BASIC version. When in doubt, check documentation on the sites.\n\nBONUS 2: Because You’re Still Reading This\n\nHere are a couple of special somethings for you since you’re still here:\n\nAnother of David Ahl’s books, BASIC Computer Adventures, unpacks how to create various adventure games, with complete source code for typing in. These aren’t what are normally referred to as text adventures, but they are a different and interesting take on an adventure premise within a BASIC game.\n\nAhl’s book Big Computer Games goes in for larger, more complex game programs. If you want to see how they used to code up more sophisticated BASIC games, this is the place to look.\n\nFeeling a desire for some computer history? Check out a PDF of the original BASIC manual from Dartmouth, in 1964 (the birth place and year of BASIC)."
    },
    {
        "link": "https://cx16forum.com/forum/viewtopic.php?t=6120",
        "document": "NOTE: If you just want to run the latest version of this game on the Web based emulator do like this.\n\n\n\n\n\n 2. Go here: https://www.commanderx16.com/emulator/x16emu.html and paste the code. (CTRL-V)\n\n\n\n\n\n This (version 0 of the game) is a very little game I wrote on the commodore 64 ages ago, I changed it a little to work with vpeek, vpoke, the new color command, and the new screen resolution.\n\n\n\n\n\n To me starting with a simple game in basic is how I learned about the c64, and now the X16, before jumping in machine language. \n\n\n\n\n\n In the code for this game you can see practical examples, on how to set characters on the screen, read characters from the screen, change colors for characters, listen to the keyboard, set a screen mode.\n\n\n\n\n\n What surprised me was that I needed a delay in the code in order to have it not run too fast. This was not the case on the c64. \n\n\n\n\n\n I really like the way you can use the emulator in the browser, as it allows you to type in basic inside the browser, using \"regular key mappings\", and the run it. \n\n\n\n\n\n When I wanted to save it, I copy-pasted it into the installed emulator (hats off for who added he paste function there), and types the save command. \n\n\n\n\n\n This was done, because in the browser you cannot save it, and see it on disk (as far as I know)\n\n\n\n\n\n I added many REMs in the code, in order so it can be understood, and it is more of a tutorial, then a \"real\" game.\n\n\n\n\n\n Below I will go through the code.\n• From line 9, the title screen is drawn\n• From line 49, the game is initialized\n• From line 300, the game over screen is drawn\n• The SCREEN command is used to set the screen in text mode (Petscii) 40x30\n• The color command is used to set character fore and background colors. Unlike the c64 each char has its own background color. There is no \"global\" background color\n• CHR$(113) is used to draw the Petscii circle character, used on the title screen. Adding the actual character into the code listing, makes it hard to edit outside the emulator.\n• VPOKE 0,0,x, pokes a character on the top level corner of the screen. So the text screen address = 0 (not like on the C64)\n• On line 52 the bottom of the screen offset is calulated. NOTE: Even though the screen is 40 chars long, to get to VPOKE address of the next line, you need to add 256 bytes.\n• SI and PI (StoneImage and PlayerImage) are Petsci chars, that are used in the game. NOTE: Petscii chars have different values in the PRINT or the VPOKE commands.\n• Reminder: In C64/Microsoft basic a variable name is only two characters long max.\n• Reminder: Lines in Basic should not be longer then 80 chars. When you make them longer, the emulator ignores them.\n• A good place to see all PETSCII character codes is here: https://www.commanderx16.com/forum/index.php?/files/file/23-vera-chars/\n\n \n\n \n\n\n\n\n\n (it is easier to copy paste it in the browsers emulator and be able to modify it more easy here: https://www.commanderx16.com/emulator/x16emu.html\n\n\n\n\n\n ----- code below for copy & pasting, also you can get it by downloading FALLSNAKE.PRG or checked out at: https://github.com/JoystickAndCursorKeys/x16basic/blob/main/fallingsnake.v0.bas.txt----- \n\n\n\n\n\n \n\n\n\n 9 REM TITLE SCREEN -----------------\n\n\n\n 10 REM SET COLORS TO BLACK AND WHITE, CLEAR SCREEN\n\n\n\n 11 COLOR 1,0: CLS\n\n\n\n 12 PRINT:PRINT:PRINT:PRINT : REM PRINT TITLE\n\n\n\n 13 PRINT \" FALLING SNAKE\": PRINT: COLOR 15\n\n\n\n 14 PRINT \" YOU ARE FALLING DOWN A HOLE\"\n\n\n\n 15 PRINT \" AVOID ALL OBSTACLES\"\n\n\n\n 16 COLOR 7: PRINT \" PRESS SPACE TO START\"\n\n\n\n 17 BA$=CHR$(113):BB$=CHR$(119) : REM BALL SYMBOLS\n\n\n\n 18 COLOR 2,0 : PRINT \" \"+BA$\n\n\n\n 19 PRINT \" \"+BA$:PRINT \" \"+BA$\n\n\n\n 20 PRINT \" \"+BA$+BA$+BA$+BA$+BA$+BA$+BA$+BA$+BA$;:COLOR 8:PRINT BB$\n\n\n\n 25 GET A$: IF A$=\"\" GOTO 25 : REM WAIT FOR KEY\n\n\n\n 35 TS=0 : REM SET TOP SCORE\n\n\n\n\n\n \n\n\n\n 199 REM GAME LOOP -----------------\n\n\n\n 200 GET A$\n\n\n\n 201 IF A$=CHR$(29) AND PX<40 THEN PX=PX+1 : REM GO RIGHT\n\n\n\n 202 IF A$=CHR$(157) AND PX>0 THEN PX=PX-1: REM GO LEFT\n\n\n\n 210 X=INT(RND(1)*40)*2: C=INT(RND(1)*15)+1 : REM GET RANDOM STONE POSITION\n\n\n\n 211 PE=VPEEK( 0, PO+(PX*2))\n\n\n\n 212 IF PE=SI THEN GOTO 400\n\n\n\n 220 VPOKE 0, BO+X, SI: VPOKE 0, BO+X+1, C\n\n\n\n 221 VPOKE 0, PO+(PX*2), PI: VPOKE 0, PO+(PX*2)+1, PC\n\n\n\n 296 FOR W=1 TO DE: NEXT : REM DELAY, SLOW DOWN CODE\n\n\n\n 297 PRINT : S=S+1 : DE=DE-1 : IF DE<0 THEN DE=0\n\n\n\n 298 GOTO 200\n\n\n\n\n\n \n\n\n\n 399 REM GAME OVER -----------------\n\n\n\n 400 IF S>TS THEN TS=S\n\n\n\n 401 PRINT HM$:PRINT:PRINT:PRINT \" GAME OVER\": PRINT\n\n\n\n 402 PRINT \" SCORE: \"+STR$(S);\n\n\n\n 405 PRINT \" TOP SCORE=\"+STR$(TS)\n\n\n\n 410 COLOR 7: PRINT: PRINT \" PRESS SPACE TRY AGAIN\" : PRINT:PRINT\n\n\n\n 420 GET A$\n\n\n\n 421 IF A$ = \"\" OR A$=CHR$(29) OR A$=CHR$(157) THEN GOTO 420\n\n\n\n 422 GOTO 50\n\n\n\n\n\n The way I normally work when creating a game, I create first the skeleton, and then add more and more niceties, like effects, and game play elements.\n\n\n\n\n\n Above, we have the skeleton, we have a minimal game. We have a title screen, we have a playable section, we have a score, a game over section, and a high score.\n\n\n\n\n\n Below I will show the improvements I made so far, and are saved in FALLSNAKE2.\n• In the init section of the program, I rearranged the line numbers, so I would not overlap with the rest of the program, when adding two more lines. The added lines are in Bold/Underline.\n\n \n\n\n\n\n\n Line 3, I allocate an array called EX to store the \"petscii picture\" of an \"explosion\". It is 9 chars. The \"picture\" is 3x3 chars. No colors. 3x3=9, which is how much we need to allocate with the DIM command.\n\n\n\n\n\n Line 4, reads data from the DATA statements at the end of the program into the array called \"EX\".\n\n\n\n\n\n 0 REM SET TO 40X30 CHARS SCREEN\n\n\n\n 1 SCREEN 0\n\n\n\n 2 HM$=CHR$(19) : REM HOME CHARACTER\n\n\n\n 3 DIM EX(9)\n\n\n\n 4 FOR T=0TO8: READ C : EX(T)=C: NEXT : REM READ PETSCII EXPLOSION\n• In the \"Game over\" section of the game, I added the drawing of the explosion picture, and a flashing color effect to go with it. Again, I renumbered the code around it a bit.\n\n \n\n\n\n\n\n We iterate through the characters in the EX array, by looping x and y from 0 to 2, and calculating the offset to EX (called DO, data offset). We use VPOKE to put the bytes on the screen memory, at address SO (screen offset). SO is calculated by using the xx + the player y coordinate, minus 1 (this will be XS). Similar will be done for y, but to calculate SO, we add XS*2 (each char takes two bytes) + YS*256 (from one row to the next the distance offset is 256 chars)\n\n\n\n\n\n 401 REM DRAW EXPLOSION\n\n\n\n 402 FOR XX=0TO2:FOR YY=0TO2\n\n\n\n 403 XS=XX+PX-1: YS=YY+15-1 : REM SCREEN X,Y\n\n\n\n 404 IF PX<1 THEN XS=XX+1 : REM CHECK PLAYER X TO BE ON SCREEN\n\n\n\n 405 IF PX>38 THEN XS=XX+38\n\n\n\n 406 DO=XX+(YY*3):SO=(XS*2)+(YS*256) : REM CALC DATA OFFSET, SCREEN OFFSET\n\n\n\n 407 VPOKE 0,SO,EX(DO) : REM WRITE TO SCREEN\n\n\n\n 408 NEXT:NEXT\n\n\n\n\n\n Below there is a simple color cycling effect for the background, this is done by adding random values into palette register for color 0. The register is stored in two addresses, $FA00 and $FA01. Actually some bytes are not used, but for a random effect we ignore that. If we want to have for example a red explosion flicker, we need to be more careful on the values we put into the register.\n\n\n\n\n\n 410 REM EXPLOSION COLOR EFFECT\n\n\n\n 411 FOR T=1 TO 50\n\n\n\n 412 C0=INT(RND(1)*255)\n\n\n\n 413 C1=INT(RND(1)*255)\n\n\n\n 414 VPOKE 1,$FA00,C0: VPOKE 1,$FA01,C1\n\n\n\n 415 NEXT: VPOKE 1,$FA00,0: VPOKE 1,$FA01,0\n\n\n\n\n\n and the last part (after renumbering even more lines of code), we added the data for the explosion petscii \"picture\".\n\n\n\n\n\n The complete code can be found in FALLSNAKE1.PRG, or checked out at: https://github.com/JoystickAndCursorKeys/x16basic/blob/main/fallingsnake.v1.bas.txt\n\n\n\n\n\n One thing that keeps me going when creating a game, is but adding sessions where I make the game look nicer, without adding functionality.\n\n\n\n The changes below (1.0.2 version, FALLSNAKE2.PRG), is all about this.\n\n\n\n\n\n To start off, we have been renumbering again the lines of the source code. \n\n\n\n\n\n For those that are not used to using old school type basic, it is very easy to add extra code and run out of numbers. And it is important to \"reserve\" numbers. So for example if you make a program like this.\n\n\n\n \n\n\n\n\n\n And you want to add something between line 1 and 2, you cannot do it, unless you renumber the existing lines. For that reason it is a better idea to start coding like this:\n\n\n\n\n\n This way you have some space in between, and you could easily add a line 15 to print something else, if you want to.\n\n\n\n\n\n Nevertheless it can still happen even when you have reserve ranges, and they get to be \"full\". This is especially the case when you add new sections of verbose code between other code. And this is exactly why I am once more renumbering. \n\n\n\n\n\n To add sprites, you need to have the images stored some where. The old school way of doing it, is to add \"DATA\" commands to the code, like below. I will not write it completely here, since it becomes very verbose, but it looks something like this:\n\n\n\n\n\n ..... Many more lines of this\n\n\n\n\n\n NOTE: Only in the 80s would you type in lines and lines of DATA like this. Now there are easier ways, for example a sprite editor with an export function. There are many options, below is one of them that I am coding on myself.\n\n\n\n\n\n The important thing is to export to a sprite data that the X16 understands. In this case 16x16 dimensions, 16 colors, so 4bpp (4 bits per pixel for color info), and basic support HEX numbers.\n\n\n\n\n\n And to use them, you write something like this.\n\n\n\n\n\n 1000 REM READ SPRITE DATA \n\n\n\n 1001 FOR I=O TO 255\n\n\n\n 1011 READ PX : REM READ ONE NUMBER FROM THE DATA.\n\n\n\n 1012 VPOKE $0,$4000+I,PX: REM USE VPOKE TO MOVE THE DATA IN VIDEO MEMORY\n\n\n\n 1013 NEXT I\n\n\n\n 1014 RETURN\n\n\n\n\n\n At the end of these lines of code, you see the command RETURN. What is this about?\n\n\n\n\n\n Well, with basic we can simulate calling a function/subrouting, with GOSUB. RETURN returns back to where it was called.\n\n\n\n\n\n The code is being called in the beginning, something like this:\n\n\n\n\n\n After the call to the subroutine at line 1000, it continues to the next line. This is one way to organize the code inside Commodore/Micro$oft basic.\n\n\n\n\n\n I will not mention all the details of setting up the sprite here, you can check the code yourself, if you want to. Later I will go deep into this topic, but not here.\n\n\n\n\n\n However to get the sprite in the right position we have another subroutine.\n\n\n\n \n\n\n\n\n\n 1070 REM SET SPRITE 0,X0,Y0\n\n\n\n 1171 VPOKE $1,$FC12,X0 AND $FF\n\n\n\n 1172 VPOKE $1,$FC13,(X0 AND $0300)/$100 : REM MAGIC TO GET HI BYTE OF THE X COORDINATE\n\n\n\n 1173 VPOKE $1,$FC14,Y0 : REM YPOS 128\n\n\n\n 1174 VPOKE $1,$FC15,$00 : REM WE DON'T CALCULATE THE HI BYTE OF THE Y COORDINATE\n\n\n\n 1175 RETURN\n\n\n\n\n\n Which I call in the title screen build up like this.\n\n\n\n\n\n Note that for calling the subroutine with parameters, we simply assign global variables. To keep from clashing with other global variables, use a naming convention.\n\n\n\n\n\n Here I used 0 (zero) as the second 'letter' in the name as the naming convention.\n\n\n\n\n\n In the game, the position changes all the time, so instead we do like this:\n\n\n\n\n\n X0 is calculated. Y0 is static, but X0 is PlayerX (PX) times 8 (the width of a character on screen in bits)\n\n\n\n\n\n Now for the colour effect, we chose one color to be the one that has the effect, and we draw our blinking characters with this color. Like below.\n\n\n\n\n\n And we cycle / blink, by doing something like this.\n\n\n\n\n\n 80 C0=C0+1: IF C0>2 THEN C0=0: C1=C1+1: IF C1>255 THEN C1=0:\n\n\n\n 82 VPOKE 1,$FA1C,C1: VPOKE 1,$FA1D,C1\n\n\n\n\n\n Offset $FA1C and $FA1D in the VERA video ram, control the palette registers for color 14. Each color has two bytes, so if you want to find the color register for color 0, you just substract 28 decimal (2*14) from hex $FA1C.\n\n\n\n\n\n Feel free to check out the code or the PRG file, at this stage.\n\n\n\n\n\n In the next session we will concentrate a bit more on gameplay. It is no use to pimp up the graphics, if the gameplay is boring.\n\n\n\n\n\n Since this is really a simple game, we easily can do a few things to spice it up.\n\n\n\n\n\n So now it is time to look a little at the game play.\n\n\n\n\n\n So far the gameplay has been very simplistic. Avoid obstacles, and do it as long as you can. And the obstacles are the same.\n\n\n\n\n\n And the speed is the same always.\n\n\n\n\n\n ...... Hold on, not so fast.\n\n\n\n\n\n In the previous sections I managed to sneak in two lines of code that change the play speed over time. The longer you play the quicker the game becomes.\n\n\n\n\n\n This was done as such.\n\n\n\n\n\n Here the delay between each \"cycle\" in the game is defined as 1000, before the game starts.\n\n\n\n\n\n And then to use the delay, we have:\n\n\n\n\n\n 296 FOR W=1 TO DE: NEXT : REM DELAY, SLOW DOWN CODE\n\n\n\n\n\n And to decrease we have:\n\n\n\n 297 ......................... DE=DE-1 : IF DE<0 THEN DE=0\n\n\n\n\n\n This already gives a little variation in the game. Let's add even more.\n\n\n\n\n\n (ps, you can see all the latest changes here on github\n\n\n\n\n\n The two gameplay elements I intend to add are \"Slow down\" and \"Extra (Bonus) Points\"'\n\n\n\n\n\n Since the game goes faster and faster it it reasonable tro asume that the player wants to slow down from time to time. With this \"feature\", this will be possible. \n\n\n\n\n\n How will it work? Some of the objects that need to be avoided will look different. (Arrow up sign) And to make them recognizable they also have a blue blinking color.\n\n\n\n\n\n When you catch one, your speed (DE) will be increased.\n\n\n\n\n\n Extra points is implemented in a similar way. There is another symbol (a green clover, to symbolize snake food (yes Simon is a vegetarian snake :) ). When you run into this symbol, your score will be increased by a fixed amount.\n\n\n\n\n\n NOTE: In order to do all this, we needed to renumber a few things again. You see that happening alot in old school basics, at least when I am programing there ?\n\n\n\n\n\n To do all this, first we defined all the colors characters for the different types of obstacles.\n\n\n\n\n\n #CHARACTERS. see any Petscii table like on page https://www.linusakesson.net/art/three-petscii-pieces/index.php\n\n\n\n 7 DIM IO(6): IO(0)=$66: IO(1)=$6F: IO(2)=$54: IO(3)=$75: IO(4)=$58: IO(5)=$1E\n\n\n\n\n\n Now we have 6 characters defined, we can select a random one by just doing a INT(RND(1)*6)\n\n\n\n\n\n But actually I do a little differently, to make the changes to select a special character lower, my code looks like this.\n\n\n\n\n\n C = the value for the color, I is the value for the character (I=image)\n\n\n\n\n\n And we poke them on the screen like so:\n\n\n\n\n\n But now we cannot just jump to \"explosion\", when we hit something, we we also adjust our code here:\n\n\n\n\n\n IF PE<>32 THEN O0=O: C0=PE: D0=1: GOSUB 500 : IF D0=1 THEN GOTO 400\n\n\n\n\n\n O0,C0 are the input parameters for the gosub, and D0 is the output.\n• O0, is the object offset on the screen of the object we collide with.\n• C0, is the character code of this object.\n• D0, is returned. It is 1 if we died, zero otherwise.\n\n \n\n\n\n\n\n If D0 is returned 1, we jump to 400, where we go into the \"die/explosion\" state.\n\n\n\n\n\n The handling of the different collisions with \"slow\" and \"extra points\" is done at line 500. \n\n\n\n\n\n 500 REM CHECK COLISSION\n\n\n\n 501 D0 = 1\n\n\n\n 502 IF C0 = $58 THEN S=S+50 : D0=0: GOSUB600 : REM GOT FOOD = EXTRA POINTS\n\n\n\n 503 IF C0 = $1E THEN DE=DE+100 : D0=0: GOSUB630 : REM GOT \"SLOW DOWN\" SYMBOL\n\n\n\n 505 RETURN\n\n\n\n\n\n And this i basically our changes. Feel free to copy the code from:\n\n\n\n\n\n To test it in the emulator.\n\n\n\n\n\n As I mentioned before, in order to keep the interest for such a game, I usually sneak in some visual improvements, so that also happened during my focus on game play.\n\n\n\n\n\n The \"slow\" character has been made to flash blue/cyan.\n\n\n\n\n\n This is done like this.\n\n\n\n\n\n 1. The character is always drawn with color 6\n\n\n\n\n\n 2. The pallette color for color 6 flips between 2 presets.\n\n\n\n\n\n This is done with these 3 lines of code.\n\n\n\n\n\n Increase a counter. This counter has only one purpose, to control the speed of the blinking.\n\n\n\n\n\n 281 IF CL>2 THEN CL=0: CC=1-CC : LO=255:HI=8: IF CC=1 THEN LO=15:HI=1\n\n\n\n\n\n If the counter is larger then 2, then reset it, and flip a flag called CC, by inverting it's value with CC=1-CC\n\n\n\n\n\n Set the low and high value of the color index. If the flag is set, overwrite the color low and high value with different values.\n\n\n\n\n\n And this last line, writes it into the palette register, so it becomes visible. Remember to only now use color 6 for things that should blink.\n\n\n\n\n\n (And the same goes for color 15, which is blinking during the title screen)\n\n\n\n\n\n To make it a little more looking like a professional game, we add a score display on the screen. While we are add it, we also add the speed.\n\n\n\n\n\n Making it finally look like this:\n\n\n\n\n\n Let's have a look on how we added this.\n\n\n\n\n\n Writing the information to the top of the screen buffer would not work very well, since the whole screen buffer is scrolling upwards, and so it would keep dissapearing, resulting in a flicker. \n\n\n\n\n\n Also, since this is Basic, updating 80 bytes for each cycle, would create alot of delays.\n\n\n\n\n\n The X16 has hardware support for two layers of text. And the top layer can have transparency, so you can still see the bottom layer. The transparency is enabled by using color 0, which is black.\n\n\n\n\n\n The score is \"printed\" in the frontmost layer.\n\n\n\n\n\n We can add this extra layer by direcly poking in Vera's registers.\n\n\n\n\n\n There are some things to keep in mind:\n• The extra text layer is not accessible through \"PRINT\", so it needs to be changed by POKING directly in the buffer.\n• Per default BASIC uses layer 1, which is the front layer. We want BASIC to use layer 0, which is the background, since we're printing everything on the background with basic commands.\n• Writing a number to the screen, is time consuming, and slows down the game. So for now, we only update the score-bar, each ten cycles, to save on speed.\n\n \n\n\n\n\n\n We start out by adding a new routing, to setup the layered text based screens.\n\n\n\n\n\n These registers point to the tilebase and the layer 0 config. So layer 0 looks now like layer 1. Same font, same screen dimensions.\n\n\n\n\n\n Now setting layer 0 to point to screen memory offset 0, and layer 1 to screen offset \"$0F\" (note this is only the \"high byte\" of the offset)\n\n\n\n\n\n And last, we clear the screen with the right colors. (this affects now layer 0, after our changes)\n\n\n\n\n\n Since one of our layer is now in a different memory space then basic looks at, we need to manually update this layer with the poke command.\n\n\n\n\n\n By running a simple for loop, we can clear the while screen, while poking a value into the screen buffer.\n\n\n\n\n\n The code turned out so, that it was very slow. So I created a \"fill text line\" routine, which is somewhat quicker. When I want to clear the screen, I call it with the right parameters (offset, draw character, draw color)\n\n\n\n\n\n The code below, as you see is repeating alot of pokes, instead of doing a for loop with one poke in it. This not-so-nice trick, gets us just a tiny bit of speed improvement. Since clearing the screen takes long, any improvement in speed is worth is.\n\n\n\n\n\n Many pokes below. Instead of just one poke. To get this tiny speed improvement.\n\n\n\n\n\n Note that O0, P0, and C0 are the \"input parameters\" to the routine. (offset, draw character, draw color)\n\n\n\n\n\n The next part is the routine to draw a number on the screen, for the score. We have the similar routine for the speed, but the code is basically a copy-paste.\n\n\n\n\n\n The trick is to get the score, which is a number, into a sequence of printable (pokeable) characters. \n\n\n\n\n\n We want the score to also always have the same \"size\", which is six digits. There are not commands in Basic to format the string nicely for us, so we use tricks.\n\n\n\n\n\n We convert N0 (the input of the routing, which is the Score in our case), to a string with STR$. But before that we add 1000000 to it so the output is always score + 1000000, which is 7 digits always.\n\n\n\n\n\n (unless you get more the 1 millions points, then the code stops working fine)\n\n\n\n\n\n And the trick is to use the last 6 characters from the string only. Example: Score = 555 -> 10000000 + Score = 1000555 -> last 6 digits is -> 000555\n\n\n\n\n\n To get the last 6 digits, we start our loop below at position 2. Then we use MID$ to get one character from the string, and ASC to convert that character to a pokeable number.\n\n\n\n\n\n And here we poke it to the video memory. (O0 is the offset)\n\n\n\n\n\n So far this tutorial.\n\n\n\n\n\n The code can be found at:\n\n\n\n\n\n Recreating this old program on the X16 was fun, and quite informative on how the VERA video chip worked. There is many more things you can do to improve the game. One thing we found is that the game currently is \"almost\" a little on the slow side.\n\n\n\n\n\n So adding more features, would need rewrites of certain sections, or moving things into assembly language.\n\n\n\n\n\n Since this is a \"simple game basic manual\", I will not do this here, but the game may evolve in that way in the future.\n\n\n\n\n\n Things you can easily add to the program, without compromising speed, is \"cutscenes\", dedicated character graphics, and perhaps some simple sound effects.\n• For the snake and snake head, I could have used character graphics instead of sprites. In fact there is no real need to use sprites here, but then again, in the end it made the snake head less flickery, which is a nice bonus.\n• Using text mode was a design decision, since Basic has the build in scroll-screen feature, if you print a newline on the bottom line. This is what this game utilizes to it's fullest.\n• Why does the snake fall? In fact it has nothing to do with the story, it is more that it is the simplest way of having a scrolling game. It started out as a car racing game, but the care left trails. So calling the trails for snake was easiest. And since it went down, falling seemed appropriate. If you want a more interesting background story, I can also provide. Simon is domesticated snake, and he goes out one day, and falls down a hole. He needs to avoid obstacles like branches and so on to survive, so he can splash down in the water at the bottom safely, before climbing up again. Feel free to clone the code, and make a more convincing background story if you wish.\n• Color palette changes. Changing the palette is a really cool way to change many things on the screen, with only one command. Which is excellent for BASIC since it saves in CPU usage, and you do not loose to much speed.\n• Even though running fine in the beginning, almost too fast. When you add features to the game main loop, it is very noticeable how the game slows down, and the delay constant DE needs to be set to lower, to run at the same speed. At the end I was running into a limit, since if the delay is too small, you cannot decrease and decrease the delay during the game, since there would be not much to decrease. Going to Assembly, would be an obvious next move.\n• The ability to very simply set the extra layer is a very nice feature. The layer is hardware, so it does not slow the game down at all, and you can overlay semi static information like the score.\n• Sprites: There are so many sprites on the X16, this game is not utilizing them at all, so there is alot of room for improvement for the visuals when it comes to that.\n• Most design goals were also marked by the fact that the reason why the game is simple, is that it uses PETSCII, and PRINT. I wanted to keep that look and feel, so only minimal use of graphics, to spice it up only a little.\n\n \n\n\n\n\n\n This game will probably be possihed a while more, since it is fun to do, but that will not be part of this tutorial.\n\n\n\n\n\n However feel free to watch the download section / games, to see the next version being worked on.\n\n\n\n\n\n \n\n\n\n Check out as well the youtube video below, where I do a (quick-ish) \"coding basic on x16\" + game + code walk-through:\n\n\n\n \n\n\n\n\n\n \n\n\n\n \n\n\n\n Have fun, and thanks for reading!\n\n\n\n\n\n Especially thanks to all who helped me with my questions, when creating this short (medium sized ;)) tutorial.\n\n\n\n\n\n Check out FALLSNAKE4.PRG for this latest version"
    },
    {
        "link": "https://retro-programming.com/how-to-program-joystick-input-handling-on-a-c64",
        "document": "It is important to know how to program Joystick Input Handling on a C64. How else should we know what the player does? Read on to learn how this works.\n\nThe Joystick at the C64 can be read at the Memory Addresses $DC01 for Port 1 and $DC00 for Port 2 of the Complex Interface Adapter (CIA). If the examined Bit is 0, then the switch is closed and the corresponding action is active. Otherwise the Bit is 1.\n\nThere is a mapping from Bits to Direction/Fire Action:\n\nLet us look at an example where we put this knowledge into action.\n\nThe Complex Interface Adapter (CIA) handles the two 9-pin game ports in the C64. So you have a maximum of two Joysticks by default. A C64 Joystick is more or less digital. The switches inside open and close in alignment to axis movements and button presses. As already described above, the Bit in the memory address will be 0 if the switch is closed, or 1 otherwise.\n\nThis example will focus on the Joystick Input. Therefore we will not put fancy graphics or animations on the screen.\n\nWe will map the four directions of the joystick to the numbers 1 (left), 2 (right), 3 (up) and 4 (down). If you push the Joystick in any direction the corresponding number will appear on the screen. The fire button will print the character F.\n\nLook at the Code and its explanation in order to understand how this works. We will discuss later where you can go from here.\n\nThis is a complete program for Joystick Input Handling on a C64 in Assembly Language.\n\nIf you assemble this program, start it and randomly press into the directions or the button on the joystick, you will get something like this:\n\nThe first lines are very similar to the ones I showed you in my C64 Machine Code Hello World Example. We set the start address of our program right after the beginning of the BASIC memory. Then we use SYS to call our Assembly code.\n\nAt the beginning we clear the screen. In order to do that we jump to the built-in subroutine that does what we want. It is stored at $E544.\n\nThe label input_left_check marks the beginning of our loop. Now we check every bit for if there is something to do. Initially we load a bit mask into the Register A. We have to check if the third Bit is 1 or 0, therefore we mask the third Bit with 1. In the next line we do a bitwise and with the content in Register A.\n\nIf the result is 0, the switch is closed which means that the player moves the joystick to the left. In this case we load the character ‘1’ into the A register (represented by Hex Code 31) and print it to the screen. This is done by the built in routine CHROUT which is located at memory address $FFD2.\n\nIf the result is not equal to zero, we jump to the label input_right_check where we will proceed checking directions.\n\nThe code for the checks of right, up and down are similar to the check left. The only things that change are the bitmask (according to the direction) and the character that will be printed to the screen.\n\nThe last check adds one little extra. After the fire button there is nothing left to check. If we do nothing the program will end and return to BASIC. Therefore we jump back to the first check, our input_left_check and start over. This makes for an endless loop.\n\nThe C64 Joystick has eight directions\n\nThe C64 Joystick can move up, down, left and right. But you can also move up and right at the same time. The same is true for up/left, down/right and down/left. This makes a total of eight directions that you can move to.\n\nWhat happens if we press right/down at the same time in our example program? The number ’24’ will print, because we show 2 (right) and 4 (down) at the same time.\n\nThe Complex Interface Adapter is an Interface Chip. It controls the I/O and the internal timer (clock) of the C64. Inside the C64 there are two identical CIAs. The different usage of the chips is specific to the C64.\n\nCIA1 has the Memory Address Area $DC00-$DCFF and controls Keyboard, Joystick, Paddles, Datasette and IRQ Control.\n\nCIA2 has the Memory Address Area $DD00-$DDFF and controls the Serial Bus, RS-232. VIC memory and NMI control.\n\nYou can see that we only need the CIA1 for our example.\n\nFirst of all you could make the program read inputs from a Joystick in Port 2. This should be easy enough and will help you to internalize the new knowledge. You could use the numbers 5,6,7 and 8 for the directions and trigger a space for the fire button of the Joystick #2.\n\nThe next step would be moving sprites instead of printing numbers. You would have to create a Sprite, put it in the Sprite Register and show it on the screen. Then you would have to manipulate the Sprite Position as reaction to the user input. After that you could trigger sprite animations.\n\nNow you know how to program joystick input handling on the C64. As you can see it is not that hard. You need to know which Bits to check in the correct CIA1 Memory Address. The you simply map the Inputs to Actions like showing numbers on the screen or moving a sprite. Just keep in mind that the two Joystick Ports have different Addresses in the CIA1 Memory."
    },
    {
        "link": "https://stackoverflow.com/questions/1750210/draw-on-screen-border-in-commodore-64",
        "document": "Firstly only sprites can be displayed in the border area or a repeating 8 bit pattern (8 pixels wide) which is read from the last byte of the video bank, usually $3fff. Note you can only see these sprites or 8 bit pattern when you trick the VIC chip into \"not displaying\" the borders. See below.\n\nThe borders have a higher priority than sprites, so normally when a sprite is drawn in a border area the border covers the sprite. With a bit of VIC chip trickery you can turn the borders off.\n\nYou can turn the top and bottom borders off quite easily (I'll explain below), and the side borders off with very critical timing.\n\nFirstly a little bit of info on how the VIC chip works on a c64.\n\nThe VIC chip draws the screen from the top left to the top right, then down a line, and from left to right again until the entire screen is drawn. It performs this redraw 50 times a second (for PAL units) or 60 times a second for (NTSC units).\n\nThere is an 8-bit VIC register that contains the vertical position of the raster at any given time. $d012. Actually there are more than 255 possible positions, so the 9th bit is stored in bit 7 (highest bit) or register $d011. So at any point you can read these registers and find out the vertical position of the raster. There is no available register to read the x position of the raster.\n\nAnother cool feature of the VIC chip was used to fix a problem when using hardware scrolling. Basic vertical scrolling was achieved by using a hardware register to move the screen 0-7 pixels vertically. Once you reached limit (0 or 7 depending on the direction of the scroll) you would move each character block (8x8 pixel) one block vertically and draw the new data to be displayed at the top (or bottom depending direction). This works very well, except that every 8 pixels of scrolling you would see data \"pop\" onto the screen. To remedy this, you could make the border area grow by 8 pixels vertically by clearing bit 3 in register $d011. This is called 24 row mode. By default the screen was set to 25 rows of 8x8 pixel characters. In 24 row mode, you could still draw characters to the bottom row, they would just be hidden by the border.\n\nSo the trick to turning off the top and bottom borders is to:\n\n2) wait for the raster to reach a vertical position between $f2 and $fa (the 8 pixels between where the border starts in both 24 row mode and 25 row mode).\n\n3) Set the screen to 24 row mode... moving the vertical start of the border above the current raster position\n\nStep 3) tricks the VIC chip into thinking that it has already started drawing the border, so it never starts drawing it. Voila, the top and bottom borders are open.\n\nRegarding side borders you can do the same thing with different registers, but as the horizontal movement of the raster is a lot quicker than the vertical movement, the timing needs to be much tighter. And there is another issue to take into account called jitter. <-which I won't explain here. Search the web for \"Stable Raster C64\" for an in depth explanation of that issue."
    },
    {
        "link": "https://retrogamecoders.com/commodore-basic-game-logic",
        "document": "Commodore BASIC series part 3: IF THEN and GET Commodore BASIC commands. Keyboard control and how to print at a certain location on screen\n\nFor your Commodore 64 BASIC game to be fun and challenging, it will need to have some “logic”.\n\nThere are two kinds of logic we will need to address:\n• The “rules” of your game – how the game works internally.\n• Display or “render” logic – how the game updates visually.\n\nFor our example Commodore BASIC programs, we will first update the Dungeons and Dragons Character Generator to make our character stats more fair, then we will look at a game of Rock, Paper, Scissors that will have a computer “player”. Finally we will start controlling a text-based player character with the keyboard and move it around the screen.\n\nWhen computer games first started appearing, they tended to be two player, such as Space War and Pong, or were games with very simple logic, such as puzzle games.\n\nWhy is that?\n\nIt’s because even now, producing a computer player that is as challenging as a human is tough, and it was especially tough on early computers with low processing power and scarce memory.\n\nFortunately, you don’t need actual AI to make a fun game.\n\nFor the most part, the game keeps track of where the player is, positioning the invaders that are still standing, if to show the UFO, and missile hits from and against the aliens.\n\nIf you hit an alien then your score is incremented, if an alien hits you then a life is lost until you are out of lives.\n\nPac-Man is an example of more complex-feeling game logic, still crammed into a very simple machine by today’s standards.\n\nYou can read all about how it works in this in-depth article.\n\nEssentially it was an early form of maze pathfinding.\n\nThe creator, Toru Iwatani, didn’t want the ghosts to be so aggressive and competent that the game was over-challenging. At the same time, it needed to have some challenge, otherwise people wouldn’t pump in coins to try and beat it.\n\nToday pathfinding has a whole science around it, read more about that here.\n\nGames from first-person shooters through to real time strategy games need to have the enemies and non-player characters avoid obstacles, go from point A to point B semi-directly, and not get stuck banging their pixelated heads against walls.\n\nNote our bad guys don’t need to learn, just appear to be semi-rational in their behavior.\n\nHow to Program Logic in Commodore BASIC\n\nJust talking about logic leads us to use the words and .\n\nIt is hardly surprising then then BASIC uses IF THEN as the commands for decision-making.\n\nWith this knowledge we can tweak our D&D Character Creator BASIC program from the previous lesson to make the stats more fair.\n\nin our original we used a roll of a D20 (20-sided dice). This could mean you get a value of 20 – yay! But also get a roll of 1 … ouch.\n\nAnother approach is to roll 4x D6, take the top-3 numbers, and combine them. While you can’t ever get 20 in that scenario, it does mean the very worst score you can get is a 3. Not stellar but not tragic either.\n\nAs we are doing this as a learning process, it gives me the opportunity to introduce a Sorting Algorithm called the “Bubble” Sort. Wayyy overkill for this use-case but worthwhile to understand.\n\nIn the Bubble Sort we go through our list of numbers and compare them.\n\nWe want the highest numbers to “bubble up”, so we compare using IF and when we find a higher number we switch them in our list (an array called D) then compare the next.\n\nHow to Print at a X,Y Location in Commodore BASIC – Displaying Text Anywhere You Want on Screen\n\nUnfortunately, Commodore 64 BASIC doesn’t have a Print at X,Y command, or an easy Cursor/Locate command to set the cursor at a specific place on screen.\n\nFortunately, we have several options to overcome this limitation. The easiest but least-desirable is to use the control characters we touched on previously.\n\nIf you are using drag and drop to upload a .BAS BASIC text file to my in-browser C64 emulator, or are using CBM Prg Studio, then you can enclose keywords in {brackets}. On an actual or emulated Commodore 64 then if you start with ” then cursor key presses will be converted to special characters. Entering the final ” will turn that mode off.\n\nAt run time those characters will be interpreted as movement commands for the cursor. With the cursor in place, anything you print will appear after it.\n\nOf course this is not as elegant as we like. We will cover alternative options as we get to them!\n\nGET reads input from the keyboard, but unlike INPUT, GET does not require you to press the Return/Enter key to send the information back.\n\nThis obviously comes in handy for keyboard control in games, but also “Press any key to continue” and for menus.\n\nLet’s combine this, along with the IF statement, and make a playable game of Rock, Paper, Scissors.\n\nThe user is asked to press 1, 2 or 3, after which the computer selects it’s move randomly, then the results are compared.\n\nTo make the screen more legible, we use our new-found cursor positioning powers.\n\nAfter the match, the player is asked if they want to play again.\n\nNote the ? is translated to PRINT. It is just a shorthand. We can safely initialize our random number generator using PRINT because the next line clears the screen anyway!\n\nOver this series, one of the game examples we will work on is a Dungeon Crawler game, where you explore a dungeon battling bad-guys and collecting keys and treasure.\n\nNow we can crudely position text on screen, and we can read the keyboard, we can start making our game.\n\nAn obvious flaw with our method is we can move anywhere we want without limitation, right over walls. Another problem is we leave a trail behind us.\n\nWe will fix these issues next time!"
    }
]