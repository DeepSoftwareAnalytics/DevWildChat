[
    {
        "link": "https://docs.oracle.com/cd/E19316-01/819-3669/bnakc/index.html",
        "document": "The JavaServer Pages Standard Tag Library (JSTL) encapsulates core functionality common to many JSP applications. Instead of mixing tags from numerous vendors in your JSP applications, JSTL allows you to employ a single, standard set of tags. This standardization allows you to deploy your applications on any JSP container supporting JSTL and makes it more likely that the implementation of the tags is optimized.\n\nJSTL has tags such as iterators and conditionals for handling flow control, tags for manipulating XML documents, internationalization tags, tags for accessing databases using SQL, and commonly used functions.\n\nThis chapter demonstrates JSTL through excerpts from the JSP version of the Duke’s Bookstore application discussed in the earlier chapters. It assumes that you are familiar with the material in the Using Custom Tags section of Chapter 5, JavaServer Pages Technology.\n\nThis chapter does not cover every JSTL tag, only the most commonly used ones. Please refer to the reference pages at for a complete list of the JSTL tags and their attributes.\n\nThis chapter illustrates JSTL using excerpts from the JSP version of the Duke’s Bookstore application discussed in Chapter 5, JavaServer Pages Technology. Here, they are rewritten to replace the JavaBeans component database access object with direct calls to the database using the JSTL SQL tags. For most applications, it is better to encapsulate calls to a database in a bean. JSTL includes SQL tags for situations where a new application is being prototyped and the overhead of creating a bean may not be warranted.\n\nThe source for the Duke’s Bookstore application is located in the directory created when you unzip the tutorial bundle (see Chapter 2, Using the Tutorial Examples).\n\nTo deploy and run the application using NetBeans IDE, follow these steps:\n• Perform all the operations described in Accessing Databases from Web Applications.\n• In the Open Project dialog, navigate to:\n• Select the Open as Main Project check box and the Open Required Projects check box.\n• In the Projects tab, right-click the project, and select Undeploy and Deploy.\n• To run the application, open the bookstore URL .\n\nTo deploy and run the application using Ant, follow these steps:\n• In a terminal window, go to .\n• Type . This command will spawn any necessary compilations, copy files to the directory, and create a WAR file and copy it to the directory.\n• Perform all the operations described in Creating a Data Source in the Application Server.\n• To deploy the example, type . The target outputs a URL for running the application. Ignore this URL, and instead use the one shown in the next step.\n• To run the application, open the bookstore URL .\n\nTo learn how to configure the example, refer to the file, which includes the following configurations:\n• A element that specifies the name that tools use to identify the application.\n• A element that specifies the JSTL resource bundle base name.\n• A set of elements that identify the application’s JSP files.\n• A set of elements that define the aliases to the JSP files.\n• Nested inside a element are two elements, which define the preludes and coda to be included in each page. See Setting JavaBeans Component Properties for more information.\n\nSee Troubleshooting Duke's Bookstore Database Problems for help with diagnosing common problems.\n\nJSTL includes a wide variety of tags that fit into discrete functional areas. To reflect this, as well as to give each area its own namespace, JSTL is exposed as multiple tag libraries. The URIs for the libraries are as follows:\n\nTable 7–1 summarizes these functional areas along with the prefixes used in this tutorial.\n\nThus, the tutorial references the JSTL core tags in JSP pages by using the following directive:\n\nIn addition to declaring the tag libraries, tutorial examples access the JSTL API and implementation. In the Application Server, the JSTL TLDs and libraries are distributed in the archive . This library is automatically loaded into the classpath of all web applications running on the Application Server, so you don’t need to add it to your web application.\n\nTags usually collaborate with their environment in implicit and explicit ways. Implicit collaboration is done by means of a well-defined interface that allows nested tags to work seamlessly with the ancestor tag that exposes that interface. The JSTL conditional tags employ this mode of collaboration.\n\nExplicit collaboration happens when a tag exposes information to its environment. JSTL tags expose information as JSP EL variables; the convention followed by JSTL is to use the name for any tag attribute that exports information about the tag. For example, the tag exposes the current item of the shopping cart it is iterating over in the following way:\n\nIn situations where a tag exposes more than one piece of information, the name is used for the primary piece of information being exported, and an appropriate name is selected for any other secondary piece of information exposed. For example, iteration status information is exported by the tag through the attribute .\n\nWhen you want to use an EL variable exposed by a JSTL tag in an expression in the page’s scripting language (see Chapter 9, Scripting in JSP Pages), you use the standard JSP element to declare a scripting variable.\n\nFor example, removes a book from a shopping cart using a scriptlet. The ID of the book to be removed is passed as a request parameter. The value of the request parameter is first exposed as an EL variable (to be used later by the JSTL tag) and then is declared as a scripting variable and passed to the method:\n\nTable 7–2 summarizes the core tags, which include those related to variables and flow control, as well as a generic way to access URL-based resources whose content can then be included or processed within the JSP page.\n\nThe tag sets the value of an EL variable or the property of an EL variable in any of the JSP scopes (page, request, session, or application). If the variable does not already exist, it is created.\n\nThe JSP EL variable or property can be set either from the attribute :\n\nor from the body of the tag:\n\nFor example, the following sets an EL variable named with the value of the request parameter named :\n\nTo remove an EL variable, you use the tag. When the bookstore JSP page is invoked, the shopping session is finished, so the session attribute is removed as follows:\n\nThe attribute of the tag can also take a deferred value expression (See Immediate and Deferred Evaluation Syntax) so that JavaServer Faces component tags can access the value at the appropriate stage of the page life cycle.\n\nJavaServer Faces technology (see Chapter 10, JavaServer Faces Technology) supports a multiphase life cycle, which includes separate phases for rendering components, validating data, updating model values, and performing other tasks. What this means is that any JavaServer Faces component tags that reference the value set by the tag must have access to this value at different phases of the life cycle, not just during the rendering phase. Consider the following code:\n\nThe attribute of the tag uses a deferred value expression, which means that the variable it references is available not only during the rendering phase of the JavaServer Faces life cycle but also during the later stages of the life cycle. Therefore, whatever value the user enters into the component tag is updated to the external data object during the appropriate stage of the life cycle.\n\nIf the expression referenced by the attribute used immediate evaluation syntax then the variable would be available only when the component is rendered during the render response phase. This would prevent the value the user enters into the component from being converted, validated, or updated to the external data object during the later phases of the life cycle.\n\nTo execute flow control logic, a page author must generally resort to using scriptlets. For example, the following scriptlet is used to iterate through a shopping cart:\n\nFlow control tags eliminate the need for scriptlets. The next two sections have examples that demonstrate the conditional and iterator tags.\n\nThe tag allows the conditional execution of its body according to the value of the attribute. The following example from tests whether the request parameter is empty. If the test evaluates to , the page queries the database for the book record identified by the request parameter and adds the book to the shopping cart:\n\nThe tag performs conditional block execution by the embedded subtags. It renders the body of the first tag whose test condition evaluates to . If none of the test conditions of nested tags evaluates to , then the body of an tag is evaluated, if present.\n\nFor example, the following sample code shows how to render text based on a customer’s membership category.\n\nThe , , and tags can be used to construct an - - statement as follows:\n\nThe tag allows you to iterate over a collection of objects. You specify the collection using the attribute, and the current item is available through a variable named by the attribute.\n\nA large number of collection types are supported by , including all implementations of and . If the attribute is of type , then the current item will be of type , which has the following properties:\n• : The key under which the item is stored in the underlying\n• : The value that corresponds to the key\n\nArrays of objects as well as arrays of primitive types (for example, ) are also supported. For arrays of primitive types, the current item for the iteration is automatically wrapped with its standard wrapper class (for example, for , for , and so on).\n\nImplementations of and are supported, but they must be used with caution. and objects can't be reset, so they should not be used within more than one iteration tag. Finally, objects can be iterated over if the string contains a list of comma-separated values (for example: ).\n\nHere’s the shopping cart iteration from the preceding section, now with the tag:\n\nThe tag is used to iterate over a collection of tokens separated by a delimiter.\n\nSimilarly to the value attribute of the tag (see Variable Support Tags), the attribute of and can also take a deferred value expression so that JavaServer Faces tags can be included within these tags.\n\nAs described in Variable Support Tags, JavaServer Faces technology (see Chapter 10, JavaServer Faces Technology) supports a multiphase life cycle. Therefore, any JavaServer Faces component tags that are included in the tag or the tag must have access to the variable referenced by the attribute at different phases of the life cycle, not just during the rendering phase. Consider the following code:\n\nThe attribute uses a deferred value expression, which means that the variable it references is available not only during the rendering phase of the JavaServer Faces life cycle but also during the later stages of the life cycle. Therefore, whatever values the user enters into the component tags are updated to the external data object during the appropriate stage of the life cycle.\n\nIf the expression referenced by the attribute used immediate evaluation syntax then the variable would be available only when the component is rendered during the render response phase. This would prevent the values the user enters into the components from being converted, validated, or updated to the external data object during the later phases of the life cycle. The JavaServer Faces version of Duke’s Bookstore includes a tag on its page.\n\nThe element provides for the inclusion of static and dynamic resources in the same context as the current page. However, cannot access resources that reside outside the web application, and it causes unnecessary buffering when the resource included is used by another element.\n\nIn the following example, the element uses the content of the included resource as the input of its transformation. The element reads the content of the response and writes it to the body content of the enclosing transform element, which then rereads exactly the same content. It would be more efficient if the element could access the input source directly and thereby avoid the buffering involved in the body content of the transform tag.\n\nThe tag is therefore the simple, generic way to access URL-based resources, whose content can then be included and or processed within the JSP page. For example, in XML Tag Library, is used to read in the XML document containing book information and assign the content to the scoped variable :\n\nThe tag, analogous to the tag (see Element), can be used with to specify request parameters.\n\nSession Tracking discusses how an application must rewrite URLs to enable session tracking whenever the client turns off cookies. You can use the tag to rewrite URLs returned from a JSP page. The tag includes the session ID in the URL only if cookies are disabled; otherwise, it returns the URL unchanged. Note that this feature requires that the URL be relative. The tag takes subtags to include parameters in the returned URL. For example, rewrites the URL used to add a book to the shopping cart as follows:\n\nThe tag sends an HTTP redirect to the client. The tag takes subtags for including parameters in the returned URL.\n\nThe tag provides a complement to the JSP error page mechanism. It allows page authors to recover gracefully from error conditions that they can control. Actions that are of central importance to a page should not be encapsulated in a ; in this way their exceptions will propagate instead to an error page. Actions with secondary importance to the page should be wrapped in a so that they never cause the error page mechanism to be invoked.\n\nThe exception thrown is stored in the variable identified by , which always has page scope. If no exception occurred, the scoped variable identified by is removed if it existed. If is missing, the exception is simply caught and not saved.\n\nThe tag evaluates an expression and outputs the result of the evaluation to the current object. The syntax and attributes are as follows:\n\nIf the result of the evaluation is a object, then data is first read from the object and then written into the current object. The special processing associated with objects improves performance when a large amount of data must be read and then written to the response.\n\nIf is true, the character conversions listed in Table 7–3 are applied.\n\nThe JSTL XML tag set is listed in Table 7–4.\n\nA key aspect of dealing with XML documents is to be able to easily access their content. XPath (see ), a W3C recommendation since 1999, provides an easy notation for specifying and selecting parts of an XML document. In the JSTL XML tags, XPath expressions specified using the attribute are used to select portions of XML data streams. Note that XPath is used as a local expression language only for the attribute. This means that values specified for attributes are evaluated using the XPath expression language but that values for all other attributes are evaluated using the rules associated with the JSP 2.0 expression language.\n\nIn addition to the standard XPath syntax, the JSTL XPath engine supports the following scopes to access web application data within an XPath expression:\n\nThese scopes are defined in exactly the same way as their counterparts in the JSP expression language discussed in Implicit Objects. Table 7–5 shows some examples of using the scopes.\n\nThe XML tags are illustrated in another version ( ) of the Duke’s Bookstore application. This version replaces the database with an XML representation of the bookstore database, which is retrieved from another web application. The directions for building and deploying this version of the application are in The Example JSP Document.\n\nThe core XML tags provide basic functionality to easily parse and access XML data.\n\nThe tag parses an XML document and saves the resulting object in the EL variable specified by attribute . In , the XML document is parsed and saved to a context attribute in , which is included by all JSP pages that need access to the document:\n\nThe and tags parallel the behavior described in Variable Support Tags and Miscellaneous Tags for the XPath local expression language. The tag evaluates an XPath expression and sets the result into a JSP EL variable specified by attribute . The tag evaluates an XPath expression on the current context node and outputs the result of the evaluation to the current object.\n\nThe JSP page selects a book element whose attribute matches the request parameter and sets the attribute. The tag then selects the book’s element and outputs the result.\n\nAs you have just seen, stores an internal XML representation of a node retrieved using an XPath expression; it doesn’t convert the selected node into a and store it. Thus, is primarily useful for storing parts of documents for later retrieval.\n\nIf you want to store a , you must use within . The tag converts the node to a , and then stores the as an EL variable. For example, stores an EL variable containing a book price, which is later provided as the value of a tag, as follows:\n\nThe other option, which is more direct but requires that the user have more knowledge of XPath, is to coerce the node to a manually by using XPath’s function.\n\nThe XML flow control tags parallel the behavior described in Flow Control Tags for XML data streams.\n\nThe JSP page uses the tag to display all the books contained in as follows:\n\nThe tag applies a transformation, specified by an XSLT stylesheet set by the attribute , to an XML document, specified by the attribute . If the attribute is not specified, the input XML document is read from the tag’s body content.\n\nThe subtag can be used along with to set transformation parameters. The attributes and are used to specify the parameter. The attribute is optional. If it is not specified, the value is retrieved from the tag’s body.\n\nChapter 15, Internationalizing and Localizing Web Applications covers how to design web applications so that they conform to the language and formatting conventions of client locales. This section describes tags that support the internationalization of JSP pages.\n\nJSTL defines tags for setting the locale for a page, creating locale-sensitive messages, and formatting and parsing data elements such as numbers, currencies, dates, and times in a locale-sensitive or customized manner. Table 7–6 lists the tags.\n\nJSTL I18N tags use a localization context to localize their data. A localization context contains a locale and a resource bundle instance. To specify the localization context at deployment time, you define the context parameter , whose value can be a or a . A context parameter is interpreted as a resource bundle base name. For the Duke’s Bookstore application, the context parameter is the . When a request is received, JSTL automatically sets the locale based on the value retrieved from the request header and chooses the correct resource bundle using the base name specified in the context parameter.\n\nThe tag is used to override the client-specified locale for a page. The tag is used to set the request’s character encoding, in order to be able to correctly decode request parameter values whose encoding is different from .\n\nBy default, the capability to sense the browser locale setting is enabled in JSTL. This means that the client determines (through its browser setting) which locale to use, and allows page authors to cater to the language preferences of their clients.\n\nYou can set the resource bundle at runtime with the JSTL and tags. is used to set the localization context in a variable or configuration variable for a specified scope. is used to set the resource bundle for a given tag body.\n\nThe tag is used to output localized strings. The following tag from is used to output a string inviting customers to choose a book from the catalog.\n\nThe subtag provides a single argument (for parametric replacement) to the compound message or pattern in its parent tag. One tag must be specified for each variable in the compound message or pattern. Parametric replacement takes place in the order of the tags.\n\nJSTL provides a set of tags for parsing and formatting locale-sensitive numbers and dates.\n\nThe tag is used to output localized numbers. The following tag from is used to display a localized price for a book.\n\nNote that because the price is maintained in the database in dollars, the localization is somewhat simplistic, because the tag is unaware of exchange rates. The tag formats currencies but does not convert them.\n\nAnalogous tags for formatting dates ( ) and for parsing numbers and dates ( , ) are also available. The tag establishes the time zone (specified with the attribute) to be used by any nested tags.\n\nIn , a “pretend” ship date is created and then formatted with the tag:\n\nThe JSTL SQL tags for accessing databases listed in Table 7–7 are designed for quick prototyping and simple applications. For production applications, database operations are normally encapsulated in JavaBeans components.\n\nThe tag allows you to set data source information for the database. You can provide a JNDI name or parameters to set the data source information. All of the Duke’s Bookstore pages that have more than one SQL tag use the following statement to set the data source:\n\nThe tag performs an SQL query that returns a result set. For parameterized SQL queries, you use a nested tag inside the tag.\n\nIn , the value of the request parameter determines which book information should be retrieved from the database. This parameter is saved as the attribute name and is passed to the tag.\n\nThe tag is used to update a database row. The tag is used to perform a series of SQL statements atomically.\n\nThe JSP page uses both tags to update the database inventory for each purchase. Because a shopping cart can contain more than one book, the tag is used to wrap multiple queries and updates. First, the page establishes that there is sufficient inventory; then the updates are performed.\n\nThe interface is used to retrieve information from objects returned from a tag.\n\nFor complete information about this interface, see the API documentation for the JSTL packages.\n\nThe attribute set by a tag is of type . The method returns an array of maps that can be supplied to the attribute of a tag. The JSTL expression language converts the syntax to a call to . The expression in the following example returns an array of maps.\n\nWhen you provide an array of maps to the tag, the attribute set by the tag is of type . To retrieve information from a row, use the method to get a column value. The JSP expression language converts the syntax to a call to . For example, the expression returns the value of the title entry of a book map.\n\nThe Duke’s Bookstore page retrieves the column values from the map as follows.\n\nThe following excerpt from uses the interface to retrieve values from the columns of a book row using scripting language expressions. First, the book row that matches a request parameter ( ) is retrieved from the database. Because the and objects are later used by tags that use scripting language expressions to set attribute values and by a scriptlet that adds a book to the shopping cart, both objects are declared as scripting variables using the tag. The page creates a bean that describes the book, and scripting language expressions are used to set the book properties from book row column values. Then the book is added to the shopping cart.\n\nYou might want to compare this version of to the versions in Chapter 5, JavaServer Pages Technology and Chapter 8, Custom Tags in JSP Pages that use a book database JavaBeans component.\n\nAlthough the interface defines a method, it does not conform to the JavaBeans component design pattern for properties and so cannot be accessed by using the JSP expression language. The function can be applied to any collection supported by the and returns the length of the collection. When applied to a , it returns the number of characters in the string.\n\nFor example, the page of the application introduced in Chapter 3, Getting Started with Web Applications uses the function and the tag to determine whether to include a response page:\n\nThe rest of the JSTL functions are concerned with string manipulation:\n• , : Changes the capitalization of a string\n• , , , , : Checks whether a string contains another string\n\nFor more information on JSTL, see:"
    },
    {
        "link": "https://tutorialspoint.com/jsp/jsp_standard_tag_library.htm",
        "document": "In this chapter, we will understand the different tags in JSP. The JavaServer Pages Standard Tag Library (JSTL) is a collection of useful JSP tags which encapsulates the core functionality common to many JSP applications.\n\nJSTL has support for common, structural tasks such as iteration and conditionals, tags for manipulating XML documents, internationalization tags, and SQL tags. It also provides a framework for integrating the existing custom tags with the JSTL tags.\n\nTo begin working with JSP tages you need to first install the JSTL library. If you are using the Apache Tomcat container, then follow these two steps −\n\nStep 1 − Download the binary distribution from Apache Standard Taglib and unpack the compressed file.\n\nStep 2 − To use the Standard Taglib from its Jakarta Taglibs distribution, simply copy the JAR files in the distribution's 'lib' directory to your application's webapps\\ROOT\\WEB-INF\\lib directory.\n\nTo use any of the libraries, you must include a <taglib> directive at the top of each JSP that uses the library.\n\nThe JSTL tags can be classified, according to their functions, into the following JSTL tag library groups that can be used when creating a JSP page −\n\nThe core group of tags are the most commonly used JSTL tags. Following is the syntax to include the JSTL Core library in your JSP −\n\nFollowing table lists out the core JSTL Tags −\n\n<c:out> Like <%= ... >, but for expressions. <c:set > Sets the result of an expression evaluation in a 'scope' <c:remove > Removes a scoped variable (from a particular scope, if specified). <c:catch> Catches any Throwable that occurs in its body and optionally exposes it. <c:if> Simple conditional tag which evalutes its body if the supplied condition is true. <c:choose> Simple conditional tag that establishes a context for mutually exclusive conditional operations, marked by <when> and <otherwise>. <c:when> Subtag of <choose> that includes its body if its condition evalutes to 'true'. <c:otherwise > Subtag of <choose> that follows the <when> tags and runs only if all of the prior conditions evaluated to 'false'. <c:import> Retrieves an absolute or relative URL and exposes its contents to either the page, a String in 'var', or a Reader in 'varReader'. <c:forEach > The basic iteration tag, accepting many different collection types and supporting subsetting and other functionality . <c:forTokens> Iterates over tokens, separated by the supplied delimeters.\n\nThe JSTL formatting tags are used to format and display text, the date, the time, and numbers for internationalized Websites. Following is the syntax to include Formatting library in your JSP −\n\nFollowing table lists out the Formatting JSTL Tags −\n\nThe JSTL SQL tag library provides tags for interacting with relational databases (RDBMSs) such as Oracle, mySQL, or Microsoft SQL Server.\n\nFollowing is the syntax to include JSTL SQL library in your JSP −\n\nFollowing table lists out the SQL JSTL Tags −\n\nThe JSTL XML tags provide a JSP-centric way of creating and manipulating the XML documents. Following is the syntax to include the JSTL XML library in your JSP.\n\nThe JSTL XML tag library has custom tags for interacting with the XML data. This includes parsing the XML, transforming the XML data, and the flow control based on the XPath expressions.\n\nBefore you proceed with the examples, you will need to copy the following two XML and XPath related libraries into your <Tomcat Installation Directory>\\lib −\n\nFollowing is the list of XML JSTL Tags −\n\n<x:out> Like <%= ... >, but for XPath expressions. <x:parse> Used to parse the XML data specified either via an attribute or in the tag body. <x:set > Sets a variable to the value of an XPath expression. <x:if > Evaluates a test XPath expression and if it is true, it processes its body. If the test condition is false, the body is ignored. <x:forEach> To loop over nodes in an XML document. <x:choose> Simple conditional tag that establishes a context for mutually exclusive conditional operations, marked by <when> and <otherwise> tags. <x:when > Subtag of <choose> that includes its body if its expression evalutes to 'true'. <x:otherwise > Subtag of <choose> that follows the <when> tags and runs only if all of the prior conditions evaluates to 'false'. <x:param > Used along with the transform tag to set a parameter in the XSLT stylesheet\n\nJSTL includes a number of standard functions, most of which are common string manipulation functions. Following is the syntax to include JSTL Functions library in your JSP −\n\nFollowing table lists out the various JSTL Functions −\n\nfn:contains() Tests if an input string contains the specified substring. fn:containsIgnoreCase() Tests if an input string contains the specified substring in a case insensitive way. fn:endsWith() Tests if an input string ends with the specified suffix. fn:escapeXml() Escapes characters that can be interpreted as XML markup. fn:indexOf() Returns the index withing a string of the first occurrence of a specified substring. fn:join() Joins all elements of an array into a string. fn:length() Returns the number of items in a collection, or the number of characters in a string. fn:replace() Returns a string resulting from replacing in an input string all occurrences with a given string. fn:split() Splits a string into an array of substrings. fn:startsWith() Tests if an input string starts with the specified prefix. fn:toLowerCase() Converts all of the characters of a string to lower case. fn:toUpperCase() Converts all of the characters of a string to upper case. fn:trim() Removes white spaces from both ends of a string."
    },
    {
        "link": "https://docs.oracle.com/javaee/5/jstl/1.1/docs/tlddocs/c/tld-summary.html",
        "document": ""
    },
    {
        "link": "https://codejava.net/java-ee/jstl/jstl-core-tag-foreach",
        "document": "This post helps you understand and use the <c:forEach> tag in the JSTL core tags library.\n\nYou know, <c:forEach> is the looping construct in the JSTL. We use <c:forEach> to iterate over a collection of objects and display their values. The objects can be POJOs or plain data type values.\n\nThe following JSP example iterates over the choices user selected and displays them.\n\nIn the above example, we have few checkboxes to represent different programming choices. Upon user selection of these choices, we are iterating over the items user selected and displaying them using <c:forEach> tag.\n\nIn the above example we are displaying countries. Since it’s a simple type (String in this case) we can simply display its value. To display values from a list of POJOs, we iterate through the list and access each object’s property in order to display its value. The following example demonstrates this:\n\nIn the above example, we iterate over collection of student objects and displayed student properties. The attribute ‘var’ holds each object from the current iteration. Every time the variable defined in ‘var’ attribute will have a new object throughout the iteration.\n\nIn the some cases, we need to start iteration at a specified index or we may need to stop iterative at certain point. Also, we may need to iterate every alternate item in the collection. To deal with this kind of special cases <c:forEach> has additional attributes:\n\nIteration begins at the specified index. First item has an index of 0.\n\nThe above example displays school names from index 4 that means, from item 5 since index begins at 0.\n\nIteration ends at the specified index. The index is inclusive.\n\nThe above example displays school names from index 4 that means, from item 5 since index begins at 0 until index 8. If the collection contains items more than 8, rest of the items will be ignored displaying only until index 8.\n\nTo iterate over step items in the collection stating with the first item.\n\nAbove example displays every alternate school in the collection (i.e., 1,3,5,7 and so on).\n\nvarStatus attribute essentially holds loop status object. We can do number of things with this attribute. One example is, if we want to do special things for last item in the collection we can use varStatus to access last item as shown in the below example:\n\nIn the above example we are displaying school names with horizontal line for each school name. We avoided horizontal line for the last school name instead we had given a line break for the last item.\n\nThe variable given in the varStatus attribute is of type javax.servlet.jsp.jstl.core.LoopTagStatus.\n\nThe selected choices are displaying using <c:forEach> tag.\n\nThe <c:forEach> tag is useful to iterate over collections and to display their values. We can use attributes like begin, end, and step to perform iterations which start at a particular index or end at particular index or to step over items respectively. Using varStatus attribute which holds loop status, we can perform loop operations like checking whether the current iteration is the last iteration etc."
    },
    {
        "link": "https://objectcomputing.com/resources/publications/sett/september-2002-script-free-javaserver-pages-with-the-standard-tag-library-jstl",
        "document": "For some time now web application developers have utilized Sun's Java Servlet APIs for processing HTTP query and submission requests from client browsers, and generating dynamic HTML (or XHTML) content as a response. Put plainly, Servlets are services, implemented in the Java programming language, that run inside a J2EE-compliant \"container,\" typically a web or application server. A container hosts Servlets by handling the low level details of the HTTP protocol, managing the Servlet service lifecycle, and executing Java code written by developers to handle the HTTP request/response cycle associated with user requests. Furthermore, the Servlet API provides developers with high-level Java interfaces that expose lower level aspects of the HTTP protocol and service requests in a more object-oriented manner. This includes accessing the values of user query and form parameters; other information about client and HTTP requests; and facilities for managing HTTP forwards, HTTP redirects, and user state; among other things.\n\nAn example of a simple Servlet follows:\n\nSeveral observations can be made about this example. One, Servlets are easy to write. The HttpServlet, HttpServletRequest, and HttpServletResponse objects provide access to most of what a developer needs to create simple Servlets like this, as well as ones considerably more complex, like a web-based shopping cart, for example. The example above doesn't reveal the rich set of features the Servlet API provides, but one only needs to examine the API documentation briefly to understand that Servlets can be quite sophisticated.\n\nThe second point to note illustrates a relative shortcoming of Servlets. The HTML for the response sent back to the HTTP client is embedded as a series of strings emitted in print statements to an IO stream. This is problematic for a couple of reasons. Responsibility for creating HTML lies in the hands of the Servlet developer, meaning greater expense in terms of training and engineering costs. Furthermore, web site maintenance becomes more difficult since changes to the content and/or appearance of the web site requires changes to the Java code and all those print statements, which get quite ugly with any but the simplest Servlets. Early solutions to this problem include delegating production of HTML fragments to dedicated Java objects, but fail to address another concern.\n\nGenerally, content authors working within a more limited context of HTML, JavaScript, CSS, and related technologies are less costly to utilize than server-side engineers working in Java. The approach illustrated above virtually eliminates using content authors for anything but prototyping. To involve them in creation of production code requires additional training and expense. Solving this problem requires an approach inspired by classical Model-View-Controller (MVC) architecture, an object-oriented framework pattern that separates data (the Model), presentation (the View), and application logic (the Controller) in a loosely-coupled design with well-defined interfaces.\n\nOne solution that utilizes MVC involves eXtensible Markup Language (XML) and eXtensible Stylesheet Language Transformation (XSLT). This approach has Servlet logic that creates an XML representation of the dynamic content (data) intended for presentation, and uses an XSLT stylesheet to transform the XML data into HTML sent as a response to the HTTP client. The presentation logic moves from the Servlet code to the XSLT stylesheet, which implements a series of production rules for embedding the data into HTML and emitting the result HTML document the client sees.\n\nThe details of XML/XSLT are beyond the scope of this article, but a Servlet using this approach, along with the Java API for XML Processing (JAXP), might look something like this:\n\nClearly this is a improvement since no HTML is embedded in the Servlet code. If changes need to be made to the resulting HTML or how the dynamic content is handled, that requires nothing more than editing the XSLT stylesheet residing in the web application directory on the server. The servlet itself does not need to be changed, nor recompiled and redeployed. The Servlet developers focus on production of application and data logic, leaving content authors to maintain the presentation logic separately. However, this approach also requires XML/XSLT expertise on the part of the content authors, and XSLT (along with XPath that it depends on) has a steeper learning curve than HTML and associated technologies that content authors use traditionally. Nevertheless, it's one that works quite well and sees wider use all the time.\n\nThere is an alternative solution that is adopted widely. JavaServer Pages (JSP), a technology that parallels Java Servlets, addresses another approach to the problem of embedding HTML content into application code implemented in Java. Using JSP, content authors develop regular HTML documents, but add JSP scripting elements and tags for specifying the dynamic aspects of the content. Unlike JavaScript, JSP pages are processed on the server (rather than in the client browser), and in fact are translated into Servlets by the JSP container. This implies that JSP containers are also Servlet containers, which is indeed the case. It also means that JSP pages have access to the same information the Servlet API provides to Servlets. JSP pages can also collaborate with JavaBeans (Java classes with interfaces conforming to well-defined conventions) residing on the server.\n\nA typical JSP page might look something like the following. It creates a web page for looking up an employee's information and displaying phone numbers in a table.\n\nThis example illustrates how easy it is to access Java objects conforming to the JavaBeans conventions without direct knowledge of the Java programming language. Unfortunately, the and associated JSP tags don't support indexed bean properties nor other Java collections. Iteration and branching logic, as well as other common tasks such as date and number formatting, require using JSP expressions and scriptlets implemented with Java code. The example gets even more complicated if one changes it to check whether the map of phone numbers is non-empty before outputting the HTML table at all. This typically involves using a scriptlet with conditional logic where the HTML table tags are emitted as Java print statements within the scriptlet. It doesn't take a long stretch of imagination to realize this approach to separating presentation and application logic has shortcomings. Where the early Servlets suffered from HTML print statements embedded in Java code, JSPs evolve easily into the opposite and equally undesirable problem of embedding too much Java code in HTML.\n\nBut the facilities in JSP for authoring dynamic web pages don't end here. Using APIs in the JSP specification for creating custom actions, one can delegate branching, iteration, and other Java scriptlet code to dedicated Java classes separate from the JSP page, and define JSP tag interfaces to that code. A JSP page can then call the Java code indirectly by using the custom JSP tag element, rather than defining the code directly. Entire custom tag libraries can be created to remove Java code from JSP pages. With custom tags, authoring presentation content can be put back in the hands of non-programmer content authors.\n\nThe previous example implemented with custom tags might look something like this:\n\nThe tag calls Java code that translates the map of phone numbers for the given employee into a HTML table that is inserted into the output of the JSP. Custom tags can come in many forms - with or without attributes, body content, and so on - and perform any tasks one might expect regular Servlet code to handle. The above tag might be implemented differently, where it only performs iteration over the map key/value pairs and HTML for the table remains in the JSP code. So instead of the tag, one might create something more reusable, a tag for iterating over key/value pairs of any map:\n\nIn either case, most of the pure Java code is removed from the JSP, which is desirable. It's why custom tag libraries are very popular and in widespread use. However, a few problems remain. Many types of actions perform very common and useful tasks, such as the map entry iterator above. However, since they are implemented as custom tags, they vary in specifics and syntax from project to project, enterprise to enterprise, and so on. Furthermore, as one sees from the example, a Java expression is still used to supply the attribute value in the tag. There's a lack of standardization for common and useful tasks, and some dependence on use of Java code for expressions is still necessary. Until now that is.\n\nSome time ago the developer community recognized this lack of standardization and other problems reaching the goal of code-free JSP pages, so an expert group in the Java Community Process (JCP) was formed to address this as the Java Specification Request (JSR) 52 for the JavaServer Pages Standard Tag Library (JSTL). The result of this is the first Specification and Reference Implementation of JSTL 1.0, released in the summer of 2002. JSTL includes a set of four standard JSP tag libraries for performing general purpose tasks, URL-related tasks, relational database access, XML processing, and internationalization & formatting. It also introduces Expression Language (EL) - for specifying tag attributes values - that is higher level and simpler than the Java programming language.\n\nDrawing from the above examples, a JSP using JSTL looks like this:\n\nThis JSP example is entirely free of Java language scripting elements, and somewhat more sophisticated than the previous ones. It performs the map iteration using the JSTL tag, but also tests that the map of phone numbers is non-empty using the JSTL tag. A JSTL tag for \"if-else\" type conditional testing exists, but this example uses the two \"if\" tests to show one example that takes advantage of JSTL support for JavaBean conventions and another utilizing the EL operator. As with many other languages, there's more than one way to do things with JSTL.\n\nJSTL's Expression Language (EL) has a simple syntax inspired by ECMAScript and XPath. For now EL can only be used in tag attribute values, but the expert groups for the next specifications of JSP and JSTL are defining support for using EL in tag bodies and other template text as well (this will appear in the JSP 2.0 specification). EL is easy to use, hides the details of the page language (Java), and custom tags can be implemented to support it. Expressions may include static text and/or multiple expressions combined in attribute values to form larger expressions, and may include the use of EL operators for boolean expressions. For example:\n\nEL supports JavaBeans conventions for accessing object properties, like used to retrieve the nested \"zip\" property from the employee object. It also provides a rich set of operators including the dot (.) operator used to access bean properties; the subscript ([]) operator to access array and collection indices and for map key lookups; relational, arithmetic, and logical operators similar to those found in most modern programming languages; and the operator seen in the example.\n\nThe real goal for EL is to provide a way to create JSPs using custom and/or standard tags that are entirely free of Java language declarations, expressions, and scriptlets.\n\nThe other major component of JSTL comprises the four tag libraries mentioned above. For the most part, the authors designed them to provide a standard means for implementing common and useful tasks that have been the subject of many different custom tag implementations.\n\nThe tag library identified by the URI , consists of tags for four categories of core actions. These include:\n• General Purpose Actions:\n• < > - sets value of JSP scoped variables from EL expressions\n• Conditional Actions:\n• < >, < >, < > - for mutually exclusive tests, used to implement \"if-else\" and switch-like branching\n• Iterator Actions:\n• < > - iterates over items in an array, a comma-delimited string, Collection, or Map; or for looping through a specified count\n• URL Actions:\n• < > - encodes URL parameter names and values, used as a nested action of , , and\n\nMany of the core tags listed here can be seen used in the example given earlier, as well as those that follow.\n\nIn general accessing relational databases using in a web application should be delegated to a separate data tier, but sometimes it can be useful to perform database lookups directly from a JSP. Typical scenarios include web application prototyping, or developing small web applications that are fairly simple, have small user communities, and low security requirements. To facilitate developing JSPs with direct database access using SQL, the JSTL includes a tag library of database actions, identified by the tag URI . This tag library includes actions for creating connections to back-end databases, executing database queries, executing database updates, and performing multiple database operations inside transactions.\n\nThe following JSP fragment demonstrates how to create a HTML table with data from a SQL database query:\n\nThe query tag provides access to a JSTL-defined object (i.e. in the example) that maps column database names to values, which is simpler than using JDBC objects.\n\nWith increasing globalization of the economy, internationalizing web applications becomes increasingly important. While Java provides full support for internationalization, utilizing this support has been difficult with JSP. And even where internationalization isn't needed, most non-trivial web applications must deal with formatting date and number values correctly for presentation. The JSTL tag library for formatting provides facilities to handle these problems more easily with actions based on Java's resource bundle mechanism for localizing text messages, and numerous tags for parsing and formatting dates and numbers, among other things. Formatting a Java Date object with a particular pattern becomes a trivial task with the action:\n\nThe tag library for XML processing and transformation provides one of the most interesting and useful aspects of JSTL beyond the core tag library. Some of these actions are counterparts to the core tags, but they access XML data using XPath expressions and functions in tag attributes, instead of EL. This library, identified by the tag URI http://java.sun.com/jstl/xml, includes three categories of XML actions.\n• Core XML support.\n• - sets value of JSP scoped variables from XPath expressions\n• XML flow control tags corresponding to the core conditional and iteration tags, with usage similar to that found in their XSLT counterparts.\n• XSLT stylesheet transformations of XML data.\n• - applies an XSLT stylesheet to an XML document\n\nThe following example demonstrates using a combination of JSP with JSTL and XML with XSLT to produce HTML output from a web application.\n\nThe data to be presented is represented by this XML document:\n\nAn XSLT stylesheet generates a HTML table for displaying the XML data. It also takes a parameter that specifies a number formatting pattern.\n\nThe JSP generates the actual HTML web page. It might also include a header and/or footer, some boilerplate content, CSS links, and other static and dynamic content such as summary data, but it delegates presentation of the most structured data (tables, lists, etc.) to an XML/XSLT approach. It defines the pattern for number formatting and passes it to the XSLT stylesheet. (Note the use of the JSTL tag: another approach involves using the tag along with the XPath format-number() function, similar to that used in the XSLT, but version 1.0 of the JSTL reference implementation doesn't support that function in its XPath function library.\n\nWhen the JSP is executed, the following web page is generated.\n\n\n\nIn earlier examples, output is produced using either XML/XSLT or JSP, and in both cases the technique used is responsible for all aspects of the HTML output. The point to this combined approach is to demonstrate how one might choose to use the strengths of JSP and XML/XSLT together. XSLT is excellent for generating presentation of highly structured data in tabular form, but less appealing for generating content based more on static and loosely-structured content. JSP, on the other hand, is somewhat more natural to creating complete HTML and is good for creating the general outline of the result web page.\n\nOn the other hand, one might argue this approach requires that content authors learn more technologies: HTML, JSP, etc. plus JSTL and XSLT. This is true, but for large scale applications with bigger development teams, developers can be further segregated into content authors responsible for boilerplate content and style, using JSP and CSS, and those responsible for presentation of reports and other structured data, using XML/XSLT. In the end, deciding which is really the better approach still depends on many factors, including the unique characteristics of a given development and business environment.\n\nIn both cases (pure JSTL and combined with XSLT), however, the advantage of creating script-free JSPs is realized. All the JSTL examples presented are entirely void of Java language JSP expressions, declarations, and scriptlets. Future implementations of the JSP and JSTL specifications will carry this even further when JSP 2.0 allows using Expression Language in tag body and template text.\n\nThe JSTL reference implementation is available from Apache's Jakarta Taglibs project web site, and is also bundled with Sun's Java Web Services Developer Pack (refer to the internet references below). Installation is no different than with any other custom JSP tag library. The JSTL reference implementation is bundled with the tag libraries jar file, additional support jar files, and the TLD (tag library descriptor) files. These are deployed with web applications using JSTL in the same manner as other JSP tag libraries.\n\nOne should also be sure to obtain the official specification in final form from the JSTL home page. Although it's about 200 pages long, it consists mostly of syntax references for the tag libraries and an Expression Language reference. As of the date of this article, several books on JSTL are slated for publication, but one should exercise caution selecting early editions to make sure they are based on the official release of JSTL. Numerous changes appeared in the JSTL specification after the initial public review draft was published."
    },
    {
        "link": "https://geeksforgeeks.org/spring-mvc-form-checkbox",
        "document": "In this article, we will learn about the Spring MVC Checkbox and Checkboxes tags. We will create a basic Spring MVC project in the Spring tool suite(STS) to create checkboxes using form:checkbox and form:checkboxes tags.\n\nIn Spring Framework, we can use Java Server Pages (JSPs) as a view component. To implement views using JSP, Spring Framework provides a form tag library namely spring-form.tld with some tags for evaluating errors, setting themes, formatting the fields for inputting and outputting internationalized messages.\n\n‘checkbox’ tag: The ‘checkbox’ is one of the tag provided by the spring-form.tld library. It renders an HTML ‘input’ tag with type ‘checkbox’.\n\n‘checkboxes’ tag: The ‘checkbox’ is one of the tag provided by the spring-form.tld library. It renders multiple HTML ‘input’ tags with type ‘checkbox’.\n\nWe will be creating the below Spring MVC application,\n• In STS, while creating the project based on the developer selection, it will download all the required maven dependencies, *.jar, lib files and it will provide an embedded server.\n• Below is the final project structure of the Spring MVC project after creating *.java and *.jsp files also.\n\nImplementation: Files to be created are as follows:\n• Home.java – Bean class – To define the properties and getter/setter methods of the properties.\n• HomeController.java – Controller class – To process the user request and generate the output.\n• home.jsp – Jsp file to interact with the user for the input.\n• summary.jsp – Jsp file to display the output after processing to the user.\n\nThis is the home page displayed to the user when the application starts. To use Spring form tags, first, we need to include the taglib URI – “http://www.springframework.org/tags/form” in the Jsp page. In the form tag – action, method attributes are used to map the controller method that has to be executed when the page submits. The checkbox tag has many attributes like path, cssStyle, dir, value, etc. We can include any number of attributes based on our requirements.\n\nIn this example, we have included the below attributes,\n• path – To specify the path to the property that needs to be bound with the data. Here, the data-bind to duration property in checkbox and framework property in checkboxes tags.\n• value – To specify the value to the particular checkbox.\n• label – To display the name of the value for the checkbox.\n• disabled – It is a boolean attribute to make the checkbox disabled when the value is true. By default, the value will be false.\n• items – To display the checkboxes names from the list.\n• delimiter – To specify a delimiter to use between each ‘input’ tag with type ‘checkbox’. Here we are using ‘|’ symbol as a delimiter.\n• This is the java bean class to define the required parameters.\n• Here, we are defining name, duration, and framework as parameters and their getter/setter methods to get/set the values to the properties.\n\nOutput Explanation: This is the controller class where it executes the methods based on the mapping of the request URLs. Here, @Controller, conveys to the container that this class is the spring controller class. To use this annotation we need to import org.springframework.stereotype.Controller package.\n\nThe annotation, @RequestMapping, maps the request URL’s to the specified method based on the value provided. o use this annotation, we need to import org.springframework.web.bind.annotation.RequestMapping package. The annotation @ModelAttribute, used to bind a method parameter or method return value to the named model attribute. We need to import org.springframework.web.bind.annotation.ModelAttribute package. The RequestMethod specifies the type of the request whether it is a get request or post request.\n• This is the output Jsp page to display the user entered values in the browser after the processing of the request.\n• After creating all the required .java and .jsp files, run the project on the server.\n• Right on the Project, Run as -> Run on Server.\n• Select the server in the localhost to run the application.\n• Open the URL: in the browser to get the below screen.\n\nAs we specified,\n• disabled=true for 6 Months checkbox, it is showing disabled in the screen.\n• delimiter = |, the specified delimiter is displaying between the checkbox names.\n\nNow, select the checkbox values and click on submit button.\n• Once the page is submitted, we will get the below output with the details we have selected."
    },
    {
        "link": "https://stackoverflow.com/questions/8700339/spring-mvc-usage-of-formcheckbox-to-bind-data",
        "document": "My guess is you are missing the implementation for the and methods on the RoleEntity class.\n\nThis is correct, but to check for presence in a you need and implemented correctly.\n\nJust as a quick test to see if that's the problem, replace this line:\n\nDo you get all your checkboxes checked? If yes, then you didn't provide your own and and the default ones are used (those inherited from ).\n\nThe default compares identity which means that a variable holds the same instance as another variable. Equality means two different object contain the same state or have the same meaning, so to speak.\n\nUsing triggers the default method to return true because the list and values you check for presence in the list are identical (two identical objects are always equal).\n\nBut in your case you use for one and for the other which means different objects. At this point you have to use a proper equality test as opposed to identity.\n\nDo you have / implemented?\n\nBased on your code, here is an example that works:\n\nRoles class (notice the and methods; if you remove them, the example no longer works):\n\nP.S. Just one observation about your JSP. If you do for your form:checkbox you will get HTML checkbox attributes like which might get you in another sort of trouble later on."
    },
    {
        "link": "http://fruzenshtein.com/spring-mvc-form-checkbox",
        "document": "It’s hard to imagine a situation when a modern web-application doesn’t have checkboxes in a form. In one of the previous posts I wrote about form handling in Spring MVC, as a continuation of this series I’m going to write about Spring MVC forms, and in particular about checkbox processing. This post will be about a standard usage of tag.\n\n \n\n I’ll examine three cases of the checkbox tag usage, when:\n• Group of checkboxes represents an array of strings\n\nSo you can see that these three points are simple enough, but they need some attention from developer’s side. Below I will describe how to realize each of these cases, you can download the source code in the end of the article.\n\n\n\n For the first case I will use the following domain model:\n\nThis class doesn’t need any explanations, because it’s simple bean with getters and setters. Now I can show you views for this case:\n\nNotice that usage of Spring form tag implies import of the appropriate tag library. The checkbox tag contains the attribute path which corresponds to the property of the domain model.\n\n The result will be displayed on another page:\n\nAnd finally I need to declare a controller for all this stuff:\n\n\n\n The second case will be explained with the following domain model:\n\nThe view for this situation will be a little bit different from the previous one:\n\nNotice that a new attribute appears in the checkbox tag. The value attribute represents the string property from the domain model.\n\n The result will be displayed on another page:\n\nAnd the controller for this example:\n\n\n\n The last case of the tutorial will describe how to bind an array of strings to a property from a domain model. In the same way you can bind values of java.util.Collection. So the domain model will look like this:\n\nThe page with the form:\n\nThe values from the checkbox tags will be passed to the string array during the processing.\n\n The result page:\n\nAnd the controller for the last case:\n\nWhen some page with form is rendered, you can open its source code, and see something like this:\n\nStrange, where does the additional input appear from? Official documentation explains this fact:\n\nWhen a checkbox in an HTML page is not checked, its value will not be sent to the server as part of the HTTP request parameters once the form is submitted, so we need a workaround for this quirk in HTML in order for Spring form data binding to work. The checkbox tag follows the existing Spring convention of including a hidden parameter prefixed by an underscore (“_”) for each checkbox. By doing this, you are effectively telling Spring that “ the checkbox was visible in the form and I want my object to which the form data will be bound to reflect the state of the checkbox no matter what ”.\n\nThis article gives you a high level overview of the checkbox tag usage, but this is just a base. In the nearest posts I will show you more interesting situations of the checkbox usage in Spring MVC.\n\n You can download the source code of the entire application clicking on the link."
    },
    {
        "link": "https://stackoverflow.com/questions/41671924/spring-mvc-how-to-bind-html-checkbox-value-in-a-boolean-variable",
        "document": "I am very new to spring mvc world. I am trying to send boolean value to from html form checkbox. When a user check the checkbox then it will send true, false otherwise.\n\nAfter some googilng I have found this so post, where it said standard behaviour is the value is only sent if the checkbox is checked. So what I have understand that is if the checkbox checked then the form will submit with the value of checkbox, otherwise it will not submit. When there is unchecked checkbox the initialization value in data class will be effective.\n\nBut in my case every time I am submitting the form it submitting .\n\nhere is my rest controller for the bind html form submit.\n\nthe data class(I am using kotlin)\n\nSo what will be the method to bind boolean data from a form submission with checkbox. I am also using . Thanks in advance."
    },
    {
        "link": "https://baeldung.com/spring-mvc-form-tags",
        "document": "In the first article of this series we introduced the use of the form tag library and how to bind data to a controller.\n\nIn this article, we’ll cover the various tags that Spring MVC provides to help us create and validate forms.\n\nWe’ll get started with the input tag. This tag renders an HTML input tag using the bound value and type=’text’ by default:\n\nStarting with Spring 3.1 you can use other HTML5-specific types, such as email, date, and others. For example, if we wanted to create an email field, we can use type=’email’:\n\nSimilarly, to create a date field, we can use type=’date’, which will render a date picker in many browsers compatible with HTML5:\n\n\n\nThis tag renders an HTML input tag with type=’password’ using the bound value. This HTML input masks the value typed into the field:\n\nWe can specify the number of rows and columns in the same way we would an HTML textarea.\n\nThe checkbox tag renders an HTML input tag with type=’checkbox’. Spring MVC’s form tag library provides different approaches to the checkbox tag which should meet all our checkbox needs:\n\nThe above example generate a classic single checkbox, with a boolean value. If we set the bound value to true, this checkbox will be checked by default.\n\nThe following example generates multiple checkboxes. In this case, the checkbox values are hard-coded inside the JSP page:\n\nHere, the bound value is of type array or java.util.Collection:\n\nThe purpose of the checkboxes tag is used to render multiple checkboxes, where the checkbox values are generated at runtime:\n\nTo generate the values we pass in an Array, a List or a Map containing the available options in the items property. We can initialize our values inside the controller:\n\nTypically the bound property is a collection so it can hold multiple values selected by the user:\n\nThis tag renders an HTML input tag with type=’radio’:\n\nA typical usage pattern will involve multiple tag instances with different values bound to the same property:\n\nJust like the checkboxes tag, the radiobuttons tag renders multiple HTML input tags with type=’radio’:\n\nIn this case, we might want to pass in the available options as an Array, a List or a Map containing the available options in the items property:\n\nTo generate the values we pass in an Array, a List or a Map containing the available options in the items property. Once again, we can initialize our values inside the controller:\n\nThe select tag also support the use of nested option and options tags.\n\nWhile the option tag renders a single HTML option, the options tag renders a list of HTML option tags.\n\nThe options tag takes an Array, a List or a Map containing the available options in the items property, just like the select tag:\n\nWhen we have the need to select several items at once, we can create a multiple list box. To render this type of list, just add the multiple=”true” attribute in the select tag.\n\nHere the bound property is an array or a java.util.Collection:\n\nThis tag renders an HTML input tag with type=’hidden’ using the bound value:\n\nField error messages are generated by validators associated with the controller. We can use The Errors Tag to render those field error messages:\n\nThis will display errors for the field specified in the path property. The error messages are rendered within a span tag by default, with .errors appended to the path value as the id, and optionally a CSS class from the cssClass property, which can be used to style the output:\n\nTo enclose the error messages with a different element instead of the default span tag, we can specify the preferred element inside the element attribute:\n\nThis renders the error messages within a div element:\n\nIn addition to having the capability to show errors for a specific input element, we can display the entire list of errors (regardless of field) for a given page. This is achieved by the use of the wildcard *:\n\nTo display errors for a given field we need to define a validator:\n\nIn this case, if the field name is empty, the validator returns the error message identified by required.name from the resource bundle.\n\nThe resource bundle is defined in the Spring XML configuration file as follows:\n\nThe error message is defined inside the messages.properties file:\n\nTo apply this validation, we need to include a reference to the validator in our controller and call the method validate in the controller method which is called when user submits the form:\n\nStarting from Spring 3, we can use JSR 303 (via the @Valid annotation) for bean validation. To do this we need a JSR303 validator framework on the classpath. We will use the Hibernate Validator (the reference implementation). Following is the dependency that we need to include in the POM:\n\nTo make Spring MVC support JSR 303 validation via the @Valid annotation, we need to enable the following in our Spring configuration file:\n\nOr use the corresponding annotation @EnableWebMvc in a Java configuration:\n\nNext, we need to annotate the controller method that we want to validate with the @Valid annotation:\n\nNow we can annotate the entity’s property to validate it with Hibernate validator annotation:\n\nBy default, this annotation will display “may not be empty” if we leave the password input field empty.\n\nWe can override the default error message by creating a property in the resource bundle defined in the validator example. The key of the message follows the rule AnnotationName.entity.fieldname:\n\nIn this tutorial we explored the various tags that Spring provides for working with forms.\n\nWe also had a look at the tag for validation error displaying and the configuration needed to display custom error messages.\n\nWhen the project runs locally, the form example can be accessed at:"
    }
]