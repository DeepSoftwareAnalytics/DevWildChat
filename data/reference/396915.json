[
    {
        "link": "https://swiftbysundell.com/articles/swifts-closure-capturing-mechanics",
        "document": "Closures are an increasingly important part of Swift, both in terms of the overall direction of the language itself, and when it comes to the ways that both Apple and third party developers design libraries and APIs using it. However, closures also come with a certain set of complexities and behaviors that at first can be quite difficult to fully grasp — especially when it comes to how they capture values and objects from their surrounding context in order to perform their work.\n\nWhile we already took a look at various ways to capture objects within closures in 2017’s “Capturing objects in Swift closures”, this week’s, let’s explore the concept of capturing more broadly — by taking a closer look at some of the opportunities and challenges that comes with writing capturing closures in general.\n\nWhenever we’re defining an escaping closure — that is, a closure that either gets stored in a property, or captured by another escaping closure — it’ll implicitly capture any objects, values and functions that are referenced within it. Since such closures may be executed at a later time, they need to maintain strong references to all of their dependencies in order to prevent them from being deallocated in the meantime.\n\nFor example, here we’re using Grand Central Dispatch to delay the presentation of a by three seconds, which requires the closure passed into the call to to capture the view controller instance:\n\nWhile the above behavior is really convenient, it can also become the source of some really tricky bugs and memory-related issues if we’re not careful.\n\nFor example, since we’re delaying the execution of the above code by a few seconds, it’s possible for our view controller to have been removed from our app’s view hierarchy by the time the closure actually gets run — and while that wouldn’t be a catastrophe in this case, it would arguably be better for us to only present our confirmation if the view controller is still being retained by another object (presumably its parent view controller or window).\n\nThis is where capture lists come in, which enable us to customize how a given closure captures any of the objects or values that it refers to. Using a capture list, we can instruct our above closure to capture the view controller weakly, rather than strongly (which is the default). That way, the view controller will get deallocated if not referenced by any other part of our code base — resulting in memory getting freed up quicker, and no unnecessary operations being performed:\n\nCapture lists are perhaps even more useful when we need to reference , especially when doing so would cause a retain cycle, which is when two objects or closures refer to each other — preventing both of them from ever getting deallocated (since they can’t reach a reference count of zero).\n\nHere’s an example of such a situation, in which we’re using a capture list to avoid referencing strongly within a closure that will also be retained by :\n\nAlternatively, we could’ve converted the above property into a function using its key path, like we did in “The power of key paths in Swift” — since all that we’re doing inside of our observation closure is updating that property’s value.\n\nThe reason the above closure would end up causing a retain cycle if we didn’t capture weakly is because will retain that closure, and already retains that object through its property.\n\nWeak references are not always the answer\n\nWhile the above two code samples might make it seem like always capturing weakly is the way to go, that’s definitely not the case. Like with other kinds of memory management, we’ll have to carefully consider how will be used within each situation, and for how long we expect each capturing closure to remain in memory.\n\nFor example, if we’re dealing with really short-lived closures, such as ones passed to the API (which are just executed to perform interpolation for an animation, and then released), capturing is really not a problem, and will most likely lead to code that’s easier to read:\n\nNote how we always need to explicitly refer to when accessing both instance methods and properties within an escaping closure. That’s a good thing, as it requires us to make an explicit decision to capture , given the consequences that doing so might have.\n\nThere are also many kinds of situations in which we might want to retain even for longer — for example if the current object is required in order to perform a closure’s work, like in this case:\n\nThe above code won’t cause any retain cycles, since doesn’t retain the tasks that it creates. For more sophisticated ways of modeling and working with tasks in Swift, check out “Task-based concurrency in Swift”.\n\nWe can also capture each of a closure’s dependencies directly, rather than referencing — again using a capture list. For example, here we’re capturing an image loader’s property in order to be able to use it once an image was successfully downloaded:\n\nThe above technique works really well when we only need access to a few of our properties, rather than to as a whole — as long as those properties either contain reference types (class instances), or immutable value types.\n\nValue types can sometimes be a bit more complex to deal with when it comes to closure capturing, since they’re passed to external scopes as copies, rather than as references. Although that’s exactly what makes Swift’s value types so powerful, it can have somewhat unexpected consequences in situations like the one below — in which we’re capturing a and property when assigning a closure to a button:\n\nAt first glance, the above code may seem perfectly fine. However, the type that we’re using above is implemented as a struct, which gives it value semantics — meaning that we’re just capturing its current value when adding it to our capture list. So even though that value might change during our view controller’s lifecycle, once our is tapped, we’ll still send our original value — which isn’t great.\n\nOne way to solve the above problem, while still avoiding any additional statements, would be to only capture to be able to access its — and then map that value directly to our sender’s method, like this:\n\nHowever, the above is really only a problem when dealing with mutable values. If we instead only have constants, like in the following example, then we can add those properties to any closure’s capture list without any problems (as their values won’t change):\n\nIn situations like the one above, we could also create a new function by combining our value ( in this case) with the method that it’ll be passed into. Check out the first episode of Swift Clips for an example of doing just that.\n\nFinally, let’s take a look at how values are captured when it comes to local variables. Contrary to how value-based properties are captured, local variables still maintain their connection to their original declaration when captured by a closure within the same scope — which can be incredibly useful in order to keep track of various kinds of state.\n\nFor example, let’s say that we wanted to extend Swift’s protocol with an API to enable us to iterate over any collection using a buffer consisting of the current element, as well as the next one. That could be done by combining the standard library’s and types with locally captured values — like this:\n\nFor more information about the above way of creating custom sequences, check out “Wrapping sequences in Swift”.\n\nSo values copied when captured using a capture list, while they’re not copied when referenced directly — for example when accessed as properties, or when a local variable is captured within the same scope as it was defined in.\n\nOne final option when it comes to closure capturing is to use references. These are, just like references, specified using capture lists — and can also only be applied to reference types. Using gives us essentially the same result as when using force-unwrapped optionals, in that it lets us treat a weak reference as if it was non-optional, but will result in a crash if we try to access it after it was deallocated.\n\nGoing back to our example from before, here’s what it’d look like if we were to use instead of :\n\nWhile using lets us get rid of optionals, and might occasionally be really convenient, the fact that it causes crashes for deallocated references makes it quite dangerous to use unless we’re absolutely certain that a given closure won’t accidentally be triggered after one of its dependencies has been deallocated.\n\nOne advantage of such crashes, however, is that they let us identify code paths that ideally should never have been entered. For example, if our above observation closure ends up getting triggered after was deallocated, that probably means that we’re not unregistering our observations properly, which would be great to know.\n\nHowever, rather than using , we could (in this case) achieve the exact same thing using an — and while doing so will result in a bit more code, it’ll also give us a much more actionable error message in case of a failure, and we wouldn’t be causing any crashes in production:\n\nTo learn more about , along with other ways of propagating various errors — check out “Picking the right way of failing in Swift”.\n\nAlthough Swift’s Automatic Reference Counting memory management model doesn’t require us to manually allocate and deallocate memory, it still requires us to decide exactly how we want our various objects and values to be referenced.\n\nWhile it’s common to hear over-simplified rules like “Always use references within closures”, writing well-performing and predictable apps and systems often requires a bit more nuanced thinking than that. Like with most things within the world of software development, the best approach tends to be to throughly learn the underlying mechanics and behaviors, and then choose how to apply them within each given situation.\n\nHopefully this article has provided a few insights into those mechanics and behaviors when it comes to closure capturing, and if you have any questions, comments or feedback — just let me know, either on Twitter or via email."
    },
    {
        "link": "https://docs.swift.org/swift-book/documentation/the-swift-programming-language/closures",
        "document": "Please turn on JavaScript in your browser and refresh the page to view its content."
    },
    {
        "link": "https://medium.com/@harshaag99/understanding-capture-lists-in-swift-closures-6971908eb1e3",
        "document": "Closures in Swift are powerful. They allow us to write blocks of code that we can pass around like variables and execute whenever needed. But closures can also “capture” values from their surrounding context. Sometimes, this can lead to unexpected behavior, especially when you’re dealing with reference types, like classes. To handle this, Swift gives us the concept of Capture Lists.\n\nIn this article, we’ll explore Capture Lists using a real-world analogy, explain how they work, and provide some practical examples.\n\nImagine that you need to borrow your friend’s phone for a day to make some calls. You both agree that you’ll return it by evening. Now, let’s take two different scenarios:\n• In the first scenario, you use the phone responsibly, return it on time, and all is well.\n• In the second scenario, you forget to return the phone, and your friend is stuck without their phone until you finally remember to give it back!\n\nThis situation is similar to how closures work in Swift. When you use a closure, it can “borrow” a value from outside its scope. But if you don’t handle the borrowing properly, you can run into trouble — similar to forgetting to return your friend’s phone.\n\nCapture Lists are Swift’s way of managing this “borrowing” process more responsibly.\n\nWhat is a Capture List in Swift?\n\nWhen you use a closure, Swift “captures” the variables it needs from the surrounding context. For example, if your closure uses an object, the closure will hold a reference to that object. However, without managing this properly, the closure can create a strong reference cycle, which means the closure holds onto the object forever, causing memory leaks.\n\nTo avoid this, Swift uses Capture Lists to define how you want the closure to capture values from its surrounding context. This allows you to control how the closure treats the variables it captures, ensuring everything is managed responsibly.\n\nCapture lists are placed at the beginning of a closure in square brackets. You can specify whether the closure should capture a value weakly (without keeping it alive) or unowned (meaning the closure won’t keep a reference to it). Here’s what the syntax looks like:\n\nIn this case, we’re telling the closure to capture weakly, meaning it won’t create a strong reference cycle.\n\nLet’s now relate this to a daily human process: memory management.\n\nImagine you’re working on a group project. You’re all assigning tasks to each other, but everyone needs to remember their responsibilities. If each person keeps a strong memory of every single task forever, it’ll eventually become overwhelming (like a strong reference cycle). Some of these tasks are short-lived, and once completed, they should be “forgotten.”\n\nIn programming terms, this is where a weak reference comes in. By making some memories weaker, you allow your brain to forget them once they’re no longer needed.\n\nIn Swift, Capture Lists let you decide whether a closure should keep a strong memory (strong reference) of an object or allow it to be “forgotten” (weak reference) when it’s no longer needed.\n\nAn Example in Code\n\nHere’s an example to illustrate how Capture Lists work. Let’s say we have a class called that assigns tasks, and we’re using a closure to handle task completion.\n\nIn this example:\n• The method takes a closure as a parameter and calls it after the task is assigned.\n• Inside the closure, we use a weak capture list ( ) to prevent a strong reference cycle.\n\nWithout the capture list, the closure would keep a strong reference to , even after is no longer needed, which could lead to a memory leak.\n\nWhen to Use Capture Lists\n\nYou might wonder when to use capture lists in your code. Here are a few scenarios where they’re useful:\n• Avoiding memory leaks: If you have a closure inside a class and that closure references , it could create a strong reference cycle. A weak or unowned capture list prevents this.\n• Handling async tasks: When dealing with asynchronous code, a closure might still exist after the object it refers to is gone. A weak reference helps ensure the closure doesn’t access a deallocated object.\n• Memory management in complex projects: In complex applications, Capture Lists help ensure that objects are deallocated when no longer needed, reducing memory usage.\n\nCapture Lists in Swift allow you to manage how closures “borrow” values from their surrounding context. Whether you’re working on a small task or a large project, understanding how to manage memory using weak or unowned references can save you from unexpected memory leaks and performance issues.\n\nJust like remembering to return your friend’s phone on time, using Capture Lists ensures your closures behave responsibly, releasing objects when they’re no longer needed."
    },
    {
        "link": "https://shantaram-kokate-swift.medium.com/capture-list-in-swift-a7d7d1328c84",
        "document": "The capture list is described as a “comma-separated list enclosed in square brackets” before the list of parameters. When using a capture list, always use keywords, even if you omit the parameter name, parameter, and return types.\n\ncapture list creates a local variable in the closure. It is initialized with the value of the variable with the same name in the outer context.\n\nlet understand the capture list using value type and reference type.\n\nlet start with outer variable and are Int Type i.e Value Type in swift\n\nIn the above code, is included in the capture list, but not.\n\ncapture variable is initialized with an outer variable when the closure is created but those variables ​​are not pointing to the same memory location. because Int is a value type. That is, changes in the outer variable do not affect the capture of the local variable , and changes inside the closure do not affect anything outer variable .\n\nNote: To create a capture list make sure that outer variable and capture variable name should be same\n\nIn contrast, there is only one variable named , so that change affects both inside and outside variable. because we have not captured this variable inside closure.\n\nWhy we use capture list?"
    },
    {
        "link": "https://hackingwithswift.com/articles/179/capture-lists-in-swift-whats-the-difference-between-weak-strong-and-unowned-references",
        "document": "Capture lists come before a closure’s parameter list in your code, and capture values from the environment as either strong, weak, or unowned. We use them a lot, mainly to avoid strong reference cycles – aka retain cycles.\n\nDeciding which to use isn’t easy when you’re learning, so you can spend time trying to figure out strong vs weak, or weak vs unowned, but as you progress with your learning you’ll start to realize there’s often only one right choice.\n\nFirst, let’s take a look at the problem. First, here’s a simple class:\n\nSecond, here’s a function that creates an instance of , creates a closure that uses the singer’s method, and returns that closure for us to use elsewhere:\n\nFinally, we can call to get back a function we can call wherever we want to have printed:\n\nThat will print “Shake it off!” thanks to the call to .\n\nSponsor Hacking with Swift and reach the world's largest Swift community!\n\nUnless you ask for something special, Swift uses strong capturing. This means the closure will capture any external values that are used inside the closure, and make sure they never get destroyed.\n\nLook again at our function:\n\nThat constant is made inside the function, so normally it would be destroyed when the function ends. However, it gets used inside the closure, which means Swift will automatically make sure it stays alive for as long as the closure exists somewhere, even after the function has returned.\n\nThis is strong capturing in action. If Swift allowed to be destroyed, then the closure would no longer be safe to call – its method wouldn’t be valid any more.\n\nSwift lets us specify a capture list to determine how values used inside the closure should be captured. The most common alternative to strong capturing is called weak capturing, and it changes two things:\n• Weakly captured values aren’t kept alive by the closure, so they might be destroyed and be set to .\n• As a result of 1, weakly captured values are always optional in Swift. This stops you assuming they are present when in fact they might not be.\n\nWe can modify our example to use weak capturing and you’ll see an immediate difference:\n\nThat part is our capture list, which is a specific part of closures where we give specific instructions as to how values should be captured. Here we’re saying that should be captured weakly, which is why we need to use – it’s an optional now, because it could be set to nil at any time.\n\nIf you run the code now you’ll see that calling doesn’t print anything any more. The reason is that exists only inside , because the closure it returns doesn’t keep a strong hold of it.\n\nTo see this behavior in action, try changing to this:\n\nThat force unwraps inside the closure, which will cause your code to crash because becomes nil.\n\nAn alternative to is , which behaves more like implicitly unwrapped optionals. Like weak capturing, unowned capturing allows values to become nil at any point in the future. However, you can work with them as if they are always going to be there – you don’t need to unwrap optionals.\n\nThat will crash in a similar way to our force-unwrapped example from earlier: says I know for sure that will always exist for the lifetime of the closure I’m sending back so I don’t need to hold on to the memory, but in practice will be destroyed almost immediately so the code will crash.\n\nYou should use very carefully indeed.\n\nThere are four problems folks commonly hit when using closure capturing:\n• They aren’t sure where to use capture lists when closures accept parameters.\n• They make strong reference cycles, causing memory to get eaten up.\n• They accidentally use strong references, particularly when using multiple captures.\n• They make copies of closures and share captured data.\n\nLet’s walk through each of those with some code examples, so you can see what happens.\n\nThis is a common problem to hit when you’re first starting out with capture lists, but fortunately it’s one that Swift catches for us.\n\nWhen using capture lists and closure parameters together the capture list must always come first, then the word to mark the start of your closure body – trying to put it after the closure parameters will stop your code from compiling.\n\nWhen thing A owns thing B, and thing B owns thing A, you have what’s called a strong reference cycle, or often just a retain cycle.\n\nAs an example, consider this code:\n\nThat creates a class with one property (a closure), one method, and a deinitializer so it prints a message when it’s being destroyed.\n\nNow here’s an class that is the same, except its closure stores house details:\n\nWe can try creating two instances of those classes inside a block. We don’t need a block here, but using ensures they will be destroyed as soon as the is reached:\n\nThat should print “Creating a house and an owner”, “I’m dying!”, “I'm being demolished!”, then “Done” – everything works as expected.\n\nNow it will print “Creating a house and an owner” then “Done”, with neither deinitializer being called.\n\nWhat’s happening here is that has a property that points to a method of , and has a property that points to a method of , so neither can be safely destroyed. In real code this causes memory that can’t be freed, known as a memory leak, which degrades system performance and can even cause your app to be terminated.\n\nTo fix this we need to create a new closure and use weak capturing for one or both values, like this:\n\nIt isn’t necessary to have both values weakly captured – all that matters is that at least one is, because it allows Swift to destroy them both when necessary.\n\nNow, in real project code it’s rare to find strong reference cycles that are so obvious, but that just means it’s all the more important to use weak capturing to avoid the problem entirely.\n\nSwift defaults to strong capturing, which can cause unintentional problems.\n\nGoing back to our singing example from earlier, consider this code:\n\nNow we have two values being captured by the closure, and both values are being used the same way inside the closure. However, only is being captured as unowned – is being captured strongly, because the keyword must be used for each captured value in the list.\n\nNow, if you want to be unowned but to be strongly captured, that’s fine. But if you want both to be unowned you need to say so:\n\nSwift does offer some protection against accidental capturing, but it’s limited: if you use implicitly inside a closure, Swift forces you to add or . to make your intentions clear.\n\nImplicit use of self happens a lot in Swift. For example, this initializer calls , but what it really means is – the part is implied by the context:\n\nSwift won’t let you use implicit inside closures, which helps reduce a common type of retain cycle.\n\nThe last thing that trips people up is the way closures themselves are copied, because their captured data becomes shared amongst copies.\n\nFor example, here’s a simple closure that captures the integer created outside so that it can increment and print its value whenever its called:\n\nThat will print “Lines logged: 1” because we call the closure at the end.\n\nNow, if we take a copy of that closure, that copy shares the same capturing values as its original, so whether we call the original or the copy you’ll see the log line count increasing:\n\nThat will now print that 1, 2, 3, and 4 lines have been logged, because both and are pointing at the same captured value.\n\nWhen to use strong, when to use weak, when to use unowned\n\nNow that you understand how everything works, let’s try to summarize whether to use strong, weak, or unowned references:\n• If you know for sure your captured value will never go away while the closure has any chance of being called, you can use . This is really only for the handful of times when would cause annoyances to use, but even when you could use inside the closure with a weakly captured variable.\n• If you have a strong reference cycle situation – where thing A owns thing B and thing B owns thing A – then one of the two should use weak capturing. This should usually be whichever of the two will be destroyed first, so if view controller A presents view controller B, view controller B might hold a weak reference back to A.\n• If there’s no chance of a strong reference cycle you can use strong capturing. For example, performing animation won’t cause to be retained inside the animation closure, so you can use strong capturing.\n\nIf you’re not sure which to use, start out with and change only if you need to.\n\nAs you’ve seen, closure capture lists help us avoid memory problems by controlling each how values are captured inside our closures. They are captured strongly by default, but we can use and even to allow values to be destroyed even if they are used inside our closure.\n\nI go into a lot more detail on closures in my book Pro Swift, so for more information you might want to check that out.\n\nAnd if you still have questions about the way closures capture values, let me know on Twitter – I’m @twostraws there.\n\nSponsor Hacking with Swift and reach the world's largest Swift community!"
    },
    {
        "link": "https://arc-sosangyo.medium.com/swift-programming-tutorial-weak-references-531d179c5812",
        "document": "The mighty yet misunderstood ! It’s one of those words in Swift that seems unassuming but wields great power, like a wizard whispering magic to avoid memory leaks.\n\nWhat is in Swift?\n\nWhen you declare a property as , you’re telling Swift, “Hey, I don’t want this property to own the thing it’s pointing to. I just want to borrow it and let someone else keep the main responsibility for it.”\n\nHere’s the deal: Swift uses ARC (Automatic Reference Counting) to manage memory. Objects can have strong references to each other, which means, “I own you, and I won’t let you go!” But if two objects own each other at the same time, it’s like a clingy couple — neither one lets the other go, and they’re stuck in memory forever. This is called a retain cycle, and it’s bad news.\n\nEnter , the hero that saves the day by breaking this cycle. A reference doesn’t increase the reference count of the object it points to, so the object can still be deallocated when the strong references let it go."
    },
    {
        "link": "https://docs.swift.org/swift-book/documentation/the-swift-programming-language/automaticreferencecounting",
        "document": "Please turn on JavaScript in your browser and refresh the page to view its content."
    },
    {
        "link": "https://dhiwise.com/post/unowned-vs-weak-swift-a-guide-to-effective-memory-management",
        "document": "In Swift, understanding the differences between unowned vs. weak Swift references is crucial for effective memory management, especially when developing efficient and responsive applications. Proper memory management helps avoid memory leaks, reduces an app's memory usage, and prevents runtime errors caused by improper reference handling.\n\nSwift's Automatic Reference Counting (ARC) handles much of this for you, but knowing when to use weak and unowned references is key to avoiding strong reference cycles and ensuring smooth app performance.\n\nTo understand memory management in Swift, it's essential to grasp the concept of memory ownership. In Swift, each object's reference count determines its lifespan. When you create an instance of a class, it is stored in memory, and its reference count starts at one. Each time another strong reference references the instance, its reference count increases. Conversely, when a strong reference is removed, the reference count decreases. When the reference count reaches zero, ARC automatically frees the referenced object from memory.\n\nHowever, strong references can lead to strong reference cycles, where two objects hold strong references to each other, preventing ARC from deallocating either. This is where weak and unowned references come into play. These references help manage memory more effectively by breaking strong reference cycles.\n\nGot it! Here's the revised explanation for the section without bolding all the keywords:\n\nWhat is Weak in Swift?\n\nIn Swift, weak references are a fundamental concept used to manage memory efficiently and prevent strong reference cycles that can lead to memory leaks. Understanding how and when to use weak references is crucial for building robust and optimized applications, especially when dealing with reference types like classes.\n\nA weak reference in Swift is a type of reference that does not increase the object's reference count when assigned. Unlike a strong reference, which maintains a firm hold on the referenced object and keeps it in memory, a weak reference allows the referenced instance to be deallocated when there are no other strong references to it. This is essential for breaking strong reference cycles in situations where two objects might reference each other, causing a retain cycle.\n\nWeak references are declared using the weak keyword. They must always be optional types because the referenced object can be deallocated and set to nil at any point. Here's a simple example to illustrate the use of a weak reference:\n\nIn this example, the friend property is a weak reference, meaning that if there are no other strong references to the Person instance it points to, the referenced object can be deallocated, and friend will automatically be set to nil.\n\nUse Cases for Weak References in App Development\n\nWeak references are particularly useful in scenarios where one object references another, but the second object should not strongly own the first. Common use cases include:\n• Delegation Patterns: Delegates in iOS development are often declared as weak references to prevent strong reference cycles between a view controller and its delegate.\n• Parent-Child Relationships: In a parent-child hierarchy where the parent holds a strong reference to the child, the child often holds a weak reference back to the parent. This prevents a retain cycle and ensures proper memory deallocation.\n\nWhen to Use Weak References\n\nWeak references should be used when the referenced object might be deallocated before the owner object. This is common in scenarios involving delegates, data sources, or closures that capture self. For example:\n• View Controllers and Delegates: When a view controller assigns itself as a delegate to another class (e.g., UITableView), it should use a weak reference for the delegate to prevent a retain cycle.\n• Closures Capturing Self: Closures that capture self should often use to avoid keeping self in memory longer than necessary. Here’s an example of using weak self in a closure:\n\nIn this example, the closure captures self weakly, ensuring that NetworkManager can be deallocated if there are no other strong references.\n\nCommon Pitfalls and Considerations When Using Weak References\n\nWhile weak references are useful for avoiding strong reference cycles, there are some pitfalls to be aware of:\n• Unexpected nil Values: Since weak references are automatically set to nil when the referenced object is deallocated, you must always handle the optional value carefully. Failing to do so can lead to crashes or unexpected behavior.\n• Memory Management Complexity: Overusing weak references can lead to complex memory management issues where it becomes challenging to track which objects are still in memory and which are not.\n• Overuse of Weak References: Using weak references indiscriminately, especially when they are not needed, can lead to confusion and bugs. Always assess whether a strong reference cycle is possible before opting for a weak reference.\n\nBy understanding when and how to use weak references, you can effectively manage memory in your Swift applications, preventing retain cycles and reducing the risk of memory leaks.\n\nWhat is Unowned in Swift?\n\nIn Swift, unowned references provide another approach to managing memory efficiently, particularly when you want to prevent strong reference cycles but need to ensure a referenced object is always present when accessed. Unlike weak references, unowned references are non-optional and are used when the referenced object will never be nil during its lifetime. Understanding how to use unowned references correctly is key to avoiding potential runtime errors.\n\nAn unowned reference in Swift is a reference that does not increase the reference count of the object it refers to. While similar to weak references in breaking strong reference cycles, an unowned reference differs in that it assumes the referenced instance will always exist as long as the unowned reference is accessed. If the referenced instance is deallocated and an unowned reference is accessed, it will result in a runtime error, specifically a crash.\n\nUnowned references are declared using the unowned keyword. Unlike weak references, unowned references cannot be nil because they assume a guaranteed lifetime of the referenced object. Here's a simple example of using an unowned reference:\n\nIn this example, the CreditCard class holds an unowned reference to the Customer object. This ensures that the CreditCard instance does not increase the reference count of Customer, preventing a retain cycle. Here, the customer property is marked as unowned because the credit card is only valid as long as the customer exists.\n\nWhile both weak and unowned references help in breaking strong reference cycles, they differ in their usage and behavior:\n• Weak References are used when the referenced object can be set to nil at some point. They are always declared as optional to handle the case when the object is deallocated.\n• Unowned References are used when it is guaranteed that the referenced object will never be nil during the lifetime of the referencing object. They are non-optional and assume the referenced instance will always be available.\n\nThe choice between weak and unowned references depends on whether the referenced object might be deallocated or if it is guaranteed to exist.\n\nWhen to Use Unowned References\n\nUnowned references are suitable when you know that the referenced object will outlive the object holding the unowned reference. This is often the case in relationships where there is a clear hierarchy or ownership structure:\n• One-to-One Relationships with Ownership: For example, a CreditCard always belongs to a Customer. The CreditCard should not exist without a Customer. Therefore, the CreditCard has an unowned reference to its Customer.\n• Closures with Unowned Self: In closures, when you are certain that the closure will not outlive the object it references, you can use unowned self instead of weak self. This is particularly useful to avoid optional unwrapping of self when the closure executes. Here is an example:\n\nIn this example, unowned self is used because it is guaranteed that NetworkManager will be alive when the closure is executed.\n\nRisks and Potential Crashes When Using Unowned References Incorrectly\n\nUsing unowned references incorrectly can lead to severe issues, particularly runtime crashes. If an unowned reference points to a deallocated object and is accessed, it will cause a fatal program error. This is why unowned references should only be used when you are sure of the referenced object's lifecycle.\n• Risk of Crashes: If the referenced instance is deallocated while an unowned reference still exists and is accessed, the app will crash. This makes debugging more challenging since the crash will point to the invalid memory access rather than a clean nil check.\n• Incorrect Assumptions About Object Lifecycles: Developers must be cautious not to assume that an object's lifecycle will always match the unowned reference. If there is any possibility that the object could be deallocated earlier than expected, a weak reference should be used instead.\n\nIn summary, unowned references in Swift provide a powerful way to manage memory when used correctly. However, their use comes with risks, and understanding the differences between weak and unowned references will help in deciding the best approach for your Swift applications.\n\nUnderstanding the key differences between weak and unowned references in Swift is crucial for effective memory management and avoiding common pitfalls like retain cycles and memory leaks. Both weak and unowned references are used to prevent strong reference cycles, but they handle memory differently and have different safety implications.\n\nThe main difference between weak and unowned references lies in their memory safety and behavior when the referenced object is deallocated:\n• Weak References: A weak reference does not increase the reference count of the referenced object. When the referenced object is deallocated, the weak reference is automatically set to nil. This makes weak references safe to use in situations where the referenced object can be deallocated at any time. However, because weak references are optional, you must always handle the possibility that they may be nil when accessed. This helps avoid runtime crashes but requires additional checks in the code.\n• Unowned References: An unowned reference also does not increase the reference count of the referenced object, but unlike weak references, it is non-optional. This means that when you declare an unowned reference, you are assuming that the referenced object will never be deallocated while the unowned reference exists. If the object is deallocated and the unowned reference is accessed, it will cause a runtime crash. Therefore, unowned references are not memory-safe in scenarios where there is any uncertainty about the lifetime of the referenced object.\n\nIn the example above, the owner property is a weak reference, so if the Owner instance is deallocated, owner will automatically become nil. On the other hand, permanentOwner is an unowned reference, and it must always point to a valid Owner instance; otherwise, accessing it after deallocation will lead to a crash.\n\nBest Practices for Choosing Between Weak and Unowned\n\nChoosing between weak and unowned references depends on the specific use case and the relationship between objects:\n\n◦ The referenced object might be deallocated at any time. For example, delegates in iOS development are often declared as weak references to avoid retain cycles between a view controller and its delegate.\n\n◦ You want to avoid runtime crashes by safely handling the deallocation of the referenced object. This requires the use of optional handling (e.g., if let or optional chaining).\n\n◦ The object holding the weak reference does not have a strong ownership relationship or lifecycle dependency on the referenced object.\n\n◦ You are sure that the referenced object will always exist as long as the object holding the unowned reference exists. For instance, in a parent-child relationship where the child does not outlive the parent, unowned can be used safely.\n\n◦ You want to avoid the overhead of optional handling and are certain about the memory management lifecycle. For example, when a CreditCard object always has an associated Customer object that will exist for the duration of the CreditCard.\n\nHere are some practical examples demonstrating when to use weak vs. unowned references:\n\nA common scenario for using weak references is with delegates to prevent strong reference cycles:\n\nIn this example, the delegate property is weak because the DataManager should not strongly own its delegate. If the delegate is deallocated, delegate will be set to nil, preventing a retain cycle.\n\nAn example of using unowned references is when you have a tightly coupled parent-child relationship:\n\nIn this case, the CreditCard object has an unowned reference to Person, its holder, because a credit card should not exist without its holder. The unowned reference ensures that the CreditCard does not increase the reference count of Person, but if Person is deallocated, accessing holder would cause a crash.\n\nIn this article, we explored the concepts of weak and unowned references in Swift and their crucial roles in managing memory effectively. Both weak and unowned references help break strong reference cycles, but they differ in their handling of memory safety and the risk of runtime crashes. Weak references are best suited for scenarios where the referenced object can be deallocated, as they safely become nil when this occurs. On the other hand, unowned references are used when there is a guaranteed relationship between objects, where the referenced instance is expected to always exist.\n\nUnderstanding the differences in \"unowned vs weak Swift\" is essential for making informed decisions about memory management. By applying the best practices highlighted in this article, you can write safer, more efficient Swift code, reducing the risk of memory leaks and ensuring optimal app performance.\n\nShort on time? Speed things up with DhiWise!\n\nTired of manually designing screens, coding on weekends, and technical debt? Let DhiWise handle it for you!\n\nYou can build an e-commerce store, healthcare app, portfolio, blogging website, social media or admin panel right away. Use our library of 40+ pre-built free templates to create your first application using DhiWise."
    },
    {
        "link": "https://stackoverflow.com/questions/68784936/swift-keeping-a-strong-reference-to-a-weak-variable",
        "document": "I have a class with a weak reference to its delegate. In a background operation, I need to set the delegate, perform an operation on the class, and then have the delegate released.\n\nThe code below works in Debug mode, but fails in Release mode, because in Release mode the delegate is released right away.\n\nI assumed that the last instruction would cause the compiler to keep the delegate around until then (i.e. the \"last\" time the variable is used). However, thinking about it, it does make sense that the compiler optimizes the code and releases the delegate instance right away, since there are no other strong references.\n\nHowever, I do not understand why the compiler does not behave the same way in the second case when using \"let\". Here as well the compiler could see that the delegate is not referenced via a strong reference anywhere else, but it does keep it around until the end of the block.\n\nWhat would be a good way to think about this and what is a good way to keep a strong reference to the weak delegate?"
    },
    {
        "link": "https://forums.swift.org/t/pitch-weak-method-storage-modifiers-aka-weak-references/12161",
        "document": "Swift made functions first-class citizens. This means we can get references to functions and assign them to variables or pass them around as parameters to other functions. This is great. The downside is that, as with any other reference, function references can cause retain cycles. Specially class method references which can easily create strong references to . This is a common problem that many Swift developers have had to learn the hard way [1, 2]. Existing solutions\n\n Swift provides solutions to prevent retain cycles for both class properties (members) and closures:\n• Properties can be declared as optionals.\n• Closures can use (also ) However, Swift does not provide any support for weak method references when assigned to strong properties or when passed as arguments. I would like to submit a proposal to add this feature to the language, but first I thought of pitching it here to see if there was any support or no support at all. Examples\n\n The following is a basic example of a retain cycle caused by using a method reference which turns into a strong reference to : import Foundation class MyClass { var foo: () -> Void = {} init() { foo = defaultFoo } private func defaultFoo() { print(\"Foo Bar\") } deinit { print(\"Released 🎉\") } } MyClass().foo() // prints \"Foo Bar\" but instance is never released Proposed (pitched) solution\n\n Add to the language support for using the keyword for method references: I have no idea how feasible this is, but I believe in most cases this could be implemented syntax sugar for a closure with . Thank you for your time.\n\n Eneko\n\nI won't try to answer two language design questions here because honestly I don't have any good answers:\n• Whether introducing (and presumably and ) in this location in the grammar creates any ambiguities for parsing and semantic analysis\n• Whether this feature is desirable However from an implementation standpoint I don't forsee any difficulties with adding something like this. I would assume that the formal type of such a weak-self closure would return an Optional of the method's original return type, with the call evaluating to nil if the weak reference has already expired. With an unowned self capture, it could be an IUO (or force inside the closure body?) Also another minor suggestion, I think this would apply not only to classes, but to the inside protocol extensions where the protocol is class-constrained. Also, we allow method references to be formed with 'super.foo' as well, or in fact any non-self value. So I would generalize this pitch to allow creating such a closure with any class-like base expression, not just .\n\nThis is not an entirely new pitch, because I already pitched it a while ago but never pursued it that much after @anandabits pointed me at his proposal that needs some revisiting. I initially asked about that on Twitter: Then there is this thread converted from the mailing list: Hello Evolution, I’d like to pitch a new idea and see where it would go. Recently I tapped into a small trap and just now realized that even that non-escaping should have been the default for closures (SE–0103) there is an exception for that. Apparently generics don’t follow that rule and a closure like Optional<() -> Void> or simply (() -> Void)? is still escaping by default. But that was the half of the story yet. As we all know and “love” reference lists inside closures, methods don’t have… I've been bitten by this issue too so I know how it feels like, and this is exactly why I don't like the implicit in generic context (Optional is just one of them). My pitch was all about invalidating a weak closure when the captured reference are no longer available or use the unowned closure on own risk with an assumption that it will not fail. At the same time it would avoid retain-cycles.\n\nNo. AFAICT, the semantics of strong/weak in Swift are currently the same as the semantics of strong/weak in Objective-C. In Obj-C-land (and in this thread too, I believe) there is a persistent — almost irresistible, apparently — misconception that there are things known as strong and weak references. This isn't true, there are only strong and weak storage modifiers (i.e. for variables and stored properties). A \"strong\" variable holds an owning reference to some other object. A \"weak\" variable holds a non-owning reference. But there is no difference in the references themselves. You can't tell which \"kind\" it is by looking only at the reference. Rather, you need to know what kind of variable it is stored in. Hence Chris's suggestion, that should become an allowable modifier for declarations of function type. That's all that's needed to resolve the reference cycle problem. The alternative solution was something along the lines of a \"strong\" variable referencing a closure that captures weakly, and that's the design that \"doesn't make sense\".\n\nI haven’t thought deeply about this, but my off-the-cuff behavior is that a weak reference to a closure leads to weak references to any closed-over state (e.g. the self argument of a method). The closure would be deallocated if any of the closed over state is deallocated. Interesting. It seems to me like this approach might lead to confusion about the behavior of capture specifiers because it allows a library to effectively turn every capture into a weak capture. For example, somebody might write a type that exposes an method and stores the closures with weak references with the idea that users won't need to specify . If this style of API became common people may begin to think less about how they capture objects. It also introduces the need for libraries to document how they store closures and for users to be aware of the semantics the library uses. It would probably lead to requests to introduce a capture specifier (name intentionally awkward) that is strong even in the presence of a weak reference to the closure. I gave some thought to this problem space last year and was heading in the direction of introducing guarded closures. I was working on a second draft incorporating some of the feedback from that thread when I decided to set it aside. This design makes capture semantics clear at the declaration site of the closure but supports an \"inverted\" default that is sugar for closures that (mostly) capture with a on the weak captures at the beginning of the closure. It also allows an API to \"invert\" the default by using instead of , requiring users to provide a guarded closure. Users would still be able to use explicit captures where necessary. I recently started a new thread for guarded closures when the topic came up in The Future Of [weak self] Rebinding. It's clear that there is a lot of interest in doing something in this area. It's less clear what the right balance is.\n\nIn the long term, I would like to push these unapplied/partially-applied method references into the same basic syntax that key paths currently use, so that e.g. you can write and get a function back whose parameters depend on how much you fill in. That is a syntax which gives us a lot more room to incorporate things like or modifiers, as opposed to having to contort the general expression grammar to support them and then retroactively forbid them when an expression is fully-applied. But the semantic question of what the function actually does when the captures have gone away is still quite open. I don't think it's a good idea to add a general ability to ask whether any of the captures of an arbitrary function value have been destroyed."
    }
]