[
    {
        "link": "https://github.com/caiorss/Functional-Programming/blob/master/scheme/README.org",
        "document": "\n• Lisp is used as embedded script language in many products\n• Scheme is used as extension language of softwares like GIMP and GnuCash\n• Scheme can be used to test JVM and .NET API in the REPL.\n• Google App Engine Uses Kawa scheme which is a implementations for the JVM.\n• What Scheme implementations are there?\n• About Scheme implementations - The Adventures of a Pythonista in Schemeland\n\nScheme uses prefix notation, or polish notation. Every operator like +,-,* is a function.\n\nSpecial forms are statements that are not functions like if, then, else, begin, define …\n\nBind a name to a value or function (procedure).\n• if then else\n\nThe begin statement is used to execute multiple s-expressions.\n\nDon’t evaluate a lisp expression, returns the list of symbols, numbers and atoms that forms the list, or in other words, any lisp expression is just a list.\n\nEval evaluates a quoted lis expression, its arguments depends on the scheme implementation. It is better to use macros rather than eval. It is necessary to remember that “eval is evil” since it can allow untrusted code execute arbitrary commands so it must be used with care.\n\nNote: In some scheme implementations [] square brackets can be used instead of parenthesis to make the code more readable.\n\nScheme lists are linked lists with sequential access to any element.\n\nVectors are equivalent to C-arrays, are linear data structures of fixed size with random access to any element.\n\nScheme is dynamic typed language therefore there is not guarantee about the variable type or the function type signature. The types can be checked with the following predicates.\n\nThe keyword let* is equivalent to a nested let.\n\nLetrec allows to implement loops or loops with recursive anonymous functions.\n\nExample2: Loop over a list and find the sum of all elements:\n\nIn Scheme functions are first class, they can be passed as arguments to other functions and be returned from another functions, in other words, functions are data.\n\nAnonymous functions are useful to pass functions as arguments to other functions, callbacks and connect one function to another.\n\nThe Scheme operators are functions of two arguments and are written in the infix notation, also known as polish notation.\n• car - It selects the first element, “head” of a list cell\n• cdr - It selects the “tail” of a list, removes the first element\n• caddr - It gets the second element of a list\n• caddr - It gets the third element of a list\n• cadddr - It gets the forth element of alist.\n• cddr - Removes the first two elements of a list.\n• cdddr - Removes the first three elements of a list.\n\nAll the functions defined are in the file: hof_functions.scm that can be loaded in scheme by typing:\n\nSimilar to map, however it used for functions with side effects.\n\nReturns a functions that takes a list of functions and applies it to a single value.\n\nSimilar to Ocaml function mapi, map a function of index and value each index and element of a list.\n\nTake while and Drop While\n\nObjects can be implemented with closures as can be seen in:\n• FP, OO and relations. Does anyone trump the others?\n\nMetaprogramming is the ability to create that code that writes code. Like any lisp scheme has great metaprogramming capabilities like:\n• Code is data and data is code\n• Exposes the AST abstract syntax tree, that is an atom (symbol, string or a number) or a list\n• The AST is a list of lists and atoms or a single atom\n• The AST can be manipulated like any list\n• The macro system allows the user to create new syntax rules and create new language constructs.\n\nMacros allows to redefine the synxtax, create new language constructs, expand the language and create DSL - Domain Specific Languages.\n\nNote: all the macros bellow were tested on GNU GUILE that was started with the command:\n\nPrint Variable name and value\n\nApplies a sequence of methods to a object and returns the object modified by the methods.\n• There is no need to write specific parsers for configuration files.\n• S-expression parsers can be embedded in static typed languages like Ocaml, Haskell, Java to create GUIs, read configuration files.\n• Compact and flexible like XML and lightweight like json.\n\nThe examples bellow are in GNU Guile.\n• Uses a growing amount of stack frames, for a big number of iterations it can cause a stack overflow.\n• A function is said to be tail recursive when the recursive call is the last function executed in the body of the function.\n• It uses a fixed amount stack frame, therefore there is no risk of stack overflow.\n• It can be turned into loops\n• Sometimes non tail recursive functions can be changed to tail recursive by adding a new function with extra parameters (accumulators) to store partial results (state).\n\nIntegral of f from a to b\n\nThe sum procedure above generates a linear recursion. The procedure can be rewritten so that the sum is performed iteratively. Show how to do this by filling in the missing expressions in the following definition:\n\nSolution: The assignment is asking to turn the function sum into a tail recursive function.\n\na. The sum procedure is only the simplest of a vast number of similar abstractions that can be captured as higher-order procedures.51 Write an analogous procedure called product that returns the product of the values of a function at points over a given range. Show how to define factorial in terms of product. Also use product to compute approximations to using the formula 52.\n\nb. If your product procedure generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.\n\n.a .b The function below is already tail recursive ( iterative process).\n\na. Show that sum and product (exercise 1.31) are both special cases of a still more general notion called accumulate that combines a collection of terms, using some general accumulation function:\n\nAccumulate takes as arguments the same term and range specifications as sum and product, together with a combiner procedure (of two arguments) that specifies how the current term is to be combined with the accumulation of the preceding terms and a null-value that specifies what base value to use when the terms run out. Write accumulate and show how sum and product can both be defined as simple calls to accumulate.\n\nb. If your accumulate procedure generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.\n\na. b. It is already tail recursive.\n\nYou can obtain an even more general version of accumulate (exercise 1.32) by introducing the notion of a filter on the terms to be combined. That is, combine only those terms derived from values in the range that satisfy a specified condition. The resulting filtered-accumulate abstraction takes the same arguments as accumulate, together with an additional predicate of one argument that specifies the filter. Write filtered-accumulate as a procedure. Show how to express the following using filtered-accumulate:\n\na. the sum of the squares of the prime numbers in the interval a to b (assuming that you have a prime? predicate already written)\n\nb. the product of all the positive integers less than n that are relatively prime to n (i.e., all positive integers i < n such that GCD(i,n) = 1).\n\nTask: Write an s-expression evaluator (prefix notation evaluator) in lisp without using eval function. This evaluator can be useful to execute untrusted code on a restricted environment.\n\nRacket, former known as PLT Scheme, is an extension of Scheme language that has multi OS support, IDE: Dr. Racket, debugger, package system and repository, great documentation, large library and a powerful ffi - Foreign Function Interface. Racket has also support to many languages like pure Scheme, typed racket and others.\n\nPrint expression in the screen with character “\n\n” at the end.\n\nExample: Parametric Equation of an Ellipse\n\nKawa Scheme is a implementation of the language in Java that can compile to Java bytecodes and has access to the Java API.\n• Can be embedded as scripting language for Java applications.\n• Can call Java API in the REPL, provides interactive Java development.\n• With some tricks can compile to Android “Java”, Dalvik VM.\n• The Adventures of a Pythonista in Schemeland\n• Structure and Interpretation of Computer Programs - SCIP / Abelson, Sussman, and Sussman.\n• Structure and Interpretation of Computer Programs - SCIP / Abelson, Sussman, and Sussman / Alternative Link\n• Structure and Interpretation of Computer Programs - Video Lectures by Hal Abelson and Gerald Jay Sussman\n• Structure and Interpretation of Classical Mechanics - Geral Jay Sussman and Jack Wisdom\n• How to Design Programs - by Felleisen, Findler, Flatt and Krishnamurthi\n• Beating the Average - The Secret Weapon - By Paul Graham\n• Why Structure and Interpretation of Computer Programs matters\n• [IBM - The art of metaprogramming, Part 1: Introduction to metaprogramming\n• Why should programmers care about currying in practice in Scheme?\n• The ActionScript Byte Code assembler / disassembler in PLT Scheme and Gauche\n• Why Scheme Shouldn’t Have An Official Object System\n• JRM’s Syntax-rules Primer for the Merely Eccentric\n• The Adventures of a Pythonista in Schemeland v0.1 documentation » Hygienic macros\n• Source-to-Source Compilation in Racket You Want it in Which Language?\n• Understanding the Haskell IO Monad. By Building a Toy Model in Scheme\n• Continuations by example: Exceptions, time-traveling search, generators, threads, and coroutines\n• Have some way to save the REPL state of Common Lisp or Scheme?\n• Ask news.YC: For the lisp experts - tell me how you learned the language.\n• Is Scheme as good as Common Lisp?"
    },
    {
        "link": "https://help.autodesk.com/view/ACD/2023/CHT?guid=GUID-A0459510-CE7A-4206-9EAA-E25AAB569B20",
        "document": ""
    },
    {
        "link": "https://caiorss.github.io/Functional-Programming/scheme/README.html",
        "document": "Function that returns a value from a Lisp object Function that sets a value in a Lisp object Function that converts one type of Lisp object into another type Scheme uses prefix notation, or polish notation. Every operator like +,-,* is a function. Special forms are statements that are not functions like if, then, else, begin, define … Bind a name to a value or function (procedure).\n• if then else (if <condition> <then statement>) (if <condition> <then statement> <else statement>) > (if (zero? 4) \"zero\" \"not zero\") $5 = \"not zero\" > (if (zero? 4) \"zero\") > (if (zero? 0) \"zero\") $7 = \"zero\" (cond (<condition 1> <action1>) (<condition 2> <action12) ... (else <action else>)) ;; Optional > (define x 10) > x $15 = 10 > (cond ((zero? x) \"is zero\") ((< x 3) \"Less than 3\") ((< x 5) \"Less than 5\") ((< x 9) \"Less than 9\") (else \"Greater or equal 9\")) $16 = \"Greater or equal 9\" ;;; Returns nothing ;; (define x 100) > (cond ((zero? x) \"is zero\") ((< x 3) \"Less than 3\") ((< x 5) \"Less than 5\") ((< x 9) \"Less than 9\")) > The begin statement is used to execute multiple s-expressions. Don't evaluate a lisp expression, returns the list of symbols, numbers and atoms that forms the list, or in other words, any lisp expression is just a list. quote Or ' > ' exp 3.0 $11 = exp 3.0 > quote exp 3.0 $12 = exp 3.0 > eval ' exp 3.0 interaction-environment $15 = 20.08553692318766 $16 = 20.085536923187668 > ' 1 2 3 4 5 $13 = 1 2 3 4 5 > quote 1 2 3 4 5 $14 = 1 2 3 4 5 > eval ' 1 2 3 4 5 interaction-environment : In procedure 1: : Wrong type to apply: 1 Eval evaluates a quoted lis expression, its arguments depends on the scheme implementation. It is better to use macros rather than eval. It is necessary to remember that \"eval is evil\" since it can allow untrusted code execute arbitrary commands so it must be used with care. Note: In some scheme implementations [] square brackets can be used instead of parenthesis to make the code more readable. 1 ]=> 'mysymbol ;Value: mysymbol 1 ]=> (quote mysymbol) ;Value: mysymbol Scheme lists are linked lists with sequential access to any element. 1 => ' 23.23 1000 40 50 102 1 => ' 1 => ' hello world scheme 1 => quote hello world symbols 1 => ' + 10 2 1 => quote + sin 0.4 cos 0.01 1 => quote 1 2 3 4 5 6 Vectors are equivalent to C-arrays, are linear data structures of fixed size with random access to any element. 1 => # a b c d e 1 => vector-ref # a b c d e 0 1 => vector-ref # a b c d e 4 Scheme is dynamic typed language therefore there is not guarantee about the variable type or the function type signature. The types can be checked with the following predicates.\n• let*\n\n The keyword let* is equivalent to a nested let. $ rlwrap -c --remember csi CHICKEN c 2008-2015, The CHICKEN Team c 2000-2007, Felix L. Winkelmann Version 4.10.0 rev b259631 linux-unix-gnu-x86 manyargs dload ptables compiled 2015-08-04 on yves.more-magic.net Linux > x 10 y + x 40 z * y x f a * a 3 f + x y z Error: unbound variable: x > x 10 y + x 40 z * y x f a * a 3 f + x y z 1680 > > x 10 y + x 40 z * y x f a * a 3 f + x y z 1680\n• letrec\n\n Letrec allows to implement loops or loops with recursive anonymous functions. Example2: Loop over a list and find the sum of all elements: In Scheme functions are first class, they can be passed as arguments to other functions and be returned from another functions, in other words, functions are data. Anonymous functions are useful to pass functions as arguments to other functions, callbacks and connect one function to another. The Scheme operators are functions of two arguments and are written in the infix notation, also known as polish notation. $ rlwrap scheme MIT/GNU Scheme running under GNU/Linux Type `^C' control-C followed by `H' to obtain information about interrupts. Copyright C 2011 Massachusetts Institute of Technology This is free software warranty Image saved on Tuesday October 22, 2013 at 12:31:09 PM Release 9.1.1 Microcode 15.3 Runtime 15.7 SF 4.41 LIAR/i386 4.118 Edwin 3.116 => => + 10 20 => + 1 2 3 4 5 6 => * 3 5 => * 1 2 3 4 5 6 => / 10 20 => / 10.0 20.0 1 => / 29 3 1 => / 29 3 7 1 => / 29 3 7 2 1 => exact->inexact / 29 3 7 2 => - 10 20 => 1 => + * 3 4 / 8 4 * -3 5 Test if non numeric values are equal Check if the two objects represents the same location in memory The return value depends on implementation. $ rlwrap -c --remember csi CHICKEN c 2008-2015, The CHICKEN Team c 2000-2007, Felix L. Winkelmann Version 4.10.0 rev b259631 linux-unix-gnu-x86 manyargs dload ptables compiled 2015-08-04 on yves.more-magic.net Linux > = 'symbol1 'symbol2 Error: = bad argument type: symbol1 = 100 100 #t > = 10 1 #f > > eq? 'a-symbol 'a-symbol #t > eq? 'a-symbol 'a-symb #f > > eq? 10 10 #t > eq? 10 10.0 #f > eq? 10.0 10.0 #f > > eq? 10 > eq? #f > > eq? list 1 'symbol1 list 1 'symbol1 #f > > eq? ' ' #t > > eqv? 'symbol1 'symbol1 #t > > eqv? 10.0 10.0 #t > > eqv? ' ' #t > > eqv? #f > > eqv? list 1 'symbol1 list 1 'symbol1 #f > = list 1 'symbol1 list 'symbol1 Error: = bad argument type: 1 symbol1 > equal? list 1 'symbol1 list 1 'symbol1 #t > > equal? #t > > ' 1 2.23 1e3 hello world lisp 2 5 $55 = 1 2.23 1000.0 hello world lisp 2 5 > ' a b c d e $56 = a b c d e 1 2 10 'a-symbol 'theta > list x y z w $61 = 1 2 theta a-symbol list 'x x 'y y 'z z 'w w $62 = x 1 y 2 z theta w a-symbol > list cons 'x x cons 'y y cons 'z z $66 = x . 1 y . 2 z . theta > ` the product of 3 and 4 is , * 3 4 $106 = the product of 3 and 4 is 12 > ` \"the product of 3 and 4 is\" , * 3 4 $107 = \"the product of 3 and 4 is\" 12 ' 1 2 3 ' a b c > ` x ,x y ,y z ,z $69 = x 1 y 2 z theta > ` x ,x y ,y z ,z $71 = x 1 y 2 z theta > ` x ,x y ,y z ,z ,@xs $72 = x 1 y 2 z theta 1 2 3 > ` x ,x y ,y z ,z ,@xs ,@ys $73 = x 1 y 2 z theta 1 2 3 a b c > ` x ,x y ,y z ,z xs ,@xs ys ,@ys $74 = x 1 y 2 z theta xs 1 2 3 ys a b c > ` x ,x y ,y z ,z xs ,xs ys ,ys $92 = x 1 y 2 z theta xs 1 2 3 ys a b c > ` x ,x y ,y , > 2 x w z $77 = x 1 y 2 a-symbol > ` x ,x y ,y , < 2 x w z $78 = x 1 y 2 theta > ` x ,x y ,y , < 2 x ` w ,w ` z ,z $79 = x 1 y 2 z theta > ` x ,x y ,y , > 5 x ` w ,w ` z ,z $80 = x 1 y 2 w a-symbol > ` x ,x y ,y > 5 x w ,w z ,z $82 = x 1 y 2 > 5 x w a-symbol z theta list cons 'f1 f1 cons 'f2 f2 cons 'f3 f3 $83 = f1 . #<procedure f1 x > f2 . #<procedure f2 x > f3 . #<procedure f3 x > x * 2 x x + x 5 x + 2 * 6 x x f f x > list f1 f2 f3 $64 = #<procedure f1 x > #<procedure f2 x > #<procedure f3 x > > call-with 5 list f1 f2 f3 $65 = 10 10 32 > list cons 'f1 f1 cons 'f2 f2 cons 'f3 f3 $83 = f1 . #<procedure f1 x > f2 . #<procedure f2 x > f3 . #<procedure f3 x > > cdr assoc 'f1 list cons 'f1 f1 cons 'f2 f2 cons 'f3 f3 $85 = #<procedure f1 x > cdr assoc 'f2 list cons 'f1 f1 cons 'f2 f2 cons 'f3 f3 $86 = #<procedure f2 x > > cdr assoc 'f2 list cons 'f1 f1 cons 'f2 f2 cons 'f3 f3 10 $88 = 15 > key arg cdr assoc key list cons 'f1 f1 cons 'f2 f2 cons 'f3 f3 arg > f-dispatch 'f1 5 $89 = 10 > f-dispatch 'f2 5 $90 = 10 > f-dispatch 'f3 5 $91 = 32 > ' + 1 2 3 4 5 $75 = + 1 2 3 4 5 > eval ' + 1 2 3 4 5 interaction-environment $76 = 15\n• car - It selects the first element, \"head\" of a list cell\n• cdr - It selects the \"tail\" of a list, removes the first element\n• caddr - It gets the second element of a list\n• caddr - It gets the third element of a list\n• cadddr - It gets the forth element of alist.\n• cddr - Removes the first two elements of a list.\n• cdddr - Removes the first three elements of a list.\n\nAll the functions defined are in the file: hof_functions.scm that can be loaded in scheme by typing: Similar to map, however it used for functions with side effects. a b c sqrt + * a a * b b * c c > hypot3d 3 4 5 7.07106781186548 > apply hypot3d ' 3 4 5 7.07106781186548 > f list-of-args x apply f x list-of-args > map-apply hypot3d ' 1 2 3 3 4 5 6 7 8 3.74165738677394 7.07106781186548 12.2065556157337 Returns a functions that takes a list of functions and applies it to a single value. n xs acc zero? n ' null? xs cycle_aux - n 1 acc acc cons car xs cycle_aux - n 1 cdr xs acc 1 => cycle_aux 10 ' 1 2 3 ' 1 2 3 $16 = 1 2 3 1 2 3 1 2 1 => cycle_aux 20 ' 1 2 3 ' 1 2 3 $17 = 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 n xs cycle_aux n xs xs 1 => cycle 10 ' a b c $18 = a b c a b c a b 1 => cycle 20 ' 0 1 $19 = 0 1 0 1 0 1 0 1 0 1 0 1 0 1 Similar to Ocaml function mapi, map a function of index and value each index and element of a list. n alist null? alist = n 0 ' cons car alist take - n 1 cdr alist 1 => take 10 ' 1 => take 3 ' 1 2 3 4 5 6 1 => take 4 ' 1 2 3 4 5 6 1 => take 100 ' 1 2 3 4 5 6 1 => n alist null? alist = n 0 alist drop - n 1 cdr alist 1 => drop 3 ' 1 2 3 4 5 6 1 => drop 5 ' 1 2 3 4 5 6 1 => drop 15 ' 1 2 3 4 5 6 1 => drop 15 ' 1 => Take while and Drop While list1 list2 null? list1 null? list2 ' cons list car list1 car list2 zip2 cdr list1 cdr list2 1 => zip2 ' ' 1 => zip2 ' ' 1 2 3 4 1 => zip2 ' 1 2 3 4 5 ' 1 => zip2 ' 1 2 3 4 5 ' a b c d e f g i j l m n 1 => predicate alist null? alist #f predicate car alist #t any predicate cdr alist 1 => any x > x 10 ' -3 4 5 8 9 $1 = #f 1 => any x > x 10 ' -3 10 4 5 8 20 9 $2 = #t 1 => any x > x 10 ' $3 = #f 1 => any null? list ' 1 2 ' 3 5 $5 = #f 1 => any null? list ' 1 2 ' 3 5 ' $6 = #t list-of-lists any null? list-of-lists ' cons car list-of-lists zip_aux cdr list-of-lists . lists zip_aux lists 1 => zip_aux list ' 1 2 3 4 5 ' a b c d e f g h ' $7 = 1 a 2 b 3 c 4 d 1 => zip ' 1 2 3 4 5 ' a b c d e f g h ' $7 = 1 a 2 b 3 c 4 d list-of-pairs null? list-of-pairs ' list car list-of-pairs xy car cdr xy list-of-pairs 1 => ' 1 a 2 b 3 c 4 d 1 => xys $9 = 1 a 2 b 3 c 4 d 1 => unzip2 xys $11 = 1 2 3 4 a b c d f_el_acc acc alist null? alist acc f_el_acc car alist foldr f_el_acc acc cdr alist car xs car cdr xs list-of-pairs null? list-of-pairs ' foldr xy xys list cons fst xy fst xys cons snd xy snd xys list ' ' list-of-pairs 1 => unzip2f ' 1 a 2 b 3 c 4 d $24 = 1 2 3 4 a b c d 1 => unzip2f ' $25 = a x a alist x list x alist list-of-list null? list-of-list ' foldr t ts x cons car x car cdr x zip t ts constant ' list-of-list list-of-list . lists unzip lists 1 => unzip ' 1 2 3 11 10 20 30 40 50 $4 = 1 11 30 2 10 40 3 20 50 1 => unzip ' 1 a 230 b 1000 sym 434 con $5 = 1 230 1000 434 a b sym con 1 => unzip-v ' 1 2 3 ' 11 10 20 ' 30 40 50 $6 = 1 11 30 2 10 40 3 20 50 1 => unzip-v ' 1 a ' 230 b ' 1000 sym ' 434 con $7 = 1 230 1000 434 a b sym con\n\nMetaprogramming is the ability to create that code that writes code. Like any lisp scheme has great metaprogramming capabilities like:\n• Code is data and data is code\n• Exposes the AST abstract syntax tree, that is an atom (symbol, string or a number) or a list\n• The AST is a list of lists and atoms or a single atom\n• The AST can be manipulated like any list\n• The macro system allows the user to create new syntax rules and create new language constructs. Macros allows to redefine the synxtax, create new language constructs, expand the language and create DSL - Domain Specific Languages. Note: all the macros bellow were tested on GNU GUILE that was started with the command: define-syntax-rule $n pred args ... not pred args ... > list? ' 1 2 3 4 $1 = #t > $n list? ' 1 2 3 4 $2 = #f > ,expand $n list? 100 $4 = not list? 100 > ,expand $n or pair? x list? x $6 = not pair? x list? x define-syntax-rule thunk computation computation > thunk / 3 0 $9 = #<procedure 960e670 at <current input>:37:0 > > > thunk / 3 0 > t $10 = #<procedure t > > > t <unnamed port>:42:17: In procedure t: <unnamed port>:42:17: Throw to key `numerical-overflow' with args ` #f #f '. Entering a new prompt. Type `,bt' for a backtrace or `,q' to continue. > define-syntax-rule force-thunk computation computation > force-thunk t <unnamed port>:59:17: In procedure t: <unnamed port>:59:17: Throw to key `numerical-overflow' with args ` #f #f '. Entering a new prompt. Type `,bt' for a backtrace or `,q' to continue. > def name value value > def x 100 > ,expand def x 100 $10 = 100 > def f x y + * 3 x * 4 y > f 3 5 $11 = 29 > ,expand def f x y + * 3 x * 4 y $12 = x y + * 3 x * 4 y define-multi var val ... val ... define-multi a 10 b 200 c 300 d e 'a-symbol > a $13 = 10 > b $14 = 200 > c $15 = 300 > d $16 = > e $17 = a-symbol > ,expand define-multi a 10 b 200 c 300 d e 'a-symbol $4 = 10 200 300 'a-symbol Print Variable name and value _ var cons 'var var > ' it is all symbols list of symbols > x $36 = it is all symbols litst of symbols > 1 => show-var x 1 => define-assoc name sym value ... list cons sym value ... > define-assoc colors 'red 1 'blue 2 'white 3 'green 5 > colors $94 = red . 1 blue . 2 white . 3 green . 5 ,expand define-assoc colors 'red 1 'blue 2 'white 3 'green 5 $95 = list cons 'red 1 cons 'blue 2 cons 'white 3 cons 'green 5 assoc 'red colors $96 = red . 1 car assoc 'red colors $97 = red define-syntax-rule def name value value define-syntax-rule defn name params body ... . params body ... define-syntax-rule fn params body params body > def x 10 > x $2 = 10 > def xs ' a b c d e f > xs $3 = a b c d e f > defn f x y + * 3 x * 4 y > f 3 4 $4 = 25 > fn x + x 3 ' 1 2 3 4 5 6 $5 = 4 5 6 7 8 9 Applies a sequence of methods to a object and returns the object modified by the methods. define-syntax-rule dolist var alist body loop xs null? xs values var car xs body loop cdr xs loop alist > dolist i ' a b c d e display i display a b c d e > ,expand dolist i ' a b c d e display i display $8 = xs ' a b c d e null? xs values i car xs display i display loop cdr xs name args body ` ,name ,@args ,body name value ` ,name ,value defun f x y z + * 3 x * -4 y * 2 z > f 5 6 3 $119 = -3 > defvar x 10 > x $120 = 10 scheme@ guile-user 31 > > ,expand defun f x y z + * 3 x * -4 y * 2 z $121 = x y z + * 3 x * -4 y * 2 z > ,expand defvar x 10 $122 = 10 case-pred value predicate result ... predicate value result ... > case-pred -100 negative? positive? zero? $6 = > case-pred 100 negative? positive? zero? $7 = ,expand case-pred -100 negative? positive? zero? $8 = negative? -100 positive? -100 zero? -100 > ' negative? positive? zero? > body negative? positive? zero? > car body negative? positive? zero? > cadr body > row ` , car row value , cadr row body negative? value positive? value zero? value > row ` , car row ,value , cadr row body negative? 10 positive? 10 zero? 10 value body row ` , car row ,value , cadr row body > template 20 body negative? 20 positive? 20 zero? 20 > template 'x body negative? x positive? x zero? x > ` ,@ template 'x body negative? x positive? x zero? x value . body ` ,@ template value body > case-pred 10 negative? positive? zero? $2 = > case-pred -100 negative? positive? zero? $3 = Negative Positive Zero Negative Positive Zero\n\nThe examples bellow are in GNU Guile.\n• Uses a growing amount of stack frames, for a big number of iterations it can cause a stack overflow.\n• A function is said to be tail recursive when the recursive call is the last function executed in the body of the function.\n• It uses a fixed amount stack frame, therefore there is no risk of stack overflow.\n• It can be turned into loops\n• Sometimes non tail recursive functions can be changed to tail recursive by adding a new function with extra parameters (accumulators) to store partial results (state). n = n 0 = n 1 1 * n factorial - n 1 > factorial 10 $1 = 3628800 > > factorial 20000000 warnings can be silenced by the --no-warnings -n option Aborted core dumped > ,trace factorial 5 : # #<directory guile-user 95c3630> factorial : #<procedure 9953350 at <current input>:8:7 > : factorial 5 : factorial 2 : factorial 1 : 1 : 24 : 120 > > ,trace factorial 10 : # #<directory guile-user 95c3630> factorial : #<procedure 9880800 at <current input>:6:7 > : factorial 10 : factorial 7 : factorial 6 : factorial 3 : factorial 2 : 1 : 2 : 120 : 720 : 362880 : 3628800 > n acc = n 0 = n 1 acc factorial-aux - n 1 * n acc > factorial-aux 5 1 $1 = 120 > > factorial-aux 10 1 $2 = 3628800 > > n factorial-aux n 1 > factorial2 5 $3 = 120 > factorial2 10 $4 = 3628800 > > ,trace factorial-aux 5 1 : # #<directory guile-user 82ca630> factorial-aux : #<procedure 85eb910 at <current input>:10:7 > : factorial-aux 5 1 : factorial-aux 4 5 : factorial-aux 3 20 : factorial-aux 2 60 : factorial-aux 1 120 : 120 > > ,trace factorial-aux 10 1 : # #<directory guile-user 82ca630> factorial-aux : #<procedure 8657a00 at <current input>:13:7 > : factorial-aux 10 1 : factorial-aux 9 10 : factorial-aux 8 90 : factorial-aux 7 720 : factorial-aux 6 5040 : factorial-aux 5 30240 : factorial-aux 4 151200 : factorial-aux 3 604800 : factorial-aux 2 1814400 : factorial-aux 1 3628800 : 3628800 > n n acc = n 0 = n 1 acc factorial-aux - n 1 * n acc factorial-aux n 1 > factorial3 4 $2 = 24 > factorial3 5 $3 = 120 > factorial3 10 $4 = 3628800 > a b > a b 0 + a sum-ints + a 1 b > sum-ints 1 10 $5 = 55 > sum-ints 1 100 $6 = 5050 > > sum-ints 1 10000 > <unnamed port>:4:13: In procedure sum-ints: <unnamed port>:4:13: Throw to key `vm-error' with args ` vm-run '. > ,trace sum-ints 1 10 : # #<directory guile-user a00e630> sum-ints : #<procedure a41abc0 at <current input>:10:7 > : sum-ints 1 10 : sum-ints 4 10 : sum-ints 5 10 : sum-ints 8 10 : sum-ints 9 10 : 10 : 19 : 40 : 45 : 54 : 55 > a b acc > a b acc sum-ints-aux + a 1 b + a acc > sum-ints-aux 1 10 0 $4 = 55 > > sum-ints-aux 1 10000 0 $5 = 50005000 > > ,trace sum-ints-aux 1 10 0 : # #<directory guile-user 93fd630> sum-ints-aux : #<procedure 98646a0 at <current input>:31:7 > : sum-ints-aux 1 10 0 : sum-ints-aux 2 10 1 : sum-ints-aux 3 10 3 : sum-ints-aux 4 10 6 : sum-ints-aux 5 10 10 : sum-ints-aux 6 10 15 : sum-ints-aux 7 10 21 : sum-ints-aux 8 10 28 : sum-ints-aux 9 10 36 : sum-ints-aux 10 10 45 : sum-ints-aux 11 10 55 : 55 > a b a b acc > a b acc sum-ints-aux + a 1 b + a acc sum-ints-aux a b 0 > sum-ints-safe 1 10 $6 = 55 > sum-ints-safe 1 100 $7 = 5050 > > sum-ints-safe 1 10000 $8 = 50005000 > > sum-ints-safe 1 100000 > $9 = 5000050000 > term next term next a b > a b 0 + term a summation_ term next next a b a b summation_ term next a b summation x * x x x n + n 1 scheme@ guile-user > sum-cubes 1 10 $1 = 3025 scheme@ guile-user > summation x x n + n 1 scheme@ guile-user 1 > sum-integers 1 10 $2 = 55 summation x / 1.0 * x + x 2 x + x 4 scheme@ guile-user 1 > * 8 pi-sum 1 1000 $4 = 3.139592655589783 Integral of f from a to b f dx a b * dx summation f x + x dx + a / dx 2.0 b scheme@ guile-user 1 > x * x x x scheme@ guile-user 1 > integral cube 0.01 scheme@ guile-user > integral-cube 0 1 $2 = 0.24998750000000042 scheme@ guile-user > scheme@ guile-user > integral cube 0.001 0 1 $3 = 0.249999875000001 scheme@ guile-user 1 > integral cube 0.001 0 1 $1 = 0.249999875000001 scheme@ guile-user 1 > integral cube 0.0001 0 1 <unnamed port>:8:37: In procedure summation_: <unnamed port>:8:37: Throw to key `vm-error' with args ` vm-run '. Entering a new prompt. Type `,bt' for a backtrace or `,q' to continue. scheme@ guile-user 2 > integral cube 0.00001 0 1 : warning: guile crashed, killed by SIGABRT core dumped . rlwrap itself has not crashed, but for transparency, it will now kill itself with the same signal warnings can be silenced by the --no-warnings -n option Aborted core dumped 0.0001 v1 v2 < abs - v1 v2 tolerance f first-guess guess next f guess close-enough? guess next next try next try first-guess > fixed-point cos 1.0 > The sum procedure above generates a linear recursion. The procedure can be rewritten so that the sum is performed iteratively. Show how to do this by filling in the missing expressions in the following definition: Solution: The assignment is asking to turn the function sum into a tail recursive function. term a next b a result > a b result iter next a + term a result iter a 0 > n + n 1 > n * n n n > > a b > sum cube a inc b > > sum-cubes 1 10 $13 = 3025 > > ,trace sum cube 1 inc 4 : # #<directory guile-user 955f630> sum cube inc : #<procedure 9ce4910 at <current input>:72:7 > : sum #<procedure cube n > 1 #<procedure inc n > 4 : 2 : 1 : 3 : 8 : 4 : 27 : 5 : 64 : 100 > a. The sum procedure is only the simplest of a vast number of similar abstractions that can be captured as higher-order procedures.51 Write an analogous procedure called product that returns the product of the values of a function at points over a given range. Show how to define factorial in terms of product. Also use product to compute approximations to using the formula 52. b. If your product procedure generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process. .a .b The function below is already tail recursive ( iterative process). term a next b a result > a b result iter next a * term a result iter a 1 > n n > n + n 1 > > product id 1 inc 5 $24 = 120 > > n product id 1 inc n > factorial 5 $25 = 120 > factorial 6 $26 = 720 > a. Show that sum and product (exercise 1.31) are both special cases of a still more general notion called accumulate that combines a collection of terms, using some general accumulation function: Accumulate takes as arguments the same term and range specifications as sum and product, together with a combiner procedure (of two arguments) that specifies how the current term is to be combined with the accumulation of the preceding terms and a null-value that specifies what base value to use when the terms run out. Write accumulate and show how sum and product can both be defined as simple calls to accumulate. b. If your accumulate procedure generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process. a. b. It is already tail recursive. combiner null-value term a next b a result > a b result iter next a combiner term a result iter a null-value > term a next b accumulate + 0 term a next b > term a next b accumulate * 1 term a next b > > n + n 1 > n * n n n > n n > > a b sum cube a inc b > sum-cubes 1 10 $1 = 3025 > > n product id 1 inc n > factorial 5 $2 = 120 > factorial 6 $3 = 720 > You can obtain an even more general version of accumulate (exercise 1.32) by introducing the notion of a filter on the terms to be combined. That is, combine only those terms derived from values in the range that satisfy a specified condition. The resulting filtered-accumulate abstraction takes the same arguments as accumulate, together with an additional predicate of one argument that specifies the filter. Write filtered-accumulate as a procedure. Show how to express the following using filtered-accumulate: a. the sum of the squares of the prime numbers in the interval a to b (assuming that you have a prime? predicate already written) b. the product of all the positive integers less than n that are relatively prime to n (i.e., all positive integers i < n such that GCD(i,n) = 1). combiner null-value term a next b pred? a result > a b result iter next a pred? a combiner term a result result iter a null-value n i = 0 modulo n i a b step > a b ' cons a range + a step b step n null? filter divisor? n range 2 - n 1 1 > filter prime? range 1 100 1 $8 = 1 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 > n + n 1 n * n n n n a b filtered-accumulate + 0 square a inc b prime? > sum-of-square-primes 1 10 $9 = 88 > > sum-of-square-primes 1 100 $17 = 65797 > > filter prime? range 1 10 1 $10 = 1 2 3 5 7 > square filter prime? range 1 10 1 $11 = 1 4 9 25 49 > apply + square filter prime? range 1 10 1 $12 = 88 > > a b apply + square filter prime? range a b 1 > > sum-of-square-primes2 10 $14 = 88 > sum-of-square-primes2 1 100 $15 = 65797 > n i = gcd i n 1 n filtered-accumulate * 1 id 1 inc - n 1 relprime? n > filter relprime? 18 range 1 18 1 $22 = 1 5 7 11 13 17 > apply * filter relprime? 18 range 1 18 1 $23 = 85085 > > product-primes 18 $24 = 85085 >"
    },
    {
        "link": "https://scispace.com/pdf/an-implementation-of-python-for-racket-1hgzt11u8u.pdf",
        "document": ""
    },
    {
        "link": "https://help.autodesk.com/view/OARX/2025/ENU?guid=GUID-265AADB3-FB89-4D34-AA9D-6ADF70FF7D4B",
        "document": ""
    },
    {
        "link": "https://forums.autodesk.com/t5/visual-lisp-autolisp-and-general/plotting-using-vla-commands/td-p/7996063",
        "document": "I am using AutoCAD 2017 32bit on a 64bit computer. The software has been converted using the LongBow conversion software.\n\nThe code below runs until it gets to the line marked ** it then errors out with the following error message\n\nThe (vl_bt) returns the following backtrace\n\nThe syntax seems to be correct, anybody experience anything like this?"
    },
    {
        "link": "https://documentation.help/AutoCAD-ALISP-VLISP/WS73099cc142f4875516d84be10ebc87a53f-7bf6.htm",
        "document": "Arrays passed to ActiveX methods must be of the safearray type. These arrays are safe because you cannot accidentally assign values outside the array bounds and cause a data exception to occur. Use the vlax-make-safearray function to create a safearray and use vlax-safearray-put-element or vlax-safearray-fill to populate a safearray with data.\n\nThe vlax-make-safearray function requires a minimum of two arguments. The first argument identifies the type of data that will be stored in the array. Specify one of the following constants for the data type:\n\nThe constants evaluate to integer values. Because the integer values can change, you should always refer to the constant, not the integer value. See the entry for vlax-make-safearray in the AutoLISP Reference for the current integer value assigned to each constant.\n\nThe remaining arguments to vlax-make-safearray specify the upper and lower bounds of each dimension of the array. You can create single or multidimensional arrays with vlax-make-safearray. The lower bound for an index can be zero or any positive or negative integer.\n\nFor example, the following function call creates a single-dimension array consisting of doubles, with a starting index of 0:\n\nThe upper bound specified in this example is 2, so the array will hold three elements (element 0, element 1, and element 2).\n\nDifferent dimensions can have different bounds. For example, the following function call creates a two-dimension array of strings. The first dimension starts at index 0 and contains two elements, while the second dimension starts at index 1 and contains three elements:\n\nYou can use either vlax-safearray-fill or vlax-safearray-put-element to populate arrays with data.\n\nThe vlax-safearray-fill function requires two arguments: the variable containing the array you are populating and a list of the values to be assigned to the array elements. You must specify as many values as there are elements in the array. For example, the following code populates a single-dimension array of three doubles: You can display the contents of this array in list form with the vlax-safear-ray->list function: If you do not specify a value for every element in the array, vlax-safear-ray-fill results in an error. To assign values to a multi-dimensional array, specify a list of lists to vlax-safearray-fill, with each list corresponding to a dimension. For example, the following command assigns values to a two-dimension array of strings that contains three elements in each dimension: Use the vlax-safearray->list function to confirm the contents of mat2:\n\nThe vlax-safearray-put-element function can be used to assign values to one or more elements of a safearray. The number of arguments required by this function depends on the number of dimensions in the array. The following rules apply to specifying arguments to vlax-safearray-put-element:\n• The first argument always names the safearray to which you are assigning a value.\n• The next set of arguments identifies index values pointing to the element to which you are assigning a value. For a single-dimension array, specify one index value; for a two-dimension array, specify two index values, and so on.\n• The final argument is always the value to be assigned to the safearray element. For example, the following code populates a single-dimension array of three doubles: To change the second element of the array to a value of 50, issue the following command: The following example populates a two-dimension array of strings. The first dimension of the array starts at index 0, while the second dimension starts at index 1: You can use vlax-safearray->list to confirm the contents of the array:"
    },
    {
        "link": "https://forums.autodesk.com/t5/visual-lisp-autolisp-and-general/lisp-user-form-and-data-array/td-p/11836610",
        "document": "I am NOT well versed in LISP. And I am somewhat familiar with VBA, having used it with Excel for a few years...\n\nA while ago, I needed to pull some information for some AutoCAD Solids, do some simple math (based on user input), and spit the results into a CSV. So I ended up accomplishing this with AutoCAD's VBA enabler (*.dvb). (descriptive PDF and ZIP with VBA code attached)\n\nEssentially what the VBA does is this:\n• get the geometric center of all selected SOLIDS from AutoCAD\n• put the geometric center information into an array\n• put the material properties into an array\n• do some math with the geometric array and the material array\n• spit out the results into a new array\n\nIs it possible to do that with LISP?...relatively easily? Any recommendations? Where to start?"
    },
    {
        "link": "https://afralisp.net/visual-lisp/tutorials/arrays.php",
        "document": "If you've programmed in VBA or other languages, you're probably familiar with the concept of arrays. An array is a named collection of variables of the same data type. Each array element can be distinguished from other elements by one or more integer indexes. For example, if the \"sheetNames\" array contains three names, you can set and return the names in VBA as shown in the following example :\n\nArrays allow you to group related variables in a way that makes it easier for you to keep track of, access, and manipulate them all at once, while still being able to access each variable individually. This helps you create smaller and simpler routines in many situations, because you can set up loops using index numbers to deal efficiently with any number of cases.\n\nWhen you create an array, its size is determined by the number of dimensions it has and the by the upper and lower bounds for the index numbers in each dimension. The \"sheetNames\" array in the earlier example has one dimension and three elements; the lower bound is 0 and the upper bound is 2.\n\n\"That's fine Kenny, but how do we create an Array in Visual Lisp?\"\n\nOK I hear you, there's no need to yell!\n\n Enter this at the Console prompt :\n\nHave a look at the \"sheet_ type\" variable in the Watch window :\n\nThis tells us that the Array contains strings, has one dimension and contains 3 elements. Let's convert it to an AutoLisp List :\n\nDid a light just go off in your head? An Array is just a List in a slightly different format. To create an Array, or safearray as they are know in Visual Lisp, we use the \"vlax-make-safearray\" function. To populate a safearray we use the \"vlax-safearray-fill\" or the \"vlax-safearray-put\" functions.\n\nThe \"vlax-make-safearray\" function requires a minimum of two arguments. The first argument identifies the type of data that will be stored in the array.\n\n One of the following constants must be specified for the data type :\n\nThe remaining arguments to \"vlax-make-safearray\" specify the upper and lower bounds of each dimension of the array. The lower bound for an index can be zero or any positive or negative number. Have another look at the function we called earlier :\n\nThis function created a single-dimension array consisting of three strings with a starting index of 0 (element 0, element 1 and element 2).\n\n Consider this :\n\nThe lower bound specified in this example is one and the upper bound specified is three, so the array will hold three doubles (element 1, element 2 and element 3).\n\nThe \"vla-safearray-fill\" function requires two arguments: the variable containing the array you are populating and a list of the values to be assigned to the array elements. You must specify as many values as there are elements in the array or vla-safearray-fill\" results in an error.\n\n The following code populates a single-dimension array of three doubles :\n\nTo convert an array to an AutoLisp list, you can use the (vlax-safearray->list) function. Try it out :\n\nLet's create a Array with two dimensions, each dimension with three elements :\n\nThis is just a list of lists.\n\n The first list, is the number of dimensions.\n\n The second list, is the number of elements\n\nAnd now a three dimensional Array with two elements in each dimension :\n\nHere we have a list of three lists.\n\n This time, the first list defines three dimensions and the second defines 2 elements in each dimension.\n\nOne place you will be using \"vlax-safearray-fill\" is when creating selection sets with filters. The syntax in ActiveX for \"Selecting All with Filters\" is as follows :\n\nFilter_Code must be an Integer array and Filter_Value a Variant array.\n\n In Visual Lisp, the coding would be written like this :\n\nFor more information on Selections Sets, pop along to my \"Selection Sets\" tutorial page and get yourself even more confused.\n\nThe \"vlax-safearray-put-element\" function can be used to assign values to one or more elements of a safearray. The number of arguments required by this function depends on the number of dimensions in the array.\n• The first argument always names the safearray to which you are assigning a value.\n• The next set of arguments identifies index values pointing to the element to which you are assigning a value. For a single-dimension array, specify one index value: for a two-dimension array, specify two index values, and so on.\n• The final argument is always the value to be assigned to the safearray element.\n\nHave a look at the following :\n\nYou can use \"vlax-safearray-get-element\" to get the value of any element in any array. Here we'll use \"vlax-safearray-get-element\" to retrieve the second element in the first dimension of the array :\n\n(vlax-safearray-get-l-bound) returns the lower boundary (starting index) of a dimension of an array :\n\nGet the starting index value of the second dimension of the array :\n\nThe second dimension starts with index 1.\n\nConversley, \"vlax-safearray-get-u-bound\" returns the upper boundary (end index) of a dimension of an array\n\nGet the end index value of the second dimension of the array :\n\nThe second dimension ends with index 3.\n\nYou can use \"vlax-safearray-get-dim\" to get the number of dimensions in a safearray object :\n\nGet the number of dimensions in \"two_dim\" :\n\nThere are 2 dimensions in \"two_dim\".\n\nLet's have a look at putting some of this to good use :\n\nThere is an easier way of writing this routine :\n\nFor methods that require you to pass a three-element array of doubles (typically to specify a point), you can use the \"vlax-3d-point\" function.\n\nWell, that's it with Arrays. I haven't covered absolutely everything pertaining to Arrays, but you should now have enough to get you started. I hope that you understood everything I was warbling on about, and that I didn't confuse you too much!"
    },
    {
        "link": "https://forums.autodesk.com/t5/visual-lisp-autolisp-and-general/setting-multiple-plotter-locations/td-p/5127630",
        "document": "Based out of Ontario, Canada, Kristina has long advocated for the benefits of building online and offline communities throughout the Design & Make industries.We caught up with Kristina during her busy AU2024 schedule to learn more about the vital role that the community plays in the AU experience, the highs and lows of leveraging AI workflows, and so much more."
    }
]