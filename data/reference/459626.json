[
    {
        "link": "https://datacamp.com/tutorial/python-inheritance",
        "document": "Inheritance is one of the foundational pillars of object-oriented programming (OOP) that allows one class (called the child class) to derive attributes and methods from another class (called the parent class). This feature is central to code reuse and simplifies maintenance, making it easier to build scalable and efficient programs.\n\nBefore going further, let's explore the relationship between parent and child classes.\n\nLet’s start with the parent class. A parent class is the base class from which child classes derive. It encapsulates shared attributes and methods.\n\nUsing Python, here is how we define a parent class:\n\nA child class inherits attributes and methods from the parent class. This allows it to use the functionality defined in the parent class. The following code shows how a child class inherits attributes and methods from a parent class:\n\nThis simple syntax allows the child class to utilize and extend the functionality defined in the parent class.\n\nLet’s create a practical example with a class as the parent and a class as the child.\n\nThe class contains shared attributes and a method to display information:\n\nThe class inherits from and adds a new method .\n• The class uses the method from to initialize and .\n• The method is unique to the class, extending its functionality.\n• The method is inherited directly from .\n\nInheritance in Python allows classes to inherit attributes and behaviors from other classes, promoting code reuse and clean design, as we talked about earlier. In this section, we can talk about the different types of Python inheritance, which includes single, multiple, hierarchical, and hybrid inheritance as separate categories.\n\nSingle inheritance occurs when a child class inherits from a single parent class, allowing it to extend the functionality of the parent. This is useful when an object type shares common properties with a broader category but also requires additional attributes or behavior.\n\nThe example I started to work through earlier was single inheritance, but let's now look a bit more closely: In a school management system, all individuals, including students, teachers, and staff, share some common details like and . However, students also have academic records such as grades and enrolled courses. Using single inheritance, we can create a class for shared attributes and extend it with a class for academic details.\n\nHere’s a good example of the above scenario:\n\nThe class inherits the method from but extends it to include and . This is a good example of how single inheritance promotes what is known as modular code.\n\nMultiple inheritance, like a family tree, in a way, allows a child class to inherit from more than one parent class, combining attributes and behaviors from each. This can lead to potential conflicts, which Python resolves using method resolution order (MRO).\n\nWe see that the class inherited attributes and methods from both and . Without any additional effort, the class has access to the method from the parent class and the method from the parent class. We are effectively combining functionality from multiple sources.\n\nHowever, inheriting from multiple classes can lead to conflicts. What if both parent classes define a method or attribute with the same name? I mentioned something about method resolution order earlier but let me know say a little something more about it. Method resolution order determines the order in which classes are searched for methods and attributes. The MRO follows a depth-first, left-to-right approach.\n\nYou can view the MRO of a class using the attribute or the method:\n\nPython also supports more complex inheritance structures. I'll show these more complex ideas using the same example.\n\nMultilevel inheritance happens when a child class inherits from another child class, and that child class inherits from a parent class. This creates a chain of inheritance.\n\nHere, each class in the chain adds something new: manages names and IDs, includes grades, and introduces a thesis. Thanks to , we reuse the initialization logic without duplicating code. It’s efficient, neat, and ensures every level of the “inheritance ladder”, as I think of it, works.\n\nIn hierarchical inheritance, multiple child classes inherit from a single parent class, allowing for shared behavior across subclasses with unique attributes.\n\nLet’s look at a good example together:\n\nHere, the class serves as the foundation, offering common attributes and methods ( , , and ). The and classes then extend this functionality by adding their unique properties ( and ) and customizing the method to reflect their specific contexts.\n\nWith this approach, shared functionality stays in one place (the class), while specialized behavior is neatly encapsulated in the subclasses.\n\nHybrid inheritance combines multiple inheritance types, such as multilevel or multiple inheritance, to model more complex relationships.\n\nLet’s look at an example that shows the complexity of hybrid inheritance.\n\nIn this example, the class demonstrates hybrid inheritance by inheriting attributes and methods from both (which itself inherits from ) and . This combines hierarchical inheritance (where inherits from ) and multiple inheritance (where inherits from both and ).\n\nNow, it's time to see the strengths and weaknesses:\n• Reusability: With inheritance you can write code once in the parent class and reuse it in the child classes. Using the example, both and can inherit a method from the parent class.\n• Simplicity: Inheritance models relationships clearly. A good example is the class which “is-a” type of the parent class.\n• Scalability: It also add new features or child classes without affecting existing code. For example, we can easily add a new class as a child class.\n• Complexity: This won't be surprising, but too many levels of inheritance can make the code hard to follow. For example, if an has too many child classes like , , , etc., it may become confusing.\n• Dependency: Changes to a parent class can unintentionally affect all subclasses. If you modify for example, it might break or .\n• Misuse: Using inheritance when it is not the best fit can complicate designs. You would not want to create a solution where inherits from just to reuse . The relationship doesn’t make sense.\n\nNow that we have explored the basics of inheritance, let’s look at some advanced techniques. These techniques, like method overriding, , abstract base classes, and polymorphism, enhance code flexibility and allow for more sophisticated design patterns.\n\nMethod overriding allows a child class to provide a specific implementation for a method already defined in its parent class. This is useful when the inherited behavior doesn’t fully meet the requirements of the child class.\n\nHere, the class overrides the method from the class to give its own specific implementations. This allows the child class to have its own behavior while still following the same method name.\n\nSo why do we override? We override because we want to customize inherited behavior and also because we want to tailor the functionality of a parent method to a child class’s unique requirements.\n\nThe function is used to call methods in the parent class from the child class. This is particularly useful when you want to extend or modify the functionality of a parent class method, such as the constructor method.\n\nSo why do we use the function? We use the super function because we want to call and initialize the parent class’s constructor and also because we want to avoid explicitly naming the parent class. This is helpful, especially in cases of multiple inheritance.\n\nHere, the class uses to call the method of the parent class, so it does not need to repeat code to initialize the and attributes. The child class then introduces a attribute, which is specific to the class.\n\nAn abstract base class (ABC) is a class that cannot be directly used to create objects. It is meant to define a common set of methods that other classes should implement. So ABCs are useful when you want to ensure that certain methods are always present in the child classes.\n\nThe class here is an abstract class that requires any child class to implement the method. This method is being later implemented by the child class, .\n\nPolymorphism means many shapes. In Python, it allows different classes to use the same method name, but each can implement that method in a different way.\n\nPolymorphism helps us write code that can work with objects of different classes, even if those classes have different behaviors:\n\nIn this example, the function can accept any object of type , but it will call the appropriate method based on whether the object is a or a .\n\nWhile inheritance is powerful, it is easy to misuse. I will share some ideas to help you make the most of the ideas.\n\nWhen a child class overrides a method from its parent, the behavior can change.\n\nFor example, if the parent class has a method, and the child class overrides it without considering all scenarios, it might produce incorrect pay calculations.\n\nThe best practice, in this case, is to always test overridden methods thoroughly and document their behavior.\n\nI know this article is about inheritance, but it is not always the right approach. Sometimes, composition, where you build classes by combining objects rather than extending them might be a better fit with whatever you are doing.\n\nTo distll the differences in the most basic way, think that:\n• Inheritance refers to “Is-a” relationships. For example, a is an .\n• Composition refers to “Has-a” relationships. For example, a has an .\n\nSo, how do you know when composition is the best approach to use? Use composition when the relationship is not strictly hierarchical and/or when you want to reduce tight coupling between classes.\n\nOr, we could also say that, while inheritance models relationships, composition focuses on functionality. To help, consider this:\n• Use inheritance when objects are naturally hierarchical. For example, .\n• Use composition when objects share functionality but are not related. For example, a and both use a .\n\nDeep inheritance chains (many levels of parent-child relationships) can make your code hard to read and maintain. This is a problem because changes to a parent class may unintentionally affect many child classes. Also, debugging becomes complex as behavior is spread across multiple levels.\n\nThe best practice in this case is to keep hierarchies shallow. Also, consider using composition (as I mentioned earlier) or breaking a chain into separate hierarchies if you find it is becoming too deep.\n\nInheritance is a major pillar of object-oriented programming that enables developers like you to create reusable, modular, and scalable code. If you can master inheritance, you will find it easy to simplify complex systems.\n\nA good way to deepen your understanding is to try building inheritance structures in your projects. Start simple, then experiment with more complex hierarchies to see how they work in practice.\n\nIf you are eager to explore even deeper, you can check out our Programming Paradigm Concepts course for a deeper understanding of inheritance and other ideas. Our Python Developer career track is also a good resource that offers a comprehensive path to developing advanced programming skills that will equip you for software development."
    },
    {
        "link": "https://realpython.com/inheritance-composition-python",
        "document": "In Python, understanding inheritance and composition is crucial for effective object-oriented programming. Inheritance allows you to model an is a relationship, where a derived class extends the functionality of a base class. Composition, on the other hand, models a has a relationship, where a class contains objects of other classes to build complex structures. Both techniques promote code reuse, but they approach it differently.\n\nBy the end of this tutorial, you’ll understand that:\n• Composition and inheritance in Python model relationships between classes, enabling code reuse in different ways.\n• Composition is achieved by creating classes that contain objects of other classes, allowing for flexible designs.\n• Inheritance models an is a relationship, allowing derived classes to extend base class functionality.\n• Inheritance in Python is achieved by defining classes that derive from base classes, inheriting their interface and implementation.\n\nExploring the differences between inheritance and composition helps you choose the right approach for designing robust, maintainable Python applications. Understanding how and when to apply each concept is key to leveraging the full power of Python’s object-oriented programming capabilities.\n\nAn Overview of Inheritance in Python Everything in Python is an object. Modules are objects, class definitions and functions are objects, and of course, objects created from classes are objects too. Inheritance is a required feature of every object-oriented programming language. This means that Python supports inheritance, and as you’ll see later, it’s one of the few languages that supports multiple inheritance. When you write Python code using classes, you’re using inheritance even if you don’t know that you’re using it. Next up, take a look at what that means. The easiest way to see inheritance in Python is to jump into the Python interactive shell and write a little bit of code. You’ll start by writing the simplest class possible: You declared , which doesn’t do much, but it’ll illustrate the most basic inheritance concepts. Now that you have the class declared, you can create an instance of the class and use the function to list its members: The function returns a list of all the members in the specified object. You haven’t declared any members in , so where’s the list coming from? You can find out using the interactive interpreter: As you can see, the two lists are nearly identical. There are three additional members in : However, every single member of the class is also present in . This is because every class that you create in Python implicitly derives from . You could be more explicit and write , but it’s redundant and unnecessary. Note: In Python 2, you had to explicitly derive from for reasons beyond the scope of this tutorial, but you can read about it in the new-style and classic classes section of the Python 2 documentation. Okay, it’s not entirely true that every class in Python derives from . There’s one aptly named exception, which you’ll learn about next. Every class that you create in Python will implicitly derive from . However, there’s one exception to this rule: classes used to indicate errors by raising an exception. If you try to treat a normal Python class like an exception and it, then Python will present you with a : You created a new class to indicate a type of error. Then you tried to raise the class to signal an exception. Python does indeed raise an exception, but the output states that the exception is of type , not , and that all . is a base class provided for all error types. To create a new error type, you must derive your class from or one of its derived classes. The convention in Python is to derive your custom error types from , which in turn derives from . The correct way to define your error type is the following: In this example, explicitly inherits from instead of implicitly inheriting from . With that change, you’ve fulfilled the requirements for creating a custom exception, and you can now raise your new exception class. When you raise , the output correctly states that Python raised an error of the type . Inheritance is the mechanism that you’ll use to create hierarchies of related classes. These related classes will share a common interface that the base classes will define. Derived classes can specialize the interface by providing a particular implementation where applicable. In this section, you’ll start modeling an HR system. Along the way, you’ll explore the use of inheritance and see how derived classes can provide a concrete implementation of the base class interface. The HR system needs to process payroll for the company’s employees, but there are different types of employees depending on how their payroll is calculated. You start by implementing a class that processes payroll: implements a method that takes a collection of employees and prints their , , and check amount using the method exposed on each employee object. Now, you implement a base class, , that handles the common interface for every employee type: is the base class for all employee types. It’s constructed with an and a . What you’re saying is that every must have an as well as a assigned. The HR system requires that every processed must provide a interface that returns the weekly salary for the employee. The implementation of that interface differs depending on the type of . For example, administrative workers have a fixed salary, so every week they get paid the same amount: You create a derived class, , that inherits from . The class initializes with the and required by the base class, and you use to initialize the members of the base class. You can read all about in Supercharge Your Classes With Python . also requires a initialization parameter that represents the amount that the employee makes per week. The class provides the required method that the HR system uses. The implementation just returns the amount stored in . The company also employs manufacturing workers who are paid by the hour, so you add to the HR system: The class is initialized with and , like the base class, plus the and the required to calculate the payroll. You implement the method by returning the hours worked times the hourly rate. Finally, the company employs sales associates who are paid through a fixed salary plus a commission based on their sales, so you create a class: You derive from because both classes have a to consider. At the same time, you initialize with a value that’s based on the sales for the employee. With , you leverage the implementation of the base class to retrieve the salary, and you add the commission value. Since derives from , you have access to the property directly, and you could’ve implemented using the value of that property. The problem with accessing the property directly is that if the implementation of changes, then you’ll have to also change the implementation of . It’s better to rely on the already-implemented method in the base class and extend the functionality as needed. You’ve created your first class hierarchy for the system. The UML diagram of the classes looks like this: The diagram shows the inheritance hierarchy of the classes. The derived classes implement the interface, which the requires. The implementation requires that the objects in the collection contain an , , and implementation. Note: Interfaces are represented similarly to classes in UML diagrams, with the word Interface above the interface name. Interface names are usually prefixed with a capital . In Python, you don’t implement interfaces explicitly. Instead, interfaces are defined by the attributes used and methods called by other functions and methods. Next, create a new file and call it . This program creates the employees and passes them to the payroll system to process payroll: You can run the program in the command line and see the results: The program creates three employee objects, one for each of the derived classes. Then, it creates the payroll system and passes a list of the employees to its method, which calculates the payroll for each employee and prints the results. Notice how the base class doesn’t define a method. This means that if you were to create a plain object and pass it to the , then you’d get an error. You can try it in the Python interactive interpreter: While you can instantiate an object, can’t use the object. Why? Because it can’t call for . To be more explicit about the requirements of , you can convert the class, which is currently a concrete class, to an abstract class. That way, no employee is ever just an , but instead always a derived class that implements . The class in the example above is what is called an abstract base class. Abstract base classes exist to be inherited, but never instantiated. Python provides the module to formally define abstract base classes. You can use leading underscores in your class name to communicate that objects of that class shouldn’t be created. Underscores provide a friendly way to prevent misuse of your code, but they don’t prevent eager users from creating instances of that class. The module in the Python standard library provides functionality to prevent creating objects from abstract base classes. You can modify the implementation of the class to ensure that it can’t be instantiated: You derive from , making it an abstract base class. Then, you decorate the method with the decorator. This change has two nice side-effects:\n• You’re telling users of the module that objects of type can’t be created.\n• You’re telling other developers working on the module that if they derive from , then they must override the abstract method. You can see that you can’t create objects of type anymore using the interactive interpreter: The output shows that you can’t instantiate the class because it contains an abstract method, . Derived classes must override the method to allow creating objects of their type. When you derive one class from another, the derived class inherits both of the following:\n• The base class interface: The derived class inherits all the methods, properties, and attributes of the base class.\n• The base class implementation: The derived class inherits the code that implements the class interface. Most of the time, you’ll want to inherit the implementation of a class, but you’ll want to implement multiple interfaces so that you can use your objects in different situations. Modern programming languages are designed with this basic concept in mind. They allow you to inherit from a single class, but you can implement multiple interfaces. In Python, you don’t have to explicitly declare an interface. Any object that implements the desired interface can be used in place of another object. This is known as duck typing. Duck typing is usually explained as if it walks like a duck and it quacks like a duck, then it must be a duck. In other words, it’s enough to behave like a duck to be considered a duck. To illustrate this, you’ll now add a class to the example above, and it won’t derive from . Create a new file called and add the following code: The class doesn’t derive from , but it exposes the same interface that requires. Remember that requires a list of objects that implement the following interface:\n• An property or attribute that returns the employee’s ID\n• A property or attribute that represents the employee’s name\n• A method that doesn’t take any parameters and returns the payroll amount to process The class meets all these requirements, so can still calculate its payroll. You can modify the program to use the class: The program creates a object and adds it to the list that processes. You can now run the program and see its output: As you can see, the can still process the new object because it meets the desired interface. Since you don’t have to derive from a specific class for your objects to be reusable by the program, you may be asking why you should use inheritance instead of just implementing the desired interface. The following rules may help you to make this decision:\n• Use inheritance to reuse an implementation: Your derived classes should leverage most of their base class implementation. They must also model an is a relationship. A class might also have an and a , but a is not an , so in this case, you shouldn’t use inheritance.\n• Implement an interface to be reused: When you want your class to be reused by a specific part of your application, you implement the required interface in your class, but you don’t need to provide a base class, or inherit from another class. You can now clean up the example above to move on to the next topic. You can delete the file and then modify the module to its original state: You removed the import of the module since the class doesn’t need to be abstract. You also removed the abstract method from it since it doesn’t provide any implementation. Basically, you’re inheriting the implementation of the and attributes of the class in your derived classes. Since is just an interface to the method, you don’t need to implement it in the base class. Notice how the class derives from . This means that inherits the implementation and interface of . You can see how the method leverages the base class implementation because it relies on the result from to implement its own version. If you’re not careful, inheritance can lead you to a huge hierarchical class structure that’s hard to understand and maintain. This is known as the class explosion problem. You started building a class hierarchy of types used by the to calculate payroll. Now, you need to add some functionality to those classes so that you can use them with the new . tracks productivity based on employee roles. There are different employee roles:\n• Managers: They walk around yelling at people, telling them what to do. They’re salaried employees and make more money.\n• Secretaries: They do all the paperwork for managers and ensure that everything gets billed and payed on time. They’re also salaried employees but make less money.\n• Sales employees: They make a lot of phone calls to sell products. They have a salary, but they also get commissions for sales.\n• Factory workers: They manufacture the products for the company. They’re paid by the hour. With those requirements, you start to see that and its derived classes might belong somewhere other than the module because now they’re also used by the . You create an module and move the classes there: The implementation remains the same, but you move the classes to the module. Your module is now much smaller and focused on the payroll system: With both and in place, you can now update your program to support the change: You run the program and verify that it still works: With everything in place, you start adding the new classes: First, you add a class that derives from . The class exposes a method that the productivity system will use. The method takes the that the employee worked. Then you add , , and and then implement the interface, so they can be used by the productivity system—which you haven’t created yet. As a next step, you can create a new file called and add the class: The class tracks employees in the method that takes a list of employees and the number of hours to track. As outlined above, the productivity system makes use of on each of the objects in to accomplish the tracking. You can now add the productivity system to your program, and update it to represent different types of employees: Your updated program creates a list of employees of different types. The employee list is sent to the productivity system to track their work for forty hours. Then the same list of employees is sent to the payroll system to calculate their payroll. You can run the program to see the output: The program shows the employees working for forty hours through the productivity system. Then it calculates and displays the payroll for each of the employees. The program works as expected, but you had to add four new classes to support the changes. As new requirements come, your class hierarchy will inevitably grow, leading to the class explosion problem where your hierarchies will become so big that they’ll be hard to understand and maintain. The following diagram shows the new class hierarchy: The diagram shows how the class hierarchy is growing. Additional requirements might have an exponential effect on the number of classes with this design. Python is one of the few modern programming languages that supports multiple inheritance. Multiple inheritance is the ability to derive a class from multiple base classes at the same time. Multiple inheritance has a bad reputation to the extent that most modern programming languages don’t support it. Instead, modern programming languages support the concept of interfaces. In those languages, you inherit from a single base class and then implement multiple interfaces, so you can reuse your classes in different situations. This approach puts some constraints in your designs. You can only inherit the implementation of one class by directly deriving from it. You can implement multiple interfaces, but you can’t inherit the implementation of multiple classes. This constraint is good for software design because it forces you to design your classes with fewer dependencies on each other. You will see later in this tutorial that you can leverage multiple implementations through composition, which makes software more flexible. This section, however, is about multiple inheritance, so take a look at how it works. It turns out that sometimes temporary secretaries are hired when there’s too much paperwork to do. The class performs the role of a in the context of the , but for payroll purposes, it’s an . You look at your class design. It’s grown a little bit, but you can still understand how it works. It seems you have two options:\n• Derive from : You can derive from to inherit the method for the role, and then override the method to implement it as an .\n• Derive from : You can derive from to inherit the method, and then override the method to implement it as a . Then, you remember that Python supports multiple inheritance, so you decide to derive from both and : Python allows you to inherit from two different classes by specifying them between parentheses in the class declaration, and separating them with commas. Now, you modify your program to add the new temporary secretary employee: You run the program to test it: python program.py TypeError: SalaryEmployee.__init__() takes 4 positional arguments but 5 were given You get a exception saying that positional arguments where expected, but were given. This is because you derived first from and then from , so the interpreter is trying to use to initialize the object. Okay, go ahead and reverse it: Now, run the program again and see what happens: Now it seems that you’re missing a parameter, which is necessary to initialize , but that parameter doesn’t make sense in the context of a because it’s an . Maybe implementing will help: That didn’t work either. Okay, it’s time for you to dive into Python’s method resolution order (MRO) to see what’s going on. When a method or attribute of a class is accessed, Python uses the class MRO to find it. The MRO is also used by to determine which method or attribute to invoke. You can learn more about in Supercharge Your Classes With Python . You can evaluate the class MRO using the interactive interpreter: The MRO shows the order in which Python is going to look for a matching attribute or method. In the example, this is what happens when you create the object:\n• calls , which the MRO is going to match to , which is inherited from . You can bypass parts of the MRO. In this case, you want to skip the initialization of and . You can do this by reversing the inheritance order again back to how you had it initially. Then, you’ll directly call : When you put before , then the MRO of looks like the following: Because you explicitly specified that should use , you’re effectively skipping and in the MRO when initializing an object. That solves the problem of creating the object, but you’ll run into a similar problem when trying to calculate payroll. You can run the program to see the problem: The problem now is that because you reversed the inheritance order, the MRO is finding the method of before the one in . You need to override in and invoke the right implementation from it: The new method now directly invokes to ensure that you get the correct result. You can run the program again to see it working: The program now works as expected because you’re forcing the method resolution order by explicitly telling the interpreter which method you want to use. As you can see, multiple inheritance can be confusing, especially when you run into the diamond problem. The following diagram shows the diamond problem in your class hierarchy: The diagram shows the diamond problem with the current class design. uses multiple inheritance to derive from two classes that ultimately also derive from . This causes two paths to reach the base class, which is something you want to avoid in your designs. The diamond problem appears when you’re using multiple inheritance and deriving from two classes that have a common base class. This can cause the wrong version of a method to be called. As you’ve seen, Python provides a way to force the right method to be invoked, and analyzing the MRO can help you understand the problem. Still, when you run into the diamond problem, it’s better to rethink the design. You’ll now make some changes to leverage multiple inheritance, avoiding the diamond problem. Two different systems use the derived classes:\n• The payroll system that calculates the employee payroll This means that everything related to productivity should be together in one module, and everything related to payroll should be together in another. You can start making changes to the productivity module: The module implements the class, as well as the related roles that it supports. The classes implement the interface required by the system, but they don’t derive from . You can do the same with the module: The module implements the , which calculates payroll for the employees. It also implements the policy classes for payroll. As you can see, the policy classes don’t derive from anymore. You can now add the necessary classes to the module: The module imports policies and roles from the other modules and implements the different types. You’re still using multiple inheritance to inherit the implementation of the salary policy classes and the productivity roles, but the implementation of each class only needs to deal with initialization. Notice that you still need to explicitly initialize the salary policies in the constructors. You probably saw that the initializations of and are identical. Also, the initializations of and are the same. You won’t want to have this kind of code duplication in more complex designs, so you have to be careful when designing class hierarchies. Here’s the UML diagram for the new design: The diagram shows the relationships to define the and using multiple inheritance, but avoiding the diamond problem. You can run the program and see how it works: You’ve seen how inheritance and multiple inheritance work in Python. You can now explore the topic of composition.\n\nComposition is an object-oriented design concept that models a has a relationship. In composition, a class known as composite contains an object, or component, of another class. In other words, a composite class has a component of another class. Composition allows composite classes to reuse the implementation of the components it contains. The composite class doesn’t inherit the component class interface, but it can leverage its implementation. The composition relation between two classes is considered loosely coupled. That means that changes to the component class rarely affect the composite class, and changes to the composite class never affect the component class. This provides better adaptability to change and allows applications to introduce new requirements without affecting existing code. When looking at two competing software designs, one based on inheritance and another based on composition, the composition solution usually is more flexible. You can now look at how composition works. You’ve already used composition in your examples. If you look at the class, then you’ll see that it contains two attributes:\n• to contain the name of the employee These two attributes are objects that the class has. Therefore, you can say that an has an and has a . Another attribute for an might be an . Create a new Python file called and add code for an class: You implemented a basic address class that contains the usual components for an address. You made the attribute optional because not all addresses will have that component. You implemented to provide a pretty representation of an . You can see this implementation in the interactive interpreter: When you the variable, you’re invoking the special method . Since you overloaded the method to return a string formatted as an address, you get a nice, readable representation. Operator and Function Overloading in Custom Python Classes gives a good overview of the special methods available in classes that you can implement to customize the behavior of your objects. You can now add to the class through composition: You initialize the attribute to for now to make it optional, but by doing that, you can now assign an to an . Also notice that there’s no reference in the module to the module. Composition is a loosely coupled relationship that often doesn’t require the composite class to have knowledge of the component. The UML diagram representing the relationship between and looks like this: The diagram shows the basic composition relationship between and . You can now modify the class to leverage the attribute in : You check to see if the object has an address, and if it does, you print it. You can now modify the program to assign some addresses to the employees: You added a couple of addresses to the and objects. When you run the program, you’ll see the addresses printed: Notice how the payroll output for the and objects shows the addresses where the checks were sent. The class leverages the implementation of the class without any knowledge of what an object is or how it’s represented. This type of design is so flexible that you can change the class without any impact to the class. Composition is more flexible than inheritance because it models a loosely coupled relationship. Changes to a component class have minimal or no effects on the composite class. Designs based on composition are more suitable to change. You change behavior by providing new components that implement those behaviors instead of adding new classes to your hierarchy. Take a look at the multiple inheritance example above. Imagine how new payroll policies will affect the design. Try to picture what the class hierarchy will look like if new roles are needed. As you saw before, relying too heavily on inheritance can lead to class explosion. The biggest problem isn’t so much the number of classes in your design, but how tightly coupled the relationships between those classes are. Tightly coupled classes affect each other when changes are introduced. In this section, you’re going to use composition to implement a better design that still fits the requirements of the and the . You can start by implementing the functionality of the : The updated class defines some roles using a string identifier mapped to a role class that implements the role. It exposes a method that, given a role identifier, returns the role type object. If the role isn’t found, then Python raises a exception. It also exposes the previous functionality in the method, where given a list of employees, it tracks the productivity of those employees. You can now implement the different role classes: Each of the roles that you implemented exposes its own method that takes the number of worked. These methods return a string representing the duties. Note: If you’ve followed along throughout the section on inheritance, then you’ll notice that these roles are similar, but slightly different from that example. Feel free to continue working with the roles that you previously defined and their methods if you prefer. You’ll just need to adapt the relevant names to account for the change. The role classes are independent of each other, but they expose the same interface, so they’re interchangeable. You’ll see later how they’re used in the application. Now, you can implement the for the application: keeps an internal database of payroll policies for each employee. It exposes a method that, given an employee , returns its payroll policy. If a specified doesn’t exist in the system, then the method raises a exception. The implementation of works the same as before. It takes a list of employees, calculates the payroll, and prints the results. You can now implement the payroll policy classes: You first implement a class that serves as a base class for all the payroll policies. This class tracks the , which is common to all payroll policies. The other policy classes derive from . You use inheritance here because you want to leverage the implementation of . Also, , , and are a . is initialized with a value that then uses. is initialized with and implements by leveraging the base class . The class derives from because it wants to inherit its implementation. It’s initialized with the parameters, but it also requires a parameter. The is used to calculate the , which is implemented as a property so it gets calculated when requested. In the example, you’re assuming that a sale happens every five hours worked, and the is the number of sales times the value. implements the method by first leveraging the implementation in and then adding the calculated commission. You can now add an class to manage employee addresses: The class keeps an internal database of objects for each employee. It exposes a method that returns the address of the specified employee . If the employee doesn’t exist, then it raises a . The class implementation remains the same as before: The class manages the address components and provides a pretty representation of an address. So far, the new classes have been extended to support more functionality, but there are no significant changes to the previous design. This is going to change with the design of the module and its classes. You can start by implementing an class: keeps track of all the employees in the company. For each employee, it tracks the , , and . It has an instance of the , the , and the . These instances are used to create employees. It exposes an property that returns the list of employees. The objects are created in an internal method. Notice that you don’t have different types of classes. You just need to implement a single class: You initialize the class with the , , and attributes. This class also requires the productivity for the employee and the policy. The class exposes a method that takes the hours worked. This method first retrieves the from the . In other words, it delegates to the object to perform its duties. In the same way, it delegates to the object to track the work . The , as you saw, uses those hours to calculate the payroll if needed. The following diagram shows the composition design used: The diagram shows the design of composition-based policies. There’s a single that’s composed of other data objects like and depends on the and interfaces to delegate the work. There are multiple implementations of these interfaces. You can now use this design in your program: You can run the program to see its output: This design is what’s called policy-based design, where classes are composed of policies, and they delegate to those policies to do the work. Policy-based design was introduced in the book Modern C++ Design, and it uses template metaprogramming in C++ to achieve the results. Python doesn’t support templates, but you can achieve similar results using composition, as you saw in the example above. This type of design gives you all the flexibility you’ll need as requirements change. Imagine that you need to change the way payroll is calculated for an object at runtime. If your design relies on inheritance, then you need to find a way to change the type of an object to change its behavior. With composition, you just need to change the policy that the object uses. Imagine that your all of a sudden becomes a temporary employee who gets paid by the hour. You can modify the object during the execution of the program in the following way: The program gets the employee list from the and retrieves the first employee, which is the manager you want. Then it creates a new initialized at 55 dollars per hour and assigns it to the manager object. The new policy is now used by the , modifying the existing behavior. You can run the program again to see the result: The check for Mary Poppins, your manager, is now for 2200 dollars instead of the fixed weekly salary of 3000 dollars that she used to have. Notice how you added that business rule to the program without changing any of the existing classes. Consider what type of changes would’ve been required with an inheritance design. You would’ve had to create a new class and change the type of the manager employee. There’s no chance that you could’ve changed the policy at runtime.\n\nChoosing Between Inheritance and Composition in Python So far, you’ve seen how inheritance and composition work in Python. You’ve seen that derived classes inherit the interface and implementation of their base classes. You’ve also seen that composition allows you to reuse the implementation of another class. You’ve implemented two solutions to the same problem. The first solution used multiple inheritance, and the second one used composition. You’ve also seen that Python’s duck typing allows you to reuse objects with existing parts of a program by implementing the desired interface. In Python, it isn’t necessary to derive from a base class to reuse your classes. At this point, you might be asking when to use inheritance vs composition in Python. They both enable code reuse. Inheritance and composition can tackle similar problems in your Python programs. The general advice is to use the relationship that creates fewer dependencies between two classes. This relation is composition. Still, there’ll be times where inheritance will make more sense. The following sections provide some guidelines to help you make the right choice between inheritance and composition in Python. You should only use inheritance to model an is a relationship. Liskov’s substitution principle says that an object of type , which inherits from , can replace an object of type without altering the desirable properties of a program. Liskov’s substitution principle is the most important guideline to determine if inheritance is the appropriate design solution. Still, the answer might not be straightforward in all situations. Fortunately, there’s a simple test that you can use to determine if your design follows Liskov’s substitution principle. Let’s say you have a class, , that provides an implementation and interface you want to reuse in another class, . Your initial thought is that you can derive from and inherit both the interface and the implementation. To be sure this is the right design, you follow theses steps:\n• Evaluate is an : Think about this relationship and justify it. Does it make sense?\n• Evaluate is a : Reverse the relationship and justify it. Does it also make sense? If you can justify both relationships, then you should never inherit those classes from one another. Look at a more concrete example. You have a class that exposes an property. You need a class, which also has an . It seems that a is a special type of , so maybe you can derive from it and leverage both the interface and implementation. Before you jump into the implementation, you use Liskov’s substitution principle to evaluate the relationship. A is a because its area is calculated from the product of its times its . The constraint is that and must be equal. It makes sense. You can justify the relationship and explain why a is a . Now reverse the relationship to see if it makes sense. A is a because its area is calculated from the product of its times its . The difference is that and can change independently. It also makes sense. You can justify the relationship and describe the special constraints for each class. This is a good sign that these two classes should never derive from each other. You might have seen other examples that derive from to explain inheritance. You might be skeptical with the little test that you just did. Fair enough. Next, you’ll write a program that illustrates the problem with deriving from . First, you implement . You’re even going to encapsulate the attributes to ensure that you’re meeting all the constraints: You initialize the class with a and a , and the class provides an property that returns the area. The and are encapsulated as and to avoid changing them directly. Now, you derive from and override the necessary interface to meet the constraints of a : You initialize the class with a , which is used to initialize both components of the base class. Now, you write a small program to test the behavior: The program creates a and a and asserts that their is calculated correctly. You can run the program and see that everything is so far: The program executes correctly, so it seems that is just a special case of a . Later on, you need to support resizing objects, so you make the appropriate changes to the class: Your method takes the and for the object. You can add the following code to the program to verify that it works correctly: You resize the rectangle object and assert that the new area is correct. You can run the program to verify the behavior: The assertion passes, and you see that the program runs correctly. So, what happens if you resize a square? Modify the program, and try to modify the object: You pass the same parameters to that you used with , and print the area. When you run the program you see: The program shows that the new area is like the object. The problem now is that the object no longer meets the class constraint that the length and height must be equal. How can you fix that problem? You can try several approaches, but all of them will be awkward. You can override in and ignore the parameter. However, that will be confusing for people looking at other parts of the program where objects are being resized and some of them are not getting the expected areas because they’re really objects. In a small program like this one, it might be easy to spot the causes of the weird behavior, but in a more complex program, the problem will be harder to find. The reality is that if you’re able to justify an inheritance relationship between two classes both ways, then you shouldn’t derive one class from another. In the example, it doesn’t make sense that inherits the interface and implementation of from . That doesn’t mean that objects can’t be resized. It means that the interface is different because it only needs a parameter. This difference in interface justifies not deriving from , like the test above advised. One of the uses of multiple inheritance in Python is to extend class features through mixins. A mixin is a class that provides methods to other classes but isn’t considered a base class. A mixin allows other classes to reuse its interface and implementation without becoming a superclass. It implements a unique behavior that you can aggregate to other unrelated classes. Mixins are similar to composition, but they create a stronger relationship. Say you want to convert objects of certain types in your application to a dictionary representation of the object. You could provide a method in every class that you want to support this feature, but the implementation of seems to be very similar. This could be a good candidate for a mixin. You start by slightly modifying the class from the composition example: The changes are minimal. You just changed the and attributes to be internal by adding a leading underscore to their names. You’ll see soon why you’re making that change. Now, you create an class in a new file called : The class exposes a method that returns the representation of itself as a dictionary. The method is implemented as a comprehension that creates a dictionary mapping to for each item in if the isn’t internal. Note: This is why you made the role and payroll attributes internal in the class—because you don’t want to represent them in the dictionary. As you saw at the beginning, creating a class inherits some members from , and one of those members is , which is basically a mapping of all the attributes in an object to their values. You iterate through all the items in and filter out the ones that have a name that starts with an underscore using . With , you check the specified value. If the value is an , then the method looks to see if it also has a member and uses it to represent the object. Otherwise, it returns a string representation. If the value isn’t an , then it simply returns the value. You can modify the class to support this mixin: All you have to do is inherit the to support the functionality. It’ll be nice to support the same functionality in the class, so you represent the attribute in the same way: You apply the mixin to the class to support the feature. Now, you can write a small program to test it: The program implements , which converts the dictionary to a JSON string using indentation so the output looks better. Then, it iterates through all the employees, printing the dictionary representation provided by . You can run the program to see its output: You leveraged the implementation of in both and classes even when they’re not related. Because only provides behavior, you can reuse it with other classes without causing problems. Composition models a has a relationship. With composition, a class has an instance of the class and can leverage its implementation. You can reuse the class in other classes completely unrelated to the . In the composition example above, the class has an object. implements all the functionality to handle addresses, and other classes can reuse it. Other classes like or can reuse without being related to . They can leverage the same implementation, ensuring that addresses are handled consistently across the application. A problem that you may run into when using composition is that some of your classes may start growing by using multiple components. Your classes may require multiple parameters in the constructor just to pass in the components that they’re made of. This can make your classes hard to use. A way to avoid the problem is by using the factory method to construct your objects. You did that with the composition example. If you look at the implementation of the class, then you’ll notice that it uses to construct an object with the right parameters. This design will work, but ideally, you should be able to construct an object just by specifying an ID, for example . The following changes might improve your design. You can start with the module: First, you make the class internal by prepending an underscore to the class name. Then you provide a internal variable to the module. You’re communicating to other developers that they shouldn’t create or use directly. Instead, you provide two functions, and , as the public interface to the module. This is what other modules should use. What you’re saying is that is a singleton, and there should only be one object created from it. Now, you can do the same with the module: Again, you make internal and provide a public interface to it. The application will use the public interface to get policies and calculate payroll. You’ll now do the same with the module: You’re basically saying that there should only be one , one , and one . Again, this design pattern is called the singleton design pattern, which comes in handy for classes from which there should only be one single instance. Now, you can work on the module. You’ll also mark the as internal and make a singleton out of it, but you’ll make some additional changes: You first import the relevant public functions and classes from other modules. You make internal, and at the bottom, you create a single instance. This instance is public and part of the interface because you’ll want to use it in the application. You changed the attribute to a dictionary where the key is the employee ID and the value is the employee information. You also exposed a method to return the information for the specified employee . The property now sorts the keys to return the employees sorted by their . You replaced the method that constructed the objects with calls to the initializer directly. The class now is initialized with the ID and uses the public functions exposed in the other modules to initialize its attributes. You can now change the program to test the changes: You import the relevant functions from the and modules, as well as the and class. The program is cleaner because you exposed the required interface and encapsulated how to access objects. Notice that you can now create an object directly just using its ID. You can run the program to see its output: The program works the same as before, but now you can see that you can create a single object from its ID and display its dictionary representation. Take a closer look at the class: The class is a composite that contains multiple objects providing different functionality. It contains an that implements all the functionality related to where the employee lives. also contains a productivity role from the module, and a payroll policy from the module. These two objects provide implementations that the class leverages to track work in the method and to calculate the payroll in the method. You’re using composition in two different ways. The class provides additional data to , while the role and payroll objects provide additional behavior. Still, the relationship between and those objects is loosely coupled, which provides some interesting capabilities that you’ll see in the next section. Inheritance, as opposed to composition, is a tightly coupled relationship. With inheritance, there’s only one way to change and customize behavior. Method overriding is the only way to customize the behavior of a base class. This creates rigid designs that are difficult to change. Composition, on the other hand, provides a loosely coupled relationship that enables flexible designs and can be used to change behavior at runtime. Imagine you need to support a long-term disability (LTD) policy when calculating payroll. The policy states that an employee on LTD should be paid 60 percent of their weekly salary, assuming forty hours of work. With an inheritance design, this can be a very difficult requirement to support. Adding it to the composition example is a lot simpler. Start by adding the policy class: Notice that doesn’t inherit from , but implements the same interface. This is because the implementation is completely different, so you don’t want to inherit any of the implementation. The initializes to and provides an internal method that raises an exception if the hasn’t been applied. Then, it provides an method to assign . The public interface first checks that has been applied, and then it implements the functionality in terms of that base policy. The method just delegates to the base policy, and uses it to calculate the and then return the 60 percent. You can now make a small change to the class: You added an method that applies the existing payroll policy to the new policy and then substitutes it. You can now modify the program to apply the policy to an object: The program accesses located at index , creates the object, and applies the policy to the employee. When you call , the change is reflected. You can run the program to evaluate the output: The check amount for employee Kevin Bacon, who’s the sales employee, is now for 1080 dollars instead of 1800 dollars. That’s because the has been applied to the salary. As you can see, you were able to support the changes just by adding a new policy and modifying a couple of interfaces. This is the kind of flexibility that policy design based on composition gives you. Choosing Between Inheritance and Composition in Python Python, as an object-oriented programming language, supports both inheritance and composition. You saw that inheritance is best used to model an is a relationship, whereas composition models a has a relationship. Sometimes, it’s hard to see what the relationship between two classes should be, but you can follow these guidelines:\n• Use inheritance over composition in Python to model a clear is a relationship. First, justify the relationship between the derived class and its base. Then, reverse the relationship and try to justify it. Only if you can’t justify the relationship in both directions should you use inheritance between them.\n• Use inheritance over composition in Python to leverage both the interface and implementation of the base class.\n• Use inheritance over composition in Python to provide mixin features to several unrelated classes when there’s only one implementation of that feature.\n• Use composition over inheritance in Python to model a has a relationship that leverages the implementation of the component class.\n• Use composition over inheritance in Python to create components that multiple classes in your Python applications can reuse.\n• Use composition over inheritance in Python to implement groups of behaviors and policies that can be applied interchangeably to other classes to customize their behavior.\n• Use composition over inheritance in Python to enable runtime behavior changes without affecting existing classes. With that, you have a strong understanding of when to use inheritance vs composition."
    },
    {
        "link": "https://stackoverflow.com/questions/46707552/best-practices-for-multiple-inheritance-in-this-python-code",
        "document": "I'm having some doubts with the design of mutiple inheritance in some Python classes.\n\nThe thing is that I wanted to extend the ttk button. This was my initial proposal (I'm omitting all the source code in methods for shortening, except init methods):\n\nBut I realized later that I wanted also a subclass of this ImgButton as follows:\n\nThe inheritance feels natural right to his point. The problem came when I noticed as well that most methods in ImgButton would be reusable for any Widget I may create in the future.\n\nfor putting in it all methods which help with color for widgets and then I need ImgButton to inherit both from MyWidget and ttk.Button:\n\nEdited: Also I want my objects to be loggable, so I did this class:\n\nI come from Java and I don't know best practices for multiple inheritance. I don't know how I should sort the parents in the best order or any other thing useful for designing this multiple inheritance.\n\nI have searched about the topic and found a lot of resources explaining the MRO but nothing about how to correctly design a multiple inheritance. I don't know if even my design is wrongly made, but I thought it was feeling pretty natural.\n\nI would be grateful for some advice, and for some links or resources on this topic as well.\n\nThank you very much."
    },
    {
        "link": "https://accuweb.cloud/resource/articles/inheritance-in-python",
        "document": "Inheritance is a fundamental concept in Python programming, playing a crucial role in enhancing code reusability and maintaining a clean and modular codebase. This object-oriented programming (OOP) principle allows for the creation of a new class that inherits attributes and methods from an existing class. In this article, we will explore the basics of inheritance in Python, its types, syntax, implementation, real-world examples, advanced concepts, best practices, and considerations.\n\nThe following topics are converted in this article/tutorial\n• When to Use Inheritance\n\nInheritance in Python is the process of creating a new class, known as the derived class, that inherits attributes and methods from an existing class, known as the base class. It forms the foundation of object-oriented programming, facilitating the creation of structured and modular code.\n\nInheritance establishes a parent-child relationship between classes. The base class serves as the template, providing common attributes and methods, while the derived class inherits and extends this functionality. This relationship enhances code organization and promotes the reuse of code.\n\nThere are main 5 types of inheritance in Python:\n• Single Inheritance: A derived class inherits from only one base class.\n\nIn single inheritance, a class (known as the derived class) can inherit attributes and methods from only one base class. This creates a straightforward and linear hierarchy, where each class has a single parent and can extend the functionality of that parent class.\n\nIn this Example\n\nAnimal is the base class with attributes and methods related to generic animals.\n\nMammal is the derived class that inherits from Animal. It has additional attributes like fur_color and a method specific to mammals (give_birth).\n\nAn instance of Mammal (in this case, a dog) can access both the attributes and methods from its own class (Mammal) and the base class (Animal).\n\nThis demonstrates the concept of single inheritance, where Mammal inherits from only one base class (Animal). If there were additional base classes, it would be an example of multiple inheritance.\n• Multiple Inheritance: A derived class inherits from more than one base class.\n\nIn multiple inheritance, a class (known as the derived class) can inherit attributes and methods from more than one base class. This allows the derived class to combine and extend the functionalities of multiple parent classes.\n\nIn this Example\n\nReptile is another base class with a method crawl.\n\nParrot is the derived class that inherits from both Bird and Reptile.\n\nThe Parrot class can access methods from both Bird and Reptile, combining the abilities of flying and crawling. This demonstrates the concept of multiple inheritance.\n\nIt’s important to note that while multiple inheritance can be powerful, it can also lead to challenges like the diamond problem. In Python, the method resolution order (MRO) is used to determine the sequence in which base classes are considered when searching for a method. The super() function is often used to call methods from the parent classes in a controlled way.\n• Multilevel Inheritance: A class is derived from a class, and then another class is derived from that derived class.\n\nIn multilevel inheritance, a class (known as the derived class) is derived from another class, and then another class is derived from that derived class. This creates a chain of inheritance, allowing each class to inherit properties and behaviors from the class above it in the hierarchy.\n\nIn this Example\n\nVehicle is the base class with a method start_engine.\n\n Car is a derived class from Vehicle with an additional method drive.\n\n SportsCar is further derived from Car and inherits methods from both Vehicle and Car. It also has its own method race.\n\nThe SportsCar class, through multilevel inheritance, inherits the ability to start the engine (start_engine), drive (drive), and race at high speed (race). This structure demonstrates the concept of multilevel inheritance where each class extends the functionality of the class above it in the hierarchy.\n\nIn hierarchical inheritance, multiple classes (known as derived classes) are derived from a single base class. Each derived class inherits the properties and behaviors of the common base class, forming a hierarchical structure.\n\nIn this Above Code\n\nThe Shape class is the base class, defining a method draw that provides a generic way to draw a shape.\n\nThe Circle class is derived from Shape and overrides the draw method to provide a specific implementation for drawing a circle.\n\nThe Square class is also derived from Shape and overrides the draw method to provide a specific implementation for drawing a square.\n\nWhen we create instances of Circle and Square and call their draw methods, we see that they produce different outputs based on their specific implementations. This showcases the essence of hierarchical inheritance:\n\ncircle.draw() returns “Drawing a circle”, demonstrating that Circle inherits from Shape and provides its own drawing method.\n\nsquare.draw() returns “Drawing a square”, demonstrating that Square similarly inherits from Shape and provides its own drawing method.\n\nHierarchical inheritance allows multiple classes to share a common base class (Shape in this case) and extend its functionality in different ways. Each derived class has a unique implementation of the shared method, providing a specialized behavior while still benefiting from the common features defined in the base class.\n\nIn hybrid inheritance, a class can inherit from multiple classes using a combination of any two or more types of inheritance: single, multiple, multilevel, or hierarchical. This allows for a diverse and flexible inheritance structure.\n\nClass A is the base class with a method method_A.\n\nClass B is derived from A and has its own method method_B.\n\nClass C is derived from B and introduces its method method_C.\n\nClass D is derived from both A and C, forming a combination of single and multiple inheritance. It introduces its method method_D.\n\nWhen we create an instance of class D (named instance_d), we can access methods from all the involved classes:\n\ninstance_d.method_A() calls the method from class A.\n\n instance_d.method_B() calls the method from class B.\n\n instance_d.method_C() calls the method from class C.\n\n instance_d.method_D() calls the method from class D.\n\nThis example illustrates how hybrid inheritance allows a class to inherit from multiple classes, providing a powerful mechanism for combining features and behaviors from different parts of the class hierarchy. The resulting class (D in this case) can leverage methods from all the involved classes in a flexible and modular manner.\n\nA base class is created with attributes and methods that will be inherited by the derived class.\n\nA derived class is created by specifying the base class in parentheses.\n\nIntermediate Class: This class is derived from the base class and serves as a base class for the next class in the hierarchy. It may have its attributes and methods in addition to those inherited from the base class.\n\nMethod overriding allows customization of methods in the derived class while maintaining the structure of the parent class.\n\nThe super() function is used to call methods from the parent class.\n\nCreating a simple hierarchy of animal classes demonstrates how inheritance helps organize and reuse code effectively.\n\nBuilding a basic employee management system using classes and inheritance showcases how different employee types can inherit common properties from a base employee class.\n\nIntroduction to abstract classes and their role in providing a blueprint for other classes, explaining the ABC module.\n\nDiscussing challenges and solutions in multiple inheritance, clarifying the concept of Method Resolution Order.\n\nWhen to Use Inheritance\n\nThere is a clear parent-child relationship between classes.\n\nYou want to reuse code effectively.\n\nYou need to organize complex class hierarchies.\n\nAvoid excessive inheritance and favor composition (creating objects from other objects) for simpler relationships.\n• Diamond problem: In multiple inheritance, conflicts can arise when two parent classes have the same method. Be mindful of MRO and plan inheritance carefully.\n• Overusing inheritance: Don’t force inheritance where composition is more suitable.\n• Complex hierarchies: Deep inheritance hierarchies can become hard to maintain. Favor simpler structures when possible.\n\nIn conclusion, understanding inheritance is crucial for effective Python programming. It not only promotes code reusability but also enhances code organization and modularity. By mastering the concepts and best practices outlined in this article, you’ll be better equipped to design robust and maintainable Python applications. Happy coding!"
    },
    {
        "link": "https://geeksforgeeks.org/inheritance-in-python",
        "document": "Inheritance is a fundamental concept in object-oriented programming (OOP) that allows a class (called a child or derived class) to inherit attributes and methods from another class (called a parent or base class). This promotes code reuse, modularity, and a hierarchical class structure. In this article, we’ll explore inheritance in Python.\n\nInheritance allows us to define a class that inherits all the methods and properties from another class.\n• None Animal is the parent class with an __init__ method and a speak method.\n• None Dog is the child class that inherits from Animal.\n• None The speak method is overridden in the Dog class to provide specific behavior.\n• Parent Class\n• None This is the base class from which other classes inherit.\n• None It contains attributes and methods that the child class can reuse.\n• Child Class:\n• None This is the derived class that inherits from the parent class.\n• None The syntax for inheritance is class ChildClass(ParentClass).\n• None The child class automatically gets all attributes and methods of the parent class unless overridden.\n\nIn object-oriented programming, a parent class (also known as a base class) defines common attributes and methods that can be inherited by other classes. These attributes and methods serve as the foundation for the child classes. By using inheritance, child classes can access and extend the functionality provided by the parent class.\n\nHere’s an example where Person is the parent class:\n• None The Person class has two attributes: name and id. These are set when an of the class is created.\n• None The display method prints the name and id of the person.\n\nA child class (also known as a subclass) is a class that inherits properties and methods from its parent class. The child class can also introduce additional attributes and methods, or even override the ones inherited from the parent.\n\nIn this case, Emp is the child class that inherits from the Person class:\n• Emp class inherits the name and id attributes and the display method from the Person class.\n• __init__ method in Emp calls super().__init__(name, id) to invoke the constructor of the Person class and initialize the inherited attributes.\n• Emp introduces an additional attribute, role, and also overrides the display method to print the role in addition to the name and id.\n\n__init__() function is a constructor method in Python. It initializes the object’s state when the object is created. If the child class does not define its own __init__() method, it will automatically inherit the one from the parent class.\n\nIn the example above, the __init__() method in the Employee class ensures that both inherited and new attributes are properly initialized.\n• __init__() method in Person initializes name and idnumber.\n• super().__init__(name, idnumber) to initialize the name and idnumber inherited from the Person class and adds salary and post.\n\nsuper() function is used to call the parent class’s methods. In particular, it is commonly used in the child class’s __init__() method to initialize inherited attributes. This way, the child class can leverage the functionality of the parent class.\n• None The super() function is used inside the __init__() method of Employee to call the constructor of Person and initialize the inherited attributes (name and idnumber).\n• None This ensures that the parent class functionality is reused without needing to rewrite the code in the child class.\n\nOnce inheritance is established, both the parent and child classes can have their own properties. Properties are attributes that belong to a class and are used to store data.\n• None Person class has properties name and idnumber\n• None The properties are initialized when an object is created, and they represent the specific data related to the Person and Employee.\n• Multiple Inheritance : A child class inherits from more than one parent class.\n• Multilevel Inheritance : A class is derived from a class which is also derived from another class.\n• Hybrid Inheritance : A combination of more than one type of inheritance.\n• Multiple Inheritance: EmployeePersonJob inherits from both Employee and Job, allowing access to both name and salary.\n• Multilevel Inheritance: Manager inherits from EmployeePersonJob, which already includes Employee and Job.\n• Hierarchical Inheritance : AssistantManager also inherits from EmployeePersonJob, demonstrating multiple child classes inheriting from the same parent.\n• Hybrid Inheritance : SeniorManager inherits from both Manager (multilevel) and AssistantManager (hierarchical), combining two inheritance types.\n\nFor more details please read this article: Types of inheritance in Python"
    },
    {
        "link": "https://stackoverflow.com/questions/4246000/how-to-call-python-functions-dynamically",
        "document": "I have come across this problem twice now, and finally came up with a safe and not ugly solution (in my humble opinion).\n\nglobals is the hacky, fast & easy method, but you have to be super consistent with your function names, and it can break at runtime if variables get overwritten. Also it's un-pythonic, unsafe, unethical, yadda yadda...\n\nDictionaries (i.e. string-to-function maps) are safer and easy to use... but it annoys me to no end, that i have to spread dictionary assignments across my file, that are easy to lose track of.\n\nDecorators made the dictionary solution come together for me. Decorators are a pretty way to attach side-effects & transformations to a function definition.\n\nWhenever you define a cleaner function, add this to the declaration:\n\nThe functions are added to the dictionary as soon as their definition is parsed and can be called like this:\n\nThis uses the function name of the cleaner method as its dictionary key. It is more concise, though I think the method names become a little awkward. Pick your favorite."
    },
    {
        "link": "https://stackoverflow.com/questions/68332780/how-to-dynamically-call-different-functions-based-on-user-input",
        "document": "I am looking to figure out how I can dynamically call certain functions based on user input. For example, I have the following code that just does simple math based on a series of keyword arguments.\n\nI know there are better ways to do a calculator of course, but the point here is I want to try and avoid using a bunch of if/elses to check and see what function to run between add/sub/divide/multiply. I thought I could save it into a variable called \"operation\" and use that to call the proper function, but that will not work as a string isn't callable.\n\nEssentially I want to be able to dynamically call a function based on user input (assuming the user input is exactly the name of the function) but I am unsure how."
    },
    {
        "link": "https://danielmorell.com/blog/dynamically-calling-functions-in-python-safely",
        "document": "Before I started writing Python code, I spent most of my time working with PHP. There are a few things that PHP makes first class citizens to the language. One of them is dynamic class inclusion, and the other is the ability to dynamically call a function.\n\nPython on the other hand does not make either of these easy. There is good reason. Both autoloading classes and dynamically executing functions lean toward the magical side of programming. Code that uses dynamic function calls can become confusing very fast.\n\nYou may be wondering what I mean by \"dynamically\" call a function. Let's look at a quick example in PHP. Even if you have never looked at PHP, you should be able to understand what is going on.\n\nNote: in this example the type declarations are optional, but they are a good practice.\n\nIn this example, the function can be called as long as we know the name of the function i.e. . As long as we know the name of the function we want to call, we can execute the function and even pass in arguments.\n\nThis is the idea behind dynamic function execution. The function that will be executed is not determined when the code is written. It is determined at runtime.\n\nDoing this in Python is a little more complicated. As we said earlier, that is not necessarily bad. To do this in Python you have to access the global namespace. Python makes you do this explicitly where PHP is implicit.\n\nIn this example we use the function to access the global namespace. returns a dictionary that includes as a key and the value is a reference to the function. If you are not familiar with a simple change to our code can give you a clear idea of what we are doing.\n\nYou can see that both and point to the same address in memory . This means that in the current scope calling and would run the exact same function.\n\nJust because you can do something does not mean you should. Using in this way is often frowned on as neither pythonic nor safe. It is safer to use or to access just the local scope, but still not ideal.\n\nFortunately, the objects in scope in this way is not as dangerous as it could be. Python built in functions and classes are available in the key. This is very important, since It means calling will raise a . You would actually need to call .\n\nLet's be honest Python's built in functions and classes are not the only exploitable objects in any program.\n\nA better way is to use a class to encapsulate the methods you want to make available to execute at runtime. You can create each function as a method of the class. When the name of a function is provided you can test to see if it is an attribute of the class and callable.\n\nIf you are looking at the statement in the method and getting a little confused. Don't worry. I am using some syntax that is new in Python 3.8.\n\nThe assignment expression allows you to both set the value of a variable and evaluate the result of an expression in a single line.\n\nThe function is equivalent to the following...\n\nThe difference is that does not need to be evaluated twice.\n\nLet's get back to our example.\n\nThe method is really doing most of the heavy lifting here. It first takes the and appends to the front. This is often a good idea. Your class will likely have few extra methods and attributes that you don't want to expose.\n\nOnce the name of the function has been determined we can check to make sure it is a valid attribute and a function that we can call. The last thing we do is simply call the function.\n\nPassing arguments to the dynamic function is straight forward. We simply can make accept and then pass that to .\n\nOf course, you will need to handle the arguments in the function that will be called. Currently, none of the methods in our example accept arguments.\n\nOne of the complexities of using arguments with dynamic function execution is the need for each function to handle the same arguments. This requires you to standardize your function arguments.\n\nTwo of the common uses for dynamic function execution in PHP are callbacks and hooks. However, in Python neither of these are very common.\n\nI think Python's focus on being explicit keeps developers from moving toward meta and magical programming. Python also provides decorators that can be used to explicitly hook or wrap a function. These two things limit the use of dynamic function calls.\n\nI think the best example of dynamic function execution in Python is form validation in Django. Let's say we had a form like this...\n\nWhen Django validates and parses the values to native Python data types it will call a function for each field. The function is where is the name of the field.\n\nIn this example we could add a method to ensure the value of name is valid and formatted the way we want.\n\nThis is a very simple example. We are just taking whatever value is given in and making it lower case. is called by Django's method.\n\nThe method from Django is a good example of how to execute a function dynamically.\n\nThe reason exists is not because it is imposible to do this any other way. But because it provides a clean interface for developers building forms in Django.\n\nI think this is a good example of why you may want to use this pattern. In general, I would recommend avoiding it, but there are times when it makes a library or API easy for developers to use. In those instances, don't shy away from doing it, but make sure you do it safely!"
    },
    {
        "link": "https://medium.com/@python-javascript-php-html-css/dynamic-function-replacement-in-c-for-card-game-mechanics-56371f7847fc",
        "document": "Imagine designing a card game where each card can evolve dynamically with new abilities. 🎴 You want to modify the Play() function of a card at runtime, adding effects like “Mill a card” or “Play it twice.” This creates a highly flexible system where cards adapt to upgrades seamlessly.\n\nTraditionally, modifying functions dynamically in C++ is tricky due to its static nature. Unlike languages with built-in function reassignments, C++ requires a structured approach, such as function pointers, lambdas, or std::function. Choosing the right method ensures efficiency and maintainability.\n\nOne challenge is preserving the original function while layering upgrades without rewriting massive amounts of code. You need a method to wrap the existing Play() function and extend its behavior based on the applied upgrades. Think of it like decorating a cake — each layer adds a unique flavor without replacing the entire cake! 🎂\n\nIn this article, we’ll explore how to implement function replacement dynamically in C++. We’ll look at strategies like function pointers and std::function while discussing their trade-offs. Whether you’re new to C++ or refining an existing system, these techniques will help you create a more flexible and scalable game design.\n\nIn a dynamic card game, modifying the Play() function at runtime allows for greater flexibility in gameplay. Instead of writing separate versions of the Play function for each upgrade, we use function pointers, lambdas, and std::function to modify the behavior of the card dynamically. This approach enables cards to receive upgrades such as “Mill a card” or “Play twice” without rewriting existing logic. Imagine playing a collectible card game where you attach an ability to a card mid-game, altering its effect instantly! 🎴\n\nOne of the key techniques used is the function wrapper provided by std::function. This allows us to store a function and later modify it with additional behaviors. For example, when an upgrade is applied, we capture the previous Play() function and wrap it inside a new function that extends its behavior. This is similar to adding an extra layer of strategy in a game — just like stacking buffs on a character in an RPG! 🛡️\n\nAnother method we explored is using function pointers. Function pointers allow us to change which function is called at runtime, making them ideal for cases where performance is critical. While they provide flexibility, they can be harder to manage than std::function, especially when capturing local variables. However, function pointers are useful in performance-sensitive scenarios, such as real-time card interactions or AI decision-making in a card game.\n\nFinally, an object-oriented approach using inheritance and method overriding was implemented. This method allows us to extend the Play() function by creating derived classes that modify its behavior. For example, a special card type could inherit from the base card class and override Play() to include additional effects. This is useful when designing more complex game mechanics where specific card types require unique behaviors. By combining these techniques, developers can create a highly modular and extensible card game system that supports dynamic upgrades seamlessly.\n\nModifying Functionality at Runtime in a C++ Card Game\n\nUsing function pointers, lambdas, and std::function in C++ for dynamic behavior modification\n\nUsing Function Pointers to Dynamically Replace a Method in C++\n\nImplementation using function pointers for better control in runtime modifications\n\nUsing a Class-Based Approach for More Extensible Card Upgrades\n\nAnother powerful way to modify functions dynamically in C++ is by using a decorator pattern. This method allows us to wrap an existing function with additional behaviors while keeping the core logic intact. Instead of directly replacing the Play() function, we create a chain of modifications, similar to applying buffs in a role-playing game. Imagine you have a base card that deals damage, and you add a “Burn” effect — each time the card is played, the enemy also takes damage over time. 🔥\n\nMiddleware-style function wrapping is another approach inspired by web development but applicable to game mechanics. Here, each effect acts as a layer that gets executed before or after the main function. Using std::vector to store multiple function wrappers allows stacking multiple upgrades dynamically. For example, a card could gain both “Play twice” and “Mill a card” abilities without overwriting previous effects. This is similar to equipping multiple power-ups in a game, where each enhancement adds new abilities.\n\nFinally, considering event-driven programming can further optimize runtime modifications. By using an observer pattern, cards can register effects dynamically and respond to triggers. This is useful when handling complex interactions, such as chaining multiple effects based on specific conditions. For instance, a card might gain a different effect if played under certain circumstances, like drawing an extra card if another card was played earlier in the turn. These techniques make function replacement in C++ more flexible and scalable. 🎮\n\nCommon Questions About Runtime Function Replacement in C++\n\nWhat is the best way to replace a function at runtime in C++?\n\nUsing std::function provides flexibility while maintaining readability. Function pointers can also be useful for performance-critical applications.\n\nHow do I preserve the original function while modifying it?\n\nStore the original function in a variable before replacing it, then call it inside the new function using a lambda wrapper.\n\nYes! Using std::vector to store function wrappers allows for stacking multiple upgrades dynamically.\n\nWhat are the performance considerations when modifying functions at runtime?\n\nFunction pointers are faster but less flexible. std::function adds slight overhead but improves maintainability.\n\nHow does this compare to using inheritance for modifying behavior?\n\nInheritance works well for predefined behavior changes, while function replacement is better for dynamic, runtime modifications.\n\nUsing runtime function replacement in C++ is a powerful technique for adding flexibility to a game system. By leveraging function pointers, lambda expressions, and std::function, developers can modify card behaviors dynamically. This method ensures that game mechanics stay adaptable without requiring excessive rewrites or complex class hierarchies.\n\nBeyond card games, this approach is useful in AI behavior changes, plugin systems, and dynamic event handling. It allows for real-time modifications without restarting the application. Whether you’re designing a digital card game or an interactive simulation, mastering function replacement techniques will greatly enhance your development workflow. 🚀\n\nDetailed explanation on std::function and its applications in C++: cppreference.com\n\nBest practices for function pointers and their alternatives: ISO C++ FAQ\n\nDynamic Function Replacement in C++ for Card Game Mechanics"
    },
    {
        "link": "https://labex.io/tutorials/python-how-to-implement-dynamic-method-calling-420868",
        "document": "Dynamic method calling in Python can be achieved through multiple techniques, each with unique characteristics and use cases.\n\ngraph TD A[Method Call] --> B{Method Exists?} B -->|Yes| C[Execute Method] B -->|No| D[Handle Error/Fallback] C --> E[Return Result] D --> F[Raise Exception/Default Action]\n\nBy mastering these dynamic method calling techniques, developers can create more flexible and adaptable Python applications."
    }
]