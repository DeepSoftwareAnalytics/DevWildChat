[
    {
        "link": "https://socket.io/docs/v4",
        "document": "Socket.IO is a library that enables low-latency, bidirectional and event-based communication between a client and a server.\n\nThe Socket.IO connection can be established with different low-level transports:\n\nSocket.IO will automatically pick the best available option, depending on:\n• the capabilities of the browser (see here and here)\n\nYou can find more detail about that in the \"How it works\" section.\n\nAlthough Socket.IO indeed uses WebSocket for transport when possible, it adds additional metadata to each packet. That is why a WebSocket client will not be able to successfully connect to a Socket.IO server, and a Socket.IO client will not be able to connect to a plain WebSocket server either.\n\nIf you are looking for a plain WebSocket server, please take a look at ws or µWebSockets.js.\n\nThere are also discussions for including a WebSocket server in the Node.js core.\n\nOn the client-side, you might be interested in the robust-websocket package.\n\nThe Socket.IO library keeps an open TCP connection to the server, which may result in a high battery drain for your users. Please use a dedicated messaging platform like FCM for this use case.\n\nHere are the features provided by Socket.IO over plain WebSockets:\n\nThe connection will fall back to HTTP long-polling in case the WebSocket connection cannot be established.\n\nThis feature was the #1 reason people used Socket.IO when the project was created more than ten years ago (!), as the browser support for WebSockets was still in its infancy.\n\nEven if most browsers now support WebSockets (more than 97%), it is still a great feature as we still receive reports from users that cannot establish a WebSocket connection because they are behind some misconfigured proxy.\n\nUnder some particular conditions, the WebSocket connection between the server and the client can be interrupted with both sides being unaware of the broken state of the link.\n\nThat's why Socket.IO includes a heartbeat mechanism, which periodically checks the status of the connection.\n\nAnd when the client eventually gets disconnected, it automatically reconnects with an exponential back-off delay, in order not to overwhelm the server.\n\nThe packets are automatically buffered when the client is disconnected, and will be sent upon reconnection.\n\nSocket.IO provides a convenient way to send an event and receive a response:\n\nYou can also add a timeout:\n\nOn the server-side, you can send an event to all connected clients or to a subset of clients:\n\nThis also works when scaling to multiple nodes.\n\nNamespaces allow you to split the logic of your application over a single shared connection. This can be useful for example if you want to create an \"admin\" channel that only authorized users can join.\n\nMore on that here.\n\nThat's a fair question, since WebSockets are supported almost everywhere now.\n\nThat being said, we believe that, if you use plain WebSockets for your application, you will eventually need to implement most of the features that are already included (and battle-tested) in Socket.IO, like reconnection, acknowledgements or broadcasting.\n\nwill be sent as a single WebSocket frame containing with:\n• being the -ed version of the arguments array\n\nSo, a few additional bytes for each message, which can be further reduced by the usage of a custom parser.\n\nYou can find the details of the Socket.IO protocol here."
    },
    {
        "link": "https://socket.io/docs/v4/client-api",
        "document": "The method is bound to the global scope in the standalone build:\n\nAn ESM bundle is also available since version 4.3.0:\n\nElse, in all other cases (with some build tools, in Node.js or React Native), it can be imported from the package:\n\nThe protocol defines the format of the packets exchanged between the client and the server. Both the client and the server must use the same revision in order to understand each other.\n\nYou can find more information here.\n• \n• whether to create a new connection\n\nCreates a new for the given URL, and attempts to reuse an existing for subsequent calls, unless the option is passed with . Passing this option is the equivalent of passing or .\n\nA new instance is returned for the namespace specified by the pathname in the URL, defaulting to . For example, if the is , a transport connection will be established to and a Socket.IO connection will be established to .\n\nQuery parameters can also be provided, either with the option or directly in the url (example: ).\n\nTo understand what happens under the hood, the following example:\n\nis the short version of:\n\nThe complete list of available options can be found here.\n\nThe manages the Engine.IO client instance, which is the low-level engine that establishes the connection to the server (by using transports like WebSocket or HTTP long-polling).\n\nA single can be used by several Sockets. You can find more information about this multiplexing feature here.\n\nPlease note that, in most cases, you won't use the Manager directly but use the Socket instance instead.\n\nThe complete list of available options can be found here.\n\nFired when a ping packet is received from the server.\n\nFired upon an attempt to reconnect.\n\nIf the manager was initiated with to , launch a new connection attempt.\n\nThe argument is optional and will be called once the attempt fails/succeeds.\n\nSets the option, or returns it if no parameters are passed.\n\nSets the option, or returns it if no parameters are passed.\n\nSets the option, or returns it if no parameters are passed.\n\nSets the option, or returns it if no parameters are passed.\n\nCreates a new for the given namespace. Only ( ) is read from the object. Other keys will be ignored and should be passed when instancing a .\n\nSets the option, or returns it if no parameters are passed.\n\nA is the fundamental class for interacting with the server. A belongs to a certain Namespace (by default ) and uses an underlying Manager to communicate.\n\nA is basically an EventEmitter which sends events to — and receive events from — the server over the network.\n\nMore information can be found here.\n\nThis event is fired by the Socket instance upon connection and reconnection.\n\nThis event is fired upon connection failure.\n\nThe attribute indicates whether the socket will automatically try to reconnect after a small randomized delay:\n\nThis event is fired upon disconnection.\n\nHere is the list of possible reasons:\n\nThe attribute indicates whether the socket will automatically try to reconnect after a small randomized delay:\n\nWhether the socket will automatically try to reconnect.\n\nThis attribute can be used after a connection failure:\n\nWhether the socket is currently connected to the server.\n\nWhether the socket is currently disconnected from the server.\n\nA unique identifier for the socket session. Set after the event is triggered, and updated after the event.\n\nWhether the connection state was successfully recovered during the last reconnection.\n\nMore information about this feature here.\n\nSets a modifier for a subsequent event emission that the event data will only be compressed if the value is . Defaults to when you don't call the method.\n\nIt can also be used to manually reconnect:\n\nManually disconnects the socket. In that case, the socket will not try to reconnect.\n\nIf this is the last active Socket instance of the Manager, the low-level connection will be closed.\n\nEmits an event to the socket identified by the string name. Any other parameters can be included. All serializable data structures are supported, including .\n\nThe argument is optional and will be called with the server answer.\n\nPromised-based version of emitting and expecting an acknowledgement from the server:\n\nThe example above is equivalent to:\n\nAnd on the receiving side:\n\nReturns the array of listeners for the event named .\n\nReturns the list of registered catch-all listeners for outgoing packets.\n\nRemoves the specified from the listener array for the event named .\n\nThe argument can also be omitted:\n\nRemoves the previously registered listener. If no listener is provided, all catch-all listeners are removed.\n\nRemoves the previously registered listener. If no listener is provided, all catch-all listeners are removed.\n\nRegister a new handler for the given event.\n\nAdds a one-time function for the event named . The next time is triggered, this listener is removed and then invoked.\n\nRegister a new catch-all listener. The listener is added to the beginning of the listeners array.\n\nRegister a new catch-all listener for outgoing packets. The listener is added to the beginning of the listeners array.\n\nSets a modifier for a subsequent event emission that the callback will be called with an error when the given number of milliseconds have elapsed without an acknowledgement from the server:\n\nSets a modifier for the subsequent event emission indicating that the packet may be dropped if:\n• the socket is not connected\n• the low-level transport is not writable (for example, when a request is already running in HTTP long-polling mode)"
    },
    {
        "link": "https://socket.io/docs/v4/listening-to-events",
        "document": "There are several ways to handle events that are transmitted between the server and the client.\n\nOn the server-side, the Socket instance extends the Node.js EventEmitter class.\n\nOn the client-side, the Socket instance uses the event emitter provided by the component-emitter library, which exposes a subset of the EventEmitter methods.\n\nAdds the listener function to the end of the listeners array for the event named eventName.\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nRemoves all listeners, or those of the specified eventName.\n\nSince Socket.IO v3, a new API inspired from the EventEmitter2 library allows to declare catch-all listeners.\n\nThis feature is available on both the client and the server.\n\nAdds a listener that will be fired when any event is emitted.\n\nAdds a listener that will be fired when any event is emitted. The listener is added to the beginning of the listeners array.\n\nRemoves all catch-all listeners, or the given listener.\n\nRegister a new catch-all listener for outgoing packets. The listener is added to the beginning of the listeners array.\n\nRemoves the previously registered listener. If no listener is provided, all catch-all listeners are removed.\n\nThe validation of the event arguments is out of the scope of the Socket.IO library.\n\nThere are many packages in the JS ecosystem which cover this use case, among them:\n\nExample with joi and acknowledgements:\n\nThere is currently no built-in error handling in the Socket.IO library, which means you must catch any error that could be thrown in a listener.\n\nThis can be refactored into:"
    },
    {
        "link": "https://socket.io/docs/v4/middlewares",
        "document": "A middleware function is a function that gets executed for every incoming connection.\n\nMiddleware functions can be useful for:\n\nNote: this function will be executed only once per connection (even if the connection consists in multiple HTTP requests).\n\nA middleware function has access to the Socket instance and to the next registered middleware function.\n\nYou can register several middleware functions, and they will be executed sequentially:\n\nPlease make sure to call in any case. Otherwise, the connection will be left hanging until it is closed after a given timeout.\n\nImportant note: the Socket instance is not actually connected when the middleware gets executed, which means that no event will be emitted if the connection eventually fails.\n\nFor example, if the client manually closes the connection:\n\nThe client can send credentials with the option:\n\nThose credentials can be accessed in the handshake object on the server-side:\n\nIf the method is called with an Error object, the connection will be refused and the client will receive an event.\n\nYou can attach additional details to the Error object:\n\nSince they are not bound to a usual HTTP request/response cycle, Socket.IO middlewares are not really compatible with Express middlewares.\n\nThat being said, starting with version , Express middlewares are now supported by the underlying engine:\n\nThe middlewares will be called for each incoming HTTP requests, including upgrade requests.\n\nIf the middleware must be only applied to the handshake request (and not for each HTTP request), you can check for the existence of the query parameter."
    },
    {
        "link": "https://socket.io/docs/v4/troubleshooting-connection-issues",
        "document": "\n• the socket is not able to connect\n• the socket is stuck in HTTP long-polling\n\nOn the client side, the event provides additional information:\n\nOn the server side, the event may also provide some additional insights:\n\nHere is the list of possible error codes:\n\nAs explained in the \"What Socket.IO is not\" section, the Socket.IO client is not a WebSocket implementation and thus will not be able to establish a connection with a WebSocket server, even with :\n\nPlease make sure the Socket.IO server is actually reachable at the given URL. You can test it with:\n\nwhich should return something like this:\n\nIf that's not the case, please check that the Socket.IO server is running, and that there is nothing in between that prevents the connection.\n\nMaintaining backward compatibility is a top priority for us, but in some particular cases we had to implement some breaking changes at the protocol level:\n• from v1.x to v2.0.0 (released in May 2017), to improve the compatibility with non-Javascript clients (see here)\n• from v2.x to v3.0.0 (released in November 2020), to fix some long-standing issues in the protocol once for all (see here)\n\nFor example, reaching a v3/v4 server with a v1/v2 client will result in the following response:\n\nHere is the compatibility table for the JS client:\n\nHere is the compatibility table for the Java client:\n\nHere is the compatibility table for the Swift client:\n\n[1] Yes, with allowEIO3: true (server) and (client):\n\nIf you see the following error in your console:\n\nIt probably means that:\n• either you are not actually reaching the Socket.IO server (see above)\n• or you didn't enable Cross-Origin Resource Sharing (CORS) on the server-side.\n\nPlease see the documentation here.\n\nWhen scaling to multiple Socket.IO servers, you need to make sure that all the requests of a given Socket.IO session reach the same Socket.IO server. The explanation can be found here.\n\nFailure to do so will result in HTTP 400 responses with the code:\n\nPlease see the documentation here.\n\nBy default, the client sends — and the server expects — HTTP requests with the \"/socket.io/\" request path.\n\nThis can be controlled with the option:\n\nIn that case, the HTTP requests will look like .\n\nFirst and foremost, please note that disconnections are common and expected, even on a stable Internet connection:\n• anything between the user and the Socket.IO server may encounter a temporary failure or be restarted\n• the server itself may be killed as part of an autoscaling policy\n• the user may lose connection or switch from WiFi to 4G, in case of a mobile browser\n• the browser itself may freeze an inactive tab\n\nThat being said, the Socket.IO client will always try to reconnect, unless specifically told otherwise.\n\nThe possible reasons are listed here.\n\nIf the disconnection happens at a regular interval, this might indicate that something between the server and the client is not properly configured and closes the connection:\n\nThe value of nginx's (60 seconds by default) must be bigger than Socket.IO's (45 seconds by default), else it will forcefully close the connection if no data is sent after the given delay and the client will get a \"transport close\" error.\n\nThe value of httpd's (60 seconds by default) must be bigger than Socket.IO's (45 seconds by default), else it will forcefully close the connection if no data is sent after the given delay and the client will get a \"transport close\" error.\n\nWhen a browser tab is not in focus, some browsers (like Chrome) throttle JavaScript timers, which could lead to a disconnection by ping timeout in Socket.IO v2, as the heartbeat mechanism relied on function on the client side.\n\nAs a workaround, you can increase the value on the server side:\n\nPlease note that upgrading to Socket.IO v4 (at least , due to this) should prevent this kind of issues, as the heartbeat mechanism has been reversed (the server now sends PING packets).\n\nSince the format of the packets sent over the WebSocket transport is similar in v2 and v3/v4, you might be able to connect with an incompatible client (see above), but the connection will eventually be closed after a given delay.\n\nSo if you are experiencing a regular disconnection after 30 seconds (which was the sum of the values of pingTimeout and pingInterval in Socket.IO v2), this is certainly due to a version incompatibility.\n\nIf you get disconnected while sending a huge payload, this may mean that you have reached the value, which defaults to 1 MB. Please adjust it according to your needs:\n\nA huge payload taking more time to upload than the value of the option can also trigger a disconnection (since the heartbeat mechanism fails during the upload). Please adjust it according to your needs:\n\nIn most cases, you should see something like this:\n• the Engine.IO handshake (contains the session ID — here, — that is used in subsequent requests)\n• the Socket.IO handshake request (contains the value of the option)\n• the Socket.IO handshake response (contains the Socket#id)\n• the first HTTP long-polling request, which is closed once the WebSocket connection is established\n\nIf you don't see a HTTP 101 Switching Protocols response for the 4th request, that means that something between the server and your browser is preventing the WebSocket connection.\n\nPlease note that this is not necessarily blocking since the connection is still established with HTTP long-polling, but it is less efficient.\n\nYou can get the name of the current transport with:\n\nIf a proxy like nginx or Apache HTTPD is not properly configured to accept WebSocket connections, then you might get a error:\n\nWhich means that the Socket.IO server does not receive the necessary header (you can check the object).\n\nPlease see the documentation here.\n\nPlease see the solution here.\n\nOn the client side, the event will be emitted every time the socket reconnects, so the event listeners must be registered outside the event listener:\n\nIf that's not the case, your event listener might be called multiple times.\n\nPlease note that, unless connection state recovery is enabled, the attribute is an ephemeral ID that is not meant to be used in your application (or only for debugging purposes) because:\n• this ID is regenerated after each reconnection (for example when the WebSocket connection is severed, or when the user refreshes the page)\n• two different browser tabs will have two different IDs\n• there is no message queue stored for a given ID on the server (i.e. if the client is disconnected, the messages sent from the server to this ID are lost)\n\nPlease use a regular session ID instead (either sent in a cookie, or stored in the localStorage and sent in the payload).\n• How to deal with cookies\n\nSince most serverless platforms (such as Vercel) bill by the duration of the request handler, maintaining a long-running connection with Socket.IO (or even plain WebSocket) is not recommended."
    },
    {
        "link": "https://stackoverflow.com/questions/41092082/best-practice-for-handling-socket-io-events",
        "document": "I am switching from ajax polling to socket.io live data pushing but have a question about best practice of managing events.\n\nLet's say I have a basic server like this:\n\nIn the example there is a event, but ideally there are many other events I'd like to push to clients in real-time, such as:\n\nUser sends message, user starts/stops typing, user likes a post, user invites you to become friends/group member, and so on.\n\nThere are many events that I'd like to capture in real-time but it seems like there has to be a better way than cramming the statement full of them all.\n\nI've looked into Node OOP but not sure if it would necessarily help in this application.\n\nSo where we have the statements, what would the best practice be for including event catching like I described?"
    },
    {
        "link": "https://aslamanver.medium.com/socket-io-session-handler-for-node-js-90c15519fa02",
        "document": "When we use Socket.IO for connecting many clients at a same time with Socket transports we need to handle the connection and disconnection triggers at the time of the event occurred, but unfortunately, you need to do a lot of array-based connection operations to simply handle the connections, that’s why the io-session-handler library was built for.\n\nLet me explain the logic behind this Socket.IO connection method.\n\nWhen the first time a client connected to Socket.IO server from a browser the Socket.IO creates an ID for the particular connection and manages it by itself and when the user creates another browser tab while the previous connection is still alive, the Socket.IO creates another ID for the user.\n\nAnyhow those two connections belong to a single user which is not understandable by Socket.IO that’s the reason it will consider as two connections are totally two users.\n\nAt this problem, we need to find a solution to let the Socket.IO server knows that those two or more connections created from a browser at a particular login session are totally from a single user which cannot be considered as two users but two sessions from a single user.\n\nSo what is the solution?\n\nWell, this is actually obvious, when a user login or starts to connect the Socket.IO session we assign a token to the particular user to identify the sessions from user authority. After that how many tabs or browsers the user opens will carry the token to the server until the authentication session time is expired.\n\nNow we know the client-side logic for the solution, furthermore, we can refer to the below table.\n\nAll the sessions which are created by a single user will be having the same token which will be sent to the Socket.IO server.\n\nNow let’s talk about the server-side logic.\n\nThe server has an array list of all the users in concurrent connections, as users[]. When a user connects the Socket.IO server at the initial time the server will find the current user’s token on its users[] array list so in this case, now the server will not find any tokens in its array list since this is the first time the particular user tries to connect the server.\n\nThen the server will create an object with token and sessions for the user as below and push the object to the users[] array list.\n\nWhen the user tries to create another browser tab while the previous tab is still alive, the server will get the ID of the created tab connection and it will push the connection ID to the connections array of the user’s object from users[] array list.\n\nNow the server can understand all the connections coming with the same tokens should be stored as connections of a single user in the users[] array list.\n\nHow to handle the disconnect event?\n\nIt’s the tricky part of this lesson, we need to think about some facts before implementing programming logic for this part.\n\nWhen a user connects with the Socker.IO server, as we discussed an object will be created and pushed to the users’ array but let’s assume that if the user refresh the browser tab, Socket.IO will consider as the session is disconnected and once the page refreshed, it will generate another connection ID for the same user.\n\nThe user may refresh the page or try to connect the server from an unstable internet connection, in this case, our server should not consider that the user has been totally disconnected rather the server should wait a certain period of time to see whether the user is connecting back or no any responses from the connection after few seconds.\n\nThis is how we are gonna implement the disconnect event triggering logic on the Socket.IO server.\n\nOnce a client connection is dropped, the server will be still waiting a few seconds for any responses from the client, before it totally removes the user from the users[] array list and triggers the disconnect event.\n\nAfter a certain period of time is completed but still, the server is not receiving any responses from the client it clearly indicates the user has not refreshed the page or not in an unstable connection but the user has chosen to close the browser or log out which is a good point to trigger the disconnect event and remove the dropped user object from the users[] array list from the server."
    },
    {
        "link": "https://stackoverflow.com/questions/28777230/how-to-handle-sessions-with-socket-io-and-express",
        "document": "I have an application up and running. Users requested that after they log in they would stay logged when they come back later.\n\nI know that I need somehow store session data on client side, cookies for example. I tried this https://stackoverflow.com/a/25618636/2440515 but it doesn't work. Neither this https://www.npmjs.com/package/socket.io-handshake\n\nI have both Express and Socket.io in the latests versions.\n\nMy application authenticates using Socket.io, so I will need a way to update cookies from Socket.io callback. I spent last 4h searching and trying different solutions. Can someone give me a hint?"
    },
    {
        "link": "https://socket.io/docs/v4/using-multiple-nodes",
        "document": "When deploying multiple Socket.IO servers, there are two things to take care of:\n• enabling sticky session, if HTTP long-polling is enabled (which is the default): see below\n• using a compatible adapter, see here\n\nIf you plan to distribute the load of connections among different processes or machines, you have to make sure that all requests associated with a particular session ID reach the process that originated them.\n\nThis is because the HTTP long-polling transport sends multiple HTTP requests during the lifetime of the Socket.IO session.\n\nIn fact, Socket.IO could technically work without sticky sessions, with the following synchronization (in dashed lines):\n\nWhile obviously possible to implement, we think that this synchronization process between the Socket.IO servers would result in a big performance hit for your application.\n• without enabling sticky-session, you will experience HTTP 400 errors due to \"Session ID unknown\"\n• the WebSocket transport does not have this limitation, since it relies on a single TCP connection for the whole session. Which means that if you disable the HTTP long-polling transport (which is a perfectly valid choice in 2021), you won't need sticky sessions:\n\nTo achieve sticky-session, there are two main solutions:\n\nYou will find below some examples with common load-balancing solutions:\n\nFor other platforms, please refer to the relevant documentation:\n\nImportant note: if you are in a CORS situation (the front domain is different from the server domain) and session affinity is achieved with a cookie, you need to allow credentials:\n\nWithout it, the cookie will not be sent by the browser and you will experience HTTP 400 \"Session ID unknown\" responses. More information here.\n\nWithin the section of your file, you can declare a section with a list of Socket.IO process you want to balance load between:\n\nNotice the instruction that indicates the connections will be sticky.\n\nMake sure you also configure in the topmost level to indicate how many workers nginx should use. You might also want to look into tweaking the setting within the block.\n\nWithin the section of your Ingress configuration, you can declare an upstream hashing based on the client's IP address, so that the Ingress controller always assigns the requests from a given IP address to the same pod:\n\nThis annotation instructs the NGINX Ingress Controller to use the client's IP address for routing incoming traffic to a specific Pod in your Kubernetes cluster. This is crucial for maintaining sticky sessions.\n• None If the request passes through upstream reverse proxies or API gateways that append an header, this snippet extracts the first IP address from that header and uses it to update the $client_ip.\n• None In the absence of such proxies or gateways, the snippet simply uses the remote_addr, which is the IP address of the client directly connected to the ingress.\n\nThis ensures that the correct client IP is used for the sticky session logic, enabled by the annotation. The snippet is particularly important when your architecture includes upstream network components like reverse proxies or API gateways.\n\nJust like nginx, Node.js comes with built-in clustering support through the module.\n\nThere are several solutions, depending on your use case:\n\nNow that you have multiple Socket.IO nodes accepting connections, if you want to broadcast events to all clients (or to the clients in a certain room) you ’ ll need some way of passing messages between processes or computers.\n\nThe interface in charge of routing messages is what we call the Adapter."
    },
    {
        "link": "https://dev.to/imsushant12/real-time-communication-with-websockets-and-socketio-in-nodejs-4p8e",
        "document": "Conclusion of My Node.js Journey and a Sneak Peek into My Upcoming AWS Series\n\nWorking with WebSocket and Real-Time Communication in Node.js\n\nLogging and Monitoring in Node.js: Best Practices\n\nMonitoring and Logging in Node.js Applications: Best Practices and Tools\n\nUnderstanding SSL, Encryption, and Their Importance in Web Applications\n\nNode.js Streams: What, Why, and How to Use Them\n\nReal-time communication with WebSockets and Socket.IO in Node.js\n\nUnderstanding Node.js Streams: What, Why, and How to Use Them\n\nNGINX for Node.js Applications: What, Why, and How to Use It\n\nMastering Event-Driven Programming with the EventEmitter in Node.js\n\nSecuring Web Applications: Stateful vs. Stateless Systems, Authentication, and Authorization in Node.js\n\nModern web applications often require real-time communication, whether for chat systems, live updates, collaborative editing, or notifications. Traditional HTTP communication is insufficient for real-time applications as it relies on request-response patterns. This is where WebSockets come into play, allowing for full-duplex communication between the server and the client.\n\nIn this article, we will explore:\n• What WebSockets are, and why they are essential for real-time applications.\n• How to implement WebSockets in Node.js.\n\nWebSockets are a protocol that provides full-duplex communication channels over a single TCP connection. Unlike traditional HTTP requests, which are request-response-based and have overhead in continuously establishing new connections, WebSockets allow persistent communication.\n• Full-Duplex Communication: Both client and server can send messages at any time without waiting for each other.\n• Lower Latency: WebSockets eliminate the need to constantly open and close connections, reducing latency and improving performance for real-time apps.\n• Event-Driven: Both sides can push data, making it ideal for dynamic applications like chat, gaming, or real-time notifications.\n\nIn Node.js, WebSockets are not built-in, so we need a library. One of the most popular WebSocket libraries for Node.js is .\n\n\n\nIn this example:\n• The server listens for messages from the client and responds with a confirmation message.\n• If the client disconnects, we log a message.\n\nYou can create a WebSocket client using JavaScript in the browser:\n• When the WebSocket connection opens, the client logs a success message.\n• A message is sent to the server when the button is clicked, and the server’s response is displayed.\n\nWhile WebSockets are powerful, they require some manual work for handling events like reconnections, broadcasting, and managing fallbacks (e.g., long polling). Socket.IO simplifies real-time communication by providing features like:\n• Fallback to polling if WebSockets are not supported.\n• We create a server using Socket.IO that listens for connections and incoming messages.\n• is used to send a message back to the client.\n\nIn this example, the Socket.IO client automatically handles the connection to the server and allows bidirectional communication.\n\nUse Cases for WebSockets and Socket.IO\n\nProblem: A messaging platform needs to enable real-time communication between users.\n\nSolution: WebSockets (or Socket.IO) provide an event-driven, persistent connection, allowing users to send and receive messages in real time without delays.\n\nProblem: Users collaborating on a document need to see changes made by others instantly.\n\nSolution: By using WebSockets, changes are pushed to all clients in real time, ensuring that the document remains synchronized across all users.\n\nProblem: A web application needs to notify users of events like new messages, updates, or alerts.\n\nSolution: WebSockets allow the server to push notifications to the client as soon as events occur, improving user engagement.\n\nScaling WebSockets and Socket.IO is challenging because of their persistent nature. Each WebSocket connection is a long-lived TCP connection, which can become resource-intensive as the number of connections increases.\n• Sticky Sessions: Ensuring that all WebSocket connections from a client are routed to the same server.\n• Redis for Pub/Sub: Using Redis for event publishing and subscription across servers, ensuring all clients receive real-time updates.\n\nHere’s an example of configuring Socket.IO to use Redis:\n\n\n\nWebSockets and Socket.IO are essential technologies for real-time communication in modern web applications. While WebSockets provide a low-level protocol for full-duplex communication, Socket.IO simplifies the implementation, offering additional features like automatic reconnection and broadcasting. Both technologies have significant real-world applications, from chat applications to collaborative tools.\n\nIn the next article, we’ll dive into Node.js Streams and explore how they handle large data efficiently, focusing on scalability and performance."
    }
]