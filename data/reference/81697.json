[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Window/setInterval",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 . * Some parts of this feature may have varying levels of support.\n\nThe method of the interface repeatedly calls a function or executes a code snippet, with a fixed time delay between each call. This method returns an interval ID which uniquely identifies the interval, so you can remove it later by calling .\n\nA to be executed every milliseconds. The first execution happens after milliseconds. An optional syntax allows you to include a string instead of a function, which is compiled and executed every milliseconds. This syntax is not recommended for the same reasons that make using a security risk. The time, in milliseconds (thousandths of a second), the timer should delay in between executions of the specified function or code. Defaults to 0 if not specified. See Delay restrictions below for details on the permitted range of values. Additional arguments which are passed through to the function specified by func once the timer expires.\n\nThe returned is a numeric, non-zero value which identifies the timer created by the call to ; this value can be passed to to cancel the interval. It may be helpful to be aware that and share the same pool of IDs, and that and can technically be used interchangeably. For clarity, however, you should try to always match them to avoid confusion when maintaining your code. Note: The argument is converted to a signed 32-bit integer. This effectively limits to 2147483647 ms, roughly 24.8 days, since it's specified as a signed integer in the IDL.\n\nCode executed by runs in a separate execution context than the function from which it was called. As a consequence, the keyword for the called function is set to the (or ) object, it is not the same as the value for the function that called . See the following example (which uses instead of – the problem, in fact, is the same for both timers): myArray = [\"zero\", \"one\", \"two\"]; myArray.myMethod = function (sProperty) { alert(arguments.length > 0 ? this[sProperty] : this); }; myArray.myMethod(); // prints \"zero,one,two\" myArray.myMethod(1); // prints \"one\" setTimeout(myArray.myMethod, 1000); // prints \"[object Window]\" after 1 second setTimeout(myArray.myMethod, 1500, \"1\"); // prints \"undefined\" after 1.5 seconds // Passing the 'this' object with .call won't work // because this will change the value of this inside setTimeout itself // while we want to change the value of this inside myArray.myMethod. // In fact, it will be an error because setTimeout code expects this to be the window object: setTimeout.call(myArray, myArray.myMethod, 2000); // error: \"NS_ERROR_XPC_BAD_OP_ON_WN_PROTO: Illegal operation on WrappedNative prototype object\" setTimeout.call(myArray, myArray.myMethod, 2500, 2); // same error As you can see there are no ways to pass the object to the callback function in the legacy JavaScript.\n\nAll modern JavaScript runtimes (in browsers and elsewhere) support arrow functions, with lexical — allowing us to write if we're inside the method. If you need to support IE, use the method, which lets you specify the value that should be used as for all calls to a given function. That lets you easily bypass problems where it's unclear what will be, depending on the context from which your function was called.\n\nThe function is commonly used to set a delay for functions that are executed again and again, such as animations. You can cancel the interval using . If you wish to have your function called once after the specified delay, use .\n\nIt's possible for intervals to be nested; that is, the callback for can in turn call to start another interval running, even though the first one is still going. To mitigate the potential impact this can have on performance, once intervals are nested beyond five levels deep, the browser will automatically enforce a 4 ms minimum value for the interval. Attempts to specify a value less than 4 ms in deeply-nested calls to will be pinned to 4 ms. Browsers may enforce even more stringent minimum values for the interval under some circumstances, although these should not be common. Note also that the actual amount of time that elapses between calls to the callback may be longer than the given ; see Reasons for delays longer than specified for examples.\n\nEnsure that execution duration is shorter than interval frequency If there is a possibility that your logic could take longer to execute than the interval time, it is recommended that you recursively call a named function using . For example, if using to poll a remote server every 5 seconds, network latency, an unresponsive server, and a host of other issues could prevent the request from completing in its allotted time. As such, you may find yourself with queued up XHR requests that won't necessarily return in order. In these cases, a recursive pattern is preferred: In the above snippet, a named function is declared and is immediately executed. is recursively called inside after the logic has completed executing. While this pattern does not guarantee execution on a fixed interval, it does guarantee that the previous interval has completed before recursing."
    },
    {
        "link": "https://w3schools.com/jsref/met_win_setinterval.asp",
        "document": "Display \"Hello\" every second (1000 milliseconds):\n\nThe method calls a function at specified intervals (in milliseconds).\n\nThe method continues calling the function until is called, or the window is closed.\n\nTo execute the function only once, use the method instead.\n\nTo clear an interval, use the id returned from setInterval():\n\nThen you can to stop the execution by calling clearInterval():"
    },
    {
        "link": "https://stackoverflow.com/questions/457826/pass-parameters-in-setinterval-function",
        "document": "You can pass the parameter(s) as a property of the function object, not as a parameter:\n\nThen in your function , you will have access to the parameters. This is particularly useful inside classes where the scope goes to the global space automatically and you lose references to the class that called setInterval to begin with. With this approach, \"parameter2\" in \"someFunction\", in the example above, will have the right scope."
    },
    {
        "link": "https://codecademy.com/resources/docs/javascript/window/setInterval",
        "document": "The method is used to execute a function repeatedly at specified time intervals.\n\nThe function is used to execute a function repeatedly at a specified interval (delay).\n• The to be executed or, alternatively, a code snippet.\n• The in milliseconds between each execution. This parameter is optional and if not provided defaults to 0.\n• Optional additional arguments ( , … ), which are passed to the once the timer expires.\n\nAfter is executed, the argument is executed only after the given .\n\nIt returns a numeric, non-zero value as of the timer created by the call to . This value can be passed to to cancel the interval.\n\nFollowing code outputs “Hello” 3 times to given number each second"
    },
    {
        "link": "https://shecodes.io/athena/143127-how-does-setinterval-work-in-javascript",
        "document": "const toggleInfo = (index, event) => { setVisibleLightIndexes((prev) => { if (prev.includes(index)) { return prev.filter((i) => i !== index); } else { return [...prev, index]; } }); const clickedElement = event.target.closest(\".chauvetLights\"); if (clickedElement) { clickedElement.classList.toggle(\"expanded\"); } toggleBackgroundColor(event); }; TypeError: Cannot read properties of undefined (reading 'target') at k (home-OO3WpeNb.js:1:102576) at onClick (home-OO3WpeNb.js:1:104620) at Object.Em (index-h-qGlws7.js:38:9852) at km (index-h-qGlws7.js:38:10006) at Cm (index-h-qGlws7.js:38:10063) at Wa (index-h-qGlws7.js:38:31422) at fd (index-h-qGlws7.js:38:31839) at index-h-qGlws7.js:38:36751 at Vs (index-h-qGlws7.js:41:36768) at Df (index-h-qGlws7.js:38:8988)\n\nAdd a value attribute to both radio buttons. For convenience, set the button's value attribute to the same value as its id attribute."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Window/setInterval",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 . * Some parts of this feature may have varying levels of support.\n\nThe method of the interface repeatedly calls a function or executes a code snippet, with a fixed time delay between each call. This method returns an interval ID which uniquely identifies the interval, so you can remove it later by calling .\n\nA to be executed every milliseconds. The first execution happens after milliseconds. An optional syntax allows you to include a string instead of a function, which is compiled and executed every milliseconds. This syntax is not recommended for the same reasons that make using a security risk. The time, in milliseconds (thousandths of a second), the timer should delay in between executions of the specified function or code. Defaults to 0 if not specified. See Delay restrictions below for details on the permitted range of values. Additional arguments which are passed through to the function specified by func once the timer expires.\n\nThe returned is a numeric, non-zero value which identifies the timer created by the call to ; this value can be passed to to cancel the interval. It may be helpful to be aware that and share the same pool of IDs, and that and can technically be used interchangeably. For clarity, however, you should try to always match them to avoid confusion when maintaining your code. Note: The argument is converted to a signed 32-bit integer. This effectively limits to 2147483647 ms, roughly 24.8 days, since it's specified as a signed integer in the IDL.\n\nCode executed by runs in a separate execution context than the function from which it was called. As a consequence, the keyword for the called function is set to the (or ) object, it is not the same as the value for the function that called . See the following example (which uses instead of – the problem, in fact, is the same for both timers): myArray = [\"zero\", \"one\", \"two\"]; myArray.myMethod = function (sProperty) { alert(arguments.length > 0 ? this[sProperty] : this); }; myArray.myMethod(); // prints \"zero,one,two\" myArray.myMethod(1); // prints \"one\" setTimeout(myArray.myMethod, 1000); // prints \"[object Window]\" after 1 second setTimeout(myArray.myMethod, 1500, \"1\"); // prints \"undefined\" after 1.5 seconds // Passing the 'this' object with .call won't work // because this will change the value of this inside setTimeout itself // while we want to change the value of this inside myArray.myMethod. // In fact, it will be an error because setTimeout code expects this to be the window object: setTimeout.call(myArray, myArray.myMethod, 2000); // error: \"NS_ERROR_XPC_BAD_OP_ON_WN_PROTO: Illegal operation on WrappedNative prototype object\" setTimeout.call(myArray, myArray.myMethod, 2500, 2); // same error As you can see there are no ways to pass the object to the callback function in the legacy JavaScript.\n\nAll modern JavaScript runtimes (in browsers and elsewhere) support arrow functions, with lexical — allowing us to write if we're inside the method. If you need to support IE, use the method, which lets you specify the value that should be used as for all calls to a given function. That lets you easily bypass problems where it's unclear what will be, depending on the context from which your function was called.\n\nThe function is commonly used to set a delay for functions that are executed again and again, such as animations. You can cancel the interval using . If you wish to have your function called once after the specified delay, use .\n\nIt's possible for intervals to be nested; that is, the callback for can in turn call to start another interval running, even though the first one is still going. To mitigate the potential impact this can have on performance, once intervals are nested beyond five levels deep, the browser will automatically enforce a 4 ms minimum value for the interval. Attempts to specify a value less than 4 ms in deeply-nested calls to will be pinned to 4 ms. Browsers may enforce even more stringent minimum values for the interval under some circumstances, although these should not be common. Note also that the actual amount of time that elapses between calls to the callback may be longer than the given ; see Reasons for delays longer than specified for examples.\n\nEnsure that execution duration is shorter than interval frequency If there is a possibility that your logic could take longer to execute than the interval time, it is recommended that you recursively call a named function using . For example, if using to poll a remote server every 5 seconds, network latency, an unresponsive server, and a host of other issues could prevent the request from completing in its allotted time. As such, you may find yourself with queued up XHR requests that won't necessarily return in order. In these cases, a recursive pattern is preferred: In the above snippet, a named function is declared and is immediately executed. is recursively called inside after the logic has completed executing. While this pattern does not guarantee execution on a fixed interval, it does guarantee that the previous interval has completed before recursing."
    },
    {
        "link": "https://dev.to/akanksha_9560/why-not-to-use-setinterval--2na9",
        "document": "In order to understand why setInterval is evil we need to keep in mind a fact that javascript is essentially single threaded, meaning it will not perform more than one operation at a time.\n\nIn cases when functions takes longer than delay mentioned in (like ajax call, which might it prevent from completing on time), we will find that either functions have no breathing room or setInterval breaks it's rhythm.\n\n\n\nTry above code snippets in your console\n\nAs you can see from printed console.log statement that keeps on sending ajax calls relentlessly without caring previous call has returned or not.\n\n This can queue up a lot of requests at once on the server.\n\nNow, let's try a synchronous operation in :\n\n\n\nWe see here when encounters time intensive operation, it does either of two things, a) try to get on track or b) create new rhythm. Here on chrome it creates a new rhythm.\n\nIn case of asynchronous operations, will create long queue of requests which will be very counterproductive.\n\n In case of time intensive synchronous operations, may break the rhythm.\n\n Also, if any error occurs in setInterval code block, it will not stop execution but keeps on running faulty code. Not to mention they need a function to stop it.\n\n Alternatively, you can use recursively in case of time sensitive operations."
    },
    {
        "link": "https://reddit.com/r/javascript/comments/51srsf/is_it_still_true_that_we_shouldnt_use_setinterval",
        "document": "I remember for a while I used to write for loops like:\n\nBut for a while now JS engines don't need explicit instructions to not constantly reevaluate the array length in a for loop, thus making it an outdated optimization.\n\nAdditionally another tip I learned way back when (in early 2015), to never use setInterval but instead just recursively call setTimeout.\n\nIs this still true?\n\nAlso what other common best practices no longer apply anymore? I always read that Mozilla and Google constantly watch how JS is used and optimize towards making it run faster, for example + for string concatenation."
    },
    {
        "link": "https://stackoverflow.com/questions/70085665/javascript-best-practices-implementation-of-the-setinverval-function",
        "document": "I want to log some text to the console every n number of seconds. My code is:\n\nThis works fine. And, the following variation works fine, too:\n\nNow, I attempt to move inside the function, as follows:\n\nThis does not work.\n\nQuestion: Is there a way to move inside the function? And, if it is possible, is doing so recommended?\n\nThanks for helping out a JavaScript newbie!\n\nTaking the suggestion from @FZs, I implemented the function as follows:\n\nThe messages are stacking in the console because the Date is not incrementing. Is this a scope issue?"
    },
    {
        "link": "https://stackoverflow.com/questions/5515159/javascript-setinterval-how-to-set-a-good-timing-performance",
        "document": "I'm writing a simple jquery plugin that let me add classes to elements at a certain scroll position. To accomplish this, rather than binding onScroll events, I call a setInterval function that checks the current Y page offset:\n\nHow you can see, I set the interval at 25 ms. I was wondering if this is to be considered a right time, and how the performance are effectively involved."
    }
]