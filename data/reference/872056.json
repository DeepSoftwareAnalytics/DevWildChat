[
    {
        "link": "https://stackoverflow.com/questions/21385196/how-to-check-the-version-of-scipy",
        "document": "This will give you a list of all installed Python modules with version number.\n\n(Linux/Unix) Use to filter out all unnecessary information about other packages.\n\n(Windows) Use to filter out all unnecessary information about other packages."
    },
    {
        "link": "https://stackoverflow.com/questions/10214827/find-which-version-of-package-is-installed-with-pip",
        "document": "The python function returning just the package version in a machine-readable format:\n\nThe bash equivalent (here also invoked from python) would be much more complex (but more robust - see caution below):\n\nNote that in both cases parameter should contain package name in the format as returned by and not as used during , e.g. not or , not .\n\nNote that while invoking in bash version may seem inefficient, only this method proves to be sufficiently robust to package naming peculiarities and inconsistencies (e.g. underscores vs dashes, small vs large caps, and abbreviations such as vs ).\n\nCaution: in complex environments both variants can return surprise version numbers, inconsistent with what you can actually get during .\n\nOne such problem arises when there are other versions of the package hidden in a user subfolder. As an illustration of the perils of using here's a situation I encountered:\n\nAnother problem is having some conda-installed packages in the same environment. If they share dependencies with your pip-installed packages, and versions of these dependencies differ, you may get downgrades of your pip-installed dependencies.\n\nTo illustrate, the latest version of available in PyPI on 04-01-2020 was 1.18.0, while at the same time Anaconda's channel had only 1.17.3 version on as their latest. So when you installed a package with conda (as second), your previously pip-installed would get downgraded by conda to 1.17.3, and version 1.18.0 would become unavailable to the function. In this case would be right, and / wrong:"
    },
    {
        "link": "https://scipy.org/install",
        "document": "This page assumes that you are comfortable with using a terminal and happy to learn how to use a package manager. If you are a beginner and just want to get started with SciPy as quickly as possible, check out the beginner installation guide!\n\nThe recommended method of installing SciPy depends on your preferred workflow. The common workflows can roughly be broken down into the following categories:\n• Building from source (for debugging and development)\n\nTo install SciPy with static type stubs, see Installing with type stubs.\n\nSee next steps in the SciPy user guide.\n\nStatic type stubs are available via a separate package, , on PyPI and conda-forge. You can also install SciPy and as a single package, via the extra on PyPI, or the package on conda-forge. To get a specific version of SciPy (such as ), you should install version , for example:\n\nPlease direct questions about static typing support to the GitHub repository."
    },
    {
        "link": "https://geeksforgeeks.org/check-version-of-installed-python-modules",
        "document": "In Python, managing packages is an essential part of the development process. Knowing the version of the package that is currently installed can help us to ensure compatibility and debug issues effectively in our python code. In this article, we will explore methods to determine the version of packages installed in our current working python environment.\n\nThe pip show command provides detailed information about specific package, including its version. To use this method, we need to follow these steps:\n• None Open terminal or command prompt and type the following command\n\nMany python packages store their version number in '__version__' attribute. We can access this attribute to find the version of the installed package. Steps to follow this method are\n• None Open python interpreter or script (in command prompy by typing command python)\n• None Next is to import the package and using __version__ attribute we can print the version of imported packkage as follows\n\nUsing this method we can get the versions of all the packages installed in current python working environment. Steps to achieve this method are\n• None Type the following command and hit enter\n\nKnowing how to check the version of instaled packages in python is crucial for maintainig a stable development environment. The methods discussed above provide ways to accomplish this, whether we prefer using command -line tools or python. Choose the method taht best fits our workflow and ensure our projects run smoothly by keeping track of installed package versions.\n\n1. How can I check the version of a specific python package?\n\n2. What command lists all the installed python packages an thier versions?\n\n3. Is there a way to check a package version directly in a python script?\n\n4. How can I check the version of a package using 'importlib'?\n\n5. What command should I use If I am working in conda environment?"
    },
    {
        "link": "https://reddit.com/r/vscode/comments/1bgdi6z/python_scipy_on_vscode",
        "document": "Hey, I am new to learning python. I'm trying to make a program that requires using Scipy for my CS class in school. How exactly do I download Scipy on Vscode with python. Thank you."
    },
    {
        "link": "https://docs.scipy.org/doc/scipy/reference",
        "document": "In Python, the distinction between what is the public API of a library and what are private implementation details is not always clear. Unlike in other languages like Java, it is possible in Python to access “private” functions or objects. Occasionally this may be convenient, but be aware that if you do so your code may break without warning in future releases. Some widely understood rules for what is and isn’t public in Python are:\n• None Methods / functions / classes and module attributes whose names begin with a leading underscore are private.\n• None If a class name begins with a leading underscore, none of its members are public, whether or not they begin with a leading underscore.\n• None If a module name in a package begins with a leading underscore none of its members are public, whether or not they begin with a leading underscore.\n• None If a module or package defines , that authoritatively defines the public interface.\n• None If a module or package doesn’t define , then all names that don’t start with a leading underscore are public. Reading the above guidelines one could draw the conclusion that every private module or object starts with an underscore. This is not the case; the presence of underscores do mark something as private, but the absence of underscores do not mark something as public. In SciPy there are modules whose names don’t start with an underscore, but that should be considered private. To clarify which modules these are, we define below what the public API is for SciPy, and give some recommendations for how to import modules/functions/objects from SciPy.\n\nEverything in the namespaces of SciPy submodules is public. In general in Python, it is recommended to make use of namespaces. For example, the function (defined in ) should be imported like this: Or alternatively one could use the submodule as a namespace like so: For prefer the use of because is also the name of a module in the Python stdlib. In some cases, the public API is one level deeper. For example, the module is public, and the functions it contains are not available in the namespace. Sometimes it may result in more easily understandable code if functions are imported from one level deeper. For example, in the following it is immediately clear that is a distribution if the second form is chosen: In that case, the second form can be chosen if it is documented in the next section that the submodule in question is public. Of course you can still use: SciPy is using a lazy loading mechanism which means that modules are only loaded in memory when you first try to access them.\n\nEvery submodule listed below is public. That means that these submodules are unlikely to be renamed or changed in an incompatible way, and if that is necessary, a deprecation warning will be raised for one SciPy release before the change is made."
    },
    {
        "link": "https://stackoverflow.com/questions/72167802/adding-version-attribute-to-python-module",
        "document": "I have no idea why other answers say that your approach is not recommended, on the contrary, it is the officially recommended one (as of 2023). Core Python developers use this approach. What you need to make sure is to define the string statically, not dynamically (ie, do not fetch at runtime from a text file, it must be hardcoded in a Python string in a Python file, to be statically available at build time).\n\nSince setuptools v61, you can indeed set a attribute in your package's file as you did, and then dynamically fetch it into your like so:\n\nNote however that if you also want to access from inside , you should NOT because if you also import things in your , this will cause an infinite import loop! Instead, you need to implement a function to read (not import!) and extract the version string, fortunately the official documentation nowadays provides an easy example:\n\nIf you only want to support Py3, then you are all set, you can stop reading here.\n\nBut if you need to use an older version of setuptools, eg if you need to support Python 2.7 (which is very disadvised but some legacy projects may need it), then you can instead use , which supports dynamic version since an earlier version of setuptools:\n\nNote that you still need to have an almost empty for the to work, otherwise setuptools will choke (it's an official rule):\n\nBut then, if you also want your module to have both a setup.cfg and setup.py to support Py2 and also have a pyproject.toml to support Py3, you will notice that building may fail under Py2 because of requiring a setuptools version too high (the latest on Py2 being v41.1.1). Indeed, even if on Py2 building is done through setup.cfg and setup.py, if you updated pip, then it will STILL access pyproject.toml and access the table, because this is the only place where a module can specify build-time requirements, according to PEP 517.\n\nTo fix this issue, you need to edit the build requirement in to specify the python version (see PEP 508 about dependencies specifications):\n\nThen your package should build fine (with the module or ) under both Py3 and Py2, using only the pyproject.toml for the former, or setup.cfg for the latter (with a bit of pyproject.toml just for the build-system)."
    },
    {
        "link": "https://stackoverflow.com/questions/3524168/how-do-i-get-a-python-modules-version-number-through-code",
        "document": "Use pkg_resources (part of ). Anything installed from PyPI at least has a version number. No extra package/module is needed.\n\nimportlib.metadata can be used as a replacement for . No extra package/module is needed."
    },
    {
        "link": "https://docs.scipy.org/doc/scipy",
        "document": "Want to build from source rather than use a Python distribution or pre-built SciPy binary? This guide will describe how to set up your build environment, and how to build SciPy itself, including the many options for customizing that build."
    },
    {
        "link": "https://w3schools.com/python/scipy/scipy_getting_started.php",
        "document": "If you have Python and PIP already installed on a system, then installation of SciPy is very easy.\n\nInstall it using this command:\n\nIf this command fails, then use a Python distribution that already has SciPy installed like, Anaconda, Spyder etc.\n\nOnce SciPy is installed, import the SciPy module(s) you want to use in your applications by adding the statement:\n\nNow we have imported the constants module from SciPy, and the application is ready to use it:\n\nThe version string is stored under the attribute."
    }
]