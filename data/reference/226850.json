[
    {
        "link": "https://geeksforgeeks.org/python-3-input-function",
        "document": "In Python, we use the input() function to take input from the user. Whatever you enter as input, the input function converts it into a string. If you enter an integer value still input() function converts it into a string.\n\nIn this example, we are using input() function to input user data as a string in Python.\n\nIn this example, we are using the Python input() function to input user data as a string in Python, which takes input from the user and prints it.\n\nIn this example, we are taking input from the user and input user data as a string in Python with a prompt and printing it.\n\nIn this example, we are using the Python input() function which takes input from the user in string format converting it into an integer adding 1 to the integer, and printing it.\n\nIn this example, we are using the Python input() function which takes input from the user in string format converts it into float adds 1 to the float, and prints it.\n\nIn this example, we are taking input from the user in string format converting it into a list, and printing it.\n\nTake User Input for Tuples and Sets\n\nIn this example, we are taking input from the user in string format converting it into a tuple, and printing it.\n\nIn this example, we are taking the words separated by space to input user data as a string in Python, and we make a dictionary of the word as the key with their length as the value."
    },
    {
        "link": "https://w3schools.com/python/ref_func_input.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://docs.python.org/3/tutorial/inputoutput.html",
        "document": "There are several ways to present the output of a program; data can be printed in a human-readable form, or written to a file for future use. This chapter will discuss some of the possibilities.\n\nSo far we’ve encountered two ways of writing values: expression statements and the function. (A third way is using the method of file objects; the standard output file can be referenced as . See the Library Reference for more information on this.) Often you’ll want more control over the formatting of your output than simply printing space-separated values. There are several ways to format output.\n• None To use formatted string literals, begin a string with or before the opening quotation mark or triple quotation mark. Inside this string, you can write a Python expression between and characters that can refer to variables or literal values.\n• None The method of strings requires more manual effort. You’ll still use and to mark where a variable will be substituted and can provide detailed formatting directives, but you’ll also need to provide the information to be formatted. In the following code block there are two examples of how to format variables: Notice how the are padded with spaces and a negative sign only for negative numbers. The example also prints multiplied by 100, with 2 decimal places and followed by a percent sign (see Format Specification Mini-Language for details).\n• None Finally, you can do all the string handling yourself by using string slicing and concatenation operations to create any layout you can imagine. The string type has some methods that perform useful operations for padding strings to a given column width. When you don’t need fancy output but just want a quick display of some variables for debugging purposes, you can convert any value to a string with the or functions. The function is meant to return representations of values which are fairly human-readable, while is meant to generate representations which can be read by the interpreter (or will force a if there is no equivalent syntax). For objects which don’t have a particular representation for human consumption, will return the same value as . Many values, such as numbers or structures like lists and dictionaries, have the same representation using either function. Strings, in particular, have two distinct representations. The value of x is 32.5, and y is 40000... # The repr() of a string adds string quotes and backslashes: # The argument to repr() may be any Python object: The module contains a class that offers yet another way to substitute values into strings, using placeholders like and replacing them with values from a dictionary, but offers much less control of the formatting. Formatted string literals (also called f-strings for short) let you include the value of Python expressions inside a string by prefixing the string with or and writing expressions as . An optional format specifier can follow the expression. This allows greater control over how the value is formatted. The following example rounds pi to three places after the decimal: 'The value of pi is approximately The value of pi is approximately 3.142. Passing an integer after the will cause that field to be a minimum number of characters wide. This is useful for making columns line up. Other modifiers can be used to convert the value before it is formatted. applies , applies , and applies : 'My hovercraft is full of My hovercraft is full of eels. 'My hovercraft is full of My hovercraft is full of 'eels'. The specifier can be used to expand an expression to the text of the expression, an equal sign, then the representation of the evaluated expression: See self-documenting expressions for more information on the specifier. For a reference on these format specifications, see the reference guide for the Format Specification Mini-Language. Basic usage of the method looks like this: We are the knights who say \"Ni!\" The brackets and characters within them (called format fields) are replaced with the objects passed into the method. A number in the brackets can be used to refer to the position of the object passed into the method. If keyword arguments are used in the method, their values are referred to by using the name of the argument. Positional and keyword arguments can be arbitrarily combined: The story of Bill, Manfred, and Georg. If you have a really long format string that you don’t want to split up, it would be nice if you could reference the variables to be formatted by name instead of by position. This can be done by simply passing the dict and using square brackets to access the keys. This could also be done by passing the dictionary as keyword arguments with the notation. This is particularly useful in combination with the built-in function , which returns a dictionary containing all local variables: __name__: __main__; __doc__: None; __package__: None; __loader__: ... As an example, the following lines produce a tidily aligned set of columns giving integers and their squares and cubes: For a complete overview of string formatting with , see Format String Syntax. Here’s the same table of squares and cubes, formatted manually: # Note use of 'end' on previous line The method of string objects right-justifies a string in a field of a given width by padding it with spaces on the left. There are similar methods and . These methods do not write anything, they just return a new string. If the input string is too long, they don’t truncate it, but return it unchanged; this will mess up your column lay-out but that’s usually better than the alternative, which would be lying about a value. (If you really want truncation you can always add a slice operation, as in .) There is another method, , which pads a numeric string on the left with zeros. It understands about plus and minus signs: The % operator (modulo) can also be used for string formatting. Given (where format is a string), conversion specifications in format are replaced with zero or more elements of values. This operation is commonly known as string interpolation. For example: 'The value of pi is approximately The value of pi is approximately 3.142. More information can be found in the printf-style String Formatting section.\n\nreturns a file object, and is most commonly used with two positional arguments and one keyword argument: The first argument is a string containing the filename. The second argument is another string containing a few characters describing the way in which the file will be used. mode can be when the file will only be read, for only writing (an existing file with the same name will be erased), and opens the file for appending; any data written to the file is automatically added to the end. opens the file for both reading and writing. The mode argument is optional; will be assumed if it’s omitted. Normally, files are opened in text mode, that means, you read and write strings from and to the file, which are encoded in a specific encoding. If encoding is not specified, the default is platform dependent (see ). Because UTF-8 is the modern de-facto standard, is recommended unless you know that you need to use a different encoding. Appending a to the mode opens the file in binary mode. Binary mode data is read and written as objects. You can not specify encoding when opening file in binary mode. In text mode, the default when reading is to convert platform-specific line endings ( on Unix, on Windows) to just . When writing in text mode, the default is to convert occurrences of back to platform-specific line endings. This behind-the-scenes modification to file data is fine for text files, but will corrupt binary data like that in or files. Be very careful to use binary mode when reading and writing such files. It is good practice to use the keyword when dealing with file objects. The advantage is that the file is properly closed after its suite finishes, even if an exception is raised at some point. Using is also much shorter than writing equivalent - blocks: # We can check that the file has been automatically closed. If you’re not using the keyword, then you should call to close the file and immediately free up any system resources used by it. Calling without using the keyword or calling might result in the arguments of not being completely written to the disk, even if the program exits successfully. After a file object is closed, either by a statement or by calling , attempts to use the file object will automatically fail. The rest of the examples in this section will assume that a file object called has already been created. To read a file’s contents, call , which reads some quantity of data and returns it as a string (in text mode) or bytes object (in binary mode). size is an optional numeric argument. When size is omitted or negative, the entire contents of the file will be read and returned; it’s your problem if the file is twice as large as your machine’s memory. Otherwise, at most size characters (in text mode) or size bytes (in binary mode) are read and returned. If the end of the file has been reached, will return an empty string ( ). 'This is the entire file.\n\n' reads a single line from the file; a newline character ( ) is left at the end of the string, and is only omitted on the last line of the file if the file doesn’t end in a newline. This makes the return value unambiguous; if returns an empty string, the end of the file has been reached, while a blank line is represented by , a string containing only a single newline. 'This is the first line of the file.\n\n' 'Second line of the file\n\n' For reading lines from a file, you can loop over the file object. This is memory efficient, fast, and leads to simple code: This is the first line of the file. If you want to read all the lines of a file in a list you can also use or . writes the contents of string to the file, returning the number of characters written. Other types of objects need to be converted – either to a string (in text mode) or a bytes object (in binary mode) – before writing them: returns an integer giving the file object’s current position in the file represented as number of bytes from the beginning of the file when in binary mode and an opaque number when in text mode. To change the file object’s position, use . The position is computed from adding offset to a reference point; the reference point is selected by the whence argument. A whence value of 0 measures from the beginning of the file, 1 uses the current file position, and 2 uses the end of the file as the reference point. whence can be omitted and defaults to 0, using the beginning of the file as the reference point. # Go to the 6th byte in the file # Go to the 3rd byte before the end In text files (those opened without a in the mode string), only seeks relative to the beginning of the file are allowed (the exception being seeking to the very file end with ) and the only valid offset values are those returned from the , or zero. Any other offset value produces undefined behaviour. File objects have some additional methods, such as and which are less frequently used; consult the Library Reference for a complete guide to file objects. Strings can easily be written to and read from a file. Numbers take a bit more effort, since the method only returns strings, which will have to be passed to a function like , which takes a string like and returns its numeric value 123. When you want to save more complex data types like nested lists and dictionaries, parsing and serializing by hand becomes complicated. Rather than having users constantly writing and debugging code to save complicated data types to files, Python allows you to use the popular data interchange format called JSON (JavaScript Object Notation). The standard module called can take Python data hierarchies, and convert them to string representations; this process is called serializing. Reconstructing the data from the string representation is called deserializing. Between serializing and deserializing, the string representing the object may have been stored in a file or data, or sent over a network connection to some distant machine. The JSON format is commonly used by modern applications to allow for data exchange. Many programmers are already familiar with it, which makes it a good choice for interoperability. If you have an object , you can view its JSON string representation with a simple line of code: Another variant of the function, called , simply serializes the object to a text file. So if is a text file object opened for writing, we can do this: To decode the object again, if is a binary file or text file object which has been opened for reading: JSON files must be encoded in UTF-8. Use when opening JSON file as a text file for both of reading and writing. This simple serialization technique can handle lists and dictionaries, but serializing arbitrary class instances in JSON requires a bit of extra effort. The reference for the module contains an explanation of this. Contrary to JSON, pickle is a protocol which allows the serialization of arbitrarily complex Python objects. As such, it is specific to Python and cannot be used to communicate with applications written in other languages. It is also insecure by default: deserializing pickle data coming from an untrusted source can execute arbitrary code, if the data was crafted by a skilled attacker."
    },
    {
        "link": "https://geeksforgeeks.org/python-input-function",
        "document": "Python input() function is used to take user input. By default, it returns the user input in form of a string.\n\nRefer to all datatypes and examples from here.\n\nExample 1: Taking Name and Age of the user as input and printing it\n\nBy default, input returns a string. So the name and age will be stored as strings.\n\nExample 2: Taking two integers from users and adding them.\n\nIn this example, we will be looking at how to take integer input from users. To take integer input we will be using int() along with Python input()\n\nSimilarly, we can use float() to take two float numbers. Let’s see one more example of how to take lists as input\n\nExample 3: Taking Two lists as input and appending them\n\nTaking user input as a string and splitting on each character using list() to convert into list of characters.\n\nHow to use the\n\nCan we provide a basic example of using the\n\nHow to store the value entered by the user using the\n\nHow does the\n\nHow can we convert the input received from the\n\nYou can use the function to convert the input to an integer. Here’s an example: If you need to convert to other data types, you can use for floating-point numbers, for boolean values, etc."
    },
    {
        "link": "https://w3schools.com/python/python_user_input.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://docs.python.org/3/tutorial/floatingpoint.html",
        "document": "Floating-point numbers are represented in computer hardware as base 2 (binary) fractions. For example, the decimal fraction has value 6/10 + 2/100 + 5/1000, and in the same way the binary fraction has value 1/2 + 0/4 + 1/8. These two fractions have identical values, the only real difference being that the first is written in base 10 fractional notation, and the second in base 2.\n\nUnfortunately, most decimal fractions cannot be represented exactly as binary fractions. A consequence is that, in general, the decimal floating-point numbers you enter are only approximated by the binary floating-point numbers actually stored in the machine.\n\nThe problem is easier to understand at first in base 10. Consider the fraction 1/3. You can approximate that as a base 10 fraction:\n\nand so on. No matter how many digits you’re willing to write down, the result will never be exactly 1/3, but will be an increasingly better approximation of 1/3.\n\nIn the same way, no matter how many base 2 digits you’re willing to use, the decimal value 0.1 cannot be represented exactly as a base 2 fraction. In base 2, 1/10 is the infinitely repeating fraction\n\nStop at any finite number of bits, and you get an approximation. On most machines today, floats are approximated using a binary fraction with the numerator using the first 53 bits starting with the most significant bit and with the denominator as a power of two. In the case of 1/10, the binary fraction is which is close to but not exactly equal to the true value of 1/10.\n\nMany users are not aware of the approximation because of the way values are displayed. Python only prints a decimal approximation to the true decimal value of the binary approximation stored by the machine. On most machines, if Python were to print the true decimal value of the binary approximation stored for 0.1, it would have to display:\n\nThat is more digits than most people find useful, so Python keeps the number of digits manageable by displaying a rounded value instead:\n\nJust remember, even though the printed result looks like the exact value of 1/10, the actual stored value is the nearest representable binary fraction.\n\nInterestingly, there are many different decimal numbers that share the same nearest approximate binary fraction. For example, the numbers and and are all approximated by . Since all of these decimal values share the same approximation, any one of them could be displayed while still preserving the invariant .\n\nHistorically, the Python prompt and built-in function would choose the one with 17 significant digits, . Starting with Python 3.1, Python (on most systems) is now able to choose the shortest of these and simply display .\n\nNote that this is in the very nature of binary floating point: this is not a bug in Python, and it is not a bug in your code either. You’ll see the same kind of thing in all languages that support your hardware’s floating-point arithmetic (although some languages may not display the difference by default, or in all output modes).\n\nFor more pleasant output, you may wish to use string formatting to produce a limited number of significant digits:\n\nIt’s important to realize that this is, in a real sense, an illusion: you’re simply rounding the display of the true machine value.\n\nOne illusion may beget another. For example, since 0.1 is not exactly 1/10, summing three values of 0.1 may not yield exactly 0.3, either:\n\nAlso, since the 0.1 cannot get any closer to the exact value of 1/10 and 0.3 cannot get any closer to the exact value of 3/10, then pre-rounding with function cannot help:\n\nThough the numbers cannot be made closer to their intended exact values, the function can be useful for comparing inexact values:\n\nAlternatively, the function can be used to compare rough approximations:\n\nBinary floating-point arithmetic holds many surprises like this. The problem with “0.1” is explained in precise detail below, in the “Representation Error” section. See Examples of Floating Point Problems for a pleasant summary of how binary floating point works and the kinds of problems commonly encountered in practice. Also see The Perils of Floating Point for a more complete account of other common surprises.\n\nAs that says near the end, “there are no easy answers.” Still, don’t be unduly wary of floating point! The errors in Python float operations are inherited from the floating-point hardware, and on most machines are on the order of no more than 1 part in 2**53 per operation. That’s more than adequate for most tasks, but you do need to keep in mind that it’s not decimal arithmetic and that every float operation can suffer a new rounding error.\n\nWhile pathological cases do exist, for most casual use of floating-point arithmetic you’ll see the result you expect in the end if you simply round the display of your final results to the number of decimal digits you expect. usually suffices, and for finer control see the method’s format specifiers in Format String Syntax.\n\nFor use cases which require exact decimal representation, try using the module which implements decimal arithmetic suitable for accounting applications and high-precision applications.\n\nAnother form of exact arithmetic is supported by the module which implements arithmetic based on rational numbers (so the numbers like 1/3 can be represented exactly).\n\nIf you are a heavy user of floating-point operations you should take a look at the NumPy package and many other packages for mathematical and statistical operations supplied by the SciPy project. See <https://scipy.org>.\n\nPython provides tools that may help on those rare occasions when you really do want to know the exact value of a float. The method expresses the value of a float as a fraction:\n\nSince the ratio is exact, it can be used to losslessly recreate the original value:\n\nThe method expresses a float in hexadecimal (base 16), again giving the exact value stored by your computer:\n\nThis precise hexadecimal representation can be used to reconstruct the float value exactly:\n\nSince the representation is exact, it is useful for reliably porting values across different versions of Python (platform independence) and exchanging data with other languages that support the same format (such as Java and C99).\n\nAnother helpful tool is the function which helps mitigate loss-of-precision during summation. It uses extended precision for intermediate rounding steps as values are added onto a running total. That can make a difference in overall accuracy so that the errors do not accumulate to the point where they affect the final total:\n\nThe goes further and tracks all of the “lost digits” as values are added onto a running total so that the result has only a single rounding. This is slower than but will be more accurate in uncommon cases where large magnitude inputs mostly cancel each other out leaving a final sum near zero:\n\nThis section explains the “0.1” example in detail, and shows how you can perform an exact analysis of cases like this yourself. Basic familiarity with binary floating-point representation is assumed. Representation error refers to the fact that some (most, actually) decimal fractions cannot be represented exactly as binary (base 2) fractions. This is the chief reason why Python (or Perl, C, C++, Java, Fortran, and many others) often won’t display the exact decimal number you expect. Why is that? 1/10 is not exactly representable as a binary fraction. Since at least 2000, almost all machines use IEEE 754 binary floating-point arithmetic, and almost all platforms map Python floats to IEEE 754 binary64 “double precision” values. IEEE 754 binary64 values contain 53 bits of precision, so on input the computer strives to convert 0.1 to the closest fraction it can of the form J/2**N where J is an integer containing exactly 53 bits. Rewriting and recalling that J has exactly 53 bits (is but ), the best value for N is 56: That is, 56 is the only value for N that leaves J with exactly 53 bits. The best possible value for J is then that quotient rounded: Since the remainder is more than half of 10, the best approximation is obtained by rounding up: Therefore the best possible approximation to 1/10 in IEEE 754 double precision is: Dividing both the numerator and denominator by two reduces the fraction to: Note that since we rounded up, this is actually a little bit larger than 1/10; if we had not rounded up, the quotient would have been a little bit smaller than 1/10. But in no case can it be exactly 1/10! So the computer never “sees” 1/10: what it sees is the exact fraction given above, the best IEEE 754 double approximation it can get: If we multiply that fraction by 10**55, we can see the value out to 55 decimal digits: meaning that the exact number stored in the computer is equal to the decimal value 0.1000000000000000055511151231257827021181583404541015625. Instead of displaying the full decimal value, many languages (including older versions of Python), round the result to 17 significant digits: The and modules make these calculations easy:"
    },
    {
        "link": "https://stackoverflow.com/questions/55517241/how-to-correctly-deal-with-floating-point-arithmetic-in-python",
        "document": "How to correctly add or subtract using floats? For example how to perform:\n\nso that it returns instead of .\n\nConverting to int first yields unexpected results, the below returns :\n\nHow to perform subtraction and addition of numbers with 8 decimal point precision?\n\nis not sufficient as the number is used as a lookup in a dictionary, and the key is . This means that any value other than results in an incorrect lookup."
    },
    {
        "link": "https://stackoverflow.com/questions/55660432/best-practices-on-floating-point-precision-in-python",
        "document": "Your question is a specialization of \"Is a point inside a regular polygon?\" by regular I mean not self intersecting or multi polygons as we can often found in GIS system. And by extension because your are asking for triangle, I'll assume the polygon is convex.\n\nWhat is interesting, is that cross product is the key to solve it. When you are dealing with vectors in 2D plane, cross products are orthogonal to this plane. The useful information to extract is: does it point upward or downward?\n\nFloat Arithmetic errors will happen, and it becomes critical when the cross product is close to zero, but not equal to, then it will have a sign instead of being null.\n\nTo check if your point is inside the polygon, it merely boils down to check if all cross products between edge and the point have the same signs, eg.: .\n\nIn the same way, to check if the polygon is convex is about to check that all cross products of consecutive edges have the same signs, eg.: .\n\nLet's build a small class to check if a point is inside (on the edge or outside) of a regular convex polygon:\n\nThe class is initialized with a list of 2D points (by default it is yours).\n\nOn my setup, float precision is about:\n\nIf we adapt your function to have compliant output:\n\nThen we check trial points to see if both our functions behave well:\n\nWith this setup, all points are correctly classified. But you can see that your algorithm is flawed. Mainly the following line:\n\nPoints close to an edge and Float Arithmetic Error\n\nEven for point exactly on the edge like floating point error leads to point misclassification. The following point would make the cross product not exactly equal to zero as it should. See details bellow:\n\nThis is why we must add a ball of radius to check if is actually zero for the given tolerance:\n\nIt means we must accept that points close enough to the edge (from both side) are considered to be contained into the polygon. This is inherent from Float Arithmetic, the best you can do is to tune to an acceptable value for your application. Or you can find out another logic or data model which does not suffer this problem.\n\nIf we zoom to precision scale to see what happens close to the edge, we got:\n\nWe see that some points very close to the edge, but inside or outside of the polygon, are classified as \"on the edge\". This is because of the epsilon ball criterion. You can also observe that points are not equally spaced (no matter if I used ) because of it is impossible to express as an integral power of .\n\nThe solution above is a generalization of your problem, performing in . It might seems to be overkill but it is general (it works for any regular polygon) and comprehensive (it relies on a well known geometric concept).\n\nActually, the algorithm simply check if the point stays at the same side of all edges of the polygon when walking through the path. If it does, then it concludes the point is inside the polygon, that is!\n\nThe above solution is off course affected by float arithmetic error because it relies on float computation (see point ). Fortunately, using epsilon ball test, we can mitigate it.\n\nIf you want to deeper understand finite precision arithmetic, I would advise you to read the excellent book: Accuracy and Stability of Numerical Algorithms, J. Higham.\n\nBellow a comparison of all answers with the trial dataset:\n\nWe can give some context on the different kind of \"errors\" underlined by this soft check:\n• Points and are misclassified by because of the design flaw;\n• use straight float equality in its logic, this is why it returns different results for equivalent class of points (eg.: points to , polygon points);\n• uses the simplest logic with an epsilon ball test. It seems to have a biggest error rate because it does not discriminate between inside and on the border (we can ignore all points where exact answer is and its function returned ). IMO, this it is the best algorithm presented which runs in . Additionally it can easily be updated to take into account the 3 states logic;\n• Point was deliberately designed to challenge logic at the border, the point is clearly outside the polygon from distance with a magnitude about the machine precision. This is where float arithmetic error becomes significant and the logic is more fuzzy: how far from the edge is acceptable and tractable?"
    },
    {
        "link": "https://docs.python.org/3/library/decimal.html",
        "document": "The module provides support for fast correctly rounded decimal floating-point arithmetic. It offers several advantages over the datatype:\n• None Decimal “is based on a floating-point model which was designed with people in mind, and necessarily has a paramount guiding principle – computers must provide an arithmetic that works in the same way as the arithmetic that people learn at school.” – excerpt from the decimal arithmetic specification.\n• None Decimal numbers can be represented exactly. In contrast, numbers like and do not have exact representations in binary floating point. End users typically would not expect to display as as it does with binary floating point.\n• None The exactness carries over into arithmetic. In decimal floating point, is exactly equal to zero. In binary floating point, the result is . While near to zero, the differences prevent reliable equality testing and differences can accumulate. For this reason, decimal is preferred in accounting applications which have strict equality invariants.\n• None The decimal module incorporates a notion of significant places so that is . The trailing zero is kept to indicate significance. This is the customary presentation for monetary applications. For multiplication, the “schoolbook” approach uses all the figures in the multiplicands. For instance, gives while gives .\n• None Unlike hardware based binary floating point, the decimal module has a user alterable precision (defaulting to 28 places) which can be as large as needed for a given problem:\n• None Both binary and decimal floating point are implemented in terms of published standards. While the built-in float type exposes only a modest portion of its capabilities, the decimal module exposes all required parts of the standard. When needed, the programmer has full control over rounding and signal handling. This includes an option to enforce exact arithmetic by using exceptions to block any inexact operations.\n• None The decimal module was designed to support “without prejudice, both exact unrounded decimal arithmetic (sometimes called fixed-point arithmetic) and rounded floating-point arithmetic.” – excerpt from the decimal arithmetic specification.\n\nThe module design is centered around three concepts: the decimal number, the context for arithmetic, and signals.\n\nA decimal number is immutable. It has a sign, coefficient digits, and an exponent. To preserve significance, the coefficient digits do not truncate trailing zeros. Decimals also include special values such as , , and . The standard also differentiates from .\n\nThe context for arithmetic is an environment specifying precision, rounding rules, limits on exponents, flags indicating the results of operations, and trap enablers which determine whether signals are treated as exceptions. Rounding options include , , , , , , , and .\n\nSignals are groups of exceptional conditions arising during the course of computation. Depending on the needs of the application, signals may be ignored, considered as informational, or treated as exceptions. The signals in the decimal module are: , , , , , , , and .\n\nFor each signal there is a flag and a trap enabler. When a signal is encountered, its flag is set to one, then, if the trap enabler is set to one, an exception is raised. Flags are sticky, so the user needs to reset them before monitoring a calculation.\n\nThe usual start to using decimals is importing the module, viewing the current context with and, if necessary, setting new values for precision, rounding, or enabled traps: Decimal instances can be constructed from integers, strings, floats, or tuples. Construction from an integer or a float performs an exact conversion of the value of that integer or float. Decimal numbers include special values such as which stands for “Not a number”, positive and negative , and : If the signal is trapped, accidental mixing of decimals and floats in constructors or ordering comparisons raises an exception: The significance of a new Decimal is determined solely by the number of digits input. Context precision and rounding only come into play during arithmetic operations. If the internal limits of the C version are exceeded, constructing a decimal raises : Decimals interact well with much of the rest of Python. Here is a small decimal floating-point flying circus: And some mathematical functions are also available to Decimal: The method rounds a number to a fixed exponent. This method is useful for monetary applications that often round results to a fixed number of places: As shown above, the function accesses the current context and allows the settings to be changed. This approach meets the needs of most applications. For more advanced work, it may be useful to create alternate contexts using the Context() constructor. To make an alternate active, use the function. In accordance with the standard, the module provides two ready to use standard contexts, and . The former is especially useful for debugging because many of the traps are enabled: Contexts also have signal flags for monitoring exceptional conditions encountered during computations. The flags remain set until explicitly cleared, so it is best to clear the flags before each set of monitored computations by using the method. The flags entry shows that the rational approximation to pi was rounded (digits beyond the context precision were thrown away) and that the result is inexact (some of the discarded digits were non-zero). Individual traps are set using the dictionary in the attribute of a context: Most programs adjust the current context only once, at the beginning of the program. And, in many applications, data is converted to with a single cast inside a loop. With context set and decimals created, the bulk of the program manipulates the data no differently than with other Python numeric types.\n\nConstruct a new object based from value. value can be an integer, string, tuple, , or another object. If no value is given, returns . If value is a string, it should conform to the decimal numeric string syntax after leading and trailing whitespace characters, as well as underscores throughout, are removed: Other Unicode decimal digits are also permitted where appears above. These include decimal digits from various other alphabets (for example, Arabic-Indic and Devanāgarī digits) along with the fullwidth digits through . If value is a , it should have three components, a sign ( for positive or for negative), a of digits, and an integer exponent. For example, returns . If value is a , the binary floating-point value is losslessly converted to its exact decimal equivalent. This conversion can often require 53 or more digits of precision. For example, converts to . The context precision does not affect how many digits are stored. That is determined exclusively by the number of digits in value. For example, records all five zeros even if the context precision is only three. The purpose of the context argument is determining what to do if value is a malformed string. If the context traps , an exception is raised; otherwise, the constructor returns a new Decimal with the value of . Changed in version 3.2: The argument to the constructor is now permitted to be a instance. Changed in version 3.3: arguments raise an exception if the trap is set. By default the trap is off. Changed in version 3.6: Underscores are allowed for grouping, as with integral and floating-point literals in code. Decimal floating-point objects share many properties with the other built-in numeric types such as and . All of the usual math operations and special methods apply. Likewise, decimal objects can be copied, pickled, printed, used as dictionary keys, used as set elements, compared, sorted, and coerced to another type (such as or ). There are some small differences between arithmetic on Decimal objects and arithmetic on integers and floats. When the remainder operator is applied to Decimal objects, the sign of the result is the sign of the dividend rather than the sign of the divisor: The integer division operator behaves analogously, returning the integer part of the true quotient (truncating towards zero) rather than its floor, so as to preserve the usual identity : The and operators implement the and operations (respectively) as described in the specification. Decimal objects cannot generally be combined with floats or instances of in arithmetic operations: an attempt to add a to a , for example, will raise a . However, it is possible to use Python’s comparison operators to compare a instance with another number . This avoids confusing results when doing equality comparisons between numbers of different types. Changed in version 3.2: Mixed-type comparisons between instances and other numeric types are now fully supported. In addition to the standard numeric properties, decimal floating-point objects also have a number of specialized methods: Return the adjusted exponent after shifting out the coefficient’s rightmost digits until only the lead digit remains: returns seven. Used for determining the position of the most significant digit with respect to the decimal point. Return a pair of integers that represent the given instance as a fraction, in lowest terms and with a positive denominator: The conversion is exact. Raise OverflowError on infinities and ValueError on NaNs. Return the canonical encoding of the argument. Currently, the encoding of a instance is always canonical, so this operation returns its argument unchanged. Compare the values of two Decimal instances. returns a Decimal instance, and if either operand is a NaN then the result is a NaN: This operation is identical to the method, except that all NaNs signal. That is, if neither operand is a signaling NaN then any quiet NaN operand is treated as though it were a signaling NaN. Compare two operands using their abstract representation rather than their numerical value. Similar to the method, but the result gives a total ordering on instances. Two instances with the same numeric value but different representations compare unequal in this ordering: Quiet and signaling NaNs are also included in the total ordering. The result of this function is if both operands have the same representation, if the first operand is lower in the total order than the second, and if the first operand is higher in the total order than the second operand. See the specification for details of the total order. This operation is unaffected by context and is quiet: no flags are changed and no rounding is performed. As an exception, the C version may raise InvalidOperation if the second operand cannot be converted exactly. Compare two operands using their abstract representation rather than their value as in , but ignoring the sign of each operand. is equivalent to . This operation is unaffected by context and is quiet: no flags are changed and no rounding is performed. As an exception, the C version may raise InvalidOperation if the second operand cannot be converted exactly. Just returns self, this method is only to comply with the Decimal Specification. Return the absolute value of the argument. This operation is unaffected by the context and is quiet: no flags are changed and no rounding is performed. Return the negation of the argument. This operation is unaffected by the context and is quiet: no flags are changed and no rounding is performed. Return a copy of the first operand with the sign set to be the same as the sign of the second operand. For example: This operation is unaffected by context and is quiet: no flags are changed and no rounding is performed. As an exception, the C version may raise InvalidOperation if the second operand cannot be converted exactly. Return the value of the (natural) exponential function at the given number. The result is correctly rounded using the rounding mode. Alternative constructor that only accepts instances of or . Note is not the same as . Since 0.1 is not exactly representable in binary floating point, the value is stored as the nearest representable value which is . That equivalent value in decimal is . From Python 3.2 onwards, a instance can also be constructed directly from a . Fused multiply-add. Return self*other+third with no rounding of the intermediate product self*other. Return if the argument is canonical and otherwise. Currently, a instance is always canonical, so this operation always returns . Return if the argument is a finite number, and if the argument is an infinity or a NaN. Return if the argument is either positive or negative infinity and otherwise. Return if the argument is a (quiet or signaling) NaN and otherwise. Return if the argument is a normal finite number. Return if the argument is zero, subnormal, infinite or a NaN. Return if the argument is a quiet NaN, and otherwise. Return if the argument has a negative sign and otherwise. Note that zeros and NaNs can both carry signs. Return if the argument is a signaling NaN and otherwise. Return if the argument is subnormal, and otherwise. Return if the argument is a (positive or negative) zero and otherwise. Return the natural (base e) logarithm of the operand. The result is correctly rounded using the rounding mode. Return the base ten logarithm of the operand. The result is correctly rounded using the rounding mode. For a nonzero number, return the adjusted exponent of its operand as a instance. If the operand is a zero then is returned and the flag is raised. If the operand is an infinity then is returned. is a logical operation which takes two logical operands (see Logical operands). The result is the digit-wise of the two operands. is a logical operation. The result is the digit-wise inversion of the operand. is a logical operation which takes two logical operands (see Logical operands). The result is the digit-wise of the two operands. is a logical operation which takes two logical operands (see Logical operands). The result is the digit-wise exclusive or of the two operands. Like except that the context rounding rule is applied before returning and that values are either signaled or ignored (depending on the context and whether they are signaling or quiet). Similar to the method, but the comparison is done using the absolute values of the operands. Like except that the context rounding rule is applied before returning and that values are either signaled or ignored (depending on the context and whether they are signaling or quiet). Similar to the method, but the comparison is done using the absolute values of the operands. Return the largest number representable in the given context (or in the current thread’s context if no context is given) that is smaller than the given operand. Return the smallest number representable in the given context (or in the current thread’s context if no context is given) that is larger than the given operand. If the two operands are unequal, return the number closest to the first operand in the direction of the second operand. If both operands are numerically equal, return a copy of the first operand with the sign set to be the same as the sign of the second operand. Used for producing canonical values of an equivalence class within either the current context or the specified context. This has the same semantics as the unary plus operation, except that if the final result is finite it is reduced to its simplest form, with all trailing zeros removed and its sign preserved. That is, while the coefficient is non-zero and a multiple of ten the coefficient is divided by ten and the exponent is incremented by 1. Otherwise (the coefficient is zero) the exponent is set to 0. In all cases the sign is unchanged. For example, and both normalize to the equivalent value . Note that rounding is applied before reducing to simplest form. In the latest versions of the specification, this operation is also known as . Return a string describing the class of the operand. The returned value is one of the following ten strings.\n• None , indicating that the operand is negative infinity.\n• None , indicating that the operand is a negative normal number.\n• None , indicating that the operand is negative and subnormal.\n• None , indicating that the operand is a negative zero.\n• None , indicating that the operand is a positive zero.\n• None , indicating that the operand is positive and subnormal.\n• None , indicating that the operand is a positive normal number.\n• None , indicating that the operand is positive infinity.\n• None , indicating that the operand is a quiet NaN (Not a Number).\n• None , indicating that the operand is a signaling NaN. Return a value equal to the first operand after rounding and having the exponent of the second operand. Unlike other operations, if the length of the coefficient after the quantize operation would be greater than precision, then an is signaled. This guarantees that, unless there is an error condition, the quantized exponent is always equal to that of the right-hand operand. Also unlike other operations, quantize never signals Underflow, even if the result is subnormal and inexact. If the exponent of the second operand is larger than that of the first then rounding may be necessary. In this case, the rounding mode is determined by the argument if given, else by the given argument; if neither argument is given the rounding mode of the current thread’s context is used. An error is returned whenever the resulting exponent is greater than or less than . Return , the radix (base) in which the class does all its arithmetic. Included for compatibility with the specification. Return the remainder from dividing self by other. This differs from in that the sign of the remainder is chosen so as to minimize its absolute value. More precisely, the return value is where is the integer nearest to the exact value of , and if two integers are equally near then the even one is chosen. If the result is zero then its sign will be the sign of self. Return the result of rotating the digits of the first operand by an amount specified by the second operand. The second operand must be an integer in the range -precision through precision. The absolute value of the second operand gives the number of places to rotate. If the second operand is positive then rotation is to the left; otherwise rotation is to the right. The coefficient of the first operand is padded on the left with zeros to length precision if necessary. The sign and exponent of the first operand are unchanged. Test whether self and other have the same exponent or whether both are . This operation is unaffected by context and is quiet: no flags are changed and no rounding is performed. As an exception, the C version may raise InvalidOperation if the second operand cannot be converted exactly. Return the first operand with exponent adjusted by the second. Equivalently, return the first operand multiplied by . The second operand must be an integer. Return the result of shifting the digits of the first operand by an amount specified by the second operand. The second operand must be an integer in the range -precision through precision. The absolute value of the second operand gives the number of places to shift. If the second operand is positive then the shift is to the left; otherwise the shift is to the right. Digits shifted into the coefficient are zeros. The sign and exponent of the first operand are unchanged. Return the square root of the argument to full precision. Convert to a string, using engineering notation if an exponent is needed. Engineering notation has an exponent which is a multiple of 3. This can leave up to 3 digits to the left of the decimal place and may require the addition of either one or two trailing zeros. For example, this converts to . Identical to the method. The name has been kept for compatibility with older versions. Round to the nearest integer, signaling or as appropriate if rounding occurs. The rounding mode is determined by the parameter if given, else by the given . If neither parameter is given then the rounding mode of the current context is used. Round to the nearest integer without signaling or . If given, applies rounding; otherwise, uses the rounding method in either the supplied context or the current context. Decimal numbers can be rounded using the function: If ndigits is not given or , returns the nearest to number, rounding ties to even, and ignoring the rounding mode of the context. Raises if number is an infinity or if it is a (quiet or signaling) NaN. If ndigits is an , the context’s rounding mode is respected and a representing number rounded to the nearest multiple of is returned; in this case, is equivalent to . Returns if number is a quiet NaN. Raises if number is an infinity, a signaling NaN, or if the length of the coefficient after the quantize operation would be greater than the current context’s precision. In other words, for the non-corner cases:\n• None if ndigits is positive, return number rounded to ndigits decimal places;\n• None if ndigits is zero, return number rounded to the nearest integer;\n• None if ndigits is negative, return number rounded to the nearest multiple of . The , , , and methods expect their arguments to be logical operands. A logical operand is a instance whose exponent and sign are both zero, and whose digits are all either or .\n\nContexts are environments for arithmetic operations. They govern precision, set rules for rounding, determine which signals are treated as exceptions, and limit the range for exponents. Each thread has its own current context which is accessed or changed using the and functions: Return the current context for the active thread. Set the current context for the active thread to c. You can also use the statement and the function to temporarily change the active context. Return a context manager that will set the current context for the active thread to a copy of ctx on entry to the with-statement and restore the previous context when exiting the with-statement. If no context is specified, a copy of the current context is used. The kwargs argument is used to set the attributes of the new context. For example, the following code sets the current decimal precision to 42 places, performs a calculation, and then automatically restores the previous context: # Round the final result back to the default precision Using keyword arguments, the code would be the following: Raises if kwargs supplies an attribute that doesn’t support. Raises either or if kwargs supplies an invalid value for an attribute. Changed in version 3.11: now supports setting context attributes through the use of keyword arguments. New contexts can also be created using the constructor described below. In addition, the module provides three pre-made contexts: This is a standard context defined by the General Decimal Arithmetic Specification. Precision is set to nine. Rounding is set to . All flags are cleared. All traps are enabled (treated as exceptions) except , , and . Because many of the traps are enabled, this context is useful for debugging. This is a standard context defined by the General Decimal Arithmetic Specification. Precision is set to nine. Rounding is set to . All flags are cleared. No traps are enabled (so that exceptions are not raised during computations). Because the traps are disabled, this context is useful for applications that prefer to have result value of or instead of raising exceptions. This allows an application to complete a run in the presence of conditions that would otherwise halt the program. This context is used by the constructor as a prototype for new contexts. Changing a field (such a precision) has the effect of changing the default for new contexts created by the constructor. This context is most useful in multi-threaded environments. Changing one of the fields before threads are started has the effect of setting system-wide defaults. Changing the fields after threads have started is not recommended as it would require thread synchronization to prevent race conditions. In single threaded environments, it is preferable to not use this context at all. Instead, simply create contexts explicitly as described below. The default values are = , = , and enabled traps for , , and . In addition to the three supplied contexts, new contexts can be created with the constructor. Creates a new context. If a field is not specified or is , the default values are copied from the . If the flags field is not specified or is , all flags are cleared. prec is an integer in the range [ , ] that sets the precision for arithmetic operations in the context. The rounding option is one of the constants listed in the section Rounding Modes. The traps and flags fields list any signals to be set. Generally, new contexts should only set traps and leave the flags clear. The Emin and Emax fields are integers specifying the outer limits allowable for exponents. Emin must be in the range [ , ], Emax in the range [ , ]. The capitals field is either or (the default). If set to , exponents are printed with a capital ; otherwise, a lowercase is used: . The clamp field is either (the default) or . If set to , the exponent of a instance representable in this context is strictly limited to the range . If clamp is then a weaker condition holds: the adjusted exponent of the instance is at most . When clamp is , a large normal number will, where possible, have its exponent reduced and a corresponding number of zeros added to its coefficient, in order to fit the exponent constraints; this preserves the value of the number but loses information about significant trailing zeros. For example: A clamp value of allows compatibility with the fixed-width decimal interchange formats specified in IEEE 754. The class defines several general purpose methods as well as a large number of methods for doing arithmetic directly in a given context. In addition, for each of the methods described above (with the exception of the and methods) there is a corresponding method. For example, for a instance and instance , is equivalent to . Each method accepts a Python integer (an instance of ) anywhere that a Decimal instance is accepted. Resets all of the flags to . Resets all of the traps to . Creates a new Decimal instance from num but using self as context. Unlike the constructor, the context precision, rounding method, flags, and traps are applied to the conversion. This is useful because constants are often given to a greater precision than is needed by the application. Another benefit is that rounding immediately eliminates unintended effects from digits beyond the current precision. In the following example, using unrounded inputs means that adding zero to a sum can change the result: This method implements the to-number operation of the IBM specification. If the argument is a string, no leading or trailing whitespace or underscores are permitted. Creates a new Decimal instance from a float f but rounding using self as the context. Unlike the class method, the context precision, rounding method, flags, and traps are applied to the conversion. Returns a value equal to which is the minimum exponent value for subnormal results. When underflow occurs, the exponent is set to . The usual approach to working with decimals is to create instances and then apply arithmetic operations which take place within the current context for the active thread. An alternative approach is to use context methods for calculating within a specific context. The methods are similar to those for the class and are only briefly recounted here. Returns the absolute value of x. Return the sum of x and y. Compares the values of the two operands numerically. Compares two operands using their abstract representation. Compares two operands using their abstract representation, ignoring sign. Returns a copy of x with the sign set to 0. Returns a copy of x with the sign inverted. Copies the sign from y to x. Return x divided by y, truncated to an integer. Divides two numbers and returns the integer part of the result. Returns if x is canonical; otherwise returns . Returns if x is finite; otherwise returns . Returns if x is infinite; otherwise returns . Returns if x is a qNaN or sNaN; otherwise returns . Returns if x is a normal number; otherwise returns . Returns if x is a quiet NaN; otherwise returns . Returns if x is negative; otherwise returns . Returns if x is a signaling NaN; otherwise returns . Returns if x is subnormal; otherwise returns . Returns if x is a zero; otherwise returns . Returns the exponent of the magnitude of the operand’s MSD. Applies the logical operation and between each operand’s digits. Invert all the digits in x. Applies the logical operation or between each operand’s digits. Applies the logical operation xor between each operand’s digits. Compares two values numerically and returns the maximum. Compares the values numerically with their sign ignored. Compares two values numerically and returns the minimum. Compares the values numerically with their sign ignored. Minus corresponds to the unary prefix minus operator in Python. Return the product of x and y. Returns the number closest to x, in direction towards y. Returns an indication of the class of x. Plus corresponds to the unary prefix plus operator in Python. This operation applies the context precision and rounding, so it is not an identity operation. Return to the power of , reduced modulo if given. With two arguments, compute . If is negative then must be integral. The result will be inexact unless is integral and the result is finite and can be expressed exactly in ‘precision’ digits. The rounding mode of the context is used. Results are always correctly rounded in the Python version. results in , and if is not trapped, then results in . Changed in version 3.3: The C module computes in terms of the correctly rounded and functions. The result is well-defined but only “almost always correctly rounded”. With three arguments, compute . For the three argument form, the following restrictions on the arguments hold:\n• None all three arguments must be integral\n• None at least one of or must be nonzero\n• None must be nonzero and have at most ‘precision’ digits The value resulting from is equal to the value that would be obtained by computing with unbounded precision, but is computed more efficiently. The exponent of the result is zero, regardless of the exponents of , and . The result is always exact. Returns a value equal to x (rounded), having the exponent of y. Just returns 10, as this is Decimal, :) The sign of the result, if non-zero, is the same as that of the original dividend. Returns , where n is the integer nearest the exact value of (if the result is 0 then its sign will be the sign of x). Returns if the two operands have the same exponent. Returns the first operand after adding the second value its exp. Return the difference between x and y. Convert to a string, using engineering notation if an exponent is needed. Engineering notation has an exponent which is a multiple of 3. This can leave up to 3 digits to the left of the decimal place and may require the addition of either one or two trailing zeros.\n\nThe use of decimal floating point eliminates decimal representation error (making it possible to represent exactly); however, some operations can still incur round-off error when non-zero digits exceed the fixed precision. The effects of round-off error can be amplified by the addition or subtraction of nearly offsetting quantities resulting in loss of significance. Knuth provides two instructive examples where rounded floating-point arithmetic with insufficient precision causes the breakdown of the associative and distributive properties of addition: The module makes it possible to restore the identities by expanding the precision sufficiently to avoid loss of significance: The number system for the module provides special values including , , , , and two zeros, and . Infinities can be constructed directly with: . Also, they can arise from dividing by zero when the signal is not trapped. Likewise, when the signal is not trapped, infinity can result from rounding beyond the limits of the largest representable number. The infinities are signed (affine) and can be used in arithmetic operations where they get treated as very large, indeterminate numbers. For instance, adding a constant to infinity gives another infinite result. Some operations are indeterminate and return , or if the signal is trapped, raise an exception. For example, returns which means “not a number”. This variety of is quiet and, once created, will flow through other computations always resulting in another . This behavior can be useful for a series of computations that occasionally have missing inputs — it allows the calculation to proceed while flagging specific results as invalid. A variant is which signals rather than remaining quiet after every operation. This is a useful return value when an invalid result needs to interrupt a calculation for special handling. The behavior of Python’s comparison operators can be a little surprising where a is involved. A test for equality where one of the operands is a quiet or signaling always returns (even when doing ), while a test for inequality always returns . An attempt to compare two Decimals using any of the , , or operators will raise the signal if either operand is a , and return if this signal is not trapped. Note that the General Decimal Arithmetic specification does not specify the behavior of direct comparisons; these rules for comparisons involving a were taken from the IEEE 854 standard (see Table 3 in section 5.7). To ensure strict standards-compliance, use the and methods instead. The signed zeros can result from calculations that underflow. They keep the sign that would have resulted if the calculation had been carried out to greater precision. Since their magnitude is zero, both positive and negative zeros are treated as equal and their sign is informational. In addition to the two signed zeros which are distinct yet equal, there are various representations of zero with differing precisions yet equivalent in value. This takes a bit of getting used to. For an eye accustomed to normalized floating-point representations, it is not immediately obvious that the following calculation returns a value equal to zero:\n\nQ. It is cumbersome to type . Is there a way to minimize typing when using the interactive interpreter? A. Some users abbreviate the constructor to just a single letter: Q. In a fixed-point application with two decimal places, some inputs have many places and need to be rounded. Others are not supposed to have excess digits and need to be validated. What methods should be used? A. The method rounds to a fixed number of decimal places. If the trap is set, it is also useful for validation: # Validate that a number does not exceed two places Q. Once I have valid two place inputs, how do I maintain that invariant throughout an application? A. Some operations like addition, subtraction, and multiplication by an integer will automatically preserve fixed point. Others operations, like division and non-integer multiplication, will change the number of decimal places and need to be followed-up with a step: In developing fixed-point applications, it is convenient to define functions to handle the step: Q. There are many ways to express the same value. The numbers , , , and all have the same value at various precisions. Is there a way to transform them to a single recognizable canonical value? A. The method maps all equivalent values to a single representative: Q. When does rounding occur in a computation? A. It occurs after the computation. The philosophy of the decimal specification is that numbers are considered exact and are created independent of the current context. They can even have greater precision than current context. Computations process with those exact inputs and then rounding (or other context operations) is applied to the result of the computation: Q. Some decimal values always print with exponential notation. Is there a way to get a non-exponential representation? A. For some values, exponential notation is the only way to express the number of significant places in the coefficient. For example, expressing as keeps the value constant but cannot show the original’s two-place significance. If an application does not care about tracking significance, it is easy to remove the exponent and trailing zeroes, losing significance, but keeping the value unchanged: Q. Is there a way to convert a regular float to a ? A. Yes, any binary floating-point number can be exactly expressed as a Decimal though an exact conversion may take more precision than intuition would suggest: Q. Within a complex calculation, how can I make sure that I haven’t gotten a spurious result because of insufficient precision or rounding anomalies. A. The decimal module makes it easy to test results. A best practice is to re-run calculations using greater precision and with various rounding modes. Widely differing results indicate insufficient precision, rounding mode issues, ill-conditioned inputs, or a numerically unstable algorithm. Q. I noticed that context precision is applied to the results of operations but not to the inputs. Is there anything to watch out for when mixing values of different precisions? A. Yes. The principle is that all values are considered to be exact and so is the arithmetic on those values. Only the results are rounded. The advantage for inputs is that “what you type is what you get”. A disadvantage is that the results can look odd if you forget that the inputs haven’t been rounded: The solution is either to increase precision or to force rounding of inputs using the unary plus operation: Alternatively, inputs can be rounded upon creation using the method: Q. Is the CPython implementation fast for large numbers? A. Yes. In the CPython and PyPy3 implementations, the C/CFFI versions of the decimal module integrate the high speed libmpdec library for arbitrary precision correctly rounded decimal floating-point arithmetic . uses Karatsuba multiplication for medium-sized numbers and the Number Theoretic Transform for very large numbers. The context must be adapted for exact arbitrary precision arithmetic. and should always be set to the maximum values, should always be 0 (the default). Setting requires some care. The easiest approach for trying out bignum arithmetic is to use the maximum value for as well : For inexact results, is far too large on 64-bit platforms and the available memory will be insufficient: On systems with overallocation (e.g. Linux), a more sophisticated approach is to adjust to the amount of available RAM. Suppose that you have 8GB of RAM and expect 10 simultaneous operands using a maximum of 500MB each: # Maximum number of digits for a single operand using 500MB in 8-byte words # with 19 digits per word (4-byte and 9 digits for the 32-bit build): # Fill the available precision with nines: File , line , in : In general (and especially on systems without overallocation), it is recommended to estimate even tighter bounds and set the trap if all calculations are expected to be exact."
    },
    {
        "link": "https://medium.com/@akhilnathe/understanding-the-quirks-of-floating-point-arithmetic-in-python-7d7d436c8338",
        "document": "Consider rounding off 0.3 to 5 decimal places:\n\nBut, when rounded off to 25 decimal places:\n\nAs seen, the first code snippet gives the expected 0.3 with 5 decimal places. But on increasing the precision to 25 decimal places, an unexpected behavior emerges.\n\nYet, when you try:\n\nWhy this inconsistency? The difference arises due to the way floating-point precision is handled in the intermediate calculations.\n\nComputers express numbers in binary format, translating them into powers of 2. Some decimals, like 0.1, don’t have an exact binary representation, causing computers to approximate and sometimes yield unexpected results.\n\nLet us round up 0.1 to 5 decimal places and add them up like this:\n\nHere, evaluates to , not .\n\nAt first glance, and seem identical. Yet, upon comparison:\n\nThe IEEE 754 standard defines the floating-point arithmetic representations used by modern computers. It’s a widely adopted standard that dictates how floating-point numbers should be stored and computed on computers. Due to finite memory, these representations approximate many numbers. More bits yield a closer approximation, but imperfections persist.\n\nPython’s library offers the function for these discrepancies:\n\nThis function checks if two numbers are close enough, considering typical floating-point inaccuracies. This method uses a relative or absolute tolerance, to see if the values are close.\n\nHelp on built-in function isclose in module math:\n\n\n\nisclose(a, b, *, rel_tol=1e-09, abs_tol=0.0)\n\n Determine whether two floating point numbers are close in value.\n\n \n\n rel_tol\n\n maximum difference for being considered \"close\", relative to the\n\n magnitude of the input values\n\n abs_tol\n\n maximum difference for being considered \"close\", regardless of the\n\n magnitude of the input values\n\n \n\n Return True if a is close in value to b, and False otherwise.\n\n \n\n For the values to be considered close, the difference between them\n\n must be smaller than at least one of the tolerances.\n\n \n\n -inf, inf and NaN behave similarly to the IEEE 754 Standard. That\n\n is, NaN is not close to anything, even itself. inf and -inf are\n\n only close to themselves.\n\nWhile this seems straightforward at first, it’s essential to delve deeper for an accurate understanding.\n\nYou need to be very careful to use a combination of relative tolerance and absolute tolerance. Using only one of them in isolation makes it difficult to get a one-size-fits-all solution. This is explained quite well in PEP-485. I will try to provide an essence here below.\n\nThe function offers two primary parameters to determine how \"close\" two numbers must be to be considered equal: (relative tolerance) and (absolute tolerance).\n• Represents the maximum allowed difference between and as a fraction of the larger absolute value of or .\n• Useful when you want to see if two numbers are close relative to their magnitude.\n\nHere, the relative difference between and is (or 0.1%), which is within the (or 1%) relative tolerance.\n• Represents a fixed, absolute difference that and can have to be considered close.\n• Useful when comparing numbers close to zero.\n\nHere, the absolute difference between and is , which is within the absolute tolerance.\n\nWhy Using Either One in Isolation Can Be Problematic:\n• Only Using : If you're comparing numbers close to zero, alone can be misleading. For instance:\n\nEven though and are very close in absolute terms, their relative difference is vast. This leads to a false result. This outcome arises because the relative tolerance is calculated as a ratio of the absolute difference compared to the maximum of the two numbers — in this case, a. Since a is minuscule, the relative tolerance becomes a much larger number.\n• Only Using : If you're comparing large numbers, can be too large:\n\nHere, the numbers differ by , which is not within the absolute tolerance, but they have a significant relative difference.\n\nA Balanced Solution: Using both and together allows to handle a wide range of scenarios. The function considers two numbers close if their difference is within either the relative or absolute tolerance. This dual approach ensures that the comparison is robust across various magnitudes and use cases.\n\nAnd in both these cases"
    }
]