[
    {
        "link": "https://socket.io/docs/v4/client-api",
        "document": "The method is bound to the global scope in the standalone build:\n\nAn ESM bundle is also available since version 4.3.0:\n\nElse, in all other cases (with some build tools, in Node.js or React Native), it can be imported from the package:\n\nThe protocol defines the format of the packets exchanged between the client and the server. Both the client and the server must use the same revision in order to understand each other.\n\nYou can find more information here.\n• \n• whether to create a new connection\n\nCreates a new for the given URL, and attempts to reuse an existing for subsequent calls, unless the option is passed with . Passing this option is the equivalent of passing or .\n\nA new instance is returned for the namespace specified by the pathname in the URL, defaulting to . For example, if the is , a transport connection will be established to and a Socket.IO connection will be established to .\n\nQuery parameters can also be provided, either with the option or directly in the url (example: ).\n\nTo understand what happens under the hood, the following example:\n\nis the short version of:\n\nThe complete list of available options can be found here.\n\nThe manages the Engine.IO client instance, which is the low-level engine that establishes the connection to the server (by using transports like WebSocket or HTTP long-polling).\n\nA single can be used by several Sockets. You can find more information about this multiplexing feature here.\n\nPlease note that, in most cases, you won't use the Manager directly but use the Socket instance instead.\n\nThe complete list of available options can be found here.\n\nFired when a ping packet is received from the server.\n\nFired upon an attempt to reconnect.\n\nIf the manager was initiated with to , launch a new connection attempt.\n\nThe argument is optional and will be called once the attempt fails/succeeds.\n\nSets the option, or returns it if no parameters are passed.\n\nSets the option, or returns it if no parameters are passed.\n\nSets the option, or returns it if no parameters are passed.\n\nSets the option, or returns it if no parameters are passed.\n\nCreates a new for the given namespace. Only ( ) is read from the object. Other keys will be ignored and should be passed when instancing a .\n\nSets the option, or returns it if no parameters are passed.\n\nA is the fundamental class for interacting with the server. A belongs to a certain Namespace (by default ) and uses an underlying Manager to communicate.\n\nA is basically an EventEmitter which sends events to — and receive events from — the server over the network.\n\nMore information can be found here.\n\nThis event is fired by the Socket instance upon connection and reconnection.\n\nThis event is fired upon connection failure.\n\nThe attribute indicates whether the socket will automatically try to reconnect after a small randomized delay:\n\nThis event is fired upon disconnection.\n\nHere is the list of possible reasons:\n\nThe attribute indicates whether the socket will automatically try to reconnect after a small randomized delay:\n\nWhether the socket will automatically try to reconnect.\n\nThis attribute can be used after a connection failure:\n\nWhether the socket is currently connected to the server.\n\nWhether the socket is currently disconnected from the server.\n\nA unique identifier for the socket session. Set after the event is triggered, and updated after the event.\n\nWhether the connection state was successfully recovered during the last reconnection.\n\nMore information about this feature here.\n\nSets a modifier for a subsequent event emission that the event data will only be compressed if the value is . Defaults to when you don't call the method.\n\nIt can also be used to manually reconnect:\n\nManually disconnects the socket. In that case, the socket will not try to reconnect.\n\nIf this is the last active Socket instance of the Manager, the low-level connection will be closed.\n\nEmits an event to the socket identified by the string name. Any other parameters can be included. All serializable data structures are supported, including .\n\nThe argument is optional and will be called with the server answer.\n\nPromised-based version of emitting and expecting an acknowledgement from the server:\n\nThe example above is equivalent to:\n\nAnd on the receiving side:\n\nReturns the array of listeners for the event named .\n\nReturns the list of registered catch-all listeners for outgoing packets.\n\nRemoves the specified from the listener array for the event named .\n\nThe argument can also be omitted:\n\nRemoves the previously registered listener. If no listener is provided, all catch-all listeners are removed.\n\nRemoves the previously registered listener. If no listener is provided, all catch-all listeners are removed.\n\nRegister a new handler for the given event.\n\nAdds a one-time function for the event named . The next time is triggered, this listener is removed and then invoked.\n\nRegister a new catch-all listener. The listener is added to the beginning of the listeners array.\n\nRegister a new catch-all listener for outgoing packets. The listener is added to the beginning of the listeners array.\n\nSets a modifier for a subsequent event emission that the callback will be called with an error when the given number of milliseconds have elapsed without an acknowledgement from the server:\n\nSets a modifier for the subsequent event emission indicating that the packet may be dropped if:\n• the socket is not connected\n• the low-level transport is not writable (for example, when a request is already running in HTTP long-polling mode)"
    },
    {
        "link": "https://socket.io/docs/v4",
        "document": "Socket.IO is a library that enables low-latency, bidirectional and event-based communication between a client and a server.\n\nThe Socket.IO connection can be established with different low-level transports:\n\nSocket.IO will automatically pick the best available option, depending on:\n• the capabilities of the browser (see here and here)\n\nYou can find more detail about that in the \"How it works\" section.\n\nAlthough Socket.IO indeed uses WebSocket for transport when possible, it adds additional metadata to each packet. That is why a WebSocket client will not be able to successfully connect to a Socket.IO server, and a Socket.IO client will not be able to connect to a plain WebSocket server either.\n\nIf you are looking for a plain WebSocket server, please take a look at ws or µWebSockets.js.\n\nThere are also discussions for including a WebSocket server in the Node.js core.\n\nOn the client-side, you might be interested in the robust-websocket package.\n\nThe Socket.IO library keeps an open TCP connection to the server, which may result in a high battery drain for your users. Please use a dedicated messaging platform like FCM for this use case.\n\nHere are the features provided by Socket.IO over plain WebSockets:\n\nThe connection will fall back to HTTP long-polling in case the WebSocket connection cannot be established.\n\nThis feature was the #1 reason people used Socket.IO when the project was created more than ten years ago (!), as the browser support for WebSockets was still in its infancy.\n\nEven if most browsers now support WebSockets (more than 97%), it is still a great feature as we still receive reports from users that cannot establish a WebSocket connection because they are behind some misconfigured proxy.\n\nUnder some particular conditions, the WebSocket connection between the server and the client can be interrupted with both sides being unaware of the broken state of the link.\n\nThat's why Socket.IO includes a heartbeat mechanism, which periodically checks the status of the connection.\n\nAnd when the client eventually gets disconnected, it automatically reconnects with an exponential back-off delay, in order not to overwhelm the server.\n\nThe packets are automatically buffered when the client is disconnected, and will be sent upon reconnection.\n\nSocket.IO provides a convenient way to send an event and receive a response:\n\nYou can also add a timeout:\n\nOn the server-side, you can send an event to all connected clients or to a subset of clients:\n\nThis also works when scaling to multiple nodes.\n\nNamespaces allow you to split the logic of your application over a single shared connection. This can be useful for example if you want to create an \"admin\" channel that only authorized users can join.\n\nMore on that here.\n\nThat's a fair question, since WebSockets are supported almost everywhere now.\n\nThat being said, we believe that, if you use plain WebSockets for your application, you will eventually need to implement most of the features that are already included (and battle-tested) in Socket.IO, like reconnection, acknowledgements or broadcasting.\n\nwill be sent as a single WebSocket frame containing with:\n• being the -ed version of the arguments array\n\nSo, a few additional bytes for each message, which can be further reduced by the usage of a custom parser.\n\nYou can find the details of the Socket.IO protocol here."
    },
    {
        "link": "https://socket.io/docs/v3/client-api",
        "document": "Exposed as the namespace in the standalone build, or the result of calling .\n\nThe protocol defines the format of the packets exchanged between the client and the server. Both the client and the server must use the same revision in order to understand each other.\n\nYou can find more information here.\n• (Object)\n• (Boolean) whether to reuse an existing connection\n\nCreates a new for the given URL, and attempts to reuse an existing for subsequent calls, unless the option is passed with . Passing this option is the equivalent of passing or .\n\nA new instance is returned for the namespace specified by the pathname in the URL, defaulting to . For example, if the is , a transport connection will be established to and a Socket.IO connection will be established to .\n\nQuery parameters can also be provided, either with the option or directly in the url (example: ).\n\nis the short version of:\n\nSee new Manager(url[, options]) for the list of available .\n\nPlease note: will only read the key in the object. and other optional values are only used when passed via a instance.\n\nSee Migrating from 2.x to 3.0 for more on the difference between the and options.\n\nThe manages the Engine.IO client instance, which is the low-level engine that establishes the connection to the server (by using transports like WebSocket or HTTP long-polling).\n\nA single can be used by several Sockets. You can find more information about this multiplexing feature here.\n\nPlease note that, in most cases, you won't use the Manager directly but use the Socket instance instead.\n\nAvailable options for the underlying Engine.IO client:\n\nSets the option, or returns it if no parameters are passed.\n\nSets the option, or returns it if no parameters are passed.\n\nSets the option, or returns it if no parameters are passed.\n\nSets the option, or returns it if no parameters are passed.\n\nSets the option, or returns it if no parameters are passed.\n\nIf the manager was initiated with to , launch a new connection attempt.\n\nThe argument is optional and will be called once the attempt fails/succeeds.\n\nCreates a new for the given namespace. Only ( ) is read from the object. Other keys will be ignored and should be passed when instancing a .\n\nFired upon an attempt to reconnect.\n\nFired when a ping packet is received from the server.\n\nA is the fundamental class for interacting with the server. A belongs to a certain Namespace (by default ) and uses an underlying Manager to communicate.\n\nA is basically an EventEmitter which sends events to — and receive events from — the server over the network.\n\nMore information can be found here.\n\nA unique identifier for the socket session. Set after the event is triggered, and updated after the event.\n\nWhether or not the socket is connected to the server.\n\nWhether or not the socket is disconnected from the server.\n\nIt can also be used to manually reconnect:\n\nEmits an event to the socket identified by the string name. Any other parameters can be included. All serializable data structures are supported, including .\n\nThe argument is optional and will be called with the server answer.\n\nRegister a new handler for the given event.\n\nThe socket actually inherits every method of the Emitter class, like , or (to remove an event listener).\n\nRegister a new catch-all listener. The listener is added to the beginning of the listeners array.\n\nRemoves the previously registered listener. If no listener is provided, all catch-all listeners are removed.\n\nSets a modifier for a subsequent event emission that the event data will only be compressed if the value is . Defaults to when you don't call the method.\n\nManually disconnects the socket. In that case, the socket will not try to reconnect.\n\nIf this is the last active Socket instance of the Manager, the low-level connection will be closed.\n\nSets a modifier for the subsequent event emission indicating that the packet may be dropped if:\n• the socket is not connected\n• the low-level transport is not writable (for example, when a request is already running in HTTP long-polling mode)\n\nFired upon connection to the Namespace (including a successful reconnection).\n\nFired upon disconnection. The list of possible disconnection reasons:\n\nIn the first two cases (explicit disconnection), the client will not try to reconnect and you need to manually call .\n\nIn all other cases, the client will wait for a small random delay and then try to reconnect:"
    },
    {
        "link": "https://python-socketio.readthedocs.io/en/latest/client.html",
        "document": "This package contains two Socket.IO clients:\n• None a “simple” client, which provides a straightforward API that is sufficient for most applications\n• None an “event-driven” client, which provides access to all the features of the Socket.IO protocol\n\nEach of these clients comes in two variants: one for the standard Python library, and another for asynchronous applications built with the package.\n\nTo install the standard Python client along with its dependencies, use the following command: If instead you plan on using the client, then use this:\n\nThe advantage of the simple client is that it abstracts away the logic required to maintain a Socket.IO connection. This client handles disconnections and reconnections in a completely transparent way, without adding any complexity to the application. The easiest way to create a Socket.IO client is to use the context manager interface: # ... connect to a server and use the client # ... no need to manually disconnect! # ... connect to a server and use the client # ... no need to manually disconnect! With this usage the context manager will ensure that the client is properly disconnected before exiting the or block. If preferred, a client can be manually instantiated: The connection to a server is established by calling the method: In the case of the client, the method is a coroutine: By default the client first connects to the server using the long-polling transport, and then attempts to upgrade the connection to use WebSocket. To connect directly using WebSocket, use the argument: Upon connection, the server assigns the client a unique session identifier. The application can find this identifier in the attribute: The Socket.IO transport that is used in the connection can be obtained from the attribute: The transport is given as a string, and can be either or . The client supports TLS/SSL connections. To enable it, use a connection URL: The client verifies server certificates by default. Consult the documentation for the event-driven client for information on how to customize this behavior. The client can emit an event to the server using the method: Or in the case of , as a coroutine: The arguments provided to the method are the name of the event to emit and the optional data that is passed on to the server. The data can be of type , , , or . When sending a or a , the elements in it need to be of any allowed types except . When a tuple is used, the elements of the tuple will be passed as individual arguments to the server-side event handler function. The client can wait for the server to emit an event with the method: When using , this method needs to be awaited: The return value of is a list. The first element of this list is the event name, while the remaining elements are the arguments passed by the server. With the usage shown above, the method will return only when an event is received from the server. An optional timeout in seconds can be passed to prevent the client from waiting forever: At any time the client can request to be disconnected from the server by invoking the method: For the client this is a coroutine: To help you debug issues, the client can be configured to output logs to the terminal: The argument controls logging related to the Socket.IO protocol, while controls logs that originate in the low-level Engine.IO transport. These arguments can be set to to output logs to , or to an object compatible with Python’s package where the logs should be emitted to. A value of disables logging. Logging can help identify the cause of connection problems, unexpected disconnections and other issues.\n\nTo instantiate an Socket.IO client, simply create an instance of the appropriate client class: The Socket.IO protocol is event based. When a server wants to communicate with a client it emits an event. Each event has a name, and a list of arguments. The client registers event handler functions with the or decorators: In the first example the event name is obtained from the name of the handler function. The second example is slightly more verbose, but it allows the event name to be different than the function name or to include characters that are illegal in function names, such as spaces. For the client, event handlers can be regular functions as above, or can also be coroutines: If the server includes arguments with an event, those are passed to the handler function as arguments. A “catch-all” event handler is invoked for any events that do not have an event handler. You can define a catch-all handler using as event name: Asyncio servers can also use a coroutine: A catch-all event handler receives the event name as a first argument. The remaining arguments are the same as for a regular event handler. The and events have to be defined explicitly and are not invoked on a catch-all event handler. Similarily, a “catch-all” namespace handler is invoked for any connected namespaces that do not have an explicitly defined event handler. As with catch-all events, is used in place of a namespace: For these events, the namespace is passed as first argument, followed by the regular arguments of the event. Lastly, it is also possible to define a “catch-all” handler for all events on all namespaces: Event handlers with catch-all events and namespaces receive the event name and the namespace as first and second arguments. The , and events are special; they are invoked automatically when a client connects or disconnects from the server: The handler is invoked when a connection attempt fails. If the server provides arguments, these are passed on to the handler. The server can use an argument to provide information to the client regarding the connection failure. The handler is invoked for application initiated disconnects, server initiated disconnects, or accidental disconnects, for example due to networking failures. In the case of an accidental disconnection, the client is going to attempt to reconnect immediately after invoking the disconnect handler. As soon as the connection is re-established the connect handler will be invoked once again. The handler receives a argument which provides the cause of the disconnection: See the The attribute for a list of possible disconnection reasons. The , and events have to be defined explicitly and are not invoked on a catch-all event handler. The connection to a server is established by calling the method: In the case of the client, the method is a coroutine: Upon connection, the server assigns the client a unique session identifier. The application can find this identifier in the attribute: The Socket.IO transport that is used in the connection can be obtained from the attribute: The transport is given as a string, and can be either or . The client supports TLS/SSL connections. To enable it, use a connection URL: The client will verify the server certificate by default. To disable certificate verification, or to use other less common options such as client certificates, the client must be initialized with a custom HTTP session object that is configured with the desired TLS/SSL options. The following example disables server certificate verification, which can be useful when connecting to a server that uses a self-signed certificate: Instead of disabling certificate verification, you can provide a custom certificate authority bundle to verify the certificate against: Below you can see how to use a client certificate to authenticate against the server: The client can emit an event to the server using the method: Or in the case of , as a coroutine: The arguments provided to the method are the name of the event to emit and the optional data that is passed on to the server. The data can be of type , , , or . When sending a or a , the elements in it need to be of any allowed types except . When a tuple is used, the elements of the tuple will be passed as individual arguments to the server-side event handler function. The method can be invoked inside an event handler as a response to a server event, or in any other part of the application, including in background tasks. When a server emits an event to a client, it can optionally provide a callback function, to be invoked as a way of acknowledgment that the server has processed the event. While this is entirely managed by the server, the client can provide a list of return values that are to be passed on to the callback function set up by the server. This is achieved simply by returning the desired values from the handler function: Likewise, the client can request a callback function to be invoked after the server has processed an event. The method has an optional argument that can be set to a callable. If this argument is given, the callable will be invoked after the server has processed the event, and any values returned by the server handler will be passed as arguments to this function. The Socket.IO protocol supports multiple logical connections, all multiplexed on the same physical connection. Clients can open multiple connections by specifying a different namespace on each. Namespaces use a path syntax starting with a forward slash. A list of namespaces can be given by the client in the call. For example, this example creates two logical connections, the default one plus a second connection under the namespace: To define event handlers on a namespace, the argument must be added to the corresponding decorator: Likewise, the client can emit an event to the server on a namespace by providing its in the call: If the argument of the call isn’t given, any namespaces used in event handlers are automatically connected. As an alternative to the decorator-based event handlers, the event handlers that belong to a namespace can be created as methods of a subclass of : For asyncio based servers, namespaces must inherit from , and can define event handlers as coroutines if desired: A catch-all class-based namespace handler can be defined by passing as the namespace during registration: When class-based namespaces are used, any events received by the client are dispatched to a method named as the event name with the prefix. For example, event will be handled by a method named . If an event is received for which there is no corresponding method defined in the namespace class, then the event is ignored. All event names used in class-based namespaces must use characters that are legal in method names. As a convenience to methods defined in a class-based namespace, the namespace instance includes versions of several of the methods in the and classes that default to the proper namespace when the argument is not given. In the case that an event has a handler in a class-based namespace, and also a decorator-based function handler, only the standalone function handler is invoked. At any time the client can request to be disconnected from the server by invoking the method: For the client this is a coroutine: When a client connection to the server is established, a few background tasks will be spawned to keep the connection alive and handle incoming events. The application running on the main thread is free to do any work, as this is not going to prevent the functioning of the Socket.IO client. If the application does not have anything to do in the main thread and just wants to wait until the connection with the server ends, it can call the method: Or in the version: For the convenience of the application, a helper function is provided to start a custom background task: # do some background work here! The arguments passed to this method are the background function and any positional or keyword arguments to invoke the function with. Here is the version: # do some background work here! Note that this function is not a coroutine, since it does not wait for the background function to end. The background function must be a coroutine. The method is a second convenience function that is provided for the benefit of applications working with background tasks of their own: The single argument passed to the method is the number of seconds to sleep for. To help you debug issues, the client can be configured to output logs to the terminal: The argument controls logging related to the Socket.IO protocol, while controls logs that originate in the low-level Engine.IO transport. These arguments can be set to to output logs to , or to an object compatible with Python’s package where the logs should be emitted to. A value of disables logging. Logging can help identify the cause of connection problems, unexpected disconnections and other issues."
    },
    {
        "link": "https://socket.io/docs/v4/client-socket-instance",
        "document": "A is the fundamental class for interacting with the server. It inherits most of the methods of the Node.js EventEmitter, like emit, on, once or off.\n\nBesides emitting and listening to events, the Socket instance has a few attributes that may be of use in your application:\n\nEach new connection is assigned a random 20-characters identifier.\n\nThis identifier is synced with the value on the server-side.\n\nPlease note that, unless connection state recovery is enabled, the attribute is an ephemeral ID that is not meant to be used in your application (or only for debugging purposes) because:\n• this ID is regenerated after each reconnection (for example when the WebSocket connection is severed, or when the user refreshes the page)\n• two different browser tabs will have two different IDs\n• there is no message queue stored for a given ID on the server (i.e. if the client is disconnected, the messages sent from the server to this ID are lost) Please use a regular session ID instead (either sent in a cookie, or stored in the localStorage and sent in the payload).\n• How to deal with cookies\n\nThis attribute describes whether the socket is currently connected to the server.\n\nThis event is fired by the Socket instance upon connection and reconnection.\n\nThis event is fired upon connection failure.\n\nThe attribute indicates whether the socket will automatically try to reconnect after a small randomized delay:\n\nThis event is fired upon disconnection.\n\nHere is the list of possible reasons:\n\nThe attribute indicates whether the socket will automatically try to reconnect after a small randomized delay:\n\nThe complete API exposed by the Socket instance can be found here."
    },
    {
        "link": "https://medium.com/@conboys111/how-do-you-manage-large-state-objects-in-javascript-without-sacrificing-performance-c048b808213c",
        "document": "I like to think of managing large state objects in JavaScript like tending to a massive garden. Imagine I have this sprawling plot of land, and every plant, tree, and flower represents a part of the state in my app. Some plants are small, like flags for toggling a modal, while others are massive oak trees, like data for my user profile or shopping cart.\n\nNow, if I try to water the entire garden every time something changes — a single flower wilting or a tree sprouting a new leaf — I’ll exhaust myself and waste a lot of resources. Instead, I use a system. First, I divide my garden into zones, grouping plants that are related or close together. In JavaScript terms, these are like components, each managing its slice of state.\n\nThen, I pay attention only to the zones that need care. If a flower in one corner wilts, I don’t water the whole garden — I just focus on that zone. In code, this is like using state libraries such as React’s or to isolate parts of the state, so changes in one place don’t affect the entire app.\n\nSometimes, I notice patterns. Maybe certain plants always need water when it’s sunny, or certain trees drop leaves at the same time of year. I create a schedule to automate this care, similar to memoization or using to avoid unnecessary re-renders.\n\nLastly, I keep an eye on the big picture. Occasionally, I might prune an entire zone that’s no longer needed, just like I clean up state or unsubscribe from listeners to prevent memory leaks. The garden stays healthy, and my work becomes manageable.\n\nIn the end, optimizing state management is all about working smarter, not harder, so my app — or my garden — flourishes without unnecessary effort."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Performance/JavaScript",
        "document": "It is very important to consider how you are using JavaScript on your websites and think about how to mitigate any performance issues that it might be causing. While images and video account for over 70% of the bytes downloaded for the average website, byte per byte, JavaScript has a greater potential for negative performance impact — it can significantly impact download times, rendering performance, and CPU and battery usage. This article introduces tips and techniques for optimizing JavaScript to enhance the performance of your website. To learn about the effects of JavaScript on web performance and how to mitigate or fix related issues.\n\nTo optimize or not to optimize The first question you should answer before starting to optimize your code is \"what do I need to optimize?\". Some of the tips and techniques discussed below are good practices that will benefit just about any web project, whereas some are only needed in certain situations. Trying to apply all these techniques everywhere is probably unnecessary, and may be a waste of your time. You should figure out what performance optimizations are actually needed in each project. To do this, you need to measure the performance of your site. As the previous link shows, there are several different ways to measure performance, some involving sophisticated performance APIs. The best way to get started however, is to learn how to use tools such as built-in browser network and performance tools, to see what parts of the page load are taking a long time and need optimizing.\n\nThe most performant, least blocking JavaScript you can use is JavaScript that you don't use at all. You should use as little JavaScript as possible. Some tips to bear in mind:\n• You don't always need a framework: You might be familiar with using a JavaScript framework. If you are experienced and confident with using this framework, and like all of the tooling it provides, then it might be your go-to tool for building most projects. However, frameworks are JavaScript-heavy. If you are creating a fairly static experience with few JavaScript requirements, you probably don't need that framework. You might be able to implement what you need using a few lines of standard JavaScript.\n• Consider a simpler solution: You might have a flashy, interesting solution to implement, but consider whether your users will appreciate it. Would they prefer something simpler?\n• Remove unused code: This may sound obvious, but it is surprising how many developers forget to clean up unused functionality that was added during the development process. You need to be careful and deliberate about what is added and removed. All script gets parsed, whether it is used or not; therefore, a quick win to speed up downloads would be to get rid of any functionality not being used. Consider also that often you will only use a small amount of the functionality available in a framework. Is it possible to create a custom build of the framework that only contains the part that you need?\n• Consider built-in browser features: It might be that you can use a feature the browser already has, rather than creating your own via JavaScript. For example:\n• Use the browser's own player.\n• Use CSS animations instead of a JavaScript animation library (see also Handling animations). You should also split your JavaScript into multiple files representing critical and non-critical parts. JavaScript modules allow you to do this more efficiently than just using separate external JavaScript files. Then you can optimize these smaller files. Minification reduces the number of characters in your file, thereby reducing the number of bytes or weight of your JavaScript. Gzipping compresses the file further and should be used even if you don't minify your code. Brotli is similar to Gzip, but generally outperforms Gzip compression. You can split and optimize your code manually, but often a module bundler like webpack will do a better job of this.\n\nBefore looking at the tips contained in this section, it is important to talk about where in the process of browser page rendering JavaScript is handled. When a web page is loaded:\n• The HTML is generally parsed first, in the order in which it appears on the page.\n• Whenever CSS is encountered, it is parsed to understand the styles that need to be applied to the page. During this time, linked assets such as images and web fonts start to be fetched.\n• Whenever JavaScript is encountered, the browser parses, evaluates, and runs it against the page.\n• Slightly later on, the browser works out how each HTML element should be styled, given the CSS applied to it.\n• The styled result is then painted to the screen. Note: This is a very simplified account of what happens, but it does give you an idea. The key step here is Step 3. By default, JavaScript parsing and execution are render-blocking. This means that the browser blocks the parsing of any HTML that appears after the JavaScript is encountered, until the script has been handled. As a result, styling and painting are blocked too. This means that you need to think carefully not only about what you are downloading, but also about when and how that code is being executed. The next few sections provide useful techniques for optimizing the parsing and execution of your JavaScript.\n\nLoading critical assets as soon as possible If a script is really important and you are concerned that it is affecting performance by not being loaded quickly enough, you can load it inside the of the document: This works OK, but is render-blocking. A better strategy is to use to create a preloader for critical JavaScript: The preload fetches the JavaScript as soon as possible, without blocking rendering. You can then use it wherever you want in your page: or inside your script, in the case of a JavaScript module: Note: Preloading does not guarantee that the script will be loaded by the time you include it, but it does mean that it will start being downloaded sooner. Render-blocking time will still be shortened, even if it is not completely removed.\n\nOn the other hand, you should aim to defer parsing and execution of non-critical JavaScript to later on, when it is needed. Loading it all up-front blocks rendering unnecessarily. First of all, you can add the attribute to your elements: This causes the script to be fetched in parallel with the DOM parsing, so it will be ready at the same time and won't block rendering. Note: There is another attribute, , which causes the script to be executed after the document has been parsed, but before firing the event. This has a similar effect to . You could also just not load the JavaScript at all until an event occurs when it is needed. This could be done via DOM scripting, for example: const scriptElem = document.createElement(\"script\"); scriptElem.src = \"index.js\"; scriptElem.addEventListener(\"load\", () => { // Run a function contained within index.js once it has definitely loaded init(); }); document.head.append(scriptElem); JavaScript modules can be dynamically loaded using the function: import(\"./modules/myModule.js\").then((module) => { // Do something with the module });\n\nWhen the browser runs your JavaScript, it will organize the script into tasks that are run sequentially, such as making fetch requests, driving user interactions and input through event handlers, running JavaScript-driven animation, and so on. Most of this happens on the main thread, with exceptions including JavaScript that runs in Web Workers. The main thread can run only one task at a time. When a single task takes longer than 50 ms to run, it is classified as a long task. If the user attempts to interact with the page or an important UI update is requested while a long task is running, their experience will be affected. An expected response or visual update will be delayed, resulting in the UI appearing sluggish or unresponsive. To mitigate this issue, you need to break down long tasks into smaller tasks. This gives the browser more chances to perform vital user interaction handling or UI rendering updates — the browser can potentially do them between each smaller task, rather than only before or after the long task. In your JavaScript, you might do this by breaking your code into separate functions. This also makes sense for several other reasons, such as easier maintenance, debugging, and writing tests. However, this kind of structure doesn't help with main thread blocking. Since all the five functions are being run inside one main function, the browser runs them all as a single long task. To handle this, we tend to run a \"yield\" function periodically to get the code to yield to the main thread. This means that our code is split into multiple tasks, between the execution of which the browser is given the opportunity to handle high-priority tasks such as updating the UI. A common pattern for this function uses to postpone execution into a separate task: This can be used inside a task runner pattern like so, to yield to the main thread after each task has been run: async function main() { // Create an array of functions to run const tasks = [a, b, c, d, e]; // Loop over the tasks while (tasks.length > 0) { // Shift the first task off the tasks array const task = tasks.shift(); // Run the task task(); // Yield to the main thread await yield(); } } To improve this further, we can use where available to allow this code to continue executing ahead of other less critical tasks in the queue: function yield() { // Use scheduler.yield() if available if (\"scheduler\" in window && \"yield\" in scheduler) { return scheduler.yield(); } // Fall back to setTimeout: return new Promise((resolve) => { setTimeout(resolve, 0); }); }\n\nAnimations can improve perceived performance, making interfaces feel snappier and making users feel like progress is being made when they are waiting for a page to load (loading spinners, for example). However, larger animations and a higher number of animations will naturally require more processing power to handle, which can degrade performance. The most obvious piece of animation advice is to use less animations — cut out any non-essential animations, or consider giving your users a preference they can set to turn off animations, for example if they are using a low-powered device or a mobile device with limited battery power. For essential DOM animations, you are advised to use CSS animations where possible, rather than JavaScript animations (the Web Animations API provides a way to directly hook into CSS animations using JavaScript). Using the browser to directly perform DOM animations rather than manipulating inline styles using JavaScript is much faster and more efficient. See also CSS performance optimization > Handling animations. For animations that can't be handled in JavaScript, for example, animating an HTML , you are advised to use rather than older options such as . The method is specially designed for handling animation frames efficiently and consistently, for a smooth user experience. The basic pattern looks like this: function loop() { // Clear the canvas before drawing the next frame of the animation ctx.fillStyle = \"rgb(0 0 0 / 25%)\"; ctx.fillRect(0, 0, width, height); // Draw objects on the canvas and update their positioning data // ready for the next frame for (const ball of balls) { ball.draw(); ball.update(); } // Call requestAnimationFrame to run the loop() function again // at the right time to keep the animation smooth requestAnimationFrame(loop); } // Call the loop() function once to set the animation running loop(); You can find a nice introduction to canvas animations at Drawing graphics > Animations, and a more in-depth example at Object building practice. You can also find a full set of canvas tutorials at Canvas tutorial.\n\nEvents can be expensive for the browser to track and handle, especially when you are running an event continuously. For example, you might be tracking the position of the mouse using the event to check whether it is still inside a certain area of the page: function handleMouseMove() { // Do stuff while mouse pointer is inside elem } elem.addEventListener(\"mousemove\", handleMouseMove); You might be running a game in your page. While the mouse is inside the canvas, you will want to constantly check for mouse movement and cursor position and update the game state — including the score, the time, the position of all the sprites, collision detection information, etc. Once the game is over, you will no longer need to do all that, and in fact, it will be a waste of processing power to keeping listening for that event. It is, therefore, a good idea to remove event listeners that are no longer needed. This can be done using : Another tip is to use event delegation wherever possible. When you have some code to run in response to a user interacting with any one of a large number of child elements, you can set an event listener on their parent. Events fired on any child element will bubble up to their parent, so you don't need to set the event listener on each child individually. Less event listeners to keep track of means better performance. See Event delegation for more details and a useful example.\n\nThere are several general best practices that will make your code run more efficiently.\n• Reduce DOM manipulation: Accessing and updating the DOM is computationally expensive, so you should minimize the amount that your JavaScript does, especially when performing constant DOM animation (see Handling JavaScript animations above).\n• Batch DOM changes: For essential DOM changes, you should batch them into groups that get done together, rather than just firing off each individual change as it occurs. This can reduce the amount of work the browser is doing in real terms, but also improve perceived performance. It can make the UI look smoother to get several updates out of the way in one go, rather than constantly making small updates. A useful tip here is — when you have a large chunk of HTML to add to the page, build the entire fragment first (typically inside a ) and then append it all to the DOM in one go, rather than appending each item separately.\n• Simplify your HTML: The simpler your DOM tree is, the faster it can be accessed and manipulated with JavaScript. Think carefully about what your UI needs, and remove unnecessary cruft.\n• Reduce the amount of looped code: Loops are expensive, so reduce the amount of loop usage in your code wherever possible. In cases where loops are unavoidable:\n• Avoid running the full loop when it is unnecessary, using or statements as appropriate. For example, if you are searching arrays for a specific name, you should break out of the loop once the name is found; there is no need to run further loop iterations: function processGroup(array) { const toFind = \"Bob\"; for (let i = 0; i < array.length - 1; i++) { if (array[i] === toFind) { processMatchingArray(array); break; } } }\n• Do work that is only needed once outside the loop. This may sound a bit obvious, but it is easy to overlook. Take the following snippet, which fetches a JSON object containing data to be processed in some way. In this case the operation is being done on every iteration of the loop, which is a waste of computing power. The fetching, which does not depend on , could be moved outside the loop, so it is only done once.\n• Run computation off the main thread: Earlier on we talked about how JavaScript generally runs tasks on the main thread, and how long operations can block the main thread, potentially leading to bad UI performance. We also showed how to break long tasks up into smaller tasks, mitigating this problem. Another way to handle such problems is to move tasks off the main thread altogether. There are a few ways to achieve this:\n• Use asynchronous code: Asynchronous JavaScript is basically JavaScript that does not block the main thread. Asynchronous APIs tend to handle operations such as fetching resources from the network, accessing a file on the local file system, or opening a stream to a user's web cam. Because those operations could take a long time, it would be bad to just block the main thread while we wait for them to complete. Instead, the browser executes those functions, keeps the main thread running subsequent code, and those functions will return results once they are available at some point in the future. Modern asynchronous APIs are -based, which is a JavaScript language feature designed for handling asynchronous operations. It is possible to write your own Promise-based functions if you have functionality that would benefit from being run asynchronously.\n• Run computation in web workers: Web Workers are a mechanism allowing you to open a separate thread to run a chunk of JavaScript in, so that it won't block the main thread. Workers do have some major restrictions, the biggest being that you can't do any DOM scripting inside a worker. You can do most other things, and workers can send and receive messages to and from the main thread. The main use case for workers is if you have a lot of computation to do, and you don't want it to block the main thread. Do that computation in a worker, wait for the result, and send it back to the main thread when it is ready.\n• Use WebGPU: WebGPU is a browser API that allows web developers to use the underlying system's GPU (Graphics Processing Unit) to carry out high-performance computations and draw complex images that can be rendered in the browser. It is fairly complex, but it can provide even better performance benefits than web workers."
    },
    {
        "link": "https://reddit.com/r/gamedev/comments/tg9ffl/how_do_you_manage_game_state_for_browserbased",
        "document": "I'm building a top down 2D Pokémon red-like rpg with JS (typescript to be more precise) and canvas. I'm not using any external libraries (yet) because I'm really trying to learn how to use JS/canvas in an advanced way. (Eventually I'll probably add in a library like phaser). Plus I'm a front-end dev so JS is my bread and butter.\n\nThis game is purely for fun and learning. One thing I'm struggling with is how to manage game state. Should I use a static class for this? A redux-like library? A utility object? Any tips? Is there a pattern I can implement for global state? A react-like consumer/provider pattern could be cool but I have no idea if this is necessary or how to implement this pattern outside of the react ecosystem.\n\nOverall, the game is data-driven (all game data is stored in JSON) and built with JS classes."
    },
    {
        "link": "https://reddit.com/r/incremental_games/comments/mwx2xd/performance_tips_for_javascript_game_developers",
        "document": "This post originally started out as a comment to this thread, but the content ended up being too large to post as a comment, so I decided to post it as it's own thread.\n\nThis post details all of the performance tips I've been exposed to over my years as a software developer working primarily in JavaScript and on the web.\n\nI'll just get straight into it...\n\nThis is a very low-hanging fruit with a low impact. It doesn't do much when you have just a few elements, but it makes a noticeable difference when there are 1000s of elements on the page.\n\nDo this instead:\n\nWhen you use code like the following, you are checking the entire document for a particular element.\n\nIf you are looking for an element that you know is inside another element, and you already have that element's reference cached somewhere, you can limit the amount of elements the browser needs to compare to your query to just those elements inside the parent, like so:\n\nIf you do not have a parent element reference, but you do know that the element you're looking for is at the same level of heirarchy as another element which you do have a reference for, then you can jump up a level to the common parent like so:\n\nAnimation frames are generally far more performant than timers that simulate repaints.\n\nDon't do this (this supposedly runs 60 frames per second):\n\nDo this instead:\n\nThis has the added benefit of running at a guaranteed 60+ fps. Higher monitor refreshrates actually run this at a higher frame rate, for example my ASUS VG248QE will run this game loop at 144 fps. Just bare in mind that in order to save system resources, browsers will \"pause\" the execution of an animation frame if focus is lost. This can happen when the user tabs out, minimizes the window or idles for a few minutes. Be sure to accommodate this behavior in your calculations, for example you might want to check how much time has passed since the last \"tick\" on each new \"tick\", and calculate your player's profits based on that.\n\nDo not rely on time calculations derived from the `Date` object\n\nThere is a far more precise time API accurate down to microseconds - look at Performance.now().\n\nDo this instead:\n\nOr better yet, use the timestamp passed to the callback - it is the same high-precision time object type as `()`, but the origin of the time starts when rAF first begins executing callbacks:\n\nOf course, if you actually need to use dates - for example calculating per day numbers or just rendering a calendar or whatever, then by all means use the Date object.\n\nYou won't know when performance tanks if you don't know what numbers to reasonably expect. Most browser developer consoles have a function to show an FPS counter on the page. In Chrome, it's in developer tools -> command palette (ctrl+p on win, cmd+p on mac) -> show frames. This will show you frames per second rendering for the entire page, but if you want to measure the FPS of a single game loop, say, for a single canvas element, then you can derive that from the parameter:\n\nLet's say you encounter a performance issue. How do you begin to analyze it, find out where it's coming from, all that nonsense? It's not as simple as looking at your game and thinking, \"Well, it happened when I jumped, so obviously it's my jump code.\"\n\nWhat you can do instead, is record a performance profile. You can then generate a heapmap from that profile, and jump into the callstack to see exactly how many milliseconds were spent running particular functions and methods.\n\nHow is this done?\n\nIt's quite an involved process, with far too much information for me to condense into a section of a Reddit comment/post, so unfortunately you will have to click on a link for this one. Here you go: https://blog.appsignal.com/2020/02/20/effective-profiling-in-google-chrome.html\n\nExecute DOM Reads and Writes in different phases\n\nDid you know that most browsers optimise for the case when reads and writes exist in separate animation frames/phases? Let me demonstrate.\n\nTake this code, for example.\n\nThis code will cause a few repaints in the browser, because all of the reads and writes happen in an interleaved manner. If we \"schedule\" our reads and writes into separate animation frames, we can basically achieve the same amount of rendering with much fewer repaints - which is done (in concept) like so:\n\nOf course, this would become a pain to maintain, so we could write a scheduler that basically turns every DOM access task into an asynchronous one, by queing read and write tasks separately and flushing the queues periodically - this way the reads and writes are executed in ordered batches:\n\nJust note that the above calls to and are asynchronous - regular DOM reads and writes are synchronous, so these will not behave as you might expect. If you want to make it a little easier, you can extend it into a promisified version:\n\nFor more information on how and why this works, and a more robust and complete implementation, check out the FastDom library: https://github.com/wilsonpage/fastdom - note that you might not need this particular optimization if you're using a rendering framework, which should already be doing these sorts of optimisations for you.\n\nTry to look for areas in your code where you make use of asynchronous methods, especially if those areas deal with fetching remote resources in a serial manner.\n\nFor example, here is some code to load different sound effects into an AudioContext:\n\nThere is a problem with this code. It will load each sound asset one by one, one after the other. None of the sounds depend on one another in order to load, and we can take advantage of this to gain a substantial performance boost.\n\nInstead of loading one sound at a time, we can load them simultaneously using .\n\nDo not create too many event listeners\n\nThis is another one of those \"don't bother if you're using a framework\" tips, as a good framework should already be doing this for you. However, if you're not using a framework, then adding a bunch of event listeners to your game can cause quite a lot of cascading performance bottlenecks.\n\nTake this code for example, which adds three event listeners - one for a click on three different buttons.\n\nAt first glance, this code looks fine. Nothing's really wrong with it, aside from the fact that there are three separate functions taking up memory, which isn't a big deal.\n\nWhat if we introduce more buttons, though? Well, we will want to make maintenance easier on us, so...\n\n...and this code works, nicely. Except now 3 months have passed and there are now 400 buttons in our game, each with their own event listener, and this starts becoming an issue. First off, now we have to move the function out of the loop, so we aren't creating new instances of it on each iteration:\n\nThis is an improvement, but we still have 400 event listeners. We could do things like check if the buttons are actually actively displayed in our game, and conditionally apply the event listeners, that's one possible optimisation, but I won't get into that. It's just more branching complexity.\n\nA couple of weeks pass, and we add a feature that lets a user add their own buttons. And we somehow forget to update the button code and for some reason any button the user adds doesn't register any clicks - this is because we're only iterating over the buttons that already existed when we registered the event listeners. So, we have to make sure that new buttons get their event listeners somehow... I won't get into this either.\n\nAs you can see, this is spiralling out of control. How do we fix it? The answer is to just register one event listener for a click on the entire document, and check the event target to see if it's something we should be interested in.\n\nHow many event listeners is this? Just one. Not two, not 400, but one.\n\nWill this event listener respond to elements created as a result of user input? Yes, yes it will.\n\nIt even lets us listen for clicks on things other than buttons!\n\nTake advantage of CSS animations and their ability to utilize hardware acceleration\n\nAnimating with JS is nice, you can get a lot of precise control that you can't get with CSS. But for simple animations like fades, color changes, etc. it's better to use CSS.\n\nBecause CSS animations can take advantage of GPU acceleration. When you use properties like , , , , etc in your animations, CSS will shift the painting of those animations from the CPU over to the GPU. This is something that is not really possible in JS (unless you use something like GPU.js, but a whole dependency just for some silly animations? kek)\n\nPlus, not only do you get GPU acceleration, but you can simplify your code as well. Instead of slowly incrementing/decrementing an opacity value over time via JS, you can just toggle a class on activation/deactivation. Simple. Easy. You can even bind it to your state.\n\nAlthough a bit outdated, this article gives a good outline of this concept: https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/\n\nMost games are full of static resources like images, sprite sheets, audio files, fonts, etc. These are all assets that need to be sent to the browser over the network.\n\nIf the player lacks an internet connection, some of these assets may be broken.\n\nOne can cache these assets in the browser so that they load even while the user is offline, and this has the added benefit of decreasing loading times for these assets.\n\nThis used to be done via the HTML5 ApplicationCache, which has been deprecated in favor of the Cache API, which requires Service Workers. Thankfully, the Cache API is currently supported in all modern browsers.\n\nHere is a tutorial on how to get started with the Cache API: https://web.dev/cache-api-quick-guide/\n\nUtilize Web Workers to offload heavy computations to another thread\n\nWeb Workers can do quite a lot for gains in performance. Think of web workers as threads, but in the browser.\n\nAny JS script can spawn a new web worker that it has exclusive access to, or a shared worker that other scripts can share access to.\n\nWeb workers are an isolated execution context that executes code in a limited environment - they have access to a number of APIs, but do not have access to the DOM.\n\nThey are also very easy to use. You simply pass messages around and react to messages to communicate between your workers and your main script, like so:\n\nNote that in the worker, and aren't attached to anything, since the worker itself is basically the global scope.\n\nOf course, using a whole thread for something as simple as an incrementing counter is a little bit overkill, but it makes a big difference when you have expensive math calculations to perform and you can perform them on a separate thread.\n\nOffloading computationally expensive code like this to a separate thread allows you to keep your main thread for just rendering purposes, keeping your user interface snappy and performant.\n\nSee more information here: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers\n\nDon't act on entities the player cannot see\n\nIf you have objects that are out-of-view, (whether a spaceship in a game off to the side of the screen or a resource counter hidden behind a tab in a component), do not bother updating their views. They might exist in the document at the time that the player is playing a game, but just because they exist in the document, that doesn't mean the player can actually see them.\n\nPerforming calculations to update all of these hidden things could cost quite a bit of resources and cause a number of unnecessary browser repaints.\n\nInstead, simply ignore them. Be sure to keep your game's state updated, and only update these elements or objects with their new state when they come back into view.\n\nYou can use the IntersectionObserver API to detect if document elements are currently in view. For canvas objects, just check if their x and y coordinates exceed the canvas width / height or are less than 0.\n\nUsing the IntersectionObserver API is nice, but if you can get away with not using it, even better. It is less necessary if you derive your view from your state and only render elements/objects if the state requires that they be rendered.\n\nIf your game has complex objects that have their own \"intelligence\" and produce events on their own, you still don't need to update their views if they exist off screen. Simply attach these objects to a State Machine and update the state machine instead. If their state requires that they be rendered (for example a sheep has walked within view of the player), then by all means, render it.\n\nReduce the number of logical branching pathes via polymorphism\n\nIn programming, we make use of all sorts of syntax constructs, like conditional statements, ternary operators, functions, loops, binary / logical operators, etc.\n\nSome of these constructs result in what we call \"logical branches\". A logical branch is essentially a point during a program's execution where the program must inspect some state and then choose between two or more \"paths\" of execution. These are found typically in conditional statements:\n\nWhen the interpreter (or compiler) comes to these sections of code, it performs a little calculation to determine where in the code to go next. Though almost entirely negligible, this little calculation does take a little bit of time, and in larger more complex programs, with many potential users, this time can add up.\n\nThere is a concept known as a \"polymorphism\" in functional programming, where we can take advantage of the type to remove some of this branching complexity.\n\nTake a Result union type, for example. It can be one of two possible unions:\n\nWe have both a and a type, that both belong to the same union - . If we get a and want to act upon it (for example, transform it's value), we first have to inspect which of the two types we're working with. Let's do that with a simple utility:\n\nThis utility could be used in many places in our projects, and each time we use it, we are creating a branching path.\n\nThere's an optimization we can make here, to remove this branching, via a polymorphism of the utility on each type. All we have to do is adjust the implementations of our types to implement this interface:\n\nNow, we just adjust our utility to call this interface:\n\nThus, we can use our utility, and it won't ever create any logical branches. It just defers to the interface of the type.\n\nOf course, this can be achieved without using union types. A realistic example would be an event handler that responds to different actions, or anywhere a switch case might be used. let's say we have an event handler that receives a message object, and we do different things according to the message's property (much like we would do in Redux or in our button event handler we saw earlier).\n\nNormally we would inspect this property via a switch/case statement, which could have many potential logical branches (based on how many different types we have), but instead of doing that, we could simply use a dictionary:\n\nAs you can see, there are no logical branches in this code, yet we are still able to perform different functions based on different inputs. This scales to however many different types our message handler deals with.\n\nOf course, care needs to be taken here. There are certainly cases where deferring logic to a function via polymorphism could in fact be more computationally expensive than just checking a condition, depending on what the function is doing and how computationally expensive it is to call. Be sure to routinely profile your code to be sure you're seeing improvements. Don't just optimise for the sake of it.\n\nAs your idea develops more and fleshes itself out, you might add a lot of code for lots of different parts of your game. You might start seeing areas where code performs calculations that are not strictly necessary.\n\nSince we're in a game sub, I will give a perfect game-related example: collision detection.\n\nLet's assume we have a bunch of objects on our game's canvas, and we want to check if two objects are colliding:\n\nThis code is straightforward, and it works. We loop through each game object, reset it's collision status to false, then loop through each game object again to check if our current object from the outer loop is colliding with an object in the inner loop. We be sure to ignore the case where both the inner and outer objects reference the same object, because we know that an object will always be colliding with itself.\n\nHowever, there is a major issue here. If we've checked if an object is colliding, we don't need to check it again, because we know it's colliding already, so we can actually start our collision check with only the remaining objects:\n\nThis is already much better, we're not performing any unnecessary calculations anymore, but there's still one more optimisation we can make. We know that the index references the current object, which means that the first object that is inspected in our inner loop corresponds to the object in our outer loop - so we can simply shift the index by 1 to ignore it, and remove our conditional branch that deals with ignoring the case where both objects reference the same thing:\n\nNow, our code for doing collision detection doesn't perform any unnecessary checks. Since collision detection is quite a computationally heavy task, especially if there are hundreds our thousands of objects in our game, this little optimisation could have saved us potentially a lot of execution time.\n\nThere's actually more optimisations we can make here - we don't exactly need to check every object in our game for collisions, like this code is doing.\n\nFor a simple 2D game, we could divide the \"game world\" into a grid of tiles, and only check the objects that exist in the same tile as the object that we're currently inspecting.\n\nFor a 3D game, we could use an algorithm that puts the entire game world into a giant invisible cube, then divides that cube into 8 smaller invisible cubes, and each of those cubes into 8 smaller invisible cubes, etc. Then we can take an object, find out which \"cube\" it is in by checking it's coordinates against the coordinates of the lowest level of cubes - if it exists inside two cubes simultaneously, then we move \"up\" a level to get a bigger cube - and only check for collisions on objects that exist inside the same cube.\n\nWe could also adjust our collision detection function to check a boxed area around the object we're checking (known as a \"hitbox\"), so we don't match on each and every pixel.\n\nThis is an involved example, but this sort of problem arises almost anywhere in a program, not just in things like collision detection, so you should definitely keep an eye out for optimisations you can make that reduce unnecessary computations, as these optimisations will generally net you the most performance gains.\n\nHopefully all of these tips are useful to some of you, as this post took me a lot longer to write than I thought it would 😅."
    },
    {
        "link": "https://najm-eddine-zaga.medium.com/top-javascript-best-practices-cf897022b6fd",
        "document": "In JavaScript, using new Object is a bit risky, while using primitives always better for several reasons. Let’s dig deeper into this. The for example, creates a string primitive as we all know, on the other hand… creates a string object. As they are more complex and have methods, string object can bring unexpected behavior, precisely when it comes to comparisons and type coercion. Primitives are simpler in usage and more straightforward, as their usage avoids unnecessary complexity, and the code become easy to read and maintain. Primitives are more efficient in terms of memory and performance. While creating an object involves additional overhead. Since JavaScript treats objects and primitives differently, using can lead to confusing situations where you’re unintentionally dealing with an object instead of a primitive, which might take you to a nest of bugs. In most cases, it’s better to use primitives instead. // ❌ Avoid\n\nconst str = new String();\n\nconst num = new Number();\n\nconst bool = new Boolean();\n\nconst obj = new Object();\n\nconst arr = new Array();\n\nconst regEx = new RegExp();\n\nconst func = new Function();\n\n\n\n// ✅ Use\n\nconst str = \"JavaScript\";\n\nconst num = 10;\n\nconst bool = true;\n\nconst obj = {};\n\nconst arr = [];\n\nconst regEx = /()/;\n\nconst func = function() {};\n\n2 — Avoid using let with arrays and objects First of all, let’s be clear… Using with arrays and objects is not inherently problematic at all. But there are some specific considerations that might lead you to avoid it in certain cases: As we all know, allows us to reassign the variable itself, which can lead to confusion or data loss. An object / array can be reassigned by accident with an entire new set of data (new object / new array). Using instead makes it safer and clear that the reference to the object / array won’t change, but you can still modify it’s content. Using , you signal to other developers you work with that the variable should not be reassigned, enhancing code readability and maintainability. While has a block scope, it can lead to unexpected behavior in loops or conditional statements. By using , the variable remains in scope without the risk of unintentional reassignment. Many coding standards and best practices encourage using for variables that don’t need reassignment, promoting cleaner and more predictable code. // ❌ Avoid\n\nlet book = { title: \"Inferno\", author: \"Dan Brown\" };\n\n\n\n// The book object will be overrode with string\n\nbook = \"Hello world\"; // ✅ Use\n\nconst book = { title: \"Inferno\", author: \"Dan Brown\" };\n\n\n\n// The book object cannot be overrode\n\nbook = \"Hello world\";\n\nand are comparison operators used to compare values, but they behave differently. When using , JavaScript converts the values to a common type before making the comparison console.log(5 == '5'); // true (number is converted to string)\n\nconsole.log(null == undefined); // true (considered equal)\n\nconsole.log(0 == false); // true (0 is converted to boolean as it's falsy value) With , the comparison checks both the value and the type. If types are different, it returns console.log(5 === '5'); // false (different types)\n\nconsole.log(null === undefined); // false (different types)\n\nconsole.log(0 === false); // false (different types) When to Use ? Use when you want to ensure both value and type are the same, which is generally a good practice to avoid unexpected results. Use if you specifically need to compare values without considering their types, but this can lead to bugs and usually discouraged. In general, consider using for more predictable and clear comparisons. Note: Same thing goes with and\n\nIn JavaScript, using destructuring technique with Objects and Arrays gives you several benefits. The destructuring assignment syntax is a JavaScript expression that makes it possible to unpack values from arrays, or properties from objects, into distinct variables. As MDN web docs says. It allows you to extract multiple properties from an object or elements from an array in a single statement, reducing the amount of code you need to write. const book = { name: 'The Lost Symbol', author: 'Dan Brown' };\n\nconst { name, price } = book; // concise extraction Destructuring can make your code more readable by clearly showing which properties or elements you are working with. You can easily assign default values if the property or element doesn’t exist. const { height = 180 } = person; // uses default value if height is undefined You can destructure nested objects or arrays, which can simplify accessing deeply nested data. const user = { profile: { name: 'Eren Yeager', age: 20 } };\n\nconst { profile: { name } } = user; // easy access to nested properties It can be useful for function parameters, allowing you to unpack values directly. Destructuring helps streamline your code, making it cleaner and easier to maintain.\n\nThe DRY (Don’t Repeat Yourself) principle is a key concept in software development aimed at reducing repetition in code. By ensuring that every piece of knowledge or logic is represented in a single place, you make your code easier to maintain, understand, and refactor. Encapsulate repetitive logic in functions. This way, you can reuse the same code without duplication. function calculateArea(width, height) {\n\n return width * height;\n\n}\n\n\n\n// Use the function instead of repeating the code\n\nconst area1 = calculateArea(5, 10);\n\nconst area2 = calculateArea(7, 3); Use modules to organize your code. This helps keep related functions and variables together, making them reusable across different parts of your application. Utilize classes or objects to group related data and behaviors. This encapsulation helps avoid repetition when working with similar data structures. Note: If you’re adopting the “Functional Programming” paradigm in your daily coding, consider using any other tip but this one “Classes and Objects”. In web development, use templates or components (in frameworks like React, Vue, etc.) to encapsulate UI logic and styles that are reused. Use arrays or objects to store related data rather than creating separate variables for each piece of data. const members = [\n\n { name: 'Feitan Portor', nen: \"Transmutation\" },\n\n { name: 'Nobonaga Hazama', nen: \"Enhancement\"},\n\n];\n\n\n\n// Iterate over users without repeating code\n\nmembers.forEach(member => console.log(member.name)); Use configuration objects to pass parameters to functions or classes instead of having multiple parameters. function addMember({ name, nen }) {\n\n return { name, nen };\n\n}\n\n\n\nconst member = addMember({ name: 'Illumi Zoldyck', nen: \"Manipulation\" }); Applying the DRY principle leads to cleaner, more maintainable code. It helps minimize the risk of bugs since changes need to be made in only one place, and it enhances readability by reducing clutter. Remember that while it’s important to avoid repetition, there’s a balance to strike; over-abstracting can lead to complexity, so use your judgment when applying these principles.\n\nUsing meaningful variable and function names is crucial for writing clear, maintainable, and understandable code. Choose names that clearly describe the purpose or value of the variable or function. // ❌ Bad\n\nlet x = 10; // What does x represent?\n\n\n\n// ✅ Good\n\nlet itemCount = 10; // Clearly indicates it's a count of items. Start functions with a verb that describes the action being performed. While short names might seem convenient, they can lead to confusion. Avoid abbreviations unless they are widely understood. // ❌ Bad\n\nlet amt = 50; // What does amt mean?\n\n\n\n// ✅ Good\n\nlet amount = 50; // Clear and understandable. Stick to a consistent naming convention throughout your codebase, such as camelCase for variables and functions, and PascalCase for classes. Indicate Data Type or Purpose in Names If a variable holds a specific type of data or serves a particular purpose, include that in the name. // ❌ Bad\n\nlet data = []; // What kind of data?\n\n\n\n// ✅ Good\n\nlet userProfiles = []; // Indicates it's an array of user profiles. Consider the context in which the variable or function will be used to make names more meaningful. // ❌ Bad\n\nlet list = []; // Vague\n\n\n\n// ✅ Good\n\nlet todoList = []; // Clearly indicates it's for to-do items. Keep It Concise but Clear While names should be descriptive, they shouldn’t be excessively long. Aim for a balance between clarity and brevity. If you’re working in a specific domain (like finance, healthcare, etc.), use terms that are familiar to that domain. let interestRate = 5.5; // Clear in a financial context. If you find that a name is no longer suitable as the code evolves, don’t hesitate to refactor it for better clarity. let temp = 30; // After some time, this name may become unclear.\n\nlet roomTemperature = 30; // After refactor... More descriptive. Meaningful variable and function names significantly enhance code readability and maintainability. They help others (and yourself) understand the purpose and function of your code at a glance, making collaboration and debugging much easier. Always strive for clarity in your naming conventions.\n\nAvoiding global variables is a key practice in JavaScript (and programming in general) to maintain clean, modular, and maintainable code. Global variables can lead to unexpected behavior, naming conflicts, and difficulty in debugging. Declare variables within functions to limit their scope and prevent them from being accessible globally. Use Block Scope with and Utilize and to declare variables within blocks (like loops or conditionals), ensuring they are not accessible outside that block. for (let i = 0; i < 10; i++) {\n\n let square = i * i; // `square` is block-scoped\n\n console.log(square);\n\n}\n\n// console.log(square); // ReferenceError: square is not defined Organize your code into modules. Use ES6 modules or IIFE (Immediately Invoked Function Expressions) to encapsulate variables. Group related variables and functions within an object to avoid polluting the global scope. If you need to persist data, consider using local storage, session storage, or indexedDB instead of global variables. Limit the Use of Globals If you must use global variables, limit their use to configuration constants or application-wide settings. Name them clearly to indicate their global nature. const APP_VERSION = \"1.0.0\"; // A constant that might be needed globally When designing functions, avoid modifying global variables. This keeps functions predictable and easier to test. let counter = 0;\n\n\n\nfunction incrementCounter() {\n\n return ++counter; // Avoid this! Instead, return a new value.\n\n} In object-oriented programming, use to manage state within instances instead of relying on global variables. By avoiding global variables, you enhance the modularity and maintainability of your code. It helps prevent naming conflicts and unintended side effects, making your code more predictable and easier to work with. Following these best practices will lead to cleaner and more manageable codebases.\n\nDocumenting your code is essential for maintaining clarity, aiding collaboration, and ensuring long-term maintainability.\n• Explain “Why,” Not “What”: Focus on explaining why you did something rather than what the code does. The code itself should be readable enough to convey what it does. // ❌ Bad: This doesn't provide much context\n\nlet x = 10; // Assigns 10 to x\n\n\n\n// ✅ Good: Explains the purpose\n\nlet maxRetries = 10; // Maximum number of attempts for the API call\n• Comment Complex Logic: For complex or non-obvious sections of code, provide detailed explanations. // Check if user has the necessary permissions to access the resource\n\nif (user.role === 'admin' || user.permissions.includes('access_resource')) {\n\n // Proceed with the operation\n\n} In JavaScript, especially when using JSDoc, you can document functions, classes, and methods using structured comments. /**\n\n * Calculates the total price including tax.\n\n * @param {number} price - The original price of the item.\n\n * @param {number} tax - The tax rate as a decimal.\n\n * @returns {number} The total price after tax.\n\n */\n\nfunction calculateTotal(price, tax) {\n\n return price + (price * tax);\n\n} For libraries or modules, provide clear documentation for public APIs, including parameters, return values, and usage examples. /**\n\n * Fetches user data from the server.\n\n * @async\n\n * @param {string} userId - The ID of the user to fetch.\n\n * @returns {Promise<Object>} A promise that resolves to the user data.\n\n * @throws {Error} Throws an error if the fetch fails.\n\n */\n\nasync function fetchUserData(userId) {\n\n const response = await fetch(`/api/users/${userId}`);\n\n if (!response.ok) {\n\n throw new Error('Failed to fetch user data');\n\n }\n\n return response.json();\n\n} For projects, maintain a file that provides an overview, installation instructions, usage examples, and contribution guidelines. Effective documentation makes your code more understandable and maintainable, helping both current and future developers (including yourself) work efficiently. By incorporating these practices into your development workflow, you’ll foster better collaboration and reduce the learning curve for anyone interacting with your code."
    }
]