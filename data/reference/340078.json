[
    {
        "link": "https://doc.qt.io/qt-6/qtnetwork-programming.html",
        "document": "The Qt Network module offers classes that allow you to write TCP/IP clients and servers. It offers lower-level classes such as QTcpSocket, QTcpServer and QUdpSocket that represent low level network concepts, and high level classes such as QNetworkRequest, QNetworkReply and QNetworkAccessManager to perform network operations using common protocols.\n\nThe Qt Network C++ Classes page contains a list of the C++ classes in Qt Network.\n\nThe Network Access API is a collection of classes for performing common network operations. The API provides an abstraction layer over the specific operations and protocols used (for example, getting and posting data over HTTP), and only exposes classes, functions, and signals for general or high level concepts.\n\nNetwork requests are represented by the QNetworkRequest class, which also acts as a general container for information associated with a request, such as any header information and the encryption used. The URL specified when a request object is constructed determines the protocol used for a request. Currently HTTP and local file URLs are supported for uploading and downloading.\n\nThe coordination of network operations is performed by the QNetworkAccessManager class. Once a request has been created, this class is used to dispatch it and emit signals to report on its progress. The manager also coordinates the use of cookies to store data on the client, authentication requests, and the use of proxies.\n\nReplies to network requests are represented by the QNetworkReply class; these are created by QNetworkAccessManager when a request is dispatched. The signals provided by QNetworkReply can be used to monitor each reply individually, or developers may choose to use the manager's signals for this purpose instead and discard references to replies. Since QNetworkReply is a subclass of QIODevice, replies can be handled synchronously or asynchronously; i.e., as blocking or non-blocking operations.\n\nEach application or library can create one or more instances of QNetworkAccessManager to handle network communication.\n\nUsing TCP with QTcpSocket and QTcpServer\n\nTCP (Transmission Control Protocol) is a low-level network protocol used by most Internet protocols, including HTTP and FTP, for data transfer. It is a reliable, stream-oriented, connection-oriented transport protocol. It is particularly well suited to the continuous transmission of data.\n\nThe QTcpSocket class provides an interface for TCP. You can use QTcpSocket to implement standard network protocols such as POP3, SMTP, and NNTP, as well as custom protocols.\n\nA TCP connection must be established to a remote host and port before any data transfer can begin. Once the connection has been established, the IP address and port of the peer are available through QTcpSocket::peerAddress() and QTcpSocket::peerPort(). At any time, the peer can close the connection, and data transfer will then stop immediately.\n\nQTcpSocket works asynchronously and emits signals to report status changes and errors, just like QNetworkAccessManager. It relies on the event loop to detect incoming data and to automatically flush outgoing data. You can write data to the socket using QTcpSocket::write(), and read data using QTcpSocket::read(). QTcpSocket represents two independent streams of data: one for reading and one for writing.\n\nSince QTcpSocket inherits QIODevice, you can use it with QTextStream and QDataStream. When reading from a QTcpSocket, you must make sure that enough data is available by calling QTcpSocket::bytesAvailable() beforehand.\n\nIf you need to handle incoming TCP connections (e.g., in a server application), use the QTcpServer class. Call QTcpServer::listen() to set up the server, and connect to the QTcpServer::newConnection() signal, which is emitted once for every client that connects. In your slot, call QTcpServer::nextPendingConnection() to accept the connection and use the returned QTcpSocket to communicate with the client.\n\nAlthough most of its functions work asynchronously, it's possible to use QTcpSocket synchronously (i.e., blocking). To get blocking behavior, call QTcpSocket's waitFor...() functions; these suspend the calling thread until a signal has been emitted. For example, after calling the non-blocking QTcpSocket::connectToHost() function, call QTcpSocket::waitForConnected() to block the thread until the connected() signal has been emitted.\n\nSynchronous sockets often lead to code with a simpler flow of control. The main disadvantage of the waitFor...() approach is that events won't be processed while a waitFor...() function is blocking. If used in the GUI thread, this might freeze the application's user interface. For this reason, we recommend that you use synchronous sockets only in non-GUI threads. When used synchronously, QTcpSocket doesn't require an event loop.\n\nThe Fortune Client and Fortune Server examples show how to use QTcpSocket and QTcpServer to write TCP client-server applications. See also Blocking Fortune Client for an example on how to use a synchronous QTcpSocket in a separate thread (without using an event loop), and Threaded Fortune Server for an example of a multithreaded TCP server with one thread per active client.\n\nUDP (User Datagram Protocol) is a lightweight, unreliable, datagram-oriented, connectionless protocol. It can be used when reliability isn't important. For example, a server that reports the time of day could choose UDP. If a datagram with the time of day is lost, the client can simply make another request.\n\nThe QUdpSocket class allows you to send and receive UDP datagrams. It inherits QAbstractSocket, and it therefore shares most of QTcpSocket's interface. The main difference is that QUdpSocket transfers data as datagrams instead of as a continuous stream of data. In short, a datagram is a data packet of limited size (normally smaller than 512 bytes), containing the IP address and port of the datagram's sender and receiver in addition to the data being transferred.\n\nQUdpSocket supports IPv4 broadcasting. Broadcasting is often used to implement network discovery protocols, such as finding which host on the network has the most free hard disk space. One host broadcasts a datagram to the network that all other hosts receive. Each host that receives a request then sends a reply back to the sender with its current amount of free disk space. The originator waits until it has received replies from all hosts, and can then choose the server with most free space to store data. To broadcast a datagram, simply send it to the special address QHostAddress::Broadcast (255.255.255.255), or to your local network's broadcast address.\n\nQUdpSocket::bind() prepares the socket for accepting incoming datagrams, much like QTcpServer::listen() for TCP servers. Whenever one or more datagrams arrive, QUdpSocket emits the readyRead() signal. Call QUdpSocket::readDatagram() to read the datagram.\n\nThe Broadcast Sender and Broadcast Receiver examples show how to write a UDP sender and a UDP receiver using Qt.\n\nQUdpSocket also supports multicasting. The Multicast Sender and Multicast Receiver examples show how to use write UDP multicast clients.\n\nBefore establishing a network connection, QTcpSocket and QUdpSocket perform a name lookup, translating the host name you're connecting to into an IP address. This operation is usually performed using the DNS (Domain Name Service) protocol.\n\nQHostInfo provides a static function that lets you perform such a lookup yourself. By calling QHostInfo::lookupHost() with a host name, a QObject pointer, and a slot signature, QHostInfo will perform the name lookup and invoke the given slot when the results are ready. The actual lookup is done in a separate thread, making use of the operating system's own methods for performing name lookups.\n\nQHostInfo also provides a static function called QHostInfo::fromName() that takes the host name as argument and returns the results. In this case, the name lookup is performed in the same thread as the caller. This overload is useful for non-GUI applications or for doing name lookups in a separate, non-GUI thread. (Calling this function in a GUI thread may cause your user interface to freeze while the function blocks as it performs the lookup.)\n\nNetwork communication with Qt can be performed through proxies, which direct or filter network traffic between local and remote connections.\n\nIndividual proxies are represented by the QNetworkProxy class, which is used to describe and configure the connection to a proxy. Proxy types which operate on different levels of network communication are supported, with SOCKS 5 support allowing proxying of network traffic at a low level, and HTTP and FTP proxying working at the protocol level. See QNetworkProxy::ProxyType for more information.\n\nProxying can be enabled on a per-socket basis or for all network communication in an application. A newly opened socket can be made to use a proxy by calling its QAbstractSocket::setProxy() function before it is connected. Application-wide proxying can be enabled for all subsequent socket connections through the use of the QNetworkProxy::setApplicationProxy() function.\n\nProxy factories are used to create policies for proxy use. QNetworkProxyFactory supplies proxies based on queries for specific proxy types. The queries themselves are encoded in QNetworkProxyQuery objects which enable proxies to be selected based on key criteria, such as the purpose of the proxy (TCP, UDP, TCP server, URL request), local port, remote host and port, and the protocol in use (HTTP, FTP, etc.).\n\nQNetworkProxyFactory::proxyForQuery() is used to query the factory directly. An application-wide policy for proxying can be implemented by passing a factory to QNetworkProxyFactory::setApplicationProxyFactory() and a custom proxying policy can be created by subclassing QNetworkProxyFactory; see the class documentation for details."
    },
    {
        "link": "https://doc.qt.io/qt-6/qtcpsocket.html",
        "document": "The QTcpSocket class provides a TCP socket. More...\n\nNote: All functions in this class are reentrant.\n\nTCP (Transmission Control Protocol) is a reliable, stream-oriented, connection-oriented transport protocol. It is especially well suited for continuous transmission of data.\n\nQTcpSocket is a convenience subclass of QAbstractSocket that allows you to establish a TCP connection and transfer streams of data. See the QAbstractSocket documentation for details."
    },
    {
        "link": "https://felgo.com/doc/qt/topics-network-connectivity",
        "document": "Qt provides classes for both high-level and low-level network communication, classes for web integration, and classes for inter-process communication.\n\nFor high-level network traffic, Qt Network provides an abstraction layer over the operations used, showing only high-level classes and functions. Qt Network can also handle lower level protocols like TCP and UDP. Classes like QTcpSocket and QUdpSocket enable the developer to send and receive messages using the TCP or UDP protocol.Name resolution is done with QHostInfo. QHostInfo is called before creating a network connection with QTcpSocket or QUdpSocket. Filtering and redistributing network traffic via proxies can handled by the QNetWorkProxy class.\n\nQt also offers functionalities for inter-process communication (IPC). The class QProcess is used to start external programs. Qt D-Bus provides support for D-Bus, an inter-process communication and remote procedure calling mechanism. It mostly communicates via a central server application, called a bus. However, it is also possible to let applications communicate directly with each other. QSharedMemory provides access to a shared memory segment by multiple threads and processes. It is however also possible for a single process to exclusively lock that shared memory.\n\nQt supports a wide range of network communication, with a focus on HTTP, TCP, and UDP.\n\nAt the HTTP level, the Qt Network module offers the network access API, which consists mainly of QNetworkRequest, QNetworkAccessManager, and QNetworkReply. Put simply, the QNetworkRequest resembles an HTTP request, which gets passed to the QNetworkAccessManager to send the request on the wire; this class returns a QNetworkReply, which enables parsing the HTTP reply. The network access API uses the socket classes mentioned below (for TCP and SSL) internally.\n\nFor communication at the socket level, QTcpSocket, QUdpSocket and QSslSocket should be used. These classes offer a synchronous API through the waitFor* methods as well as an asynchronous API; if possible (i.e. if the event loop is running), the asynchronous API should always be preferred. Qt also offers QTcpServer to enable the server-side part of a TCP communication. Please note that there is no HTTP server class in Qt.\n\nFor secure communication via SSL, Qt Network offers a wide range of classes alongside the central QSslSocket, e.g. QSslCertificate, QSslConfiguration and QSslError.\n\nQt also offers HTTP support in QML by either using HTTP explicitly via XmlHttpRequest, or by transparently using HTTP URLs in e.g. Image sources.\n• Resource Loading and Network Transparency - network and URL transparency in QML\n\nQt provides several ways to implement Inter-Process Communication (IPC) in Qt applications.\n\nThe cross-platform Qt Network module provides classes that make network programming portable and easy. It offers high-level classes (e.g., QNetworkAccessManager) that communicate using specific application-level protocols, and lower-level classes (e.g., QTcpSocket, QTcpServer, QSslSocket) for implementing protocols.\n\nThe cross-platform shared memory class, QSharedMemory, provides access to the operating system's shared memory implementation. It allows safe access to shared memory segments by multiple threads and processes. Additionally, QSystemSemaphore can be used to control access to resources shared by the system, as well as to communicate between processes.\n\nThe Qt D-Bus module is a cross-platform library you can use to implement IPC using the D-Bus protocol. It extends Qt's signals and slots mechanism to the IPC level, allowing a signal emitted by one process to be connected to a slot in another process.\n\nThe cross-platform class QProcess can be used to start external programs as child processes, and to communicate with them. It provides an API for monitoring and controlling the state of the child process. QProcess gives access to the input/output channels of child process by inheriting from QIODevice.\n\nThe QLocalSocket class provides a local socket. On Windows this is a named pipe and on Unix this is a local domain socket. The QLocalServer class provides a local socket based server. This class makes it possible to accept incoming local socket connections."
    },
    {
        "link": "https://qthub.com/static/doc/qt5/qtnetwork/qtnetwork-programming.html",
        "document": "The Qt Network module offers classes that allow you to write TCP/IP clients and servers. It offers lower-level classes such as QTcpSocket, QTcpServer and QUdpSocket that represent low level network concepts, and high level classes such as QNetworkRequest, QNetworkReply and QNetworkAccessManager to perform network operations using common protocols. It also offers classes such as QNetworkConfiguration, QNetworkConfigurationManager and QNetworkSession that implement bearer management.\n\nThe Qt Network C++ Classes page contains a list of the C++ classes in Qt Network.\n\nThe Network Access API is a collection of classes for performing common network operations. The API provides an abstraction layer over the specific operations and protocols used (for example, getting and posting data over HTTP), and only exposes classes, functions, and signals for general or high level concepts.\n\nNetwork requests are represented by the QNetworkRequest class, which also acts as a general container for information associated with a request, such as any header information and the encryption used. The URL specified when a request object is constructed determines the protocol used for a request. Currently HTTP, FTP and local file URLs are supported for uploading and downloading.\n\nThe coordination of network operations is performed by the QNetworkAccessManager class. Once a request has been created, this class is used to dispatch it and emit signals to report on its progress. The manager also coordinates the use of cookies to store data on the client, authentication requests, and the use of proxies.\n\nReplies to network requests are represented by the QNetworkReply class; these are created by QNetworkAccessManager when a request is dispatched. The signals provided by QNetworkReply can be used to monitor each reply individually, or developers may choose to use the manager's signals for this purpose instead and discard references to replies. Since QNetworkReply is a subclass of QIODevice, replies can be handled synchronously or asynchronously; i.e., as blocking or non-blocking operations.\n\nEach application or library can create one or more instances of QNetworkAccessManager to handle network communication.\n\nUsing TCP with QTcpSocket and QTcpServer\n\nTCP (Transmission Control Protocol) is a low-level network protocol used by most Internet protocols, including HTTP and FTP, for data transfer. It is a reliable, stream-oriented, connection-oriented transport protocol. It is particularly well suited to the continuous transmission of data.\n\nThe QTcpSocket class provides an interface for TCP. You can use QTcpSocket to implement standard network protocols such as POP3, SMTP, and NNTP, as well as custom protocols.\n\nA TCP connection must be established to a remote host and port before any data transfer can begin. Once the connection has been established, the IP address and port of the peer are available through QTcpSocket::peerAddress() and QTcpSocket::peerPort(). At any time, the peer can close the connection, and data transfer will then stop immediately.\n\nQTcpSocket works asynchronously and emits signals to report status changes and errors, just like QNetworkAccessManager. It relies on the event loop to detect incoming data and to automatically flush outgoing data. You can write data to the socket using QTcpSocket::write(), and read data using QTcpSocket::read(). QTcpSocket represents two independent streams of data: one for reading and one for writing.\n\nSince QTcpSocket inherits QIODevice, you can use it with QTextStream and QDataStream. When reading from a QTcpSocket, you must make sure that enough data is available by calling QTcpSocket::bytesAvailable() beforehand.\n\nIf you need to handle incoming TCP connections (e.g., in a server application), use the QTcpServer class. Call QTcpServer::listen() to set up the server, and connect to the QTcpServer::newConnection() signal, which is emitted once for every client that connects. In your slot, call QTcpServer::nextPendingConnection() to accept the connection and use the returned QTcpSocket to communicate with the client.\n\nAlthough most of its functions work asynchronously, it's possible to use QTcpSocket synchronously (i.e., blocking). To get blocking behavior, call QTcpSocket's waitFor...() functions; these suspend the calling thread until a signal has been emitted. For example, after calling the non-blocking QTcpSocket::connectToHost() function, call QTcpSocket::waitForConnected() to block the thread until the connected() signal has been emitted.\n\nSynchronous sockets often lead to code with a simpler flow of control. The main disadvantage of the waitFor...() approach is that events won't be processed while a waitFor...() function is blocking. If used in the GUI thread, this might freeze the application's user interface. For this reason, we recommend that you use synchronous sockets only in non-GUI threads. When used synchronously, QTcpSocket doesn't require an event loop.\n\nThe Fortune Client and Fortune Server examples show how to use QTcpSocket and QTcpServer to write TCP client-server applications. See also Blocking Fortune Client for an example on how to use a synchronous QTcpSocket in a separate thread (without using an event loop), and Threaded Fortune Server for an example of a multithreaded TCP server with one thread per active client.\n\nUDP (User Datagram Protocol) is a lightweight, unreliable, datagram-oriented, connectionless protocol. It can be used when reliability isn't important. For example, a server that reports the time of day could choose UDP. If a datagram with the time of day is lost, the client can simply make another request.\n\nThe QUdpSocket class allows you to send and receive UDP datagrams. It inherits QAbstractSocket, and it therefore shares most of QTcpSocket's interface. The main difference is that QUdpSocket transfers data as datagrams instead of as a continuous stream of data. In short, a datagram is a data packet of limited size (normally smaller than 512 bytes), containing the IP address and port of the datagram's sender and receiver in addition to the data being transferred.\n\nQUdpSocket supports IPv4 broadcasting. Broadcasting is often used to implement network discovery protocols, such as finding which host on the network has the most free hard disk space. One host broadcasts a datagram to the network that all other hosts receive. Each host that receives a request then sends a reply back to the sender with its current amount of free disk space. The originator waits until it has received replies from all hosts, and can then choose the server with most free space to store data. To broadcast a datagram, simply send it to the special address QHostAddress::Broadcast (255.255.255.255), or to your local network's broadcast address.\n\nQUdpSocket::bind() prepares the socket for accepting incoming datagrams, much like QTcpServer::listen() for TCP servers. Whenever one or more datagrams arrive, QUdpSocket emits the readyRead() signal. Call QUdpSocket::readDatagram() to read the datagram.\n\nThe Broadcast Sender and Broadcast Receiver examples show how to write a UDP sender and a UDP receiver using Qt.\n\nQUdpSocket also supports multicasting. The Multicast Sender and Multicast Receiver examples show how to use write UDP multicast clients.\n\nBefore establishing a network connection, QTcpSocket and QUdpSocket perform a name lookup, translating the host name you're connecting to into an IP address. This operation is usually performed using the DNS (Domain Name Service) protocol.\n\nQHostInfo provides a static function that lets you perform such a lookup yourself. By calling QHostInfo::lookupHost() with a host name, a QObject pointer, and a slot signature, QHostInfo will perform the name lookup and invoke the given slot when the results are ready. The actual lookup is done in a separate thread, making use of the operating system's own methods for performing name lookups.\n\nQHostInfo also provides a static function called QHostInfo::fromName() that takes the host name as argument and returns the results. In this case, the name lookup is performed in the same thread as the caller. This overload is useful for non-GUI applications or for doing name lookups in a separate, non-GUI thread. (Calling this function in a GUI thread may cause your user interface to freeze while the function blocks as it performs the lookup.)\n\nNetwork communication with Qt can be performed through proxies, which direct or filter network traffic between local and remote connections.\n\nIndividual proxies are represented by the QNetworkProxy class, which is used to describe and configure the connection to a proxy. Proxy types which operate on different levels of network communication are supported, with SOCKS 5 support allowing proxying of network traffic at a low level, and HTTP and FTP proxying working at the protocol level. See QNetworkProxy::ProxyType for more information.\n\nProxying can be enabled on a per-socket basis or for all network communication in an application. A newly opened socket can be made to use a proxy by calling its QAbstractSocket::setProxy() function before it is connected. Application-wide proxying can be enabled for all subsequent socket connections through the use of the QNetworkProxy::setApplicationProxy() function.\n\nProxy factories are used to create policies for proxy use. QNetworkProxyFactory supplies proxies based on queries for specific proxy types. The queries themselves are encoded in QNetworkProxyQuery objects which enable proxies to be selected based on key criteria, such as the purpose of the proxy (TCP, UDP, TCP server, URL request), local port, remote host and port, and the protocol in use (HTTP, FTP, etc.).\n\nQNetworkProxyFactory::proxyForQuery() is used to query the factory directly. An application-wide policy for proxying can be implemented by passing a factory to QNetworkProxyFactory::setApplicationProxyFactory() and a custom proxying policy can be created by subclassing QNetworkProxyFactory; see the class documentation for details."
    },
    {
        "link": "https://stackoverflow.com/questions/20546750/qtcpsocket-reading-and-writing",
        "document": "I know some similar questions may have been asked already, but the answers to those I found covered very specific problems and I still haven't figured it out.\n\nIn my program I'm creating a QObject (called QPeer) that uses a QTcpSocket to communicate with another such object over a network. QPeer has a slot that accepts a QByteArray with data ( ). The entire contents of that array are considered to be one 'message' and they are written to the socket. I want to do the following: every time a message is written, I want the receiving QPeer to emit its signal exactly once, that QByteArray containing the entire message. (NOTE: all signals/slots, both private ones connecting the QPeer with its socket and the public ones such as are serialized by using whenever necessary.)\n\nI use the signal for asynchronous reading from the socket. Now I know I can't just call once in sendData and then assume that for every write I do, the QTcpSocket on the other side produces exactly one readyRead signal. So what should I do?\n\nThis is my idea, please tell me if this will work:\n\nnow I want the read function (connected to ) to use the header (the 4 byte int specifying the length of the message) and then read that amount of bytes; next emit dataReceived with exactly those bytes. I'm having serious trouble trying to do this. For example: what to do if readyRead is emitted and I can read the header of a message, but not the amount of bytes specified? Or what if a header has only been received partially?\n\n1. How do I correctly write the header (4 byte int) to the socket?\n\n2. How do I correctly implement the read function so that it does what I want?\n\nAny tips are welcome. Thanks!"
    },
    {
        "link": "https://forum.qt.io/topic/67855/slot-signal-safety-with-qbytearray-references",
        "document": "@frank.quebec\n\n Salut Francois,\n\n In general it's not a good idea to send references through a queued connection, even if one leaves the thread safety aside. The problem is that a reference is not much different from a pointer, so when the actual object goes out of scope you will get a segmentation fault accessing a reference to it. For example:\n\nSo while most compilers will find the error in the above simple example and will warn you it gets a bit more complicated when working with signals and slots. You can send references, but only provided the original object will not go out of scope. So for most intents and purposes you should be satisfied with just passing objects by value. That's one of the reasons many of the \"data\" classes in Qt are implicitly shared, and what's more they have internal thread-safe reference counting.\n\nOn a side note one of the side effects of using signals and slots is you shouldn't need to use mutexes directly. The signal slot connection (with a few rare exceptions) is safe across thread boundaries. So Just making it is usually enough to ensure race conditions don't occur.\n\nNo, but this is outside of Qt's scope. This is because of how C++ works.\n\nYou are not. For the most part you will need to use which is equivalent to using a queued one when working with objects living in different threads, and to direct connection when sender and receiver are in the same thread.\n\nIf the above snippet deadlocks, that would pretty strongly suggest you have only one thread and the slot call will double-lock the mutex, thus the program deadlocks."
    },
    {
        "link": "https://stackoverflow.com/questions/70576065/is-it-a-good-practice-to-use-signals-and-slots-in-qt-also-when-no-input-from-gui",
        "document": "Overuse of signals and slots is a very bad and unfortunately very common practice. It hides dependencies, it makes code hard to debug and basically unmaintainable in the long term. Unfortunately many programmers think this it is a good practice because they achieve \"decoupling\", which seems as a holy grail to them. This is a nonsense.\n\nI do not say you should not use signals and slots at all. I only say you should not overuse them. Signals and slots are the perfect tool to implement Observer design pattern to have a \"reactive\" system in which objects react to other objects having changed their states. Only this is the correct use of signals and slots. Almost every other use of signals and slots is wrong. The most extreme case which I have seen was implementing a getter function with a signal-slot connection. The signal sent a reference to a variable and the slot filled it with a value and then it returned to the emitter. This is just mad!\n\nHow you know that your signals and slots implement Observer pattern correctly? These are rules of thumb which follow from my quite long experience with Qt:\n• The nature of the signal is that the emitter announces publicly (signals are always public - except if you use a private class dummy parameter) by sending out some signal that its state has somehow changed.\n• The emitter does not care who are the observers or whether there are any observers at all, i.e. the emitter must not depend on observers in any way.\n• It is never the emitter's responsibility to establish or manage the connection - do not ever do it! The connection/disconnection is the responsibility of the observer (then it often connects to a private slot) or of some parent object which knows of the existence of both, the emitter and the observer (in that case the mutual parent connects emitter's signal to observers public slot).\n\nIt is normal that you will see lots of signal-slot connections in GUI layer and this is perfectly OK (note: GUI layer includes view models!). This is because GUI is typically a reactive system where objects react to other objects or to some changes in the underlying layers. But you will probably see much less signal-slot connections in the business logic layer (btw. in many projects business logic is coded without using Qt).\n\nRegarding naming: I have encountered an interesting code smell. When the observer's public (!) slot is called like - with emphasis on the prefix . This is almost always sign of bad design and abuse of signals and slots. Usually this slot should be a) made private and the connection should be established by the observer or b) should be renamed to or c) should be renamed and should be called as normal method instead of using signals and slots.\n\nAnd a note about why overuse of signals and slots are hard to maintain. There are many potential problems in the long term which can break your code:\n• The dependencies with signals and slots are often hidden in a distant seemingly unrelated part of code. This relates to the signal-slot abuse when emitter actually depends on the observer but this is not clear when looking at the emitter's code. If your class depends on some other class/module, this dependency should be explicit and clearly visible.\n• When signals and slots are connected and then disconnected programmatically by your code, you often end up in state when you forgot do disconnect and you now have multiple connections. Having multiple connections is often overlooked because it often does not do any harm, it only makes the code somewhat slower, i.e. changed text is updated multiple times instead of once only - nobody will catch this issue unless you have a thousand-fold connection. these multiplying connections are somewhat similar to memory leaks. Small memory leaks remain often unnoticed, which is similar to multiple connections.\n• It often happens that you depend on the order in which the connections are established. And when these order-dependent connections are established in distant parts of code, you are in bad trouble, this code will fall apart sooner or later.\n\nTo check whether I do not have multiple connections or whether the connection/disconnection was successful, I am using these my helper utils https://github.com/vladimir-kraus/qtutils/blob/main/qtutils/safeconnect.h\n\nPS: In the text above I am using term \"emitter\" (emits the signal) and \"observer\" (observes the emitter and receives the signal). Sometimes people use \"sender\" and \"receiver\" instead. My intention was to emphasize the fact that the emitter emits a signals without actually knowing whether anyone receives it. The word \"sender\" gives the impression that you send the signal to someone, which is however exactly the cause of signal-slot overuse and bad design. So using \"sender\" only leads to confusion, IMO. And by using \"observer\" I wanted to emphasize that signals and slots are the tool to implement the Observer design pattern.\n\nPPS: Signals and slots are also the perfect tool for async communicating between threads in Qt. This use case may be one of the very few exceptions to the principles which I described above."
    },
    {
        "link": "https://forum.qt.io/topic/74800/signal-slot-best-practice-with-composition",
        "document": "I'm developing a communication class, which is designed to be agnostic to the IPC employed. The constructor looks like this:\n\nThe main app class which creates the instance of TapDisplayCommunicationHandler knows the IPC mechanism to be used, which has a common interface. The common interface of the IPC handler class defines signals such as:\n\nMy question is this. Since the main app class creates the IPC handler instance, which is passed to the TapDisplayCommunicationHandler and integrated as a class member, is it acceptable to connect the signals from the IPC handler class to the main class directly, before passing it to the TapCommunicationHandler, or is it a better practice to have slots in TapCommunicationHandler to receive the signals from the IPC handler and then re-emit them to the main class? In the latter case, the main class would define connections with the TapCommunicationHandler instance instead of the IPC Handler instance"
    },
    {
        "link": "https://stackoverflow.com/questions/13362551/qt-signal-slot-design-and-performance",
        "document": "I've recently started using Qt and I need some clarification on signal/slot mechanism. I understand how it's a great tool for the GUI and communication between objects living in separate threads, but I'm not quite sure whether I should use it in a simple cases like the following one.\n\nI have three classes, let's call them MainWindow, DataManager and DataWorker. DataWorker lives in a separate thread and signals when new data is ready for collection. It is then visualised in MainWindow widgets after some processing. I've created DataManager class as to not pollute the GUI class with processing code.\n\nNow, how should I handle the communication between DataManager and the MainWindow.\n\nOption #1 - have a pointer to MainWindow as a member and just call its method\n\nOption 1 seems more intuitive to me, but then again I don't know Qt very well. I can see the benefit of using signals and slots if there will be more classes that I'd like to react to a newData() signal.\n\nSo what's a better option and is there any difference in performance between the two?"
    },
    {
        "link": "https://sii.pl/blog/en/performance-comparison-of-the-qt-signals-and-slots-mechanism-and-the-native-c-implementation",
        "document": "C++ is a common choice when the performance of the designed system is crucial. Unfortunately, its use alone does not guarantee that the assumed processing speed will be achieved. This is why more and more emphasis is placed on the optimization of the source code and its execution time. One aspect that affects performance is the amount of data copied.\n\nIn this article, I will focus on the number of object copies made by the very popular Qt library version 6.2.4, specifically in its mechanism called “Signal & Slot”. I will also present a comparison with my own implementation of the TBC (Template Based Communication) library I created.\n\nThe “Signal & Slot” mechanism in Qt is used for synchronous or asynchronous communication between objects. To use this mechanism, objects must inherit from the QObject class and include the “Q_OBJECT” macro in the declaration. The object that sends the message declares a signal with arguments that must be copyable:\n\nThe receiving object declares the corresponding slot:\n\nThen, the objects should be connected by executing the static method QObject::connect:\n\nThis method also accepts an optional parameter defining the connection type. I will focus on the two most important ones:\n• Qt::DirectConnection – the method defined as a slot will be executed synchronously in the same thread, as if the slot had been called directly,\n• Qt::QueuedConnection – the method defined as a slot will be executed asynchronously:\n• In the same thread when it returns to the main Qt loop, and this call will be next in the queue.\n• In another thread after the QObject::moveToThread method has been executed on the receiving object.\n\nDetails of this mechanism are included in the Qt documentation.\n\nThe mechanism described above seems very useful and easy to use. Later in the article, I will focus on checking the number of copies created only in the queued connection. I have written a simple object transfer test that counts copies by incrementing a static variable in the copy constructor. The definition of this class is as follows:\n\nAfter providing the parameter to the slot, the number of copies is printed to the console. The results of this test are presented in the table below:\n\nAs can be seen, in a queued connection, the number of copies made depends on the type of the parameter in the signal and the argument in the slot. It’s worth noting that in the last two cases, the parameter is given by rvalue. I will present the performance overhead introduced by making these copies in a separate chapter.\n\nThe Qt documentation mentions that it must make a copy to store the object “behind the scenes”, but doesn’t define how many of these copies are made for different types of arguments. I aim to demonstrate that the number of copies for a queuing connection can be minimized by using move semantics or by ensuring that the object reference will be valid at the time of the slot call. For this purpose, I wrote my TBC (Template Based Communication) library. Instead of creating my own metalanguage, I used the template mechanism to specify the arguments to be sent. Here’s how the library works:\n• The sending object must inherit from the TBC::Sender<T> class.\n• The receiving object must inherit from the TBC::Receiver<T> class, where ‘T’ is the type of the argument being sent.\n\nThe signal is sent in two ways:\n• valueSignal(T ) – the signal takes an argument by value, allowing for the use of move semantics,\n• constRefSignal(const T& ) – the signal takes a constant reference to an object. The object will only be copied if the slot accepts an argument as a value. It’s important to ensure that the object being sent is not destroyed before the connected slot is invoked.\n\nSimilarly, the reception of arguments is handled by valueSlot(T ) and constRefSlot(const T& ). An example of usage in the code is presented below:\n\nTo connect objects, you can use the static TBC::connect method:\n\nFor more details, please refer to my repository, where you can find the implementation of the TBC library, a class diagram and functional and performance tests. All comments and remarks are welcome 🙂\n\nAs in the case of Qt, analogous tests were performed to examine the number of copies made for the queued connection. The test results are in the table below:\n\nYou will notice that the TBC library provides the minimum number of required copies for a queued connection.\n\nThe performance tests conducted measure the time that passes from the signal broadcast to the slot call running in a separate thread for various sizes of the transmitted parameter. Each benchmark was executed for 50 iterations. The tests were run twice, resulting in a total of 100 measurements, from which the average operation time was calculated.\n\nHere is the configuration of the system used for the tests:\n\nThe first benchmark measures the transmission of std::chrono::high_resolution_clock::time_point set just before the signal is emitted and examines the delay in the recipient slot. To illustrate, here is a piece of code using Qt:\n\nThe test results are illustrated below:\n\nAlthough the TBC library shows approximately 10% less delay compared to the Qt library, it is not a significant difference because only after 100 thousand operations will the delay accumulate to 1 second.\n\nSubsequent benchmarks measure the time needed to transmit a Msg object containing an array of bytes, with the size increasing fourfold, starting from 1kB and going up to 256MB. The source code of the Msg class is presented below:\n\nTests were conducted for all combinations of signal parameter and slot argument types as listed in the tables in the previous sections. Charts created based on the results achieved are presented below:\n\nThe graphs reveal that the operation time of Qt in each case, is linearly dependent on the size of the parameter, and the times correlate with the previously declared values of the number of copies made. In contrast, TBC, for the three cases in which an object copy can be avoided, demonstrates constant complexity, rendering the data transfer time independent of its size.\n\nThe performance tests have confirmed that the Qt library (version 6.2.4) does not optimally manage memory in the tests performed. Unfortunately, the Qt documentation does not explicitly mention this performance limitation. The TBC library I created proves that it is possible to achieve the optimal number of objects copying operations while maintaining a similar, user-friendly interface. It is possible that in subsequent versions of Qt we may receive an update adding support for move semantics.\n\nIn the meantime, when using the “Signal & Slot” mechanism from Qt:\n• Please remember that the object must be copyable, and it will be copied at least once when the signal is emitted in the queued connection.\n• Prefer to take the parameter in the slot as a constant reference, which will avoid making one copy.\n• If possible, wrap the parameter in std::shared_ptr so that a copy of the object is not made.\n\nWhen using std::shared_ptr, remember that the parameter inside will be destroyed when the last copy of std::shared_ptr is deleted unless custom deletetion is set. It is safest to use the std::make_shared at the memory allocation to avoid calling the destructor of the stored object and freeing its memory a second time.\n• Burkhard Stubert “Copied or Not Copied: Arguments in Signal-Slot Connections?”\n\nIf you’re interested in C++, also take a look at other articles by our experts."
    }
]