[
    {
        "link": "https://docs.arduino.cc/libraries/liquidcrystal-i2c",
        "document": ""
    },
    {
        "link": "https://reference.arduino.cc/reference/en/libraries/liquidcrystal-i2c",
        "document": "Doubts on how to use Github? Learn everything you need to know in this tutorial .\n\nFind anything that can be improved? Suggest corrections and new documentation via GitHub.\n\nA library for I2C LCD displays. \n\n The library allows to control I2C displays with functions extremely similar to LiquidCrystal library. THIS LIBRARY MIGHT NOT BE COMPATIBLE WITH EXISTING SKETCHES.\n\nThis library is compatible with the avr architecture so you should be able to use it on the following Arduino boards:\n\nNote: while the library is supposed to compile correctly on these architectures, it might require specific hardware features that may be available only on some boards.\n\nTo use this library, open the Library Manager in the Arduino IDE and install it from there."
    },
    {
        "link": "https://docs.oyoclass.com/unoeditor/Libraries/liquid_crystal",
        "document": "The LiquidCrystal_I2C library allows you to program an Arduino to print messages to an LCD screen using an I2C backpack. I2C is a communication protocol that allows you to communicate with multiple devices using only a few pins.\n\nTo include the library into the sketch you're working on, include the two libraries shown below at the top of your sketch.\n\nTo create an LCD object, follow the line of code below.\n\nThe first argument is the address of your LCD screen. This can be found by using the scanner script at the bottom of this page.\n• x: the number of horizontal characters of the lcd screen\n• y: the number of vertical characters of the lcd screen\n\nInitialize the LCD screen with the height and width of the displays\n\nClear all characters from the LCD screen\n\nPrints characters to the LCD screen starting at the current location of the cursor. This method does not skip to the next line when it reaches the end of the line.\n\nPlaces the cursor at the (0,0) point (upper left-hand corner)"
    },
    {
        "link": "https://docs.arduino.cc/libraries/liquidcrystal",
        "document": ""
    },
    {
        "link": "https://github.com/mrkaleArduinoLib/LiquidCrystal_I2C/blob/master/README.md",
        "document": "It is the reimplementation of the standard Arduino LCD library, configured to work with parallel HD44780 compatible LCDs, and interfaced via a Chinese PCF8574 I2C serial extender.\n\nThe reimplementation has been inspired by and credit goes to:\n\nThe library class extends the system library Print and includes following sytem header files.\n• inttypes.h: Integer type conversions. This header file includes the exact-width integer definitions and extends them with additional facilities provided by the implementation.\n• Print.h: Base class that provides print() and println().\n\nSome of listed functions come out of Arduino LCD API 1.0, some of them are specific for this library. It is possible to use functions from the system library Print, which is extended by the LiquidCrystal_I2C.\n\n*) The function is an alias of another (usually previous) one.\n\nConstructor of the object controlling an LCD. It defines address of the LCD and its geometry.\n• More LCDs can be connected to the same I2C bus if they are hardware configured for different addresses.\n• For each of LCDs the separate object has to be created.\n• When the display powers up, it is configured as follows:\n• Note, however, that resetting the Arduino does not reset the LCD, so we cannot assume that it is in that state when a sketch starts (and the constructor is called).\n• addr: I2C addres of the LCD predefined by the serial extender.\n• Usual values:\n• 0x3F for LCDs 2004 with 20 columns and 4 rows.\n• 0x27 for LCDs 1602 with 16 columns and 2 rows.\n• cols: Number of characters in a row defined by the hardware construction of the LCD screen.\n• rows: Number of rows in the LCD screen defined by the hardware construction of the LCD.\n\nInitialize the LCD with its specific geometry parameters.\n• cols: Number of characters in a row defined by the hardware construction of the LCD screen.\n• rows: Number of rows in the LCD screen defined by the hardware construction of the LCD.\n• charsize: Geometry of the LCD's character defined by a library constant.\n\nInitializes the display with values put to the constructor, clears the screen, and puts cursor to the upper left corner of the screen, i.e., to the home position 0,0. It is a wrapper function for function begin() with forgoing initialization of Wire library.\n\nOverloaded function for clearing the entire LCD screen or just a part of a row.\n• Using the function without any parameters clears the entire srceen.\n• For clearing the entire row use the function just with the first parameter.\n• The functions sets the cursor to the start column and row after clearing, i.e., after calling without parameters to the home position (0, 0), or after calling with parameters to the starts of cleared row segment.\n• rowStart: Number of a row to be cleared counting from 0.\n• Valid values: unsigned byte 0 to rows - 1 of the constructor\n• colStart: Order number of the first character in a cleared row counting from 0, which the cleared segment starts from.\n• Valid values: unsigned byte 0 to cols - 1 of the constructor\n• \n• Valid values: unsigned byte 0 to cols of the constructor\n• Default value: 255, but internally limited to (cols - colStart)\n\nPlaces the cursor to the home position (0, 0) and leaves displayed characters.\n\nPrints text or number to the LCD. It is inhereted function from the parent system one. The function is overloaded and acts according the data type of the input data to be printed.\n• data: String or number that should be printed on the LCD from current cursor position.\n• base: Optional base in which to print numbers.\n\nWrites a raw value to the display.\n• value: Value that should be write to the LCD at address set before.\n\nTurns the display off quickly. If the display does not have an option to turn on the display, the function just turns backlight on.\n\nTurns the display on quickly. If the display does not have an option to turn off the display, the function just turns backlight off.\n\nScrolls the display text to the left without changing the RAM. The function scrolls entire 40 character buffer. If you print 40 characters to a row and start scrolling, you get continuous moving banner in a row especially on 1602 LCDs.\n\nScrolls the display text to the right without changing the RAM. The function scrolls entire 40 character buffer. If you print 40 characters to a row and start scrolling, you get continuous moving banner in a row especially on 1602 LCDs.\n\nSets the flow of text from left to right as it is normal for Latin languages.\n\nSets the flow of text from right to left as it is normal for Arabic languages.\n\nJustifies the text from the cursor to the left.\n\nJustifies the text from the cursor to the right.\n\nFills the first 8 character generator RAM (CGRAM) locations with custom characters.\n• col: Number of a column where the cursor will be located counting from 0.\n• Valid values: unsigned byte 0 to cols - 1 of the constructor\n• row: Number of a row where the cursor will be located counting from 0.\n• Valid values: unsigned byte 0 to rows - 1 of the constructor\n\nInitializes particular bar graph. The function creates a set of custom characters for displaying bar graphs. Some number of first current custom characters (5 or 8) will be overwritten according to the type of graph.\n\nDisplays horizontal graph from desired cursor position with input value.\n• The bar graph is composed of solid, full rectangle characters eventually except final character with reduced vertical pipes. Value of the bar graph is displayed as equivalent number of pipes in the graph segment.\n• The line graph is composed of one pipe running across a LCD row. Value of the bar graph is displayed as a pipe at equivalent dot position in the graph segment.\n• The function is overloaded by data type of a displayed graph value, which determines its form.\n• Zero value of the graph is displayed as the very left pipe in the graph segment due to counting from 0, so that the graph always displays something.\n• row: Row positon of graph segment counting from 0 to physical number of rows.\n• Valid values: non-negative integer 0 to rows - 1 of the constructor\n• col: Column position of graph segment counting from 0 physical number of columns on a row.\n• Valid values: non-negative integer 0 to cols - 1 of the constructor\n• len: Length of a graph segment in characters limited to remaining physical columns from starting col position.\n• Valid values: non-negative integer 0 to cols - col of the constructor\n• pixel_col_end: Displayed value in pipes (horizontal dots) counting from 0 to number of pipes of the graph segment. A sketch should calculate the number of segment pipes in order to map an application value to displayed value.\n• percentage: Displayed value in percentage of a graph segment length. Accepted value is rounded to integer per cents.\n• ratio: Displayed value as a fragment of a graph segment length.\n\nDisplays vertical bar from desired cursor position with input value.\n• The bar graph is composed of solid, full rectangle characters eventually except final character with reduced horizontal dashes. Value of the bar graph is displayed as equivalent number of dashes in the graph segment.\n• The function is overloaded by data type of a displayed graph value, which determines its form.\n• row: Row positon of graph segment counting from 0 to physical limit.\n• Valid values: non-negative integer 0 to rows - 1 of the constructor\n• \n• Valid values: non-negative integer 0 to cols - 1 of the constructor\n• len: Length of a graph segment in rows limited to remaining physical rows from starting row position.\n• Valid values: non-negative integer 0 to row + 1 of the constructor\n• pixel_col_end: Displayed value in dashes (vertical dots) counting from 0 to number of dashes of the graph segment. A sketch should calculate the number of segment dashes in order to map an application value to displayed value.\n• percentage: Displayed value in percentage of a graph segment length. Accepted value is rounded to integer per cents.\n• ratio: Displayed value as a fragment of a graph segment length.\n\nFills the first 8 character generator RAM (CGRAM) locations with custom characters.\n• char_num: Position of a custom character in CGRAM for custom chars.\n• \n• Valid values: Character row byte patterns from the top of the char.\n• rows: Pointer to the array of custom characters definitions.\n\nSends a command to the display. It is useful for commands not supported by the library.\n• value: Command code that should be send to the LCD."
    },
    {
        "link": "https://arduino.cc/reference/cs/language/functions/external-interrupts/attachinterrupt",
        "document": "The first parameter to is an interrupt number. Normally you should use to translate the actual digital pin to the specific interrupt number. For example, if you connect to pin 3, use as the first parameter to .\n\nNote\n\n Inside the attached function, won’t work and the value returned by will not increment. Serial data received while in the function may be lost. You should declare as any variables that you modify within the attached function. See the section on ISRs below for more information.\n\nInterrupts are useful for making things happen automatically in microcontroller programs, and can help solve timing problems. Good tasks for using an interrupt may include reading a rotary encoder, or monitoring user input.\n\nIf you wanted to insure that a program always caught the pulses from a rotary encoder, so that it never misses a pulse, it would make it very tricky to write a program to do anything else, because the program would need to constantly poll the sensor lines for the encoder, in order to catch pulses when they occurred. Other sensors have a similar interface dynamic too, such as trying to read a sound sensor that is trying to catch a click, or an infrared slot sensor (photo-interrupter) trying to catch a coin drop. In all of these situations, using an interrupt can free the microcontroller to get some other work done while not missing the input.\n\nISRs are special kinds of functions that have some unique limitations most other functions do not have. An ISR cannot have any parameters, and they shouldn’t return anything.\n\nGenerally, an ISR should be as short and fast as possible. If your sketch uses multiple ISRs, only one can run at a time, other interrupts will be executed after the current one finishes in an order that depends on the priority they have. relies on interrupts to count, so it will never increment inside an ISR. Since requires interrupts to work, it will not work if called inside an ISR. works initially, but will start behaving erratically after 1-2 ms. does not use any counter, so it will work as normal.\n\nTypically global variables are used to pass data between an ISR and the main program. To make sure variables shared between an ISR and the main program are updated correctly, declare them as .\n\n: the number of the interrupt ( )\n\n : the pin number\n\n : the ISR to call when the interrupt occurs; this function must take no parameters and return nothing. This function is sometimes referred to as an interrupt service routine.\n\n : defines when the interrupt should be triggered. Four constants are predefined as valid values:"
    },
    {
        "link": "https://reference.arduino.cc/reference/en/language/functions/external-interrupts/attachinterrupt",
        "document": "The first parameter to is an interrupt number. Normally you should use to translate the actual digital pin to the specific interrupt number. For example, if you connect to pin 3, use as the first parameter to .\n\nNote\n\n Inside the attached function, won’t work and the value returned by will not increment. Serial data received while in the function may be lost. You should declare as any variables that you modify within the attached function. See the section on ISRs below for more information.\n\nInterrupts are useful for making things happen automatically in microcontroller programs and can help solve timing problems. Good tasks for using an interrupt may include reading a rotary encoder, or monitoring user input.\n\nIf you wanted to ensure that a program always caught the pulses from a rotary encoder, so that it never misses a pulse, it would make it very tricky to write a program to do anything else, because the program would need to constantly poll the sensor lines for the encoder, in order to catch pulses when they occurred. Other sensors have a similar interface dynamic too, such as trying to read a sound sensor that is trying to catch a click, or an infrared slot sensor (photo-interrupter) trying to catch a coin drop. In all of these situations, using an interrupt can free the microcontroller to get some other work done while not missing the input.\n\nISRs are special kinds of functions that have some unique limitations most other functions do not have. An ISR cannot have any parameters, and they shouldn’t return anything.\n\nGenerally, an ISR should be as short and fast as possible. If your sketch uses multiple ISRs, only one can run at a time, other interrupts will be executed after the current one finishes in an order that depends on the priority they have. relies on interrupts to count, so it will never increment inside an ISR. Since requires interrupts to work, it will not work if called inside an ISR. works initially but will start behaving erratically after 1-2 ms. does not use any counter, so it will work as normal.\n\nTypically global variables are used to pass data between an ISR and the main program. To make sure variables shared between an ISR and the main program are updated correctly, declare them as .\n\n: the number of the interrupt. Allowed data types: .\n\n : the Arduino pin number.\n\n : the ISR to call when the interrupt occurs; this function must take no parameters and return nothing. This function is sometimes referred to as an interrupt service routine.\n\n : defines when the interrupt should be triggered. Four constants are predefined as valid values:"
    },
    {
        "link": "https://docs.arduino.cc/language-reference/en/functions/external-interrupts/attachInterrupt",
        "document": ""
    },
    {
        "link": "https://forum.arduino.cc/t/issues-reading-two-flow-sensors-using-interrupts/583063",
        "document": "The Arduino programming language Reference, organized into Functions, Variable and Constant, and Structure keywords."
    },
    {
        "link": "https://deepbluembedded.com/arduino-interrupts-tutorial-examples",
        "document": "In this tutorial, we’ll discuss Arduino Interrupts from the very basic concepts all the way to implementing Arduino interrupt-based systems. We’ll start off by discussing what are interrupts, how they work, and what are different types of interrupts. You’ll learn all Arduino interrupts mechanics and how to properly set up an interrupt-based system and write efficient ISRs (interrupt service routines).\n\nWe’ll create a couple of Arduino Interrupt Example Code Projects in this tutorial to practice what we’ll learn all the way through. And finally, we’ll draw some conclusions and discuss some advanced tips & tricks for Arduino interrupts that will definitely help you take some guided design decisions in your next projects. Without further ado, let’s get right into it!\n• Why & When To Use Interrupts?\n\nTo better understand interrupts in microcontrollers like Arduino (Atmega328p), Let’s consider the following analogy as an example to demonstrate how interrupts actually work.\n\nFirst of all, let’s say you are acting as the (CPU) and your main task is to read a book. But your friend can call you on the phone at any moment to check how you’re doing. Therefore, the phone ringing is considered an interrupt, and your answering the phone is the handling of this interrupt signal.\n\nWhen the phone rings, you need to bookmark or save where you’re currently on the book ( let’s page x, line y). Then, you pick up the phone and get done with it. And you can continue the main work (reading the book) exactly where you left off (page x, line y).\n\nIf you’re receiving too many calls or taking too long to service each call, you’ll never progress through the main, and most important, task which is reading the book. And this is exactly why we need to limit the number of interrupts the CPU receives per second and also make the ISR (interrupt service routine) handlers as quick as possible.\n\nInterrupts are side tasks that the CPU needs to handle as soon as they arrive and it should not take too long doing so. Otherwise, the main program execution will greatly slow down and the responsiveness of the whole system will also deteriorate.\n\nThe actual interrupt handling mechanism in Arduino (Atmega328p) microcontroller is very similar to the previous analogy example in the previous section. And it goes like this:\n\nWhen the microcontroller’s CPU receives an interrupt signal, it pauses the main program execution and saves its current context.\n\nThe CPU then jumps to the interrupt vector (address) where the corresponding ISR handler function is located. And starts executing that ISR handler function till completion.\n\nThen, the CPU restores back the context of the main program and jumps back to where it left off the main program. And everything resumes as it used to before the arrival of the interrupt signal.\n\nWhen a new interrupt is fired, the CPU will immediately be notified and all previous steps will be repeated again. Otherwise, the CPU will keep executing the main program (super loop() function).\n\nInterrupts can be categorized based on their type into different categories as we’ll discuss in this section. Each interrupt type has a unique set of features, advantages, and disadvantages. And it’s totally dependent on what your actual microcontroller supports.\n\nSoftware interrupts are interrupt signals that can be fired with specific software instructions. Some microcontrollers support native software interrupt instructions while others don’t have dedicated assembly instructions for the CPU to get an interrupt from the software.\n\nOther techniques can be implemented to programmatically enforce an interrupt to the CPU within your software even if it doesn’t have a soft interrupt instruction. This of course requires some workarounds but it’s not that hard to do in general.\n\nA software interrupt can be referred to as a Trap as well. Which is a technique to signal the CPU within the software to change the mode, throw an error, indicate an arithmetic error, or signal the OS.\n\nHardware interrupts are generated by hardware peripherals in the microcontroller itself (like Timers, External IRQ pins, UART, SPI, etc.). Hardware modules fire various interrupt signals so the CPU gets notified about it and handles them as quickly as possible.\n\nInternal interrupts are generated by internal events within the microcontroller itself, such as timers, ADC, UART, or any other peripheral events.\n\nExternal interrupts on the other hand are triggered by external signals applied to specific pins of the microcontroller. Those pins are usually referred to as IRQ pins (interrupt request pins). Which directly fire interrupt signals to the CPU when a certain external event occurs, that’s why those interrupts are known as external interrupts.\n\nThe most common types of IRQ pins are dedicated external interrupt pins and IOC (interrupt-on-change) pins. The difference is that dedicated external IRQ pins have separate interrupt vectors, while IRQ IOC pins share a common interrupt signal and you have to manually check which pin state has changed and caused that IOC global flag to fire the interrupt.\n\nA vectored-quantity in physics is a quantity that has a magnitude and a direction. Similarly, a vectored interrupt is an interrupt signal that has a specific address (vector) that points to the memory location where its ISR handler is located. So when an interrupt is fired, the CPU goes directly to the corresponding interrupt vector to execute the respective ISR handler.\n\nThis means, in vectored-interrupts systems, we’ll have a dedicated ISR handler for each interrupt signal that we’re using in the system. For example, here is how to handle two interrupt sources (INT0, and TMR1) in a vectored-interrupts system.\n\nAs you might have noticed, there are two separate ISR handlers for each interrupt signal source and each one has its own vector (address).\n\nNon-Vectored Interrupts, on the other hand, share a common global interrupt vector (address) for all interrupt signal sources. This means you need to manually check which interrupt has occurred and service them after validating the interrupt flag bits. This has to be done each time any interrupt is fired.\n\nHere is an example of how to handle two interrupt sources (INT0, and TMR1) in a non-vectored interrupts system.\n\nAs you might have noticed, there is only one global ISR handler for all interrupt sources. And we had to manually check the interrupt flag bits (INT0IF & TMR1IF) to detect which interrupt has occurred and service it accordingly.\n\nMaskable interrupts can be programmatically enabled or disabled using dedicated interrupt enable/disable bits. Maskable interrupts can be enabled or disabled during runtime using software instructions which can be helpful in a lot of applications.\n\nNon-Maskable interrupts on the other hand are always enabled by default and there is no way to disable them by software instructions in runtime. Things like RESET, WDT (watchdog timer), BOD (brown-out detection or power failure), and hardware failures are common non-maskable interrupts that you can’t disable in software.\n\nWhy & When To Use Interrupts?\n\nWe typically use interrupts in embedded systems as a better alternative for event polling mechanism which keeps the CPU blocked in a busy-waiting state waiting for something to happen. Interrupts on the other hand saves the CPU time from being wasted in unnecessarily polling events & peripherals. And provides a near-immediate response to various events instead.\n\nBut there are so many other reasons to use interrupts in embedded systems other than replacing polling instructions. Here are some other situations and use cases for interrupts:\n\nTime-Critical Tasks: When certain tasks require immediate attention and cannot be delayed by the main program flow, interrupts provide a way to handle them immediately.\n\nReal-Time Event Handling: Interrupts allow quick responses to external events, such as button clicks, sensor readings, or communication signals, enabling the microcontroller to react instantly.\n\nEfficient CPU Time Utilization: By using interrupts, the microcontroller can multitask and handle multiple events concurrently, optimizing resource utilization and ensuring smooth operation.\n\nPrecise Timing Requirements: For tasks that require precise timing or synchronization, timer interrupts can be used to trigger actions at specific moments or time intervals.\n\nEnergy Efficiency: Interrupts enable the microcontroller to stay in a low-power mode until an external event occurs, reducing power consumption and prolonging battery life in portable devices.\n\nThe ISR (Interrupt Service Routine) is a dedicated function that the CPU executes in response to an interrupt event. It is responsible for handling the specific task associated with the interrupt signal. When an interrupt occurs, the microcontroller jumps to the ISR handler function, executes it, and returns to where it left off the main program.\n\nISRs should be kept short and efficient to minimize the disruption of the main program flow. They should focus on completing the critical tasks associated with the interrupt and avoid unnecessary delays or time-consuming operations.\n\nAn ISR handler function should have a unique identifier that designates an ISR function from a general-purpose user-defined function. This varies from one toolchain to another, each compiler has its own syntax to define an ISR function (whether it’s vectored or non-vectored ISR handler).\n\nAs stated earlier, Arduino’s Atmega328p microcontroller has a vectored-interrupt system. This means we need to define an ISR handler function for each interrupt signal being used in the system. Here is an example of the Timer1 overflow interrupt handler definition.\n\nSimilarly, other interrupt signals can be handled by ISR functions written in the same way as the one shown above. Which we’ll see in this tutorial’s examples hereafter.\n\nIn this section, we’ll shift the focus from general interrupts working principles and mechanisms to discuss Arduino Interrupts in detail. We’ll explore Arduino interrupt types, available features, and more other details.\n\nIt’s stated clearly in the Arduino UNO’s Atmega328p datasheet that it doesn’t have a dedicated assembly instruction to trigger a software-generated interrupt signal. But as we’ve stated earlier, we can still implement some workarounds to fire software-generated interrupt signals.\n\nOne technique to generate a software interrupt is clearly stated in the datasheet itself. Which is to enable any external interrupt pin (IRQ) and set it as an output pin. Writing to any pin of these will trigger an interrupt, and that’s how we get a software-generated interrupt even if it’s not supported by the microcontroller.\n\nCheck this tutorial below for more information about Arduino Software Interrupts and to get some code examples as well as some useful tips and tricks.\n\nThe Arduino hardware peripherals have the ability to generate various interrupt signals to the CPU, which include but are not limited to the following hardware interrupt signals:\n\nThe full list of hardware interrupt signals supported by the Atmega328p microcontroller can be found in the datasheet. We’ll only use the INTx external interrupt request (IRQ) pin in this tutorial’s examples. Later on, we’ll explore other hardware interrupts & how to handle them in separate future tutorials in this Arduino Programming Series.\n\nInterrupt priority affects the overall system in only one situation. Which is when two interrupts are fired at the exact same time or the CPU found more than one interrupt flag raised at the same time. Only then, the interrupt priority rule decides which interrupt gets serviced first.\n\nThe Arduino interrupts system doesn’t support explicit interrupt priority assignation. However, interrupts are executed based on their interrupt vector address, the lower the address the higher the priority.\n\nBy relocating and re-arranging the interrupt vector table, we can change the interrupt priorities to match the need. The default interrupt vector table is found in the datasheet and we’ll check it together later on in this tutorial.\n\nInterrupt nesting is having interrupts to interrupt the execution of the current interrupt handler (ISR). There is a control bit that enables or disables this feature. When enabled, interrupts can get interrupted by other interrupt signals. After completion, the CPU will restore context and keep servicing all interrupt requests till completion, then it gets back to the main context (program flow).\n\nWe’ve always learned that Interrupts Nesting is Evil and we should never release software with nested interrupts enabled. However, it can be very helpful for debugging, assessment, and measurements. But it makes the system insanely unpredictable, and you can easily end up having your CPU servicing interrupts all the time without making progress in running the main program at all.\n\nThere is no guarantee that your system will run as expected without getting stuck processing endless chains of interrupt requests. Even safety mechanisms like WDT and such won’t help us get out of such a situation.\n\nAll in all, it’s what it’s and you only need to know that it does exist and we can enable interrupts to interrupt each other. And this is done by writing to the I-bit in the status register (SREG) as stated in the datasheet.\n\nNow, let’s see how to use Interrupts in Arduino, which functions are associated with interrupts in Arduino, IRQ pins, trigger modes, and much more.\n\nSpeaking of the dedicated IRQ pins (external interrupt pins) in Arduino, they are different from one Arduino board to another. Here is a summarized table for the external interrupt pins available in each Arduino board.\n\nLet’s take Arduino UNO as an example, it’s got (pins 2 & 3) that correspond to external interrupts (INT0 & INT1) respectively. Note that the interrupt vector number is different than the Arduino IO pin number itself. For this, we use the digitalPinToInterrupt() function that maps the IO pin number to the respective interrupt vector number automatically for us.\n\nThe PCINT (pin-change interrupt) is available in all IO pins across the entire Arduino boards list but you need to check the target microcontroller’s datasheet for further details regarding the pin-change interrupts.\n\nThe Arduino external interrupt pins fire an interrupt when the digital state of the associated pin has changed. The pin change event that triggers an interrupt can be configured to have one of the following modes:\n• RISING: Interrupt fires when the signal goes from LOW to HIGH\n• FALLING: Interrupt fires when the signal goes from HIGH to LOW\n• CHANGE: Interrupt fires when the signal changes (LOW -> HIGH or HIGH -> LOW)\n• LOW: Interrupt fires whenever the signal is held LOW\n\nThis gives us (programmers) the flexibility to choose the pin change mode that suits the application we’re working on. Each interrupt trigger mode is useful in a particular system configuration. And below is an example to demonstrate this.\n\nAs stated earlier, interrupt vectors are the addresses for different ISR handlers one for each interrupt signal. We need to know the name of the interrupt vector associated with the interrupt signal that we’d like to use & write an ISR handler for.\n\nTherefore, you can reference the Arduino interrupt vector table below which includes the interrupt vector names that you can use in code.\n\nTo write an ISR handler function in Arduino, you need to name it ISR(vector_name) and include the vector name in the space of the argument. The vector name for each interrupt signal in Arduino can be found in the table shown above.\n\nAnd here is an example of an ISR handler function to the Timer1 overflow interrupt signal.\n\nAnd here is another example of an ISR handler function to the INT0 external interrupt IRQ pin (IO pin2).\n\nAnd so on for any other interrupt signal that you’d like to use & write an ISR handler for.\n\nThe Arduino attachInterrupt() function is used to enable the external interrupt (IRQ) pins only (INT0 & INT1).\n\ninterrupt: the number of the interrupt vector ( int).\n\nISR: the ISR handler function to call when the interrupt occurs. This function must take no parameters and return nothing.\n\nmode: defines when the interrupt should be triggered. Four constants are predefined as valid values:\n• RISING to trigger when the pin goes from low to high,\n• FALLING for when the pin goes from high to low.\n• CHANGE to trigger the interrupt whenever the pin value changes\n• LOW to trigger the interrupt whenever the pin is low,\n\nThe Due, Zero and MKR1000 boards allow also:\n• HIGH to trigger the interrupt whenever the pin is high.\n\nThe Arduino detachInterrupt() function is used to disable external interrupts (INTx) if being enabled earlier. This can be really useful if you no longer need the external interrupt pin in your application, it’s better to offload the CPU by shutting down interrupt sources that are no longer needed.\n\ninterrupt: the number of the interrupt vector to be disabled ( int).\n\npin: the pin number of the interrupt to disable.\n\nSometimes, under certain circumstances, you may need to have a critical section in your code. Which is usually a couple of instructions that you want the CPU to run through without getting interrupted. This can be achieved by disabling and re-enabling the global interrupts in the microcontroller.\n\nArduino (Atmega328p) has a global interrupt enable/disable control bit that you can use for this purpose. There are two wrapper functions for this functionality that you can use instead of direct bit manipulation.\n\nKeep in mind that you should minimize the utilization of this feature as much as possible. And it’s going to disrupt the timing functions (like millis, micros, and delay functions). Check out the tutorial below to learn more about Arduino global interrupts control functions ( interrupts, noInterrupts, sei, and cli).\n\nIn this example project, we’ll test Arduino external interrupt pins & write an ISR function to handle it. We’ll use INT0 interrupt to toggle an LED output on every rising edge on the external interrupt input pin (hooked to a push button).\n\nHere is the wiring diagram for this example showing how to connect the LED output, and the push button to the interrupt input pin (INT0 = pin2).\n\nHere is the full code listing for this Arduino External Interrupt Example.\n\nWe first need to define the IO pins to be used for the LED output & push button input (INT0 external interrupt pin = IO pin2).\n\nThis is the ISR handler function for the INT0 external interrupt in which we’ll only do a LED toggle action. For each RISING edge on the external interrupt pin (push button), the CPU will execute this ISR function which will toggle the output LED.\n\nin the setup() function, we’ll initialize the IO pins to be used as input & output using the pinMode() function to set their modes.\n\nThen we’ll enable the external interrupt for the INT0 (pin2) using the attachInterrupt() function & set it to trigger on RISING edge events only.\n\nin the loop() function, nothing needs to be done.\n\nHere is the simulation result for this project on the TinkerCAD simulator. You can run it as is, or make a copy and add your own code and start running the simulation to see how it’s going to behave.\n\nYou can check this simulation project on TinkerCAD using this link.\n\nHere is a demo video for testing this project on my Arduino UNO board.\n\nNote that this example project will behave in a weird way due to an issue that’s commonly known as “Button Bouncing“. This is simply a random event due to the button’s mechanical contacts bouncing, which results in some glitches or unintended pulses being injected into the digital input pin causing it falsely trigger the interrupt multiple times “randomly”.\n\nDespite the fact that there are so many software button debouncing techniques (algorithms) that you can learn about from the guide below, it still won’t protect an external interrupt pin because the hardware bouncing is sending a random triggering signal to the interrupt circuitry. The best way to deal with it and prevent false interrupt triggering is to use hardware button debouncing which is also demonstrated in the guide tutorial below with a lot of examples.\n\nInterrupts provide a very efficient way for the CPU to immediately respond to various internal & external events as soon as they arrive. However, having too many interrupts in your system and non-careful implementation for ISR handlers can hold your system back or cause it to potentially fail in many cases.\n\nI remember working on an Automotive ECU that had a microcontroller that was receiving 10k interrupts per second to run the main data sampling & control loop, plus multiple other thousands of interrupts for other sensing & communication purposes. And you won’t be surprised to know that the CPU load was in the 90s% of course.\n\nThe nature of the system dictated to have such an insane amount of interrupt signals to the CPU each and every second, and we can’t change that while maintaining the measurement resolution & control frequency. But we can, however, optimize our ISR handlers and we actually did. And that alone brought the CPU load down to 60-ish%.\n\nTry to make the ISR handler function as short as possible and avoid bloating it with a lot of logic operations and other stuff. Just keep it as simple as possible and, if needed, you can raise a global flag, check in the main program, and use it for logic activation to call a separate function that handles whatever logic you need to do. There are so many other ways to optimize the size of an ISR handler function and make it much smaller and quicker.\n\nMake it as fast as possible\n\nAs we’ve illustrated earlier, you always need to have very fast ISR handler functions. We don’t want to spend so much time processing each interrupt request. So avoid doing heavy arithmetic & floating-point operations in ISR handler functions as much as possible.\n\nYou need also to avoid serial communication functions, polling variables & flags, and any other kind of low-speed operations inside ISR handler functions. And here is a simple example to demonstrate how can we accelerate the ISR execution without affecting the overall system functionality.\n\nWe’ll read the ADC using a timer interrupt each 20ms (50Hz update rate) and convert the reading to analog voltage and print it to the serial port. Here is how to do it without caring about the ISR speed.\n\nAnd here is how to perform the same functionality but with a much better optimized ISR implementation.\n\nThe execution time measurement for the non-optimized ISR handler came to around 500μs, while the optimized version of the ISR takes around 100μs. Which is a 5x times less CPU time utilization without sacrificing anything at all. Here are the execution time measurement results from my oscilloscope.\n\nYou can run the tests on your own using a virtual oscilloscope in Arduino Proteus Simulation Environment. And using the technique illustrated in this ADC Tutorial For analogRead Function Speed Measurement. You can use the same code to measure the execution time of ISR handlers and compare the results on your side.\n\nNeedless to say that you should not use any sort of delay functions within an ISR handler function. It’ll simply increase the execution time of the ISR for no reason as it can be avoided in the first place with more careful implementations.\n\nTry to find an alternative way to achieve the timing behavior you want without using a delay within any ISR handler function. We’ll discuss more techniques to do this efficiently in this Arduino Programming Series of Tutorials.\n\nVariables used in ISRs must be volatile\n\nVariables used within ISR handler functions must be defined as volatile to protect them from being discarded (optimized out) by the compiler during the code compilation process. Compilers tend to remove global variables that are only used inside ISRs because they think those variables are not used anywhere in the code. And here is an example to demonstrate this.\n\nConsider the following code example.\n\nIn the code above, the ISR function increments the global variable counter each time it gets executed. But the INT0_ISR function itself is not called anywhere in the code. The CPU jumps to it whenever a hardware interrupt signal is fired.\n\nThat’s why the compiler thinks this variable is not used because no one is calling the INT0_ISR function in the whole program. Therefore, it’s going to remove it during the code optimization step. But defining the variable as volatile will protect it against this anyway. And that’s why you need to do it as well.\n\nWhen working with interrupts, it’s important to remember not to use time-related functionalities within your interrupt routines. Let’s explore the details of the four main time functions and their behavior in interrupts:\n• delay(): The delay() function relies on interrupts, so it won’t function properly within an ISR handler function. It’s crucial to keep interrupts fast, and using delay() inside interrupts is not recommended by any means.\n• delayMicroseconds(): While delayMicroseconds() would work as expected, it’s generally advised to avoid using it within interrupts. Prolonged execution in an interrupt can introduce various problems, as discussed earlier.\n• millis(): This function returns the time elapsed since the Arduino program started, measured in milliseconds. However, inside an ISR, other interrupts are temporarily halted, so the value returned by millis() will remain unchanged within the interrupt function. While the last stored value will be correct, it won’t increase during the execution of the interrupt function. And the CPU may get stuck waiting for it to change, potentially forever.\n• micros(): Similar to millis(), This function returns the elapsed time but in microseconds. At the start of an interrupt, micros() would work just as fine. However, after some time, the accuracy of micros() may be compromised, leading to a potential drift whenever micros() is used thereafter. Again, the key advice is to keep your interrupts short and fast to avoid issues.\n\nIn summary, it’s best to avoid relying on these time functions within ISR handler functions. If you need to compare durations or debounce a button, it’s possible to implement such logic in your main code rather than within the interrupt service routine. Interrupts should primarily be used to instantly notify changes in the monitored signals (interrupt sources).\n\nBefore concluding this tutorial, I’d like to highlight some interesting points about Arduino interrupts that you need to know. This will help you take guided design decisions & prevent potential issues while working on your next Arduino projects.\n\nContext saving and restoration is a process that the CPU needs to do just to smoothly switch between main program execution and ISR handlers. It needs to save the current CPU registers, program counter address, and shadow registers. This is the only way the CPU can know where it left off before jumping to the interrupt vector to execute the ISR function located there.\n\nAfter finishing the execution of the ISR handler function, the CPU needs to remember where it left off the main program to continue from that point. Therefore, context restoration is needed. So it pops up all saved addresses and registers (context) and jumps back to where it left off the main program.\n\nContext saving and switching take time for the CPU to do and we call it interrupt latency. And it happens every time an interrupt signal is received, so if your system is set up in such a way that the CPU receives thousands of interrupts per second, you definitely need to assess the effect of interrupt latency & its contribution to the whole CPU load measurement.\n\nThis topic is demonstrated in detail with a couple of measurement techniques in the tutorial linked below which is highly recommended to read, so make sure to check it out.\n\nThis was stated earlier in this tutorial, but I’d like to highlight it again. Using interrupts adds to the overall unpredictability of your system’s dynamic (timing) behavior and makes it harder to analyze.\n\nUsing excessive interrupt rates will dramatically load the CPU and potentially cause it to fail, miss deadlines, and mess up the timing behavior and requirements. So you not only need to carefully implement & optimize ISR handler functions, but you also need to question the usage of interrupts in the first place and if there is a better alternative or not.\n\nHere is an example: using an optical encoder sensor to measure a motor’s speed, can be achieved using interrupts. But it’ll generate high-frequency pulses (high interrupts rate) and is going to dramatically increase the CPU load.\n\nWhile we could have done that using the internal timer in counter mode to count the pulses over fixed time intervals to detect the motor’s RPM speed without even using interrupts at all. And there are so many other applications that can be accelerated using internal hardware peripherals without completely relying on interrupts. Especially when it’s going to generate high-frequency interrupt signals that would unnecessarily load the CPU.\n\nTo conclude this tutorial, we’d like to highlight the fact that the Arduino interrupts are very useful in so many applications in which you need your Arduino to immediately respond to various events as soon as they arrive. And it needs careful implementation for the ISR handler functions to keep it as efficient as possible. While, sometimes, you may need to avoid using interrupts in the first place.\n\nThis tutorial is a fundamental part of our Arduino Series of Tutorials because we’ll build on top of it to interface various sensors and modules with Arduino in other tutorials & projects. So make sure you get the hang of it and try all provided code examples & simulations (if you don’t have your Arduino Kit already).\n\nIf you’re just getting started with Arduino, you need to check out the Arduino Getting Started [Ultimate Guide] here."
    },
    {
        "link": "https://forum.arduino.cc/t/control-water-pump-with-l298n-motor-drive/1196752",
        "document": "The \"minimum output voltage\" is zero. The maximum output voltage is the supply voltage, less about a couple of volts.\n\nIt will not output any voltage except the minimum and maximum. That's what PWM does. Let's say the supply voltage is 10V. The output voltage is only ever 0V or ~8V.\n\nHowever, by varying the PWM \"duty cycle\" you can vary the output voltage.\n\nTo get an average 3V output with 10V input, you would set the duty cycle to about 3/(10-2)*255 = 95. For 6V output, set the duty cycle to about 190."
    },
    {
        "link": "https://howtomechatronics.com/tutorials/arduino/arduino-dc-motor-control-tutorial-l298n-pwm-h-bridge",
        "document": "In this Arduino Tutorial we will learn how to control DC motors using Arduino. We well take a look at some basic techniques for controlling DC motors and make two example through which we will learn how to control DC motors using the L298N motor driver and the Arduino board.\n\nYou can watch the following video or read the written tutorial below.\n\nWe can control the speed of the DC motor by simply controlling the input voltage to the motor and the most common method of doing that is by using PWM signal.\n\nPWM, or pulse width modulation is a technique which allows us to adjust the average value of the voltage that’s going to the electronic device by turning on and off the power at a fast rate. The average voltage depends on the duty cycle, or the amount of time the signal is ON versus the amount of time the signal is OFF in a single period of time.\n\nSo depending on the size of the motor, we can simply connect an Arduino PWM output to the base of transistor or the gate of a MOSFET and control the speed of the motor by controlling the PWM output. The low power Arduino PWM signal switches on and off the gate at the MOSFET through which the high power motor is driven.\n\nOn the other hand, for controlling the rotation direction, we just need to inverse the direction of the current flow through the motor, and the most common method of doing that is by using an H-Bridge. An H-Bridge circuit contains four switching elements, transistors or MOSFETs, with the motor at the center forming an H-like configuration. By activating two particular switches at the same time we can change the direction of the current flow, thus change the rotation direction of the motor.\n\nSo if we combine these two methods, the PWM and the H-Bridge, we can have a complete control over the DC motor. There are many DC motor drivers that have these features and the L298N is one of them.\n\nThe L298N is a dual H-Bridge motor driver which allows speed and direction control of two DC motors at the same time. The module can drive DC motors that have voltages between 5 and 35V, with a peak current up to 2A.\n\nLet’s take a closer look at the pinout of L298N module and explain how it works. The module has two screw terminal blocks for the motor A and B, and another screw terminal block for the Ground pin, the VCC for motor and a 5V pin which can either be an input or output.\n\nThis depends on the voltage used at the motors VCC. The module have an onboard 5V regulator which is either enabled or disabled using a jumper. If the motor supply voltage is up to 12V we can enable the 5V regulator and the 5V pin can be used as output, for example for powering our Arduino board. But if the motor voltage is greater than 12V we must disconnect the jumper because those voltages will cause damage to the onboard 5V regulator. In this case the 5V pin will be used as input as we need connect it to a 5V power supply in order the IC to work properly.\n\nWe can note here that this IC makes a voltage drop of about 2V. So for example, if we use a 12V power supply, the voltage at motors terminals will be about 10V, which means that we won’t be able to get the maximum speed out of our 12V DC motor.\n\nNext are the logic control inputs. The Enable A and Enable B pins are used for enabling and controlling the speed of the motor. If a jumper is present on this pin, the motor will be enabled and work at maximum speed, and if we remove the jumper we can connect a PWM input to this pin and in that way control the speed of the motor. If we connect this pin to a Ground the motor will be disabled.\n\nNext, the Input 1 and Input 2 pins are used for controlling the rotation direction of the motor A, and the inputs 3 and 4 for the motor B. Using these pins we actually control the switches of the H-Bridge inside the L298N IC. If input 1 is LOW and input 2 is HIGH the motor will move forward, and vice versa, if input 1 is HIGH and input 2 is LOW the motor will move backward. In case both inputs are same, either LOW or HIGH the motor will stop. The same applies for the inputs 3 and 4 and the motor B.\n\nNow let’s make some practical applications. In the first example we will control the speed of the motor using a potentiometer and change the rotation direction using a push button. Here’s the circuit schematics.\n\nSo we need an L298N motor driver, a DC motor, a potentiometer, a push button and an Arduino board.\n\nYou can get the components needed for this Arduino Tutorial from the links below:\n\nDisclosure: These are affiliate links. As an Amazon Associate I earn from qualifying purchases.\n\nDescription: So first we need to define the pins and some variables needed for the program. In the setup section we need to set the pin modes and the initial rotation direction of the motor. In the loop section we start by reading the potentiometer value and then map the value that we get from it which is from 0 to 1023, to a value from 0 to 255 for the PWM signal, or that’s 0 to 100% duty cycle of the PWM signal. Then using the analogWrite() function we send the PWM signal to the Enable pin of the L298N board, which actually drives the motor.\n\nNext, we check whether we have pressed the button, and if that’s true, we will change the rotation direction of the motor by setting the Input 1 and Input 2 states inversely. The push button will work as toggle button and each time we press it, it will change the rotation direction of the motor.\n\nSo once we have learned this, now we can build our own Arduino robot car. Here’s the circuit schematic:\n\nAll we need is 2 DC Motors, the L298N motor driver, an Arduino board and a joystick for the control. As for the power supply, I chose to use three 3.7V Li-ion batteries, providing total of 11V. I made the chassis out of 3 mm tick plywood, attached the motors to it using metal brackets, attached wheels to the motors and in front attached a swivel wheel.\n\nNow let’s take a look at the Arduino code and see how it works. (Down below you can find the complete code)\n\nAfter defining the pins, in the loop section, we start with reading the joystick X and Y axis values. The joystick is actually made of two potentiometers which are connected to the analog inputs of the Arduino and they have values from 0 to 1023. When the joystick stays in its center position the value of both potentiometers, or axes is around 512.\n\nWe will add a little tolerance and consider the values from 470 to 550 as center. So if we move the Y axis of joystick backward and the value goes below 470 we will set the two motors rotation direction to backward using the four input pins. Then, we will convert the declining values from 470 to 0 into increasing PWM values from 0 to 255 which is actually the speed of the motor.\n\nSimilar, if we move the Y axis of the joystick forward and the value goes above 550 we will set the motors to move forward and convert the readings from 550 to 1023 into PWM values from 0 to 255. If the joystick stays in its center the motors speed will be zero.\n\nNext, let’s see how we use the X axis for the left and right control of the car.\n\nSo again, first we need to convert the X axis readings into speed values from 0 to 255. For moving left, we use this value to decrease the left motor speed and increase the right motor speed. Here, because of the arithmetic functions we use two additional “if” statements to confine the range of the motor speed from 0 to 255.\n\nThe same method is used for moving the car to the right.\n\nRelated: How To Make a PWM DC Motor Speed Controller using the 555 Timer IC\n\nDepending on the applied voltage and the motor itself, at lower speeds the motor is not able to start moving and it produces a buzzing sound. In my case, the motors were not able to move if the value of the PWM signal was below 70. Therefore using this two if statements I actually confined to speed range from 70 to 255. At the end we just send the final motor speeds or PWM signal to the enable pins of the L298N driver.\n\nHere’s the complete code of the Arduino robot car example:\n\nSo that would be all for this tutorial, and in my next video we will upgrade this Arduino robot car, by adding a Bluetooth and Radio devices for enabling smartphone and wireless control.\n\nFeel free to ask any question in the comments section below and don’t forget to check my collection of Arduino Projects."
    },
    {
        "link": "https://forum.arduino.cc/t/pwm-with-arduino-and-l298n/1150869",
        "document": "Learn about L298N Motor Driver module along with PWM, H-bridge Working, Pinout, Wiring, Arduino Code for controlling speed & direction of DC motor."
    },
    {
        "link": "https://arduinoyard.com/l298n-motor-driver-with-arduino",
        "document": "The L298N Motor Driver Module is a powerful and versatile component that allows you to control the speed and direction of DC motors with an Arduino. It is commonly used in robotics, car projects, and other applications requiring motor control.\n\nThis guide will cover everything you need to know about using the L298N Motor Driver with Arduino, including wiring, code examples, and a detailed explanation of its working principle.\n• Output current up to 2A per channel\n\nThe L298N Motor Driver uses an H-Bridge circuit to control the direction and speed of motors.\n\nWhat is an H-Bridge?\n\nAn H-Bridge is an electronic circuit that allows a voltage to be applied across a load in either direction. It is commonly used to drive DC motors.\n\nAn H-Bridge consists of four switches (transistors or MOSFETs) arranged in an H shape:\n• When switches S1 and S4 are closed, the motor rotates in one direction.\n• When switches S2 and S3 are closed, the motor rotates in the opposite direction.\n• If S1 and S3 or S2 and S4 are closed simultaneously, it causes a short circuit, so this is avoided.\n• By controlling these switches, we can change the motor’s rotation direction.\n\nEach side of the motor can be connected to either the positive supply voltage or ground by switching the transistors. This allows current to flow through the motor in both forward and reverse directions. Speed can also be controlled by rapidly switching the transistors on and off using Pulse Width Modulation (PWM).\n• ENA and ENB (Enable Pins):\n• Used to enable or disable motors A and B.\n• Can be connected to PWM pins on the Arduino for speed control.\n• PWM allows controlling the speed of the motors by adjusting the duty cycle (0 to 255).\n• OUT1, OUT2 (Motor A Outputs):\n• Connected to the terminals of Motor A.\n• OUT3, OUT4 (Motor B Outputs):\n• Connected to the terminals of Motor B.\n• 12V:\n• Supports voltage from 5V to 35V depending on motor specifications.\n• 5V:\n• Provides 5V output when powered by 12V. Can be used to power the Arduino, but it’s safer to power Arduino separately.\n\nThis code controls two DC motors using the L298N motor driver.\n\nWhat to Expect from the Code\n\nThe following code will control Motor A:\n• It will move forward for 3 seconds.\n• It will then stop for 2 seconds.\n• It will move backward for 3 seconds.\n• It will stop again for 2 seconds.\n\nThis cycle will repeat continuously. You can modify the delays and motor speed according to your needs.\n\nThe ENA and ENB pins control motor speed using PWM signals (values between 0 and 255). A higher value means higher speed.\n• Overheating: Ensure the motor voltage and current are within the module’s limits.\n• Low Power: Use an external power supply for motors; avoid powering motors from the Arduino.\n\nThe L298N motor driver with Arduino is a versatile and cost-effective solution for controlling DC motors. Whether you’re building a robot or automating a system, the L298N module provides an easy and efficient way to control motor direction and speed.\n\nDo you have questions? Let us know in the comments! 🚀\n\nCheck out these helpful resources to learn more:\n• Autonomous Edge-Detection Robot with Arduino – Build a smart robot that avoids falling off edges.\n• Ultrasonic Sensor HC-SR04 with Arduino – Measure distance and detect obstacles using an ultrasonic sensor."
    },
    {
        "link": "https://dronebotworkshop.com/dc-motors-l298n-h-bridge",
        "document": "If you plan on working with robots or just building things that move you’ll eventually need to learn how to control a DC motor. The inexpensive L298N H-Bridge module is a simple way to achieve that. Coupling the L298N H-Bridge to a microcontroller like an Arduino will give you the ability to control both the speed and rotation direction of two DC motors.\n\nIn this article and it’s accompanying video I’ll show you everything you need to know to start adding some motion to your next Arduino project. So let’s get moving!\n\nThe first practical DC (Direct Current) motor was invented by the British scientist William Sturgeon in 1832. Since then DC motors have been part of countless pieces of equipment and machinery.\n\nToday DC motors range from huge models used in industrial equipment to tiny devices that can fit in the palm of your hand. They are inexpensive and are ideal for use in your Robotics, Quadcopter, and Internet of Things projects.\n\nUnlike LED’s you can’t just connect a DC motor to one of the output pins of your Arduino or Raspberry Pi and expect it to work. DC motors have current and voltage requirements that are beyond the capabilities of your microcontroller or microcomputer. It is necessary to use some external electronics to drive and control the motor, and you’ll probably need a separate power supply as well.\n\nThere are a number of ways to drive a DC motor from the output of your computing device. A single transistor can be used to drive a DC motor, this works well providing you do not need to change the direction that the motor is spinning.\n\nA more versatile way of controlling a DC motor is to use a circuit called an “H-Bridge”. An “H-Bridge” is an arrangement of transistors that allow you to control both the direction and speed of the motor. Today we’ll examine a very common H-Bridge module based around the L298N integrated circuit.\n\nIn a simple DC motor there are two main components, the “stator” and the “armature”. The stator is a permanent magnet and provides a constant magnetic field. The armature, which is the rotating part, is a simple coil.\n\nThe armature is connected to a DC power source using a 2-piece ring installed around the motor shaft, these ring sections are called “commutator rings”. The two pieces of the commutator rings are connected to each end of the armature coil. Direct Current of a suitable voltage is applied to the commutator rings via two “brushes” that rub against the rings.\n\nWhen DC is applied to the commutator rings it flows through the armature coil, producing a magnetic field. This field is attracted to the stator magnet (remember, opposite magnetic polarities attract, similar ones repel) and the motor shaft begins to spin.\n\nThe motor shaft rotates until it arrives at the junction between the two halves of the commutator. At that point the brushes come into contact with the other half of the commutator rings, reversing the polarity of the armature coil (or coils, most modern DC motors have several). This is great because at this point the motor shaft has rotated 180 degrees and the magnetic field polarities need to be reversed for the motor to continue rotating. This process repeats itself indefinitely until the current is removed from the armature coils.\n\nThe motor I have just described is referred to as a brushed DC motor because (obviously) it has brushes. Brushes, however, create many problems – they can start to wear over time, they rub against the motor shaft and they can even cause sparking as the motor gets older.\n\nBetter quality DC motors are the brushless variety. Brushless motors use a more complex arrangement of coils and do not require a commutator. The moving part of the motor is connected to the permanent magnet. Because they do not contain brushes these brushless motors will last longer and are also much quieter than brushed DC motors. Most quadcopter Motors are brushless motors.\n\nDC motors are specified by the voltage level at which they operate. Common hobbyist motors run at 6 Volts or 12 volts DC.\n\nTo reverse the direction in which the DC motor rotates you simply reverse the polarity of the DC current that you apply to it. Changing the speed however, is a different story.\n\nOne method of changing the speed of a DC motor is to simply reduce its supply voltage. While this will work to some degree it is actually not a very good method of controlling motor speed as lowering the voltage will also lower the torque that the motor is capable of producing. Also, once the voltage drops below a certain point the motor will not rotate at all.\n\nA far better method of controlling DC motors is to use pulse width modulation or PWM. If you’ve read up on controlling LEDs with your microcontroller you probably have already run into PWM as it’s also a good method of controlling the brightness of an LED.\n\nWith PWM the motor is sent a series of pulses. Each pulse is of the full voltage that the motor can handle so a 6-volt motor will be sent 6-volt pulses while a 12-volt motor will be sent 12 volt pulses. The width of the pulses are varied to control the motor speed, pulses with a narrow width will cause the motor to spin quite slowly. Increasing the pulse width will increase the speed of the motor, as illustrated below.\n\nIn order to stop the motor completely you just stop pulsing it, essentially sending it zero volts. To run it at full speed you send it the full voltage, again without pulsing it.\n\nYou can build a simple PWM generator using a 555 timer and discrete components but it’s a lot easier to use an Arduino. The Arduino has a function called “analogWrite” which is used to drive any of its PWM-capable outputs (the Arduino Uno has 6 digital outputs that are also capable of PWM).\n\nNow that you know how DC motors work, how you can reverse their direction by changing polarity and how you can change their speed using pulse width modulation, let’s examine an easy way to do this using a very common circuit configuration called an “H-Bridge”.\n\nAn “H-Bridge” is simply an arrangement of switching the polarity of the voltage applied to a DC motor, thus controlling its direction of rotation. To visualize how this all works I’ll use some switches, although in real life an H-Bridge is usually built using transistors. Using transistors also allows you to control the motor speed with PWM, as described above.\n\nIn the first diagram we can see four switches which are all in the open or “off” position. In the center of the circuit is a DC motor. If you look at the circuit as it is drawn here you can distinctly see a letter “H”, with the motor attached in the center or “bridge” section – thus the term “H-Bridge”.\n\nIf we close (i.e. turn on) two of the switches you can see how the voltage is applied to the motor, causing it to turn clockwise.\n\nNow we’ll open those switches and close the other two. As you can see this causes the polarity of the voltage applied to the motor to be reversed, resulting in our motor spinning counterclockwise.\n\nThis is pretty simple but effective. In fact if all you need to do is design a circuit to drive the motor full-speed in either direction you could actually build this as shown here, using a 4PDT (4 Pole Double-Throw) center-off switch. But of course we want to control the motor using an Arduino, so an electronic circuit where the switches are replaced by transistors is what we need.\n\nWhile you can use discrete transistors to build an H-Bridge there are a number of advantages in using an integrated circuit. A number of H-Bridge motor driver IC’s are available and all of them work in pretty much the same fashion. One of the most popular is the L298N.\n\nThe L298N is a member of a family of IC’s that all have the designation “L298”. The difference between the family members is in the amount of current they can handle. The L298N can handle up to 3 amperes at 35 Volts DC, which is suitable for most hobby motors.\n\nThe L298N actually contains two complete H-Bridge circuits, so it is capable of driving a pair of DC motors. This makes it ideal for robotic projects, as most robots have either two or four powered wheels. The L298N can also be used to drive a single stepper motor, however we won’t cover that configuration in this article.\n\nHere is a diagram of the pinouts of an L298N integrated circuit:\n\nAlthough you can certainly purchase an L298N integrated circuit and wire it up yourself it is far easier to just buy a complete L298N circuit board, which is wired up and complete with connectors for motors, power supplies and input logic. These boards also have a 5 volt voltage regulator which can be used to supply the logic circuits. L298N driver boards are available from a number of sources like eBay or your local electronics shop at very reasonable prices.\n\nYou’ll find a few different styles of L298N boards but they all operate in the same fashion. The board contains an L298N mounted on a heatsink, a 5 volt voltage regulator to “optionally) provide power for logic circuits, supporting diodes and capacitors and connectors as follows:\n• An optional 5 Volt power input for the logic circuits.\n\nYou’ll notice that the board also has a number of jumpers. Most of the time you will leave them in place, with the exception of one. They are as follows:\n• CSA – This is the “current sensing” function for Motor A. If the jumper is in this function is ignored. Most of the time you’ll leave this jumper in place.\n• CSB – The “current sensing” function for Motor B. Again you’ll usually just leave this in place to disable this function.\n• U1 – Input 1 pull-up resistor. You will usually leave this in place, which enables a 10k pull-up resistor for the input.\n• 5v-EN – This is the only jumper that you need to really pay attention to. When this jumper is in place it enables the boards internal 78M05 5 Volt regulator, supplying logic power from the motor power supply. When this jumper is enabled you will NOT supply 5 volts to the 5 Volt input terminal. When the jumper is removed you will need to supply 5 Volts to the 5 Volt input terminal.\n\nIf you do use the internal voltage regulator you’ll have to supply the motor power supply with at least 7.5 volts.\n\nSpeaking of the motor power supply it needs to be a bit higher voltage than the actual motor requirements. This is due to the internal voltage drop in the transistors that form the H-Bridge circuit. The combined voltage drop is 1.4 volts, so if you are using 6 Volt motors you’ll need to give the board 7.4 volts, if you have 12 volt motors then your motor supply voltage will need to be 13.4 volts.\n\nThe board has four input terminals plus two enable terminals. You will use these terminals to control both direction and speed or each motor. They are as follows:\n\nIn order to simplify things a bit I’ll just discuss the inputs and enable for Motor A, Motor B functions identically.\n\nThe two Input lines control the direction that the motor rotates. I will call one direction “forward” and the other one “reverse”, if it makes more sense to you just substitute “clockwise” and “counterclockwise”.\n\nYou control motor direction by applying either a Logic 1 (5 Volts) or Logic 0 (Ground) to the inputs. This chart illustrates how this is done.\n\nAs you can see only two combinations are actually used to control the direction of the motors rotation.\n\nThe Enable line can be used to turn the motor on, to turn it off and to control its speed. When the Enable line is at 5 Volts (1) the motor will be on. Grounding the Enable line (0) will turn the motor off.\n\nTo control the speed of the motor you apply a Pulse Width Modulation (PWM) signal to the Enable line. The shorter the pulse width, the slower the motor will spin.\n\nWe can use a solderless breadboard, a pair of motors and a few jumpers to test the L298N module.\n\nYou’ll also need a power supply for the motors. In my experiment I used a second power supply to supply the 5 Volts for the logic circuitry but you could use one supply for both the motors and logic if you wish. Just be sure to set the 5 Volt Jumper properly (if you use one supply it should be in place, if you use two like I did remove the jumper).\n\nThe initial hookup looks like this:\n\nNote that both the motor and logic power supplies share a common ground. I’ve brought the 5 Volt supply with ground out to the solderless breadboard so it can be used to set logic levels.\n\nTo get things moving we will need to set the logic levels on the input and enable lines. In our first experiment we will set EN1, IN1 and IN3 to 5 Volts. The remaining inputs and enable line will be tied to ground.\n\nThis arrangement will cause Motor A to move in a forward direction. As the enable line for Motor B is at ground it will remain off.\n\nNow let’s enable Motor B by setting EN2 to 5 Volts.\n\nAs you might expect this causes both motors to rotate in a forward direction.\n\nNow we will change the inputs for Motor A, we will set IN1 to ground and IN2 to 5 Volts. The other connections will remain as they are.\n\nIf you understood the chart I showed you earlier with the input logic levels you won’t be surprised to see Motor A now moving in reverse. Motor B continues to move forward.\n\nYou can use this arrangement to experiment with controlling the motor direction, as well as enabling and disabling the two motors. But one thing that you can’t test this way is controlling motor speed. For this we will need to apply a PWM signal to the Enable lines. There are a number of ways of accomplishing this, for our next experiment we will do it using an Arduino.\n\nUsing an Arduino with the L298N\n\nBringing an Arduino or similar microcontroller into the picture allows us to control both the direction and speed of each motor. I am going to show you how to do this using an Arduino Uno but you can also accomplish the same thing with a Mega, Nano or other Arduino compatible controller.\n\nThe Arduino Uno has 14 digital Input/Output (I/O) pins, six of which are capable of supplying a PWM signal.\n\n The following diagram shows how I have hooked up the Arduino Uno to the L298N board.\n\nNote that the 5 Volts for the L298N board is now being supplied from the Arduino 5 Volt output. The Arduino itself is being powered via its USB cable, which of course will also allow you to load the sketch to make everything work. After the sketch is loaded you could remove the USB cable and power the Arduino with an external power supply (or a USB supply).\n\nThe input and enable lines in the L298N are driven from six Arduino digital output pins, as follows:\n\nI chose this pinout as Arduino output pins 9 and 3 are both capable of Pulse Width Modulation, if you wish you can use alternate pins. Just be sure to modify the sketch to reflect any pinout changes you make.\n\n Speaking of the sketch, here it is:\n\nThis sketch demonstrates a number of things we can do to control an L298N H-Bridge with an Arduino. You can play around with it to see what effects changing some values have and you can also use sections of it as the basis for other motor control sketcheds you want to create. It could also be used with other H-Bridge controllers as they all operate in a similar fashion.\n\nWe start out by defining integers to represent the digital output pins that will be used to drive the H-Bridge controller. This is good coding practice as it allows you to change pin numbers by just changing these values, allowing you to use the same sketch with different Arduinos. Just remember that the two enable pins, defined as enA and enB, need to be connected to outputs that support PWM.\n\nIn the setup function we define all of these pins as digital outputs.\n\nAfter that we define two functions. Once you understand how they work feel free to add more if you wish.\n• demoOne – this function spins both motors forward as a speed of 200 for two seconds. It then reverses the motors and spins them for another two seconds. Finally it turns off the motors.\n• demoTwo – this function spins the motors forward. First it accelerates them from zero to full speed, then it decelerates them back to zero. Again it turns the motors off when it is done.\n\nIn each of these functions Arduino’s analogWrite function is used to produce PWM signals at the digital outputs. If you plan on working with PWM it’s a very good function to know.\n\nIn the loop we just call the two functions, inserting a one second delay between them. This continues until you power off the Arduino.\n\nNow that we have the L298N H-Bridge controller working with the Arduino let’s expand upon it. Our demo sketch really isn’t that practical, especially if we are using our motors to drive a robot or toy car. What we really need is a way to take control ourselves. So let’s add some speed controls to our design.\n\nTake a look at the following diagram. Essentially we’ve taken the same circuit and have added a couple of potentiometers. Each potentiometer has one end tied to ground, the other end hooked to 5 volts and the wiper connected to an analog input pin ou the Arduino. The value of the potentiometers isn’t that critical, I used 25k pots as I happened to have a bunch of them but any value from 10k up would work. Going lower than 10k wouldn’t be a good idea though as that would start to consume a bit too much current from the Arduino 5 volt output.\n\nThe Arduino Uno has 8 analog input pins and again it really doesn’t matter which ones we use – if you decide to be daring and change pins simply modify the sketch accordingly. I used the first two – Potentiometer A is connected to analog input A0 while potentiometer B goes to analog input A1.\n\nTurning the pots will vary the voltage applied to the inputs from zero to 5 volts. In our sketch we will read these values as numbers from 0 to 1023 (the Arduino Uno has internal 10 bit analog to digital convertors).\n\nHere is the sketch that I used to take the analog values from the potentiometers and use them to control the motor speed. Note that in this sketch I haven’t made any provision to change motor direction.\n\nLet’s take a look at this sketch.\n\nWe begin in a similar fashion to our motor demo sketch, defining integers to represent output pins to control our H-Bridge. We also define a couple more integers for the analog inputs that we will use for the potentiometer inputs to A0 and A1. Again you can rewire to use other inputs and change this section of the sketch accordingly if you wish.\n\nAnother set of integers are also defined, MotorSpeed1 and MotorSpeed2. As their name implies these will hold the values to use to control the motor speeds for each motor. We initialize these with a value of zero so that our motors start out stationary.\n\nIn setup we simply set all the digital pins we defined earlier as outputs. No equivalent definition for the analog inputs is necessary as by nature these are always inputs.\n\nNow on to the loop. We start by setting the direction of both motors forward which is done by writing the proper values to the H-Bridge input pins.\n\nNext we read the values of each potentiometer using the analogRead function. As the Arduino uses an 10-bit A/D convertor this will produce a value ranging from zero to 1023, which is held in each MotorSpeed variable..\n\nWe need to convert these MotorSpeed values to a range of 0 – 255 and there are a few ways we could accomplish this. One method is to divide the values by 4, and this would work fine (try it an see). But a more eloquent method is to make use of Arduinos map function which takes a range of values and converts this to a different range of values. It’s a very handy function that you should get to know if you are not familiar with it.\n\nIn experimenting I found that my motors started to “buzz” or “sing” when fed very low PWM values (you may have noticed this during the demo sketch). To keep from this annoyance from occurring I popped a couple of if statements into the code to set any value below 8 to zero. You may need to adjust this value to suit your specific motor/ controller combination.\n\nFinally the analogWrite function is used to produce PWM pulses to the enable pins on the L298N H-Bridge Motor Controller.\n\nThis is actually a practical sketch and circuit as it allows us to control each motors speed independently using the two potentiometers. But it doesn’t allow us to control teh motor direction. This leads us to our final experiment, one that turns all that we learned into a practical arrangement for driving a small 2-motor robot car.\n\nOur circuit is now a lot more practical but it still lacks a simple way to change motor direction. We could use one of the unused digital pins on the Arduino as an input for a switch to solve this problem, but I thought it might be a bit more fun to use a joystick. If the two motors are mounted on a small toy car or robot base then the joystick would provide a fun way to drive our vehicle around the room!\n\nA joystick actually consists of three parts. First there are two potentiometers, one on the horizontal axis and the other on the vertical axis. The third part is a momentary contact switch (i.e a pushbutton) that is activated when you press down on the joystick handle.\n\nJoysticks usually have five connections:\n• Vcc – This is the +5 Volt connection\n• Sel – The output from the momentary contact switch\n\nPlease note that there are a variety of joysticks available and no apparent standard for ordering or labelling the connections. Be sure you know what connection goes where before you wire up your joystick. If you’re not sure and can’t find a hookup diagram you can usually determine the connections using a multimeter.\n\nOnce you’ve sorted out your joystick connections you can remove the two potentiometers we used in the last experiment and hook up the joystick as shown here.\n\nThe only real difference between this circuit and the previous one is that the joysticks’ internal potentiometers take the place of the two discrete potentiometers we used before. I chose not to use the pushbutton switch, if you wish you could tie it to an unused Arduino input pin and use it to beep a piezo buzzer or flash an LED. I’ll leave the customizing up to you!\n\nThe real fun with this setup lies in the sketch. Before we examine it let’s discuss how our project will work.\n• With the joystick resting in its center position the motors will be disabled. In our last experiment the only way to actually stop the motors was to set the speed to zero or unplug the power from the Arduino, not very convenient!\n• Pushing the joystick forward (i.e up) should move our car forward.\n• Pulling the joystick backward (i.e down) should make the car move backwards.\n• As we push the joystick to one side the car should respond by moving in that direction. We’ll do this by making one motor move faster than the other one.\n• Letting the joystick come to rest in the center position should stop the car.\n\nThe sketch I came up with to accomplish all this is as follows:\n\nThe sketch starts in a similar fashion to the one we used previously,integers are defined to represent the input pins for the motor input and enable lines. The two analog inputs are defined as “joyVert” (the joystick vertical or Y axis output) and “joyHorz” (the horizontal or X axis output). Once again the tow “MotorSpeed” integers represent the speed of each motor and are initially set to zero.\n\nI’ve also defined two integers to represent the value of each joystick axis position. Each has a range of 0 to 1023, so the middle position of each is approximately 512 (it’s actually 511.5, but as we are using integers I selected 512).\n\nIn the setup function the pins controlling the L298N H-Bridge controller are set as outputs and the motors are initialized as being disabled and with their directions set forward.\n\nNow to the loop, where the real action is!\n\nFirst thing we do is get the position of each joystick potentiometer by reading the value of the two analog input pins. We will use these values to determine what direction and speed we want our car to travel in. Keep the following bits of information in mind so that you understand the logic here:\n• The vertical or Y axis control determines if we are going forward or backwards, and how fast. As we push it up we are going forward, pulling it down indicates we want to go backwards. The further to the end we push, the faster we want to go. If we center the joystick then we want the motors to stop.\n• The horizontal or X axis control determines if we are moving to the left or right. Keep in mind that to move in one direction you need to spin the motor faster! So, for example, if I want to turn left I need to decrease the speed of the left motor and increase the speed of the right motor. If this control is centered then both motors should revolve at the same speed.\n\nNow that we have these concepts firmly in place let’s see how it’s accomplished in the sketch.\n\nIf our two joystick potentiometers are in the center position then we don’t want to move either motor. As I mentioned earlier the center positions should produce a value on our analog inputs of about 512, however in the real world the actual value will be “around 512” as the tolerances in the components isn’t perfect. I chose to allow plus or minus 10 percent, so I consider any value between 460 and 564 to be defined as “center”. You can experiment with these values if you wish to “fine tune” things to your own joystick.\n\nSo if the vertical potentiometer is less than 460 then we need to get it’s value and translate it into a speed, as well as move our motors backwards.\n\nMoving the motors backwards is simply a matter of setting the H-Bridge inputs properly, as we have done already. Getting the speed however requires a little bit of math, since we need the speed to increase when the analog input value decreases. No worries, as it’s fairly basic math – we just subtract 460 from the value of the analog input which gives us a negative number, then we convert this to a positive number by multiplying by negative one.\n\nFinally we get the number in our desired range of 0-255 using the handy “map” function as we did in the previous sketch.\n\nIf the vertical potentiometer is reading over 564 then we are going forward. The logic here is easier as the value goes up while the speed increases, so the “fancy math” isn’t required. Again we map these values to the range of 0-255.\n\nNow for the steering, which is controlled by the horizontal or X-axis potentiometer. Remember how this works:\n• We’ll be modifying the motor speed values we obtained using the vertical (Y-axis) analog inputs, adding or subtracting from them to make our car turn in the desired direction.\n• If the analog input value is less than 460 then we want to go to the left. The lower the value, the more to the left we want to turn\n• If the analog input value is over 564 then we want to turn right. In this case the higher the value the more to the right we want to go.\n• If the value is between 461 and 563 then we don’t want to turn in either direction.\n• Whatever we do the motor speed value cannot drop below zero or exceed 255.\n\nWith this in mind the code should make sense. Note that this section does not use an “else” statement like we did for the vertical control, since if the potentiometer is in our defined center range there is nothing we need to do.\n\nFinally we finish the sketch like we did earlier, adjusting values below 8 to zero so that the motors don’t “buzz” at extremely low speeds and then finally writing the values out to the two motor enable lines so that we can control the motor speeds with our L298N H-Bridge controller.\n\nWe have covered a lot of ground in this article and its accompanying video. We’ve learned how a DC Motor works, what an H-Bridge is and how we can use the L298N H-Bridge controller with (and without) and Arduino. We also examined Pulse Width Modulation, an important concept in motor control as well as a number of other applications. We even built a crude but functional robot car with a joystick control. Not bad for a few hours of work!\n\nOther H-Bridge controllers operate in a similar fashion so you can now take your newfound knowledge and apply it to them as well. So whether you want to control some tiny motors or a couple of massive ones you are now prepared. Your imagination is the only limit, so get out your Arduino and make some things move!\n\nControlling DC Motors with the L298N Dual H-Bridge and an Arduino"
    }
]