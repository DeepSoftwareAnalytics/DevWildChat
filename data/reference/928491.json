[
    {
        "link": "https://cplusplus.com/reference/fstream/ofstream",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/file-handling-c-classes",
        "document": "File handling is used to store data permanently in a computer. Using file handling we can store our data in secondary memory (Hard disk).\n\nHow to achieve the File Handling\n\nFor achieving file handling we need to follow the following steps:-\n\n STEP 1-Naming a file\n\n STEP 2-Opening a file\n\n STEP 3-Writing data into the file\n\n STEP 4-Reading data from the file\n\n STEP 5-Closing a file.\n\nWe give input to the executing program and the execution program gives back the output. The sequence of bytes given as input to the executing program and the sequence of bytes that comes as output from the executing program are called stream. In other words, streams are nothing but the flow of data in a sequence.\n\nThe input and output operation between the executing program and the devices like keyboard and monitor are known as “console I/O operation”. The input and output operation between the executing program and files are known as “disk I/O operation”.\n\nThe I/O system of C++ contains a set of classes which define the file handling methods. These include ifstream, ofstream and fstream classes. These classes are derived from fstream and from the corresponding iostream class. These classes, designed to manage the disk files, are declared in fstream and therefore we must include this file in any program that uses files. File handling is essential for data storage and retrieval in applications.\n• None This class is the base class for other classes in this class hierarchy.\n• None This class contains the necessary facilities that are used by all the other derived classes for input and output operations.\n• None This class is derived from the class ‘ios’.\n• None The extraction operator(>>) is overloaded in this class to handle input streams from files to the program execution.\n• None This class declares input functions such as get(), getline() and read().\n• None This class is derived from the class ‘ios’.\n• None The insertion operator(<<) is overloaded in this class to handle output streams to files from the program execution.\n• None This class declares output functions such as put() and write().\n• None This class contains a pointer which points to the buffer which is used to manage the input and output streams.\n• None This class provides operations common to the file streams. Serves as a base for fstream, ifstream and ofstream class.\n• None This class contains open() and close() function.\n• None It contains open() function with default input mode.\n• None Inherits the functions get(), getline(), read(), seekg() and tellg() functions from the istream.\n• None It contains open() function with default output mode.\n• None Inherits the functions put(), write(), seekp() and tellp() functions from the ostream.\n• None This class provides support for simultaneous input and output operations.\n• None Inherits all the functions from istream and ostream classes through iostream.\n• None Its purpose is to set the file buffers to read and write.\n• None We can also use file buffer member function to determine the length of the file. \n\n\n\nIn C++, files are mainly dealt by using three classes fstream, ifstream, ofstream available in fstream headerfile. \n\nofstream: Stream class to write on files \n\nifstream: Stream class to read from files \n\nfstream: Stream class to both read and write from/to files.\n\nNow the first step to open the particular file for read or write operation. We can open file by \n\n1. passing file name in constructor at the time of object creation \n\n2. using the open method\n\nBoth ios::app and ios::ate take us to the end of the file when it is opened. The difference between the two modes is that ios :: app allow us to add data to the end of the file only, while ios :: ate mode permits us add data or to modify the existing data anywhere in the file.\n\nProblem Statement : To read and write a File in C++. \n\nExamples:\n\nBelow is the implementation by using ifstream & ofstream classes.\n\nBelow is the implementation by using fstream class."
    },
    {
        "link": "https://cplusplus.com/doc/tutorial/files",
        "document": "std; main () { ofstream myfile ( ); (myfile.is_open()) { myfile << ; myfile << \"This is another line.\n\n\" ; myfile.close(); } cout << ; 0; }\n\n[file example.txt] This is a line. This is another line."
    },
    {
        "link": "https://stackoverflow.com/questions/17280122/c-stdofstream-class-members",
        "document": "first time contributor, but I believe I've checked the past posts correctly and do not find a solution that works. I am using Visual Studio 2012...\n\nEssentially, all I want to do is stream output to a log file owned by an object. I have no hang-ups about how precisely this should be achieved but nothing in the archives works.\n\nAs I understand it, this accepted solution ought to work:\n\nThis compiles ok but just hangs. Most probably, I guess, because output disappears at ctor end. What's a good robust way to achieve this functionality? Other StackOverflow suggestions read result in compiler errors..."
    },
    {
        "link": "https://dev.to/tbhaxor/a-comprehensive-guide-to-file-handling-in-c-2p1b",
        "document": "Hello World! You have been working with data in the program and struggling with saving its states across multiple restarts. Yeah, I know that is temporary and will be gone as the program exists. In this post, I will teach you how you can use C++ file handling and save not only text data into it but also binary data like Class or Struct.\n\nYou can clone the repository for all the snippets and source code used in this tutorial https://github.com/tbhaxor/cpp-file-handling-tutorial.\n• Why do you need File Handling Anyway?\n• Check Whether the File is Open or Not\n• Using I/O Streams of the File\n\nWhy do you need File Handling Anyway?\n\nThe program state gets vanished when it is exited or the functions go out of scope during execution. Sometimes it's required to have the states for future execution.\n\nTake the example of a game, you don't play it continuously. Saving the same and loading it later is very basic. I had first seen this in the Project IGI game and then Age of Empires. Nowadays multiplayer games are getting popular and they use databases to store this information.\n\nThat's a great idea to use databases. So why not use the database, it can be shared easily. Let me tell you that there is no different magic going on there, DBMS uses files to store the data. So it boils down to file handling.\n\nThere are and will be 2 types of operation in the file: Read file will allow you to retrieve the content and write file will allow you to put the content into the file using the current stream. A stream is basically a channel that carries your data from/to the file.\n\nclass is used to open the file in reading mode and is used to open the file in the write mode.\n\nThese classes provide different methods and properties as an abstraction to deal with files, or I would say even the large files.\n\nThere are two types of files: Human readable (or text) and human non-readable (binary).\n\nIt is easy to determine whether a file is a text or binary: If you open a file in a text editor (let's assume notepad or vscode), it will show all the characters and you can pronounce them. They might or might not make sense, but it's not required here. This file is a text file. If you are unable to pronounce any character, then that file is a binary file.\n\nWhile seeing the file format and the number of total bytes, we can determine that there are n bytes in the file that can be read, but how does an opened stream will know in general? EOF is also known as End-of-File in computing. It is a condition or a notification to the file reader that tells no more retrieve more information from the file and seems like it is ended.\n\nWhen you try to read a file and it is failed, both failed and eof bits are set in the error flags. You can use method to get this information.\n\nSo when does this bit set? An EOF bit is set after the ifstream reader tried to read the contents from the file and fails while the stream is still good (there is no error while performing I/O operations). So at least in the case of an ifstream, it waits for the OS to tell it that there's no more data read more\n\nProgrammatically, it will look like the following\n\n\n\nEnough talking, let's start by writing a text content into the file using . Before all of that, you need to instantiate the ofstream and open the file:\n\n\n\nThe function, as it says, open the file with name (first argument) and the mode (second argument).\n\nI will discuss different modes with you as we proceed, mode is used to tell the function, that opens the file in write mode, overwrite the contents of it if it exists or create a new one.\n\nNow it's time to write into the file stream using the left shift operator . This will format all your data into before writing.\n\n\n\nSince we are using a pointer variable, therefore it is required to dereference the file handle to access the operator from the object stored.\n\nReading is pretty simple and uses and operator with mode.\n\n\n\nFor reading files in text mode, there is only one option \n\n\n\nWhen you write a file with it formats whitespaces and streams that to the file, but while reading the content, it will stop at either EOF or the first whitespace character hit.\n\nEOL or End-of-line is defined by the character or and is considered as the whitespace. So if there are multiple lines, you can use the function.\n\n\n\nCheck Whether the File is Open or Not\n\nTill now we are believing that the file exists and is ready for any I/O operation, but what if the condition is otherwise? What if it failed to open? Will it throw an error?\n\nThe answer to the question is, NO. It will not throw error but the RW will not work. You can use or . The functions returns boolean value, so if the file is actually opened successfully, it will return true.\n\n\n\nWhen you are done with the file operations, it is recommended to close the file handle which will dispose of the file stream after writing any pending sequence of characters and clearing the buffer for both input and output streams.\n\nFor this you can use or .\n\n\n\nIf the file is not successfully opened, the function will fail and set the flag.\n\nWhat if you want to append the data into the file without losing old content. In the , it overwrites the file and reading the content of files, appending in memory and then writing to a file doesn't seem to be a space and time-efficient solution.\n\nThere is another mode of opening the file that you can use in place of , which is append mode . This will allow you to write from the end of the file to the size of the data.\n\nWhen you choose to open the file with append mode, the put cursor of the handle is set at the end of the file.\n\n\n\nSo far you have seen me dealing with the text file, but in the real world, there are more than binary files with the custom format, like Zip archives, PDF files and other document files.\n\nTo open the file in binary mode, you need to specify mode in the method of or .\n\n\n\nFor reading and writing, you must use and because the binary file saves the raw bytes and does not perform any kind of formatting.\n\nWith this, you can now store the object of structs or classes directly into the file without serializing it into the textual format. It will be then automatically deserialized when the file is read.\n\nLet's create a simple class called that will have name and age fields and a whoami() method to return a std::string object.\n\n\n\nYou can save this to a file using the following snippet by casing it to because of its definition in the stdc++. read more\n\n\n\nOnce this is successfully saved into the file, you will verify that there are some weird characters present in the file and that is normal, because the string data also stores the information of deserializing the object.\n\n\n\nNow as a beginner, you must be thinking that the type is different from the type. So why does the casting pointer not affect serialization? I would like to tell you that, you are getting confused between pointer type and other data types. For any data type, the pointer type would be 8 bytes or 4 bytes based on the CPU architecture, because it stores the starting address of the memory where that actual data of a type is stored. If the type of data is char, then it will consume 1 byte in the memory otherwise .\n\nUsing I/O Streams of the File\n\nIt is not like you can open a file only in one mode (that is either read or write), using you can perform both input/output operations on the file with the same file handle.\n\nThere are two types of cursors in the file et and ut. The get cursor is responsible for handling reading from the file which is known as input operation and the put cursor is responsible for handling writing into the file which is known as output operation.\n\nTo get the current position of the cursors, use the or . You can also set the position of these cursors making (either forward or backward) while the file is open using or functions.\n\nYou can also seek the cursor relatively based on the three types of the seek directions\n• — from the beginning of file\n• — from the current position of the cursor\n• — from the ending of the file or where the reader hits EOF"
    },
    {
        "link": "https://stackoverflow.com/questions/56013363/when-should-i-use-memory-manipulation-mechanisms-in-win32-api-programming",
        "document": "Applications generally use two levels of memory allocation. The operating system allocates memory to a process in pages.\n\nBecause applications typically allocate memory in quantities much smaller than a page, they use library functions (such as malloc) to allocate memory from a heap manager. The heap manager in turn allocates memory in pages from the operating system.\n\nYou have examples from both groups of functions. VirtualAlloc and CreateFileMapping allocate pages of memory from the operating system. A virtual memory system requires pages to be backed in secondary storage. CreateFileMapping backs the pages to a file you specify. VirtualAlloc will cause the pages to be backed by a system page file.\n\nGenerally, you use page allocation functions when you need to allocate a large amount of memory, such as a 100MB array for molecular modeling.\n\nHeapCreate is used to create a heap for smaller memory allocation. HeapAlloc can be used to allocate memory from the heap. More commonly, C programmers just use malloc/free. However, Windoze allows you to define your own heaps for better control. In Eunuchs land, you typically link in your own malloc/free implementation to do the same thing.\n\nThus, your first choice is the memory allocation scheme used by the programming language (e.g., new/delete, malloc/free). You second choice is Heap API functions (if the previous do not meet your needs). Your third choice is page allocation functions."
    },
    {
        "link": "https://stackoverflow.com/questions/1448302/c-and-process-memory-protection",
        "document": "Access control in Windows is on a per-object basis. If you want to protect the process object, you need to set the ACL of the process object, either when the process is created (through lpProcessAttributes of CreateProcess), or afterwards (through SetKernelObjectSecurity). If you add a \"deny all\" entry to the ACL, attempts to open the process by an attacker will fail.\n\nOf course, the owner of the process (and thus any malicious code run by the user) can change the ACL back to what it was - malicious code may not be prepared to do so, though. To prevent attacks from user space effectively, you need to run the process as a non-interactive user (e.g. as LocalSystem).\n\nNo amount of protection can prevent attacks from kernel space, so anybody who can install drivers can also hack any process on the system."
    },
    {
        "link": "https://reddit.com/r/C_Programming/comments/101t2ol/editing_another_programs_memory",
        "document": "Basically my question is how to access some programs memory block in RAM and read/edit it? I want to create a tool similar to cheat engines value edit.\n\nI know that values are stored as binary numbers so searching for the right value and then tracing its change is trivial, but the difficult part for me at least is accessing other programs memory.\n\nI assume its strictly bound to operating system so i would appreciate linking any sources that cover this topic for windows or explaining how to go about this"
    },
    {
        "link": "https://ired.team/offensive-security/code-injection-process-injection/how-to-hook-windows-api-using-c++",
        "document": "This lab is a quick look into how userland WinAPIs can be hooked. A function will be hooked in this instance, but it could be any.\n\nWindows API hooking is one of the techniques used by AV/EDR solutions to determine if code is malicious. You can read some of my notes on bypassing EDRs by leveraging unhooking - Bypassing Cylance and other AVs/EDRs by Unhooking Windows APIs\n\nFor this lab, I will write a simple C++ program that will work follows:\n• None Get memory address of the function\n• None Read the first 6 bytes of the - will need these bytes for unhooking the function\n• None Create a function that will be executed when the original is called\n• None Get memory address of the\n• None executes its code, prints the supplied arguments, unhooks the and transfers the code control to the actual\n\nPop the message box before the function is hooked - just to make sure it works and to prove that no functions are hooked so far - it's the first instruction of the program:\n\nGet the memory address of the function:\n\nIf we dissasemble the bytes at that address, we can definitely see that there is code for :\n\nNote the first 6 bytes (mind the endian-ness). We need to save these bytes for future when we want to unhook :\n\n...that will translate into the following assembly instructions:\n\nWe can now patch the - memory pane in the bottom right shows the patch being written to the beginning of function and the top right shows the beginning of the same function is re-written with a instructions:\n\nIf we disassemble the address , we can see it contains a jmp to our :\n\nThe intercepts and prints out the arguments supplied to , then unhooks by swaping back the first 6 bytes to the original bytes of the function and then calls the with the supplied arguments:\n\nOnce the function is hooked, we can call the which will invoke the , print the intercepted values and display the original message box:"
    },
    {
        "link": "https://motasemhamdan.medium.com/introduction-to-windows-api-tryhackme-walkthrough-6bb700ef5b74",
        "document": "Each API call within the Win32 library is stored in memory and requires a pointer to its memory address. However, obtaining these pointers is complicated by ASLR (Address Space Layout Randomization), which randomizes memory locations to enhance security. Different programming languages or packages employ distinct methods to bypass ASLR.\n\nIn this discussion, we will focus on two of the most common approaches: P/Invoke and the Windows header file.\n\nMicrosoft introduced the Windows header file, commonly referred to as the Windows loader, as a direct solution to challenges posed by ASLR. At a high level, the loader operates at runtime by identifying the API calls being made and creating a thunk table to resolve function addresses or pointers.\n\nFortunately, it’s not necessary to delve deeply into the inner workings of this process to use API calls effectively.\n\nBy simply including the windows.h file at the beginning of an unmanaged program, developers can invoke any Win32 function with ease.\n\nMicrosoft defines P/Invoke (Platform Invoke) as “a technology that allows you to access structs, callbacks, and functions in unmanaged libraries from your managed code.”\n\nP/Invoke simplifies the process of calling unmanaged functions, such as those in the Win32 API, from managed code. It begins by importing the necessary DLL that contains the desired unmanaged function or Win32 API call. This process provides a straightforward way to bridge the gap between managed and unmanaged code.\n\nHere is an example of how a DLL can be imported with specific options:\n\nThis declaration demonstrates importing the library to access the function. P/Invoke handles the details of invoking this unmanaged function from the managed environment.\n\nAPI calls form the second major component of the Win32 library, providing extensibility and flexibility to address a wide variety of use cases. Most of these API calls are thoroughly documented in resources like the Windows API documentation and pinvoke.net.\n\nIn this task, we will explore the basics of API call naming conventions and the use of in/out parameters.\n\nThe functionality of an API call can be extended by altering its naming scheme and appending specific representational characters.\n\nBelow is a table summarizing the naming conventions supported by Microsoft for these extensions:\n\nCharacterDescription Indicates ANSI (American National Standards Institute) encoding for string parameters. Indicates Unicode encoding for string parameters. Represents an “extended” version of a standard function with additional features. Refers to 32-bit specific versions of a function.\n\nThis naming system allows developers to select functions that best match their needs, such as those supporting Unicode or enhanced functionality.\n\nCreating API Calls in C and C++\n\nMicrosoft provides low-level programming languages like C and C++ with a set of pre-configured libraries to simplify access to API calls. The windows.h header file, discussed earlier, is key to defining the structure of these calls and obtaining function pointers.\n\nTo include the windows.h file in your program, add the following line at the top of your code:\n\nLet’s create a simple pop-up window with the title “Test” using the function.\n\nFirst, let’s revisit the in/out parameters of this API call to understand how it works:\n\nThis function creates a window with various customizable properties. To meet our objective, the title bar will display “Test”.\n\nHere’s a basic implementation of the function in a C program:\n\nThis code registers a window class, creates a window titled “Hello THM!”, and displays it on the screen. It also includes a basic message loop to keep the window running until it is closed by the user.\n\nP/Invoke allows managed code, such as C#, to call unmanaged functions from DLLs by importing the DLLs and mapping pointers to their API calls. Below is a simple example demonstrating how P/Invoke can be used to invoke a Windows API function.\n• The attribute is used to specify the DLL that contains the unmanaged function.\n• : Specifies the DLL from which the function is imported.\n• : Defines how string parameters are marshaled (e.g., ANSI or Unicode).\n• : Indicates that the function sets the system’s last-error code, which can be retrieved using .\n• The function is declared with the same signature as in the unmanaged library.\n• : Handle to the owner window (use for no owner).\n• : The title of the message box.\n• : Specifies the buttons and icons for the message box (e.g., for a simple “OK” button).\n• The function is invoked like any other method in C#.\n• In this example, it displays a message box with the text “Hello, THM!” and a title “P/Invoke Example.”\n\nCertain API calls within the Win32 library are often exploited for malicious purposes. Organizations like SANS and MalAPI.io have worked to document and categorize these calls to help identify and mitigate such threats.\n\nBelow is a table summarizing some of the most frequently abused API calls, categorized by their prevalence in real-world samples:\n\nAPI CallDescription Allocates memory in a remote process, commonly used for injecting malicious code. Writes data into the memory of a target process, often a step in process injection. Creates a thread in another process, frequently used to execute injected code. Opens a handle to a target process, used for various malicious operations. Loads a DLL into the process’s address space, often abused for loading malicious libraries. Retrieves the address of a function in a DLL, used to dynamically resolve API calls. Gathers detailed system information, often leveraged for reconnaissance. Installs a hook procedure to monitor or manipulate events, abused for keylogging. Modifies the Windows registry, frequently used for persistence mechanisms. Creates or opens files, often exploited to access or manipulate sensitive data.\n• Memory Manipulation\n\nFunctions like , , and are integral to process injection techniques, making them prime targets for abuse.\n• Dynamic API Resolution\n\n and are commonly exploited to dynamically load malicious code or resolve function addresses without detection.\n• System and Process Control\n\nCalls such as and enable attackers to interact with and gather information about processes and the system.\n• Persistence and Monitoring\n\nFunctions like and are used to maintain persistence or monitor user activity.\n\nTo analyze the keylogger, it’s crucial to identify the API calls and hooks it employs. Since the keylogger is written in C#, it uses P/Invoke to bridge managed code with the unmanaged Windows API.\n\nBelow is a snippet of the P/Invoke definitions from the malware’s source code:\n• Installs a hook procedure to monitor system events, such as keyboard or mouse input.\n• : Specifies the type of hook (e.g., WH_KEYBOARD for keyboard hooks).\n• : Handle to the DLL containing the hook procedure (optional for local hooks).\n• : Specifies the thread ID to monitor (or 0 for all threads).\n• Abuse Potential: Often exploited in keyloggers to intercept and log keystrokes.\n• : Handle to the hook to be removed.\n• Passes the hook information to the next hook procedure in the chain.\n• : Handle to the current hook (can be null for global hooks).\n• , , : Data about the event being processed.\n• Retrieves a handle to the specified module in the current process.\n• : Name of the module (passing retrieves the handle of the current process).\n• Hooks: The keylogger uses to establish hooks for monitoring keyboard input.\n• Resource Management: is used to remove hooks, while helps in setting up the hook procedure.\n\nBy analyzing these definitions, we gain insight into the keylogger’s functionality and its reliance on the Windows API for implementing malicious hooks.\n\nTo analyze the shellcode launcher, the process involves identifying the API calls it implements. Like the keylogger analysis, this malware sample also uses P/Invoke to interact with the unmanaged Windows API.\n\nBelow is a snippet of the P/Invoke definitions from the shellcode launcher’s source code:\n• : Base address of the region (optional; for system-determined address).\n• : Specifies the type of allocation (e.g., or ).\n• Abuse Potential: Used to allocate memory for storing shellcode.\n• Creates a new thread in the process.\n• : Pointer to the thread’s starting function (e.g., the shellcode).\n• : Pointer to arguments passed to the thread.\n\nAbuse Potential: Often used to execute shellcode in a new thread.\n• Waits for a specified object (e.g., thread) to enter a signaled state or timeout.\n\n: Handle to the object (e.g., thread created with ).\n\n: Time to wait (e.g., for no timeout).\n• Abuse Potential: Ensures the shellcode thread completes execution before the process ends.\n• Changes the protection of a region of memory.\n• Memory Manipulation: Functions like and are used to allocate and prepare memory for executing shellcode.\n• Thread Management: launches the shellcode in a new thread, while synchronizes its execution.\n• Process Execution: These API calls collectively enable the injection, preparation, and execution of shellcode in a process.\n\nBy analyzing these definitions, it becomes evident that the shellcode launcher leverages API calls focused on memory and thread manipulation, common tactics in malware execution.\n\nRoom answers can be found here."
    }
]