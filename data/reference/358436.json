[
    {
        "link": "https://pygame.org/wiki/GettingStarted",
        "document": "Pygame requires Python; if you don't already have it, you can download it from python.org. It's recommended to run the latest python version, because it's usually faster and has better features than the older ones. Bear in mind that pygame has dropped support for python 2.\n\nThe best way to install pygame is with the pip tool (which is what python uses to install packages). Note, this comes with python in recent versions. We use the --user flag to tell it to install into the home directory, rather than globally.\n\nTo see if it works, run one of the included examples:\n\nIf it works, you are ready to go! If not there are more detailed, platform-specific instructions further down the page.\n\nYou could try:\n• Having a go at one of the tutorials.\n• Or dive right into the pygame Docs\n\nHopefully the installation instructions above worked for you. If not, please read some alternative installation methods, and extra details below.\n\nWheels are available for x86 and x64 architectures on Linux and Windows, and for x64 and arm64 on Mac. If pip doesn't find a wheel for your platform, it will try to compile pygame from source (see below).\n\npygame requires a \"newer\" pip. If pygame starts compiling from source and fails, first try upgrading pip.\n\nThis comes with pygame already installed on the default raspbian installation. However, it's an ancient version. Get a newer pygame...\n\nMake sure you install python with the \"Add python to PATH\" option selected. This means that python, and pip will work for you from the command line.\n\nThere is documentation with python for the \"windows installation steps\"\n\nIf you get 'PermissionError: [WinError 5] Access is denied', before starting the command prompt right click and \"Run as administrator\".\n\nIf your examples aren't running and you are using a recent version of Mac OS X; try this line to install pygame instead:\n\n(note the w on the end). If it doesn't work for you, please see the /wiki/MacCompile instructions.\n\nMany Linux and BSD distributions have their own packages of Pygame. These may have an older version of Pygame than the wheels, but have been carefully tested with other packages in that distribution.\n\nFreeBSD also has an active pygame package. While techinicaly it isn't binary, it is automatically built and installed by the ports manager. See the FreeBSD package page for more information. http://www.freebsdports.info/ports/devel/py-game.html\n\nGentoo has a builtin package for pygame. This is compiled for your system as it installs, similar to BSD, http://packages.gentoo.org/package/dev-python/pygame\n\nCompiling and installing pygame is handled by Python's distutils. Pygame also comes with some scripts to automatically configure the flags needed to build pygame. Use the \"setup.py\" script to start the installation.\n\nThe first time you run the setup script, it will call the \" \" script. This will build a \" \" file which stores all the information needed to compile. The \"config.py\" will do a good job of detecting what dependencies are available and where they are located. If it isn't perfect, it is easy to build your own, or edit the created \" \" text file. This \" \" file is a simple Makefile-like text file. It defines variables needed to use each dependency, and then enables all the pygame modules with found dependencies. If you have trouble compiling, you should be able to easily fix any problems inside the \" \" file.\n\nRunning the \" \" script will call distutils to build and install the pygame package. Distutils actually supports a wide variety of compile and install options. running \" \" will start to show you the different options available. You can change many things like install locations, compiler to use, and more. Calling the \"setup.py\" script with no arguments and it will just ask you if you want the default flags needed to compile and install.\n\nSome of the .c files are generated by Cython from .pyx files. Running \" \" will update them.\n\nUp to date instructions for compiling on Mac OS X can be found here: MacCompile"
    },
    {
        "link": "https://pygame.org/docs",
        "document": "Welcome to pygame! Once you've got pygame installed ( or for most people), the next question is how to get a game loop running. Pygame, unlike some other libraries, gives you full control of program execution. That freedom means it is easy to mess up in your initial steps.\n\nHere is a good example of a basic setup (opens the window, updates the screen, and handles events)--\n\nHere is a slightly more fleshed out example, which shows you how to move something (a circle in this case) around on screen--\n\nFor more in depth reference, check out the Tutorials section below, check out a video tutorial (I'm a fan of this one), or reference the API documentation by module."
    },
    {
        "link": "https://scuba.cs.uchicago.edu/pygame/index.html",
        "document": "Welcome to pygame! Once you've got pygame installed ( or for most people), the next question is how to get a game loop running. Pygame, unlike some other libraries, gives you full control of program execution. That freedom means it is easy to mess up in your initial steps.\n\nHere is a good example of a basic setup (opens the window, updates the screen, and handles events)--\n\n# pygame.QUIT event means the user clicked X to close your window # fill the screen with a color to wipe away anything from last frame # flip() the display to put your work on screen\n\nHere is a slightly more fleshed out example, which shows you how to move something (a circle in this case) around on screen--\n\n# pygame.QUIT event means the user clicked X to close your window # fill the screen with a color to wipe away anything from last frame # flip() the display to put your work on screen # dt is delta time in seconds since last frame, used for framerate-\n\nFor more in depth reference, check out the Tutorials section below, check out a video tutorial (I'm a fan of this one), or reference the API documentation by module."
    },
    {
        "link": "https://pypi.org/project/pygame",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://discuss.python.org/t/how-to-install-pygame-for-dummies/45778",
        "document": "In this tutorial, you'll learn how to use a Python virtual environment to manage your Python projects. You'll also dive deep into the structure of virtual environments built using the venv module, as well as the reasoning behind using virtual..."
    },
    {
        "link": "https://dev.to/mxdws/using-python-with-the-spotify-api-1d02",
        "document": "I made a previous post and a video to explain how to scrape the Spotify website by using the Beautiful Soup library with Python so as I could return some pieces of information about a band. When I posted it to Reddit, someone made a comment asking why didn’t I just use Spotify’s API, which is a valid point.\n\nSo I’m going to try and explain how you can use Spotify’s API with the Python Requests library, to fetch data.\n\nI also made a video explaining some of this too. Check it out!\n\nFirst, why might we want to use the API to harvest data, rather than scraping the website?\n\nFirst, it’s more official. Sometimes scraping is a grey area, and if someone provides an API, they would rather you use it than scraping. Then they are able to control who can access it, monitor usage and make sure they have the capacity to support the usage and keep the system up and running.\n\nAlso, you’re likely to get access to more data, and in a more structured way, so you might think that you only want an album name and cover art, but if you decide you want to expand, it’s just a new API endpoint that you need to call and use the data accordingly.\n\nFor me the main reason is that the API is much more reliable. I’ve actually scraped the Spotify website for a few projects over the last year, and the way that the website HTML is written has changed, meaning that what worked once might not work again. I wrote an article about scraping Spotify in October of 2019, 6 months before I made the video about the same process. And in that time, some of the key items have changed. For example the Albums heading was an h2 tag, and now it’s in an h3 tag. If you were relying on that structure, you’d be a bit frustrated when it changed without warning.\n\nWhen a company like Spotify provide an API, the structure is much more reliable and the chances of it changing dramatically are very low. Spotify themselves use this API for their website, and other third parties pay for the service so if any significant changes are coming down the line, there will at least be some notice.\n\nUltimately if you have the choice between an API and scraping to gather data, the API is easily your best bet. Unless, like me you had an itch that you wanted to scratch by scraping.\n\nThe aim of this tutorial is to show you how to use the Spotify API using the Client Credentials authorisation flow. This is on the Spotify website as one of the four ways that you can authenticate. Once we’ve authenticated, we can call one of the API endpoints to return some data.\n\nHere's how we're aiming to get data from the Spotify API:\n• Look at the documentation to see how authentication works\n• Setup a Spotify Account and use it to create a new App for our website\n• Get the Client Id and Client Secret\n• Use Authorisation Token to retrieve information from endpoints\n\nThe first thing to look at before I do anything, is to look at the documentation, and this can be found at https://developer.spotify.com\n\nThis might sound dull, but if a company provide an API then they probably provide documentation to show how to use it. This should include information on authentication and endpoints which is what we’ll be interested in.\n\nThere are a number of ways to obtain authentication, but I’m going to use the Client Credentials Flow, which is like a server to server authentication. It means I will not be able to update private user data, and I can only access tracks, artists, playlists, etc. But this is fine for what I want to do here.\n\nMy use case is that once I’ve got the data, I’d probably use it to create a static website, so I’ll just be making one or two calls when the site is built, and that’s it. This is unlike the Web API which requires user authentication, and this will hit the API every time the page is loaded, so would be significantly higher volume of API calls.\n\nThe way this works is that you create an App in your dashboard, and that App has a Client Id and Client Secret. When you want to make API calls, firstly you encode your Client Id and Secret as Base64 and post it to Spotify with some other information. If everything is ok, they will send you back an Access Token. Then, using this Access Token as authentication, you can request information from the API endpoints.\n\nSo first things first, we need to login to your Spotify Account at the Spotify for Developers website, head to your dashboard, and once we’ve done that we can create an App.\n\nI created an App called Pretty Playlists and it has a Client Id and Client Secret. It’s handy that they have an option for resetting your secret just in case you, for example, make a YouTube video and reveal the secret.\n\nThe next step is to obtain the Access Token.\n\nIf we look at the documentation it says we need to make a Post request to the endpoint https://accounts.spotify.com/api/token and as part of that request we need to send an Authorization Header Parameter, and a Request Body parameter for the Grant Type.\n\nIt’s at this point we can actually start writing some Python.\n\nIn order to make the API requests, there is a library called Requests that we have to install that makes this very easy. It’s not part of the Standard Library, so we’ll install it by typing the following at the command line:\n\nAnd at the top of my Python code, I’ll import that.\n\n import requests\n\nSo when you make a request, you need to send a number of parameters.\n\n First, the URL endpoint you are calling. Secondly, you might need to send headers, that will send information like Access Tokens, amongst other things. Also, you can send and data that needs to be part of the payload.\n\nIn the documentation it has shown an example cURL request that has -h and -d arguments which represent the headers and data respectively of the Post request so we’ll use that to help us.\n\nI’m then going to create three variables.\n• url which I’m going to set to\n• headers and data which are both going to be empty dictionaries for the moment\n\nAnd this is what they look like:\n\nThe header has to be the Authorisation and the documentation says it needs to be a Base64 encoded string that contains the client id and client secret.\n\nNow, I didn’t know how to do this, so a quick Google meant I found this article which informed me that in order to encode something as Base64 you need to use the Base64 module that is part of the Standard Library.\n\nThe reason it is Base64 encoded is because it’s a popular way to encode binary data to ASCII characters, but the article I found has a much much better explanation of it.\n\nIt also says how you do it, and I shamelessly copied that.\n\nFirst you take the string you want to encode. In this instance, it’s the client ID and client secret.\n\nFor security if I’ve got any sensitive information like this, whilst I’m developing code, I just store them as variables in a separate file and I import them to my code. In this case, I’ve made a file called secrets.py, with my secrets in, and I’ll import the variables to this code.\n\nMy secrets.py file has the following lines:\n\nAnd I imported this to my python code by adding the following line at the top:\n\nOk, back to the encoding. So the message to encode will be:\n\nThen you take that message and convert it to bytes\n\nNext, we Base64 encode it:\n\nAnd then we convert those bytes back to a string\n\nThat’s the nasty bit done, and we can plug that in to our header dictionary.\n\nOur data dictionary needs to have a key value pair of grant_type = client_credentials\n\nSo the last thing we need to do is to put this all in to a Post request.\n\nTo interpret the response we’ll need the json module too, so let’s make sure that has been imported.\n\nAnd we’ll print out the response to see what that returns. If it errors, we’ll know, or if the response is 401 or something like that we will know that something has gone a bit wrong because it that HTTP status code is to do with user permissions.\n\nExcellent!! We have been sent back an Access Token, so now we can use that to request some information.\n\nWe can extract the Access Token from the json by typing:\n\nOk, so the last thing we need to do now is use that Access Token to call the API and return playlist information, so let’s do that.\n\nIf we look at the documentation, we can see that to get playlist information we need to use the URL endpoint for playlists, and specify the playlist id when making the call. The end point looks like this:\n\nI created a playlist and got the ID from the the sharing link and have plugged this in to my code.\n\nThis time the call is going to be a GET request rather than a POST, and the Authorisation is Bearer rather than Basic which we need to incorporate in to the headers object. We don’t need to send any data this time.\n\nAnd printing it out, should give us all the data that is associated with that playlist:\n\nI love API’s because they are so powerful and you can create nice websites from the data that is fetched.\n\nI’m going to use this playlist data to create a static website with list of tracks on it, but you could go as far as creating a third-party app for Spotify with their API.\n\nThe same principles can be applied to most APIs of this nature, and in my experience, if you choose one and make a little project, you can see just what potential this simple concept has.\n\nHere is all the code:"
    },
    {
        "link": "https://medium.com/@lorelablaka/extract-data-using-spotify-api-889222835bf4",
        "document": "The goal of this article is to gain a better understanding of API documentation by going through an example using the Spotify API.\n\nAPI stands for Application Programming Interface and has been a turning point in the development of technology. It allows different programs to work together in various ways by creating a line of communication between them. APIs can be used to gain access to data from third parties, like how Apple uses The Weather Channel API to access weather forecasts. APIs can also extend functionality of a product when a vendor integrates with an application. For example, when an online showroom extends functionality to also process transactions.\n\nThere are three approaches companies take to API release policies.\n• Private: the API can only be used for internal purposes\n• Partner: the API can be shared with specific business partners\n• Public: the API can be used by anyone to gain access to information for innovative or other purposes\n\nAmongst the different types of APIs, we will focus on extracting data using the Spotify Web API.\n\nWe will start by going to Dashboard section of Spotify for Developers, which is where we have to Login and create an app by specifying some details:\n\nWithin the app, there is the Client ID and Client Secret, which is needed to authenticate with the service. You can reset your Client Secret by just clicking the red reset button.\n\nNext, we will open up a new Jupyter Notebook file and install the library requests, which is needed to actually use the API. We then authenticate once by specifying the Client ID and Client Secret, and receive a token to access future sessions.\n\nAfter token authentication, client authorization is needed based on this Client Credentials Flow of the Authorization Guide. We will need to specify:\n\nThe Token URL for the URL request, the method of POST, and the required token parameters. The token parameters can be specified in dictionary form. Notice our second parameter requires our Authorization (client ID and client secret) to be turned into base64 encoded string. So we first need to import base64 and modify the Authorization key to bring the base64 encoded credentials\n\nThen we import the requests library and create and run our request using the post method. From here, we can get our access token.\n\nSo far, our notebook should look something like this (Note: our token expires in 3600 seconds):\n\nNext, I’m going to organize this code in a class object called Spotify and run some print statements to visualize the outputs within the class:\n\nEverything looks good! We can finally retrieve some Spotify data. How we actually use the Access Token to access the data goes back to the Authorization Guide. Notice our token_type is “Bearer” now instead of “Basic”, which was our original token_type during authentication. So moving forward, we will use the Bearer type.\n\nWe also need to specify an endpoint from their list .. the endpoint for this example will be Search:\n\nNotice our only required header parameter is Authorization and our required query parameters are “q” and “type”. If we accurately set up our code to include these parameters, we should be getting a Status Code of 200. The code for making requests to the Search endpoint will look something like this:\n\nOne thing to point out is we need to import urlencode (cell 11 of the picture above). Urlencode allows us to pass multiple url parameters, like the ones in the data dictionary above, while keeping the url string format.\n\nWe then print the data to make sure that the parameters are aligned appropriately in the url (which it looks like they are).\n\nLastly, we make a request with the specified lookup_url and headers. In this example, calling the json object displays all of the results of the “The Weeknd” tracks.\n\nMoving forward, we can switch up the Search parameters, or even switch up the endpoints."
    },
    {
        "link": "https://developer.spotify.com/documentation/web-api",
        "document": "This is where the magic begins! The following steps will help you to get started with your journey towards creating some awesome music apps using the API:\n• Log into the dashboard using your Spotify account.\n• Create an app and select \"Web API\" for the question asking which APIs are you planning to use. Once you have created your app, you will have access to the app credentials. These will be required for API authorization to obtain an access token.\n• Use the access token in your API requests.\n\nYou can follow the Getting started tutorial to learn how to make your first Web API call.\n\nThe documentation is organized as follows:\n• Tutorials, which serve as an introduction to important topics when using Web API\n• How-Tos, step-by-step guides that cover practical tasks or use cases\n\nThe Spotify Web API provides a wide range of functionality for developers, including:\n• Retrieve data from your favourite artist, album or show.\n• Control and interact with the playback, play and resume, seek to a position or retrieve your queue.\n• Manage your personal library, by creating a new playlist and adding your favourite tracks to it.\n\nAnd much more! You can find a complete list of available endpoints in the API Reference.\n\nWe've provided a step-by-step how-to that will guide you through the creation of a web app to display your Spotify profile data.\n\nIf you have any questions or run into any issues while using the Spotify Web API, you can find help in the Spotify Developer Community. Here, you can connect and get help from other developers.\n\nBy using Spotify Web API, you accept the Spotify Developer Terms of Service."
    },
    {
        "link": "https://byteplus.com/en/topic/409403",
        "document": ""
    },
    {
        "link": "https://medium.com/@anusha.kuppahally/spotify-api-project-using-python-5fbcab921f5e",
        "document": "Spotify’s API is rich with data, allowing for public access to a variety of information related to any song or artist on the platform. Other features like Spotify’s recommendation algorithm and search engine can also be accessed. This can be easily done through Spotipy, a Python package that makes it easy to extract data.\n\nI wanted to get familiar with data extraction from an API and decided to use Spotify’s API because of its large range of available data. For my project, I wanted to create an application that allows an end user to input an artist of their choice and receive an email report that contains information about the artist, recommendations, and data analysis related to the artist’s discography.\n\nI thought this could help users learn more about artists they listen to and access even more music they might like. Check out my code here: https://github.com/anushakuppahally/spotify-api-project.\n\nTo get started with my project, I first created a Spotify for Developers account to get access to a client ID and client secret key. These are both needed to access the Spotify API. Once I logged in with my Spotify credentials, I navigated to the dashboard and then clicked on ‘Create an App’. Then, it’s possible to access the necessary credentials.\n\nI created a Sendgrid account to send the email reports. Then, navigating to settings, I clicked on ‘API Keys’ and then ‘Create API Key’. I configured the account’s email address and obtained an API key to use.\n\nI placed the credentials for the Spotify API and Sendgrid in a .env file, and I created a .gitignore file for security as I was using Github for version control.\n\nAfter this, I decided to set up my requirements.txt file with the libraries I would need for my project, related to data querying, analysis, and visualization.\n\nBefore starting on my actual app, I wanted to finalize my set up. I integrated my app with Code Climate to assess my code quality. Then, I created a .codeclimate.yml file in my root directory to help provide automated code quality checks.\n\nThen, for organization, I created an app folder and a tests folder in my root directory, where the code for my app and its associated tests would be located in the appropriate folder. I created .conftest.py in my root directory to help my tests find the app code.\n\nI created a python-app.yml file under .github/workflows to help with continuous integration, or automated testing whenever I pushed changes.\n\nFinally, I created a README.md file to explain how my project works and a LICENSE.md file.\n\nAfter setting up, I imported my credentials to access the Spotify API.\n\nI decided to set up my functions under one class for simplicity. I structured my app to allow for user input for the artist, so once the user inputted the artist, I used Spotify’s search engine to find the artist associated with the input. I then asked the user to verify that the result of the search was correct.\n\nOnce verified, the functions used the artist’s URI, or Uniform Resource Identifier, to return the requested results. I used the artist’s URI to find the artist’s albums, top 5 tracks, song recommendations, and artist recommendations.\n\nThen, I used the artist’s URI to find the track IDs for each song under each album by that artist. I then used a separate function to loop through each album and create a dataframe of the tracks and their characteristics from the Spotify API, such as acousticness, length, popularity, etc.\n\nFrom there, I wanted to do some basic data analysis. I wanted to find the variables most and least correlated with popularity for an artist and create scatterplots based on those variables. This is an example of what the scatterplots look like, with a case where loudness was most correlated and acousticness was least correlated with popularity."
    }
]