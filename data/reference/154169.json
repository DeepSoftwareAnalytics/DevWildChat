[
    {
        "link": "https://geeksforgeeks.org/reading-writing-text-files-python",
        "document": "Python provides built-in functions for creating, writing, and reading files. Two types of files can be handled in Python, normal text files and binary files (written in binary language, 0s, and 1s).\n• Text files: In this type of file, Each line of text is terminated with a special character called EOL (End of Line), which is the new line character (‘\n\n’) in Python by default.\n• Binary files: In this type of file, there is no terminator for a line, and the data is stored after converting it into machine-understandable binary language.\n\nThis article will focus on opening, closing, reading, and writing data in a text file. Here, we will also see how to get Python output in a text file.\n\nIt is done using the open() function. No module is required to be imported for this function.\n\nExample: Here, file1 is created as an object for MyFile1 and file2 as object for MyFile2.\n\nThere are three ways to read txt file in Python:\n\nread(): Returns the read bytes in form of a string. Reads n bytes, if no n specified, reads the entire file.\n\nreadline(): Reads a line of the file and returns in form of a string.For specified n, reads at most n bytes. However, does not reads more than one line, even if n exceeds the length of the line.\n\nreadlines(): Reads all the lines and return them as each line a string element in a list.\n\nNote: ‘\n\n’ is treated as a special character of two bytes.\n\nIn this example, a file named “myfile.txt” is created and opened in write mode ( ). Data is written to the file using and methods. The file is then reopened in read and append mode ( ). Various read operations, including , , , and the use of , demonstrate different ways to retrieve data from the file. Finally, the file is closed.\n\nThere are two ways to write in a file:\n\nwrite(): Inserts the string str1 in a single line in the text file.\n\nwritelines(): For a list of string elements, each string is inserted in the text file.Used to insert multiple strings at a single time.\n\nIn this example, a file named “myfile.txt” is initially opened in write mode ( ) to write lines of text. The file is then reopened in append mode ( ), and “Today” is added to the existing content. The output after appending is displayed using . Subsequently, the file is reopened in write mode, overwriting the content with “Tomorrow”. The final output after writing is displayed using\n\nPython close() function closes the file and frees the memory space acquired by that file. It is used at the time when the file is no longer needed or if it is to be opened in a different file mode. File_object.close()\n\nReading and Writing to text files in Python – FAQs\n\nAccess modes govern the type of operations possible in the opened file. It refers to how the file will be used once it’s opened. These modes also define the location of the File Handle in the file. The file handle is like a cursor, which defines from where the data has to be read or written in the file and we can get Python output in text file. There are 6 access modes in Python:\n• Read Only (‘r’): Open text file for reading. The handle is positioned at the beginning of the file. If the file does not exist, raises the I/O error. This is also the default mode in which a file is opened.\n• Read and Write (‘r+’): Open the file for reading and writing. The handle is positioned at the beginning of the file. Raises I/O error if the file does not exist.\n• Write Only (‘w’): Open the file for writing. For the existing files, the data is truncated and over-written. The handle is positioned at the beginning of the file. Creates the file if the file does not exist.\n• Write and Read (‘w+’) : Open the file for reading and writing. For an existing file, data is truncated and over-written. The handle is positioned at the beginning of the file.\n• Append Only (‘a’) : Open the file for writing. The file is created if it does not exist. The handle is positioned at the end of the file. The data being written will be inserted at the end, after the existing data.\n• Append and Read (‘a+’): Open the file for reading and writing. The file is created if it does not exist. The handle is positioned at the end of the file. The data being written will be inserted at the end, after the existing data.\n\nHow to read a file and write to another file in Python?\n\nHow Files are Loaded into Primary Memory?\n\nThere are two kinds of memory in a computer i.e. Primary and Secondary memory every file that you saved or anyone saved is on secondary memory causing any data in primary memory to be deleted when the computer is powered off. So when you need to change any text file or just to work with them in Python you need to load that file into primary memory. Python interacts with files loaded in primary memory or main memory through “file handlers” ( This is how your operating system gives access to Python to interact with the file you opened by searching the file in its memory if found it returns a file handler and then you can work with the file).\n\nWhat is the difference between reading and writing files in Python?\n\nWhich function is used to read data from a text file?"
    },
    {
        "link": "https://docs.python.org/3/tutorial/inputoutput.html",
        "document": "There are several ways to present the output of a program; data can be printed in a human-readable form, or written to a file for future use. This chapter will discuss some of the possibilities.\n\nSo far we’ve encountered two ways of writing values: expression statements and the function. (A third way is using the method of file objects; the standard output file can be referenced as . See the Library Reference for more information on this.) Often you’ll want more control over the formatting of your output than simply printing space-separated values. There are several ways to format output.\n• None To use formatted string literals, begin a string with or before the opening quotation mark or triple quotation mark. Inside this string, you can write a Python expression between and characters that can refer to variables or literal values.\n• None The method of strings requires more manual effort. You’ll still use and to mark where a variable will be substituted and can provide detailed formatting directives, but you’ll also need to provide the information to be formatted. In the following code block there are two examples of how to format variables: Notice how the are padded with spaces and a negative sign only for negative numbers. The example also prints multiplied by 100, with 2 decimal places and followed by a percent sign (see Format Specification Mini-Language for details).\n• None Finally, you can do all the string handling yourself by using string slicing and concatenation operations to create any layout you can imagine. The string type has some methods that perform useful operations for padding strings to a given column width. When you don’t need fancy output but just want a quick display of some variables for debugging purposes, you can convert any value to a string with the or functions. The function is meant to return representations of values which are fairly human-readable, while is meant to generate representations which can be read by the interpreter (or will force a if there is no equivalent syntax). For objects which don’t have a particular representation for human consumption, will return the same value as . Many values, such as numbers or structures like lists and dictionaries, have the same representation using either function. Strings, in particular, have two distinct representations. The value of x is 32.5, and y is 40000... # The repr() of a string adds string quotes and backslashes: # The argument to repr() may be any Python object: The module contains a class that offers yet another way to substitute values into strings, using placeholders like and replacing them with values from a dictionary, but offers much less control of the formatting. Formatted string literals (also called f-strings for short) let you include the value of Python expressions inside a string by prefixing the string with or and writing expressions as . An optional format specifier can follow the expression. This allows greater control over how the value is formatted. The following example rounds pi to three places after the decimal: 'The value of pi is approximately The value of pi is approximately 3.142. Passing an integer after the will cause that field to be a minimum number of characters wide. This is useful for making columns line up. Other modifiers can be used to convert the value before it is formatted. applies , applies , and applies : 'My hovercraft is full of My hovercraft is full of eels. 'My hovercraft is full of My hovercraft is full of 'eels'. The specifier can be used to expand an expression to the text of the expression, an equal sign, then the representation of the evaluated expression: See self-documenting expressions for more information on the specifier. For a reference on these format specifications, see the reference guide for the Format Specification Mini-Language. Basic usage of the method looks like this: We are the knights who say \"Ni!\" The brackets and characters within them (called format fields) are replaced with the objects passed into the method. A number in the brackets can be used to refer to the position of the object passed into the method. If keyword arguments are used in the method, their values are referred to by using the name of the argument. Positional and keyword arguments can be arbitrarily combined: The story of Bill, Manfred, and Georg. If you have a really long format string that you don’t want to split up, it would be nice if you could reference the variables to be formatted by name instead of by position. This can be done by simply passing the dict and using square brackets to access the keys. This could also be done by passing the dictionary as keyword arguments with the notation. This is particularly useful in combination with the built-in function , which returns a dictionary containing all local variables: __name__: __main__; __doc__: None; __package__: None; __loader__: ... As an example, the following lines produce a tidily aligned set of columns giving integers and their squares and cubes: For a complete overview of string formatting with , see Format String Syntax. Here’s the same table of squares and cubes, formatted manually: # Note use of 'end' on previous line The method of string objects right-justifies a string in a field of a given width by padding it with spaces on the left. There are similar methods and . These methods do not write anything, they just return a new string. If the input string is too long, they don’t truncate it, but return it unchanged; this will mess up your column lay-out but that’s usually better than the alternative, which would be lying about a value. (If you really want truncation you can always add a slice operation, as in .) There is another method, , which pads a numeric string on the left with zeros. It understands about plus and minus signs: The % operator (modulo) can also be used for string formatting. Given (where format is a string), conversion specifications in format are replaced with zero or more elements of values. This operation is commonly known as string interpolation. For example: 'The value of pi is approximately The value of pi is approximately 3.142. More information can be found in the printf-style String Formatting section.\n\nreturns a file object, and is most commonly used with two positional arguments and one keyword argument: The first argument is a string containing the filename. The second argument is another string containing a few characters describing the way in which the file will be used. mode can be when the file will only be read, for only writing (an existing file with the same name will be erased), and opens the file for appending; any data written to the file is automatically added to the end. opens the file for both reading and writing. The mode argument is optional; will be assumed if it’s omitted. Normally, files are opened in text mode, that means, you read and write strings from and to the file, which are encoded in a specific encoding. If encoding is not specified, the default is platform dependent (see ). Because UTF-8 is the modern de-facto standard, is recommended unless you know that you need to use a different encoding. Appending a to the mode opens the file in binary mode. Binary mode data is read and written as objects. You can not specify encoding when opening file in binary mode. In text mode, the default when reading is to convert platform-specific line endings ( on Unix, on Windows) to just . When writing in text mode, the default is to convert occurrences of back to platform-specific line endings. This behind-the-scenes modification to file data is fine for text files, but will corrupt binary data like that in or files. Be very careful to use binary mode when reading and writing such files. It is good practice to use the keyword when dealing with file objects. The advantage is that the file is properly closed after its suite finishes, even if an exception is raised at some point. Using is also much shorter than writing equivalent - blocks: # We can check that the file has been automatically closed. If you’re not using the keyword, then you should call to close the file and immediately free up any system resources used by it. Calling without using the keyword or calling might result in the arguments of not being completely written to the disk, even if the program exits successfully. After a file object is closed, either by a statement or by calling , attempts to use the file object will automatically fail. The rest of the examples in this section will assume that a file object called has already been created. To read a file’s contents, call , which reads some quantity of data and returns it as a string (in text mode) or bytes object (in binary mode). size is an optional numeric argument. When size is omitted or negative, the entire contents of the file will be read and returned; it’s your problem if the file is twice as large as your machine’s memory. Otherwise, at most size characters (in text mode) or size bytes (in binary mode) are read and returned. If the end of the file has been reached, will return an empty string ( ). 'This is the entire file.\n\n' reads a single line from the file; a newline character ( ) is left at the end of the string, and is only omitted on the last line of the file if the file doesn’t end in a newline. This makes the return value unambiguous; if returns an empty string, the end of the file has been reached, while a blank line is represented by , a string containing only a single newline. 'This is the first line of the file.\n\n' 'Second line of the file\n\n' For reading lines from a file, you can loop over the file object. This is memory efficient, fast, and leads to simple code: This is the first line of the file. If you want to read all the lines of a file in a list you can also use or . writes the contents of string to the file, returning the number of characters written. Other types of objects need to be converted – either to a string (in text mode) or a bytes object (in binary mode) – before writing them: returns an integer giving the file object’s current position in the file represented as number of bytes from the beginning of the file when in binary mode and an opaque number when in text mode. To change the file object’s position, use . The position is computed from adding offset to a reference point; the reference point is selected by the whence argument. A whence value of 0 measures from the beginning of the file, 1 uses the current file position, and 2 uses the end of the file as the reference point. whence can be omitted and defaults to 0, using the beginning of the file as the reference point. # Go to the 6th byte in the file # Go to the 3rd byte before the end In text files (those opened without a in the mode string), only seeks relative to the beginning of the file are allowed (the exception being seeking to the very file end with ) and the only valid offset values are those returned from the , or zero. Any other offset value produces undefined behaviour. File objects have some additional methods, such as and which are less frequently used; consult the Library Reference for a complete guide to file objects. Strings can easily be written to and read from a file. Numbers take a bit more effort, since the method only returns strings, which will have to be passed to a function like , which takes a string like and returns its numeric value 123. When you want to save more complex data types like nested lists and dictionaries, parsing and serializing by hand becomes complicated. Rather than having users constantly writing and debugging code to save complicated data types to files, Python allows you to use the popular data interchange format called JSON (JavaScript Object Notation). The standard module called can take Python data hierarchies, and convert them to string representations; this process is called serializing. Reconstructing the data from the string representation is called deserializing. Between serializing and deserializing, the string representing the object may have been stored in a file or data, or sent over a network connection to some distant machine. The JSON format is commonly used by modern applications to allow for data exchange. Many programmers are already familiar with it, which makes it a good choice for interoperability. If you have an object , you can view its JSON string representation with a simple line of code: Another variant of the function, called , simply serializes the object to a text file. So if is a text file object opened for writing, we can do this: To decode the object again, if is a binary file or text file object which has been opened for reading: JSON files must be encoded in UTF-8. Use when opening JSON file as a text file for both of reading and writing. This simple serialization technique can handle lists and dictionaries, but serializing arbitrary class instances in JSON requires a bit of extra effort. The reference for the module contains an explanation of this. Contrary to JSON, pickle is a protocol which allows the serialization of arbitrarily complex Python objects. As such, it is specific to Python and cannot be used to communicate with applications written in other languages. It is also insecure by default: deserializing pickle data coming from an untrusted source can execute arbitrary code, if the data was crafted by a skilled attacker."
    },
    {
        "link": "https://geeksforgeeks.org/file-handling-python",
        "document": "File handling refers to the process of performing operations on a file such as creating, opening, reading, writing and closing it, through a programming interface. It involves managing the data flow between the program and the file system on the storage device, ensuring that data is handled safely and efficiently.\n\nTo open a file we can use function, which requires file path and mode as arguments:\n\nWhen opening a file, we must specify the mode we want to which specifies what we want to do with the file. Here’s a table of the different modes available:\n\nOpens the file for reading. File must exist; otherwise, it raises an error. Opens the file for reading binary data. File must exist; otherwise, it raises an error. Opens the file for both reading and writing. File must exist; otherwise, it raises an error. Opens the file for both reading and writing binary data. File must exist; otherwise, it raises an error. Opens the file for writing. Creates a new file or truncates the existing file. Opens the file for writing binary data. Creates a new file or truncates the existing file. Opens the file for both writing and reading. Creates a new file or truncates the existing file. Opens the file for both writing and reading binary data. Creates a new file or truncates the existing file. Opens the file for appending data. Creates a new file if it doesn’t exist. Opens the file for appending binary data. Creates a new file if it doesn’t exist. Opens the file for appending and reading. Creates a new file if it doesn’t exist. Opens the file for appending and reading binary data. Creates a new file if it doesn’t exist. Creates a new file. Raises an error if the file already exists. Creates a new binary file. Raises an error if the file already exists. Creates a new file for reading and writing. Raises an error if the file exists. Exclusive creation with read and write in binary mode. Creates a new binary file for reading and writing. Raises an error if the file exists.\n\nFor this article we are using text file with text:\n\nReading a file can be achieved by file.read() which reads the entire content of the file. After reading the file we can close the file using file.close() which closes the file after reading it, which is necessary to free up system resources.\n\nWriting to a file is done using file.write() which writes the specified string to the file. If the file exists, its content is erased. If it doesn’t exist, a new file is created.\n\nExample: Writing to a File in Write Mode (w)\n\nIt is done using adds the specified string to the end of the file without erasing its existing content.\n\nExample: For this example, we will use the Python file created in the previous example.\n\nClosing a file is essential to ensure that all resources used by the file are properly released. loses the file and ensures that any changes made to the file are saved.\n\nstatement is used for resource management. It ensures that file is properly closed after its suite finishes, even if an exception is raised. with open() as method automatically handles closing the file once the block of code is exited, even if an error occurs. This reduces the risk of file corruption and resource leakage.\n\nIt’s important to handle exceptions to ensure that files are closed properly, even if an error occurs during file operations.\n• None Versatility : File handling in Python allows us to perform a wide range of operations, such as creating, reading, writing, appending, renaming and deleting files.\n• Flexibility : File handling in Python is highly flexible, as it allows us to work with different file types (e.g. text files, binary files, CSV files , etc.) and to perform different operations on files (e.g. read, write, append, etc.).\n• User – friendly : Python provides a user-friendly interface for file handling, making it easy to create, read and manipulate files.\n• Cross-platform : Python file-handling functions work across different platforms (e.g. Windows, Mac, Linux), allowing for seamless integration and compatibility.\n• Error-prone: File handling operations in Python can be prone to errors, especially if the code is not carefully written or if there are issues with the file system (e.g. file permissions, file locks, etc.).\n• Security risks : File handling in Python can also pose security risks, especially if the program accepts user input that can be used to access or modify sensitive files on the system.\n• Complexity : File handling in Python can be complex, especially when working with more advanced file formats or operations. Careful attention must be paid to the code to ensure that files are handled properly and securely.\n• Performance : File handling operations in Python can be slower than other programming languages, especially when dealing with large files or performing complex operations.\n\nWhat are the types of files in Python?\n\nWhat are the 4 file handling functions?\n\nWhy is file handling useful?\n\nIn Python file handling, is a method of file objects that returns the current position of the file pointer (cursor) within the file. It returns an integer representing the byte offset from the beginning of the file where the next read or write operation will occur. # Open a file in read mode file = open('example.txt', 'r') # Read the first 10 characters content = file.read(10) print(content) # Check the current position of the file pointer position = file.tell() print(\"Current position:\", position) # Close the file file.close()\n• None reads the first 10 characters from the file.\n• None returns the current position of the file pointer after reading."
    },
    {
        "link": "https://w3schools.com/python/python_file_handling.asp",
        "document": "File handling is an important part of any web application.\n\nPython has several functions for creating, reading, updating, and deleting files.\n\nThe key function for working with files in Python is the function.\n\nThe function takes two parameters; filename, and mode.\n\nThere are four different methods (modes) for opening a file:\n\n- Read - Default value. Opens a file for reading, error if the file does not exist - Append - Opens a file for appending, creates the file if it does not exist - Write - Opens a file for writing, creates the file if it does not exist - Create - Creates the specified file, returns an error if the file exists\n\nIn addition you can specify if the file should be handled as binary or text mode\n\nTo open a file for reading it is enough to specify the name of the file:\n\nThe code above is the same as:\n\nBecause for read, and for text are the default values, you do not need to specify them.\n\nNote: Make sure the file exists, or else you will get an error."
    },
    {
        "link": "https://tutorialsteacher.com/python/python-read-write-file",
        "document": "In Python, the IO module provides methods of three types of IO operations; raw binary files, buffered binary files, and text files. The canonical way to create a file object is by using the function.\n\nAny file operations can be performed in the following three steps:\n• Open the file to get the file object using the built-in open() function. There are different access modes, which you can specify while opening a file using the open() function.\n• Perform read, write, append operations using the file object retrieved from the function.\n\nFile object includes the following methods to read data from the file.\n• read(chars): reads the specified number of characters starting from the current position.\n• readline(): reads the characters starting from the current reading position up to a newline character.\n• readlines(): reads all lines until the end of file and returns a list object.\n\nThe following file will be used in all the examples of reading and writing files.\n\nThe following example performs the read operation using the method.\n\nAbove, opens the in the default read mode from the current directory and returns a file object. function reads all the content until EOF as a string. If you specify the char size argument in the method, then it will read that many chars only. will flush and close the stream.\n\nThe following example demonstrates reading a line from the file.\n\nAs you can see, we have to open the file in mode. The method will return the first line, and then will point to the second line in the file.\n\nThe following reads all lines using the function.\n\nThe file object has an inbuilt iterator. The following program reads the given file line by line until is raised, i.e., the EOF is reached.\n\nUse the for loop to read a file easily.\n\nUse the 'rb' mode in the function to read a binary files, as shown below.\n\nThe file object provides the following methods to write to a file.\n• write(s): Write the string s to the stream and return the number of characters written.\n• writelines(lines): Write a list of lines to the stream. Each line must have a separator at the end of it.\n\nThe following creates a new file if it does not exist or overwrites to an existing file.\n\nIn the above example, the statement opens in write mode, the method returns the file object and assigns it to a variable . specifies that the file should be writable. Next, overwrites an existing content of the file. It returns the number of characters written to a file, which is 5 in the above example. In the end, closes the file object.\n\nThe following appends the content at the end of the existing file by passing or mode in the method.\n\nPython provides the method to save the contents of a list object in a file. Since the newline character is not automatically written to the file, it must be provided as a part of the string.\n\nOpening a file with \"w\" mode or \"a\" mode can only be written into and cannot be read from. Similarly \"r\" mode allows reading only and not writing. In order to perform simultaneous read/append operations, use \"a+\" mode.\n\nThe function opens a file in text format by default. To open a file in binary format, add to the mode parameter. Hence the mode opens the file in binary format for reading, while the mode opens the file in binary format for writing. Unlike text files, binary files are not human-readable. When opened using any text editor, the data is unrecognizable.\n\nThe following code stores a list of numbers in a binary file. The list is first converted in a byte array before writing. The built-in function bytearray() returns a byte representation of the object."
    },
    {
        "link": "https://stackoverflow.com/questions/74663978/need-to-open-file-in-a-r-and-rb-mode-in-python",
        "document": "Is it ok to open the same files within one context manager? (1)\n\nI just need that original data checksum was equal to the checksum after reading it into Python program.The only thing that confuses me is what about handling very large files ca 10GB. Basically I need list of dicts (DictReader does it already) and at the same time be able to represent correct hash.\n\nAnd hash is not the same as in the (1) example. Hash at (1) is correct one.\n\nI just want to be sure that opening the same file twice in case of correct hashing and getting data is OK."
    },
    {
        "link": "https://geeksforgeeks.org/file-mode-in-python",
        "document": "In Python, the file mode specifies the purpose and the operations that can be performed on a file when it is opened. When you open a file using the open() function, you can specify the file mode as the second argument.\n\nBelow are the different types of file modes in Python along with their description:\n\nOpen text file for reading. Raises an I/O error if the file does not exist. Open the file for reading and writing. Raises an I/O error if the file does not exist. Open the file for writing. Truncates the file if it already exists. Creates a new file if it does not exist. Open the file for reading and writing. Truncates the file if it already exists. Creates a new file if it does not exist. Open the file for writing. The data being written will be inserted at the end of the file. Creates a new file if it does not exist. Open the file for reading and writing. The data being written will be inserted at the end of the file. Creates a new file if it does not exist. Open the file for reading in binary format. Raises an I/O error if the file does not exist. Open the file for reading and writing in binary format. Raises an I/O error if the file does not exist. Open the file for writing in binary format. Truncates the file if it already exists. Creates a new file if it does not exist. Open the file for reading and writing in binary format. Truncates the file if it already exists. Creates a new file if it does not exist. Open the file for appending in binary format. Inserts data at the end of the file. Creates a new file if it does not exist. Open the file for reading and appending in binary format. Inserts data at the end of the file. Creates a new file if it does not exist.\n\nBelow are some of the file modes in Python:\n\nThis mode allows you to open a file for reading only. If the file does not exist, it will raise a FileNotFoundError.\n\nIn this example, a file named 'example.txt' is opened in read mode ('r'), and its content is read and stored in the variable 'content' using a 'with' statement, ensuring proper resource management by automatically closing the file after use.\n\nThis mode allows you to open a file for writing only. If the file already exists, it will truncate the file to zero length. If the file does not exist, it will create a new file.\n\nIn this example, a file named 'example.txt' is opened in write mode ('w'), and the string 'Hello, world!' is written into the file.\n\nNote - If you were to open the file \"example.txt\" after running this code, you would find that it contains the text \"Hello, world!\".\n\nThis mode allows you to open a file for appending new content. If the file already exists, the new content will be added to the end of the file. If the file does not exist, it will create a new file.\n\nIn this example, a file named 'example.txt' is opened in append mode ('a'), and the string '\n\nThis is a new line.' is written to the end of the file.\n\nThe code will then write the string \"\n\nThis is a new line.\" to the file, appending it to the existing content or creating a new line if the file is empty.\n\nThis mode use in binary files, such as images, audio files etc. Its always used by combined with read (`'rb'`) or write ('wb') modes.\n\nIn this example, a file named 'image.png' is opened in binary read mode ('rb'). The binary data is read from the file using the 'read()' method and stored in the variable 'data'.\n\nThis mode allows you to open a file for both reading and writing. The file pointer will be positioned at the beginning of the file. If the file does not exist, it will raise a FileNotFoundError.\n\nIf the initial contents of \"example.txt\" we are \"Initial content.\", after running this code, the new content of the file would be:\n\nThis mode allows you to open a file for both reading and writing. If the file already exists, it will truncate the file to zero length. If the file does not exist, it will create a new file.\n\nIn this example, a file named 'example.txt' is opened in write and read mode ('w+').\n\nTherefore, the output of this code will be the string \"Hello, world!\". Since the file was truncated and the pointer was moved to the beginning before reading, the contents of the file will be exactly what was written to it. So, content will contain the string \"Hello, world!\"."
    },
    {
        "link": "https://stackoverflow.com/questions/15746954/what-is-the-difference-between-rb-and-rb-modes-in-file-objects",
        "document": "I am using pickle module in Python and trying different file IO modes:\n\nI never read about \"r+b\" mode anywhere, but found mentioning about it in the documentation.\n\nI am getting on Linux if I use mode and on Windows if is used. I just gave mode a shot and it's working on both.\n\nWhat's mode? What's the difference between \"rb\" and \"r+b\"? Why does it work when the others don't?"
    },
    {
        "link": "https://geeksforgeeks.org/difference-between-modes-a-a-w-w-and-r-in-built-in-open-function",
        "document": "Understanding the file modes in Python’s open() function is essential for working with files effectively. Depending on your needs, you can choose between ‘a’, ‘a+’, ‘w’, ‘w+’, and ‘r+’ modes to read, write, or append data to files while handling files. In this article, we’ll explore these modes and their use cases.\n\nDifference between modes a, a+, w, w+, and r+ in built-in open function?\n\nPython’s built-in open() function is an essential tool for working with files. It allows you to specify how you want to interact with a file by using different modes. Understanding these modes – ‘a’, ‘a+’, ‘w’, ‘w+’, and ‘r+’ – is crucial for efficient file manipulation in Python.\n\nNote – The ‘+’ symbol is often used to specify a mode that allows both reading and writing to a file.\n\nFile modes define the purpose for which you want to open a file, whether it’s for reading, writing, or both. Let’s explore each mode in detail:\n\nThe test file used is mentioned below:-\n\nDifference between a and a+ in open()\n\nThe ‘r’ is for reading only, while ‘r+’ allows both reading and writing. It’s essential to be cautious when using ‘r+’ to avoid accidentally overwriting or appending data to the wrong part of the file.\n\nIn ‘a’ mode, the file is opened for writing, positioned at the end if it exists, creates a new empty file if not, appends data without altering existing content, and disallows reading.\n\nAppend and Read Mode in Python with ‘a+’\n\nThe ‘a+’ mode opens the file for both reading and writing, positioning the file pointer at the end for writing in existing files and creating a new, empty file if it doesn’t exist.\n\nDifference between w and w+ in open()\n\nThe ‘w’ is for write-only mode, and ‘w+’ is for both write and read mode. Use ‘w+’ if you need to both write and read data from the file, while ‘w’ is for writing data and overwriting the file’s contents.\n\nIt opens the file for writing. If the file exists, it truncates (clears) its content. If the file doesn’t exist, Python creates a new, empty file. Reading from the file is not allowed in this mode.\n\nWrite and Read Mode in Python with ‘w+’\n\nIn ‘w+’ mode, the file is opened for both reading and writing, existing content is cleared, a new empty file is created if it doesn’t exist, and the file pointer is positioned at the beginning.\n\nDifference between r and r+ in open()\n\nThe ‘r’ is for reading only, and ‘r+’ is for both reading and writing. Be cautious when using ‘r+’ as it can potentially overwrite or modify the existing content of the file.\n\nThis code segment opens a file named ‘file_r.txt’ in ‘read’ mode (‘r’). It then reads the content of the file using the .read() method and stores it in the variable content. The ‘r’ mode is used for reading files, and it will raise a FileNotFoundError if the file does not exist.\n\nRead and Write Mode in Python with ‘r+’\n\nIn ‘r+’ mode, the file is opened for both reading and writing without truncation, and the file pointer is positioned at the beginning. If the file doesn’t exist, a FileNotFoundError is raised."
    },
    {
        "link": "https://book.pythontips.com/en/latest/open_function.html",
        "document": "open opens a file. Pretty simple, eh? Most of the time, we see it being used like this:\n\nThe reason I am writing this article is that most of the time, I see open used like this. There are three errors in the above code. Can you spot them all? If not, read on. By the end of this article, you’ll know what’s wrong in the above code, and, more importantly, be able to avoid these mistakes in your own code. Let’s start with the basics:\n\nThe return value from is a file handle, given out from the operating system to your Python application. You will want to return this file handle once you’re finished with the file, if only so that your application won’t reach the limit of the number of open file handles it can have at once.\n\nExplicitly calling closes the file handle, but only if the read was successful. If there is any error just after , will not be called (depending on the Python interpreter, the file handle may still be returned, but that’s another story). To make sure that the file gets closed whether an exception occurs or not, pack it into a statement:\n\nThe first argument of is the filename. The second one (the mode) determines how the file gets opened.\n• If you want to read the file, pass in\n• If you want to read and write the file, pass in\n• If you want to overwrite the file, pass in\n• If you want to append to the file, pass in\n\nWhile there are a couple of other valid mode strings, chances are you won’t ever use them. The mode matters not only because it changes the behavior, but also because it may result in permission errors. For example, if we were to open a jpg-file in a write-protected directory, would fail. The mode can contain one further character; we can open the file in binary (you’ll get a string of bytes) or text mode (a string of characters).\n\nIn general, if the format is written by humans, it tends to be text mode. image files are not generally written by humans (and are indeed not readable by humans), and you should therefore open them in binary mode by adding a to the mode string (if you’re following the opening example, the correct mode would be ). If you open something in text mode (i.e. add a , or nothing apart from ), you must also know which encoding to use. For a computer, all files are just bytes, not characters.\n\nUnfortunately, does not allow explicit encoding specification in Python 2.x. However, the function io.open is available in both Python 2.x and 3.x (where it is an alias of ), and does the right thing. You can pass in the encoding with the keyword. If you don’t pass in any encoding, a system – and Python – specific default will be picked. You may be tempted to rely on these defaults, but the defaults are often wrong, or the default encoding cannot actually express all characters in the file (this will happen often on Python 2.x and/or Windows). So go ahead and pick an encoding. Encoding is the way to instruct computers about how the numbers should be stored as bytes in memory. is a terrific one and is supported by major browsers and programming languages. When you write a file, you can just pick the encoding to your liking (or the liking of the program that will eventually read your file).\n\nHow do you find out which encoding a file you’re reading was written in? Well, unfortunately, there is no foolproof way to detect the encoding - the same bytes can represent different, but equally valid characters in different encodings. Therefore, you must rely on metadata (for example, in HTTP headers) to know the encoding. Increasingly, formats just define the encoding to be UTF-8.\n\nArmed with this knowledge, let’s write a program that reads a file, determines whether it’s JPG (hint: These files start with the bytes ), and writes a text file that describe the input file.\n\nI am sure that now you will use correctly!"
    }
]