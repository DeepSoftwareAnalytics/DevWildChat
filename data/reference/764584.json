[
    {
        "link": "https://petsc.org/main/manualpages/Mat/MatCreateSeqAIJ",
        "document": "Creates a sparse matrix in (compressed row) format (the default parallel PETSc format). For good matrix assembly performance the user should preallocate the matrix storage by setting the parameter (or the array ).\n\nnnz - array containing the number of nonzeros in the various rows (possibly different for each row) or NULL\n\nnz - number of nonzeros per row (same for all rows)\n\nIt is recommend to use instead of this routine\n\nIf is given then is ignored\n\nThe format, also called compressed row storage, is fully compatible with standard Fortran storage. That is, the stored row and column indices can begin at either one (as in Fortran) or zero.\n\nSpecify the preallocated storage with either or (not both). Set = and = for PETSc to control dynamic memory allocation.\n\nBy default, this format uses inodes (identical nodes) when possible, to improve numerical efficiency of matrix-vector products and solves. We search for consecutive rows with the same nonzero structure, thereby reusing matrix information to achieve increased efficiency."
    },
    {
        "link": "https://petsc.org/release/manualpages/Mat/MatCreateSeqAIJ",
        "document": "Creates a sparse matrix in (compressed row) format (the default parallel PETSc format). For good matrix assembly performance the user should preallocate the matrix storage by setting the parameter (or the array ).\n\nnnz - array containing the number of nonzeros in the various rows (possibly different for each row) or NULL\n\nnz - number of nonzeros per row (same for all rows)\n\nIt is recommend to use instead of this routine\n\nIf is given then is ignored\n\nThe format, also called compressed row storage, is fully compatible with standard Fortran storage. That is, the stored row and column indices can begin at either one (as in Fortran) or zero.\n\nSpecify the preallocated storage with either or (not both). Set = and = for PETSc to control dynamic memory allocation.\n\nBy default, this format uses inodes (identical nodes) when possible, to improve numerical efficiency of matrix-vector products and solves. We search for consecutive rows with the same nonzero structure, thereby reusing matrix information to achieve increased efficiency."
    },
    {
        "link": "https://petsc.org/release/manual/mat",
        "document": "PETSc provides a variety of matrix implementations because no single matrix format is appropriate for all problems. Currently, we support dense storage and compressed sparse row storage (both sequential and parallel versions) for CPU and GPU based matrices, as well as several specialized formats. Additional specialized formats can be easily added.\n\nThis chapter describes the basics of using PETSc matrices in general (regardless of the particular format chosen) and discusses tips for efficient use of the several simple uniprocess and parallel matrix types. The use of PETSc matrices involves the following actions: create a particular type of matrix, insert values into it, process the matrix, use the matrix for various computations, and finally destroy the matrix. The application code does not need to know or care about the particular storage formats of the matrices.\n\nSome people like to use matrix-free methods, which do not require explicit storage of the matrix, for the numerical solution of partial differential equations. Similarly, users may already have a custom matrix data structure and routines for that data structure and would like to wrap their code up into a ; that is, provide their own custom matrix type. To use the PETSc provided matrix-free matrix that uses finite differencing to approximate the matrix-vector product use , see Matrix-Free Methods. To provide your own matrix operations (such as ) use the following command to create a structure without ever actually generating the matrix: Here and are the global matrix dimensions (rows and columns), and are the local matrix dimensions, and is a pointer to data needed by any user-defined shell matrix operations; the manual page has additional details about these parameters. Most matrix-free algorithms require only the application of the linear operator to a vector. To provide this action, the user must write a routine with the calling sequence and then associate it with the matrix, , by using the command Here is the name of the operation for matrix-vector multiplication. Within each user-defined routine (such as ), the user should call to obtain the user-defined context, , that was set by . This shell matrix can be used with the iterative linear equation solvers discussed in the following chapters. The routine can be used to set any other matrix operations as well. The file (source) provides a complete list of matrix operations, which have the form , where is the name (in all capital letters) of the user interface routine (for example, \\(\\to\\) ). All user-provided functions have the same calling sequence as the usual matrix interface routines, since the user-defined functions are intended to be accessed through the same interface, e.g., \\(\\to\\) . The final argument for needs to be cast to a , since the final argument could (depending on the ) be a variety of different functions. Note that can also be used as a “backdoor” means of introducing user-defined changes in matrix operations for other storage formats (for example, to override the default LU factorization routine supplied within PETSc for the format). However, we urge anyone who introduces such changes to use caution, since it would be very easy to accidentally create a bug in the new routine that could affect other routines as well. See also Matrix-Free Methods for details on one set of helpful utilities for using the matrix-free approach for nonlinear solvers.\n\nIn many iterative calculations (for instance, in a nonlinear equations solver), it is important for efficiency purposes to reuse the nonzero structure of a matrix, rather than determining it anew every time the matrix is generated. To retain a given matrix but reinitialize its contents, one can employ This routine will zero the matrix entries in the data structure but keep all the data that indicates where the nonzeros are located. In this way a new matrix assembly will be much less expensive, since no memory allocations or copies will be needed. Of course, one can also explicitly set selected matrix elements to zero by calling . By default, if new entries are made in locations where no nonzeros previously existed, space will be allocated for the new entries. To prevent the allocation of additional memory and simply discard those new entries, one can use the option Once the matrix has been assembled, one can factor it numerically without repeating the ordering or the symbolic factorization. This option can save some computational time, although it does require that the factorization is not done in-place. In the numerical solution of elliptic partial differential equations, it can be cumbersome to deal with Dirichlet boundary conditions. In particular, one would like to assemble the matrix without regard to boundary conditions and then at the end apply the Dirichlet boundary conditions. In numerical analysis classes this process is usually presented as moving the known boundary conditions to the right-hand side and then solving a smaller linear system for the interior unknowns. Unfortunately, implementing this requires extracting a large submatrix from the original matrix and creating its corresponding data structures. This process can be expensive in terms of both time and memory. One simple way to deal with this difficulty is to replace those rows in the matrix associated with known boundary conditions, by rows of the identity matrix (or some scaling of it). This action can be done with the command For sparse matrices this removes the data structures for certain rows of the matrix. If the pointer is , it even removes the diagonal entry. If the pointer is not null, it uses that given value at the pointer location in the diagonal entry of the eliminated rows. One nice feature of this approach is that when solving a nonlinear problem such that at each iteration the Dirichlet boundary conditions are in the same positions and the matrix retains the same nonzero structure, the user can call in the first iteration. Then, before generating the matrix in the second iteration the user should call From that point, no new values will be inserted into those (boundary) rows of the matrix. The functions and can also be used if for each process one provides the Dirichlet locations in the local numbering of the matrix. A drawback of is that it destroys the symmetry of a matrix. Thus one can use Note that with all of these for a given assembled matrix it can be only called once to update the x and b vector. It cannot be used if one wishes to solve multiple right-hand side problems for the same matrix since the matrix entries needed for updating the b vector are removed in its first use. Once the zeroed rows are removed the new matrix has possibly many rows with only a diagonal entry affecting the parallel load balancing. The preconditioner removes all the zeroed rows (and associated columns and adjusts the right-hand side based on the removed columns) and then rebalances the resulting rows of smaller matrix across the processes. Thus one can use to set the Dirichlet points and then solve with the preconditioner . Note if the original matrix was symmetric the smaller solved matrix will also be symmetric. Another matrix routine of interest is which converts the matrix to new matrix, , that has either the same or different format. Set to to copy the matrix, keeping the same matrix format. See (source) for other available matrix types; standard ones are , , , and . In certain applications it may be necessary for application codes to directly access elements of a matrix. This may be done by using the the command (for local rows only) The argument returns the number of nonzeros in that row, while and returns the column indices (with indices starting at zero) and values in the row. If only the column indices are needed (and not the corresponding matrix elements), one can use for the argument. Similarly, one can use for the argument. The user can only examine the values extracted with ; the values cannot be altered. To change the matrix entries, one must use . Once the user has finished using a row, he or she must call to free any space that was allocated during the call to .\n\nMany sparse matrix operations can be optimized by dividing the computation into two stages: a symbolic stage that creates any required data structures and does all the computations that do not require the matrices’ numerical values followed by one or more uses of a numerical stage that use the symbolically computed information. Examples of such operations include , , , and . PETSc uses two different API’s to take advantage of these optimizations. The first approach explicitly divides the computation in the API. This approach is used, for example, with , . The caller can take advantage of their knowledge of changes in the nonzero structure of the sparse matrices to call the appropriate routines as needed. In fact, they can use to determine if a new symbolic computation is needed. The drawback of this approach is that the caller of these routines has to manage the creation of new matrices when the nonzero structure changes. The second approach, as exemplified by , does not expose the two stages explicit in the API, instead a flag, is passed through the API to indicate if a symbolic data structure is already available or needs to be computed. Thus is called first, then can be called repeatedly with new numerical values in the A matrix. In theory, if the nonzero structure of A changes, the symbolic computations for B could be redone automatically inside the same B matrix when there is a change in the nonzero state of the A matrix. In practice, in PETSc, the for most PETSc routines only works if the nonzero structure does not change and the code may crash otherwise. The advantage of this approach (when the nonzero structure changes are handled correctly) is that the calling code does not need to keep track of the nonzero state of the matrices; everything “just works”. However, the caller must still know when it is the first call to the routine so the flag is being used. If the underlying implementation language supported detecting a yet to be initialized variable at run time, the flag would not be need. PETSc uses two approaches because the same programming problem was solved with two different ways during PETSc’s early development. A better model would combine both approaches; an explicit separation of the stages and a unified operation that internally utilized the two stages appropriately and also handled changes to the nonzero structure. Code could be simplified in many places with this approach, in most places the use of the unified API would replace the use of the separate stages.\n\nFor almost all unstructured grid computation, the distribution of portions of the grid across the process’s work load and memory can have a very large impact on performance. In most PDE calculations the grid partitioning and distribution across the processes can (and should) be done in a “pre-processing” step before the numerical computations. However, this does not mean it need be done in a separate, sequential program; rather, it should be done before one sets up the parallel grid data structures in the actual program. PETSc provides an interface to the ParMETIS (developed by George Karypis; see the PETSc installation instructions for directions on installing PETSc to use ParMETIS) to allow the partitioning to be done in parallel. PETSc does not currently provide directly support for dynamic repartitioning, load balancing by migrating matrix entries between processes, etc. For problems that require mesh refinement, PETSc uses the “rebuild the data structure” approach, as opposed to the “maintain dynamic data structures that support the insertion/deletion of additional vector and matrix rows and columns entries” approach. Partitioning in PETSc is organized around the object. One first creates a parallel matrix that contains the connectivity information about the grid (or other graph-type object) that is to be partitioned. This is done with the command The argument indicates the number of rows of the graph being provided by the given process, is the total number of columns; equal to the sum of all the . The arguments and are the row pointers and column pointers for the given rows; these are the usual format for parallel compressed sparse row storage, using indices starting at 0, not 1. This, of course, assumes that one has already distributed the grid (graph) information among the processes. The details of this initial distribution is not important; it could be simply determined by assigning to the first process the first \\(n_0\\) nodes from a file, the second process the next \\(n_1\\) nodes, etc. For example, we demonstrate the form of the and for a triangular grid where we Note that elements are not connected to themselves and we only indicate edge connections (in some contexts single vertex connections between elements may also be included). We use a space above to denote the transition between rows in the matrix; and Once the connectivity matrix has been created the following code will generate the renumbering required for the new partition The resulting contains for each local node the new global number of that node. The resulting contains the new process number that each local node has been assigned to. Now that a new numbering of the nodes has been determined, one must renumber all the nodes and migrate the grid information to the correct process. The command generates, see Application Orderings, an object that can be used in conjunction with the and to move the relevant grid information to the correct process and renumber the nodes etc. In this context, the new ordering is the “application” ordering so converts old global indices to new global indices and converts new global indices back to old global indices. PETSc does not currently provide tools that completely manage the migration and node renumbering, since it will be dependent on the particular data structure you use to store the grid information and the type of grid information that you need for your application. We do plan to include more support for this in the future, but designing the appropriate general user interface and providing a scalable implementation that can be used for a wide variety of different grids requires a great deal of time. See Finite Difference Jacobian Approximations and Matrix Factorization for discussions on performing graph coloring and computing graph reorderings to reduce fill in sparse matrix factorizations. Jennifer B Erway and Roummel F Marcia. On solving large-scale limited-memory quasi-newton equations. Linear Algebra and its Applications, 515:196–225, 2017. Jennifer B Erway and Roummel F Marcia. On solving large-scale limited-memory quasi-Newton equations. Linear Algebra and its Applications, 515:196–225, 2017. J. C. Gilbert and C. Lemarechal. Some numerical experiments with variable-storage quasi-newton algorithms. Mathematical Programming, 45:407–434, 1989. Andreas Griewank. Broyden updating, the good and the bad! Optimization Stories, Documenta Mathematica. Extra Volume: Optimization Stories, pages 301–315, 2012."
    },
    {
        "link": "https://mcs.anl.gov/petsc/petsc-3.11/docs/manual.pdf",
        "document": ""
    },
    {
        "link": "https://mcs.anl.gov/petsc/petsc-3.6/docs/manual.pdf",
        "document": ""
    },
    {
        "link": "https://petsc.org/release/manual/mat",
        "document": "PETSc provides a variety of matrix implementations because no single matrix format is appropriate for all problems. Currently, we support dense storage and compressed sparse row storage (both sequential and parallel versions) for CPU and GPU based matrices, as well as several specialized formats. Additional specialized formats can be easily added.\n\nThis chapter describes the basics of using PETSc matrices in general (regardless of the particular format chosen) and discusses tips for efficient use of the several simple uniprocess and parallel matrix types. The use of PETSc matrices involves the following actions: create a particular type of matrix, insert values into it, process the matrix, use the matrix for various computations, and finally destroy the matrix. The application code does not need to know or care about the particular storage formats of the matrices.\n\nSome people like to use matrix-free methods, which do not require explicit storage of the matrix, for the numerical solution of partial differential equations. Similarly, users may already have a custom matrix data structure and routines for that data structure and would like to wrap their code up into a ; that is, provide their own custom matrix type. To use the PETSc provided matrix-free matrix that uses finite differencing to approximate the matrix-vector product use , see Matrix-Free Methods. To provide your own matrix operations (such as ) use the following command to create a structure without ever actually generating the matrix: Here and are the global matrix dimensions (rows and columns), and are the local matrix dimensions, and is a pointer to data needed by any user-defined shell matrix operations; the manual page has additional details about these parameters. Most matrix-free algorithms require only the application of the linear operator to a vector. To provide this action, the user must write a routine with the calling sequence and then associate it with the matrix, , by using the command Here is the name of the operation for matrix-vector multiplication. Within each user-defined routine (such as ), the user should call to obtain the user-defined context, , that was set by . This shell matrix can be used with the iterative linear equation solvers discussed in the following chapters. The routine can be used to set any other matrix operations as well. The file (source) provides a complete list of matrix operations, which have the form , where is the name (in all capital letters) of the user interface routine (for example, \\(\\to\\) ). All user-provided functions have the same calling sequence as the usual matrix interface routines, since the user-defined functions are intended to be accessed through the same interface, e.g., \\(\\to\\) . The final argument for needs to be cast to a , since the final argument could (depending on the ) be a variety of different functions. Note that can also be used as a “backdoor” means of introducing user-defined changes in matrix operations for other storage formats (for example, to override the default LU factorization routine supplied within PETSc for the format). However, we urge anyone who introduces such changes to use caution, since it would be very easy to accidentally create a bug in the new routine that could affect other routines as well. See also Matrix-Free Methods for details on one set of helpful utilities for using the matrix-free approach for nonlinear solvers.\n\nIn many iterative calculations (for instance, in a nonlinear equations solver), it is important for efficiency purposes to reuse the nonzero structure of a matrix, rather than determining it anew every time the matrix is generated. To retain a given matrix but reinitialize its contents, one can employ This routine will zero the matrix entries in the data structure but keep all the data that indicates where the nonzeros are located. In this way a new matrix assembly will be much less expensive, since no memory allocations or copies will be needed. Of course, one can also explicitly set selected matrix elements to zero by calling . By default, if new entries are made in locations where no nonzeros previously existed, space will be allocated for the new entries. To prevent the allocation of additional memory and simply discard those new entries, one can use the option Once the matrix has been assembled, one can factor it numerically without repeating the ordering or the symbolic factorization. This option can save some computational time, although it does require that the factorization is not done in-place. In the numerical solution of elliptic partial differential equations, it can be cumbersome to deal with Dirichlet boundary conditions. In particular, one would like to assemble the matrix without regard to boundary conditions and then at the end apply the Dirichlet boundary conditions. In numerical analysis classes this process is usually presented as moving the known boundary conditions to the right-hand side and then solving a smaller linear system for the interior unknowns. Unfortunately, implementing this requires extracting a large submatrix from the original matrix and creating its corresponding data structures. This process can be expensive in terms of both time and memory. One simple way to deal with this difficulty is to replace those rows in the matrix associated with known boundary conditions, by rows of the identity matrix (or some scaling of it). This action can be done with the command For sparse matrices this removes the data structures for certain rows of the matrix. If the pointer is , it even removes the diagonal entry. If the pointer is not null, it uses that given value at the pointer location in the diagonal entry of the eliminated rows. One nice feature of this approach is that when solving a nonlinear problem such that at each iteration the Dirichlet boundary conditions are in the same positions and the matrix retains the same nonzero structure, the user can call in the first iteration. Then, before generating the matrix in the second iteration the user should call From that point, no new values will be inserted into those (boundary) rows of the matrix. The functions and can also be used if for each process one provides the Dirichlet locations in the local numbering of the matrix. A drawback of is that it destroys the symmetry of a matrix. Thus one can use Note that with all of these for a given assembled matrix it can be only called once to update the x and b vector. It cannot be used if one wishes to solve multiple right-hand side problems for the same matrix since the matrix entries needed for updating the b vector are removed in its first use. Once the zeroed rows are removed the new matrix has possibly many rows with only a diagonal entry affecting the parallel load balancing. The preconditioner removes all the zeroed rows (and associated columns and adjusts the right-hand side based on the removed columns) and then rebalances the resulting rows of smaller matrix across the processes. Thus one can use to set the Dirichlet points and then solve with the preconditioner . Note if the original matrix was symmetric the smaller solved matrix will also be symmetric. Another matrix routine of interest is which converts the matrix to new matrix, , that has either the same or different format. Set to to copy the matrix, keeping the same matrix format. See (source) for other available matrix types; standard ones are , , , and . In certain applications it may be necessary for application codes to directly access elements of a matrix. This may be done by using the the command (for local rows only) The argument returns the number of nonzeros in that row, while and returns the column indices (with indices starting at zero) and values in the row. If only the column indices are needed (and not the corresponding matrix elements), one can use for the argument. Similarly, one can use for the argument. The user can only examine the values extracted with ; the values cannot be altered. To change the matrix entries, one must use . Once the user has finished using a row, he or she must call to free any space that was allocated during the call to .\n\nMany sparse matrix operations can be optimized by dividing the computation into two stages: a symbolic stage that creates any required data structures and does all the computations that do not require the matrices’ numerical values followed by one or more uses of a numerical stage that use the symbolically computed information. Examples of such operations include , , , and . PETSc uses two different API’s to take advantage of these optimizations. The first approach explicitly divides the computation in the API. This approach is used, for example, with , . The caller can take advantage of their knowledge of changes in the nonzero structure of the sparse matrices to call the appropriate routines as needed. In fact, they can use to determine if a new symbolic computation is needed. The drawback of this approach is that the caller of these routines has to manage the creation of new matrices when the nonzero structure changes. The second approach, as exemplified by , does not expose the two stages explicit in the API, instead a flag, is passed through the API to indicate if a symbolic data structure is already available or needs to be computed. Thus is called first, then can be called repeatedly with new numerical values in the A matrix. In theory, if the nonzero structure of A changes, the symbolic computations for B could be redone automatically inside the same B matrix when there is a change in the nonzero state of the A matrix. In practice, in PETSc, the for most PETSc routines only works if the nonzero structure does not change and the code may crash otherwise. The advantage of this approach (when the nonzero structure changes are handled correctly) is that the calling code does not need to keep track of the nonzero state of the matrices; everything “just works”. However, the caller must still know when it is the first call to the routine so the flag is being used. If the underlying implementation language supported detecting a yet to be initialized variable at run time, the flag would not be need. PETSc uses two approaches because the same programming problem was solved with two different ways during PETSc’s early development. A better model would combine both approaches; an explicit separation of the stages and a unified operation that internally utilized the two stages appropriately and also handled changes to the nonzero structure. Code could be simplified in many places with this approach, in most places the use of the unified API would replace the use of the separate stages.\n\nFor almost all unstructured grid computation, the distribution of portions of the grid across the process’s work load and memory can have a very large impact on performance. In most PDE calculations the grid partitioning and distribution across the processes can (and should) be done in a “pre-processing” step before the numerical computations. However, this does not mean it need be done in a separate, sequential program; rather, it should be done before one sets up the parallel grid data structures in the actual program. PETSc provides an interface to the ParMETIS (developed by George Karypis; see the PETSc installation instructions for directions on installing PETSc to use ParMETIS) to allow the partitioning to be done in parallel. PETSc does not currently provide directly support for dynamic repartitioning, load balancing by migrating matrix entries between processes, etc. For problems that require mesh refinement, PETSc uses the “rebuild the data structure” approach, as opposed to the “maintain dynamic data structures that support the insertion/deletion of additional vector and matrix rows and columns entries” approach. Partitioning in PETSc is organized around the object. One first creates a parallel matrix that contains the connectivity information about the grid (or other graph-type object) that is to be partitioned. This is done with the command The argument indicates the number of rows of the graph being provided by the given process, is the total number of columns; equal to the sum of all the . The arguments and are the row pointers and column pointers for the given rows; these are the usual format for parallel compressed sparse row storage, using indices starting at 0, not 1. This, of course, assumes that one has already distributed the grid (graph) information among the processes. The details of this initial distribution is not important; it could be simply determined by assigning to the first process the first \\(n_0\\) nodes from a file, the second process the next \\(n_1\\) nodes, etc. For example, we demonstrate the form of the and for a triangular grid where we Note that elements are not connected to themselves and we only indicate edge connections (in some contexts single vertex connections between elements may also be included). We use a space above to denote the transition between rows in the matrix; and Once the connectivity matrix has been created the following code will generate the renumbering required for the new partition The resulting contains for each local node the new global number of that node. The resulting contains the new process number that each local node has been assigned to. Now that a new numbering of the nodes has been determined, one must renumber all the nodes and migrate the grid information to the correct process. The command generates, see Application Orderings, an object that can be used in conjunction with the and to move the relevant grid information to the correct process and renumber the nodes etc. In this context, the new ordering is the “application” ordering so converts old global indices to new global indices and converts new global indices back to old global indices. PETSc does not currently provide tools that completely manage the migration and node renumbering, since it will be dependent on the particular data structure you use to store the grid information and the type of grid information that you need for your application. We do plan to include more support for this in the future, but designing the appropriate general user interface and providing a scalable implementation that can be used for a wide variety of different grids requires a great deal of time. See Finite Difference Jacobian Approximations and Matrix Factorization for discussions on performing graph coloring and computing graph reorderings to reduce fill in sparse matrix factorizations. Jennifer B Erway and Roummel F Marcia. On solving large-scale limited-memory quasi-newton equations. Linear Algebra and its Applications, 515:196–225, 2017. Jennifer B Erway and Roummel F Marcia. On solving large-scale limited-memory quasi-Newton equations. Linear Algebra and its Applications, 515:196–225, 2017. J. C. Gilbert and C. Lemarechal. Some numerical experiments with variable-storage quasi-newton algorithms. Mathematical Programming, 45:407–434, 1989. Andreas Griewank. Broyden updating, the good and the bad! Optimization Stories, Documenta Mathematica. Extra Volume: Optimization Stories, pages 301–315, 2012."
    },
    {
        "link": "https://petsc.org/main/manualpages/Mat/MatGetOwnershipRange",
        "document": "For matrices that own values by row, excludes and , returns the range of matrix rows owned by this MPI process.\n\nn - one more than the global index of the last local row, use NULL to not obtain this value\n\nm - the global index of the first local row, use NULL to not obtain this value\n\nIf the was obtained from a with , then the range values are determined by the specific .\n\nIf the was created directly the range values are determined by the local size passed to or . If was passed as the local size, then the vector uses default values for the range using .\n\nFor certain , such as , it is better to use specific routines, such as , to determine the local values in the matrix.\n\nThe high argument is one more than the last element stored locally.\n\nFor all matrices it returns the range of matrix rows associated with rows of a vector that would contain the result of a matrix vector product with this matrix. See Matrix Layouts for details on matrix layouts."
    },
    {
        "link": "https://petsc.org/main/manual/mat",
        "document": "PETSc provides a variety of matrix implementations because no single matrix format is appropriate for all problems. Currently, we support dense storage and compressed sparse row storage (both sequential and parallel versions) for CPU and GPU based matrices, as well as several specialized formats. Additional specialized formats can be easily added.\n\nThis chapter describes the basics of using PETSc matrices in general (regardless of the particular format chosen) and discusses tips for efficient use of the several simple uniprocess and parallel matrix types. The use of PETSc matrices involves the following actions: create a particular type of matrix, insert values into it, process the matrix, use the matrix for various computations, and finally destroy the matrix. The application code does not need to know or care about the particular storage formats of the matrices.\n\nSome people like to use matrix-free methods, which do not require explicit storage of the matrix, for the numerical solution of partial differential equations. Similarly, users may already have a custom matrix data structure and routines for that data structure and would like to wrap their code up into a ; that is, provide their own custom matrix type. To use the PETSc provided matrix-free matrix that uses finite differencing to approximate the matrix-vector product use , see Matrix-Free Methods. To provide your own matrix operations (such as ) use the following command to create a structure without ever actually generating the matrix: Here and are the global matrix dimensions (rows and columns), and are the local matrix dimensions, and is a pointer to data needed by any user-defined shell matrix operations; the manual page has additional details about these parameters. Most matrix-free algorithms require only the application of the linear operator to a vector. To provide this action, the user must write a routine with the calling sequence and then associate it with the matrix, , by using the command Here is the name of the operation for matrix-vector multiplication. Within each user-defined routine (such as ), the user should call to obtain the user-defined context, , that was set by . This shell matrix can be used with the iterative linear equation solvers discussed in the following chapters. The routine can be used to set any other matrix operations as well. The file (source) provides a complete list of matrix operations, which have the form , where is the name (in all capital letters) of the user interface routine (for example, \\(\\to\\) ). All user-provided functions have the same calling sequence as the usual matrix interface routines, since the user-defined functions are intended to be accessed through the same interface, e.g., \\(\\to\\) . The final argument for needs to be cast to a , since the final argument could (depending on the ) be a variety of different functions. Note that can also be used as a “backdoor” means of introducing user-defined changes in matrix operations for other storage formats (for example, to override the default LU factorization routine supplied within PETSc for the format). However, we urge anyone who introduces such changes to use caution, since it would be very easy to accidentally create a bug in the new routine that could affect other routines as well. See also Matrix-Free Methods for details on one set of helpful utilities for using the matrix-free approach for nonlinear solvers.\n\nIn many iterative calculations (for instance, in a nonlinear equations solver), it is important for efficiency purposes to reuse the nonzero structure of a matrix, rather than determining it anew every time the matrix is generated. To retain a given matrix but reinitialize its contents, one can employ This routine will zero the matrix entries in the data structure but keep all the data that indicates where the nonzeros are located. In this way a new matrix assembly will be much less expensive, since no memory allocations or copies will be needed. Of course, one can also explicitly set selected matrix elements to zero by calling . By default, if new entries are made in locations where no nonzeros previously existed, space will be allocated for the new entries. To prevent the allocation of additional memory and simply discard those new entries, one can use the option Once the matrix has been assembled, one can factor it numerically without repeating the ordering or the symbolic factorization. This option can save some computational time, although it does require that the factorization is not done in-place. In the numerical solution of elliptic partial differential equations, it can be cumbersome to deal with Dirichlet boundary conditions. In particular, one would like to assemble the matrix without regard to boundary conditions and then at the end apply the Dirichlet boundary conditions. In numerical analysis classes this process is usually presented as moving the known boundary conditions to the right-hand side and then solving a smaller linear system for the interior unknowns. Unfortunately, implementing this requires extracting a large submatrix from the original matrix and creating its corresponding data structures. This process can be expensive in terms of both time and memory. One simple way to deal with this difficulty is to replace those rows in the matrix associated with known boundary conditions, by rows of the identity matrix (or some scaling of it). This action can be done with the command For sparse matrices this removes the data structures for certain rows of the matrix. If the pointer is , it even removes the diagonal entry. If the pointer is not null, it uses that given value at the pointer location in the diagonal entry of the eliminated rows. One nice feature of this approach is that when solving a nonlinear problem such that at each iteration the Dirichlet boundary conditions are in the same positions and the matrix retains the same nonzero structure, the user can call in the first iteration. Then, before generating the matrix in the second iteration the user should call From that point, no new values will be inserted into those (boundary) rows of the matrix. The functions and can also be used if for each process one provides the Dirichlet locations in the local numbering of the matrix. A drawback of is that it destroys the symmetry of a matrix. Thus one can use Note that with all of these for a given assembled matrix it can be only called once to update the x and b vector. It cannot be used if one wishes to solve multiple right-hand side problems for the same matrix since the matrix entries needed for updating the b vector are removed in its first use. Once the zeroed rows are removed the new matrix has possibly many rows with only a diagonal entry affecting the parallel load balancing. The preconditioner removes all the zeroed rows (and associated columns and adjusts the right-hand side based on the removed columns) and then rebalances the resulting rows of smaller matrix across the processes. Thus one can use to set the Dirichlet points and then solve with the preconditioner . Note if the original matrix was symmetric the smaller solved matrix will also be symmetric. Another matrix routine of interest is which converts the matrix to new matrix, , that has either the same or different format. Set to to copy the matrix, keeping the same matrix format. See (source) for other available matrix types; standard ones are , , , and . In certain applications it may be necessary for application codes to directly access elements of a matrix. This may be done by using the the command (for local rows only) The argument returns the number of nonzeros in that row, while and returns the column indices (with indices starting at zero) and values in the row. If only the column indices are needed (and not the corresponding matrix elements), one can use for the argument. Similarly, one can use for the argument. The user can only examine the values extracted with ; the values cannot be altered. To change the matrix entries, one must use . Once the user has finished using a row, he or she must call to free any space that was allocated during the call to .\n\nMany sparse matrix operations can be optimized by dividing the computation into two stages: a symbolic stage that creates any required data structures and does all the computations that do not require the matrices’ numerical values followed by one or more uses of a numerical stage that use the symbolically computed information. Examples of such operations include , , , and . PETSc uses two different API’s to take advantage of these optimizations. The first approach explicitly divides the computation in the API. This approach is used, for example, with , . The caller can take advantage of their knowledge of changes in the nonzero structure of the sparse matrices to call the appropriate routines as needed. In fact, they can use to determine if a new symbolic computation is needed. The drawback of this approach is that the caller of these routines has to manage the creation of new matrices when the nonzero structure changes. The second approach, as exemplified by , does not expose the two stages explicit in the API, instead a flag, is passed through the API to indicate if a symbolic data structure is already available or needs to be computed. Thus is called first, then can be called repeatedly with new numerical values in the A matrix. In theory, if the nonzero structure of A changes, the symbolic computations for B could be redone automatically inside the same B matrix when there is a change in the nonzero state of the A matrix. In practice, in PETSc, the for most PETSc routines only works if the nonzero structure does not change and the code may crash otherwise. The advantage of this approach (when the nonzero structure changes are handled correctly) is that the calling code does not need to keep track of the nonzero state of the matrices; everything “just works”. However, the caller must still know when it is the first call to the routine so the flag is being used. If the underlying implementation language supported detecting a yet to be initialized variable at run time, the flag would not be need. PETSc uses two approaches because the same programming problem was solved with two different ways during PETSc’s early development. A better model would combine both approaches; an explicit separation of the stages and a unified operation that internally utilized the two stages appropriately and also handled changes to the nonzero structure. Code could be simplified in many places with this approach, in most places the use of the unified API would replace the use of the separate stages.\n\nFor almost all unstructured grid computation, the distribution of portions of the grid across the process’s work load and memory can have a very large impact on performance. In most PDE calculations the grid partitioning and distribution across the processes can (and should) be done in a “pre-processing” step before the numerical computations. However, this does not mean it need be done in a separate, sequential program; rather, it should be done before one sets up the parallel grid data structures in the actual program. PETSc provides an interface to the ParMETIS (developed by George Karypis; see the PETSc installation instructions for directions on installing PETSc to use ParMETIS) to allow the partitioning to be done in parallel. PETSc does not currently provide directly support for dynamic repartitioning, load balancing by migrating matrix entries between processes, etc. For problems that require mesh refinement, PETSc uses the “rebuild the data structure” approach, as opposed to the “maintain dynamic data structures that support the insertion/deletion of additional vector and matrix rows and columns entries” approach. Partitioning in PETSc is organized around the object. One first creates a parallel matrix that contains the connectivity information about the grid (or other graph-type object) that is to be partitioned. This is done with the command The argument indicates the number of rows of the graph being provided by the given process, is the total number of columns; equal to the sum of all the . The arguments and are the row pointers and column pointers for the given rows; these are the usual format for parallel compressed sparse row storage, using indices starting at 0, not 1. This, of course, assumes that one has already distributed the grid (graph) information among the processes. The details of this initial distribution is not important; it could be simply determined by assigning to the first process the first \\(n_0\\) nodes from a file, the second process the next \\(n_1\\) nodes, etc. For example, we demonstrate the form of the and for a triangular grid where we Note that elements are not connected to themselves and we only indicate edge connections (in some contexts single vertex connections between elements may also be included). We use a space above to denote the transition between rows in the matrix; and Once the connectivity matrix has been created the following code will generate the renumbering required for the new partition The resulting contains for each local node the new global number of that node. The resulting contains the new process number that each local node has been assigned to. Now that a new numbering of the nodes has been determined, one must renumber all the nodes and migrate the grid information to the correct process. The command generates, see Application Orderings, an object that can be used in conjunction with the and to move the relevant grid information to the correct process and renumber the nodes etc. In this context, the new ordering is the “application” ordering so converts old global indices to new global indices and converts new global indices back to old global indices. PETSc does not currently provide tools that completely manage the migration and node renumbering, since it will be dependent on the particular data structure you use to store the grid information and the type of grid information that you need for your application. We do plan to include more support for this in the future, but designing the appropriate general user interface and providing a scalable implementation that can be used for a wide variety of different grids requires a great deal of time. See Finite Difference Jacobian Approximations and Matrix Factorization for discussions on performing graph coloring and computing graph reorderings to reduce fill in sparse matrix factorizations. Jennifer B Erway and Roummel F Marcia. On solving large-scale limited-memory quasi-newton equations. Linear Algebra and its Applications, 515:196–225, 2017. Jennifer B Erway and Roummel F Marcia. On solving large-scale limited-memory quasi-Newton equations. Linear Algebra and its Applications, 515:196–225, 2017. J. C. Gilbert and C. Lemarechal. Some numerical experiments with variable-storage quasi-newton algorithms. Mathematical Programming, 45:407–434, 1989. Andreas Griewank. Broyden updating, the good and the bad! Optimization Stories, Documenta Mathematica. Extra Volume: Optimization Stories, pages 301–315, 2012."
    },
    {
        "link": "https://scicomp.stackexchange.com/questions/2035/what-does-matgetownershiprange-do-for-sequential-matrices",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://mcs.anl.gov/petsc/petsc-3.6/docs/manualpages/Mat/MatGetOwnershipRange.html",
        "document": ""
    },
    {
        "link": "https://petsc.org/main/manualpages/Mat/MatSetValue",
        "document": "va - the value to insert\n\nj - the column location of the entry\n\ni - the row location of the entry\n\nThis value may be cached, so and MUST be called after all calls to have been completed.\n\nFor efficiency one should use and set several values simultaneously."
    },
    {
        "link": "https://mcs.anl.gov/petsc/petsc-3.5/src/mat/interface/matrix.c.html",
        "document": ""
    },
    {
        "link": "https://petsc.org/main/src/mat/interface/matrix.c.html",
        "document": ""
    },
    {
        "link": "http://web.mit.edu/tao-petsc_v3.7/src/mat/interface/matrix.c.html",
        "document": ""
    },
    {
        "link": "https://mcs.anl.gov/petsc/petsc-3.7/src/mat/interface/matrix.c.html",
        "document": ""
    }
]