[
    {
        "link": "https://gtk.org",
        "document": "Work with the language of your choice Develop your GTK app with your language of choice by using Language Bindings or wrappers and take full advantage of the official GNOME bindings which guarantee API stability and time-based releases. // When the button is clicked, close the window passed as an argument // When the application is launched… // … with a button in it … // … which closes the window when clicked # When the application is launched… # … with a button in it … # … which closes the window when clicked # When the application is launched… # … which closes the window when clicked // glib and other dependencies are re-exported by the gtk crate // When the application is launched… // … with a button in it … // … which closes the window when clicked // Create a new application with the builder pattern // When the button is clicked, close the window\n\nGTK has all the features that a widget toolkit needs to have. These features make it the most trusted toolkit for developing Linux applications. Projects built using GTK and its dependencies run on well known operating systems. GTK delivers the enticing features and superb performance which adds to your applications. GTK is written in C but has been designed to support a wide range of languages such as Python, JavaScript, C++, Rust and many more. GTK has a comprehensive collection of core widgets like Buttons, Windows, Toolbars for use in your application. GTK is a free and open-source project maintained by GNOME and an active community of contributors. GTK is released under the terms of the GNU Lesser General Public License. GTK boasts of an easy to use API which helps in decreasing your development time and help you achieve better results. GTK caters to many features like Native look and feel, theme support, Object-oriented approach that today’s developers look for in a toolkit. GTK is built on top of GLib. GLib provides the fundamental data types and system integration points to avoid duplicated code in applications.\n\nBy taking advantage of GTK being a cross-platform development tool and its easy to use API, you can develop amazing apps using the GTK. If you are interested in developing an app, get started now by developing this example application. GTK is a large project and relies on volunteers from around the world. To help us with the project development, hack away on the existing bugs and feature requests. If you want to ask questions about GTK, whether it’s for developing applications with GTK or contributing to GTK itself, you can use the GNOME Discourse instance, under the Platform/Core category. You can use tags like gtk or glib to narrow down the topic of discussion to specific libraries. You can also ask questions in our Matrix room.\n\nGet in touch with GTK developers through Matrix. Get updates about GTK and its community from GTK blog or on Mastodon. As regularly as possible, GTK team meetings take place at conferences and hackfests to discuss the future of GTK and define a roadmap. If you are a developer and want to contribute to GTK, you are more than welcome to do so."
    },
    {
        "link": "https://gtk.org/docs",
        "document": "Find out all the things you need to work with GTK as a Developer.\n\nGet set with the topic of your choice and explore the documentation. Get started now by building a Hello World app and playing around it. Learn how to setup your development environment with GTK recommended tools. Learn to integrate your favorite programming language with GTK through bindings. Dig deep into the API references for GTK3 and GTK4. Learn about the sub modules the GTK has been built upon. Figure out how to install GTK on different platforms.\n\nWe are here to help Catch up with our core team to get answers for your questions."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-create-gui-in-c-programming-using-gtk-toolkit",
        "document": "Many programming languages bolster GUI improvement as one of the centrepieces of its language highlights. C has no such library connected to it like the string library, IO library, etc, that we every now and again use. This weakness opened the skyline for engineers to pick from a wide assortment of GUI library toolbox accessible in C. GTK+ is one of them. It represents GIMP (GNU Image Manipulation Program) Toolkit and can be utilized to program current GUI interfaces.\n\nThe beneficial thing about GTK+ is that it is steady, developed, and its starting point can be followed back to the past times of X Windows that structure the centre GUI arrangement of Linux today. GTK is completely written in C and the GTK+ programming that we regularly use in Linux is additionally written in C. The work area administrators, for example, GNOME and XFCE, likewise are manufactured utilizing GTK.\n\nA GTK+ application isn’t limited to the Linux stage no one but; it very well may be ported to non-UNIX/Linux stages also.\n\nHere, we will cling to the fundamental type of GTK+, which is its C avatar on the Linux stage. The official webpage to download GTK+ is https://www.gtk.org. The site contains API documentation, instructional exercises, and other Gnome libraries that are frequently utilized alongside GTK. Truth be told, GTK is based over libraries, for example,\n• ATK: This library provides help to create accessibility tools such as sticky keys, screen readers, etc.\n• Glib: It is a universally useful utility library that offers help for threads, dynamic loading, event loops, low-level data structures, etc.\n• GObject: This library gives full-featured object-oriented help in C, without utilizing C++. This library encourages the language binding made for different languages to give you simple access to C APIs.\n• GDK (GIMP Drawing Toolkit): This is the designs library that gives low-level drawing capacities over Xlib.\n• Pango: This library helps in content and design rendering\n• Xlib: This library provides low-level graphics support for Linux system\n\nWhen composing code with GTK, we regularly locate that a significant number of the primitive data types are prefixed with ‘g‘ as in\n\nThese data types guarantee that the code can be recompiled on any platform without rolling out any improvements. These data types are characterized in these libraries to help in making it platform-independent.\n\nGUI programming inherent object-oriented in it which is the main issue. In this, a procedural worldview doesn’t fit consummately in this scheme. Thus, regardless of GTK being written in C, it gives object-oriented help through GObject. Note that this item arranged help has nothing to do with C++. C++ has its own GTK library, called gtkmm. GObject encourages a portion of the object-oriented principles, similar to polymorphism and inheritance with the assistance of macros. The following diagram illustrates the hierarchical relation.\n\nGtkWindow inherits GtkBin, which itself is a child of GtkContainer; in this manner, an object of GtkWindow can call the function defined in GtkBin or GtkContainer. This is an example of object-oriented implementation in C by GTK.\n\nLet us comprehend a couple of things from our first GTK code in C.\n• To start with, we incorporate the header file. This incorporates all the file one needs to make a GUI, including the Glib library.\n• Presently, we declare a pointer to GtkWidget, which is only a window for our situation. What’s more, another GtkWidget pointer will be the button. Review that GtkWidget is a top-level storage type for widgets in the hierarchy.\n• Next, we invoke gtk_init function to initialize the GTK+ libraries by passing the command line parameters of the main function.\n• All GTK+ applications are instated as such; it is an “absolute necessity” statement. It parses the command arguments line and returns back to the application. Accordingly, these parameters might be utilized to alter the run time conduct of the application.\n• Now, we create the window and the button.\n• The window type value GTK_WINDOW_TOPLEVEL implies that the window made will be a standard framed window. Other sort values might be GTK_WINDOW_POPUP, which implies a frameless dialogue window will be made.\n• When we make a window, it must be closable with the goal that the client should at any rate ready to close the application because of the client hitting the upper right close the window. This implies the window must have the option to react to an event (close event).\n• Like all windowing system, GTK+ additionally executes events and event handlers. Since the code that transmits the signal is interior to a specific object, we have to compose an interfacing callback function.\n• The organization of a regular callback function is:\n• The primary parameter represents the widget that produces the signal and the subsequent parameter is a void pointer that might be utilized for any reason. Along these lines, the callback function to deal with the close events of our window will be as per the following:\n• The function gtk_main_quit() shuts the application. Presently, we should interface the window object with the callback function.\n• Likewise, we make the callback function to deal with the button event and associate it with the button widget.\n• Since the button widget is contained inside the window, we should explicitly add it to the container.\n• Also, at long last, we show the widgets made in memory with the gtk_widget_show_all() function that takes a reference to the window we have made.\n• Finally, the gtk_main() function is summoned to begin the interactive procedure.\n• This is a key function on the grounds that ordinarily a C program ends in the wake of executing the last statement. Here, it passes the control of the program to GTK+ and stays away for the indefinite future until the gtk_main_quit event is activated by the client tapping the close button for our situation.\n\nBelow is the implementation of the above steps:\n• For Compiling write the following command (with GCC in Linux)\n• To run it write the following command\n\nConclusion\n\n GTK+ has all the GUI segments one needs to make an expert looking interface. The essential thought of GUI occasion driven programming with GTK+ isn’t very different from the one appeared in the model. Include a couple of more parts, utilize various sorts of compartments, play with designs, and obviously always remember to counsel the GTK+ documentation. Proficient developers frequently utilized RAD tools, for example, Glade to plan the GUI interface rapidly. Be that as it may, in the first place, have a go at composing the code without any preparation to get a vibe of what goes where and how it is really done. It will compensate you later."
    },
    {
        "link": "https://reddit.com/r/C_Programming/comments/17lkjmg/how_to_get_started_with_gui_programming_in_c",
        "document": "Recently I have been thinking of getting started with GUI programming with C. After a quick online search, GTK seemed the way to go but it had bad reviews for its UI in Windows.\n\nI think I can use the various individual APIs on Windows/Linux/Mac to build a cross-platform app but I would like to know if there is a standard pre-existing cross-platform library.\n\nAlong with these, it would be immensely helpful if someone could tell me what SDL and OpenGL are used for. I stumbled across them during my search and both seem similar so I am a little confused.\n\nTLDR: Can anyone answer the following questions:\n• What is a standard library to build cross-platform GUI applications in C (other than GTK) ?\n• What is the difference between OpenGL and SDL and what are their applications? Answers with examples for this question would be very helpful."
    },
    {
        "link": "https://docs.gtk.org/gtk3/getting_started.html",
        "document": "GTK is a widget toolkit. Each user interface created by GTK consists of widgets. This is implemented in C using GObject, an object-oriented framework for C. Widgets are organized in a hierachy. The window widget is the main container. The user interface is then built by adding buttons, drop-down menus, input fields, and other widgets to the window. If you are creating complex user interfaces it is recommended to use GtkBuilder and its GTK-specific markup description language, instead of assembling the interface manually. You can also use a visual user interface editor, like Glade.\n\nGTK is event-driven. The toolkit listens for events such as a click on a button, and passes the event to your application.\n\nThis chapter contains some tutorial information to get you started with GTK programming. It assumes that you have GTK, its dependencies and a C compiler installed and ready to use. If you need to build GTK itself first, refer to the Compiling the GTK libraries section in this reference.\n\nTo begin our introduction to GTK, we’ll start with a simple signal-based Gtk application. This program will create an empty 200×200 pixel window.\n\nSave the following code as a file named :\n\nYou can compile the program above with GCC using:\n\nFor more information on how to compile a GTK application, please refer to the Compiling GTK Applications section.\n\nAll GTK applications must include the header, which declares functions, types and macros required by GTK applications. Even if GTK installs multiple header files, only the top level header can be directly included by third party code. The compiler will abort with an error if any other header is directly included.\n\nIn a GTK application, the purpose of the function is to create a object and run it. In this example a pointer named is called and then initialized using .\n\nWhen creating a you need to pick an application identifier (a name) and input to as parameter. For this example is used but for choosing an identifier for your application see the corresponding tutorial on the GNOME developer documentation website. Lastly takes a as input for your application, if your application would have special needs.\n\nNext the signal is connected to the function defined above the function. The signal will be sent when your application is launched with on the line below. The function also takes as arguments the pointers to the command line arguments counter and string array; this allows GTK to parse specific command line arguments that control the behavior of GTK itself.\n\nWithin , the signal is emitted and we then proceed into the function of the application. Inside the function we want to construct our GTK window, so that a window is shown when the application is launched. The call to will create a new and store it inside the pointer. The window will have a frame, a title bar, and window controls depending on the platform.\n\nA window title is set using . This function takes a pointer and a string as input. As our window pointer is a pointer, we need to cast it to . But instead of casting via the typical C cast , window can be cast using the macro . will check if the pointer is an instance of the class, before casting, and emit a warning if the check fails. More information about this convention can be found in the GObject documentation.\n\nFinally the window size is set using and the window is then shown by GTK via .\n\nWhen you exit the window, by for example pressing the X, the function returns with a number which is saved inside an integer named . Afterwards, the object is freed from memory with . Finally the status integer is returned and the GTK application exits.\n\nWhile the program is running, GTK is receiving events. These are typically input events caused by the user interacting with your program, but also things like messages from the window manager or other applications. GTK processes these and as a result, signals may be emitted on your widgets. Connecting handlers for these signals is how you normally make your program do something in response to user input.\n\nThe following example is slightly more complex, and tries to showcase some of the capabilities of GTK.\n\nIn the long tradition of programming languages and libraries, it is called Hello, World.\n\nSave the following code as a file named :\n\nYou can compile the program above with GCC using:\n\nAs seen above, builds further upon by adding a button to our window, with the label “Hello World”. Two new pointers are declared to accomplish this, and . The variable is created to store a which is GTK’s way of controlling the size and layout of buttons. The is created and assigned to which takes a enumeration as parameter. The buttons which this box will contain can either be stored horizontally or vertically but this does not matter in this particular case as we are dealing with only one button. After initializing with horizontal orientation, the code adds the widget to the window widget using .\n\nNext the variable is initialized in similar manner. is called which returns a to be stored inside . Afterwards is added to our . Using the button is connected to a function in our app called , so that when the button is clicked, GTK will call this function. As the function does not use any data as input, is passed to it. calls with the string “Hello World” which will print Hello World in a terminal if the GTK application was started from one.\n\nAfter connecting , another signal is connected to the signal of the button using . This functions is similar to with the difference lying in how the callback function is treated. allows you to specify what the callback function should take as parameter by letting you pass it as data. In this case the function being called back is and the window pointer is passed to it. This has the effect that when the button is clicked, the whole GTK window is destroyed. In contrast, if a normal were used to connect the signal with , then the button itself would have been destroyed, not the window.\n\nThe rest of the code in is identical to .\n\nThe next section will elaborate further on how to add several widgets to your GTK application.\n\nWhen creating an application, you’ll want to put more than one widget inside a window. When you want to put more than one widget into a window, it becomes important to control how each widget is positioned and sized. This is where packing comes in.\n\nGTK comes with a large variety of layout containers whose purpose it is to control the layout of the child widgets that are added to them.\n\nThe following example shows how the container lets you arrange several buttons.\n\nSave the following code as a file named :\n\nYou can compile the program above with GCC using:\n\nWhen constructing a more complicated user interface, with dozens or hundreds of widgets, doing all the setup work in C code is cumbersome, and making changes becomes next to impossible.\n\nThankfully, GTK supports the separation of user interface layout from your business logic, by using UI descriptions in an XML format that can be parsed by the class.\n\nSave the following XML as a file named :\n\nSave the following code as a file named :\n\nYou can compile the program above with GCC using:\n\nNote that can also be used to construct objects that are not widgets, such as tree models, adjustments, etc. That is the reason the method we use here is called and returns a instead of a .\n\nwill load the file from the current directory; for installed applications, you can pass a full path to to make the execution of your program independent of the current directory. A common location to install UI descriptions and similar data is , but it will require installing the file separately from your binary.\n\nIt is also possible to embed the UI description in the source code as a string and use to load it; keeping the UI description in a separate file has several advantages: it is then possible to make minor adjustments to the UI without recompiling your program, and, more importantly, graphical UI editors such as Glade can load the file and allow you to create and modify your UI by point-and-click.\n\nIt is possible to have the UI description as a separate file during development, and then embed it in the compiled executable at build time by using .\n\nA binary: The main executable of your application; it typically is installed in the binaries directory, e.g. .\n\nA desktop file: The desktop file provides important information about the application to the desktop shell, such as its name, icon, D-Bus name, command line to launch it, etc. It is typically installed in .\n\nAn icon: The icon gets installed in the “hicolor” icon theme directory, e.g. , where it will be found regardless of the current icon theme.\n\nA settings schema: If the application uses , it will install its schema in and run to ensure that the schema can be used.\n\nOther resources: Other files, such as UI definition files, are best loaded from resources stored in the application binary itself. This eliminates the need for most of the files that would traditionally be installed in an application-specific location in .\n\nGTK includes application support that is built on top of . In this tutorial we’ll build a simple application by starting from scratch, adding more and more pieces over time. Along the way, we’ll learn about , templates, resources, application menus, settings, , , , , and more.\n\nThe full, buildable sources for these examples can be found in the directory of the GTK source distribution, or online in the GTK Git repository. You can build each example separately by using make with the file. For more information, see the included in the directory.\n\nWhen using , the function can be very simple. We just call and give it an instance of our application class.\n\nAll the application logic is in the application class, which is a subclass of . Our example does not yet have any interesting functionality. All it does is open a window when it is activated without arguments, and open the files it is given, if it is started with arguments.\n\nTo handle these two cases, we override the virtual function, which gets called when the application is launched without commandline arguments; and the virtual function, which gets called when the application is launched with command line arguments.\n\nTo learn more about entry points, consult the GIO documentation.\n\nAnother important class that is part of the application support in GTK is . It is typically subclassed as well. Our subclass does not do anything yet, so we will just get an empty window.\n\nAs part of the initial setup of our application, we also create an icon and a desktop file:\n\nNote that @` needs to be replaced with the actual path to the binary before this desktop file can be used.\n\nHere is what we’ve achieved so far:\n\nThis does not look very impressive yet, but our application is already presenting itself on the session bus, it has single-instance semantics, and it accepts files as commandline arguments.\n\nIn this step, we use a GtkBuilder template to associate a GtkBuilder ui file with our application window class.\n\nOur simple ui file puts a GtkHeaderBar on top of a GtkStack widget. The header bar contains a GtkStackSwitcher, which is a standalone widget to show a row of ‘tabs’ for the pages of a GtkStack.\n\nTo make use of this file in our application, we revisit our subclass, and call from the class init function to set the ui file as template for this class. We also add a call to in the instance init function to instantiate the template for each instance of our class.\n\nYou may have noticed that we used the variant of the function that sets a template. Now we need to use GLib’s resource functionality to include the ui file in the binary. This is commonly done by listing all resources in a file, such as this:\n\nThis file has to be converted into a C source file that will be compiled and linked into the application together with the other source files. To do so, we use the utility:\n\nOur application now looks like this:\n\nIn this step, we make our application show the content of all the files that it is given on the commandline.\n\nTo this end, we add a private struct to our application window subclass and keep a reference to the there. The function arranges things so that after instantiating the template, the stack member of the private struct will point to the widget of the same name from the template.\n\nNow we revisit the function that is called for each commandline argument, and construct a that we then add as a page to the stack:\n\nNote that we did not have to touch the stack switcher at all. It gets all its information from the stack that it belongs to. Here, we are passing the label to show for each file as the last argument to the function.\n\nOur application is beginning to take shape:\n\nAn application menu is shown by GNOME shell at the top of the screen. It is meant to collect infrequently used actions that affect the whole application.\n\nJust like the window template, we specify our application menu in a ui file, and add it as a resource to our binary.\n\nTo associate the app menu with the application, we have to call . Since app menus work by activating s, we also have to add a suitable set of actions to our application.\n\nBoth of these tasks are best done in the virtual function, which is guaranteed to be called once for each primary application instance:\n\nOur preferences menu item does not do anything yet, but the Quit menu item is fully functional. Note that it can also be activated by the usual + shortcut. The shortcut was added with .\n\nThe application menu looks like this:\n\nA typical application will have a some preferences that should be remembered from one run to the next. Even for our simple example application, we may want to change the font that is used for the content.\n\nWe are going to use GSettings to store our preferences. GSettings requires a schema that describes our settings:\n\nBefore we can make use of this schema in our application, we need to compile it into the binary form that GSettings expects. GIO provides macros to do this in Autotools-based projects, whereas Meson provides the same functionality through the module.\n\nNext, we need to connect our settings to the widgets that they are supposed to control. One convenient way to do this is to use GSettings bind functionality to bind settings keys to object properties, as we do here for the transition setting.\n\nThe code to connect the font setting is a little more involved, since there is no simple object property that it corresponds to, so we are not going to go into that here.\n\nAt this point, the application will already react if you change one of the settings, e.g. using the gsettings commandline tool. Of course, we expect the application to provide a preference dialog for these. So lets do that now. Our preference dialog will be a subclass of , and we’ll use the same techniques that we’ve already seen: templates, private structs, settings bindings.\n\nNext comes the dialog class:\n\nNow we revisit the function in our application class, and make it open a new preference dialog:\n\nAfter all this work, our application can now show a preference dialog like this:\n\nWe continue to flesh out the functionality of our application. For now, we add search. GTK supports this with and . The search bar is a widget that can slide in from the top of a container to present a search entry.\n\nWe add a toggle button to the header bar, which can be used to slide out the search bar below the header bar.\n\nImplementing the search needs quite a few code changes that we are not going to completely go over here. The central piece of the search implementation is a signal handler that listens for text changes in the search entry:\n\nWith the search bar, our application now looks like this:\n\nAs another piece of functionality, we are adding a sidebar, which demonstrates , and .\n\nThe code to populate the sidebar with buttons for the words found in each file is a little too involved to go into here. But we’ll look at the code to add the gears menu.\n\nAs expected by now, the gears menu is specified in a UI file:\n\nTo connect the menuitem to the show-words setting, we use a corresponding to the given key.\n\nWhat our application looks like now:\n\nWidgets and other objects have many useful properties.\n\nHere we show some ways to use them in new and flexible ways, by wrapping them in actions with or by binding them with .\n\nTo set this up, we add two labels to the header bar in our window template, named and , and bind them to struct members in the private struct, as we’ve seen a couple of times by now.\n\nWe add a new “Lines” menu item to the gears menu, which triggers the action:\n\nTo make this menu item do something, we create a property action for the visible property of the label, and add it to the actions of the window. The effect of this is that the visibility of the label gets toggled every time the action is activated.\n\nSince we want both labels to appear and disappear together, we bind the visible property of the widget to the same property of the widget.\n\nWe also need a function that counts the lines of the currently active tab, and updates the label. See the full source if you are interested in the details.\n\nThis brings our example application to this appearance:\n\nOur application already uses a , but so far it still gets a ‘normal’ window titlebar on top of that. This is a bit redundant, and we will now tell GTK to use the header bar as replacement for the titlebar. To do so, we move it around to be a direct child of the window, and set its type to be .\n\nA small extra bonus of using a header bar is that we get a fallback application menu for free. Here is how the application now looks, if this fallback is used:\n\nIf we set up the window icon for our window, the menu button will use that instead of the generic placeholder icon you see here.\n\nMany widgets, like buttons, do all their drawing themselves. You just tell them the label you want to see, and they figure out what font to use, draw the button outline and focus rectangle, etc. Sometimes, it is necessary to do some custom drawing. In that case, a might be the right widget to use. It offers a canvas on which you can draw by connecting to the signal.\n\nThe contents of a widget often need to be partially or fully redrawn, e.g. when another window is moved and uncovers part of the widget, or when the window containing it is resized. It is also possible to explicitly cause part or all of the widget to be redrawn, by calling or its variants. GTK takes care of most of the details by providing a ready-to-use Cairo context to the signal handler.\n\nThe following example shows a signal handler. It is a bit more complicated than the previous examples, since it also demonstrates input event handling by means of and signal handlers.\n\nSave the following example in a file name :\n\nYou can compile the program above with GCC using:"
    },
    {
        "link": "https://stackoverflow.com/questions/70057876/how-to-pass-multiple-widgets-in-a-gtk-single-button-click-event-in-c",
        "document": "So, I have many entries in a 2D array in my GTK application, like this:\n\nI want that, when the user clicks on the button, all the values in the entries be passed to the callback function in order to do some operations with the data.\n\nIts name suggest that a calculation is going to be done. Indeed, I intend to develop the code to do so, but prior to it I need to get the data in the entries.\n\nWhy I am not successful in getting the data?\n\nThe function calculate now is:\n\nI was successul in getting the text of the first entry, using , but how can I get the texts of the other entries?"
    },
    {
        "link": "https://stackoverflow.com/questions/22981978/c-add-g-signal-connect-event-correcty-to-a-button",
        "document": "I created a window using gtk.then I want to add click events to the button.I tried several way but not succeeded\n\nThen I tried to add a signal using below code\n\nThen It Compile but gave runtime error\n\nmy Smartart__onCloseClicked method is below"
    },
    {
        "link": "https://itstorage.net/index.php/lprogramm/cpgtkgladem/515-06gtkppc06",
        "document": "06 Gnome/GTK+ Programming in C: What is signals, events, and callbacks in GTK+?\n\nAll GUI applications are event driven. GTK+ applications are no exception. The applications start a main loop with the gtk.main() or the GtkApplication call, which continuously checks for newly generated events. If there is no event, the application waits and does nothing.\n\nEvents are messages from the X server to the application. When we click on a button widget, the clicked signal will be emitted. There are signals that all widgets inherit, such as destroy, and there are signals that are widget specific, such as toggled on a toggle button.\n\n\n\nProgrammers use signal handlers to react to various signals. These handlers are called callbacks among GTK programmers. This passing of control is done using the idea of \"signals\". When an event occurs, such as the press of a mouse button, the appropriate signal will be \"emitted\" by the widget that was pressed. This is how GTK does most of its useful work. The following code is passing pointer to structure of pointers to callback function.\n\nTo make a button perform an action, we set up a signal handler to catch these signals and call the appropriate function. This is done by using a function such as:\n\nHere we use the g_signal_connect () method to connect a callback on_button1_clicked() to a signal called clicked.\n\nWhere the first argument is the widget which will be emitting the signal (button1), and the second, the name of the signal you wish to catch (clicked). The third is the function you wish to be called when it is caught (on_button1_clicked), and the fourth, the data you wish to have passed to this function(NULL in this example).\n\nThe function specified in the third argument is called a \"callback function\", and should be of the form:\n\nWhere the first argument will be a pointer to the widget that emitted the signal, and the second, a pointer to the data given as the last argument to the gtk_signal_connect() function as shown above.\n\nThis example illustrates the above concepts. Follow the next procedures.\n\nDownload 06_GTK_C_btn_signal.c and review code and notes. You can change and customize each part of the code in your way. Let's learning by executing programs.\n\nDebianx@itstorage ~$ cat 06_GTK_C_btn_signal.c\n\n\n\n \n\n\n\n \n\n\n\n \n\n\n\n\n\n \n\n\n\n * DESCRIPTION: The GTK3 / C code This code will be introducing \n\n * the concept of Signals, events, and Callbacks. \n\n\n\n\n\n \n\n\n\n\n\n\n\n \n\n\n\n\n\n \n\n\n\n\n\n#include <gtk/gtk.h>\n\n\n\n \n\n \n\nstatic void activate (GtkApplication* app, gpointer user_data);\n\nvoid on_button1_clicked (GtkWidget *widget, gpointer user_data);\n\nvoid on_button2_clicked(GtkWidget *widget, gpointer data);\n\nvoid on_button3_clicked(GtkWidget *widget, gpointer data);\n\nstatic void destroy(GtkWidget *widget, gpointer data);\n\n \n\n \n\nstatic void\n\nactivate (GtkApplication* app,\n\n gpointer user_data)\n\n{\n\n\n\n GtkWidget *window;\n\n GtkWidget *vbox;\n\n GtkWidget *label;\n\n GtkWidget *button1; \n\n GtkWidget *button2;\n\n GtkWidget *button3;\n\n \n\n \n\n // Create a new window, give it a title and display it to the user. */ \n\n window = gtk_application_window_new (app);\n\n label = gtk_label_new (\"Gtk.Button, Gtk.Label, Signal and function\");\n\n button1 = gtk_button_new_with_label (\"Run a Function---button1\");\n\n button2 = gtk_button_new_with_label (\"Change Label---button2\");\n\n button3 = gtk_button_new_with_label (\"exit---button3\"); \n\n vbox = gtk_box_new(TRUE, 1);\n\n \n\n\n\n gtk_window_set_title (GTK_WINDOW (window), \"GNOME (GTK+) Form\");\n\n gtk_window_set_default_size (GTK_WINDOW (window), 320, 100);\n\n \n\n\n\n g_signal_connect (window, \"destroy\",\n\n G_CALLBACK (destroy), &window);\n\n // Passing pointer to structure of pointers to callback function \n\n g_signal_connect (button1, \"clicked\",\n\n G_CALLBACK (on_button1_clicked), NULL);\n\n // Passing pointer to structure of pointers to callback function \n\n g_signal_connect (button2, \"clicked\",\n\n G_CALLBACK (on_button2_clicked), label ); \n\n // When the button is clicked, destroy the window passed as an argument \n\n g_signal_connect (button3, \"clicked\",\n\n G_CALLBACK (on_button3_clicked), window);\n\n \n\n \n\n gtk_container_add(GTK_CONTAINER(window), vbox);\n\n gtk_box_pack_start(GTK_BOX(vbox), label, TRUE, TRUE, 0);\n\n gtk_box_pack_start(GTK_BOX(vbox), button1, TRUE, TRUE, 0);\n\n gtk_box_pack_start(GTK_BOX(vbox), button2, TRUE, TRUE, 0);\n\n gtk_box_pack_start(GTK_BOX(vbox), button3, TRUE, TRUE, 0);\n\n gtk_widget_show_all (window);\n\n \n\n /* Hand control over to the main loop. */ \n\n gtk_main();\n\n \n\n}\n\n \n\n \n\nvoid\n\non_button1_clicked (GtkWidget *widget, gpointer data)\n\n{\n\n g_print(\"Button1 Clicked:\n\n\");\n\n}\n\n \n\n \n\nvoid\n\non_button2_clicked (GtkWidget *widget, gpointer data)\n\n{\n\n GtkWidget *label1;\n\n label1 = (GtkWidget*) data;\n\n\n\n gtk_label_set_text(GTK_LABEL(label1), \"Button2 Clicked: \");\n\n}\n\n \n\n \n\nvoid\n\non_button3_clicked (GtkWidget *widget, gpointer data)\n\n{\n\n GtkWidget *win;\n\n win = (GtkWidget*) data;\n\n gtk_widget_destroy(win);\n\n}\n\n \n\n \n\nstatic void destroy( GtkWidget *widget,\n\n gpointer data )\n\n{\n\n gtk_main_quit ();\n\n}\n\n \n\n \n\nint main(int argc, char **argv)\n\n{\n\n GtkApplication *app;\n\n int status = 0;\n\n \n\n app = gtk_application_new(\"itstorage.co\", G_APPLICATION_FLAGS_NONE);\n\n g_signal_connect (app, \"activate\", G_CALLBACK (activate), NULL);\n\n status = g_application_run(G_APPLICATION (app), argc, argv);\n\n g_object_unref (app);\n\n \n\n return status;\n\n}"
    },
    {
        "link": "https://zetcode.com/gui/gtk2/gtkevents",
        "document": "In this part of the GTK+ programming tutorial, we talk about the event system.\n\nGTK+ is an event driven system. All GUI applications are event driven. The applications start a main loop, which continuously checks for newly generated events. If there is no event, the application waits and does nothing. In GTK+ an event is a message from the X server. When the event reaches a widget, it may react to this event by emitting a signal. The GTK+ programmer can connect a specific callback to the signal. The callback is a handler function that reacts to the signal.\n\nWhen a button is fired, it sends a signal. A button can be fired by a mouse pointer or with the key (provided the button has focus).\n\nIn the application, we have two signals: the signal and the signal.\n\nWe use the function to connect the signal to the callback.\n\nThe callback prints the \"clicked\" string to the console. The first parameter of the callback function is the object which emitted the signal. In our case it is the Click button. The second parameter is optional. We may send some data to the callback. In our case, we did not send any data; we provided a value to the fourth parameter of the function.\n\nIf we press on the x button located in the upper right corner of the titlebar, or we press + , a signal is emitted. The function is called, which terminates the application.\n\nThe next example shows how we react to window move events.\n\nIn the example, we show the current position of the upper-left corner of our window in the titlebar.\n\nThe event mask of the widget determines what kind of events will a particular widget receive. Some event are preconfigured, other events have to be added to the event mask. The adds a event type to the mask. The event type accounts for all size, position, and the stacking order of the window changes.\n\nThe is emitted when the size, position, or stacking of the widget's window has changed.\n\nThe callback function has three parameters: the object that emitted the signal, the , and the optional data. We determine the x, y coordinates, build a string, and set it to the window title.\n\nThe following example shows how we can react to an signal. The enter signal is emitted when we enter the area of a widget with a mouse pointer.\n\nIn the example, the background colour of the button widget is changes when we hover a mouse pointer over it.\n\nWe call the user function when the signal occurs.\n\nInside the callback, we change the background of the button by calling the function.\n\nWe can disconnect a callback from the signal. The next code example demonstrates such a case.\n\nIn the code example, we have a button and a check box. The check box connects or disconnects a callback from the signal of the button.\n\nThe returns the handler id which uniquely identifies the callback.\n\nThis code determines the state of the check box. Depending on the state, it connects the callback with the function or disconnects with the function.\n\nIn the next example, we show borderless window and learn how we can drag and move such a window.\n\nThe example demonstrates a drag and drop operation of a borderless window.\n\nWe remove the window decorations with the function. This means that the window will not have borders and titlebar.\n\nWe connect the window to the signal.\n\nInside the function, we perform the drag and drop operation. We check if the left mouse button was pressed. Then we call the function, which starts moving the window.\n\nThe following example demonstrates a timer example. Timers are used when we have some repeating tasks. It could be a clock, a count down, visual effects, or animations.\n\nThe example displays the current local time on the window. The Cairo 2D library is also used.\n\nWe draw the time inside the callback. The callback is connected to the signal, which is is emitted when the window is going to be redrawn.\n\nThis function registers the timer. The function is called repeatedly at regular intervals; in our case in every second. The timer function is called until it returns FALSE.\n\nThis calls the timer function immediately. Otherwise, there would be one sec delay.\n\nThis code draws the current time on the window. For more information about the Cairo 2D library, see the ZetCode's Cairo graphics tutorial.\n\nWhen the window is destroyed, it may happen that the timer function is called. This line prevents working on an already destroyed widget.\n\nThese lines determine the current local time. The time is stored in the global variable.\n\nThe function invalidates the window area, which then emits the signal.\n\nThis chapter was about events in GTK+."
    },
    {
        "link": "https://linuxquestions.org/questions/programming-9/connect-gtk%27s-key-event-with-button-pressed-267663",
        "document": "So, what about using \n\n \n\n For example, pressing \"k\" would call gtk_buttom_pressed() associated with the buttom, and releasing \"k\" would call gtk_buttom_released(). I think, this should model the effect, you want. An even more simple way seems to use gtk_buttom_clicked().\n\n \n\n However, I'm not very familar with C, so consider this a suggestion. I see. I just checked the usual button and it looks as if pressed when you click it with your mouse.So, what about using gtk_button_pressed() ? Looks like an obvious choice to me.For example, pressing \"k\" would call gtk_buttom_pressed() associated with the buttom, and releasing \"k\" would call gtk_buttom_released(). I think, this should model the effect, you want. An even more simple way seems to use gtk_buttom_clicked().However, I'm not very familar with C, so consider this a suggestion."
    }
]