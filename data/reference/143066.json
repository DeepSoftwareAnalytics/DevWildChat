[
    {
        "link": "https://react.dev/reference/react/useCallback",
        "document": "\n• Usage\n• Preventing an Effect from firing too often\n• Troubleshooting\n• Every time my component renders, returns a different function\n• I need to call for each list item in a loop, but it’s not allowed\n\nCall at the top level of your component to cache a function definition between re-renders:\n\nSee more examples below.\n• : The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if the have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it.\n• : The list of all reactive values referenced inside of the code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like . React will compare each dependency with its previous value using the comparison algorithm.\n\nOn the initial render, returns the function you have passed.\n\nDuring subsequent renders, it will either return an already stored function from the last render (if the dependencies haven’t changed), or return the function you have passed during this render.\n• is a Hook, so you can only call it at the top level of your component or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.\n• React will not throw away the cached function unless there is a specific reason to do that. For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache—for example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should match your expectations if you rely on as a performance optimization. Otherwise, a state variable or a ref may be more appropriate.\n\nWhen you optimize rendering performance, you will sometimes need to cache the functions that you pass to child components. Let’s first look at the syntax for how to do this, and then see in which cases it’s useful.\n\nTo cache a function between re-renders of your component, wrap its definition into the Hook:\n\nYou need to pass two things to :\n• A function definition that you want to cache between re-renders.\n• A including every value within your component that’s used inside your function.\n\nOn the initial render, the returned function you’ll get from will be the function you passed.\n\nOn the following renders, React will compare the dependencies with the dependencies you passed during the previous render. If none of the dependencies have changed (compared with ), will return the same function as before. Otherwise, will return the function you passed on this render.\n\nIn other words, caches a function between re-renders until its dependencies change.\n\nLet’s walk through an example to see when this is useful.\n\nSay you’re passing a function down from the to the component:\n\nYou’ve noticed that toggling the prop freezes the app for a moment, but if you remove from your JSX, it feels fast. This tells you that it’s worth trying to optimize the component.\n\nBy default, when a component re-renders, React re-renders all of its children recursively. This is why, when re-renders with a different , the component also re-renders. This is fine for components that don’t require much calculation to re-render. But if you verified a re-render is slow, you can tell to skip re-rendering when its props are the same as on last render by wrapping it in :\n\nWith this change, will skip re-rendering if all of its props are the same as on the last render. This is when caching a function becomes important! Let’s say you defined without :\n\nIn JavaScript, a or always creates a different function, similar to how the object literal always creates a new object. Normally, this wouldn’t be a problem, but it means that props will never be the same, and your optimization won’t work. This is where comes in handy:\n\nBy wrapping in , you ensure that it’s the same function between the re-renders (until dependencies change). You don’t have to wrap a function in unless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped in , and this lets it skip re-rendering. There are other reasons you might need which are described further on this page.\n\nShould you add useCallback everywhere? If your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful. Caching a function with is only valuable in a few cases:\n• You pass it as a prop to a component wrapped in . You want to skip re-rendering if the value hasn’t changed. Memoization lets your component re-render only if dependencies changed.\n• The function you’re passing is later used as a dependency of some Hook. For example, another function wrapped in depends on it, or you depend on this function from There is no benefit to wrapping a function in in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside is that code becomes less readable. Also, not all memoization is effective: a single value that’s “always new” is enough to break memoization for an entire component. Note that does not prevent creating the function. You’re always creating a function (and that’s fine!), but React ignores it and gives you back a cached function if nothing changed. In practice, you can make a lot of memoization unnecessary by following a few principles:\n• When a component visually wraps other components, let it accept JSX as children. Then, if the wrapper component updates its own state, React knows that its children don’t need to re-render.\n• Prefer local state and don’t lift state up any further than necessary. Don’t keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library.\n• Keep your rendering logic pure. If re-rendering a component causes a problem or produces some noticeable visual artifact, it’s a bug in your component! Fix the bug instead of adding memoization.\n• Avoid unnecessary Effects that update state. Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over.\n• Try to remove unnecessary dependencies from your Effects. For example, instead of memoization, it’s often simpler to move some object or a function inside an Effect or outside the component. If a specific interaction still feels laggy, use the React Developer Tools profiler to see which components benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it’s good to follow them in any case. In long term, we’re researching doing memoization automatically to solve this once and for all."
    },
    {
        "link": "https://geeksforgeeks.org/react-js-usecallback-hook",
        "document": "The useCallback Hook is a built-in React Hook that memoizes a callback function, preventing it from being recreated on every render unless its dependencies change. This is useful for optimizing performance, especially when passing functions as props to child components.\n• None The function to be memoized is passed as a parameter to useCallback.\n• None An array of dependencies determines when the function should be recreated.\n\nNow let’s see the actual difference the useCallback hook causes\n\nThis example creates a counter app without using the useCallback Hook.\n\nIn this example\n• None Functions are stored in a Set, which only keeps unique values.\n• None Clicking a button updates the state and displays the function count in an alert.\n\nThe issue here is that every time the component re-renders, new function references are created, causing unnecessary re-renders of child components and inefficient memory usage.\n\nTo solve this problem, we can use the useCallback hook. The useCallback hook is essential for optimizing performance in React applications, especially when passing callbacks to child components.\n\nIn this example\n• None The funcSet keeps track of unique function references.\n• None Clicking a button updates the corresponding state and displays the function count in an alert.\n\nWhen to Use useCallback?\n\nYou should use useCallback when\n• None Passing functions as props to child components to prevent unnecessary re-renders.\n\nHowever, avoid overusing useCallback, as it adds an extra layer of complexity and can sometimes lead to premature optimizations.\n\nThe useCallback and useMemo Hooks are similar, but they serve different purposes:\n• None useMemo returns a memoized value, optimizing expensive calculations by caching the result.\n• None Use useCallback for passing stable function references, and useMemo for optimizing computations.\n\nUsing correctly can enhance performance, but excessive use may introduce unnecessary complexity. Here are some best practices:\n• Use it for expensive function recreations:\n• Avoid unnecessary usage: If a function is recreated but doesn’t cause performance issues, may not be needed.\n• Measure before optimizing: Use React DevTools to analyze performance before applying"
    },
    {
        "link": "https://legacy.reactjs.org/docs/hooks-reference.html",
        "document": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.\n\nThis page describes the APIs for the built-in Hooks in React.\n\nIf you’re new to Hooks, you might want to check out the overview first. You may also find useful information in the frequently asked questions section.\n\nReturns a stateful value, and a function to update it.\n\nDuring the initial render, the returned state ( ) is the same as the value passed as the first argument ( ).\n\nThe function is used to update the state. It accepts a new state value and enqueues a re-render of the component.\n\nDuring subsequent re-renders, the first value returned by will always be the most recent state after applying updates.\n\nIf the new state is computed using the previous state, you can pass a function to . The function will receive the previous value, and return an updated value. Here’s an example of a counter component that uses both forms of :\n\nThe ”+” and ”-” buttons use the functional form, because the updated value is based on the previous value. But the “Reset” button uses the normal form, because it always sets the count back to the initial value.\n\nIf your update function returns the exact same value as the current state, the subsequent rerender will be skipped completely.\n\nThe argument is the state used during the initial render. In subsequent renders, it is disregarded. If the initial state is the result of an expensive computation, you may provide a function instead, which will be executed only on the initial render:\n\nIf you update a State Hook to the same value as the current state, React will bail out without rendering the children or firing effects. (React uses the comparison algorithm.)\n\nNote that React may still need to render that specific component again before bailing out. That shouldn’t be a concern because React won’t unnecessarily go “deeper” into the tree. If you’re doing expensive calculations while rendering, you can optimize them with .\n\nReact may group several state updates into a single re-render to improve performance. Normally, this improves performance and shouldn’t affect your application’s behavior.\n\nBefore React 18, only updates inside React event handlers were batched. Starting with React 18, batching is enabled for all updates by default. Note that React makes sure that updates from several different user-initiated events — for example, clicking a button twice — are always processed separately and do not get batched. This prevents logical mistakes.\n\nIn the rare case that you need to force the DOM update to be applied synchronously, you may wrap it in . However, this can hurt performance so do this only where needed.\n\nMutations, subscriptions, timers, logging, and other side effects are not allowed inside the main body of a function component (referred to as React’s render phase). Doing so will lead to confusing bugs and inconsistencies in the UI.\n\nInstead, use . The function passed to will run after the render is committed to the screen. Think of effects as an escape hatch from React’s purely functional world into the imperative world.\n\nBy default, effects run after every completed render, but you can choose to fire them only when certain values have changed.\n\nOften, effects create resources that need to be cleaned up before the component leaves the screen, such as a subscription or timer ID. To do this, the function passed to may return a clean-up function. For example, to create a subscription:\n\nThe clean-up function runs before the component is removed from the UI to prevent memory leaks. Additionally, if a component renders multiple times (as they typically do), the previous effect is cleaned up before executing the next effect. In our example, this means a new subscription is created on every update. To avoid firing an effect on every update, refer to the next section.\n\nUnlike and , the function passed to fires after layout and paint, during a deferred event. This makes it suitable for the many common side effects, like setting up subscriptions and event handlers, because most types of work shouldn’t block the browser from updating the screen.\n\nHowever, not all effects can be deferred. For example, a DOM mutation that is visible to the user must fire synchronously before the next paint so that the user does not perceive a visual inconsistency. (The distinction is conceptually similar to passive versus active event listeners.) For these types of effects, React provides one additional Hook called . It has the same signature as , and only differs in when it is fired.\n\nAdditionally, starting in React 18, the function passed to will fire synchronously before layout and paint when it’s the result of a discrete user input such as a click, or when it’s the result of an update wrapped in . This behavior allows the result of the effect to be observed by the event system, or by the caller of .\n\nEven in cases where is deferred until after the browser has painted, it’s guaranteed to fire before any new renders. React will always flush a previous render’s effects before starting a new update.\n\nThe default behavior for effects is to fire the effect after every completed render. That way an effect is always recreated if one of its dependencies changes.\n\nHowever, this may be overkill in some cases, like the subscription example from the previous section. We don’t need to create a new subscription on every update, only if the prop has changed.\n\nTo implement this, pass a second argument to that is the array of values that the effect depends on. Our updated example now looks like this:\n\nNow the subscription will only be recreated when changes.\n\nThe array of dependencies is not passed as arguments to the effect function. Conceptually, though, that’s what they represent: every value referenced inside the effect function should also appear in the dependencies array. In the future, a sufficiently advanced compiler could create this array automatically.\n\nAccepts a context object (the value returned from ) and returns the current context value for that context. The current context value is determined by the prop of the nearest above the calling component in the tree.\n\nWhen the nearest above the component updates, this Hook will trigger a rerender with the latest context passed to that provider. Even if an ancestor uses or , a rerender will still happen starting at the component itself using .\n\nDon’t forget that the argument to must be the context object itself:\n\nA component calling will always re-render when the context value changes. If re-rendering the component is expensive, you can optimize it by using memoization.\n\nPutting it together with Context.Provider\n\nThis example is modified for hooks from a previous example in the Context Advanced Guide, where you can find more information about when and how to use Context.\n\nThe following Hooks are either variants of the basic ones from the previous section, or only needed for specific edge cases. Don’t stress about learning them up front.\n\nAn alternative to . Accepts a reducer of type , and returns the current state paired with a method. (If you’re familiar with Redux, you already know how this works.)\n\nis usually preferable to when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one. also lets you optimize performance for components that trigger deep updates because you can pass down instead of callbacks.\n\nHere’s the counter example from the section, rewritten to use a reducer:\n\nThere are two different ways to initialize state. You may choose either one depending on the use case. The simplest way is to pass the initial state as a second argument:\n\nYou can also create the initial state lazily. To do this, you can pass an function as the third argument. The initial state will be set to .\n\nIt lets you extract the logic for calculating the initial state outside the reducer. This is also handy for resetting the state later in response to an action:\n\nIf you return the same value from a Reducer Hook as the current state, React will bail out without rendering the children or firing effects. (React uses the comparison algorithm.)\n\nNote that React may still need to render that specific component again before bailing out. That shouldn’t be a concern because React won’t unnecessarily go “deeper” into the tree. If you’re doing expensive calculations while rendering, you can optimize them with .\n\nPass an inline callback and an array of dependencies. will return a memoized version of the callback that only changes if one of the dependencies has changed. This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. ).\n\nPass a “create” function and an array of dependencies. will only recompute the memoized value when one of the dependencies has changed. This optimization helps to avoid expensive calculations on every render.\n\nRemember that the function passed to runs during rendering. Don’t do anything there that you wouldn’t normally do while rendering. For example, side effects belong in , not .\n\nIf no array is provided, a new value will be computed on every render.\n\nYou may rely on as a performance optimization, not as a semantic guarantee. In the future, React may choose to “forget” some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. Write your code so that it still works without — and then add it to optimize performance.\n\nreturns a mutable ref object whose property is initialized to the passed argument ( ). The returned object will persist for the full lifetime of the component.\n\nA common use case is to access a child imperatively:\n\nEssentially, is like a “box” that can hold a mutable value in its property.\n\nYou might be familiar with refs primarily as a way to access the DOM. If you pass a ref object to React with , React will set its property to the corresponding DOM node whenever that node changes.\n\nHowever, is useful for more than the attribute. It’s handy for keeping any mutable value around similar to how you’d use instance fields in classes.\n\nThis works because creates a plain JavaScript object. The only difference between and creating a object yourself is that will give you the same ref object on every render.\n\nKeep in mind that doesn’t notify you when its content changes. Mutating the property doesn’t cause a re-render. If you want to run some code when React attaches or detaches a ref to a DOM node, you may want to use a callback ref instead.\n\ncustomizes the instance value that is exposed to parent components when using . As always, imperative code using refs should be avoided in most cases. should be used with :\n\nIn this example, a parent component that renders would be able to call .\n\nThe signature is identical to , but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside will be flushed synchronously, before the browser has a chance to paint.\n\nPrefer the standard when possible to avoid blocking visual updates.\n\ncan be used to display a label for custom hooks in React DevTools.\n\nFor example, consider the custom Hook described in “Building Your Own Hooks”:\n\nIn some cases formatting a value for display might be an expensive operation. It’s also unnecessary unless a Hook is actually inspected.\n\nFor this reason accepts a formatting function as an optional second parameter. This function is only called if the Hooks are inspected. It receives the debug value as a parameter and should return a formatted display value.\n\nFor example a custom Hook that returned a value could avoid calling the function unnecessarily by passing the following formatter:\n\naccepts a value and returns a new copy of the value that will defer to more urgent updates. If the current render is the result of an urgent update, like user input, React will return the previous value and then render the new value after the urgent render has completed.\n\nThis hook is similar to user-space hooks which use debouncing or throttling to defer updates. The benefits to using is that React will work on the update as soon as other work finishes (instead of waiting for an arbitrary amount of time), and like , deferred values can suspend without triggering an unexpected fallback for existing content.\n\nonly defers the value that you pass to it. If you want to prevent a child component from re-rendering during an urgent update, you must also memoize that component with or :\n\nMemoizing the children tells React that it only needs to re-render them when changes and not when changes. This caveat is not unique to , and it’s the same pattern you would use with similar hooks that use debouncing or throttling.\n\nReturns a stateful value for the pending state of the transition, and a function to start it.\n\nlets you mark updates in the provided callback as transitions:\n\nindicates when a transition is active to show a pending state:\n\nis a hook for generating unique IDs that are stable across the server and client, while avoiding hydration mismatches.\n\nFor a basic example, pass the directly to the elements that need it:\n\nFor multiple IDs in the same component, append a suffix using the same :\n\nThe following Hooks are provided for library authors to integrate libraries deeply into the React model, and are not typically used in application code.\n\nis a hook recommended for reading and subscribing from external data sources in a way that’s compatible with concurrent rendering features like selective hydration and time slicing.\n\nThis method returns the value of the store and accepts three arguments:\n• : function to register a callback that is called whenever the store changes.\n• : function that returns the current value of the store.\n• : function that returns the snapshot used during server rendering.\n\nThe most basic example simply subscribes to the entire store:\n\nHowever, you can also subscribe to a specific field:\n\nWhen server rendering, you must serialize the store value used on the server, and provide it to . React will use this snapshot during hydration to prevent server mismatches:\n\nThe signature is identical to , but it fires synchronously before all DOM mutations. Use this to inject styles into the DOM before reading layout in . Since this hook is limited in scope, this hook does not have access to refs and cannot schedule updates."
    },
    {
        "link": "https://medium.com/zestgeek/mastering-reacts-usecallback-hook-for-enhanced-performance-fcf23aa805d6",
        "document": "In React development, optimizing performance is crucial for creating smooth and efficient user interfaces. The hook plays a vital role in achieving this goal by memoizing callback functions and preventing unnecessary re-renders. In this article, we'll delve into the hook in React, understand its purpose, and explore practical examples to illustrate its usage.\n\nIntroduced in React 16.8 as part of the hooks API, is a powerful tool for optimizing React applications. It memoizes functions, returning a memoized version of the function that only changes if one of the dependencies has changed. This prevents the recreation of functions on each render, leading to performance improvements, especially in scenarios where functions are passed down as props to child components.\n\nLet’s start by examining a basic example of how to use in a React component:\n\nIn this example:\n• We have a simple component that receives a function as a prop and renders a button element.\n• Inside the component, we define the function using . Since does not depend on any external variables, we pass an empty dependency array.\n• By memoizing with , we ensure that it remains the same across re-renders unless its dependencies change.\n\nis particularly useful when optimizing performance in scenarios involving child components. Let's consider an example where multiple child components depend on a callback function:\n\nIn this example:\n• We have a that receives a function as a prop and renders a button.\n• The renders two instances of , both sharing the same function.\n• By using to memoize in the , we ensure that both instances of receive the same memoized function, optimizing performance by avoiding unnecessary re-renders.\n\nThe hook in React is a powerful tool for optimizing performance by memoizing callback functions. By memoizing functions, React can avoid unnecessary re-renders, leading to smoother user experiences and improved application performance. Whether optimizing callback functions in parent components or ensuring consistent performance in child components, empowers developers to build high-performance React applications with ease. By understanding and leveraging effectively, developers can unlock the full potential of React's performance optimization capabilities."
    },
    {
        "link": "https://dhiwise.com/post/understanding-the-usecallback-hook-a-guide-to-react",
        "document": "Majorly busy listening to songs, scrolling Reddit and reading other’s articles. And yeah, also a senior frontend engineer with 4+ years of experience, crafting performant and stunning UI using React, Next.js, JavaScript, TailwindCSS, TypeScript.\n\nIn the world of web development, ReactJS has become an essential tool for building interactive user interfaces. Its use of hooks, such as useCallback, has revolutionized the way we approach coding. The useCallback hook is a powerful feature that helps to optimize the performance of your React applications. It enables you to return a memoized version of a callback function that changes only if one of its dependencies changes.\n\nThis is crucial in scenarios where passing callbacks to optimized child components can prevent unnecessary renders, thus improving the performance of the application. The useCallback hook is used to ensure that the same function object is used across multiple renders, which can be vital in preventing unnecessary re-renders and improving component speed.\n\nThe primary purpose of the useCallback hook is to prevent unnecessary renders in your React application. Every time a parent component re-renders, a new function object is created. This can cause unnecessary re-rendering of child components that depend on this function, especially if they are optimized with React.memo or shouldComponentUpdate.\n\nThe useCallback hook helps to prevent this by returning the same function object across multiple renders unless its dependencies change. This way, the child components receive the same function object, and unnecessary re-renders are prevented. This is particularly useful when passing callbacks to optimized child components.\n\nIn the above example, the increment function is wrapped in useCallback to ensure that the same function object is used across multiple renders. This prevents unnecessary re-renders of the Counter component.\n\nUnderstanding the Difference Between useCallback and Callback in React\n\nIn React, a callback is a function that is passed as a prop to a child component and is invoked by the child component. However, every time the parent component re-renders, a new instance of the callback function is created. This can lead to unnecessary re-renders of the child component if it is an optimized component.\n\nOn the other hand, the useCallback hook returns a memoized version of the callback function that only changes if one of the dependencies has changed. This ensures that the same function object is used across multiple renders, thereby optimizing the performance of your application by preventing unnecessary re-renders.\n\nIn the above example, the handler function is passed to the ChildComponent as a prop. By using useCallback, we ensure that the same function object is used across multiple renders of the ParentComponent, preventing unnecessary re-renders of the ChildComponent.\n\nBoth useCallback and useMemo are React hooks used for optimization purposes. However, they serve slightly different purposes.\n\nThe useCallback hook returns a memoized version of a function. Its result is a function. It is used when you want to prevent a function from being re-created every time a component re-renders.\n\nOn the other hand, useMemo returns a memoized value. Its result can be any type. It is used when you want to prevent expensive computations from being run on every render.\n\nIn the above example, useCallback is used to memoize a function, while useMemo is used to memoize a value. Both hooks take a dependency array as a second argument, which determines when the memoized function or value should be re-computed.\n\nThe Drawbacks of Using useCallback\n\nWhile useCallback can be a powerful tool for optimizing React applications, it's not without its drawbacks. One of the main drawbacks is the complexity it can add to your code. Understanding when to use useCallback can be tricky, especially for beginners. It's also easy to misuse useCallback, which can lead to bugs that are difficult to debug.\n\nAnother drawback of useCallback is the overhead of memory usage. Each time a function is memoized using useCallback, it consumes memory. If you're memoizing a large number of functions, this can lead to increased memory usage which could potentially slow down your application.\n\nFinally, useCallback can lead to unnecessary re-renders if not used correctly. If the dependency array is not correctly defined, the function may be re-created on every render, defeating the purpose of useCallback and leading to unnecessary re-renders.\n\nIn the above example, the useCallback hook is used incorrectly. The dependency array includes a prop value that changes on every render, causing the function to be re-created on every render and leading to unnecessary re-renders.\n\nIf the drawbacks of useCallback seem too daunting, there are alternatives you can consider. One such alternative is to use a class component and bind the method in the constructor. This ensures that the same function object is used across multiple renders.\n\nAnother alternative is to define the function inside the component without using useCallback. This will create a new function on every render, but in many cases, the performance impact is negligible. This approach is simpler and easier to understand, making it a good option for beginners or in cases where performance is not a critical concern.\n\nIn the above example, the handleClick method is bound in the constructor of a class component, ensuring that the same function object is used across multiple renders.\n\nThe Difference Between useEffect and useCallback\n\nBoth useEffect and useCallback are hooks in React that serve different purposes. useEffect is used to perform side effects in functional components. These side effects could be data fetching, subscriptions, or manually changing the DOM. It runs after every render, including the first one, unless a dependency array is provided.\n\nuseCallback, on the other hand, is used to memoize functions in order to avoid wasteful re-rendering. It returns a memoized version of the callback function that changes only when one of the dependencies changes. When passing callbacks to optimized child components, this is handy.\n\nIn the above example, useCallback is used to memoize a function, while useEffect is used to perform a side effect.\n\nThe Role of useCallback in Preventing Unnecessary Renders\n\nOne of the main benefits of useCallback is its ability to prevent unnecessary renders. In React, when a parent component re-renders, all child components also re-render by default. This can lead to performance issues, especially in larger applications.\n\nThe useCallback hook can help prevent these unnecessary renders by ensuring that the same function object is used across multiple renders. When a function is wrapped in useCallback, it will only be re-created if its dependencies change. This means that if the function is passed as a prop to a child component, the child component will not re-render unless the function's dependencies change.\n\nIn the above example, the handler function is passed to the ChildComponent as a prop. By using useCallback, we ensure that the same function object is used across multiple renders of the ParentComponent, preventing unnecessary re-renders of the ChildComponent.\n\nUsing useCallback for Performance Optimization in React\n\nWhen it comes to performance optimization in React, useCallback is a valuable tool. It can significantly reduce the number of re-renders, especially in larger applications with many components. By ensuring the same function object is used across multiple renders, useCallback can prevent unnecessary re-renders and improve the overall performance of your application.\n\nHowever, it's important to note that useCallback should not be used indiscriminately. It's not always necessary to use useCallback, and in some cases, it can even lead to worse performance due to the overhead of memory usage. It's best to use useCallback when you have a function that is passed as a prop to an optimized child component and when the function's dependencies change infrequently.\n\nIn the above example, an expensive function is memoized using useCallback. This ensures that the expensive computation is not performed on every render, thereby improving the performance of the App component.\n\nLet's look at a practical example of how useCallback can be used in a React application. Consider a scenario where you have a parent component that passes a handler function to a child component. Without useCallback, the handler function would be re-created on every render of the parent component, causing the child component to re-render as well.\n\nIn the above example, the increment function is wrapped in useCallback, ensuring that it is not re-created on every render of the ParentComponent. As a result, the ChildComponent does not re-render unless the count state changes, thereby preventing unnecessary renders.\n\nThe Importance of useCallback in Modern Web Development\n\nIn conclusion, useCallback is a powerful hook in React that can greatly improve the performance of your applications by preventing unnecessary renders. It allows you to memoize functions and ensure that the same function object is used across multiple renders.\n\nHowever, useCallback should be used judiciously. While it can improve performance in some cases, it can also add complexity to your code and increase memory usage. It's best to use useCallback when necessary, such as when passing functions as props to optimized child components.\n\nRemember, the best way to improve performance in React is to write efficient, clean code. useCallback is just one tool in your optimization toolbox. Always consider the trade-offs before deciding to use it. Happy coding!\n\nShort on time? Speed things up with DhiWise!\n\nTired of manually designing screens, coding on weekends, and technical debt? Let DhiWise handle it for you!\n\nYou can build an e-commerce store, healthcare app, portfolio, blogging website, social media or admin panel right away. Use our library of 40+ pre-built free templates to create your first application using DhiWise."
    },
    {
        "link": "https://stackoverflow.com/questions/66306194/avoid-re-render-with-usecallback",
        "document": "You are seeing a re-render on the sibling component, because each time you hit the button to update the counter, you are actually updating a state value in the parent component , which causes a re-render on that component as well.\n\nAnd since is re-rendered, child components will re-render as well, which in this case includes both elements.\n\nA solution to prevent this, would be wrapping CountButton component with React.memo(). This will prevent a re-render on a component that didn't have any change on the props values.\n\nAnother solution would be not updating the state on each change caused by events on your components, which will stop triggering unwanted re-renders on their siblings. You could handle the state directly on each CountButton component if this made sense for your app.\n\nAlternatively, you could use a React state management tool, such as Redux, which also solves exactly this issue, by taking charge of delegating the state of your app separated from your components themselves."
    },
    {
        "link": "https://adevnadia.medium.com/react-re-renders-guide-preventing-unnecessary-re-renders-8a3d2acbdba3",
        "document": "Creating components inside render function of another component is an anti-pattern that can be the biggest performance killer. On every re-render React will re-mount this component (i.e. destroy it and re-create it from scratch), which is going to be much slower than a normal re-render. On top of that, this will lead to such bugs as:\n• possible “flashes” of content during re-renders\n• state being reset in the component with every re-render\n• useEffect with no dependencies triggered on every re-render\n• if a component was focused, focus will be lost\n\nSee example in codesandbox\n\nAdditional resources to read: How to write performant React code: rules, patterns, do’s and don’ts\n\nThis pattern can be beneficial when a heavy component manages state, and this state is only used on a small isolated portion of the render tree. A typical example would be opening/closing a dialog with a button click in a complicated component that renders a significant portion of a page.\n\nIn this case, the state that controls modal dialog appearance, dialog itself, and the button that triggers the update can be encapsulated in a smaller component. As a result, the bigger component won’t re-render on those state changes.\n\nSee example in codesandbox\n\nAdditional resources to read: The mystery of React Element, children, parents and re-renders, How to write performant React code: rules, patterns, do’s and don’ts\n\nThis can also be called “wrap state around children”. This pattern is similar to “moving state down”: it encapsulates state changes in a smaller component. The difference here is that state is used on an element that wraps a slow portion of the render tree, so it can’t be extracted that easily. A typical example would be or callbacks attached to the root element of a component.\n\nIn this situation, state management and components that use that state can be extracted into a smaller component, and the slow component can be passed to it as . From the smaller component perspective are just prop, so they will not be affected by the state change and therefore won’t re-render.\n\nSee example in codesandbox\n\nAdditional resources to read: The mystery of React Element, children, parents and re-renders\n\nPretty much the same as the previous pattern, with the same behavior: it encapsulates the state inside a smaller component, and heavy components are passed to it as props. Props are not affected by the state change, so heavy components won’t re-render.\n\nCan be useful when a few heavy components are independent from the state, but can’t be extracted as children as a group.\n\nSee example in codesandbox\n\nRead more about passing components as props here: React component as prop: the right way™️, The mystery of React Element, children, parents and re-renders"
    },
    {
        "link": "https://hygraph.com/blog/react-usecallback-a-complete-guide",
        "document": "Performance optimization is crucial for creating a smoother user experience in modern web development. React, a popular JavaScript library for building user interfaces, provides several Hooks to help developers manage state and side effects efficiently. One such Hook is , which plays a vital role in optimizing functional components by memoizing callback functions.\n\nWhether you are a new React developer or someone looking to get more knowledge, this guide will provide you with insights about , including its syntax, usage, common use cases, and best practices. We will also compare it with another Hook, .\n\nBefore explaining , let’s start by understanding callback functions. In JavaScript, a callback function is a function that is passed as an argument to another function and is executed after some event or action has occurred.\n\nCallback functions work the same way in the React context as in JavaScript, with the addition of being passed as props to child components. This allows children components to communicate with the parent component, enabling a flow of data and actions up the component tree.\n\nCallback functions are an integral part of React apps as they perform activities like asynchronous operations (e.g., network requests) or handle events (e.g., clicks, form submissions, or other user interactions). For example, a button's event handler may be defined as a callback function that updates the state of a React component or performs some action when the button is clicked. Like so:\n\nIn this example, is a callback function that increments the state whenever the button is clicked.\n\nLooking at this example, callback functions seem really handy and do what we need them to do. So why is there a need for ? That is because callback functions are not optimal in all cases, as we will explore in the next section.\n\nDespite the usefulness of callback functions in React development, especially in handling events and interactions, they can lead to performance issues if not handled properly. The main problem stems from how React handles component re-rendering and how JavaScript treats functions as objects.\n\nLet’s consider some common problems associated with callback functions in React:\n\nFunctions are considered objects in JavaScript; as a result, every time a component renders or re-renders, any function inside that component is recreated as a new function object. This means that even if the function's logic remains exactly the same, React treats it as a new entity every time.\n\nConsider this example:\n\nIn this example, every time changes and re-renders, a new function is created. From React's perspective, this new function is different from the current render of the previous one, even though its functionality hasn't changed.\n\nWhen a new function is created and passed as a prop, React sees this as a prop change. This can trigger the parent component to re-render the child component if the child is using optimization techniques like or PureComponent. For example:\n\nEven with , which is designed to prevent unnecessary re-renders, the will re-render every time renders because it receives a \"new\" prop each time.\n\nCallback functions can sometimes capture outdated values from their previous value, leading to bugs that are difficult to track and fix.\n\nIn this component, the interval callback will always log because it captures the initial value of .\n\nThese problems lead to performance implications such as:\n• Cascading re-renders: In a deeply nested component tree, unnecessary re-renders can cascade down, causing significant performance overhead.\n• Unnecessary computations: Each re-render involves React's reconciliation process, which can be computationally expensive, especially for complex React components.\n• Increased memory usage: Creating new function instances repeatedly can lead to increased memory consumption over time.\n\nThese problems highlight the need for a way to manage callback functions in React applications. The is designed to address these, and we will explore it in detail in the upcoming sections.\n\nis a part of the built-in React Hooks that optimizes the performance of React applications by preventing unnecessary re-renders of components. It achieves this through memoizing callback functions, ensuring that they are only recreated when the dependency array changes.\n\nThe syntax looks like so:\n• Callback function: This is the first argument, and it represents the function to memorize (remember).\n• Dependency array: This second argument is an array of dependencies that determine when the callback function should be recreated. If any value in this array changes between renders, the callback function is recreated.\n\nAfter adding , React will memoize the provided function instance between re-renders. Here's what happens:\n• On the initial render, React creates the function and returns it.\n• None a. Check if any values in the dependency array have changed. b. If none have changed, it returns the same function instance from the previous render. c. If any have changed, it creates a new function instance and returns that.\n\nThis means that as long as the dependencies don't change, the exact same function instance is returned every time the component re-renders.\n\nLet’s consider this example showing how works:\n\nIn this example:\n• is a memoized function using . It will only be recreated if the dependencies array (which are empty in this case) change.\n• is wrapped with to prevent unnecessary components re-render. It will only re-render if the prop changes.\n• Because is memoized, will not re-render when changes in .\n\nNow that we understand and its proper usage, let us consider why knowing and using it might be beneficial in building React apps.\n\n# When to use useCallback()\n\nHere are some scenarios where using is particularly beneficial:\n• Optimizing performance in lists: When rendering a list of items, you might need to pass a callback to each item. Using ensures that the same callback instance is passed to each item, preventing unnecessary re-renders.\n• When a callback is a dependency in : Use when the callback is a dependency in a Hook to prevent the effect from running unnecessarily.\n• When working with custom Hooks: Use to ensure consistent function references when creating custom Hooks that return callback functions, especially if these other functions will be used as dependencies in effects.\n• Preventing stale closures: When a callback function depends on state or props, using helps to ensure the function always has the latest values.\n• Passing callbacks to child components: If the function references change, the child components may re-render unnecessarily. helps prevent this by memoizing the function, ensuring it only changes when its dependencies change.\n\n# When not to use useCallback()\n\nWhile is a powerful optimization tool, it may not be necessary in scenarios like:\n• For simple React components that do not re-render often.\n• When the callback is only used within the component and not passed as a prop or used in a dependency array.\n• If the performance gain is negligible compared to the added complexity.\n\nIt is important to always use Hooks appropriately to prevent unnecessary complexity or performance issues in the codebase.\n\n# How to use useCallback() - Practical examples\n\nEverything discussed is of little use if we cannot apply the knowledge to real-world applications. As a result, we will now explore using in an e-commerce application. For this use case, we will focus on two functionalities:\n\nTo do this, we will use Hygraph, a GraphQL-native headless content management system. Hygraph simplifies the development process by providing content management features while allowing developers to focus on building.\n\nSet up a new React application using Vite by running the following command:\n\nSelect React as the framework and complete the installation process. Additionally, install TailwindCSS for styling.\n\nNow, check the terminal for the port the application is running on.\n\nFirst, sign up for a free-forever developer account if you haven't already.\n\nTo use Hygraph in the React application, follow these steps:\n• Clone the project: Clone this Hygraph eCommerce starter project to quickly set up a storefront. Once cloned, open the project.\n• Configure API access: In the Hygraph project, navigate to Project Settings > API Access > Public Content API. Configure the Public Content API permissions to allow read requests without authentication. Click “Yes, initialize defaults” to add the necessary permissions for the High Performance Content API.\n• Set environment variable: Locate the “High Performance Content API” and copy the URL. In the root folder of the React application, create a file and add the URL. Like so:\n\nBefore working on the React app, explore Hygraph to understand the available content. Navigate to Hygraph’s API playground and run the query below to fetch product data, like so:\n\nThis query retrieves product information accessible via the “Content” view. Now, let’s fetch and display the product data in our React application.\n\nNavigate to the project terminal and install the GraphQL client for fetching data:\n\nOpen and add the code below to fetch and display products:\n\nThe code above fetches data from Hygraph using the High Performance Content API. We also used the Hook, which manages the product data state, while the handles the data fetching.\n\nAt this point, we should have a screen that looks like this:\n\nNext, let’s add a feature to mark products as “favorites” to demonstrate the usefulness of .\n\nUpdate to include the Hook and FontAwesome icons:\n\nIn this case, we are using the icon to demonstrate the favorite in the UI.\n\nNext, we will add a state:\n\nThis initializes the state variable as an empty object and provides a function to update the state. This function object allows toggling between two states, such as “favorited” or “not favorited”.\n\nNext, we will declare the :\n\nHere, we achieved the following:\n• We wrapped the function in a to memoize it to prevent unnecessary re-creations on re-renders. This is especially beneficial for performance should the product item get larger applications with many products.\n• The function also toggled the favorite status of a product by updating the state.\n\nNow, we will complete this by adding the code below the “Price”:\n\nHere, we ensured that:\n• When a user clicks the button, it triggers the function declared earlier with the product's ID.\n• The color of the heart icon changes based on the favorite status stored in the state object.\n\nNow, we should be able to see a favorite icon in the UI for each product.\n\nUsing the Hook here to toggle favorites on each product helps prevent unnecessary re-creations of the function on re-renders. This optimization is crucial in scenarios with many items. Now let us add the “add to cart functionality”.\n\nFirst, update the FontAwesome imports to include shopping cart icons:\n\nAdd state and functions for handling the cart:\n\nHere, we have two functions doing the following:\n• : This function adds a product to the cart or increments its quantity if it already exists.\n• : This function decrements the quantity of a product in the cart or removes it if the quantity reaches 0.\n\nBoth functions use to memoize the function and to update the cart state.\n\nYour UI should now look like this:\n\nUsing in this application helps improve performance as the number of products and interactions increases. It ensures that functions handling the internal state updates are not recreated unnecessarily.\n\nYou can access the code on GitHub.\n\nIn React, both and are Hooks that optimize performance by memoizing values and functions, but they serve different purposes and are used in different scenarios.\n\nWith a syntax that looks like the below, accepts two arguments (similar to ):\n\nWhen comparing with , the differences are best based on what they memoize, return, and their use cases, as this sometimes shows the mistaken line between the two Hooks.\n\nConsider this example:\n\nIn this example, memoizes the result of . The computation will only re-run if or changes, avoiding unnecessary recalculations on every render. This is in contrast to , where the function itself would be memoized, but the expensive computation would still run every time the function is called, even if and haven't changed.\n\nNow that we have explored the difference between and , let’s consider when it is best to use .\n\n# Best practices for using ,[object Object]\n• Like any other Hook, should only be used at the top level of the component and outside of any loop or condition.\n• Pair with for child components to prevent unnecessary re-renders when the callback function's reference hasn't changed.\n• The dependency array is crucial, and omitting necessary dependencies can cause bugs. In the dependency array, include all values from the component scope that the callback function depends on.\n• It goes without saying that should only be used if and when necessary. As such, only use when the performance benefit is obvious.\n\nThis guide provides an overview of the React Hook, from the problem it solves to its use cases and best practices for its implementation.\n\nJoin the Hygraph developer workspace to discover exciting innovations and connect with other developers. It’s also a great place to interact with the Hygraph team, share insights, and expand your skills."
    },
    {
        "link": "https://stackoverflow.com/questions/70728051/how-can-i-reduce-unnecessary-re-renders-in-react-without-using-the-usememo-hook",
        "document": "I am unsure as to whether I should change my approach on how I render the components. I depend on a lot of modals that causes unnecessary re-renders when showing/hiding the modals.\n\nThis is a basic idea of how my components are currently being rendered:\n\nI have cases where I can re-use the components (such as Component X in Component C and D), however there are cases (Component A3/B3 and Component E3) where the structure is completely different making it difficult to reuse the component. The problem I am encountering is slow UI due to multiple re-renders.\n\nI display the modals based on state variables declared in their corresponding parent component. When changing the parent's state variable to display the modal causes the parent to re-render, and thus all of its children too. So as an example if I want to display the Create/Edit modal in Component A1, this will cause Component A, A2 and A3 to also re-render which is quite unnecessary. I have made use of the useMemo and useCallback hooks (https://reactjs.org/docs/hooks-reference.html#usememo) to help reduce the load, but I am unsure if this is the right approach? It feels like I am depending too much on the useMemo and useCallback hooks just to display a modal.\n\nThe idea behind the modals is to delete/edit/create a record that will display in the table (located in a different component). This is by design and I cannot change this.\n\nTo manipulate the data I am passing a callback function to each modal component. The modal component sends through the data being changed in the modal to the callback function where the data can be manipulated on the parent component."
    },
    {
        "link": "https://react.dev/reference/react/useCallback",
        "document": "\n• Usage\n• Preventing an Effect from firing too often\n• Troubleshooting\n• Every time my component renders, returns a different function\n• I need to call for each list item in a loop, but it’s not allowed\n\nCall at the top level of your component to cache a function definition between re-renders:\n\nSee more examples below.\n• : The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if the have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it.\n• : The list of all reactive values referenced inside of the code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like . React will compare each dependency with its previous value using the comparison algorithm.\n\nOn the initial render, returns the function you have passed.\n\nDuring subsequent renders, it will either return an already stored function from the last render (if the dependencies haven’t changed), or return the function you have passed during this render.\n• is a Hook, so you can only call it at the top level of your component or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.\n• React will not throw away the cached function unless there is a specific reason to do that. For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache—for example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should match your expectations if you rely on as a performance optimization. Otherwise, a state variable or a ref may be more appropriate.\n\nWhen you optimize rendering performance, you will sometimes need to cache the functions that you pass to child components. Let’s first look at the syntax for how to do this, and then see in which cases it’s useful.\n\nTo cache a function between re-renders of your component, wrap its definition into the Hook:\n\nYou need to pass two things to :\n• A function definition that you want to cache between re-renders.\n• A including every value within your component that’s used inside your function.\n\nOn the initial render, the returned function you’ll get from will be the function you passed.\n\nOn the following renders, React will compare the dependencies with the dependencies you passed during the previous render. If none of the dependencies have changed (compared with ), will return the same function as before. Otherwise, will return the function you passed on this render.\n\nIn other words, caches a function between re-renders until its dependencies change.\n\nLet’s walk through an example to see when this is useful.\n\nSay you’re passing a function down from the to the component:\n\nYou’ve noticed that toggling the prop freezes the app for a moment, but if you remove from your JSX, it feels fast. This tells you that it’s worth trying to optimize the component.\n\nBy default, when a component re-renders, React re-renders all of its children recursively. This is why, when re-renders with a different , the component also re-renders. This is fine for components that don’t require much calculation to re-render. But if you verified a re-render is slow, you can tell to skip re-rendering when its props are the same as on last render by wrapping it in :\n\nWith this change, will skip re-rendering if all of its props are the same as on the last render. This is when caching a function becomes important! Let’s say you defined without :\n\nIn JavaScript, a or always creates a different function, similar to how the object literal always creates a new object. Normally, this wouldn’t be a problem, but it means that props will never be the same, and your optimization won’t work. This is where comes in handy:\n\nBy wrapping in , you ensure that it’s the same function between the re-renders (until dependencies change). You don’t have to wrap a function in unless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped in , and this lets it skip re-rendering. There are other reasons you might need which are described further on this page.\n\nShould you add useCallback everywhere? If your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful. Caching a function with is only valuable in a few cases:\n• You pass it as a prop to a component wrapped in . You want to skip re-rendering if the value hasn’t changed. Memoization lets your component re-render only if dependencies changed.\n• The function you’re passing is later used as a dependency of some Hook. For example, another function wrapped in depends on it, or you depend on this function from There is no benefit to wrapping a function in in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside is that code becomes less readable. Also, not all memoization is effective: a single value that’s “always new” is enough to break memoization for an entire component. Note that does not prevent creating the function. You’re always creating a function (and that’s fine!), but React ignores it and gives you back a cached function if nothing changed. In practice, you can make a lot of memoization unnecessary by following a few principles:\n• When a component visually wraps other components, let it accept JSX as children. Then, if the wrapper component updates its own state, React knows that its children don’t need to re-render.\n• Prefer local state and don’t lift state up any further than necessary. Don’t keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library.\n• Keep your rendering logic pure. If re-rendering a component causes a problem or produces some noticeable visual artifact, it’s a bug in your component! Fix the bug instead of adding memoization.\n• Avoid unnecessary Effects that update state. Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over.\n• Try to remove unnecessary dependencies from your Effects. For example, instead of memoization, it’s often simpler to move some object or a function inside an Effect or outside the component. If a specific interaction still feels laggy, use the React Developer Tools profiler to see which components benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it’s good to follow them in any case. In long term, we’re researching doing memoization automatically to solve this once and for all."
    }
]