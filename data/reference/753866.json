[
    {
        "link": "https://docs.python.org/3/library/re.html",
        "document": "This module provides regular expression matching operations similar to those found in Perl.\n\nBoth patterns and strings to be searched can be Unicode strings ( ) as well as 8-bit strings ( ). However, Unicode strings and 8-bit strings cannot be mixed: that is, you cannot match a Unicode string with a bytes pattern or vice-versa; similarly, when asking for a substitution, the replacement string must be of the same type as both the pattern and the search string.\n\nRegular expressions use the backslash character ( ) to indicate special forms or to allow special characters to be used without invoking their special meaning. This collides with Python’s usage of the same character for the same purpose in string literals; for example, to match a literal backslash, one might have to write as the pattern string, because the regular expression must be , and each backslash must be expressed as inside a regular Python string literal. Also, please note that any invalid escape sequences in Python’s usage of the backslash in string literals now generate a and in the future this will become a . This behaviour will happen even if it is a valid escape sequence for a regular expression.\n\nThe solution is to use Python’s raw string notation for regular expression patterns; backslashes are not handled in any special way in a string literal prefixed with . So is a two-character string containing and , while is a one-character string containing a newline. Usually patterns will be expressed in Python code using this raw string notation.\n\nIt is important to note that most regular expression operations are available as module-level functions and methods on compiled regular expressions. The functions are shortcuts that don’t require you to compile a regex object first, but miss some fine-tuning parameters.\n\nA regular expression (or RE) specifies a set of strings that matches it; the functions in this module let you check if a particular string matches a given regular expression (or if a given regular expression matches a particular string, which comes down to the same thing). Regular expressions can be concatenated to form new regular expressions; if A and B are both regular expressions, then AB is also a regular expression. In general, if a string p matches A and another string q matches B, the string pq will match AB. This holds unless A or B contain low precedence operations; boundary conditions between A and B; or have numbered group references. Thus, complex expressions can easily be constructed from simpler primitive expressions like the ones described here. For details of the theory and implementation of regular expressions, consult the Friedl book [Frie09], or almost any textbook about compiler construction. A brief explanation of the format of regular expressions follows. For further information and a gentler presentation, consult the Regular Expression HOWTO. Regular expressions can contain both special and ordinary characters. Most ordinary characters, like , , or , are the simplest regular expressions; they simply match themselves. You can concatenate ordinary characters, so matches the string . (In the rest of this section, we’ll write RE’s in , usually without quotes, and strings to be matched .) Some characters, like or , are special. Special characters either stand for classes of ordinary characters, or affect how the regular expressions around them are interpreted. Repetition operators or quantifiers ( , , , , etc) cannot be directly nested. This avoids ambiguity with the non-greedy modifier suffix , and with other modifiers in other implementations. To apply a second repetition to an inner repetition, parentheses may be used. For example, the expression matches any multiple of six characters. (Dot.) In the default mode, this matches any character except a newline. If the flag has been specified, this matches any character including a newline. matches any character regardless of flags. (Caret.) Matches the start of the string, and in mode also matches immediately after each newline. Matches the end of the string or just before the newline at the end of the string, and in mode also matches before a newline. matches both ‘foo’ and ‘foobar’, while the regular expression matches only ‘foo’. More interestingly, searching for in matches ‘foo2’ normally, but ‘foo1’ in mode; searching for a single in will find two (empty) matches: one just before the newline, and one at the end of the string. Causes the resulting RE to match 0 or more repetitions of the preceding RE, as many repetitions as are possible. will match ‘a’, ‘ab’, or ‘a’ followed by any number of ‘b’s. Causes the resulting RE to match 1 or more repetitions of the preceding RE. will match ‘a’ followed by any non-zero number of ‘b’s; it will not match just ‘a’. Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. will match either ‘a’ or ‘ab’. The , , and quantifiers are all greedy; they match as much text as possible. Sometimes this behaviour isn’t desired; if the RE is matched against , it will match the entire string, and not just . Adding after the quantifier makes it perform the match in non-greedy or minimal fashion; as few characters as possible will be matched. Using the RE will match only . Like the , , and quantifiers, those where is appended also match as many times as possible. However, unlike the true greedy quantifiers, these do not allow back-tracking when the expression following it fails to match. These are known as possessive quantifiers. For example, will match because the will match all 4 s, but, when the final is encountered, the expression is backtracked so that in the end the ends up matching 3 s total, and the fourth is matched by the final . However, when is used to match , the will match all 4 , but when the final fails to find any more characters to match, the expression cannot be backtracked and will thus fail to match. , and are equivalent to , and correspondingly. Specifies that exactly m copies of the previous RE should be matched; fewer matches cause the entire RE not to match. For example, will match exactly six characters, but not five. Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as many repetitions as possible. For example, will match from 3 to 5 characters. Omitting m specifies a lower bound of zero, and omitting n specifies an infinite upper bound. As an example, will match or a thousand characters followed by a , but not . The comma may not be omitted or the modifier would be confused with the previously described form. Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as few repetitions as possible. This is the non-greedy version of the previous quantifier. For example, on the 6-character string , will match 5 characters, while will only match 3 characters. Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as many repetitions as possible without establishing any backtracking points. This is the possessive version of the quantifier above. For example, on the 6-character string , attempt to match 5 characters, then, requiring 2 more s, will need more characters than available and thus fail, while will match with capturing 5, then 4 s by backtracking and then the final 2 s are matched by the final in the pattern. is equivalent to . Either escapes special characters (permitting you to match characters like , , and so forth), or signals a special sequence; special sequences are discussed below. If you’re not using a raw string to express the pattern, remember that Python also uses the backslash as an escape sequence in string literals; if the escape sequence isn’t recognized by Python’s parser, the backslash and subsequent character are included in the resulting string. However, if Python would recognize the resulting sequence, the backslash should be repeated twice. This is complicated and hard to understand, so it’s highly recommended that you use raw strings for all but the simplest expressions. Used to indicate a set of characters. In a set:\n• None Characters can be listed individually, e.g. will match , , or .\n• None Ranges of characters can be indicated by giving two characters and separating them by a , for example will match any lowercase ASCII letter, will match all the two-digits numbers from to , and will match any hexadecimal digit. If is escaped (e.g. ) or if it’s placed as the first or last character (e.g. or ), it will match a literal .\n• None Special characters lose their special meaning inside sets. For example, will match any of the literal characters , , , or .\n• None Character classes such as or (defined below) are also accepted inside a set, although the characters they match depend on the flags used.\n• None Characters that are not within a range can be matched by complementing the set. If the first character of the set is , all the characters that are not in the set will be matched. For example, will match any character except , and will match any character except . has no special meaning if it’s not the first character in the set.\n• None To match a literal inside a set, precede it with a backslash, or place it at the beginning of the set. For example, both and will match a right bracket, as well as left bracket, braces, and parentheses.\n• None Support of nested sets and set operations as in Unicode Technical Standard #18 might be added in the future. This would change the syntax, so to facilitate this change a will be raised in ambiguous cases for the time being. That includes sets starting with a literal or containing literal character sequences , , , and . To avoid a warning escape them with a backslash. Changed in version 3.7: is raised if a character set contains constructs that will change semantically in the future. , where A and B can be arbitrary REs, creates a regular expression that will match either A or B. An arbitrary number of REs can be separated by the in this way. This can be used inside groups (see below) as well. As the target string is scanned, REs separated by are tried from left to right. When one pattern completely matches, that branch is accepted. This means that once A matches, B will not be tested further, even if it would produce a longer overall match. In other words, the operator is never greedy. To match a literal , use , or enclose it inside a character class, as in . Matches whatever regular expression is inside the parentheses, and indicates the start and end of a group; the contents of a group can be retrieved after a match has been performed, and can be matched later in the string with the special sequence, described below. To match the literals or , use or , or enclose them inside a character class: , . This is an extension notation (a following a is not meaningful otherwise). The first character after the determines what the meaning and further syntax of the construct is. Extensions usually do not create a new group; is the only exception to this rule. Following are the currently supported extensions. (One or more letters from the set , , , , , , .) The group matches the empty string; the letters set the corresponding flags for the entire regular expression: (The flags are described in Module Contents.) This is useful if you wish to include the flags as part of the regular expression, instead of passing a flag argument to the function. Flags should be used first in the expression string. Changed in version 3.11: This construction can only be used at the start of the expression. A non-capturing version of regular parentheses. Matches whatever regular expression is inside the parentheses, but the substring matched by the group cannot be retrieved after performing a match or referenced later in the pattern. (Zero or more letters from the set , , , , , , , optionally followed by followed by one or more letters from the , , , .) The letters set or remove the corresponding flags for the part of the expression: The letters , and are mutually exclusive when used as inline flags, so they can’t be combined or follow . Instead, when one of them appears in an inline group, it overrides the matching mode in the enclosing group. In Unicode patterns switches to ASCII-only matching, and switches to Unicode matching (default). In bytes patterns switches to locale dependent matching, and switches to ASCII-only matching (default). This override is only in effect for the narrow inline group, and the original matching mode is restored outside of the group. Changed in version 3.7: The letters , and also can be used in a group. Attempts to match as if it was a separate regular expression, and if successful, continues to match the rest of the pattern following it. If the subsequent pattern fails to match, the stack can only be unwound to a point before the because once exited, the expression, known as an atomic group, has thrown away all stack points within itself. Thus, would never match anything because first the would match all characters possible, then, having nothing left to match, the final would fail to match. Since there are no stack points saved in the Atomic Group, and there is no stack point before it, the entire expression would thus fail to match. Similar to regular parentheses, but the substring matched by the group is accessible via the symbolic group name name. Group names must be valid Python identifiers, and in patterns they can only contain bytes in the ASCII range. Each group name must be defined only once within a regular expression. A symbolic group is also a numbered group, just as if the group were not named. Named groups can be referenced in three contexts. If the pattern is (i.e. matching a string quoted with either single or double quotes): in the same pattern itself in a string passed to the repl argument of Changed in version 3.12: In patterns, group name can only contain bytes in the ASCII range ( - ). A backreference to a named group; it matches whatever text was matched by the earlier group named name. A comment; the contents of the parentheses are simply ignored. Matches if matches next, but doesn’t consume any of the string. This is called a lookahead assertion. For example, will match only if it’s followed by . Matches if doesn’t match next. This is a negative lookahead assertion. For example, will match only if it’s not followed by . Matches if the current position in the string is preceded by a match for that ends at the current position. This is called a positive lookbehind assertion. will find a match in , since the lookbehind will back up 3 characters and check if the contained pattern matches. The contained pattern must only match strings of some fixed length, meaning that or are allowed, but and are not. Note that patterns which start with positive lookbehind assertions will not match at the beginning of the string being searched; you will most likely want to use the function rather than the function: This example looks for a word following a hyphen: Changed in version 3.5: Added support for group references of fixed length. Matches if the current position in the string is not preceded by a match for . This is called a negative lookbehind assertion. Similar to positive lookbehind assertions, the contained pattern must only match strings of some fixed length. Patterns which start with negative lookbehind assertions may match at the beginning of the string being searched. Will try to match with if the group with given id or name exists, and with if it doesn’t. is optional and can be omitted. For example, is a poor email matching pattern, which will match with as well as , but not with nor . Changed in version 3.12: Group id can only contain ASCII digits. In patterns, group name can only contain bytes in the ASCII range ( - ). The special sequences consist of and a character from the list below. If the ordinary character is not an ASCII digit or an ASCII letter, then the resulting RE will match the second character. For example, matches the character . Matches the contents of the group of the same number. Groups are numbered starting from 1. For example, matches or , but not (note the space after the group). This special sequence can only be used to match one of the first 99 groups. If the first digit of number is 0, or number is 3 octal digits long, it will not be interpreted as a group match, but as the character with octal value number. Inside the and of a character class, all numeric escapes are treated as characters. Matches only at the start of the string. Matches the empty string, but only at the beginning or end of a word. A word is defined as a sequence of word characters. Note that formally, is defined as the boundary between a and a character (or vice versa), or between and the beginning or end of the string. This means that matches , , , and but not or . The default word characters in Unicode (str) patterns are Unicode alphanumerics and the underscore, but this can be changed by using the flag. Word boundaries are determined by the current locale if the flag is used. Inside a character range, represents the backspace character, for compatibility with Python’s string literals. Matches the empty string, but only when it is not at the beginning or end of a word. This means that matches , , , but not , , or . is the opposite of , so word characters in Unicode (str) patterns are Unicode alphanumerics or the underscore, although this can be changed by using the flag. Word boundaries are determined by the current locale if the flag is used. Note that does not match an empty string, which differs from RE implementations in other programming languages such as Perl. This behavior is kept for compatibility reasons. Matches any Unicode decimal digit (that is, any character in Unicode character category [Nd]). This includes , and also many other digit characters. Matches if the flag is used. Matches any decimal digit in the ASCII character set; this is equivalent to . Matches any character which is not a decimal digit. This is the opposite of . Matches if the flag is used. Matches Unicode whitespace characters (as defined by ). This includes , and also many other characters, for example the non-breaking spaces mandated by typography rules in many languages. Matches if the flag is used. Matches characters considered whitespace in the ASCII character set; this is equivalent to . Matches any character which is not a whitespace character. This is the opposite of . Matches if the flag is used. Matches Unicode word characters; this includes all Unicode alphanumeric characters (as defined by ), as well as the underscore ( ). Matches if the flag is used. Matches characters considered alphanumeric in the ASCII character set; this is equivalent to . If the flag is used, matches characters considered alphanumeric in the current locale and the underscore. Matches any character which is not a word character. This is the opposite of . By default, matches non-underscore ( ) characters for which returns . Matches if the flag is used. If the flag is used, matches characters which are neither alphanumeric in the current locale nor the underscore. Matches only at the end of the string. Most of the escape sequences supported by Python string literals are also accepted by the regular expression parser: , , and escape sequences are only recognized in Unicode (str) patterns. In bytes patterns they are errors. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Octal escapes are included in a limited form. If the first digit is a 0, or if there are three octal digits, it is considered an octal escape. Otherwise, it is a group reference. As for string literals, octal escapes are always at most three digits in length. Changed in version 3.3: The and escape sequences have been added. Changed in version 3.6: Unknown escapes consisting of and an ASCII letter now are errors. Changed in version 3.8: The escape sequence has been added. As in string literals, it expands to the named Unicode character (e.g. ).\n\nThe module defines several functions, constants, and an exception. Some of the functions are simplified versions of the full featured methods for compiled regular expressions. Most non-trivial applications always use the compiled form. Changed in version 3.6: Flag constants are now instances of , which is a subclass of . An class containing the regex options listed below. Make , , , , , , and perform ASCII-only matching instead of full Unicode matching. This is only meaningful for Unicode (str) patterns, and is ignored for bytes patterns. The flag still exists for backward compatibility, but is redundant in Python 3 since matches are Unicode by default for patterns, and Unicode matching isn’t allowed for bytes patterns. and the inline flag are similarly redundant. Perform case-insensitive matching; expressions like will also match lowercase letters. Full Unicode matching (such as matching ) also works unless the flag is used to disable non-ASCII matches. The current locale does not change the effect of this flag unless the flag is also used. Note that when the Unicode patterns or are used in combination with the flag, they will match the 52 ASCII letters and 4 additional non-ASCII letters: ‘İ’ (U+0130, Latin capital letter I with dot above), ‘ı’ (U+0131, Latin small letter dotless i), ‘ſ’ (U+017F, Latin small letter long s) and ‘K’ (U+212A, Kelvin sign). If the flag is used, only letters ‘a’ to ‘z’ and ‘A’ to ‘Z’ are matched. Make , , , and case-insensitive matching dependent on the current locale. This flag can be used only with bytes patterns. This flag is discouraged; consider Unicode matching instead. The locale mechanism is very unreliable as it only handles one “culture” at a time and only works with 8-bit locales. Unicode matching is enabled by default for Unicode (str) patterns and it is able to handle different locales and languages. Changed in version 3.6: can be used only with bytes patterns and is not compatible with . Changed in version 3.7: Compiled regular expression objects with the flag no longer depend on the locale at compile time. Only the locale at matching time affects the result of matching. When specified, the pattern character matches at the beginning of the string and at the beginning of each line (immediately following each newline); and the pattern character matches at the end of the string and at the end of each line (immediately preceding each newline). By default, matches only at the beginning of the string, and only at the end of the string and immediately before the newline (if any) at the end of the string. Indicates no flag being applied, the value is . This flag may be used as a default value for a function keyword argument or as a base value that will be conditionally ORed with other flags. Example of use as a default value: Make the special character match any character at all, including a newline; without this flag, will match anything except a newline. In Python 3, Unicode characters are matched by default for patterns. This flag is therefore redundant with no effect and is only kept for backward compatibility. See to restrict matching to ASCII characters instead. This flag allows you to write regular expressions that look nicer and are more readable by allowing you to visually separate logical sections of the pattern and add comments. Whitespace within the pattern is ignored, except when in a character class, or when preceded by an unescaped backslash, or within tokens like , or . For example, and are not allowed. When a line contains a that is not in a character class and is not preceded by an unescaped backslash, all characters from the leftmost such through the end of the line are ignored. This means that the two following regular expression objects that match a decimal number are functionally equal: Compile a regular expression pattern into a regular expression object, which can be used for matching using its , and other methods, described below. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). but using and saving the resulting regular expression object for reuse is more efficient when the expression will be used several times in a single program. The compiled versions of the most recent patterns passed to and the module-level matching functions are cached, so programs that use only a few regular expressions at a time needn’t worry about compiling regular expressions. Scan through string looking for the first location where the regular expression pattern produces a match, and return a corresponding . Return if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). If zero or more characters at the beginning of string match the regular expression pattern, return a corresponding . Return if the string does not match the pattern; note that this is different from a zero-length match. Note that even in mode, will only match at the beginning of the string and not at the beginning of each line. If you want to locate a match anywhere in string, use instead (see also search() vs. match()). The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). If the whole string matches the regular expression pattern, return a corresponding . Return if the string does not match the pattern; note that this is different from a zero-length match. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list. If there are capturing groups in the separator and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string: That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. Deprecated since version 3.13: Passing maxsplit and flags as positional arguments is deprecated. In future Python versions they will be keyword-only parameters. Return all non-overlapping matches of pattern in string, as a list of strings or tuples. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. The result depends on the number of capturing groups in the pattern. If there are no groups, return a list of strings matching the whole pattern. If there is exactly one group, return a list of strings matching that group. If multiple groups are present, return a list of tuples of strings matching the groups. Non-capturing groups do not affect the form of the result. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). Changed in version 3.7: Non-empty matches can now start just after a previous empty match. Return an iterator yielding objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). Changed in version 3.7: Non-empty matches can now start just after a previous empty match. Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, is converted to a single newline character, is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as are left alone. Backreferences, such as , are replaced with the substring matched by group 6 in the pattern. For example: If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single argument, and returns the replacement string. For example: The pattern may be a string or a . The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern are replaced only when not adjacent to a previous empty match, so returns . In string-type repl arguments, in addition to the character escapes and backreferences described above, will use the substring matched by the group named , as defined by the syntax. uses the corresponding group number; is therefore equivalent to , but isn’t ambiguous in a replacement such as . would be interpreted as a reference to group 20, not a reference to group 2 followed by the literal character . The backreference substitutes in the entire substring matched by the RE. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). Changed in version 3.5: Unmatched groups are replaced with an empty string. Changed in version 3.6: Unknown escapes in pattern consisting of and an ASCII letter now are errors. Changed in version 3.7: Unknown escapes in repl consisting of and an ASCII letter now are errors. Empty matches for the pattern are replaced when adjacent to a previous non-empty match. Changed in version 3.12: Group id can only contain ASCII digits. In replacement strings, group name can only contain bytes in the ASCII range ( - ). Deprecated since version 3.13: Passing count and flags as positional arguments is deprecated. In future Python versions they will be keyword-only parameters. Perform the same operation as , but return a tuple . The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). Escape special characters in pattern. This is useful if you want to match an arbitrary literal string that may have regular expression metacharacters in it. For example: This function must not be used for the replacement string in and , only backslashes should be escaped. For example: Changed in version 3.3: The character is no longer escaped. Changed in version 3.7: Only characters that can have special meaning in a regular expression are escaped. As a result, , , , , , , , , , , , , and are no longer escaped. Exception raised when a string passed to one of the functions here is not a valid regular expression (for example, it might contain unmatched parentheses) or when some other error occurs during compilation or matching. It is never an error if a string contains no match for a pattern. The instance has the following additional attributes: The index in pattern where compilation failed (may be ). The line corresponding to pos (may be ). The column corresponding to pos (may be ). Changed in version 3.13: was originally named ; the latter is kept as an alias for backward compatibility.\n\nMatch objects always have a boolean value of . Since and return when there is no match, you can test whether there was a match with a simple statement: Changed in version 3.9: supports to indicate a Unicode (str) or bytes match. See Generic Alias Type. Return the string obtained by doing backslash substitution on the template string template, as done by the method. Escapes such as are converted to the appropriate characters, and numeric backreferences ( , ) and named backreferences ( , ) are replaced by the contents of the corresponding group. The backreference will be replaced by the entire match. Changed in version 3.5: Unmatched groups are replaced with an empty string. Returns one or more subgroups of the match. If there is a single argument, the result is a single string; if there are multiple arguments, the result is a tuple with one item per argument. Without arguments, group1 defaults to zero (the whole match is returned). If a groupN argument is zero, the corresponding return value is the entire matching string; if it is in the inclusive range [1..99], it is the string matching the corresponding parenthesized group. If a group number is negative or larger than the number of groups defined in the pattern, an exception is raised. If a group is contained in a part of the pattern that did not match, the corresponding result is . If a group is contained in a part of the pattern that matched multiple times, the last match is returned. If the regular expression uses the syntax, the groupN arguments may also be strings identifying groups by their group name. If a string argument is not used as a group name in the pattern, an exception is raised. Named groups can also be referred to by their index: If a group matches multiple times, only the last match is accessible: # Returns only the last match. This is identical to . This allows easier access to an individual group from a match: Named groups are supported as well: Return a tuple containing all the subgroups of the match, from 1 up to however many groups are in the pattern. The default argument is used for groups that did not participate in the match; it defaults to . If we make the decimal place and everything after it optional, not all groups might participate in the match. These groups will default to unless the default argument is given: # Second group defaults to None. # Now, the second group defaults to '0'. Return a dictionary containing all the named subgroups of the match, keyed by the subgroup name. The default argument is used for groups that did not participate in the match; it defaults to . For example: Return the indices of the start and end of the substring matched by group; group defaults to zero (meaning the whole matched substring). Return if group exists but did not contribute to the match. For a match object m, and a group g that did contribute to the match, the substring matched by group g (equivalent to ) is Note that will equal if group matched a null string. For example, after , is 1, is 2, and are both 2, and raises an exception. An example that will remove remove_this from email addresses: For a match m, return the 2-tuple . Note that if group did not contribute to the match, this is . group defaults to zero, the entire match. The value of pos which was passed to the or method of a regex object. This is the index into the string at which the RE engine started looking for a match. The value of endpos which was passed to the or method of a regex object. This is the index into the string beyond which the RE engine will not go. The integer index of the last matched capturing group, or if no group was matched at all. For example, the expressions , , and will have if applied to the string , while the expression will have , if applied to the same string. The name of the last matched capturing group, or if the group didn’t have a name, or if no group was matched at all. The regular expression object whose or method produced this match instance. The string passed to or . Changed in version 3.7: Added support of and . Match objects are considered atomic.\n\nIn this example, we’ll use the following helper function to display match objects a little more gracefully: Suppose you are writing a poker program where a player’s hand is represented as a 5-character string with each character representing a card, “a” for ace, “k” for king, “q” for queen, “j” for jack, “t” for 10, and “2” through “9” representing the card with that value. To see if a given string is a valid hand, one could do the following: That last hand, , contained a pair, or two of the same valued cards. To match this with a regular expression, one could use backreferences as such: To find out what card the pair consists of, one could use the method of the match object in the following manner: # Error because re.match() returns None, which doesn't have a group() method: File , line , in : Python does not currently have an equivalent to . Regular expressions are generally more powerful, though also more verbose, than format strings. The table below offers some more-or-less equivalent mappings between format tokens and regular expressions. To extract the filename and numbers from a string like you would use a format like The equivalent regular expression would be\n• None checks for a match only at the beginning of the string\n• None checks for a match anywhere in the string (this is what Perl does by default)\n• None checks for entire string to be a match Regular expressions beginning with can be used with to restrict the match at the beginning of the string: Note however that in mode only matches at the beginning of the string, whereas using with a regular expression beginning with will match at the beginning of each line. splits a string into a list delimited by the passed pattern. The method is invaluable for converting textual data into data structures that can be easily read and modified by Python as demonstrated in the following example that creates a phonebook. First, here is the input. Normally it may come from a file, here we are using triple-quoted string syntax The entries are separated by one or more newlines. Now we convert the string into a list with each nonempty line having its own entry: Finally, split each entry into a list with first name, last name, telephone number, and address. We use the parameter of because the address has spaces, our splitting pattern, in it: The pattern matches the colon after the last name, so that it does not occur in the result list. With a of , we could separate the house number from the street name: replaces every occurrence of a pattern with a string or the result of a function. This example demonstrates using with a function to “munge” text, or randomize the order of all the characters in each word of a sentence except for the first and last characters: matches all occurrences of a pattern, not just the first one as does. For example, if a writer wanted to find all of the adverbs in some text, they might use in the following manner: \"He was carefully disguised but captured quickly by police.\" Finding all Adverbs and their Positions¶ If one wants more information about all matches of a pattern than the matched text, is useful as it provides objects instead of strings. Continuing with the previous example, if a writer wanted to find all of the adverbs and their positions in some text, they would use in the following manner: \"He was carefully disguised but captured quickly by police.\" Raw string notation ( ) keeps regular expressions sane. Without it, every backslash ( ) in a regular expression would have to be prefixed with another one to escape it. For example, the two following lines of code are functionally identical: When one wants to match a literal backslash, it must be escaped in the regular expression. With raw string notation, this means . Without raw string notation, one must use , making the following lines of code functionally identical: A tokenizer or scanner analyzes a string to categorize groups of characters. This is a useful first step in writing a compiler or interpreter. The text categories are specified with regular expressions. The technique is to combine those into a single master regular expression and to loop over successive matches: The tokenizer produces the following output: Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O’Reilly Media, 2009. The third edition of the book no longer covers Python at all, but the first edition covered writing good regular expression patterns in great detail."
    },
    {
        "link": "https://docs.python.org/3/whatsnew/3.12.html",
        "document": "This article explains the new features in Python 3.12, compared to 3.11. Python 3.12 was released on October 2, 2023. For full details, see the changelog.\n\nGeneric classes and functions under PEP 484 were declared using a verbose syntax that left the scope of type parameters unclear and required explicit declarations of variance. PEP 695 introduces a new, more compact and explicit way to create generic classes and functions: In addition, the PEP introduces a new way to declare type aliases using the statement, which creates an instance of : Type aliases can also be generic: The new syntax allows declaring and parameters, as well as parameters with bounds or constraints: The value of type aliases and the bound and constraints of type variables created through this syntax are evaluated only on demand (see lazy evaluation). This means type aliases are able to refer to other types defined later in the file. Type parameters declared through a type parameter list are visible within the scope of the declaration and any nested scopes, but not in the outer scope. For example, they can be used in the type annotations for the methods of a generic class or in the class body. However, they cannot be used in the module scope after the class is defined. See Type parameter lists for a detailed description of the runtime semantics of type parameters. In order to support these scoping semantics, a new kind of scope is introduced, the annotation scope. Annotation scopes behave for the most part like function scopes, but interact differently with enclosing class scopes. In Python 3.13, annotations will also be evaluated in annotation scopes. See PEP 695 for more details. PEP 701 lifts some restrictions on the usage of f-strings. Expression components inside f-strings can now be any valid Python expression, including strings reusing the same quote as the containing f-string, multi-line expressions, comments, backslashes, and unicode escape sequences. Let’s cover these in detail:\n• None Quote reuse: in Python 3.11, reusing the same quotes as the enclosing f-string raises a , forcing the user to either use other available quotes (like using double quotes or triple quotes if the f-string uses single quotes). In Python 3.12, you can now do things like this: 'This is the playlist: Take me back to Eden, Alkaline, Ascensionism' Note that before this change there was no explicit limit in how f-strings can be nested, but the fact that string quotes cannot be reused inside the expression component of f-strings made it impossible to nest f-strings arbitrarily. In fact, this is the most nested f-string that could be written: As now f-strings can contain any valid Python expression inside expression components, it is now possible to nest f-strings arbitrarily:\n• None Multi-line expressions and comments: In Python 3.11, f-string expressions must be defined in a single line, even if the expression within the f-string could normally span multiple lines (like literal lists being defined over multiple lines), making them harder to read. In Python 3.12 you can now define f-strings spanning multiple lines, and add inline comments: >>> f\"This is the playlist: {\", \".join([ ... 'Take me back to Eden', # My, my, those eyes like fire ... 'Alkaline', # Not acid nor alkaline ... 'Ascensionism' # Take to the broken skies at last ... ])}\" 'This is the playlist: Take me back to Eden, Alkaline, Ascensionism'\n• None Backslashes and unicode characters: before Python 3.12 f-string expressions couldn’t contain any character. This also affected unicode escape sequences (such as ) as these contain the part that previously could not be part of expression components of f-strings. Now, you can define expressions like this: This is the playlist: Take me back to Eden This is the playlist: Take me back to Eden♥Alkaline♥Ascensionism See PEP 701 for more details. As a positive side-effect of how this feature has been implemented (by parsing f-strings with the PEG parser), now error messages for f-strings are more precise and include the exact location of the error. For example, in Python 3.11, the following f-string raises a : but the error message doesn’t include the exact location of the error within the line and also has the expression artificially surrounded by parentheses. In Python 3.12, as f-strings are parsed with the PEG parser, error messages can be more precise and show the entire line: (Contributed by Pablo Galindo, Batuhan Taskaya, Lysandros Nikolaou, Cristián Maureira-Fredes and Marta Gómez in gh-102856. PEP written by Pablo Galindo, Batuhan Taskaya, Lysandros Nikolaou and Marta Gómez). PEP 684 introduces a per-interpreter GIL, so that sub-interpreters may now be created with a unique GIL per interpreter. This allows Python programs to take full advantage of multiple CPU cores. This is currently only available through the C-API, though a Python API is anticipated for 3.13. Use the new function to create an interpreter with its own GIL: /* The new interpreter is now active in the current thread. */ For further examples how to use the C-API for sub-interpreters with a per-interpreter GIL, see . PEP 669 defines a new for profilers, debuggers, and other tools to monitor events in CPython. It covers a wide range of events, including calls, returns, lines, exceptions, jumps, and more. This means that you only pay for what you use, providing support for near-zero overhead debuggers and coverage tools. See for details. PEP 688 introduces a way to use the buffer protocol from Python code. Classes that implement the method are now usable as buffer types. The new ABC provides a standard way to represent buffer objects, for example in type annotations. The new enum represents the flags that can be used to customize buffer creation. (Contributed by Jelle Zijlstra in gh-102500.) Dictionary, list, and set comprehensions are now inlined, rather than creating a new single-use function object for each execution of the comprehension. This speeds up execution of a comprehension by up to two times. See PEP 709 for further details. Comprehension iteration variables remain isolated and don’t overwrite a variable of the same name in the outer scope, nor are they visible after the comprehension. Inlining does result in a few visible behavior changes:\n• None There is no longer a separate frame for the comprehension in tracebacks, and tracing/profiling no longer shows the comprehension as a function call.\n• None The module will no longer produce child symbol tables for each comprehension; instead, the comprehension’s locals will be included in the parent function’s symbol table.\n• None Calling inside a comprehension now includes variables from outside the comprehension, and no longer includes the synthetic variable for the comprehension “argument”.\n• None A comprehension iterating directly over (e.g. ) may see “RuntimeError: dictionary changed size during iteration” when run under tracing (e.g. code coverage measurement). This is the same behavior already seen in e.g. . To avoid the error, first create a list of keys to iterate over: .\n• None Modules from the standard library are now potentially suggested as part of the error messages displayed by the interpreter when a is raised to the top level. (Contributed by Pablo Galindo in gh-98254.) File , line , in : name 'sys' is not defined. Did you forget to import 'sys'?\n• None Improve the error suggestion for exceptions for instances. Now if a is raised in a method and the instance has an attribute that’s exactly equal to the name in the exception, the suggestion will include instead of the closest match in the method scope. (Contributed by Pablo Galindo in gh-99139.) File , line : name 'blech' is not defined. Did you mean: 'self.blech'?\n• None Improve the error message when the user types instead of . (Contributed by Pablo Galindo in gh-98931.) File , line : Did you mean to use 'from ... import ...' instead?\n• None exceptions raised from failed statements now include suggestions for the value of based on the available names in . (Contributed by Pablo Galindo in gh-91058.) File , line , in : cannot import name 'chainmap' from 'collections'. Did you mean: 'ChainMap'?"
    },
    {
        "link": "https://docs.python.org/3/howto/regex.html",
        "document": "Regular expressions (called REs, or regexes, or regex patterns) are essentially a tiny, highly specialized programming language embedded inside Python and made available through the module. Using this little language, you specify the rules for the set of possible strings that you want to match; this set might contain English sentences, or e-mail addresses, or TeX commands, or anything you like. You can then ask questions such as “Does this string match the pattern?”, or “Is there a match for the pattern anywhere in this string?”. You can also use REs to modify a string or to split it apart in various ways. Regular expression patterns are compiled into a series of bytecodes which are then executed by a matching engine written in C. For advanced use, it may be necessary to pay careful attention to how the engine will execute a given RE, and write the RE in a certain way in order to produce bytecode that runs faster. Optimization isn’t covered in this document, because it requires that you have a good understanding of the matching engine’s internals. The regular expression language is relatively small and restricted, so not all possible string processing tasks can be done using regular expressions. There are also tasks that can be done with regular expressions, but the expressions turn out to be very complicated. In these cases, you may be better off writing Python code to do the processing; while Python code will be slower than an elaborate regular expression, it will also probably be more understandable.\n\nWe’ll start by learning about the simplest possible regular expressions. Since regular expressions are used to operate on strings, we’ll begin with the most common task: matching characters. For a detailed explanation of the computer science underlying regular expressions (deterministic and non-deterministic finite automata), you can refer to almost any textbook on writing compilers. Most letters and characters will simply match themselves. For example, the regular expression will match the string exactly. (You can enable a case-insensitive mode that would let this RE match or as well; more about this later.) There are exceptions to this rule; some characters are special metacharacters, and don’t match themselves. Instead, they signal that some out-of-the-ordinary thing should be matched, or they affect other portions of the RE by repeating them or changing their meaning. Much of this document is devoted to discussing various metacharacters and what they do. Here’s a complete list of the metacharacters; their meanings will be discussed in the rest of this HOWTO. The first metacharacters we’ll look at are and . They’re used for specifying a character class, which is a set of characters that you wish to match. Characters can be listed individually, or a range of characters can be indicated by giving two characters and separating them by a . For example, will match any of the characters , , or ; this is the same as , which uses a range to express the same set of characters. If you wanted to match only lowercase letters, your RE would be . Metacharacters (except ) are not active inside classes. For example, will match any of the characters , , , or ; is usually a metacharacter, but inside a character class it’s stripped of its special nature. You can match the characters not listed within the class by complementing the set. This is indicated by including a as the first character of the class. For example, will match any character except . If the caret appears elsewhere in a character class, it does not have special meaning. For example: will match either a or a . Perhaps the most important metacharacter is the backslash, . As in Python string literals, the backslash can be followed by various characters to signal various special sequences. It’s also used to escape all the metacharacters so you can still match them in patterns; for example, if you need to match a or , you can precede them with a backslash to remove their special meaning: or . Some of the special sequences beginning with represent predefined sets of characters that are often useful, such as the set of digits, the set of letters, or the set of anything that isn’t whitespace. Let’s take an example: matches any alphanumeric character. If the regex pattern is expressed in bytes, this is equivalent to the class . If the regex pattern is a string, will match all the characters marked as letters in the Unicode database provided by the module. You can use the more restricted definition of in a string pattern by supplying the flag when compiling the regular expression. The following list of special sequences isn’t complete. For a complete list of sequences and expanded class definitions for Unicode string patterns, see the last part of Regular Expression Syntax in the Standard Library reference. In general, the Unicode versions match any character that’s in the appropriate category in the Unicode database. Matches any decimal digit; this is equivalent to the class . Matches any non-digit character; this is equivalent to the class . Matches any whitespace character; this is equivalent to the class . Matches any non-whitespace character; this is equivalent to the class . Matches any alphanumeric character; this is equivalent to the class . Matches any non-alphanumeric character; this is equivalent to the class . These sequences can be included inside a character class. For example, is a character class that will match any whitespace character, or or . The final metacharacter in this section is . It matches anything except a newline character, and there’s an alternate mode ( ) where it will match even a newline. is often used where you want to match “any character”. Being able to match varying sets of characters is the first thing regular expressions can do that isn’t already possible with the methods available on strings. However, if that was the only additional capability of regexes, they wouldn’t be much of an advance. Another capability is that you can specify that portions of the RE must be repeated a certain number of times. The first metacharacter for repeating things that we’ll look at is . doesn’t match the literal character ; instead, it specifies that the previous character can be matched zero or more times, instead of exactly once. For example, will match (0 characters), (1 ), (3 characters), and so forth. Repetitions such as are greedy; when repeating a RE, the matching engine will try to repeat it as many times as possible. If later portions of the pattern don’t match, the matching engine will then back up and try again with fewer repetitions. A step-by-step example will make this more obvious. Let’s consider the expression . This matches the letter , zero or more letters from the class , and finally ends with a . Now imagine matching this RE against the string . The engine matches , going as far as it can, which is to the end of the string. The engine tries to match , but the current position is at the end of the string, so it fails. Back up, so that matches one less character. Try again, but the current position is at the last character, which is a . Back up again, so that is only matching . Try again. This time the character at the current position is , so it succeeds. The end of the RE has now been reached, and it has matched . This demonstrates how the matching engine goes as far as it can at first, and if no match is found it will then progressively back up and retry the rest of the RE again and again. It will back up until it has tried zero matches for , and if that subsequently fails, the engine will conclude that the string doesn’t match the RE at all. Another repeating metacharacter is , which matches one or more times. Pay careful attention to the difference between and ; matches zero or more times, so whatever’s being repeated may not be present at all, while requires at least one occurrence. To use a similar example, will match (1 ), (3 s), but won’t match . There are two more repeating operators or quantifiers. The question mark character, , matches either once or zero times; you can think of it as marking something as being optional. For example, matches either or . The most complicated quantifier is , where m and n are decimal integers. This quantifier means there must be at least m repetitions, and at most n. For example, will match , , and . It won’t match , which has no slashes, or , which has four. You can omit either m or n; in that case, a reasonable value is assumed for the missing value. Omitting m is interpreted as a lower limit of 0, while omitting n results in an upper bound of infinity. The simplest case matches the preceding item exactly m times. For example, will only match . Readers of a reductionist bent may notice that the three other quantifiers can all be expressed using this notation. is the same as , is equivalent to , and is the same as . It’s better to use , , or when you can, simply because they’re shorter and easier to read.\n\nNow that we’ve looked at some simple regular expressions, how do we actually use them in Python? The module provides an interface to the regular expression engine, allowing you to compile REs into objects and then perform matches with them. Regular expressions are compiled into pattern objects, which have methods for various operations such as searching for pattern matches or performing string substitutions. also accepts an optional flags argument, used to enable various special features and syntax variations. We’ll go over the available settings later, but for now a single example will do: The RE is passed to as a string. REs are handled as strings because regular expressions aren’t part of the core Python language, and no special syntax was created for expressing them. (There are applications that don’t need REs at all, so there’s no need to bloat the language specification by including them.) Instead, the module is simply a C extension module included with Python, just like the or modules. Putting REs in strings keeps the Python language simpler, but has one disadvantage which is the topic of the next section. As stated earlier, regular expressions use the backslash character ( ) to indicate special forms or to allow special characters to be used without invoking their special meaning. This conflicts with Python’s usage of the same character for the same purpose in string literals. Let’s say you want to write a RE that matches the string , which might be found in a LaTeX file. To figure out what to write in the program code, start with the desired string to be matched. Next, you must escape any backslashes and other metacharacters by preceding them with a backslash, resulting in the string . The resulting string that must be passed to must be . However, to express this as a Python string literal, both backslashes must be escaped again. In short, to match a literal backslash, one has to write as the RE string, because the regular expression must be , and each backslash must be expressed as inside a regular Python string literal. In REs that feature backslashes repeatedly, this leads to lots of repeated backslashes and makes the resulting strings difficult to understand. The solution is to use Python’s raw string notation for regular expressions; backslashes are not handled in any special way in a string literal prefixed with , so is a two-character string containing and , while is a one-character string containing a newline. Regular expressions will often be written in Python code using this raw string notation. In addition, special escape sequences that are valid in regular expressions, but not valid as Python string literals, now result in a and will eventually become a , which means the sequences will be invalid if raw string notation or escaping the backslashes isn’t used. Once you have an object representing a compiled regular expression, what do you do with it? Pattern objects have several methods and attributes. Only the most significant ones will be covered here; consult the docs for a complete listing. Determine if the RE matches at the beginning of the string. Scan through a string, looking for any location where this RE matches. Find all substrings where the RE matches, and returns them as a list. Find all substrings where the RE matches, and returns them as an iterator. and return if no match can be found. If they’re successful, a match object instance is returned, containing information about the match: where it starts and ends, the substring it matched, and more. You can learn about this by interactively experimenting with the module. This HOWTO uses the standard Python interpreter for its examples. First, run the Python interpreter, import the module, and compile a RE: Now, you can try matching various strings against the RE . An empty string shouldn’t match at all, since means ‘one or more repetitions’. should return in this case, which will cause the interpreter to print no output. You can explicitly print the result of to make this clear. Now, let’s try it on a string that it should match, such as . In this case, will return a match object, so you should store the result in a variable for later use. Now you can query the match object for information about the matching string. Match object instances also have several methods and attributes; the most important ones are: Return the string matched by the RE Return the starting position of the match Return the ending position of the match Return a tuple containing the (start, end) positions of the match Trying these methods will soon clarify their meaning: returns the substring that was matched by the RE. and return the starting and ending index of the match. returns both start and end indexes in a single tuple. Since the method only checks if the RE matches at the start of a string, will always be zero. However, the method of patterns scans through the string, so the match may not start at zero in that case. In actual programs, the most common style is to store the match object in a variable, and then check if it was . This usually looks like: Two pattern methods return all of the matches for a pattern. returns a list of matching strings: The prefix, making the literal a raw string literal, is needed in this example because escape sequences in a normal “cooked” string literal that are not recognized by Python, as opposed to regular expressions, now result in a and will eventually become a . See The Backslash Plague. has to create the entire list before it can be returned as the result. The method returns a sequence of match object instances as an iterator: You don’t have to create a pattern object and call its methods; the module also provides top-level functions called , , , , and so forth. These functions take the same arguments as the corresponding pattern method with the RE string added as the first argument, and still return either or a match object instance. Under the hood, these functions simply create a pattern object for you and call the appropriate method on it. They also store the compiled object in a cache, so future calls using the same RE won’t need to parse the pattern again and again. Should you use these module-level functions, or should you get the pattern and call its methods yourself? If you’re accessing a regex within a loop, pre-compiling it will save a few function calls. Outside of loops, there’s not much difference thanks to the internal cache. Compilation flags let you modify some aspects of how regular expressions work. Flags are available in the module under two names, a long name such as and a short, one-letter form such as . (If you’re familiar with Perl’s pattern modifiers, the one-letter forms use the same letters; the short form of is , for example.) Multiple flags can be specified by bitwise OR-ing them; sets both the and flags, for example. Here’s a table of the available flags, followed by a more detailed explanation of each one. Makes several escapes like , , and match only on ASCII characters with the respective property. Enable verbose REs, which can be organized more cleanly and understandably. Perform case-insensitive matching; character class and literal strings will match letters by ignoring case. For example, will match lowercase letters, too. Full Unicode matching also works unless the flag is used to disable non-ASCII matches. When the Unicode patterns or are used in combination with the flag, they will match the 52 ASCII letters and 4 additional non-ASCII letters: ‘İ’ (U+0130, Latin capital letter I with dot above), ‘ı’ (U+0131, Latin small letter dotless i), ‘ſ’ (U+017F, Latin small letter long s) and ‘K’ (U+212A, Kelvin sign). will match , , , or (the latter is matched only in Unicode mode). This lowercasing doesn’t take the current locale into account; it will if you also set the flag. Make , , , and case-insensitive matching dependent on the current locale instead of the Unicode database. Locales are a feature of the C library intended to help in writing programs that take account of language differences. For example, if you’re processing encoded French text, you’d want to be able to write to match words, but only matches the character class in bytes patterns; it won’t match bytes corresponding to or . If your system is configured properly and a French locale is selected, certain C functions will tell the program that the byte corresponding to should also be considered a letter. Setting the flag when compiling a regular expression will cause the resulting compiled object to use these C functions for ; this is slower, but also enables to match French words as you’d expect. The use of this flag is discouraged in Python 3 as the locale mechanism is very unreliable, it only handles one “culture” at a time, and it only works with 8-bit locales. Unicode matching is already enabled by default in Python 3 for Unicode (str) patterns, and it is able to handle different locales/languages. Usually matches only at the beginning of the string, and matches only at the end of the string and immediately before the newline (if any) at the end of the string. When this flag is specified, matches at the beginning of the string and at the beginning of each line within the string, immediately following each newline. Similarly, the metacharacter matches either at the end of the string and at the end of each line (immediately preceding each newline). Makes the special character match any character at all, including a newline; without this flag, will match anything except a newline. Make , , , , and perform ASCII-only matching instead of full Unicode matching. This is only meaningful for Unicode patterns, and is ignored for byte patterns. This flag allows you to write regular expressions that are more readable by granting you more flexibility in how you can format them. When this flag has been specified, whitespace within the RE string is ignored, except when the whitespace is in a character class or preceded by an unescaped backslash; this lets you organize and indent the RE more clearly. This flag also lets you put comments within a RE that will be ignored by the engine; comments are marked by a that’s neither in a character class or preceded by an unescaped backslash. For example, here’s a RE that uses ; see how much easier it is to read? Without the verbose setting, the RE would look like this: In the above example, Python’s automatic concatenation of string literals has been used to break up the RE into smaller pieces, but it’s still more difficult to understand than the version using .\n\nSo far we’ve only covered a part of the features of regular expressions. In this section, we’ll cover some new metacharacters, and how to use groups to retrieve portions of the text that was matched. There are some metacharacters that we haven’t covered yet. Most of them will be covered in this section. Some of the remaining metacharacters to be discussed are zero-width assertions. They don’t cause the engine to advance through the string; instead, they consume no characters at all, and simply succeed or fail. For example, is an assertion that the current position is located at a word boundary; the position isn’t changed by the at all. This means that zero-width assertions should never be repeated, because if they match once at a given location, they can obviously be matched an infinite number of times. Alternation, or the “or” operator. If A and B are regular expressions, will match any string that matches either A or B. has very low precedence in order to make it work reasonably when you’re alternating multi-character strings. will match either or , not , a or an , and . To match a literal , use , or enclose it inside a character class, as in . Matches at the beginning of lines. Unless the flag has been set, this will only match at the beginning of the string. In mode, this also matches immediately after each newline within the string. For example, if you wish to match the word only at the beginning of a line, the RE to use is . Matches at the end of a line, which is defined as either the end of the string, or any location followed by a newline character. To match a literal , use or enclose it inside a character class, as in . Matches only at the start of the string. When not in mode, and are effectively the same. In mode, they’re different: still matches only at the beginning of the string, but may match at any location inside the string that follows a newline character. Matches only at the end of the string. Word boundary. This is a zero-width assertion that matches only at the beginning or end of a word. A word is defined as a sequence of alphanumeric characters, so the end of a word is indicated by whitespace or a non-alphanumeric character. The following example matches only when it’s a complete word; it won’t match when it’s contained inside another word. There are two subtleties you should remember when using this special sequence. First, this is the worst collision between Python’s string literals and regular expression sequences. In Python’s string literals, is the backspace character, ASCII value 8. If you’re not using raw strings, then Python will convert the to a backspace, and your RE won’t match as you expect it to. The following example looks the same as our previous RE, but omits the in front of the RE string. Second, inside a character class, where there’s no use for this assertion, represents the backspace character, for compatibility with Python’s string literals. Another zero-width assertion, this is the opposite of , only matching when the current position is not at a word boundary. Frequently you need to obtain more information than just whether the RE matched or not. Regular expressions are often used to dissect strings by writing a RE divided into several subgroups which match different components of interest. For example, an RFC-822 header line is divided into a header name and a value, separated by a , like this: This can be handled by writing a regular expression which matches an entire header line, and has one group which matches the header name, and another group which matches the header’s value. Groups are marked by the , metacharacters. and have much the same meaning as they do in mathematical expressions; they group together the expressions contained inside them, and you can repeat the contents of a group with a quantifier, such as , , , or . For example, will match zero or more repetitions of . Groups indicated with , also capture the starting and ending index of the text that they match; this can be retrieved by passing an argument to , , , and . Groups are numbered starting with 0. Group 0 is always present; it’s the whole RE, so match object methods all have group 0 as their default argument. Later we’ll see how to express groups that don’t capture the span of text that they match. Subgroups are numbered from left to right, from 1 upward. Groups can be nested; to determine the number, just count the opening parenthesis characters, going from left to right. can be passed multiple group numbers at a time, in which case it will return a tuple containing the corresponding values for those groups. The method returns a tuple containing the strings for all the subgroups, from 1 up to however many there are. Backreferences in a pattern allow you to specify that the contents of an earlier capturing group must also be found at the current location in the string. For example, will succeed if the exact contents of group 1 can be found at the current position, and fails otherwise. Remember that Python’s string literals also use a backslash followed by numbers to allow including arbitrary characters in a string, so be sure to use a raw string when incorporating backreferences in a RE. For example, the following RE detects doubled words in a string. 'Paris in the the spring' Backreferences like this aren’t often useful for just searching through a string — there are few text formats which repeat data in this way — but you’ll soon find out that they’re very useful when performing string substitutions. Elaborate REs may use many groups, both to capture substrings of interest, and to group and structure the RE itself. In complex REs, it becomes difficult to keep track of the group numbers. There are two features which help with this problem. Both of them use a common syntax for regular expression extensions, so we’ll look at that first. Perl 5 is well known for its powerful additions to standard regular expressions. For these new features the Perl developers couldn’t choose new single-keystroke metacharacters or new special sequences beginning with without making Perl’s regular expressions confusingly different from standard REs. If they chose as a new metacharacter, for example, old expressions would be assuming that was a regular character and wouldn’t have escaped it by writing or . The solution chosen by the Perl developers was to use as the extension syntax. immediately after a parenthesis was a syntax error because the would have nothing to repeat, so this didn’t introduce any compatibility problems. The characters immediately after the indicate what extension is being used, so is one thing (a positive lookahead assertion) and is something else (a non-capturing group containing the subexpression ). Python supports several of Perl’s extensions and adds an extension syntax to Perl’s extension syntax. If the first character after the question mark is a , you know that it’s an extension that’s specific to Python. Now that we’ve looked at the general extension syntax, we can return to the features that simplify working with groups in complex REs. Sometimes you’ll want to use a group to denote a part of a regular expression, but aren’t interested in retrieving the group’s contents. You can make this fact explicit by using a non-capturing group: , where you can replace the with any other regular expression. Except for the fact that you can’t retrieve the contents of what the group matched, a non-capturing group behaves exactly the same as a capturing group; you can put anything inside it, repeat it with a repetition metacharacter such as , and nest it within other groups (capturing or non-capturing). is particularly useful when modifying an existing pattern, since you can add new groups without changing how all the other groups are numbered. It should be mentioned that there’s no performance difference in searching between capturing and non-capturing groups; neither form is any faster than the other. A more significant feature is named groups: instead of referring to them by numbers, groups can be referenced by a name. The syntax for a named group is one of the Python-specific extensions: . name is, obviously, the name of the group. Named groups behave exactly like capturing groups, and additionally associate a name with a group. The match object methods that deal with capturing groups all accept either integers that refer to the group by number or strings that contain the desired group’s name. Named groups are still given numbers, so you can retrieve information about a group in two ways: Additionally, you can retrieve named groups as a dictionary with : Named groups are handy because they let you use easily remembered names, instead of having to remember numbers. Here’s an example RE from the module: It’s obviously much easier to retrieve , instead of having to remember to retrieve group 9. The syntax for backreferences in an expression such as refers to the number of the group. There’s naturally a variant that uses the group name instead of the number. This is another Python extension: indicates that the contents of the group called name should again be matched at the current point. The regular expression for finding doubled words, can also be written as : 'Paris in the the spring' Another zero-width assertion is the lookahead assertion. Lookahead assertions are available in both positive and negative form, and look like this: Positive lookahead assertion. This succeeds if the contained regular expression, represented here by , successfully matches at the current location, and fails otherwise. But, once the contained expression has been tried, the matching engine doesn’t advance at all; the rest of the pattern is tried right where the assertion started. Negative lookahead assertion. This is the opposite of the positive assertion; it succeeds if the contained expression doesn’t match at the current position in the string. To make this concrete, let’s look at a case where a lookahead is useful. Consider a simple pattern to match a filename and split it apart into a base name and an extension, separated by a . For example, in , is the base name, and is the filename’s extension. The pattern to match this is quite simple: Notice that the needs to be treated specially because it’s a metacharacter, so it’s inside a character class to only match that specific character. Also notice the trailing ; this is added to ensure that all the rest of the string must be included in the extension. This regular expression matches and and and . Now, consider complicating the problem a bit; what if you want to match filenames where the extension is not ? Some incorrect attempts: The first attempt above tries to exclude by requiring that the first character of the extension is not a . This is wrong, because the pattern also doesn’t match . The expression gets messier when you try to patch up the first solution by requiring one of the following cases to match: the first character of the extension isn’t ; the second character isn’t ; or the third character isn’t . This accepts and rejects , but it requires a three-letter extension and won’t accept a filename with a two-letter extension such as . We’ll complicate the pattern again in an effort to fix it. In the third attempt, the second and third letters are all made optional in order to allow matching extensions shorter than three characters, such as . The pattern’s getting really complicated now, which makes it hard to read and understand. Worse, if the problem changes and you want to exclude both and as extensions, the pattern would get even more complicated and confusing. A negative lookahead cuts through all this confusion: The negative lookahead means: if the expression doesn’t match at this point, try the rest of the pattern; if does match, the whole pattern will fail. The trailing is required to ensure that something like , where the extension only starts with , will be allowed. The makes sure that the pattern works when there are multiple dots in the filename. Excluding another filename extension is now easy; simply add it as an alternative inside the assertion. The following pattern excludes filenames that end in either or :\n\nUp to this point, we’ve simply performed searches against a static string. Regular expressions are also commonly used to modify strings in various ways, using the following pattern methods: Split the string into a list, splitting it wherever the RE matches Find all substrings where the RE matches, and replace them with a different string Does the same thing as , but returns the new string and the number of replacements The method of a pattern splits a string apart wherever the RE matches, returning a list of the pieces. It’s similar to the method of strings but provides much more generality in the delimiters that you can split by; string only supports splitting by whitespace or by a fixed string. As you’d expect, there’s a module-level function, too. Split string by the matches of the regular expression. If capturing parentheses are used in the RE, then their contents will also be returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits are performed. You can limit the number of splits made, by passing a value for maxsplit. When maxsplit is nonzero, at most maxsplit splits will be made, and the remainder of the string is returned as the final element of the list. In the following example, the delimiter is any sequence of non-alphanumeric characters. 'This is a test, short and sweet, of split().' ['This', 'is', 'a', 'test', 'short', 'and', 'sweet', 'of', 'split', ''] 'This is a test, short and sweet, of split().' ['This', 'is', 'a', 'test, short and sweet, of split().'] Sometimes you’re not only interested in what the text between delimiters is, but also need to know what the delimiter was. If capturing parentheses are used in the RE, then their values are also returned as part of the list. Compare the following calls: The module-level function adds the RE to be used as the first argument, but is otherwise the same. Another common task is to find all the matches for a pattern, and replace them with a different string. The method takes a replacement value, which can be either a string or a function, and the string to be processed. Returns the string obtained by replacing the leftmost non-overlapping occurrences of the RE in string by the replacement replacement. If the pattern isn’t found, string is returned unchanged. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. The default value of 0 means to replace all occurrences. Here’s a simple example of using the method. It replaces colour names with the word : The method does the same work, but returns a 2-tuple containing the new string value and the number of replacements that were performed: Empty matches are replaced only when they’re not adjacent to a previous empty match. If replacement is a string, any backslash escapes in it are processed. That is, is converted to a single newline character, is converted to a carriage return, and so forth. Unknown escapes such as are left alone. Backreferences, such as , are replaced with the substring matched by the corresponding group in the RE. This lets you incorporate portions of the original text in the resulting replacement string. This example matches the word followed by a string enclosed in , , and changes to : There’s also a syntax for referring to named groups as defined by the syntax. will use the substring matched by the group named , and uses the corresponding group number. is therefore equivalent to , but isn’t ambiguous in a replacement string such as . ( would be interpreted as a reference to group 20, not a reference to group 2 followed by the literal character .) The following substitutions are all equivalent, but use all three variations of the replacement string. replacement can also be a function, which gives you even more control. If replacement is a function, the function is called for every non-overlapping occurrence of pattern. On each call, the function is passed a match object argument for the match and can use this information to compute the desired replacement string and return it. In the following example, the replacement function translates decimals into hexadecimal: When using the module-level function, the pattern is passed as the first argument. The pattern may be provided as an object or as a string; if you need to specify regular expression flags, you must either use a pattern object as the first parameter, or use embedded modifiers in the pattern string, e.g. returns .\n\nRegular expressions are a powerful tool for some applications, but in some ways their behaviour isn’t intuitive and at times they don’t behave the way you may expect them to. This section will point out some of the most common pitfalls. Sometimes using the module is a mistake. If you’re matching a fixed string, or a single character class, and you’re not using any features such as the flag, then the full power of regular expressions may not be required. Strings have several methods for performing operations with fixed strings and they’re usually much faster, because the implementation is a single small C loop that’s been optimized for the purpose, instead of the large, more generalized regular expression engine. One example might be replacing a single fixed string with another one; for example, you might replace with . seems like the function to use for this, but consider the method. Note that will also replace inside words, turning into , but the naive RE would have done that, too. (To avoid performing the substitution on parts of words, the pattern would have to be , in order to require that have a word boundary on either side. This takes the job beyond ’s abilities.) Another common task is deleting every occurrence of a single character from a string or replacing it with another single character. You might do this with something like , but is capable of doing both tasks and will be faster than any regular expression operation can be. In short, before turning to the module, consider whether your problem can be solved with a faster and simpler string method. The function only checks if the RE matches at the beginning of the string while will scan forward through the string for a match. It’s important to keep this distinction in mind. Remember, will only report a successful match which will start at 0; if the match wouldn’t start at zero, will not report it. On the other hand, will scan forward through the string, reporting the first match it finds. Sometimes you’ll be tempted to keep using , and just add to the front of your RE. Resist this temptation and use instead. The regular expression compiler does some analysis of REs in order to speed up the process of looking for a match. One such analysis figures out what the first character of a match must be; for example, a pattern starting with must match starting with a . The analysis lets the engine quickly scan through the string looking for the starting character, only trying the full match if a is found. Adding defeats this optimization, requiring scanning to the end of the string and then backtracking to find a match for the rest of the RE. Use instead. When repeating a regular expression, as in , the resulting action is to consume as much of the pattern as possible. This fact often bites you when you’re trying to match a pair of balanced delimiters, such as the angle brackets surrounding an HTML tag. The naive pattern for matching a single HTML tag doesn’t work because of the greedy nature of . The RE matches the in , and the consumes the rest of the string. There’s still more left in the RE, though, and the can’t match at the end of the string, so the regular expression engine has to backtrack character by character until it finds a match for the . The final match extends from the in to the in , which isn’t what you want. In this case, the solution is to use the non-greedy quantifiers , , , or , which match as little text as possible. In the above example, the is tried immediately after the first matches, and when it fails, the engine advances a character at a time, retrying the at every step. This produces just the right result: By now you’ve probably noticed that regular expressions are a very compact notation, but they’re not terribly readable. REs of moderate complexity can become lengthy collections of backslashes, parentheses, and metacharacters, making them difficult to read and understand. For such REs, specifying the flag when compiling the regular expression can be helpful, because it allows you to format the regular expression more clearly. The flag has several effects. Whitespace in the regular expression that isn’t inside a character class is ignored. This means that an expression such as is equivalent to the less readable , but will still match the characters , , or a space. In addition, you can also put comments inside a RE; comments extend from a character to the next newline. When used with triple-quoted strings, this enables REs to be formatted more neatly: (?P<value>.*?) # The header's value -- *? used to This is far more readable than:"
    },
    {
        "link": "https://pypi.org/project/regex",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://w3schools.com/python/python_regex.asp",
        "document": "A RegEx, or Regular Expression, is a sequence of characters that forms a search pattern.\n\nRegEx can be used to check if a string contains the specified search pattern.\n\nPython has a built-in package called , which can be used to work with Regular Expressions.\n\nWhen you have imported the module, you can start using regular expressions:\n\nThe module offers a set of functions that allows us to search a string for a match:\n\nA special sequence is a followed by one of the characters in the list below, and has a special meaning:\n\nA set is a set of characters inside a pair of square brackets with a special meaning:\n\nThe function returns a list containing all matches.\n\nThe list contains the matches in the order they are found.\n\nIf no matches are found, an empty list is returned:\n\nThe function searches the string for a match, and returns a Match object if there is a match.\n\nIf there is more than one match, only the first occurrence of the match will be returned:\n\nIf no matches are found, the value is returned:\n\nThe function returns a list where the string has been split at each match:\n\nYou can control the number of occurrences by specifying the parameter:\n\nThe function replaces the matches with the text of your choice:\n\nYou can control the number of replacements by specifying the parameter:\n\nA Match Object is an object containing information about the search and the result.\n\nThe Match object has properties and methods used to retrieve information about the search, and the result:\n\nreturns a tuple containing the start-, and end positions of the match.\n\n returns the string passed into the function\n\n returns the part of the string where there was a match"
    },
    {
        "link": "https://stackoverflow.com/questions/5989315/regex-for-match-replacing-javascript-comments-both-multiline-and-inline",
        "document": "I need to remove all JavaScript comments from a JavaScript source using the JavaScript RegExp object. What I need is the pattern for the RegExp. This pattern works OK for: But doesn't seem to work for the inline: I'm not quite an expert for RegEx and it's patterns, so I need help. Also, I' would like to have a RegEx pattern which would remove all those HTML-like comments. And also those conditional HTML comments, which can be found in various JavaScript sources."
    },
    {
        "link": "https://stackoverflow.com/questions/59093259/regex-match-comments-single-line-or-multiple-line-and-match-everything-else-c",
        "document": "Here's a simple regular expression which will match both multi-line and single-line comments (C-style):\n\nTo use this in C#:\n\nI'm not too sure what you mean with \"match everything else\", because that's not really what RegEx is for - you could just as well take the entire text. What you can (and possibly should) do, is match comments in the code and then ignore your matches when it comes to the rest of the code.\n\nIf you're interested in matching code constructs, you'd have to create a regular expression for each one. Here's one for if/else: - you could then use the matches to do whatever you intend. This would match strings (double-quoted):\n\nPerhaps I've misunderstood your question, but if you just want to split the comments, get your matches and ignore the rest - or invert the match."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions",
        "document": "You construct a regular expression in one of two ways:\n• Using a regular expression literal, which consists of a pattern enclosed between slashes, as follows: Regular expression literals provide compilation of the regular expression when the script is loaded. If the regular expression remains constant, using this can improve performance.\n• Or calling the constructor function of the object, as follows: Using the constructor function provides runtime compilation of the regular expression. Use the constructor function when you know the regular expression pattern will be changing, or you don't know the pattern and are getting it from another source, such as user input.\n\nWhen the search for a match requires something more than a direct match, such as finding one or more b's, or finding white space, you can include special characters in the pattern. For example, to match a single followed by zero or more s followed by , you'd use the pattern : the after means \"0 or more occurrences of the preceding item.\" In the string , this pattern will match the substring . The following pages provide lists of the different special characters that fit into each category, along with descriptions and examples. Assertions include boundaries, which indicate the beginnings and endings of lines and words, and other patterns indicating in some way that a match is possible (including look-ahead, look-behind, and conditional expressions). Distinguish different types of characters. For example, distinguishing between letters and digits. Groups group multiple patterns as a whole, and capturing groups provide extra submatch information when using a regular expression pattern to match against a string. Backreferences refer to a previously captured group in the same regular expression. Indicate numbers of characters or expressions to match. If you want to look at all the special characters that can be used in regular expressions in a single table, see the following: Note: A larger cheat sheet is also available (only aggregating parts of those individual articles).\n\nIf you need to use any of the special characters literally (actually searching for a , for instance), you must escape it by putting a backslash in front of it. For instance, to search for followed by followed by , you'd use — the backslash \"escapes\" the , making it literal instead of special. Similarly, if you're writing a regular expression literal and need to match a slash (\"/\"), you need to escape that (otherwise, it terminates the pattern). For instance, to search for the string \"/example/\" followed by one or more alphabetic characters, you'd use —the backslashes before each slash make them literal. To match a literal backslash, you need to escape the backslash. For instance, to match the string \"C:\\\" where \"C\" can be any letter, you'd use — the first backslash escapes the one after it, so the expression searches for a single literal backslash. If using the constructor with a string literal, remember that the backslash is an escape in string literals, so to use it in the regular expression, you need to escape it at the string literal level. and create the same expression, which searches for \"a\" followed by a literal \"*\" followed by \"b\". The function returns a new string where all special characters in regex syntax are escaped. This allows you to do to create a regular expression that matches only the string .\n\nRegular expressions are used with the methods and and with the methods , , , , , and . Executes a search for a match in a string. It returns an array of information or on a mismatch. Tests for a match in a string. It returns or . Returns an array containing all of the matches, including capturing groups, or if no match is found. Returns an iterator containing all of the matches, including capturing groups. Tests for a match in a string. It returns the index of the match, or if the search fails. Executes a search for a match in a string, and replaces the matched substring with a replacement substring. Executes a search for all matches in a string, and replaces the matched substrings with a replacement substring. Uses a regular expression or a fixed string to break a string into an array of substrings. When you want to know whether a pattern is found in a string, use the or methods; for more information (but slower execution) use the or methods. If you use or and if the match succeeds, these methods return an array and update properties of the associated regular expression object and also of the predefined regular expression object, . If the match fails, the method returns (which coerces to ). In the following example, the script uses the method to find a match in a string. If you do not need to access the properties of the regular expression, an alternative way of creating is with this script: const myArray = /d(b+)d/g.exec(\"cdbbdbsbz\"); // similar to 'cdbbdbsbz'.match(/d(b+)d/g); however, // 'cdbbdbsbz'.match(/d(b+)d/g) outputs [ \"dbbd\" ] // while /d(b+)d/g.exec('cdbbdbsbz') outputs [ 'dbbd', 'bb', index: 1, input: 'cdbbdbsbz' ] If you want to construct the regular expression from a string, yet another alternative is this script: With these scripts, the match succeeds and returns the array and updates the properties shown in the following table. In this example The matched string and all remembered substrings. The 0-based index of the match in the input string. The index at which to start the next match. (This property is set only if the regular expression uses the g option, described in Advanced Searching With Flags.) The text of the pattern. Updated at the time that the regular expression is created, not executed. As shown in the second form of this example, you can use a regular expression created with an object initializer without assigning it to a variable. If you do, however, every occurrence is a new regular expression. For this reason, if you use this form without assigning it to a variable, you cannot subsequently access the properties of that regular expression. For example, assume you have this script: const myRe = /d(b+)d/g; const myArray = myRe.exec(\"cdbbdbsbz\"); console.log(`The value of lastIndex is ${myRe.lastIndex}`); // \"The value of lastIndex is 5\" However, if you have this script: const myArray = /d(b+)d/g.exec(\"cdbbdbsbz\"); console.log(`The value of lastIndex is ${/d(b+)d/g.lastIndex}`); // \"The value of lastIndex is 0\" The occurrences of in the two statements are different regular expression objects and hence have different values for their property. If you need to access the properties of a regular expression created with an object initializer, you should first assign it to a variable.\n\nRegular expressions have optional flags that allow for functionality like global searching and case-insensitive searching. These flags can be used separately or together in any order, and are included as part of the regular expression. Makes and match the start and end of each line instead of those of the entire string. An upgrade to the mode with more Unicode features. Perform a \"sticky\" search that matches starting at the current position in the target string. To include a flag with the regular expression, use this syntax: Note that the flags are an integral part of a regular expression. They cannot be added or removed later. For example, creates a regular expression that looks for one or more characters followed by a space, and it looks for this combination throughout the string. You could replace the line: The flag is used to specify that a multiline input string should be treated as multiple lines. If the flag is used, and match at the start or end of any line within the input string instead of the start or end of the entire string. The , , and flags can be enabled or disabled for specific parts of a regex using the modifier syntax. Using the global search flag with exec() method with the flag returns each match and its position iteratively. In contrast, method returns all matches at once, but without their position. The flag is used to create \"unicode\" regular expressions; that is, regular expressions which support matching against unicode text. An important feature that's enabled in unicode mode is Unicode property escapes. For example, the following regular expression might be used to match against an arbitrary unicode \"word\": Unicode regular expressions have different execution behavior as well. contains more explanation about this."
    },
    {
        "link": "https://npmjs.com/package/comment-patterns",
        "document": "This module contains an extract of the language-database of with information about how single- and multi-line comments are written in different languages.\n\nThis will lead to being:\n• name is the name of the language\n• nameMatchers is an array of file extensions of filenames that files in this language usually have.\n• multiLineComment is an array of patterns for comments that may span multiple lines\n• start is the beginning of a comment\n• middle is a character of a regex that occurs in front of each comment line\n• end marks the end of the comment\n• singleLineComment is the prefix of comments that go until the end of the line\n\nIt is also possible to retrieve a regular expression that matches comments (up to the next line of code):\n\nThe result will be:\n• regex is the actual regular expression. It matches the comments in a string, including any empty lines after the comment.\n• cg are constant values refering to capturing groups of the regex.\n• contains the spaces that indent comment-start-delimiter.\n• is the first group that captures the contents of the comment In this case, there are multiple possible delimiters, so dependending on which delimiter is used, or is filled. the others are undefined.\n• middle contains one pattern for each group after that matches the prefix used before comment lines. It can be used to remove this prefix. If the middle-prefix for this capturing group is empty ( ), the pattern is .\n• info contains additional information for each group after , currently this information is only if the group is matching an apidoc comment.\n• name is the language name for debugging purposes.\n\nFor API-documentation, it is important to determine the context of the comment (i.e. the thing that the comment is documenting). Although this does not strictly belong to the comment itself, this library also has methods to determine the code-context of a comment These are functions that return a json by matching a single-line of code against a regular expression.\n\nThe result in will be\n\nThis result (for 'JavaScript' is actuall taken from the module by Jon Schlinkert. The method returns a\n\nLoad the comment-pattern for a given file. The file-language is determined by the file-extension.\n• {string}: the name of the file\n\nLoad the comment-regex for a given file. The result contains a regex that matches the comments in the specification. It also has information about which the different capturing groups of an object.\n• {string}: the name of the file\n• {object}: an object containing regular expressions and capturing-group metadata, see usage example for details\n\nCreate a new detector. A detector contains a list of parsers which extract the code context from a list of nodes. It is an immutable object that can be ed, creating a new instance with more parsers.\n\nCreates an extended Detector with additional parsers. A new instance will be created. The old remains untouched.\n• {function(string)}: moreParsers more parsers. Those are inserted at the beginning of the list, so they override existing parsers.\n\nPerform detection. This method calls the included parsers one after another and returns the first-non-null result. The line-number is returned as -property in the result, but the parser-function can override it.\n\nHelper function to create a parser from a that matches a string and a that parses the\n• {RegExp}: regex a regular expression that is matched against a code-line.\n• {function(...string)}: resolver a function that resolves the regex match into a code-context object. The function-parameters are the capturing groups of the regex\n• {function}: a function that can be used as parser\n\nThe language-specification can be found in the -directory. There is one file for each language. The actual databases will be created from these files on .\n\nThe content of language database can be found here\n\nextract-comments: Uses esprima to extract line and block comments from a string of JavaScript. Also optionally… more | homepage"
    },
    {
        "link": "https://geeksforgeeks.org/javascript-comments",
        "document": "Comments help explain code (they are not executed and hence do not have any logic implementation). We can also use them to temporarily disable parts of your code.\n\nA single-line comment in JavaScript is denoted by two forward slashes ( ),\n\nA multiline comment begins with /* and ends with */\n\nPrerequisite : How to Add JavaScript in HTML Document?\n\nThe syntax of comments remains same when we write inside HTML script tag.\n\nWe can use // or /*…*/ to change the JavaScript code execution using comments. JavaScript Comments are used to prevent code execution and are considered suitable for testing the code.\n\nExample 2: This example uses multi-line comments to prevent the execution of addition code and perform subtraction operations.\n\nWhat are comments in JavaScript?\n\nHow do you write a single-line comment in JavaScript?\n\nHow do you write a multi-line comment in JavaScript?\n\nCan comments be nested in JavaScript?\n\nWhy are comments useful in JavaScript?\n\nCan comments affect the performance of JavaScript code?"
    },
    {
        "link": "https://docs.python.org/3/howto/regex.html",
        "document": "Regular expressions (called REs, or regexes, or regex patterns) are essentially a tiny, highly specialized programming language embedded inside Python and made available through the module. Using this little language, you specify the rules for the set of possible strings that you want to match; this set might contain English sentences, or e-mail addresses, or TeX commands, or anything you like. You can then ask questions such as “Does this string match the pattern?”, or “Is there a match for the pattern anywhere in this string?”. You can also use REs to modify a string or to split it apart in various ways. Regular expression patterns are compiled into a series of bytecodes which are then executed by a matching engine written in C. For advanced use, it may be necessary to pay careful attention to how the engine will execute a given RE, and write the RE in a certain way in order to produce bytecode that runs faster. Optimization isn’t covered in this document, because it requires that you have a good understanding of the matching engine’s internals. The regular expression language is relatively small and restricted, so not all possible string processing tasks can be done using regular expressions. There are also tasks that can be done with regular expressions, but the expressions turn out to be very complicated. In these cases, you may be better off writing Python code to do the processing; while Python code will be slower than an elaborate regular expression, it will also probably be more understandable.\n\nWe’ll start by learning about the simplest possible regular expressions. Since regular expressions are used to operate on strings, we’ll begin with the most common task: matching characters. For a detailed explanation of the computer science underlying regular expressions (deterministic and non-deterministic finite automata), you can refer to almost any textbook on writing compilers. Most letters and characters will simply match themselves. For example, the regular expression will match the string exactly. (You can enable a case-insensitive mode that would let this RE match or as well; more about this later.) There are exceptions to this rule; some characters are special metacharacters, and don’t match themselves. Instead, they signal that some out-of-the-ordinary thing should be matched, or they affect other portions of the RE by repeating them or changing their meaning. Much of this document is devoted to discussing various metacharacters and what they do. Here’s a complete list of the metacharacters; their meanings will be discussed in the rest of this HOWTO. The first metacharacters we’ll look at are and . They’re used for specifying a character class, which is a set of characters that you wish to match. Characters can be listed individually, or a range of characters can be indicated by giving two characters and separating them by a . For example, will match any of the characters , , or ; this is the same as , which uses a range to express the same set of characters. If you wanted to match only lowercase letters, your RE would be . Metacharacters (except ) are not active inside classes. For example, will match any of the characters , , , or ; is usually a metacharacter, but inside a character class it’s stripped of its special nature. You can match the characters not listed within the class by complementing the set. This is indicated by including a as the first character of the class. For example, will match any character except . If the caret appears elsewhere in a character class, it does not have special meaning. For example: will match either a or a . Perhaps the most important metacharacter is the backslash, . As in Python string literals, the backslash can be followed by various characters to signal various special sequences. It’s also used to escape all the metacharacters so you can still match them in patterns; for example, if you need to match a or , you can precede them with a backslash to remove their special meaning: or . Some of the special sequences beginning with represent predefined sets of characters that are often useful, such as the set of digits, the set of letters, or the set of anything that isn’t whitespace. Let’s take an example: matches any alphanumeric character. If the regex pattern is expressed in bytes, this is equivalent to the class . If the regex pattern is a string, will match all the characters marked as letters in the Unicode database provided by the module. You can use the more restricted definition of in a string pattern by supplying the flag when compiling the regular expression. The following list of special sequences isn’t complete. For a complete list of sequences and expanded class definitions for Unicode string patterns, see the last part of Regular Expression Syntax in the Standard Library reference. In general, the Unicode versions match any character that’s in the appropriate category in the Unicode database. Matches any decimal digit; this is equivalent to the class . Matches any non-digit character; this is equivalent to the class . Matches any whitespace character; this is equivalent to the class . Matches any non-whitespace character; this is equivalent to the class . Matches any alphanumeric character; this is equivalent to the class . Matches any non-alphanumeric character; this is equivalent to the class . These sequences can be included inside a character class. For example, is a character class that will match any whitespace character, or or . The final metacharacter in this section is . It matches anything except a newline character, and there’s an alternate mode ( ) where it will match even a newline. is often used where you want to match “any character”. Being able to match varying sets of characters is the first thing regular expressions can do that isn’t already possible with the methods available on strings. However, if that was the only additional capability of regexes, they wouldn’t be much of an advance. Another capability is that you can specify that portions of the RE must be repeated a certain number of times. The first metacharacter for repeating things that we’ll look at is . doesn’t match the literal character ; instead, it specifies that the previous character can be matched zero or more times, instead of exactly once. For example, will match (0 characters), (1 ), (3 characters), and so forth. Repetitions such as are greedy; when repeating a RE, the matching engine will try to repeat it as many times as possible. If later portions of the pattern don’t match, the matching engine will then back up and try again with fewer repetitions. A step-by-step example will make this more obvious. Let’s consider the expression . This matches the letter , zero or more letters from the class , and finally ends with a . Now imagine matching this RE against the string . The engine matches , going as far as it can, which is to the end of the string. The engine tries to match , but the current position is at the end of the string, so it fails. Back up, so that matches one less character. Try again, but the current position is at the last character, which is a . Back up again, so that is only matching . Try again. This time the character at the current position is , so it succeeds. The end of the RE has now been reached, and it has matched . This demonstrates how the matching engine goes as far as it can at first, and if no match is found it will then progressively back up and retry the rest of the RE again and again. It will back up until it has tried zero matches for , and if that subsequently fails, the engine will conclude that the string doesn’t match the RE at all. Another repeating metacharacter is , which matches one or more times. Pay careful attention to the difference between and ; matches zero or more times, so whatever’s being repeated may not be present at all, while requires at least one occurrence. To use a similar example, will match (1 ), (3 s), but won’t match . There are two more repeating operators or quantifiers. The question mark character, , matches either once or zero times; you can think of it as marking something as being optional. For example, matches either or . The most complicated quantifier is , where m and n are decimal integers. This quantifier means there must be at least m repetitions, and at most n. For example, will match , , and . It won’t match , which has no slashes, or , which has four. You can omit either m or n; in that case, a reasonable value is assumed for the missing value. Omitting m is interpreted as a lower limit of 0, while omitting n results in an upper bound of infinity. The simplest case matches the preceding item exactly m times. For example, will only match . Readers of a reductionist bent may notice that the three other quantifiers can all be expressed using this notation. is the same as , is equivalent to , and is the same as . It’s better to use , , or when you can, simply because they’re shorter and easier to read.\n\nNow that we’ve looked at some simple regular expressions, how do we actually use them in Python? The module provides an interface to the regular expression engine, allowing you to compile REs into objects and then perform matches with them. Regular expressions are compiled into pattern objects, which have methods for various operations such as searching for pattern matches or performing string substitutions. also accepts an optional flags argument, used to enable various special features and syntax variations. We’ll go over the available settings later, but for now a single example will do: The RE is passed to as a string. REs are handled as strings because regular expressions aren’t part of the core Python language, and no special syntax was created for expressing them. (There are applications that don’t need REs at all, so there’s no need to bloat the language specification by including them.) Instead, the module is simply a C extension module included with Python, just like the or modules. Putting REs in strings keeps the Python language simpler, but has one disadvantage which is the topic of the next section. As stated earlier, regular expressions use the backslash character ( ) to indicate special forms or to allow special characters to be used without invoking their special meaning. This conflicts with Python’s usage of the same character for the same purpose in string literals. Let’s say you want to write a RE that matches the string , which might be found in a LaTeX file. To figure out what to write in the program code, start with the desired string to be matched. Next, you must escape any backslashes and other metacharacters by preceding them with a backslash, resulting in the string . The resulting string that must be passed to must be . However, to express this as a Python string literal, both backslashes must be escaped again. In short, to match a literal backslash, one has to write as the RE string, because the regular expression must be , and each backslash must be expressed as inside a regular Python string literal. In REs that feature backslashes repeatedly, this leads to lots of repeated backslashes and makes the resulting strings difficult to understand. The solution is to use Python’s raw string notation for regular expressions; backslashes are not handled in any special way in a string literal prefixed with , so is a two-character string containing and , while is a one-character string containing a newline. Regular expressions will often be written in Python code using this raw string notation. In addition, special escape sequences that are valid in regular expressions, but not valid as Python string literals, now result in a and will eventually become a , which means the sequences will be invalid if raw string notation or escaping the backslashes isn’t used. Once you have an object representing a compiled regular expression, what do you do with it? Pattern objects have several methods and attributes. Only the most significant ones will be covered here; consult the docs for a complete listing. Determine if the RE matches at the beginning of the string. Scan through a string, looking for any location where this RE matches. Find all substrings where the RE matches, and returns them as a list. Find all substrings where the RE matches, and returns them as an iterator. and return if no match can be found. If they’re successful, a match object instance is returned, containing information about the match: where it starts and ends, the substring it matched, and more. You can learn about this by interactively experimenting with the module. This HOWTO uses the standard Python interpreter for its examples. First, run the Python interpreter, import the module, and compile a RE: Now, you can try matching various strings against the RE . An empty string shouldn’t match at all, since means ‘one or more repetitions’. should return in this case, which will cause the interpreter to print no output. You can explicitly print the result of to make this clear. Now, let’s try it on a string that it should match, such as . In this case, will return a match object, so you should store the result in a variable for later use. Now you can query the match object for information about the matching string. Match object instances also have several methods and attributes; the most important ones are: Return the string matched by the RE Return the starting position of the match Return the ending position of the match Return a tuple containing the (start, end) positions of the match Trying these methods will soon clarify their meaning: returns the substring that was matched by the RE. and return the starting and ending index of the match. returns both start and end indexes in a single tuple. Since the method only checks if the RE matches at the start of a string, will always be zero. However, the method of patterns scans through the string, so the match may not start at zero in that case. In actual programs, the most common style is to store the match object in a variable, and then check if it was . This usually looks like: Two pattern methods return all of the matches for a pattern. returns a list of matching strings: The prefix, making the literal a raw string literal, is needed in this example because escape sequences in a normal “cooked” string literal that are not recognized by Python, as opposed to regular expressions, now result in a and will eventually become a . See The Backslash Plague. has to create the entire list before it can be returned as the result. The method returns a sequence of match object instances as an iterator: You don’t have to create a pattern object and call its methods; the module also provides top-level functions called , , , , and so forth. These functions take the same arguments as the corresponding pattern method with the RE string added as the first argument, and still return either or a match object instance. Under the hood, these functions simply create a pattern object for you and call the appropriate method on it. They also store the compiled object in a cache, so future calls using the same RE won’t need to parse the pattern again and again. Should you use these module-level functions, or should you get the pattern and call its methods yourself? If you’re accessing a regex within a loop, pre-compiling it will save a few function calls. Outside of loops, there’s not much difference thanks to the internal cache. Compilation flags let you modify some aspects of how regular expressions work. Flags are available in the module under two names, a long name such as and a short, one-letter form such as . (If you’re familiar with Perl’s pattern modifiers, the one-letter forms use the same letters; the short form of is , for example.) Multiple flags can be specified by bitwise OR-ing them; sets both the and flags, for example. Here’s a table of the available flags, followed by a more detailed explanation of each one. Makes several escapes like , , and match only on ASCII characters with the respective property. Enable verbose REs, which can be organized more cleanly and understandably. Perform case-insensitive matching; character class and literal strings will match letters by ignoring case. For example, will match lowercase letters, too. Full Unicode matching also works unless the flag is used to disable non-ASCII matches. When the Unicode patterns or are used in combination with the flag, they will match the 52 ASCII letters and 4 additional non-ASCII letters: ‘İ’ (U+0130, Latin capital letter I with dot above), ‘ı’ (U+0131, Latin small letter dotless i), ‘ſ’ (U+017F, Latin small letter long s) and ‘K’ (U+212A, Kelvin sign). will match , , , or (the latter is matched only in Unicode mode). This lowercasing doesn’t take the current locale into account; it will if you also set the flag. Make , , , and case-insensitive matching dependent on the current locale instead of the Unicode database. Locales are a feature of the C library intended to help in writing programs that take account of language differences. For example, if you’re processing encoded French text, you’d want to be able to write to match words, but only matches the character class in bytes patterns; it won’t match bytes corresponding to or . If your system is configured properly and a French locale is selected, certain C functions will tell the program that the byte corresponding to should also be considered a letter. Setting the flag when compiling a regular expression will cause the resulting compiled object to use these C functions for ; this is slower, but also enables to match French words as you’d expect. The use of this flag is discouraged in Python 3 as the locale mechanism is very unreliable, it only handles one “culture” at a time, and it only works with 8-bit locales. Unicode matching is already enabled by default in Python 3 for Unicode (str) patterns, and it is able to handle different locales/languages. Usually matches only at the beginning of the string, and matches only at the end of the string and immediately before the newline (if any) at the end of the string. When this flag is specified, matches at the beginning of the string and at the beginning of each line within the string, immediately following each newline. Similarly, the metacharacter matches either at the end of the string and at the end of each line (immediately preceding each newline). Makes the special character match any character at all, including a newline; without this flag, will match anything except a newline. Make , , , , and perform ASCII-only matching instead of full Unicode matching. This is only meaningful for Unicode patterns, and is ignored for byte patterns. This flag allows you to write regular expressions that are more readable by granting you more flexibility in how you can format them. When this flag has been specified, whitespace within the RE string is ignored, except when the whitespace is in a character class or preceded by an unescaped backslash; this lets you organize and indent the RE more clearly. This flag also lets you put comments within a RE that will be ignored by the engine; comments are marked by a that’s neither in a character class or preceded by an unescaped backslash. For example, here’s a RE that uses ; see how much easier it is to read? Without the verbose setting, the RE would look like this: In the above example, Python’s automatic concatenation of string literals has been used to break up the RE into smaller pieces, but it’s still more difficult to understand than the version using .\n\nSo far we’ve only covered a part of the features of regular expressions. In this section, we’ll cover some new metacharacters, and how to use groups to retrieve portions of the text that was matched. There are some metacharacters that we haven’t covered yet. Most of them will be covered in this section. Some of the remaining metacharacters to be discussed are zero-width assertions. They don’t cause the engine to advance through the string; instead, they consume no characters at all, and simply succeed or fail. For example, is an assertion that the current position is located at a word boundary; the position isn’t changed by the at all. This means that zero-width assertions should never be repeated, because if they match once at a given location, they can obviously be matched an infinite number of times. Alternation, or the “or” operator. If A and B are regular expressions, will match any string that matches either A or B. has very low precedence in order to make it work reasonably when you’re alternating multi-character strings. will match either or , not , a or an , and . To match a literal , use , or enclose it inside a character class, as in . Matches at the beginning of lines. Unless the flag has been set, this will only match at the beginning of the string. In mode, this also matches immediately after each newline within the string. For example, if you wish to match the word only at the beginning of a line, the RE to use is . Matches at the end of a line, which is defined as either the end of the string, or any location followed by a newline character. To match a literal , use or enclose it inside a character class, as in . Matches only at the start of the string. When not in mode, and are effectively the same. In mode, they’re different: still matches only at the beginning of the string, but may match at any location inside the string that follows a newline character. Matches only at the end of the string. Word boundary. This is a zero-width assertion that matches only at the beginning or end of a word. A word is defined as a sequence of alphanumeric characters, so the end of a word is indicated by whitespace or a non-alphanumeric character. The following example matches only when it’s a complete word; it won’t match when it’s contained inside another word. There are two subtleties you should remember when using this special sequence. First, this is the worst collision between Python’s string literals and regular expression sequences. In Python’s string literals, is the backspace character, ASCII value 8. If you’re not using raw strings, then Python will convert the to a backspace, and your RE won’t match as you expect it to. The following example looks the same as our previous RE, but omits the in front of the RE string. Second, inside a character class, where there’s no use for this assertion, represents the backspace character, for compatibility with Python’s string literals. Another zero-width assertion, this is the opposite of , only matching when the current position is not at a word boundary. Frequently you need to obtain more information than just whether the RE matched or not. Regular expressions are often used to dissect strings by writing a RE divided into several subgroups which match different components of interest. For example, an RFC-822 header line is divided into a header name and a value, separated by a , like this: This can be handled by writing a regular expression which matches an entire header line, and has one group which matches the header name, and another group which matches the header’s value. Groups are marked by the , metacharacters. and have much the same meaning as they do in mathematical expressions; they group together the expressions contained inside them, and you can repeat the contents of a group with a quantifier, such as , , , or . For example, will match zero or more repetitions of . Groups indicated with , also capture the starting and ending index of the text that they match; this can be retrieved by passing an argument to , , , and . Groups are numbered starting with 0. Group 0 is always present; it’s the whole RE, so match object methods all have group 0 as their default argument. Later we’ll see how to express groups that don’t capture the span of text that they match. Subgroups are numbered from left to right, from 1 upward. Groups can be nested; to determine the number, just count the opening parenthesis characters, going from left to right. can be passed multiple group numbers at a time, in which case it will return a tuple containing the corresponding values for those groups. The method returns a tuple containing the strings for all the subgroups, from 1 up to however many there are. Backreferences in a pattern allow you to specify that the contents of an earlier capturing group must also be found at the current location in the string. For example, will succeed if the exact contents of group 1 can be found at the current position, and fails otherwise. Remember that Python’s string literals also use a backslash followed by numbers to allow including arbitrary characters in a string, so be sure to use a raw string when incorporating backreferences in a RE. For example, the following RE detects doubled words in a string. 'Paris in the the spring' Backreferences like this aren’t often useful for just searching through a string — there are few text formats which repeat data in this way — but you’ll soon find out that they’re very useful when performing string substitutions. Elaborate REs may use many groups, both to capture substrings of interest, and to group and structure the RE itself. In complex REs, it becomes difficult to keep track of the group numbers. There are two features which help with this problem. Both of them use a common syntax for regular expression extensions, so we’ll look at that first. Perl 5 is well known for its powerful additions to standard regular expressions. For these new features the Perl developers couldn’t choose new single-keystroke metacharacters or new special sequences beginning with without making Perl’s regular expressions confusingly different from standard REs. If they chose as a new metacharacter, for example, old expressions would be assuming that was a regular character and wouldn’t have escaped it by writing or . The solution chosen by the Perl developers was to use as the extension syntax. immediately after a parenthesis was a syntax error because the would have nothing to repeat, so this didn’t introduce any compatibility problems. The characters immediately after the indicate what extension is being used, so is one thing (a positive lookahead assertion) and is something else (a non-capturing group containing the subexpression ). Python supports several of Perl’s extensions and adds an extension syntax to Perl’s extension syntax. If the first character after the question mark is a , you know that it’s an extension that’s specific to Python. Now that we’ve looked at the general extension syntax, we can return to the features that simplify working with groups in complex REs. Sometimes you’ll want to use a group to denote a part of a regular expression, but aren’t interested in retrieving the group’s contents. You can make this fact explicit by using a non-capturing group: , where you can replace the with any other regular expression. Except for the fact that you can’t retrieve the contents of what the group matched, a non-capturing group behaves exactly the same as a capturing group; you can put anything inside it, repeat it with a repetition metacharacter such as , and nest it within other groups (capturing or non-capturing). is particularly useful when modifying an existing pattern, since you can add new groups without changing how all the other groups are numbered. It should be mentioned that there’s no performance difference in searching between capturing and non-capturing groups; neither form is any faster than the other. A more significant feature is named groups: instead of referring to them by numbers, groups can be referenced by a name. The syntax for a named group is one of the Python-specific extensions: . name is, obviously, the name of the group. Named groups behave exactly like capturing groups, and additionally associate a name with a group. The match object methods that deal with capturing groups all accept either integers that refer to the group by number or strings that contain the desired group’s name. Named groups are still given numbers, so you can retrieve information about a group in two ways: Additionally, you can retrieve named groups as a dictionary with : Named groups are handy because they let you use easily remembered names, instead of having to remember numbers. Here’s an example RE from the module: It’s obviously much easier to retrieve , instead of having to remember to retrieve group 9. The syntax for backreferences in an expression such as refers to the number of the group. There’s naturally a variant that uses the group name instead of the number. This is another Python extension: indicates that the contents of the group called name should again be matched at the current point. The regular expression for finding doubled words, can also be written as : 'Paris in the the spring' Another zero-width assertion is the lookahead assertion. Lookahead assertions are available in both positive and negative form, and look like this: Positive lookahead assertion. This succeeds if the contained regular expression, represented here by , successfully matches at the current location, and fails otherwise. But, once the contained expression has been tried, the matching engine doesn’t advance at all; the rest of the pattern is tried right where the assertion started. Negative lookahead assertion. This is the opposite of the positive assertion; it succeeds if the contained expression doesn’t match at the current position in the string. To make this concrete, let’s look at a case where a lookahead is useful. Consider a simple pattern to match a filename and split it apart into a base name and an extension, separated by a . For example, in , is the base name, and is the filename’s extension. The pattern to match this is quite simple: Notice that the needs to be treated specially because it’s a metacharacter, so it’s inside a character class to only match that specific character. Also notice the trailing ; this is added to ensure that all the rest of the string must be included in the extension. This regular expression matches and and and . Now, consider complicating the problem a bit; what if you want to match filenames where the extension is not ? Some incorrect attempts: The first attempt above tries to exclude by requiring that the first character of the extension is not a . This is wrong, because the pattern also doesn’t match . The expression gets messier when you try to patch up the first solution by requiring one of the following cases to match: the first character of the extension isn’t ; the second character isn’t ; or the third character isn’t . This accepts and rejects , but it requires a three-letter extension and won’t accept a filename with a two-letter extension such as . We’ll complicate the pattern again in an effort to fix it. In the third attempt, the second and third letters are all made optional in order to allow matching extensions shorter than three characters, such as . The pattern’s getting really complicated now, which makes it hard to read and understand. Worse, if the problem changes and you want to exclude both and as extensions, the pattern would get even more complicated and confusing. A negative lookahead cuts through all this confusion: The negative lookahead means: if the expression doesn’t match at this point, try the rest of the pattern; if does match, the whole pattern will fail. The trailing is required to ensure that something like , where the extension only starts with , will be allowed. The makes sure that the pattern works when there are multiple dots in the filename. Excluding another filename extension is now easy; simply add it as an alternative inside the assertion. The following pattern excludes filenames that end in either or :\n\nUp to this point, we’ve simply performed searches against a static string. Regular expressions are also commonly used to modify strings in various ways, using the following pattern methods: Split the string into a list, splitting it wherever the RE matches Find all substrings where the RE matches, and replace them with a different string Does the same thing as , but returns the new string and the number of replacements The method of a pattern splits a string apart wherever the RE matches, returning a list of the pieces. It’s similar to the method of strings but provides much more generality in the delimiters that you can split by; string only supports splitting by whitespace or by a fixed string. As you’d expect, there’s a module-level function, too. Split string by the matches of the regular expression. If capturing parentheses are used in the RE, then their contents will also be returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits are performed. You can limit the number of splits made, by passing a value for maxsplit. When maxsplit is nonzero, at most maxsplit splits will be made, and the remainder of the string is returned as the final element of the list. In the following example, the delimiter is any sequence of non-alphanumeric characters. 'This is a test, short and sweet, of split().' ['This', 'is', 'a', 'test', 'short', 'and', 'sweet', 'of', 'split', ''] 'This is a test, short and sweet, of split().' ['This', 'is', 'a', 'test, short and sweet, of split().'] Sometimes you’re not only interested in what the text between delimiters is, but also need to know what the delimiter was. If capturing parentheses are used in the RE, then their values are also returned as part of the list. Compare the following calls: The module-level function adds the RE to be used as the first argument, but is otherwise the same. Another common task is to find all the matches for a pattern, and replace them with a different string. The method takes a replacement value, which can be either a string or a function, and the string to be processed. Returns the string obtained by replacing the leftmost non-overlapping occurrences of the RE in string by the replacement replacement. If the pattern isn’t found, string is returned unchanged. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. The default value of 0 means to replace all occurrences. Here’s a simple example of using the method. It replaces colour names with the word : The method does the same work, but returns a 2-tuple containing the new string value and the number of replacements that were performed: Empty matches are replaced only when they’re not adjacent to a previous empty match. If replacement is a string, any backslash escapes in it are processed. That is, is converted to a single newline character, is converted to a carriage return, and so forth. Unknown escapes such as are left alone. Backreferences, such as , are replaced with the substring matched by the corresponding group in the RE. This lets you incorporate portions of the original text in the resulting replacement string. This example matches the word followed by a string enclosed in , , and changes to : There’s also a syntax for referring to named groups as defined by the syntax. will use the substring matched by the group named , and uses the corresponding group number. is therefore equivalent to , but isn’t ambiguous in a replacement string such as . ( would be interpreted as a reference to group 20, not a reference to group 2 followed by the literal character .) The following substitutions are all equivalent, but use all three variations of the replacement string. replacement can also be a function, which gives you even more control. If replacement is a function, the function is called for every non-overlapping occurrence of pattern. On each call, the function is passed a match object argument for the match and can use this information to compute the desired replacement string and return it. In the following example, the replacement function translates decimals into hexadecimal: When using the module-level function, the pattern is passed as the first argument. The pattern may be provided as an object or as a string; if you need to specify regular expression flags, you must either use a pattern object as the first parameter, or use embedded modifiers in the pattern string, e.g. returns .\n\nRegular expressions are a powerful tool for some applications, but in some ways their behaviour isn’t intuitive and at times they don’t behave the way you may expect them to. This section will point out some of the most common pitfalls. Sometimes using the module is a mistake. If you’re matching a fixed string, or a single character class, and you’re not using any features such as the flag, then the full power of regular expressions may not be required. Strings have several methods for performing operations with fixed strings and they’re usually much faster, because the implementation is a single small C loop that’s been optimized for the purpose, instead of the large, more generalized regular expression engine. One example might be replacing a single fixed string with another one; for example, you might replace with . seems like the function to use for this, but consider the method. Note that will also replace inside words, turning into , but the naive RE would have done that, too. (To avoid performing the substitution on parts of words, the pattern would have to be , in order to require that have a word boundary on either side. This takes the job beyond ’s abilities.) Another common task is deleting every occurrence of a single character from a string or replacing it with another single character. You might do this with something like , but is capable of doing both tasks and will be faster than any regular expression operation can be. In short, before turning to the module, consider whether your problem can be solved with a faster and simpler string method. The function only checks if the RE matches at the beginning of the string while will scan forward through the string for a match. It’s important to keep this distinction in mind. Remember, will only report a successful match which will start at 0; if the match wouldn’t start at zero, will not report it. On the other hand, will scan forward through the string, reporting the first match it finds. Sometimes you’ll be tempted to keep using , and just add to the front of your RE. Resist this temptation and use instead. The regular expression compiler does some analysis of REs in order to speed up the process of looking for a match. One such analysis figures out what the first character of a match must be; for example, a pattern starting with must match starting with a . The analysis lets the engine quickly scan through the string looking for the starting character, only trying the full match if a is found. Adding defeats this optimization, requiring scanning to the end of the string and then backtracking to find a match for the rest of the RE. Use instead. When repeating a regular expression, as in , the resulting action is to consume as much of the pattern as possible. This fact often bites you when you’re trying to match a pair of balanced delimiters, such as the angle brackets surrounding an HTML tag. The naive pattern for matching a single HTML tag doesn’t work because of the greedy nature of . The RE matches the in , and the consumes the rest of the string. There’s still more left in the RE, though, and the can’t match at the end of the string, so the regular expression engine has to backtrack character by character until it finds a match for the . The final match extends from the in to the in , which isn’t what you want. In this case, the solution is to use the non-greedy quantifiers , , , or , which match as little text as possible. In the above example, the is tried immediately after the first matches, and when it fails, the engine advances a character at a time, retrying the at every step. This produces just the right result: By now you’ve probably noticed that regular expressions are a very compact notation, but they’re not terribly readable. REs of moderate complexity can become lengthy collections of backslashes, parentheses, and metacharacters, making them difficult to read and understand. For such REs, specifying the flag when compiling the regular expression can be helpful, because it allows you to format the regular expression more clearly. The flag has several effects. Whitespace in the regular expression that isn’t inside a character class is ignored. This means that an expression such as is equivalent to the less readable , but will still match the characters , , or a space. In addition, you can also put comments inside a RE; comments extend from a character to the next newline. When used with triple-quoted strings, this enables REs to be formatted more neatly: (?P<value>.*?) # The header's value -- *? used to This is far more readable than:"
    },
    {
        "link": "https://stackoverflow.com/questions/24350817/parsing-js-with-regex-python",
        "document": "I have some javascript text to parse with python There is in js html elemet such variable:\n\nobservableArray could be an holder for 1 json it will be observableArray({'id': '234234'}) or observableArray(['id': '3123123]), also it can hold infinite number of json per comma like in code pasted higher\n\nhow can i get this string with jsons with regexp i have try:"
    },
    {
        "link": "https://stackoverflow.com/questions/11230743/how-to-parse-a-javascript-regexp-in-python",
        "document": "First of all, I am not the one who is writing the regexps, so I can't just rewrite them. I am pulling in several Javascript regexps, and trying to parse them, but there seems to be some difference between them. Testing the example regexp on W3Schools, Javascript shows this:\n\nwhich alerts \"W3Schools\". However, in Python, I get:\n\nwhich prints . Is there some library I can use to convert the Javascript regexps to Python ones?"
    },
    {
        "link": "https://reddit.com/r/learnpython/comments/9xlj8f/which_is_the_best_place_to_learn_and_practice",
        "document": "Create your account and connect with a world of communities.\n\nBy continuing, you agree to our\n\nand acknowledge that you understand the"
    },
    {
        "link": "https://w3schools.com/python/python_regex.asp",
        "document": "A RegEx, or Regular Expression, is a sequence of characters that forms a search pattern.\n\nRegEx can be used to check if a string contains the specified search pattern.\n\nPython has a built-in package called , which can be used to work with Regular Expressions.\n\nWhen you have imported the module, you can start using regular expressions:\n\nThe module offers a set of functions that allows us to search a string for a match:\n\nA special sequence is a followed by one of the characters in the list below, and has a special meaning:\n\nA set is a set of characters inside a pair of square brackets with a special meaning:\n\nThe function returns a list containing all matches.\n\nThe list contains the matches in the order they are found.\n\nIf no matches are found, an empty list is returned:\n\nThe function searches the string for a match, and returns a Match object if there is a match.\n\nIf there is more than one match, only the first occurrence of the match will be returned:\n\nIf no matches are found, the value is returned:\n\nThe function returns a list where the string has been split at each match:\n\nYou can control the number of occurrences by specifying the parameter:\n\nThe function replaces the matches with the text of your choice:\n\nYou can control the number of replacements by specifying the parameter:\n\nA Match Object is an object containing information about the search and the result.\n\nThe Match object has properties and methods used to retrieve information about the search, and the result:\n\nreturns a tuple containing the start-, and end positions of the match.\n\n returns the string passed into the function\n\n returns the part of the string where there was a match"
    }
]