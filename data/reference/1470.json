[
    {
        "link": "https://geeksforgeeks.org/node-js-fs-readdir-method",
        "document": "The fs.readdir() method is used to asynchronously read the contents of a given directory. The callback of this method returns an array of all the file names in the directory. The options argument can be used to change the format in which the files are returned from the method.\n\nThis method accept three parameters as mentioned above and described below:\n• path: It holds the path of the directory from where the contents have to be read. It can be a String, Buffer or URL.\n• options: It is an object that can be used to specify optional parameters that will affect the method. It has two optional parameters:\n• encoding: It is a string value which specifies which encoding would be used for the filenames given to the callback argument. The default value is ‘utf8’.\n• withFileTypes: It is a boolean value which specifies whether the files would be returned as fs.Dirent objects. The default value is ‘false’.\n• callback: It is the function that would be called when the method is executed.\n• err: It is an error that would be thrown if the operation fails.\n• files: It is an array of String, Buffer or fs.Dirent objects that contain the files in the directory.\n\nBelow examples illustrate the fs.readdir() method in Node.js:\n\nThis example uses fs.readdir() method to return the file names or file objects in the directory.\n\nThis example uses fs.readdir() method to return only the filenames with the “.txt” extension."
    },
    {
        "link": "https://nodejs.org/api/fs.html",
        "document": "The module enables interacting with the file system in a way modeled on standard POSIX functions.\n\nTo use the promise-based APIs:\n\nTo use the callback and sync APIs:\n\nAll file system operations have synchronous, callback, and promise-based forms, and are accessible using both CommonJS syntax and ES6 Modules (ESM).\n\nThe common objects are shared by all of the file system API variants (promise, callback, and synchronous). When using the async iterator, the <fs.Dir> object will be automatically closed after the iterator exits. Asynchronously close the directory's underlying resource handle. Subsequent reads will result in errors. A promise is returned that will be fulfilled after the resource has been closed. Passing an invalid callback to the argument now throws instead of . Asynchronously close the directory's underlying resource handle. Subsequent reads will result in errors. The will be called after the resource handle has been closed. Synchronously close the directory's underlying resource handle. Subsequent reads will result in errors. The read-only path of this directory as was provided to , , or . Asynchronously read the next directory entry via as an <fs.Dirent>. A promise is returned that will be fulfilled with an <fs.Dirent>, or if there are no more directory entries to read. Directory entries returned by this function are in no particular order as provided by the operating system's underlying directory mechanisms. Entries added or removed while iterating over the directory might not be included in the iteration results. Asynchronously read the next directory entry via as an <fs.Dirent>. After the read is completed, the will be called with an <fs.Dirent>, or if there are no more directory entries to read. Directory entries returned by this function are in no particular order as provided by the operating system's underlying directory mechanisms. Entries added or removed while iterating over the directory might not be included in the iteration results. Synchronously read the next directory entry as an <fs.Dirent>. See the POSIX documentation for more detail. If there are no more directory entries to read, will be returned. Directory entries returned by this function are in no particular order as provided by the operating system's underlying directory mechanisms. Entries added or removed while iterating over the directory might not be included in the iteration results. Asynchronously iterates over the directory until all entries have been read. Refer to the POSIX documentation for more detail. Entries returned by the async iterator are always an <fs.Dirent>. The case from is handled internally. See <fs.Dir> for an example. Directory entries returned by this iterator are in no particular order as provided by the operating system's underlying directory mechanisms. Entries added or removed while iterating over the directory might not be included in the iteration results. A representation of a directory entry, which can be a file or a subdirectory within the directory, as returned by reading from an <fs.Dir>. The directory entry is a combination of the file name and file type pairs. Additionally, when or is called with the option set to , the resulting array is filled with <fs.Dirent> objects, rather than strings or <Buffer>s. The file name that this <fs.Dirent> object refers to. The type of this value is determined by the passed to or . The path to the parent directory of the file this <fs.Dirent> object refers to. The property is no longer read-only. Accessing this property emits a warning. It is now read-only. A successful call to method will return a new <fs.FSWatcher> object. All <fs.FSWatcher> objects emit a event whenever a specific watched file is modified.\n• <string> The type of change event that has occurred\n• <string> | <Buffer> The filename that changed (if relevant/available) Emitted when something changes in a watched directory or file. See more details in . The argument may not be provided depending on operating system support. If is provided, it will be provided as a <Buffer> if is called with its option set to , otherwise will be a UTF-8 string. Emitted when the watcher stops watching for changes. The closed <fs.FSWatcher> object is no longer usable in the event handler. Emitted when an error occurs while watching the file. The errored <fs.FSWatcher> object is no longer usable in the event handler. Stop watching for changes on the given <fs.FSWatcher>. Once stopped, the <fs.FSWatcher> object is no longer usable. When called, requests that the Node.js event loop not exit so long as the <fs.FSWatcher> is active. Calling multiple times will have no effect. By default, all <fs.FSWatcher> objects are \"ref'ed\", making it normally unnecessary to call unless had been called previously. When called, the active <fs.FSWatcher> object will not require the Node.js event loop to remain active. If there is no other activity keeping the event loop running, the process may exit before the <fs.FSWatcher> object's callback is invoked. Calling multiple times will have no effect. A successful call to method will return a new <fs.StatWatcher> object. When called, requests that the Node.js event loop not exit so long as the <fs.StatWatcher> is active. Calling multiple times will have no effect. By default, all <fs.StatWatcher> objects are \"ref'ed\", making it normally unnecessary to call unless had been called previously. When called, the active <fs.StatWatcher> object will not require the Node.js event loop to remain active. If there is no other activity keeping the event loop running, the process may exit before the <fs.StatWatcher> object's callback is invoked. Calling multiple times will have no effect. Instances of <fs.ReadStream> are created and returned using the function. Emitted when the <fs.ReadStream>'s underlying file descriptor has been closed.\n• <integer> Integer file descriptor used by the <fs.ReadStream>. Emitted when the <fs.ReadStream>'s file descriptor has been opened. Emitted when the <fs.ReadStream> is ready to be used. The number of bytes that have been read so far. The path to the file the stream is reading from as specified in the first argument to . If is passed as a string, then will be a string. If is passed as a <Buffer>, then will be a <Buffer>. If is specified, then will be . This property is if the underlying file has not been opened yet, i.e. before the event is emitted. Objects returned from , , , and their synchronous counterparts are of this type. If in the passed to those methods is true, the numeric values will be instead of , and the object will contain additional nanosecond-precision properties suffixed with . objects are not to be created directly using the keyword. If the <fs.Stats> object was obtained from calling on a symbolic link which resolves to a directory, this method will return . This is because returns information about a symbolic link itself and not the path it resolves to. This method is only valid when using . The numeric identifier of the device containing the file. The file system specific \"Inode\" number for the file. The number of hard-links that exist for the file. The numeric user identifier of the user that owns the file (POSIX). The numeric group identifier of the group that owns the file (POSIX). The size of the file in bytes. If the underlying file system does not support getting the size of the file, this will be . The number of blocks allocated for this file. The timestamp indicating the last time this file was accessed expressed in milliseconds since the POSIX Epoch. The timestamp indicating the last time this file was modified expressed in milliseconds since the POSIX Epoch. The timestamp indicating the last time the file status was changed expressed in milliseconds since the POSIX Epoch. The timestamp indicating the creation time of this file expressed in milliseconds since the POSIX Epoch. Only present when is passed into the method that generates the object. The timestamp indicating the last time this file was accessed expressed in nanoseconds since the POSIX Epoch. Only present when is passed into the method that generates the object. The timestamp indicating the last time this file was modified expressed in nanoseconds since the POSIX Epoch. Only present when is passed into the method that generates the object. The timestamp indicating the last time the file status was changed expressed in nanoseconds since the POSIX Epoch. Only present when is passed into the method that generates the object. The timestamp indicating the creation time of this file expressed in nanoseconds since the POSIX Epoch. The timestamp indicating the last time this file was accessed. The timestamp indicating the last time this file was modified. The timestamp indicating the last time the file status was changed. The timestamp indicating the creation time of this file. The , , , properties are numeric values that hold the corresponding times in milliseconds. Their precision is platform specific. When is passed into the method that generates the object, the properties will be bigints, otherwise they will be numbers. The , , , properties are bigints that hold the corresponding times in nanoseconds. They are only present when is passed into the method that generates the object. Their precision is platform specific. , , , and are object alternate representations of the various times. The and number values are not connected. Assigning a new number value, or mutating the value, will not be reflected in the corresponding alternate representation. The times in the stat object have the following semantics:\n• \"Access Time\": Time when file data last accessed. Changed by the , , and system calls.\n• \"Modified Time\": Time when file data last modified. Changed by the , , and system calls.\n• \"Change Time\": Time when file status was last changed (inode data modification). Changed by the , , , , , , , , and system calls.\n• \"Birth Time\": Time of file creation. Set once when the file is created. On file systems where birthtime is not available, this field may instead hold either the or (ie, Unix epoch timestamp ). This value may be greater than or in this case. On Darwin and other FreeBSD variants, also set if the is explicitly set to an earlier value than the current using the system call. Prior to Node.js 0.12, the held the on Windows systems. As of 0.12, is not \"creation time\", and on Unix systems, it never was. Objects returned from and its synchronous counterpart are of this type. If in the passed to those methods is , the numeric values will be instead of . Instances of <fs.WriteStream> are created and returned using the function. Emitted when the <fs.WriteStream>'s underlying file descriptor has been closed.\n• <integer> Integer file descriptor used by the <fs.WriteStream>. Emitted when the <fs.WriteStream>'s file is opened. Emitted when the <fs.WriteStream> is ready to be used. The number of bytes written so far. Does not include data that is still queued for writing. Closes . Optionally accepts a callback that will be executed once the is closed. The path to the file the stream is writing to as specified in the first argument to . If is passed as a string, then will be a string. If is passed as a <Buffer>, then will be a <Buffer>. This property is if the underlying file has not been opened yet, i.e. before the event is emitted. Returns an object containing commonly used constants for file system operations. The following constants are exported by and . Not every constant will be available on every operating system; this is especially important for Windows, where many of the POSIX specific definitions are not available. For portable applications it is recommended to check for their presence before use. To use more than one constant, use the bitwise OR operator. The following constants are meant for use as the parameter passed to , , and . Flag indicating that the file is visible to the calling process. This is useful for determining if a file exists, but says nothing about permissions. Default if no mode is specified. Flag indicating that the file can be read by the calling process. Flag indicating that the file can be written by the calling process. Flag indicating that the file can be executed by the calling process. This has no effect on Windows (will behave like ). The definitions are also available on Windows. The following constants are meant for use with . If present, the copy operation will fail with an error if the destination path already exists. If present, the copy operation will attempt to create a copy-on-write reflink. If the underlying platform does not support copy-on-write, then a fallback copy mechanism is used. If present, the copy operation will attempt to create a copy-on-write reflink. If the underlying platform does not support copy-on-write, then the operation will fail with an error. The definitions are also available on Windows. The following constants are meant for use with . Flag indicating to create the file if it does not already exist. Flag indicating that opening a file should fail if the flag is set and the file already exists. Flag indicating that if path identifies a terminal device, opening the path shall not cause that terminal to become the controlling terminal for the process (if the process does not already have one). Flag indicating that if the file exists and is a regular file, and the file is opened successfully for write access, its length shall be truncated to zero. Flag indicating that data will be appended to the end of the file. Flag indicating that the open should fail if the path is not a directory. Flag indicating reading accesses to the file system will no longer result in an update to the information associated with the file. This flag is available on Linux operating systems only. Flag indicating that the open should fail if the path is a symbolic link. Flag indicating that the file is opened for synchronized I/O with write operations waiting for file integrity. Flag indicating that the file is opened for synchronized I/O with write operations waiting for data integrity. Flag indicating to open the symbolic link itself rather than the resource it is pointing to. When set, an attempt will be made to minimize caching effects of file I/O. Flag indicating to open the file in nonblocking mode when possible. When set, a memory file mapping is used to access the file. This flag is available on Windows operating systems only. On other operating systems, this flag is ignored. On Windows, only , , , , , , , and are available. The following constants are meant for use with the <fs.Stats> object's property for determining a file's type. Bit mask used to extract the file type code. On Windows, only , , , , and , are available. The following constants are meant for use with the <fs.Stats> object's property for determining the access permissions for a file. File mode indicating readable, writable, and executable by others. On Windows, only and are available.\n\nBecause they are executed asynchronously by the underlying thread pool, there is no guaranteed ordering when using either the callback or promise-based methods. For example, the following is prone to error because the operation might complete before the operation: It is important to correctly order the operations by awaiting the results of one before invoking the other: Or, when using the callback APIs, move the call into the callback of the operation: Most operations accept file paths that may be specified in the form of a string, a <Buffer>, or a <URL> object using the protocol. String paths are interpreted as UTF-8 character sequences identifying the absolute or relative filename. Relative paths will be resolved relative to the current working directory as determined by calling . Example using an absolute path on POSIX: Example using a relative path on POSIX (relative to ): For most module functions, the or argument may be passed as a <URL> object using the protocol. On Windows, <URL>s with a host name convert to UNC paths, while <URL>s with drive letters convert to local absolute paths. <URL>s with no host name and no drive letter will result in an error: <URL>s with drive letters must use as a separator just after the drive letter. Using another separator will result in an error. On all other platforms, <URL>s with a host name are unsupported and will result in an error: A <URL> having encoded slash characters will result in an error on all platforms: On Windows, <URL>s having encoded backslash will result in an error: Paths specified using a <Buffer> are useful primarily on certain POSIX operating systems that treat file paths as opaque byte sequences. On such systems, it is possible for a single file path to contain sub-sequences that use multiple character encodings. As with string paths, <Buffer> paths may be relative or absolute: Example using an absolute path on POSIX: On Windows, Node.js follows the concept of per-drive working directory. This behavior can be observed when using a drive path without a backslash. For example can potentially return a different result than . For more information, see this MSDN page. On POSIX systems, for every process, the kernel maintains a table of currently open files and resources. Each open file is assigned a simple numeric identifier called a file descriptor. At the system-level, all file system operations use these file descriptors to identify and track each specific file. Windows systems use a different but conceptually similar mechanism for tracking resources. To simplify things for users, Node.js abstracts away the differences between operating systems and assigns all open files a numeric file descriptor. The callback-based , and synchronous methods open a file and allocate a new file descriptor. Once allocated, the file descriptor may be used to read data from, write data to, or request information about the file. Operating systems limit the number of file descriptors that may be open at any given time so it is critical to close the descriptor when operations are completed. Failure to do so will result in a memory leak that will eventually cause an application to crash. The promise-based APIs use a <FileHandle> object in place of the numeric file descriptor. These objects are better managed by the system to ensure that resources are not leaked. However, it is still required that they are closed when operations are completed: All callback and promise-based file system APIs (with the exception of ) use libuv's threadpool. This can have surprising and negative performance implications for some applications. See the documentation for more information. The following flags are available wherever the option takes a string.\n• : Open file for appending. The file is created if it does not exist.\n• : Like but fails if the path exists.\n• : Open file for reading and appending. The file is created if it does not exist.\n• : Like but fails if the path exists.\n• : Open file for appending in synchronous mode. The file is created if it does not exist.\n• : Open file for reading and appending in synchronous mode. The file is created if it does not exist.\n• : Open file for reading. An exception occurs if the file does not exist.\n• : Open file for reading in synchronous mode. An exception occurs if the file does not exist.\n• : Open file for reading and writing. An exception occurs if the file does not exist.\n• : Open file for reading and writing in synchronous mode. Instructs the operating system to bypass the local file system cache. This is primarily useful for opening files on NFS mounts as it allows skipping the potentially stale local cache. It has a very real impact on I/O performance so using this flag is not recommended unless it is needed. This doesn't turn or into a synchronous blocking call. If synchronous operation is desired, something like should be used.\n• : Open file for writing. The file is created (if it does not exist) or truncated (if it exists).\n• : Like but fails if the path exists.\n• : Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).\n• : Like but fails if the path exists. can also be a number as documented by ; commonly used constants are available from . On Windows, flags are translated to their equivalent ones where applicable, e.g. to , or to , as accepted by . The exclusive flag ( flag in ) causes the operation to return an error if the path already exists. On POSIX, if the path is a symbolic link, using returns an error even if the link is to a path that does not exist. The exclusive flag might not work with network file systems. On Linux, positional writes don't work when the file is opened in append mode. The kernel ignores the position argument and always appends the data to the end of the file. Modifying a file rather than replacing it may require the option to be set to rather than the default . The behavior of some flags are platform-specific. As such, opening a directory on macOS and Linux with the flag, as in the example below, will return an error. In contrast, on Windows and FreeBSD, a file descriptor or a will be returned. On Windows, opening an existing hidden file using the flag (either through , , or ) will fail with . Existing hidden files can be opened for writing with the flag. A call to or can be used to reset the file contents."
    },
    {
        "link": "https://nodejs.org/en/learn/manipulating-files/working-with-folders-in-nodejs",
        "document": "The Node.js core module provides many handy methods you can use to work with folders.\n\nUse (and its promise-based counterpart) to check if the folder exists and Node.js can access it with its permissions.\n\nUse or or to create a new folder.\n\nUse or or to read the contents of a directory.\n\nThis piece of code reads the content of a folder, both files and subfolders, and returns their relative path:\n\nYou can get the full path:\n\nYou can also filter the results to only return the files, and exclude the folders:\n\nUse or or to rename folder. The first parameter is the current path, the second the new path:\n\nUse or or to remove a folder.\n\nTo remove a folder that has contents use with the option to recursively remove the contents.\n\nmakes it so that exceptions will be ignored if the folder does not exist."
    },
    {
        "link": "https://stackoverflow.com/questions/10049557/reading-all-files-in-a-directory-store-them-in-objects-and-send-the-object",
        "document": "I do not know if this is possible, but here goes. And working with callbacks makes it even more difficult.\n\nI have a directory with html files that I want to send back to the client in Object chunks with node.js and socket.io.\n\nAll my files are in /tmpl\n\nSo socket needs to read all the files in /tmpl.\n\nfor each file it has to store the data in an object with the filename as the key, and the content as the value.\n\nThe final callback is also wrong. It has to be called when all the files in the directory are done.\n\nBut I do not know how to create the code, anyone know if this is possibel?"
    },
    {
        "link": "https://stackoverflow.com/questions/64513819/list-files-in-a-directory-with-fs-readdir-fs-stat-and-push-to-array",
        "document": "I am trying to get list of files in a directory with help of fs.readdir & fs.stat (NodeJS version 9.8.0) and push the list to JSON array but it does not get populated. I am able to do it with synchronous methods (like this) but I would like to get this done with asynchronous ones. With some googling around came to know that this has something to do with callbacks. By the time callbacks finish the response is already sent (please correct if this understanding is wrong). Following is the original code written:\n\nThen I tried to use promisify with util package of NodeJS but no luck. Can someone please assist here."
    },
    {
        "link": "https://w3schools.com/nodejs/met_path_extname.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://geeksforgeeks.org/node-js-path-extname-method",
        "document": "The path.extname() method is used to get the extension portion of a file path. The extension string returned from the last occurrence of a period (.) in the path to the end of the path string. If there are no periods in the file path, then an empty string is returned.\n\nParameters: This method accepts single parameter path which holds the file path that would be used to extract the extension.\n\nReturn Value: It returns a string with the extension portion of the path. It throws a TypeError if this parameter is not a string value.\n\nBelow examples illustrate the path.extname() method in node.js:"
    },
    {
        "link": "https://nodejs.org/en/learn/manipulating-files/nodejs-file-paths",
        "document": "Every file in the system has a path. On Linux and macOS, a path might look like: while Windows computers are different, and have a structure such as:\n\nYou need to pay attention when using paths in your applications, as this difference must be taken into account.\n\nYou include this module in your files using and you can start using its methods.\n\nGetting information out of a path\n\nGiven a path, you can extract information out of it using those methods:\n• : gets the parent folder of a file\n\nYou can get the file name without the extension by specifying a second argument to :\n\nYou can join two or more parts of a path by using :\n\nYou can get the absolute path calculation of a relative path using :\n\nIn this case Node.js will simply append to the current working directory. If you specify a second parameter folder, will use the first as a base for the second:\n\nIf the first parameter starts with a slash, that means it's an absolute path:\n\nis another useful function, that will try and calculate the actual path, when it contains relative specifiers like or , or double slashes:\n\nNeither resolve nor normalize will check if the path exists. They just calculate a path based on the information they got."
    },
    {
        "link": "https://stackoverflow.com/questions/10865347/node-js-get-file-extension",
        "document": "I would like to grab the file extension of the image. so i can rename the file and then append the file extension to it. app.post('/upload', function(req, res, next) { var is = fs.createReadStream(req.files.upload.path), fileExt = '', // I want to get the extension of the image here os = fs.createWriteStream('public/images/users/' + req.session.adress + '.' + fileExt); }); How can i get the extension of the image in node.js?"
    },
    {
        "link": "https://stackoverflow.com/questions/37073890/nodejs-get-file-extension",
        "document": "I have a folder with images and they can have different formats but the name will always be unique. Is there a way to get the file extension if I know the file's name without the extension (eg. and not )? I could just check if the file exists for every extension I expect to be there but that seems like a bad solution to me.\n\nExample: I know there is an image called but I don't know the extension (could be either '.png', '.jpg' etc.) therefore I can not use the file command."
    }
]