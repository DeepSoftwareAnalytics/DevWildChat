[
    {
        "link": "https://fabricjs.com/docs",
        "document": "A brief introduction to Fabric.js and especially what the user can expect from this guide\n\nExperience with using Javascript would be handy if you want to program something which is more more than ‚Äòhello World‚Äô üòá"
    },
    {
        "link": "https://fabricjs.com/docs/upgrading/upgrading-to-fabric-60",
        "document": "Fabric 6.0 has been a large rewrite and not all breaking changes have a suggested action items. Not all the desired outcome has been achieved because we were stuck in a long beta stage with frequent breaking changes. This is a list of the largest conceptual changes.\n\nFabric.js is now written in Typescript. Types will help you discover the api quickly, especially with things like events. As a consequence of this change if you are using you should remove it.\n\nfor node usage. Imports will require some changes in the future again, because the and namespaces are a bit of an issue for tree shaking. Indeed now you can also do:\n\nand import only the parts of fabric you are actually using, but BE AWARE you are not protected for safe usage of and svg loading, for now use at your own risk and if you are not sure ask informations.\n\nSome classes have been renamed because their name was a reserved keyword\n‚Ä¢ fabric.Object is now known as FabricObject\n‚Ä¢ fabric.Text is now known as FabricText\n‚Ä¢ fabric.Image is now known as FabricImage\n\nBefore fabric was using functions with agumented prototype and an utility to create inheritance and mixins. That was ok and functional, but didn‚Äôt really play well with Typescript.\n\nSo before we would have something like this:\n\nThe class was created with an utility, createKlass that took care of running the custom method for every new instance that was created, and that took care of inheritance. As a result this was the situation:\n‚Ä¢ Default values for properties were defined on the prototype exactly as method were\n‚Ä¢ All Instances shared the same on the prototype for properties that weren‚Äôt assigned\n‚Ä¢ Mixins were possible as simple object merges and were used for code organization and sharing\n\nYou could mutate the prototype at runtime to change default values for all classes:\n\nWould have made all instances with originX set to center, apart the ones for which you ever set the origin to some value before changing the prototype. If you were not comfortable with this concept this could have led to unexpected results.\n\nClasses works differently, the syntax does not support default values on the prototype at all, and anyway typescript does not understands it. The setup we picked up for fabricJS main classes is:\n‚Ä¢ We do not do any prototype mutation by default, but the developer can still opt in for that\n‚Ä¢ Default values for properties are assigned on the instance as it would be if you are using public properties\n‚Ä¢ Each class has a mutable static object that holds the default values for that class and that get assigned during the contructor\n‚Ä¢ There are no more default shared objects between instances for which mutation is tricky ( ex: controls )\n‚Ä¢ Mixins are there as leftovers, will need to be removed in the future\n‚Ä¢ Subclassing is done with standard syntax\n\nChanging default values and getting shared controls is still possible following specific instructions available here:\n\nAll the apis that where having a callback with one or parameters are now based. Everything that was is now\n\nTo make an example for loadSVGFromString\n\nIf it still works somewhere, don‚Äôt use it. It is a leftover.\n\nLot of breaking changes here and there\n\nThere are many breaking changes in Group, in Canvas, in methods signatures and more. If you have a large project with large customizations and subclassing upgrading will be hard, we are sorry about that. There is a more extensive list of changes here: #8299."
    },
    {
        "link": "https://github.com/fabricjs/fabric.js/issues/8299",
        "document": "This list is in progress and is meant to be an easy go to place to add things and find them when the time comes to write a document on what has changed.\n\n This will be a list of descriptive items, extended as needed to capture behavior changes.\n\n Apart from what is described here MANY bugs have been fixed in the process.\n‚Ä¢ Imports we moved from to or . To avoid packaging issues node has its own entrypoint . This means there is no fabric namespace/object anymore.\n‚Ä¢ Introduced to bridge the absence of a namespace\n‚Ä¢ Introduced the concept, to allow node/browser specific values/logic. That has made importing fabric in SSR possible and will allow offscreen support in the future.\n‚Ä¢ renamed the following Force users to use FabricObject instead of Object„ÄÅFabricImage instead of Image„ÄÅFabricText instead of Text :\n‚Ä¢ Node's has been removed, use exposed by node canvas\n‚Ä¢ method chaining is now deprecated, don't use it anymore. Not all methods were chainable, and chaining seems to offer limited advantages ( maybe saving 1-2 bytes in the code you write when minified? unsure what else ). Just for consistency sake and to be free to start returning useful information from some methods we will stop using it. We didn't remove it from everywhere so that there isn't unnecessary breakage, but you should consider that unsafe to use, since will break entirely on the next major release after 6.0\n\n ( add detailed list of where has been removed so far )\n‚Ä¢ Callbacks are mostly gone, all of the functions that took a callback now return a Promise, this on top of being breaking slightly alter code behavior when is fixed. Before sync code would execute the callback synchronously, now is chained to however the browser handle the promise ( not sure if it goes in the event loop and under which circumstances ). Promises support #3684\n‚Ä¢ TS: The code base is typed! If you used you should uninstall it\n‚Ä¢ Prototype Mutation:\n\n Fabric has moved to native classes. No more or . You can still mutate the prototype, however, properties do not exist on the prototype in native classes. Look into instead.\n‚Ä¢ scene vs. viewport\n\n We introduced these concepts to describe the rendering/view planes as follows: The viewer is viewing the scene (what is rendered/\"playing\") from the viewport. The scene was considered is the past as the plane whereas the viewport wasn't feat(Canvas): provide correctly named canvas pointer methods. BREAKING: rm , #9175.\n\n Normally geometry calculations occur in the scene with the exception of which is a viewport scalar.\n‚Ä¢ All events have a and properties replacing the deprecated and confusing and properties. Brushes are still in need of this change.\n‚Ä¢ dep in favor of or\n‚Ä¢ Using is rather confusing with this change (especially with etc.) perhaps be renaming to is the correct migration path in the future.\n‚Ä¢ \n‚Ä¢ Ensure proper disposal in , especially with React 18. Refer to this hook for guidance.\n‚Ä¢ Async Disposal: Handle async nature of dispose method. The asynchronous disposal of Canvas and StaticCanvas safeguards an edge case in which is called while rendering is still in progress. This should burden your react app.\n‚Ä¢ DOM Mutation: Fabric modifies the DOM and cleans up after itself as long as is called\n‚Ä¢ not available as a standard object as any longer, was never meant to, it was a constrain of the previous build system ( we had no imports or require or bundling before ).\n‚Ä¢ Collection now owns the stack too, methods were renamed to accommodate :\n‚Ä¢ Support to stack operations with active selection is gone\n‚Ä¢ Canvas.dispose and StaticCanvas.dispose are now async In order to handle some concurrency issue with requestAnimationFrame, dispose is now checking and waiting for any uncancellable render to finish. This could have some side effects, especially in complex environments with UI frameworks and hot reload of code.\n‚Ä¢ trying to initialize a canvas that has already been initialized fix(Canvas): Safeguard from multiple initialization #7776 is not breaking, it saves the dev from a silent breakage that they weren't aware of\n‚Ä¢ changed cloneWithoutData , now it does not clone backgrounds.\n‚Ä¢ canvas.clone now correctly return either a canvas or staticCanvas\n‚Ä¢ signature changed: now accepts the clipPath as a second argument instead of rechecking its existence\n‚Ä¢ returns the length of the array of objects after adding, like\n‚Ä¢ returns an array with the removed objects inside\n‚Ä¢ removed , , , , ( and gained similar methods from collection (refer to the section)\n‚Ä¢ is not set by default\n‚Ä¢ \n‚Ä¢ dep in favor of or\n‚Ä¢ rm , , , : assign the property directly and render the canvas\n‚Ä¢ BREAKING Coords system improvements:\n‚Ä¢ should be treated as protected , if you need the scene corners of an object use\n‚Ä¢ fixed coords to respect grouping and nesting, see the Group section\n‚Ä¢ removed , from geometry methods signatures (all listed methods operate in the scene):\n‚Ä¢ / to get/set the coordinate in the parent plane, / to get/set the coordinate in the scene plane\n‚Ä¢ is gone. It took a parameter only, was internally unused, didn't take care of internal edge cases setPositionByOrigin is more flexible\n‚Ä¢ Control coords ( ) are calculated only if the object has a ref\n‚Ä¢ has become a static field and should be used only for serialization with . There is still a deprecated getter on the object for compatibility reasons. Avoid using it.\n‚Ä¢ Object looses the stack methods, instead of guessing which was the stack we refer to when we move forward/backward we do that from the stack itself , see the Collection section\n‚Ä¢ stateful functionality is deprecated, is officially removed, but is still reacheable. Don't use it. Comparing large set of propeties to detect a change doesn't really play well neither with performance nor with edge cases. stateful and statefulCache are removed. was used to fire an object modified every render cycle in which a change in state properties was determiend. All the events that can modify an object already fire an event, and the user has no ability to change colors or state outside developer written code, so there is no really need for event firing here. statefulCache was an experiment and the suggestion to use replaced it since long. FabricJS internally still use some stateful logic for now, but the intention is to get rid of it.\n‚Ä¢ methods like , , , are gone. Those were aliases for the canvas methods, use them instead.\n‚Ä¢ changed to adapt to animation changes\n‚Ä¢ The object is not shared between instances - it is not on the prototype as all class fields\n‚Ä¢ BREAKING: , now returns instead of\n‚Ä¢ see Text styles under the Serialization section\n‚Ä¢ rename to with value , if you were using now you have to use and then check for equality with or change your cssSelector accordingly.\n‚Ä¢ returns an empty object instead of undefined when style is not set.\n‚Ä¢ controls can be used in editing mode\n‚Ä¢ (considered private in the past), has been renamed to . The logic with which Polyline based object calculate the size is changed. There wasn't an api in 5.x to change the size, but devs needed to do it anyway and the alternative was to create a new object. Is not called setPositionAndDimensions because the logic to correcly change size while keeping a visual correct position is not there yet and maybe it won't.\n‚Ä¢ CONCEPT: Group rewrite exposes a change in concept - strict object tree. An object can belong to one parent.\n‚Ä¢ exposed the property on alongside to allow an object to return to its after being deselected from an active selection.\n‚Ä¢ is gone, now does what it has to do.\n‚Ä¢ has been introduced to handle group layout . By default it will be , meaning the group will fit around its objects, updating when objects are added/removed/modified.\n‚Ä¢ expose for ease of use\n‚Ä¢ no longer shared, they are a class field\n‚Ä¢ is now exported differently. This is BREAKING only if you are handling the style object post export The default object we exported was large most of the time, with tons of empty keys and verbosity. It seems reasonable to think that most of the time text is styled in some chunk of text with coherent different styles ( eg: a red word in a black text or some words underlined and some not more than a rainbow of different stylings per object ) for that reason we changed the approach of serialization to an array with start and end index for the style. We didn't apply that to actual runtime code because we were unsure of performance, so at least for version 6, styles at runtime are going to be the same. It is highly recommended to not fiddle with the style object directly and to treat it as internal, using the public facing methods to apply changes.\n‚Ä¢ => populate with properties was used internally to add the extra options to exported objects. Between spread operator and new syntax, a generic pick approach seemed more correct.\n‚Ä¢ is not an alias of . This was a long standing bug, but also a breaking change. never accepted additional properties and will give you only the default object export. is meant for interoperability and is not meant to be used in your code base directly. reference\n‚Ä¢ classRegistry => register your subclasses to use them during serialization\n‚Ä¢ moved to and incremented from 2 to 4\n\n: removed the . Wasn't working anymore since the refactor of Pattern and also a super weird practice.\n‚Ä¢ animation util does not accept anymore the or syntax for changes, nor accept the byValue option. You can specify an animation only by startValue and endValue.\n‚Ä¢ Every animation returns a class with a cancel method to cancel the animation.\n‚Ä¢ Animation callback onChange and onComplete will fire for every animation generated by set of properties. This change is necessary because if we assign the callbacks to only one animation, in case that animation will be cancelled, the other ones won't have any registered callback.\n‚Ä¢ signature change. The transformation is not supported anymore and requires real points\n‚Ä¢ removal of all the array utils ( min, max, find those are well covered by es6 now and also is out of fabric scope to provide generic data manipulation utils )\n‚Ä¢ some utils are considered internal and not exposed anymore ( TODO add list )\n‚Ä¢ and have been removed. Those were used in all examples unfortunately so the community has likely adopted them, consider migrating to a well known common library for those functionalities ( lodash, underscore ... ). Avoid using such utilities on instances of shapes or canvas. So do not clone a Rect with a clone utility. You can clone objects you don't want to mutate, in general plain javascript objects.\n‚Ä¢ and are removed. Those were needed internally and one of them is still used internally, but is not a fabricJS core functionality and not part of the api anymore.\n‚Ä¢ exposed , , to ease common usages of linear algebra. Check them out, you will benefit from it.\n‚Ä¢ now returns a disposer making it easier to use and the method redundant feat(observable): BREAKING return disposer instead of context for chaining\n‚Ä¢ Eraser has been extracted to https://github.com/ShaMan123/erase2d\n‚Ä¢ Touch gestures are not yet migrated/officially supported - use a lib for that for now"
    },
    {
        "link": "https://fabricjs.com",
        "document": "Fabric provides interactive object model on top of canvas element Fabric also provide serialization and has SVG-to-canvas (and canvas-to-SVG) parser\n\nImport and draw complex SVG paths composed from hundreds of simple paths Support for tweening/easing of position, transformation, and style Create a clipping region for an object, group, or the whole canvas from any other Fabric object On-canvas controls for scale, rotation, and skew, and a powerful custom control API Written in Typescript for a streamlined workflow and easy debugging Group multiple objects together for selection and transformation"
    },
    {
        "link": "https://blog.logrocket.com/build-image-editor-fabric-js-v6",
        "document": "In web development projects, developers typically create user interface elements with standard DOM elements. Sometimes, web developers need to create interactive, dynamic, high-performance graphics on web surfaces.\n\nIn such scenarios, using traditional HTML or SVG elements won‚Äôt offer great performance or all the flexible drawing features you might expect.\n\nWe could use the inbuilt HTML canvas API to create interactive, high-performance graphics, but it‚Äôs a low-level, less-productive API for modern developers. So, we need to find a high-level canvas library to create interactive graphics with less code.\n\nThe solution for this is the Fabric.js HTML canvas library, a fully-featured canvas library that offers a minimal, high-level API to draw interactive, editable shapes, images, and, text on multiple canvas layers. It lets you activate freehand drawing, apply image filters, and use animations.\n\nAnd Fabric.js‚Äôs latest release, v6, has an even better API for modern web development style.\n\nIn this article, we‚Äôll check what‚Äôs new in Fabric.js v6 and learn how to use it to build interactive canvas graphics by building an image editor app using Fabric.js v6 and React.\n\nThe Fabric.js library was initially released in 2010 when the ECMAScript specification didn‚Äôt have modern readable asynchronous programming concepts like Promises and / keywords, so the earlier Fabric.js versions had old-fashioned callbacks.\n\nFabric.js v6 modernized its API and development environment by upgrading to modern JavaScript syntax by rewriting the library in TypeScript.\n\nHere is a summary of major breaking changes and enhancements from Fabric.js v6 that you‚Äôll likely need to address in your code:\n‚Ä¢ The Fabric.js project has migrated to TypeScript and started offering built-in type definitions for developers\n‚Ä¢ Fabric.js v6 comes with modular object imports (i.e., ), so developers can write more readable code and JavaScript bundlers can reduce the final source bundle size once the library supports tree-shaking\n‚Ä¢ OOP methods now use Promises for handling async operations instead of old-fashioned callbacks which may cause the callback hell problem. This means developers can write shorthand asynchronous code blocks with the keywords or methods\n‚Ä¢ The library improved React compatibility by asynchronously handling DOM cleanup operations with the method of the object\n‚Ä¢ Fabric.js now uses native ECMAScript classes, so developers don‚Äôt need to use like old utility functions to create custom Fabric classes ‚Äî you can use the native keyword\n\nApart from the above major changes and enhancements, other breaking changes include class and method deprecations and parameter changes, as listed in this GitHub issue.\n\nNow you know the benefits of using Fabric.js for creating interactive canvas elements and new features and changes in v6. Let‚Äôs learn how to work with Fabric.js v6 by building a simple image editor app. The image editor app will cover all major Fabric.js features by implementing image importing, image filtering, text element creation, and freehand drawing features.\n\nWe‚Äôll use React to develop the image editor, so create a new app with Create React App (CRA) as follows:\n\nLet‚Äôs create the structure of the image editor before installing the required dependencies. Divide the screen into two rows for the toolbox and canvas with CSS Flexbox by adding the following code to the file:\n\nThe application structure uses two sub-components: and to reduce the complexity of growing code lines. Create the component with several placeholder buttons by adding the following code to the file:\n\nNext, create the final sub-component, , which will hold the HTML canvas element of our image editor app:\n\nNow we need to style this app structure using CSS by adding the following CSS definitions to the file:\n\nStart the React app with or . You‚Äôll see the structure of the image editor app with several placeholder buttons:\n\nNow we can start adding required dependencies to continue with the development process. We‚Äôll use Fabric.js as the canvas library and Font Awesome SVG icons package, so install them using the following commands:\n\nThe current canvas is an empty, native HTML canvas element that has a white background added with CSS ‚Äî nothing happens when you click or drag using your mouse or touchpad. We need to turn this empty canvas into a Fabric.js editing canvas to start building the image editor app.\n\nImport Fabric.js class and other required React functions in the file:\n\nNext, initialize a Fabric.js canvas instance and bind it to the element within the function:\n\nHere we use a React reference to get the canvas DOM reference and the state to store the Fabric.js instance reference.\n\nUpdate the component template by passing the canvas element reference and the Fabric.js instance via component props:\n\nHere we passed the canvas reference to the via , so we need to wrap the component with , as shown in the following code snippet:\n\nFinally, remove the temporary property from the canvas element:\n\nThe above changes are enough to initialize Fabric.js with a native canvas element. Try dragging the mouse on the canvas area. You‚Äôll see a selection box indicating that Fabric.js is initialized:\n\nNow, our Fabric.js canvas is ready to hold images, shapes, texts, and all supported Fabric.js objects. Let‚Äôs add a new toolbox button to let app users import new images into the photo editing area.\n\nWe‚Äôll use Font Awesome icons in toolbox buttons, so import all the icons we‚Äôll use from the source file:\n\nImport the Font Awesome icon component and Fabric.js class from the file as follows:\n\nAdd a new button to import an image, and add the selected image to the canvas by updating the component implementation, as shown in the following code snippet:\n\nHere we use the native HTML file picker element with the inbuilt interface to read the selected image as a base64-encoded data URL. The encoded image URL is used to create a new Fabric.js image by using the asynchronous method.\n\nUse the following CSS definition to hide the native file picker element by letting users open the file picker by clicking on the toolbox button:\n\nOpen the app, click the add image button, and select any image. You can move, resize, and rotate imported images using the default Fabric.js controls, as shown in the following preview:\n\nTry to import different images and manipulate those image objects using inbuilt Fabric.js object controls. You can undoubtedly import PNG images that have alpha channels (transparent regions).\n\nFabric.js supports adding editable and non-editable text objects into the canvas. Let‚Äôs add a new toolbox button to add a new editable text element to the image editor surface.\n\nFirst, add a new toolbox button with a click handler:\n\nNext, implement the click handler by writing code to add a new interactive text element into the Fabric.js canvas as follows:\n\nHere we used the class to create a new editable text element, so make sure to import it from the package:\n\nNow you can add new text elements by clicking the newly added toolbox button. You can double-click on the text element to change text and use controls to move, resize, or rotate as usual:\n\nFabric.js has a pre-developed freehand drawing implementation that supports several inbuilt brush types. Let‚Äôs activate simple freehand drawing support in the image editor app by using the class. We‚Äôll add a toggle button to activate/deactivate drawing mode, so create a new state field for the drawing mode in the component:\n\nAdd the following function to the component to toggle the drawing mode:\n\nNext, add a new button to toggle the drawing mode:\n\nThese code changes activate the drawing mode, but you won‚Äôt see any drawing lines when you draw things on the canvas since we need to set the default freehand drawing brush first. Set the default brush by adding the following statements into the block of the component:\n\nClick on the freehand drawing mode button and draw something. You can go back to the selection mode by clicking on the same toolbox button, as shown in the following preview:\n\nTry to use a different brush type as the default freehand drawing brush, i.e., .\n\nFabric.js implements many inbuilt filter algorithms that you can add to image objects, so we can use several filters in this sample image editor app too. We‚Äôll add a new toggle button into the toolbox that users can click to activate a preferred image filter.\n\nFirst, add a new button and a filter list to the toolbox:\n\nHere we used the state field to store the current filter name of the selected image. Get the filter name and setter from props since we create the filter state in :\n\nApply the selected filter when the gets changed in a new component rendering event, as shown in the following code snippet using a block:\n\nThe above block detects filter changes and applies the selected filter to the currently selected image object. Here we used only five filters, but you can use more filters by checking all supported filter implementations in the object.\n\nCreate a new state field in the component to store the current filter and make sure to pass it into child components:\n\nHere we passed parent state fields into child components via props since we have only one child component level, but you should use React context API if your app has child elements within child elements to avoid prop drilling.\n\nNow you can activate filters for a selected image object, as demonstrated in the following preview:\n\nAs you noticed it doesn‚Äôt properly change the filter activation status and detect filters of the selected image object, so we have to subscribe to Fabric.js events to change the filter selection list based on the currently selected image‚Äôs filter.\n\nFirst, get the filter name setter from the props of the component as follows:\n\nNext, add the following block to set the current filter name according to the filter of the currently selected image object by listening to Fabric.js selection events:\n\nNow, the image editor changes the applied filter name properly when users work with multiple images:\n\nFabric.js offers many inbuilt image editing features, but it doesn‚Äôt implement keyboard support out of the box. However, we can easily listen to global keystrokes with the browser event listener API and trigger Fabric.js features to implement better, flexible keyboard support.\n\nTo learn keyboard handling, we can let users remove selected canvas objects by pressing the delete key.\n\nListen to key-down events and remove selected elements by adding the following code statements into the block of the component:\n\nMake sure to remove the attached event listener when the component gets unmounted:\n\nTry removing objects from the canvas by selecting single or multiple elements and pressing the delete key from the keyboard:\n\nYou can easily start implementing the cut-copy-paste feature and moving objects with arrow keys using the same key-down handler we‚Äôve created before.\n\nWhat if the user needs to clear all existing objects and start with a new design? Asking the user to select all elements and press the delete key is not user-friendly, so let‚Äôs add a new toolbox button to let users clear the canvas instantly.\n\nAdd a new toolbox button with a click handler as follows:\n\nThe above toolbox button removes all existing canvas objects after showing a user confirmation dialog, as demonstrated in the following preview:\n\nExporting the Fabric.js canvas as an image\n\nEvery image editor program lets users export the current design as an image. Most browsers nowadays support using PNG image format exports in the method of the native canvas element, so we can use it to export Fabric.js canvas as an image:\n\nThe web browser will download a PNG image that contains a snapshot of the Fabric.js canvas when you click on the download button, as demonstrated in the following preview:\n\nYou can access the complete source code of this sample image editor app from this GitHub repository.\n\nWe‚Äôve covered a lot by creating this image editor app via Fabric.js‚Äôs key features. That said, there are other ideas you could implement to convert this sample image editor into a fully-featured, advanced image editor program like Adobe Photoshop:\n‚Ä¢ Adding geometric shapes using pre-developed classes like , , etc.\n‚Ä¢ Letting users customize filter parameters by using several form elements in a popup\n‚Ä¢ Implementing a productive context menu with cut, copy, paste, send to back, and bring forward-like features\n‚Ä¢ Adding a productive keyboard shortcut set to let users use the keyboard for image editing, i.e., moving objects with arrow keys\n‚Ä¢ Using Fabric.js inbuilt serialization/deserialization features to save/load design documents and autosave changes in the browser‚Äôs local storage\n‚Ä¢ Adding canvas surface customization options like using custom canvas sizes and changing background fill color\n\nIf there‚Äôs a really good tip not listed here that you think other would benefit from, leave it in the comments!\n\nReady to build your own epic editor?\n\nIn this tutorial, we learned how to use Fabric.js v6 with React by developing a sample image editor app that supports importing images, adding text elements, and activating image filters. We also learned how to use inbuilt standard browser APIs with Fabric.js to add keyboard support and export canvas as a PNG image.\n\nIn v6, Fabric.js improved its API by migrating into TypeScript and using a Promise-based, modular codebase, so using Fabric.js v6 doesn‚Äôt bring the callbacks-based old-fashioned coding style that v5 and older versions had.\n\nThe official documentation is not updated yet for the latest modular, Promise-based coding style and the library maintainers are working on documentation updates.\n\nWhether you‚Äôre motivated to create an Adobe Photoshop-like image editor or Figma-esque UI design software, the above demonstration should set you on the straight and narrow towards an excellent project. Happy coding."
    },
    {
        "link": "https://stackoverflow.com/questions/18732876/crop-functionality-using-fabricjs",
        "document": "You can crop in Fabric.js using either fabric.Object.clipTo() or fabric.Object.toDataURL(). The method retains the original image and displays a crop via a mask. The method creates a new image.\n\nMy full example uses the method. I have included a small chunk of code at the end showing the method.\n‚Ä¢ Prepare an invisible rectangle. Have it draw when the user clicks and drags mouse across canvas.\n\nIn the fiddle in Tom's answer, there are a couple of minor things I wanted to change. So in my example the differences are\n‚Ä¢ None The crop box work from left to right and right to left (Tom's works from right to left only)\n‚Ä¢ None You have more than one chance to draw the crop box (attempting to re-draw the crop box in Tom's causes box to jump)\n\nOr, instead of using like above, we could generate a new image using . Something like this"
    },
    {
        "link": "https://stackoverflow.com/questions/35395610/crop-an-image-using-fabricjs",
        "document": "I would like to crop an image using (javascript)FabricJS + HTML5 canvas.\n\nI attached an image too. (you can see what i would like to accomplish) Is it possible to resize FabricJS canvas somehow to keep only the area selected by rectangle(green dotted rectangle). I think i have all necessary coordinates as you can see on attachment.\n\nAnybody have any ideas/(algorithm,pseudo code) how can i solve it using javascript(FabricJS) ?"
    },
    {
        "link": "https://fabricjs.com/api/classes/canvas",
        "document": "needs to end up in the constructor too\n\nIndicates which key enable alternate action on corner values: ‚ÄòaltKey‚Äô, ‚ÄòshiftKey‚Äô, ‚ÄòctrlKey‚Äô. If or ‚Äònone‚Äô or any other string that is not a modifier key feature is disabled feature disabled.\n\nIndicates which key enable alternative selection in case of target overlapping with active object values: ‚ÄòaltKey‚Äô, ‚ÄòshiftKey‚Äô, ‚ÄòctrlKey‚Äô. For a series of reason that come from the general expectations on how things should work, this feature works only for preserveObjectStacking true. If or ‚Äònone‚Äô or any other string that is not a modifier key feature is disabled.\n\nBackground image of canvas instance. since 2.4.0 image caching is active, please when putting an image as background, add to the canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom vale. As an alternative you can disable image objectCaching\n\nif set to false background image is not affected by viewport transform\n\nwe should really find a different way to do this\n\nIndicates which key enable centered Transform values: ‚ÄòaltKey‚Äô, ‚ÄòshiftKey‚Äô, ‚ÄòctrlKey‚Äô. If or ‚Äònone‚Äô or any other string that is not a modifier key feature is disabled feature disabled.\n\nWhen true, objects use center point as the origin of rotate transformation. Backwards incompatibility note: This property replaces ‚ÄúcenterTransform‚Äù (Boolean).\n\nWhen true, objects use center point as the origin of scale transformation. Backwards incompatibility note: This property replaces ‚ÄúcenterTransform‚Äù (Boolean).\n\na fabricObject that, without stroke define a clipping area with their shape. filled in black the clipPath object gets used when the canvas has rendered, and the context is placed in the top left corner of the canvas. clipPath will clip away controls, if you do not want this to happen use controlsAboveOverlay = true\n\nDefault element class that‚Äôs given to wrapper (div) element of canvas\n\nDefault cursor value used for the entire canvas\n\nIf true the Canvas is in the process or has been disposed/destroyed. No more rendering operation will be executed on this canvas.\n\nStarted the process of disposing but not done yet. WIll likely complete the render cycle already scheduled but stopping adding more.\n\nWhen the option is enabled, PointerEvent is used instead of TPointerEvent.\n\nWhen true, canvas is scaled by devicePixelRatio for better rendering on retina screens\n\nIndicates if the canvas can fire middle click events\n\nIndicates if the canvas can fire right click events\n\nCursor value used during free drawing\n\nHeight in virtual/logical pixels of the canvas. The canvas can be taller than width if retina scaling is active\n\nDefault cursor value used when hovering over an object on canvas\n\nIndicates whether this canvas will use image smoothing, this is on by default in browsers\n\nIndicates whether toObject/toDatalessObject should include default values if set to false, takes precedence over the object value.\n\nWhen true, mouse events on canvas (mousedown/mousemove/mouseup) result in free drawing. After mousedown, mousemove creates a shape, and then mouseup finalizes it and adds an instance of onto canvas.\n\nDefault cursor value used when moving an object on canvas\n\nCursor value used for disabled elements ( corners with disabled action )\n\nOverlay image of canvas instance. since 2.4.0 image caching is active, please when putting an image as overlay, add to the canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom vale. As an alternative you can disable image objectCaching\n\nif set to false overlay image is not affected by viewport transform\n\nwe should really find a different way to do this\n\nWhen true, object detection happens on per-pixel basis rather than on per-bounding-box\n\nIndicates whether objects should remain in current stack position when selected. When false objects are brought to top and rendered as part of the selection group\n\nIndicates whether StaticCanvas#add, StaticCanvas#insertAt and StaticCanvas#remove, StaticCanvas#moveTo, StaticCanvas#clear and many more, should also re-render canvas. Disabling this option will not give a performance boost when adding/removing a lot of objects to/from canvas at once since the renders are queued and executed one per frame. Disabling is suggested anyway and managing the renders of the app manually is not a big effort ( canvas.requestRenderAll() ) Left default to true to do not break documentation and old app, fiddles.\n\nIndicates whether group selection should be enabled\n\nColor of the border of selection (usually slightly darker than color of selection itself)\n\nDefault dash array pattern If not empty the selection border is dashed\n\nSelect only shapes that are fully contained in the dragged selection rectangle.\n\nIndicates which key or keys enable multiple click selection Pass value as a string or array of strings values: ‚ÄòaltKey‚Äô, ‚ÄòshiftKey‚Äô, ‚ÄòctrlKey‚Äô. If or empty or containing any other string that is not a modifier key feature is disabled.\n\nWidth of a line used in object/group selection\n\nBased on vptCoords and object.aCoords, skip rendering of objects that are not included in current viewport. May greatly help in applications with crowded canvas and use of zoom/pan If One of the corner of the bounding box of the object is on the canvas the objects get rendered.\n\nWhen true, target detection is skipped. Target detection will return always undefined. click selection won‚Äôt work anymore, events will fire with no targets. if something is selected before setting it to true, it will be deselected at the first click. area selection will still work. check the property too. if you deactivate both, you should look into staticCanvas.\n\nIndicates if the right click on canvas can output the context menu or not\n\nWhen true, getSvgTransform() will apply the StaticCanvas.viewportTransform to the SVG transformation. When true, a zoomed canvas will then produce zoomed SVG output.\n\nNumber of pixels around target pixel to tolerate (consider active) during object detection\n\nKeep track of the subTargets for Mouse Events, ordered bottom up from innermost nested subTarget\n\nWhen true, objects can be transformed by one side (unproportionately) when dragged on the corners that normally would not do that.\n\nfabric 4.0 // changed name and default value\n\nIndicates which key switches uniform scaling. values: ‚ÄòaltKey‚Äô, ‚ÄòshiftKey‚Äô, ‚ÄòctrlKey‚Äô. If or ‚Äònone‚Äô or any other string that is not a modifier key feature is disabled. totally wrong named. this sounds like if Canvas.uniformScaling is true, pressing this will set it to false and viceversa.\n\nThe transformation (a Canvas 2D API transform matrix) which focuses the viewport\n\nThe viewport bounding box in scene plane coordinates, see calcViewportBoundaries\n\nWidth in virtual/logical pixels of the canvas. The canvas can be larger than width if retina scaling is active\n\nA reference to the canvas actual HTMLCanvasElement. Can be use to read the raw pixels, but never write or manipulate\n\nMethod that defines actions when an Event Mouse Wheel\n\nDivides objects in two groups, one to render immediately and one to render as activeGroup.\n\nobjects to render immediately and pushes the other in the activeGroup.\n\nThis is supposed to be equivalent to discardActiveObject but without firing any selection events ( can still fire object transformation events ). There is commitment to have this stay this way. This is the functional part of discardActiveObject.\n\nthe next object to set as active, reason why we are discarding this\n\ntrue if the active object has been discarded\n\nThis is supposed to be equivalent to setActiveObject but without firing any event. There is commitment to have this stay this way. This is the functional part of setActiveObject.\n\ntrue if the object has been selected\n\nSets the cursor depending on where the canvas is being hovered. Note: very buggy in Opera\n\nObject that the mouse is hovering, if so.\n\nPan viewport so as to place point at top left corner of canvas\n\nAdds objects to collection Objects should be instances of (or inherit from) FabricObject\n\nMoves an object or a selection up in stack of drawn objects An optional parameter, intersecting allows to move the object in front of the first intersecting object. Where intersection is calculated with bounding box. If no intersection is found, there will not be change in the stack.\n\nIf , send object in front of next upper intersecting object\n\nMoves an object or the objects of a multiple selection to the top of the stack of drawn objects\n\nCalculates canvas element offset relative to the document This method is also attached as ‚Äúresize‚Äù event handler of window\n\nCalculate the position of the 4 corner of canvas with current viewportTransform. helps to determinate when an object is in the current rendering viewport\n\nCenters object vertically and horizontally in the canvas\n\nArray of properties to include in the cloned canvas and children\n\nClones canvas instance without cloning existing data. This essentially copies canvas dimensions since loadFromJSON does not affect canvas size.\n\nGiven a bounding box, return all the objects of the collection that are contained in the bounding box. If is true, return also the objects that intersect the bounding box as well. This is meant to work with selection. Is not a generic method.\n\narray of objects contained in the bounding box, ordered from top to bottom stacking wise\n\nReturns true if collection contains an object.\n\n Prefer using FabricObject#isDescendantOf for performance reasons instead of use\n\nto check all descendants, to check only\n\nif collection contains an object\n\nCreates markup containing SVG font faces, font URLs for font faces must be collected by developers and are not extracted from the DOM by fabricjs\n\nCreates markup containing SVG referenced elements like patterns, gradients etc.\n\nDiscards currently active object and fire events. If the function is called by fabric as a consequence of a mouse event, the event is passed as a parameter and sent to the fire function for the custom events. When used as a method the e param does not have any application.\n\ntrue if the active object has been discarded\n\nWaits until rendering has settled to destroy the canvas\n\na promise resolving to once the canvas has been destroyed or to if the canvas has was already destroyed\n\nPaint the cached clipPath on the lowerCanvasEl\n\nEnd the current transform. You don‚Äôt usually need to call this method unless you are interrupting a user initiated transform because of some other event ( a press of key combination, or something that block the user UX )\n\nsend the mouse event that generate the finalize down, so it can be used in the event\n\nMethod that determines what object we are clicking on 11/09/2018 TODO: would be cool if findTarget could discern between being a full target or the outside part of the corner.\n\nExecutes given function for each object in this group A simple shortcut for getObjects().forEach, before es6 was more complicated, now is just a shortcut.\n\nCallback invoked with current object as first argument, index - as second and an array of all objects - as third.\n\nReturns an array with the current selected objects\n\nReturns coordinates of a center of canvas. Returned value is an object with top and left properties\n\nReturns context of canvas where objects are drawn\n\nReturns <canvas> element corresponding to this instance\n\nReturns an array of children objects of this instance\n\nWhen specified, only objects of these types are returned\n\nwhether to return the point from the viewport or in the scene\n\npoint existing in the scene (the same plane as the plane FabricObject#getCenterPoint exists in). This means that changes to the viewportTransform do not change the values of the point, however, from the viewer‚Äôs perspective, the point is changed.\n\nReturns context of canvas where object selection is drawn\n\nReturns <canvas> element on which object selection is drawn\n\nReturns context of top canvas where interactions are drawn\n\npoint existing in the same plane as the HTMLCanvasElement, being the top left corner of the HTMLCanvasElement. This means that changes to the viewportTransform do not change the values of the point and it remains unchanged from the viewer‚Äôs perspective.\n\nCalculate the point in canvas that correspond to the center of actual viewport.\n\nInserts an object into collection at specified index\n\nReturns true if collection contains no objects\n\nReturns true if object is transparent at a certain location Clarification: this is is target transparent at location X or are controls there\n\nthis seems dumb that we treat controls with transparency. we can find controls programmatically without painting them, the cache canvas optimization is always valid\n\nPopulates canvas with data from the specified JSON. JSON format must conform to the one of fabric.Canvas#toJSON\n\nIMPORTANT: It is recommended to abort loading tasks before calling this method to prevent race conditions and unnecessary networking\n\nMethod for further parsing of JSON elements, called after each fabric object created.\n\nMoves an object to specified level in stack of drawn objects\n\nUnsubscribe all event listeners for eventname. Do not use this pattern. You could kill internal fabricJS events. We know we should have protected events for internal flows, but we don‚Äôt have yet\n\nFunction that receives a notification when an event of the specified type occurs\n\nFunction that receives a notification when an event of the specified type occurs\n\nRemoves all event listeners, used when disposing the instance\n\nRenders both the top canvas and the secondary container canvas.\n\nMethod to render only the top canvas. Also used to render the group selection box. Does not render text selection.\n\ntext selection is rendered by the active text instance during the rendering cycle\n\nAppend a renderAll request to next animation frame. unless one is already in progress, in that case nothing is done a boolean flag will avoid appending more.\n\nFunction used to search inside objects an object that contains pointer in bounding box or that contains pointerOnCanvas when painted\n\nobjects array to look into\n\ntop most object on screen that contains pointer\n\nMoves an object or a selection down in stack of drawn objects An optional parameter, allows to move the object in behind the first intersecting object. Where intersection is calculated with bounding box. If no intersection is found, there will not be change in the stack.\n\nIf , send object behind next lower intersecting object\n\nMoves an object or the objects of a multiple selection to the bottom of the stack of drawn objects\n\nSets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) does not update position of object‚Äôs borders/controls. If you need to update those, call .\n\nProperty name or object (if object, iterate over the object properties)\n\nProperty value (if function, the value is passed into it and its return value is used as a new one)\n\nSets given object as the only active object on canvas\n\nObject to set as an active one\n\ntrue if the object has been selected\n\nSet the cursor type of the canvas element\n\nSets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)\n\nSet the given dimensions only as canvas backstore dimensions\n\nSet the given dimensions only as css dimensions\n\nSets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)\n\nSet the given dimensions only as canvas backstore dimensions\n\nSet the given dimensions only as css dimensions\n\nSets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)\n\nValue to set height to\n\nSet the given dimensions only as canvas backstore dimensions\n\nSet the given dimensions only as css dimensions\n\nValue to set height to\n\nSet the given dimensions only as canvas backstore dimensions\n\nSet the given dimensions only as css dimensions\n\nValue to set width to\n\nSet the given dimensions only as canvas backstore dimensions\n\nSet the given dimensions only as css dimensions\n\nValue to set width to\n\nSet the given dimensions only as canvas backstore dimensions\n\nSet the given dimensions only as css dimensions\n\nto set zoom to, less than 1 zooms out\n\nReturns a size of a collection (i.e: length of an array containing its objects)\n\nCreate a new HTMLCanvas element painted with the current canvas content. No need to resize the actual one or repaint it. Will transfer object ownership to a new canvas, paint it, and set everything back. This is an intermediary step used to get to a dataUrl but also it is useful to create quick image copies of a canvas without passing for the dataUrl string\n\nAny properties that you might want to additionally include in the output\n\nAny properties that you might want to additionally include in the output\n\nExports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately\n\nReturns a data: URL containing a representation of the object in the format specified by options.format\n\nToggles specified property from to or from to\n\nReturns Object representation of canvas this alias is provided because if you call JSON.stringify on an instance, the toJSON object will be invoked if it exists. Having a toJSON method means you can do JSON.stringify(myCanvas)\n\nAny properties that you might want to additionally include in the output\n\nMethod for further parsing of svg elements, called after each fabric object converted into svg representation.\n\nCenters object vertically and horizontally in the viewport\n\nCenters object horizontally in the viewport, object.top is unchanged\n\nCenters object Vertically in the viewport, object.top is unchanged\n\nSets zoom level of this canvas instance, the zoom centered around point meaning that following zoom to point with the same point will have the visual effect of the zoom originating from that point. The point won‚Äôt move. It has nothing to do with canvas center or visual center of the viewport.\n\nto zoom with respect to\n\nto set zoom to, less than 1 zooms out"
    },
    {
        "link": "https://scribbler.live/2024/06/09/Image-Manipulation-in-JavaScript-Fabirc-JS.html",
        "document": "Fabric.js is a powerful and versatile JavaScript library for working with HTML5 canvas. It provides an object model for canvas elements, making it easier to create, manipulate, and render graphics on the web. Fabric.js is widely used in web applications for creating dynamic, interactive graphics.\n‚Ä¢ Object Model: Facilitates creation and manipulation of canvas elements as objects, such as rectangles, circles, and images.\n‚Ä¢ Interactivity: Supports interactive features like dragging, scaling, and rotating objects on the canvas.\n‚Ä¢ Serialization: Allows saving and restoring canvas states through JSON, making it easy to save and share designs.\n\nFabric.js supports various image processing functionalities, allowing manipulation of images directly on the canvas. This includes loading images, applying filters, and transforming images.\n\nLoading and Manipulating Images: Fabric.js can load images from URLs and manipulate them on the canvas. You can set properties such as position, scale, rotation, and opacity to control how the image appears.\n\nApplying Filters: Fabric.js allows the application of image filters such as grayscale, sepia, brightness, and more. These filters can be applied to images to achieve various visual effects, making it a valuable tool for image editing applications.\n‚Ä¢ Photo Editing Tools: Create web-based photo editors that allow users to crop, resize, and apply filters to their images.\n‚Ä¢ Interactive Design Apps: Develop applications where users can design graphics and images interactively.\n‚Ä¢ Online Collage Makers: Build tools that let users combine multiple images and manipulate them to create collages.\n\nFabric.js is used in a variety of applications due to its flexibility and powerful features:\n‚Ä¢ E-learning Platforms: Developing tools for drawing and annotating on digital whiteboards.\n‚Ä¢ XR (Extended Reality): Enhancing AR and VR experiences with interactive graphics and controls.\n\nLoading and Displaying an Image Using Fabric.js #\n\nLet‚Äôs start by loading and displaying an image on the canvas.\n\nThis code initializes a Fabric.js canvas and loads an image from a URL, placing it on the canvas at specified coordinates.\n\nTo crop an image, you can use the , , , and properties.\n\nThis code crops the image to a 200x200 square starting from (50, 50) on the original image.\n\nResizing can be done by setting the and properties.\n\nThis resizes the image to half of its original size.\n\nRotating an image is straightforward using the property.\n\nThis rotates the image by 45 degrees.\n\nFabric.js supports various image filters, such as grayscale, sepia, and brightness. Here‚Äôs how to apply a grayscale filter:\n\nYou can chain multiple filters together:\n\nFabric.js‚Äôs capabilities extend far beyond simple image loading and manipulation. Here are some practical applications of advanced image manipulation using Fabric.js:\n\nFabric.js can be used to build powerful online photo editors that allow users to upload, edit, and save images directly in the browser. Features such as cropping, resizing, rotating, and applying filters can be easily implemented.\n\nCreate comprehensive graphic design tools where users can create and manipulate complex compositions, including text, shapes, and images. Fabric.js‚Äôs object-oriented approach makes it easy to manage multiple elements on the canvas.\n\nDevelop interactive storytelling applications where users can manipulate images to create visual narratives. This can be particularly useful for digital comics, e-books, and educational materials.\n\nFor e-commerce websites, Fabric.js can be used to build customizable product previews. Users can upload their images (e.g., logos or photos) to see how they would look on various products like t-shirts, mugs, or phone cases.\n\nEnable digital artists to create and edit their artwork directly in the browser. Artists can use Fabric.js to draw, paint, and manipulate images, with support for layers, brushes, and filters.\n\nFabric.js can be used to create interactive infographics that allow users to manipulate data visualizations. This can include resizing, rotating, and editing elements to better understand the information presented.\n\nDevelop educational tools that allow students to interact with images for learning purposes. For example, students can annotate images, highlight important areas, and apply filters to enhance their understanding of the subject matter.\n\nCreate virtual scrapbooking applications where users can combine images, text, and decorative elements to create digital scrapbooks. Users can manipulate each element to design their pages creatively.\n\nFabric.js can be used in the development of 2D games where image manipulation is required. This includes sprite creation, animation, and dynamic changes to game assets based on user interactions.\n\nIn medical applications, Fabric.js can be used to manipulate medical images such as X-rays or MRIs. This includes zooming, rotating, and applying filters to enhance image analysis and diagnosis.\n\nHere‚Äôs an example of how you might implement some basic features of an online photo editor using Fabric.js:\n\nIn this example, the basic functionality for rotating an image and applying grayscale and brightness filters is implemented, demonstrating how Fabric.js can be used to create an online photo editor. Experiment with Fabric.js here: JavaScript Notebook for Fabric.js.\n\nCanvas Class: The class in Fabric.js represents the main canvas element where graphics and objects are rendered and manipulated. It serves as the core component for interactive graphics applications on HTML5 canvas.\n‚Ä¢ Key Features:\n‚Ä¢ Allows adding, removing, and manipulating graphical objects such as shapes, images, and text.\n‚Ä¢ Provides methods for handling events like mouse interactions ( , , etc.).\n\nStaticCanvas Class: The class is similar to the class but is designed for non-interactive rendering of static content. It is useful for displaying pre-rendered images or graphics without user interaction.\n‚Ä¢ Functionality: Renders static content that does not require user interaction.\n‚Ä¢ Key Features:\n‚Ä¢ Optimized for rendering large or complex scenes that do not change dynamically.\n‚Ä¢ Suitable for applications where interactivity is not required, such as displaying static diagrams or images.\n‚Ä¢ : Initializes a new instance with the specified HTML element and optional configuration options.\n‚Ä¢ : Removes a specified object from the canvas.\n‚Ä¢ : Retrieves an array of all objects currently on the canvas.\n‚Ä¢ : Attaches an event handler to canvas events such as mouse interactions ( , , etc.).\n‚Ä¢ : Serializes the current state of the canvas into a JSON string representation.\n‚Ä¢ : Fabric.js includes built-in filters like , , , etc., which can be applied to image objects on the canvas.\n‚Ä¢ : Applies selected filters to an image object, optionally invoking a callback function after applying the filters.\n\nHere are some alternatives to Fabric.js for working with HTML5 canvas:\n‚Ä¢ Konva.js\n‚Ä¢ Description: An open-source 2D canvas library for desktop and mobile applications.\n‚Ä¢ Paper.js\n‚Ä¢ Description: A vector graphics scripting framework that runs on top of the HTML5 canvas.\n‚Ä¢ EaselJS\n‚Ä¢ Description: Part of the CreateJS suite, EaselJS provides a straightforward API for working with HTML5 canvas.\n‚Ä¢ Two.js\n‚Ä¢ Description: A two-dimensional drawing API for the modern web, built on top of SVG and HTML5 canvas.\n‚Ä¢ Key Features: Focuses on rendering shapes and paths with a minimalistic API.\n‚Ä¢ PixiJS\n‚Ä¢ Description: A fast, lightweight 2D rendering library that uses WebGL and falls back to HTML5 canvas.\n‚Ä¢ Key Features: Designed for gaming and interactive applications, supports WebGL shaders, sprite sheets, and filters."
    },
    {
        "link": "https://fabricjs.com/docs/old-docs/fabric-intro-part-4",
        "document": "We‚Äôve covered so many topics in the previous series; from basic object manipulations to animations, events, filters, groups, and subclasses. But there‚Äôs still couple of very interesting and useful things to discuss!\n\nIf there‚Äôs anything really shines at, it‚Äôs that it has an excellent support for free drawing! Since canvas is simply a 2D bitmap ‚Äî a paper to paint on ‚Äî performing free drawing is very natural. And of course Fabric takes care of this for us.\n\nA free drawing mode is enabled simply by setting property of Fabric canvas to . This immediately makes any further clicks and movements on canvas get interpreted as a pencil/brush.\n\nYou can paint as many times on canvas as you wish, while is . But as soon as you perform any movement, followed by a ‚Äúmouseup‚Äù event, Fabric fires ‚Äúpath:created‚Äù event and actually transforms just-drawn shape into a real instance!\n\nIf, at any moment, you set back to , you‚Äôll end up with all of the created path objects still present on canvas. And since they‚Äôre good old objects, you can modify them any way you want ‚Äî move, rotate, scale, etc.\n\nThere are also 2 properties available to customize free drawing ‚Äî and . Both are available on Fabric canvas instances through instance. can be any regular color value and represents the color of a brush. is a number in pixels, and represents brush thickness.\n\nIn the near future, we are planning to add more options for free drawing ‚Äî various versions of a brush (e.g. spray-like or chalk-like). Also custom brush patterns, and an option to extend with your own, similar to Fabric image filters.\n\nErasing is another cool available feature that plays nicely with free drawing.\n\nOne of the amazing things about Fabric is how customizable it is. You can tweak dozens of various parameters on canvas or canvas objects, in order to make things behave exactly the way you want. Let‚Äôs take a look at some of them.\n\nEvery object on canvas can be locked in few ways. ‚ÄúlockMovementX‚Äù, ‚ÄúlockMovementY‚Äù, ‚ÄúlockRotation‚Äù, ‚ÄúlockScalingX‚Äù, ‚ÄúlockScalingY‚Äù are properties that lock corresponding object actions. So setting to prevents object from being moved horizontally. You can still move it in vertical plane though. Simiarly, prevents rotation and / ‚Äî scaling. All of these are cumulative. You can combine them together in any way.\n\nYou can control objects‚Äô borders and corners visibility via ‚ÄúhasControls‚Äù and ‚ÄúhasBorders‚Äù properties. Just set them to and objects instantly render ‚Äúnaked‚Äù.\n\nYou can also change their appearance by tweaking some of the customization properties ‚ÄúcornerDashArray‚Äù, ‚ÄúborderDashArray‚Äù, ‚ÄúborderColor‚Äù, ‚ÄútransparentCorners‚Äù ‚ÄúcornerColor‚Äù, ‚ÄúcornerStrokeColor‚Äù, ‚ÄúcornerStyle‚Äù, ‚ÄúselectionBackgroundColor‚Äù, ‚Äúpadding‚Äù and ‚ÄúcornerSize‚Äù properties.\n\nYou can disable selection of objects on canvas by setting ‚Äúselection‚Äù property of canvas to . This prevents selection on absolutely everything displayed on canvas. If you only need to make certain objects unselectable, you can change ‚Äúselectable‚Äù property of objects. Just set it to and an object loses its interactivity.\n\nNow, what if you don‚Äôt want to disable selection, but instead want to change its appearance? No problem.\n\nThere are 4 properties on canvas that control its presentation ‚Äî ‚ÄúselectionColor‚Äù, ‚ÄúselectionBorderColor‚Äù, ‚ÄúselectionLineWidth‚Äù, and ‚ÄúselectionDashArray‚Äù. These should be pretty self-explanatory, so let‚Äôs take a look at an example:\n\nThe last property ‚Äî ‚ÄúselectionDashArray‚Äù ‚Äî is not as straightforward. What it allows us to do is make selection lines dashed. The way to define dash pattern is by specifying intervals via an array. So to create a pattern where there‚Äôs one long dash followed by one short dash, we could use something like as ‚ÄúselectionDashArray‚Äù. This will draw a line that‚Äôs 10px long, then skip 5px, draw 10px line again, and so on. If we were to use array, the pattern would be created by drawing 2px line, then skipping 4px, then drawing 6px line, then skipping 2px, then drawing 4px line, then skipping 6px, and so on. You get the point. As an example, this is how pattern looks:\n\nSimilarly to ‚ÄúselectionDashArray‚Äù on canvas, all Fabric objects have ‚ÄústrokeDashArray‚Äù property responsible for dashed pattern of any stroke performed on an object.\n\nAs you know, all Fabric objects have bounding box that‚Äôs used to drag an object, or rotate and scale it, when controls/corners are present. You might have noticed that object can be dragged even when clicking on the space within object‚Äôs bounding box where nothing is drawn.\n\nTake a look at this image:\n\nBy default, all Fabric objects on canvas can be dragged by the bounding box. However, if you want different behavior ‚Äî clicking/dragging objects only by its actual contents, you can use ‚ÄúperPixelTargetFind‚Äù property on an object. Just set it to to get the desired behavior.\n\nSince version 1.0 Fabric uses alternative UI by default ‚Äî objects can no longer be scaled and rotated at the same time. Instead, there‚Äôs a separate rotate control on each object. The corresponding property for that control is ‚ÄúhasRotatingPoint‚Äù. You can customize its offset relative to the object via ‚ÄúrotatingPointOffset‚Äù numeric property.\n\nThere‚Äôs a number of other transformation-related properties available in Fabric since version 1.0. One of them is ‚ÄúuniScaleTransform‚Äù on canvas instance. It‚Äôs by default, and can be used to enable non-uniform scaling of object; in other words, it allows to change object‚Äôs proportions when dragging by the corners.\n\nThen there are ‚ÄúcenteredScaling‚Äù and ‚ÄúcenteredRotation‚Äù properties (before v1.3.4 was one property - ‚ÄúcenterTransform‚Äù). They specify if a center of an object should be used as an origin of transformation. When both of them are set to , it replicates pre-1.0 behavior when objects were always scaled/rotated from the center. Since 1.0 origin of transformation is dynamic, which allows for finer control when scaling objects.\n\nThe last pair of new properties is ‚ÄúoriginX‚Äù and ‚ÄúoriginY‚Äù. Set accordingly to ‚Äúleft‚Äù and ‚Äútop‚Äù by default, they allow to change object‚Äôs origin of transformation programatically. When you drag object‚Äôs corners, it is these properties that change dynamically under the hood.\n\nSo when would we change them manually? For example, when working with text objects. When you change text dynamically, and the text box dimensions increase, ‚ÄúoriginX‚Äù and ‚ÄúoriginY‚Äù dictate where the box grows. So if you need to center text object, you would set originX to ‚Äúcenter‚Äù. To stick it to the right, you would set originX to ‚Äúright‚Äù. And so on. This behavior resembles ‚Äúposition: absolute‚Äù in CSS.\n\nAs you might remember from the 1st part, you can assign a color to fill entire canvas background. Just set any regular color value to ‚ÄúbackgroundColor‚Äù property of canvas.\n\nYou can go even further and assign an image as a background. You‚Äôll need to use method for that, passing url and an optiona completion callback.\n\nIs important to note that while the property is called it can host any fabric object type. You can set a to represent an artboard, or you can set a group of objects. Same goes for the below or for the that can host any filler, like gradients or patterns.\n\nFinally, you can also set overlay image, in which case it will always appear on top of any objects rendered on canvas. Just use , passing url and an optional completion callback.\n\nOne of the unique aspects of Fabric, is that it can work not just on a client, in a browser, but also on a server! This could be useful when you want to send data from a client and create an image of that data right on a server. Or if you simply want to use Fabric API from a console ‚Äî for speed, convenience, or other reasons.\n\nLet‚Äôs take a look at how to set up Node environment and start Fabric.\n\nFirst, you need to install Node.js, if you haven‚Äôt yet. There are few ways to install Node, depending on a platform. You can follow these instructions or these.\n\nOnce Node is installed, we need to install node-canvas library. node-canvas is a Canvas implementation for NodeJS. It relies on Cairo ‚Äî 2D graphics library which can be run on Mac, Linux, or Windows. node-canvas has dedicated installation instructions depending on your platform of choice.\n\nSince Fabric runs on top of Node, it comes as an NPM package. So the next step is to install NPM. You can find installation instructions in its github repo.\n\nThe final step is to install Fabric package, using NPM. This is done simply by running (or to install package globally).\n\nIf we run node console now, we should have both node-canvas and Fabric available for use:\n\nNow that everything is ready, we can try a simple ‚Äúhello world‚Äù test. Let‚Äôs create a helloworld.js file:\n\nand then run it as . Opening helloworld.png reveals this:\n\nSo what‚Äôs going on here? Let‚Äôs go over important parts of this code.\n\nFirst, we‚Äôre including Fabric itself ( ). Then, we create the good old Fabric canvas.\n\nAll of this simply creates Fabric canvas and renders text object onto it. Now, how to create an image of whatever is rendered on canvas? Using method available right on the canvas instance. returns Node‚Äôs stream object, and can then be output into an image file using , and writing into the stream corresponding to an image file ( ).\n\nis one of the methods specific to Node. Everything else works the same ‚Äî you can still create objects as you usually would, add them on canvas, modify, render, and so on.\n\nAs an example, let‚Äôs create a simple Node server that will listen to incoming requests with Fabric data in JSON format, and output an image of that data. The entire script is only 25 lines long!\n\nMost of the code in this snippet should be already familiar. The gist of it is inside server response. We‚Äôre creating Fabric canvas, loading JSON data onto it, rendering it, and streaming final result as server response.\n\nTo test it out, let‚Äôs take the data for a green, slightly rotated rectangle:\n\nAnd pass to a server via a ‚Äúdata‚Äù query param. The immediate response, coming back with ‚Äúimage/png‚Äù Content-type, looks like this:\n\nAs you can see, working with Fabric on a server is very easy and straightforward. Feel free to experiment with this snippet. Perhaps change canvas dimensions from within URL parameters, or modify client data before returning image as a response.\n\nBefore we can use custom fonts in Fabric we need to load them first. In the browser (client-side) the most common way to load fonts is by using the CSS3 @font-face rule. In Fabric on Node (server-side) we can utilize the node-canvas Font API, which makes loading fonts a walk in the park.\n\nThe example below demonstrates how to load and use custom fonts. Save it to customfont.js and make sure the paths to the font files are correct. In this example we use Ubuntu as our custom font.\n\nRunning the example with creates an image (customfont.png) that looks like this:\n\nLets have a closer look at what‚Äôs happening. On fabric.nodeCanvas is exposed the node-canvas library required from JSDOM to interface the node-canvas with the HTMLCanvas Api. For each font file we want to use we need to register the file with by passing the font file path and an object that specifies the font properties. Remember that this has to happen before creating the Canvas itself.\n\nNow we can use our font by setting the fontFamily property of objects to the font name. In combination with the fontWeight and fontStyle properties we are able to apply the font faces we‚Äôve added. See Part 2 (Text) for more info on these properties.\n\n Note that the example shows how to use custom fonts when creating new text objects, but this also applies to text objects loaded via JSON.\n\nAnd so this brings us to the end of the 4-part series on Fabric. I hope you‚Äôre now equiped with enough knowledge to create something interesting, cool, useful, funny, challenging, exciting!"
    }
]