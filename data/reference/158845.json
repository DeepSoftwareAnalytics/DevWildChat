[
    {
        "link": "https://docs.python.org/3/howto/sorting.html",
        "document": "Python lists have a built-in method that modifies the list in-place. There is also a built-in function that builds a new sorted list from an iterable.\n\nIn this document, we explore the various techniques for sorting data using Python.\n\nA simple ascending sort is very easy: just call the function. It returns a new sorted list: You can also use the method. It modifies the list in-place (and returns to avoid confusion). Usually it’s less convenient than - but if you don’t need the original list, it’s slightly more efficient. Another difference is that the method is only defined for lists. In contrast, the function accepts any iterable.\n\nBoth and have a key parameter to specify a function (or other callable) to be called on each list element prior to making comparisons. \"This is a test string from Andrew\" ['a', 'Andrew', 'from', 'is', 'string', 'test', 'This'] The value of the key parameter should be a function (or other callable) that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object’s indices as keys. For example: The same technique works for objects with named attributes. For example: Objects with named attributes can be made by a regular class as shown above, or they can be instances of or a named tuple.\n\nThe key function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster. The module has , , and a function. Using those functions, the above examples become simpler and faster: The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: The module provides another helpful tool for making key-functions. The function can reduce the arity of a multi-argument function making it suitable for use as a key-function.\n\nSorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. Notice how the two records for blue retain their original order so that is guaranteed to precede . This wonderful property lets you build complex sorts in a series of sorting steps. For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: This can be abstracted out into a wrapper function that can take a list and tuples of field and order to sort them on multiple passes. The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset.\n\nThis idiom is called Decorate-Sort-Undecorate after its three steps:\n• None First, the initial list is decorated with new values that control the sort order.\n• None Second, the decorated list is sorted.\n• None Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list, but including it gives two benefits:\n• None The sort is stable – if two items have the same key, their order will be preserved in the sorted list.\n• None The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. Now that Python sorting provides key-functions, this technique is not often needed.\n\nUnlike key functions that return an absolute value for sorting, a comparison function computes the relative ordering for two inputs. For example, a balance scale compares two samples giving a relative ordering: lighter, equal, or heavier. Likewise, a comparison function such as will return a negative value for less-than, zero if the inputs are equal, or a positive value for greater-than. It is common to encounter comparison functions when translating algorithms from other languages. Also, some libraries provide comparison functions as part of their API. For example, is a comparison function. To accommodate those situations, Python provides to wrap the comparison function to make it usable as a key function:\n• None For locale aware sorting, use for a key function or for a comparison function. This is necessary because “alphabetical” sort orderings can vary across cultures even if the underlying alphabet is the same.\n• None The reverse parameter still maintains sort stability (so that records with equal keys retain the original order). Interestingly, that effect can be simulated without the parameter by using the builtin function twice:\n• None The sort routines use when making comparisons between two objects. So, it is easy to add a standard sort order to a class by defining an method: However, note that can fall back to using if is not implemented (see for details on the mechanics). To avoid surprises, PEP 8 recommends that all six comparison methods be implemented. The decorator is provided to make that task easier.\n• None Key functions need not depend directly on the objects being sorted. A key function can also access external resources. For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names:"
    },
    {
        "link": "https://docs.python.org/3.10/howto/sorting.html",
        "document": "Python lists have a built-in method that modifies the list in-place. There is also a built-in function that builds a new sorted list from an iterable.\n\nIn this document, we explore the various techniques for sorting data using Python.\n\nA simple ascending sort is very easy: just call the function. It returns a new sorted list: You can also use the method. It modifies the list in-place (and returns to avoid confusion). Usually it’s less convenient than - but if you don’t need the original list, it’s slightly more efficient. Another difference is that the method is only defined for lists. In contrast, the function accepts any iterable.\n\nBoth and have a key parameter to specify a function (or other callable) to be called on each list element prior to making comparisons. \"This is a test string from Andrew\" ['a', 'Andrew', 'from', 'is', 'string', 'test', 'This'] The value of the key parameter should be a function (or other callable) that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object’s indices as keys. For example: The same technique works for objects with named attributes. For example:\n\nThe key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster. The module has , , and a function. Using those functions, the above examples become simpler and faster: The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age:\n\nSorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. Notice how the two records for blue retain their original order so that is guaranteed to precede . This wonderful property lets you build complex sorts in a series of sorting steps. For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: This can be abstracted out into a wrapper function that can take a list and tuples of field and order to sort them on multiple passes. The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset.\n\nThe Old Way Using Decorate-Sort-Undecorate¶ This idiom is called Decorate-Sort-Undecorate after its three steps:\n• None First, the initial list is decorated with new values that control the sort order.\n• None Second, the decorated list is sorted.\n• None Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list, but including it gives two benefits:\n• None The sort is stable – if two items have the same key, their order will be preserved in the sorted list.\n• None The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. Now that Python sorting provides key-functions, this technique is not often needed.\n\nThe Old Way Using the cmp Parameter¶ Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no builtin and took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the magic method). In Py2.x, sort allowed an optional function which can be called for doing the comparisons. That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than. For example, we can do: Or you can reverse the order of comparison with: When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function. The following wrapper makes that easy to do: To convert to a key function, just wrap the old comparison function: In Python 3.2, the function was added to the module in the standard library."
    },
    {
        "link": "https://geeksforgeeks.org/python-sorted-function",
        "document": "sorted() function returns a new sorted list from the elements of any iterable like (e.g., list, tuples, strings ). It creates and returns a new sorted list and leaves the original iterable unchanged.\n\nLet’s start with a basic example of sorting a list of numbers using the sorted() function.\n• iterable: The sequence to be sorted. This can be a list, tuple, set, string, or any other iterable.\n• key (Optional): A function to execute for deciding the order of elements. By default it is None\n• reverse (Optional): True , sorts in descending order. Defaults value is False\n• None Returns a new list containing all elements from the given iterable, sorted according to the provided criteria.\n\nWhen no additional parameters are provided then It arranges the element in increasing order.\n\nTo sort an iterable in descending order, set the reverse argument to True.\n\nThe key parameter is an optional argument that allows us to customize the sort order.\n\nExplanation: The key parameter is set to len, which sorts the words by their length in ascending order.\n\nExplanation: key=lambda x: x[‘score’] specifies that the sorting should be done using the ‘score’ value from each dictionary\n• None Sort Python Dictionaries By Key or Value\n• None How to Sort a Set of Values?\n• None How to Sort a Dictionary by Value?"
    },
    {
        "link": "https://realpython.com/python-sort",
        "document": "Sorting in Python is a fundamental task that you can accomplish using and . The function returns a new sorted list from the elements of any iterable, without modifying the original iterable. On the other hand, the method modifies a list in place and doesn’t return a value. Both methods support customization through optional keyword arguments like and .\n\nBy the end of this tutorial, you’ll understand that:\n• You can sort any iterable with the function.\n• The method sorts the list in place.\n• You sort items in descending order by setting the argument to .\n• The argument accepts a function to customize the sort order.\n\nIn this tutorial, you’ll learn how to sort various types of data in different data structures, customize the order, and work with two different ways of sorting in Python. You’ll need a basic understanding of lists and tuples as well as sets. These are the data structures you’ll be using to perform some basic operations.\n\nIn Python, you can sort iterables with the built-in function. To get started, you’ll work with iterables that contain only one data type. You can use to sort a list in Python. In this example, a list of integers is defined, and then is called with the variable as the argument: The output from this code is a new, sorted list. When the original variable is printed, the initial values are unchanged. This example shows four important characteristics of :\n• You don’t have to define the function. It’s a built-in function that’s available in any standard installation of Python.\n• You’re ordering the values in from smallest to largest when you call . When you pass no additional arguments or parameters, orders the values in in ascending order.\n• You don’t change the original variable because provides sorted output and doesn’t update the original value in place.\n• You get an ordered list as a return value when you call . These points mean that can be used on a list, and the output can immediately be assigned to a variable: In this example, a new variable called now stores the output of the function. You can confirm all of these observations by calling on : Help on built-in function sorted in module builtins: Return a new list containing all items from the iterable in ascending order. A custom key function can be supplied to customize the sort order, and the reverse flag can be set to request the result in descending order. You’ll cover the optional arguments and later in the tutorial. The first parameter of is an iterable. That means that you can use on tuples and sets very similarly: Notice how even though the input was a set and a tuple, the output is a list because returns a new list by definition. The returned object can be cast to a new type if it needs to match the input type. Be careful if attempting to cast the resulting list back to a set, as a set by definition is unordered: When you cast the value to a , it’s unordered, as expected. If you’re curious about how sets work in Python, then you can check out the tutorial Sets in Python. Just like lists, tuples, and sets, strings are also iterables. This means you can sort types as well. The example below shows how iterates through each character in the value passed to it and orders them in the output: Just like before, you can use to iterate through each element of the iterable you pass in. In a string, each element means each character, including spaces. Note: Python sorts strings lexicographically by comparing Unicode code points of the individual characters from left to right. That’s why the uppercase appears before the lowercase . To learn more about some of Python’s quirks when ordering strings, check out the tutorial How to Sort Unicode Strings Alphabetically in Python. If you want to sort a sentence by words, then you can use Python’s method: In this example, you use to convert the original sentence into a list of words. Afterward, you sort the list instead of individual characters.\n\nWhen sorting objects in Python, you may run into some unexpected behavior or even errors. In this section, you’ll explore some limitations and gotchas to look out for when using Python’s function. There are data types that can’t be compared to each other using because they’re too different. Python will return an error if you attempt to use on a list containing non-comparable data. In the example below, you have and the integer zero ( ) in the same list. Python doesn’t know how to sort these two types because of their incompatibility: : '<' not supported between instances of 'int' and 'NoneType' This error shows why Python can’t sort the values given to it. It’s trying to put the values in order by using the less than operator ( ) to determine which value is lower in sorting order. You can replicate this error by manually comparing the two values: : '<' not supported between instances of 'NoneType' and 'int' The same is thrown when you try to compare two non-comparable values without using . If the values in the list can be compared without raising a , then the list can be sorted. This prevents sorting iterables with intrinsically unorderable values and producing output that may not make sense. Python can implicitly convert a value to another type. Even though elements in a list look different, Python may able to interpret them as integers and compare them to each other using : Python interprets the Boolean as and as . You can verify that Python considers the integers and equal to and by comparing them manually: If you have a look at the ordered list from before, you can spot another important aspect of sorting called sort stability. In Python, when you sort equal values, they’ll retain their original order in the output. Since the integer comes before in the unsorted list, will appear before in the sorted list. In the example above, you were sorting either single characters or different words. When dealing with a list that contains similar strings, Python sorts shorter strings first: Strings that contain identical values will end up being sorted shortest to longest because the shorter strings lack elements to compare against the longer ones. This doesn’t mean that shorter strings always come first: If the first letter is the same, then will use the second character to determine order, and so on. In the example above, is shorter than . But while traversing through the string to determine how to sort compared to , the second letter of is considered larger than the second letter of . That’s because the letter has a larger Unicode than the letter . You can leverage Python’s function to investigate a character’s Unicode: To learn more about some of Python’s quirks when ordering strings, check out the tutorial How to Sort Unicode Strings Alphabetically in Python.\n\nWhen using Python’s function, you can optionally pass in values for the keywords and . This enables you to override the default behavior of and customize the order of the output. As the name suggests, the keyword argument let’s you reverse the order of an iterable. The keyword accepts a Boolean value: The default value of is , which results in the ascending order of items. If you set to , then the sorting will be in descending order. One of the most powerful components of is the keyword argument called . This argument expects a function to be passed to it, and that function will be used on each value in the list being sorted to determine the resulting order. To demonstrate a basic example, let’s assume the requirement for ordering a specific list is the length of the strings in the list, from shortest to longest. You can use the function to return the length of a string, along with the argument: The resulting order is a list with a string order of shortest to longest. The length of each element in the list is determined by and then returned in ascending order. By default, sorting in Python is case sensitive. This means that words starting with an uppercase Z will be sorted before those beginning with lowercase letters because of their Unicode values: You can pass in as the value of to sort strings independently of a character’s case: During sorting, the function passed to is called on each element to determine sort order, but the original values remain in the output. Avoiding Pitfalls When Using With a Argument There are two main limitations to look out for when you’re using functions with the argument. First, the number of required arguments in the function passed to must be exactly one: The example above shows the definition of an addition function that takes two arguments. When that function is used in on a list of numbers, it fails because it’s missing a second argument. Each time is called during the sort, it’s only receiving one element from the list at a time. The second limitation of is that the function used with must be able to handle all the values in the iterable. Here, you have a list of numbers represented as strings to be used in , and is going to attempt to convert them to numbers using : However, if a value in the iterable can’t be cast to an integer, then using as the value for will fail: As long as a string contains a numeric value, Python can convert the string to an integer. Since isn’t a numeric value, you receive a when calling with . The functionality is extremely powerful because it allows you to manipulate the output order using almost any function, whether built-in or user-defined. If the ordering requirement is to order an iterable by each string spelled backwards, then you could define a function that reverses a word. In the example below, you define a function named that reverses the string passed to it. Then, you use as the value of when calling : The slice syntax reverses a string. Each element will have applied to it, and the sorting order will be based on the characters in the reversed version of each word. If two words have the same final letter, the next letter is compared, and so on. As a result, the elements in are sorted based on their ending letters, which is why comes before but after . Instead of writing a standalone function, you can shorten the code and leverage the keyword. With , you can create an anonymous function, commonly refered to as a function. By using , you can define a function inline and use it directly as the value of . Instead of defining and calling , you can accomplish the same result with fewer lines of code: In the example above, the is defined as a . The function takes one argument named . Then, is called on each element and reverses the word. That reversed output is then used for sorting, but the original words are still returned.\n\nSo far, you’ve learned about Python’s function. However, you may have come across a method with a similar name—the method: Sort the list in ascending order and return None. The sort is in-place (i.e. the list itself is modified) and stable (i.e. the order of two equal elements is maintained). If a key function is given, apply it once to each list item and sort them, ascending or descending, according to their function values. The reverse flag can be set to sort in descending order. At first glance, the description of looks similar to the output of , which you explored earlier. Before taking a look at the similarities between and , it’s important to first understand their differences. Understanding the Differences Between and The method accomplishes more or less the same thing as the function. But there are four critical differences between and :\n• is a method of the class.\n• can only be used with lists.\n• modifies the order of elements in place. As a method, works with the list instance itself. In other words, you don’t explicitly pass in an iterable as an argument. Have a look at the impacts of these differences in code: When you try calling with a tuple, you get an because only exists for lists. Then, there are some other pretty dramatic differences in how operates compared to in this code example:\n• returns , so the assignment to is and not an ordered list.\n• Calling changes the list in place, and the original order is not maintained in any way. These differences in behavior make and absolutely not interchangeable in code, and they can produce wildly unexpected outcomes if one is used in the wrong way. Using Keywords Arguments With and The method has the same and optional keyword arguments that produce the same robust functionality as . Revisit some examples from before, this time using instead of : Just like when you used , if you set to when calling on a list, then the sorting will be in descending order. When you pass in as the value of , you can sort strings independently of a character’s case: During sorting, the function passed to is being called on each element to determine the sort order. If you want to practice using , then try refactoring the examples from earlier sections with . When doing so, keep in mind that only works with lists.\n\nDeciding When to Use vs If you’re sorting an iterable that isn’t a list, then you must use . But if you’re working with a list, then you can use either or . Generally, if you keep the similarities and differences in mind, then you can use either or . However, there can be situations where it’s important to choose the right tool for the task at hand. Let’s say there’s a 5K race coming up and you need to capture and sort the race data. The data that needs to be captured is the runner’s bib number and the number of seconds it took to finish the race. To keep things tidy, you decide to use a named tuple for convenient access: As the runners cross the finish line, each will be added to a list called . In 5K races, not all runners start at the same time, so the first person to cross the finish line might not actually be the fastest person: # Thousands and Thousands of entries later... Each time a runner crosses the finish line, you add their bib number and total duration in seconds to the list. The top five fastest participants are the winners that get prizes, and the remaining runners will be sorted by fastest time. There are no requirements for multiple types of sorting by various attributes. The list is a reasonable size, and there’s no mention of storing the list somewhere. In other words, you need to sort by and grab the five participants with the lowest duration: You use a in the argument to get the attribute from each runner and sort in place using . After is sorted, you store the first five elements in . Mission accomplished—or so you think! The race director now informs you that every forty-second runner to cross the finish line will receive a free gym bag. That’s a problem! By using , you changed irreversibly. There’s no way to recover the original list of runners in the order they finished and find every forty-second person. In hindsight, you should’ve sorted the runners with and used the same : By using , you can keep the original list of runners intact without overwriting it. This means that you can now find every forty-second person that crosses the finish line: You create the list by leveraging the slice syntax on , which still contains the original order of runners who cross the finish line. If you’re working with important data and there’s even a remote possibility that you might need to recover the original order, then using is not the best option. However, if the data is a copy, unimportant information, or data that can be easily re-created, then can be a fine option."
    },
    {
        "link": "https://w3schools.com/python/ref_func_sorted.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://docs.python.org/3/howto/sorting.html",
        "document": "Python lists have a built-in method that modifies the list in-place. There is also a built-in function that builds a new sorted list from an iterable.\n\nIn this document, we explore the various techniques for sorting data using Python.\n\nA simple ascending sort is very easy: just call the function. It returns a new sorted list: You can also use the method. It modifies the list in-place (and returns to avoid confusion). Usually it’s less convenient than - but if you don’t need the original list, it’s slightly more efficient. Another difference is that the method is only defined for lists. In contrast, the function accepts any iterable.\n\nBoth and have a key parameter to specify a function (or other callable) to be called on each list element prior to making comparisons. \"This is a test string from Andrew\" ['a', 'Andrew', 'from', 'is', 'string', 'test', 'This'] The value of the key parameter should be a function (or other callable) that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object’s indices as keys. For example: The same technique works for objects with named attributes. For example: Objects with named attributes can be made by a regular class as shown above, or they can be instances of or a named tuple.\n\nThe key function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster. The module has , , and a function. Using those functions, the above examples become simpler and faster: The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: The module provides another helpful tool for making key-functions. The function can reduce the arity of a multi-argument function making it suitable for use as a key-function.\n\nSorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. Notice how the two records for blue retain their original order so that is guaranteed to precede . This wonderful property lets you build complex sorts in a series of sorting steps. For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: This can be abstracted out into a wrapper function that can take a list and tuples of field and order to sort them on multiple passes. The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset.\n\nThis idiom is called Decorate-Sort-Undecorate after its three steps:\n• None First, the initial list is decorated with new values that control the sort order.\n• None Second, the decorated list is sorted.\n• None Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list, but including it gives two benefits:\n• None The sort is stable – if two items have the same key, their order will be preserved in the sorted list.\n• None The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. Now that Python sorting provides key-functions, this technique is not often needed.\n\nUnlike key functions that return an absolute value for sorting, a comparison function computes the relative ordering for two inputs. For example, a balance scale compares two samples giving a relative ordering: lighter, equal, or heavier. Likewise, a comparison function such as will return a negative value for less-than, zero if the inputs are equal, or a positive value for greater-than. It is common to encounter comparison functions when translating algorithms from other languages. Also, some libraries provide comparison functions as part of their API. For example, is a comparison function. To accommodate those situations, Python provides to wrap the comparison function to make it usable as a key function:\n• None For locale aware sorting, use for a key function or for a comparison function. This is necessary because “alphabetical” sort orderings can vary across cultures even if the underlying alphabet is the same.\n• None The reverse parameter still maintains sort stability (so that records with equal keys retain the original order). Interestingly, that effect can be simulated without the parameter by using the builtin function twice:\n• None The sort routines use when making comparisons between two objects. So, it is easy to add a standard sort order to a class by defining an method: However, note that can fall back to using if is not implemented (see for details on the mechanics). To avoid surprises, PEP 8 recommends that all six comparison methods be implemented. The decorator is provided to make that task easier.\n• None Key functions need not depend directly on the objects being sorted. A key function can also access external resources. For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names:"
    },
    {
        "link": "https://geeksforgeeks.org/python-list-sort-method",
        "document": "The sort() method in Python is a built-in function that allows us to sort the elements of a list in ascending or descending order and it modifies the list in place which means there is no new list created. This method is useful when working with lists where we need to arranged the elements in a specific order, whether numerically or alphabetically.\n\nBelow is a simple example that use sort() method to arrange a list of integer values in ascending order.\n• key (Optional): This is an optional parameter that allows we to specify a function to be used for sorting. For example, we can use the len() function to sort a list of strings based on their length.\n• reverse (Optional): This is an optional Boolean parameter. By default, it is set to False to sort in ascending order. If we set reverse=True , the list will be sorted in descending order.\n\nTo sort a list in descending order, we need to set the reverse parameter to True.\n\nWe can sort a list using a custom key by defining a function that specifies the sorting rule. For example, if we have a list of strings and want to sort them by length then we can use key=len. This will arrange the words from shortest to longest.\n\nWe can also define our custom sorting function to control the sorting behavior. In the the below example, we are sorting a list of tuples by the second element (those tuple whose second value are smaller would come first).\n\nWe can also use a lambda function as a key to define more complex sorting rules. For example, sorting a list of strings based on the last character:\n\nExplanation: Here, we used to sort the strings based on their last character. The result is , ordered by the last letter of each word.\n\nBy default, the method is case sensitive, resulting in all capital letters being sorted before lowercase letters. To perform a case insensitive sort, we can use the function as the key.\n\nExplanation: In this example, we used to make sure that the sorting is case insensitive. This means that all words are treated as lowercase during sorting.\n• sort() method modifies the list in place and returns None\n• key parameter can be used for customizing the sorting logic.\n• None We can use method, if we need to create a new sorted list without altering the original."
    },
    {
        "link": "https://realpython.com/python-sort",
        "document": "Sorting in Python is a fundamental task that you can accomplish using and . The function returns a new sorted list from the elements of any iterable, without modifying the original iterable. On the other hand, the method modifies a list in place and doesn’t return a value. Both methods support customization through optional keyword arguments like and .\n\nBy the end of this tutorial, you’ll understand that:\n• You can sort any iterable with the function.\n• The method sorts the list in place.\n• You sort items in descending order by setting the argument to .\n• The argument accepts a function to customize the sort order.\n\nIn this tutorial, you’ll learn how to sort various types of data in different data structures, customize the order, and work with two different ways of sorting in Python. You’ll need a basic understanding of lists and tuples as well as sets. These are the data structures you’ll be using to perform some basic operations.\n\nIn Python, you can sort iterables with the built-in function. To get started, you’ll work with iterables that contain only one data type. You can use to sort a list in Python. In this example, a list of integers is defined, and then is called with the variable as the argument: The output from this code is a new, sorted list. When the original variable is printed, the initial values are unchanged. This example shows four important characteristics of :\n• You don’t have to define the function. It’s a built-in function that’s available in any standard installation of Python.\n• You’re ordering the values in from smallest to largest when you call . When you pass no additional arguments or parameters, orders the values in in ascending order.\n• You don’t change the original variable because provides sorted output and doesn’t update the original value in place.\n• You get an ordered list as a return value when you call . These points mean that can be used on a list, and the output can immediately be assigned to a variable: In this example, a new variable called now stores the output of the function. You can confirm all of these observations by calling on : Help on built-in function sorted in module builtins: Return a new list containing all items from the iterable in ascending order. A custom key function can be supplied to customize the sort order, and the reverse flag can be set to request the result in descending order. You’ll cover the optional arguments and later in the tutorial. The first parameter of is an iterable. That means that you can use on tuples and sets very similarly: Notice how even though the input was a set and a tuple, the output is a list because returns a new list by definition. The returned object can be cast to a new type if it needs to match the input type. Be careful if attempting to cast the resulting list back to a set, as a set by definition is unordered: When you cast the value to a , it’s unordered, as expected. If you’re curious about how sets work in Python, then you can check out the tutorial Sets in Python. Just like lists, tuples, and sets, strings are also iterables. This means you can sort types as well. The example below shows how iterates through each character in the value passed to it and orders them in the output: Just like before, you can use to iterate through each element of the iterable you pass in. In a string, each element means each character, including spaces. Note: Python sorts strings lexicographically by comparing Unicode code points of the individual characters from left to right. That’s why the uppercase appears before the lowercase . To learn more about some of Python’s quirks when ordering strings, check out the tutorial How to Sort Unicode Strings Alphabetically in Python. If you want to sort a sentence by words, then you can use Python’s method: In this example, you use to convert the original sentence into a list of words. Afterward, you sort the list instead of individual characters.\n\nWhen sorting objects in Python, you may run into some unexpected behavior or even errors. In this section, you’ll explore some limitations and gotchas to look out for when using Python’s function. There are data types that can’t be compared to each other using because they’re too different. Python will return an error if you attempt to use on a list containing non-comparable data. In the example below, you have and the integer zero ( ) in the same list. Python doesn’t know how to sort these two types because of their incompatibility: : '<' not supported between instances of 'int' and 'NoneType' This error shows why Python can’t sort the values given to it. It’s trying to put the values in order by using the less than operator ( ) to determine which value is lower in sorting order. You can replicate this error by manually comparing the two values: : '<' not supported between instances of 'NoneType' and 'int' The same is thrown when you try to compare two non-comparable values without using . If the values in the list can be compared without raising a , then the list can be sorted. This prevents sorting iterables with intrinsically unorderable values and producing output that may not make sense. Python can implicitly convert a value to another type. Even though elements in a list look different, Python may able to interpret them as integers and compare them to each other using : Python interprets the Boolean as and as . You can verify that Python considers the integers and equal to and by comparing them manually: If you have a look at the ordered list from before, you can spot another important aspect of sorting called sort stability. In Python, when you sort equal values, they’ll retain their original order in the output. Since the integer comes before in the unsorted list, will appear before in the sorted list. In the example above, you were sorting either single characters or different words. When dealing with a list that contains similar strings, Python sorts shorter strings first: Strings that contain identical values will end up being sorted shortest to longest because the shorter strings lack elements to compare against the longer ones. This doesn’t mean that shorter strings always come first: If the first letter is the same, then will use the second character to determine order, and so on. In the example above, is shorter than . But while traversing through the string to determine how to sort compared to , the second letter of is considered larger than the second letter of . That’s because the letter has a larger Unicode than the letter . You can leverage Python’s function to investigate a character’s Unicode: To learn more about some of Python’s quirks when ordering strings, check out the tutorial How to Sort Unicode Strings Alphabetically in Python.\n\nWhen using Python’s function, you can optionally pass in values for the keywords and . This enables you to override the default behavior of and customize the order of the output. As the name suggests, the keyword argument let’s you reverse the order of an iterable. The keyword accepts a Boolean value: The default value of is , which results in the ascending order of items. If you set to , then the sorting will be in descending order. One of the most powerful components of is the keyword argument called . This argument expects a function to be passed to it, and that function will be used on each value in the list being sorted to determine the resulting order. To demonstrate a basic example, let’s assume the requirement for ordering a specific list is the length of the strings in the list, from shortest to longest. You can use the function to return the length of a string, along with the argument: The resulting order is a list with a string order of shortest to longest. The length of each element in the list is determined by and then returned in ascending order. By default, sorting in Python is case sensitive. This means that words starting with an uppercase Z will be sorted before those beginning with lowercase letters because of their Unicode values: You can pass in as the value of to sort strings independently of a character’s case: During sorting, the function passed to is called on each element to determine sort order, but the original values remain in the output. Avoiding Pitfalls When Using With a Argument There are two main limitations to look out for when you’re using functions with the argument. First, the number of required arguments in the function passed to must be exactly one: The example above shows the definition of an addition function that takes two arguments. When that function is used in on a list of numbers, it fails because it’s missing a second argument. Each time is called during the sort, it’s only receiving one element from the list at a time. The second limitation of is that the function used with must be able to handle all the values in the iterable. Here, you have a list of numbers represented as strings to be used in , and is going to attempt to convert them to numbers using : However, if a value in the iterable can’t be cast to an integer, then using as the value for will fail: As long as a string contains a numeric value, Python can convert the string to an integer. Since isn’t a numeric value, you receive a when calling with . The functionality is extremely powerful because it allows you to manipulate the output order using almost any function, whether built-in or user-defined. If the ordering requirement is to order an iterable by each string spelled backwards, then you could define a function that reverses a word. In the example below, you define a function named that reverses the string passed to it. Then, you use as the value of when calling : The slice syntax reverses a string. Each element will have applied to it, and the sorting order will be based on the characters in the reversed version of each word. If two words have the same final letter, the next letter is compared, and so on. As a result, the elements in are sorted based on their ending letters, which is why comes before but after . Instead of writing a standalone function, you can shorten the code and leverage the keyword. With , you can create an anonymous function, commonly refered to as a function. By using , you can define a function inline and use it directly as the value of . Instead of defining and calling , you can accomplish the same result with fewer lines of code: In the example above, the is defined as a . The function takes one argument named . Then, is called on each element and reverses the word. That reversed output is then used for sorting, but the original words are still returned.\n\nSo far, you’ve learned about Python’s function. However, you may have come across a method with a similar name—the method: Sort the list in ascending order and return None. The sort is in-place (i.e. the list itself is modified) and stable (i.e. the order of two equal elements is maintained). If a key function is given, apply it once to each list item and sort them, ascending or descending, according to their function values. The reverse flag can be set to sort in descending order. At first glance, the description of looks similar to the output of , which you explored earlier. Before taking a look at the similarities between and , it’s important to first understand their differences. Understanding the Differences Between and The method accomplishes more or less the same thing as the function. But there are four critical differences between and :\n• is a method of the class.\n• can only be used with lists.\n• modifies the order of elements in place. As a method, works with the list instance itself. In other words, you don’t explicitly pass in an iterable as an argument. Have a look at the impacts of these differences in code: When you try calling with a tuple, you get an because only exists for lists. Then, there are some other pretty dramatic differences in how operates compared to in this code example:\n• returns , so the assignment to is and not an ordered list.\n• Calling changes the list in place, and the original order is not maintained in any way. These differences in behavior make and absolutely not interchangeable in code, and they can produce wildly unexpected outcomes if one is used in the wrong way. Using Keywords Arguments With and The method has the same and optional keyword arguments that produce the same robust functionality as . Revisit some examples from before, this time using instead of : Just like when you used , if you set to when calling on a list, then the sorting will be in descending order. When you pass in as the value of , you can sort strings independently of a character’s case: During sorting, the function passed to is being called on each element to determine the sort order. If you want to practice using , then try refactoring the examples from earlier sections with . When doing so, keep in mind that only works with lists.\n\nDeciding When to Use vs If you’re sorting an iterable that isn’t a list, then you must use . But if you’re working with a list, then you can use either or . Generally, if you keep the similarities and differences in mind, then you can use either or . However, there can be situations where it’s important to choose the right tool for the task at hand. Let’s say there’s a 5K race coming up and you need to capture and sort the race data. The data that needs to be captured is the runner’s bib number and the number of seconds it took to finish the race. To keep things tidy, you decide to use a named tuple for convenient access: As the runners cross the finish line, each will be added to a list called . In 5K races, not all runners start at the same time, so the first person to cross the finish line might not actually be the fastest person: # Thousands and Thousands of entries later... Each time a runner crosses the finish line, you add their bib number and total duration in seconds to the list. The top five fastest participants are the winners that get prizes, and the remaining runners will be sorted by fastest time. There are no requirements for multiple types of sorting by various attributes. The list is a reasonable size, and there’s no mention of storing the list somewhere. In other words, you need to sort by and grab the five participants with the lowest duration: You use a in the argument to get the attribute from each runner and sort in place using . After is sorted, you store the first five elements in . Mission accomplished—or so you think! The race director now informs you that every forty-second runner to cross the finish line will receive a free gym bag. That’s a problem! By using , you changed irreversibly. There’s no way to recover the original list of runners in the order they finished and find every forty-second person. In hindsight, you should’ve sorted the runners with and used the same : By using , you can keep the original list of runners intact without overwriting it. This means that you can now find every forty-second person that crosses the finish line: You create the list by leveraging the slice syntax on , which still contains the original order of runners who cross the finish line. If you’re working with important data and there’s even a remote possibility that you might need to recover the original order, then using is not the best option. However, if the data is a copy, unimportant information, or data that can be easily re-created, then can be a fine option."
    },
    {
        "link": "https://stackoverflow.com/questions/7719523/inheriting-a-list-to-use-its-in-place-sort-method",
        "document": "You misunderstand what inheriting from does.\n\nYour isn't just getting the interface it is a list (which is an in-memory structure like an array of Python objects that can't be directly expressed in Python). You then add a bunch of additional instance members, and override some methods to talk to your members instead of the normal instance data (because you never actually call the base class implementations). Note that still has the instance data inherited from , but as far as the data is concerned it remains an empty list with a bunch of attributes tacked on.\n\nIt happens that a lot of the operations on builtin types are implemented in C and just use the C-level data directly rather than going through the Python level hooks (like ). So while this sort of inheritance-to-get-the-interface can work for Python level classes (although it's a hack really), it usually doesn't for builtin types. It's certainly not what you're \"supposed\" to do with subclassing builting types; it's more expected that you make a that works slightly differently (you can add defaults, extra methods, meta-data, etc) than that you make a completely different thing that shares an interface. For that, see the ABCs in the module.\n\nI don't see how you can use 's builtin sort without actually having a . Memory mapped files are supposed to be faster than doing tons of little OS-level calls, but to sort you're essentially reading in and rewriting the entirety of all the files anyway, so I can't see how you'd get it to go faster than doing just that; read in all the files into memory, sort them, and then write out the results to the files.\n\nYour trick of using mmaps to do an inplace sort files containing fixed-size chunks of data is quite clever, but you'd really have to be using C all the way to actually get it to work and be fast. Python doesn't have an operation for an inplace file sort (it's a pretty obscure operation, since it's impossible unless you assume the data chunks are some fixed-size), you can't get 's sort to do it for you, and implementing such a sort yourself in Python is bound to be slower than a good C implementation. That said, it should be an IO bound operation, not compute bound, so are you sure it's actually possible to do the job much faster than your bubble sort?"
    },
    {
        "link": "https://stackoverflow.com/questions/1436962/python-sort-method-on-list-vs-builtin-sorted-function",
        "document": "I know that sorted() function works on any iterable. But can someone explain this huge (10x) performance difference between anylist.sort() vs sorted(anylist) ? Also, please point out if I am doing anything wrong with way this is measured.\n\nAs the title says, I was interested in comparing list.sort() vs sorted(list). The above snippet showed something interesting that, python's sort function behaves very well for already sorted data. As pointed out by Anurag, in the first case, the sort method is working on already sorted data and while in second sorted it is working on fresh piece to do work again and again.\n\nSo I wrote this one to test and yes, they are very close.\n\nOh, I see Alex Martelli with a response, as I was typing this one.. ( I shall leave the edit, as it might be useful)."
    }
]