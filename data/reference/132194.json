[
    {
        "link": "https://threejs.org/docs",
        "document": ""
    },
    {
        "link": "https://threejs.org/docs/manual/en/introduction/Creating-a-scene.html",
        "document": "The goal of this section is to give a brief introduction to three.js. We will start by setting up a scene, with a spinning cube. A working example is provided at the bottom of the page in case you get stuck and need help.\n\nIf you haven't yet, go through the [link:#manual/introduction/Installation Installation] guide. We'll assume you've already set up the same project structure (including index.html and main.js), have installed three.js, and are either running a build tool, or using a local server with a CDN and import maps.\n\nTo actually be able to display anything with three.js, we need three things: scene, camera and renderer, so that we can render the scene with camera.\n\nLet's take a moment to explain what's going on here. We have now set up the scene, our camera and the renderer.\n\nThere are a few different cameras in three.js. For now, let's use a `PerspectiveCamera`.\n\nThe first attribute is the `field of view`. FOV is the extent of the scene that is seen on the display at any given moment. The value is in degrees.\n\nThe second one is the `aspect ratio`. You almost always want to use the width of the element divided by the height, or you'll get the same result as when you play old movies on a widescreen TV - the image looks squished.\n\nThe next two attributes are the `near` and `far` clipping plane. What that means, is that objects further away from the camera than the value of `far` or closer than `near` won't be rendered. You don't have to worry about this now, but you may want to use other values in your apps to get better performance.\n\nNext up is the renderer. In addition to creating the renderer instance, we also need to set the size at which we want it to render our app. It's a good idea to use the width and height of the area we want to fill with our app - in this case, the width and height of the browser window. For performance intensive apps, you can also give `setSize` smaller values, like `window.innerWidth/2` and `window.innerHeight/2`, which will make the app render at quarter size.\n\nIf you wish to keep the size of your app but render it at a lower resolution, you can do so by calling `setSize` with false as `updateStyle` (the third argument). For example, `setSize(window.innerWidth/2, window.innerHeight/2, false)` will render your app at half resolution, given that your <canvas> has 100% width and height.\n\nLast but not least, we add the `renderer` element to our HTML document. This is a <canvas> element the renderer uses to display the scene to us.\n\n\"That's all good, but where's that cube you promised?\" Let's add it now.\n\nTo create a cube, we need a `BoxGeometry`. This is an object that contains all the points (`vertices`) and fill (`faces`) of the cube. We'll explore this more in the future.\n\nIn addition to the geometry, we need a material to color it. Three.js comes with several materials, but we'll stick to the `MeshBasicMaterial` for now. All materials take an object of properties which will be applied to them. To keep things very simple, we only supply a color attribute of `0x00ff00`, which is green. This works the same way that colors work in CSS or Photoshop (`hex colors`).\n\nThe third thing we need is a `Mesh`. A mesh is an object that takes a geometry, and applies a material to it, which we then can insert to our scene, and move freely around.\n\nBy default, when we call `scene.add()`, the thing we add will be added to the coordinates `(0,0,0)`. This would cause both the camera and the cube to be inside each other. To avoid this, we simply move the camera out a bit.\n\nIf you copied the code from above into the main.js file we created earlier, you wouldn't be able to see anything. This is because we're not actually rendering anything yet. For that, we need what's called a render or animation loop.\n\nThis will create a loop that causes the renderer to draw the scene every time the screen is refreshed (on a typical screen this means 60 times per second). If you're new to writing games in the browser, you might say \"why don't we just create a setInterval ?\" The thing is - we could, but `requestAnimationFrame` which is internally used in `WebGLRenderer` has a number of advantages. Perhaps the most important one is that it pauses when the user navigates to another browser tab, hence not wasting their precious processing power and battery life.\n\nIf you insert all the code above into the file you created before we began, you should see a green box. Let's make it all a little more interesting by rotating it.\n\nAdd the following code right above the `renderer.render` call in your `animate` function:\n\nThis will be run every frame (normally 60 times per second), and give the cube a nice rotation animation. Basically, anything you want to move or change while the app is running has to go through the animation loop. You can of course call other functions from there, so that you don't end up with an `animate` function that's hundreds of lines.\n\nCongratulations! You have now completed your first three.js application. It's simple, but you have to start somewhere.\n\nThe full code is available below and as an editable [link:https://jsfiddle.net/tswh48fL/ live example]. Play around with it to get a better understanding of how it works."
    },
    {
        "link": "https://threejs.org/docs/index.html",
        "document": ""
    },
    {
        "link": "https://medium.com/@nex3dstudio/getting-started-with-three-js-your-first-3d-scene-8aac4051e4a0",
        "document": "If you’ve ever wanted to add 3D graphics to your website or web application, Three.js is a great choice. It’s a JavaScript library that simplifies the creation of 3D objects, animations, and interactions. Three.js abstracts away the complex calculations needed to display 3D graphics, making it beginner-friendly and accessible even if you’re new to 3D programming. In this tutorial, we’ll walk through setting up your first 3D scene using Three.js, so you can start exploring the basics of creating and rendering 3D objects.\n\nBefore we dive in, let’s make sure we have a basic setup ready for creating our Three.js scene.\n\nIf you’re using a package manager like npm, you can install Three.js by running:\n\nAlternatively, you can use a CDN link directly in your HTML file:"
    },
    {
        "link": "https://codecademy.com/article/build-a-3d-environment-with-three-js",
        "document": "Step-by-step tutorial about how to build a 3D environment with Three.js and render/move 3D objects.\n\nWith some terms out of the way, let’s begin building a 3D environment.\n\nCameras use methods that utilize parameters named after terms in camera projection. The following terms define the observable “shape” (or frustum ) of the camera:\n\nScenes and their child elements make up the scenegraph, a tree-like representation of the parent/child-relationship between objects in the scene. Scenegraphs can also contain zero or more cameras.\n\nThe renderer object is the root of a Three.js program and carries two parameters:\n\nIt should be noted that the Three.js API uses a considerable amount of stage and camera projection terms to name classes, functions and parameters.\n\nIn this article, we are going to learn how to build a 3D environment with Three.js. Inside of this environment, we will render a cube that rotates at a modest speed. Below is what our completed environment will look like:\n\nSince its release in 2010, Three.js has been used by many developers and companies alike. Below is the GitHub homepage , which uses Three.js to render a globe. It rotates and emits interesting connections between different points. We can even change it’s rotation with our mouse!\n\nThree.js is a JavaScript library that features 3D objects and views rendered on a web page. It builds on top of WebGL by adding functionality for visual aesthetics including:\n\nStart at the beginning by learning HTML basics — an important foundation for building and editing web pages. Try it for free\n\nWe’ll begin by opening the [terminal], creating a directory called /helloCube, and changing into it.\n\nNext, we will create the following files:\n\nThen, let’s install Three.js. There are two primary options for installing Three.js in a project:\n• We could install it with [npm] and import as a Node module with or .\n• We could use elements to import the package source code via a [CDN link].\n\nFor this article, we are going to use a CDN link to install Three.js. Let’s head to the next step to add markup.\n\nStep 2: Adding the HTML and connecting to our JS\n\nLet’s begin this step by opening helloCube.html and add the following markup:\n\nOur 3D environment will eventually render a element to the body. By default, most HTML elements are displayed at the “block”-level where they begin on a new line and take up as much width as possible. We should add some styles to the page so that the body is as tall as the screen being used and the canvas is horizontally and vertically centered. Next, we’ll add a pair of tags to the element and do the following:\n• Set the and of and to 0.\n• Set the of the to to ensure the canvas is centered.\n• Set the of the to .\n\nLet’s go ahead and save the file. Next, we will render the page on a browser with the following command:\n\nWhen our page loads, it should look like this:\n\nLastly, in preparation for the next step, we’re going to connect our HTML to the Three.js library as well as our own helloCube.js file. Let’s add two pairs of tags inside the element. One of the scripts will import Three.js via CDN with the following url: . In order to ensure that our Three.js connection can access elements in the after the DOM loads, lets add a attribute to both tags.\n\nThe other will link the helloCube.html file with the helloCube.js file:\n\nOur markup is now connected with Three.js and with our local helloCube.js file.\n\nLet’s save and close the helloCube.html file. Next, we’ll proceed to build the actual 3D Three.js environment!\n\nFor the remaining steps, we will finish building our 3D environment in the helloCube.js file. Let’s open the file and define a function called . Then, we will execute it directly afterwards.\n\nWhen the helloCube.html loads at the tag linking to the helloCube.js file, the method will be invoked. To access functions and class constructors from Three.js, we’re going to use the constant. We are going to create our root object — the — with the function:\n\nBy passing nothing into , the will create a new element when in use. This is effectively our 3D environment! Although our 3D environment is technically now created, we still would like a in helloCube.html to communicate with the . There is more to the 3D environment than building the renderer.\n\nLet’s move on to the next step where we will set up a object.\n\nIn order to “see” the objects we render in our environment, we need to create a object. We will be using a perspective projection by creating a and passing in the following values:\n• A (integer) to set the range for what the camera can observe in the environment.\n• An ratio (integer) of the camera’s height and width.\n• A space range that describes how and objects can be viewed by the camera (both integers).\n\nWe’ve got a new going! Let’s move on to the next step to build a scene for our camera to see into.\n\nThe canvas inside the constant is where a object is set. Scenes are areas where 3D objects and effects, such as light effects, are stored. These objects are composed of geometric and material properties meshed together into one cohesive, 3-dimensional “shape”, like a cube or a sphere.\n\nLet’s first create our with the method:\n\nWe are now ready to add some 3D objects to our scene! The core pieces of a 3D object are:\n• A geometry that defines the size and dimensions of the object.\n• A material that defines the overall appearance of the object.\n\nLet’s begin building the geometry for our cube.\n\nThe first thing to do is define a by passing in a , , and . We’ll store it in a variable.\n\nNext, we’ll need to create a for the cube’s appearance. We can create it by using the method and passing in an object with a property and a value.\n\nLastly, we will create the actual object. Let’s combine the with the by using the method. Then, we’ll use to add the to the :\n\nLet’s go ahead and save the helloCube.js file. It’s now time to see what our rendered cube finally looks like in the next step!\n\nLet’s take a step back and look at what we’ve done so far with our 3D environment:\n• We created a that contains 3D objects and effects.\n• We created a that “views” the 3D objects and effects.\n\nNext, we will use the ’s method to create a 3D environment. We will pass in the and objects we built in the previous steps. They will be rendered through the returned element.\n\nWe can then append the of the to the DOM:\n\nAnd our rendered page should look like this:\n\nWait?! That looks more like a square than a cube! Let’s find out for sure by trying to move it in the final step.\n\nIn this last step, we are going to write an method that will move the cube in the 3D environment that just build in the previous step:\n\nSome of the code shown above is new and some is refactored. Here is a breakdown of what we just did:\n• First, we defined an method that accepts two integers, a and a , which is defined with 1.\n• Next, we converted the into seconds.\n• Then, we defined a by multiplying the by the .\n• We then assigned the to the and coordinates to “rotate” the cube.\n• Next, we rendered the and\n• Then we appended the to the DOM.\n• Right after that, we used Three.js’s method to make a recursive call to our method to keep the cube constantly rotating.\n• is also used outside of meant to start the rotation.\n\nOur rendered page should look something like this:\n\nThere we have it! We just learned how to use the Three.js library to build a 3D environment. More specifically:\n• We built a that created a that contains 3D objects.\n• We built a that “views” the objects in the .\n• We created an method that renders the and in the returned element.\n\nThis is only scratching the surface of what Three.js can do. Visit their [official website] to view other projects and learn more!"
    },
    {
        "link": "https://cmaher.github.io/posts/working-with-simplex-noise",
        "document": "Recently, I’ve been getting into procedural content generation (PCG), with the end-goal of procedurally generating entire worlds. When you consider the fact that my artistic abilities are incredibly lacking, it only makes sense that I would consider having algorithms make things for me. Add in the coolness (read: geek) factor, and it’s a wonder that I actually managed to get my other work done before plunging head-first into some PCG experimentation.\n\nBeing new to the world of PCG, I decided to do some research. The first thing I learned was that I would need a decent noise implementation to generate random values. Ken Perlin seems to be the name in noise functions. He made his original algorithm for Perlin noise while working on the original Tron, and he released an improved noise function, simplex noise, back in 2001. These noise functions produce pseudo-random smooth gradients. This noise results in a very natural appearance, so you might have come across it if you’ve done work with terrain heightmaps or particle effects.\n\nFor my project, I decided to use simplex noise, since it’s less computationally expensive and gives better results. I’m not going to go into the details of the algorithm– an excellent paper by Stefan Gustavson already does the job far better than I ever could. But for a high-level overview, it’s enough to know that the algorithm uses something known as a simplex grid to add nearby values and produce numbers between -1 and 1 that look linearly-interpolated like classic Perlin noise.\n\nSimplex noise is a complicated beast. It’s a straight-up math algorithm involving simplices and is designed to be implemented in hardware. To make matters worse, Ken Perlin’s sample implementation (appendix B) is near-indecipherable for the common mind. Thankfully, Gustavson comes to the rescue again by providing implementations in C and C++, as well as in Java, Lua, and GLSL. The implementations provide noise values for up to four dimensions (generally used as three dimensions + time).\n\nWith all of the hard work done for us, we really just need to figure out how to use the provided simplex noise functionality. The various implementations provide a noise function that takes a coordinate and returns a floating-point noise value between -1 and 1, inclusive, where coordinates that are close to each other have similar values. To make a general-purpose heightmap, we need to fill an MxN matrix with luminosity (light) values, between 0 and 255. Let’s normalize the simplex noise to our light range and populate our array:\n\nThat’s all we need, right? Well, it turns out that this produces an image that doesn’t look much better than white noise (that awful static you get on you TV when it doesn’t get a proper signal). How can we smooth this out? First recall that the term “noise” is related to sound, and sound is just a wave. So to simplify matters, we can think of our noise as a wave. Our current noise changes quickly from one value to another. In wave terms, this means that our noise has a very high frequency. What we want is noise with a low-frequency, so that values change gradually.\n\nFrom physics, we know that, for a wave, \\(\\textrm{frequency} = \\frac{\\textrm{velocity}}{\\textrm{wavelength}}\\). We don’t have a convenient method of changing the wave length, so this means that we have to change our noise’s velocity. But what is the current velocity of our noise? Recall that \\(\\textrm{velocity} = \\frac{\\textrm{distance}}{\\textrm{time}}\\). In the sample code, i and j (the distance) are increased by one in each (time) step, so the velocity is one. In order to decrease our frequency, we need to decrease our velocity, and to do that, we need to scale the values that we send to our noise function by some small value:\n\nIt turns out that we need to use a very small scale in order to produce good smooth noise like the type shown above. I use .007, because I like to imagine a very small James Bond making things smooth and suave, but other values around .01 work well for my project. You’ll have to experiment with the scale to see what suits your purposes best.\n\nSo now we have the smooth noise shown above, but it still seems kind of boring and unsatisfying. Instead of purely smooth noise we want something a bit more chaotic and organic. To get this, we’re going to need to use another technique: fractal Brownian motion. This method works by using our noise function for multiple iterations, decreasing the amplitude and increasing the frequency in each successive iteration. It then sums all these iterations together and takes the average. From there, we can normalize the value and add the result to our array.\n\nThis finally gets us the results we want. In the above code, each iteration is called an octave, because it is twice the frequency of the iteration before it, just like musical notes double in frequency as you go up an octave. The amplitude is the relative importance of the octave in the sum of the octaves, and persistence is is the scale factor in each iteration. We want the amplitude to decrease, so our persistence is less than 1. Additionally, the above method allows us to scale our noise from low to high instead of just 0 to 255.\n\nSo we have some good-looking noise that we can apply to textures or make a heightmap, etc. But using fractal Brownian motion isn’t the only way to get cool results out of noise. By using different techniques, you can use basic simplex noise to procedurally generate textures that look remarkably like dust, fire, marble, or even wood. You can try to figure these out on your own, or look around on the internet (note: techniques for using Perlin noise will pretty much get the same results with simplex noise). If you want to learn more, the links throughout the article, and below should help you.\n\nIt turns out that Simplex Noise is patented. OpenSimplexNoise is a free alternative.\n\nC and C++ implementations\n\nThe more technical paper by Ken Perlin"
    },
    {
        "link": "https://npmjs.com/package/simplex-noise",
        "document": "simplex-noise.js is a simplex noise implementation in Javascript/TypeScript. It works in the browser and Node.js, using CommonJS and ES Modules. It is self-contained (dependency-free), relatively small (about 2k minified and gzipped) and fairly fast (about 20 nanoseconds for a sample of 2d noise) and tree shakeable.\n\nCreated something awesome with simplex-noise? Let me know so I can add it to the list.\n\nBy default simplex-noise.js will use Math.random() to seed the noise. You can pass in a PRNG function to use your own seed value.\n\nThe ALEA PRNG used in the example above can be found in the alea npm package.\n\nsimplex-noise.js is reasonably quick. According to I can perform about 70 million calls/second on a single thread on my desktop (Ryzen 5950X).\n\n// IMPORTANT: If you use multiple noise functions (for example 2d and 3d) // and want compatible output with 3.x you will need to pass a fresh instance // of alea to each create call. If you reuse the alea instance you will // get different outputs compared to simplex-noise 3.x.\n• Additional tweaks to PURE annotations to avoid warnings in rollup.js. Contributed by Damien Seguin.\n• Tweaked PURE annotations to avoid warnings in rollup.js. Contributed by Damien Seguin.\n• Explicitly defined the return type of to be . Contributed by satelllte.\n\nThis release changes the API and the output of the noise functions.\n• Reworked the API so that the noise functions can be imported individually. When combined with tree shaking this helps with build sizes.\n• Removed the built in version of the ALEA PRNG to focus the library to do only one thing. If you want to continue to use it you'll have to install and import it separately.\n• Noise values can be different from previous versions\n• Input coordinates bigger than 2^31 may not result in a noisy output anymore. If you have a use case that is affected by this change, please file an issue.\n• Test coverage is now at 100%.\n• A big thank you to @mreinstein, @redblobgames and everyone else involved for their comments and PRs which motivated me to create this new version.\n• Changed module structure. When using bundlers that import the es module even using require() the import might need to be updated.\n• Code converted to typescript, the package can of course still be used from regular JS\n• Included a PRNG based on ALEA to directly allow seeding\n\nThis release changes the output of the noise functions.\n\nIn the future such changes will be released as a new major version.\n\nCopyright (c) 2022 Jonas Wagner, licensed under the MIT License (enclosed)\n\nThis is mostly a direct javascript port of the Java implementation by Stefan Gustavson and Peter Eastman.\n\nThe initial typescript definition has been provided by Neonit."
    },
    {
        "link": "https://redblobgames.com/maps/terrain-from-noise",
        "document": "A common way to generate 2D maps is to use a bandwidth-limited noise function, such as Simplex or Perlin noise, as a building block. This is what the noise function looks like: We assign each location on the map a number from 0.0 to 1.0. In this image, 0.0 is black and 1.0 is white. Here’s how to set the color at each grid location in C-like syntax: The loop will work the same in Javascript, Python, Haxe, C++, C#, Java, and most other popular languages, so I’ll show it in C-like syntax and you can convert it to the language you’re using. In the rest of the tutorial, I’ll show how the loop body (the line) changes as we add more features. At the end, I’ll show a complete example. Depending on the library you use, you may have to shift or multiply the values you get back to fit into the 0.0 to 1.0 range. Some libraries return 0.0 to 1.0; some return -1.0 to +1.0; some return other ranges like -0.7 to +0.7. Some don’t say what they return, so you may have to look at the return values to figure out the range.\n\nNoise by itself is just a bunch of numbers. We need to assign meaning to it. The first thing we might think of is to make the noise correspond to elevation (also called a “height map”). Let’s take the noise from earlier and draw it as elevation: The code is almost the same, except for what’s inside the inner loop; it now looks like this: Yes, that’s it. The map data is the same, but now I call it instead of . Lots of hills, but not much else. What’s wrong? Noise can be generated at any frequency. I’ve only picked one frequency so far. Let’s look at the effect of frequency. Try moving the slider to see what happens at different frequencies: It’s just zooming in and out. That doesn’t seem very useful at first glance, but it is. It’s sometimes useful to think of wavelength, which is the inverse of frequency. Frequency is measured in oscillations per distance. Doubling the frequency makes everything half the size. Wavelength is measured in distance per oscillation, measured in pixels or tiles or meters etc. Doubling the wavelength makes everything twice the size. Wavelength is related to frequency: . I have another tutorial that explains the concepts: frequency, wavelength, amplitude, octaves, pink and blue and white noise, etc. To make the height map more interesting we’re going add noise at different frequencies: Let’s mix big low frequency hills and small high frequency hills into the same map. Move the slider to add smaller hills to the mix: Now that looks a lot more like the fractal terrain we want! We can now get hills and rugged mountains, but we still don’t get flat valleys. We need something else for that. There’s a potential problem though. Since can go from 0 to 1, the sum can go from 0 to 1.75. The numbers are called the amplitudes. The simplest thing to do is to divide by the sum of amplitudes: In practice, you may want to experiment to find the best divisor. Although the sum of amplitudes guarantees the elevation stays in the range 0–1, the elevation values may not be distributed the way you want. Amplitudes are commonly set to be an array , where each amplitude is ½ the previous one. This ratio is called gain or persistence. However we’re not limited to using a fixed ratio. I use amplitudes for many examples on this page to bring out more fine detail than the conventional amplitudes would do. Amplitudes can also be calculated dynamically, either from previous noise values (e.g. octave 1’s noise can affect octave 2’s amplitude), or by using an independent noise field, or by using player/simulation data. Another possible issue: by using and and , what happens when nx and ny are near 0? These noise values are correlated. To get the best results we want these to be independent. If your noise library allows seeding, you can use separate seeds for each of the octaves. If it does not allow seeding, you can add an offset to each of the octaves, such as and and . That way each octave is sampling from different parts of the noise space and they will be independent instead of correlated. And yet another possible issue: these noise values may be aligned along the same directions, which can sometimes cause visible artifacts, especially when using Perlin noise. To reduce this, rotate the output of some of the octaves, or switch to Simplex noise. The noise function gives us values between 0 and 1. To make flat valleys, we can raise the elevation to a power. Move the slider to try different exponents. Higher values push middle elevations down into valleys and lower values pull middle elevations up towards mountain peaks. We want to push them down. In practice it may work better to use , where the fudge factor is some number near 1. For the above demo I used 1.2. Try different values and see what works best for you. The pow() function is only one way to reshape the elevations. There are many other functions you can try. You aren’t limited to mathematical functions; consider drawing curves yourself, like the “curves” tool in a photo editor. Now that we have a reasonable elevation map, let’s add some biomes!\n\nNoise gives us numbers but we want a map with forests, deserts, and oceans. The first thing to do is to make low elevations into water: function biome(e) { // a threshold between 0.2 and 0.5 work well in the demo // but each generator will need its own parameter tuning if (e < ) return WATER; else return LAND; } Hey, that’s starting to look like a procedurally generated world! We have water, grass, and snow. What if we want more things? Let’s make the sequence water, beach, grassland, forest, savannah, desert, snow: function biome(e) { // these thresholds will need tuning to match your generator if (e < 0.1) return WATER; else if (e < 0.2) return BEACH; else if (e < 0.3) return FOREST; else if (e < 0.5) return JUNGLE; else if (e < 0.7) return SAVANNAH; else if (e < 0.9) return DESERT; else return SNOW; } Hey, looks cool! You’ll want to change the numbers and biomes for your game. Crysis will have more jungles; Skyrim will have more ice and snow. But no matter what you change the numbers to, this approach is a bit limited. The terrain types line up with the elevations, so they form bands. To make it more interesting, we need to choose biomes with something other than elevation. Let’s create a second noise map for “moisture”: Elevation noise on left; moisture noise on right Now let’s use both elevation and moisture. In the diagram on the left below, the y-axis is the elevation (first diagram above) and the x-axis is the moisture (second diagram above). It produces a reasonable looking map: Low elevations are oceans and beaches. High elevations are rocky or snowy. In between we get a wide range of biomes. The code looks like this: function biome(e, m) { // these thresholds will need tuning to match your generator if (e < 0.1) return OCEAN; if (e < 0.12) return BEACH; if (e > 0.8) { if (m < 0.1) return SCORCHED; if (m < 0.2) return BARE; if (m < 0.5) return TUNDRA; return SNOW; } if (e > 0.6) { if (m < 0.33) return TEMPERATE_DESERT; if (m < 0.66) return SHRUBLAND; return TAIGA; } if (e > 0.3) { if (m < 0.16) return TEMPERATE_DESERT; if (m < 0.50) return GRASSLAND; if (m < 0.83) return TEMPERATE_DECIDUOUS_FOREST; return TEMPERATE_RAIN_FOREST; } if (m < 0.16) return SUBTROPICAL_DESERT; if (m < 0.33) return GRASSLAND; if (m < 0.66) return TROPICAL_SEASONAL_FOREST; return TROPICAL_RAIN_FOREST; } These are example threshold numbers. In every project I’ve worked on I’ve had to change them, not only for predominant biomes (Dagobah will have more swamp, Hoth will have more tundra, Tatooine will have more desert) but also because it depends on the noise library being used and how the octaves are mixed together. Plan to tweak these numbers! Alternatively if you don’t need biomes, smooth gradients (see cartographer Tom Patterson’s article[2]) can produce colors: With either biomes or gradients, one noise value doesn’t produce enough diversity, but two is pretty good. Two is what ecologist Robert Whittaker[3] used when he was studying biomes.\n\nFor some projects I want the boundaries of the map to be water. One way to do this is to generate a map as above and then reshape it. Looking from the side, what is stopping the map from being an island? The border areas that are on land need to be pushed down into water, and the center areas that are in water need to be pushed up to become land. Need this below water Need this above water Need this below water How does this work? There are two ingredients:\n• A distance function assigns a distance to every position on the map, from 0 at the center to 1 at the border.\n• A shaping function (as used in the Redistribution section) takes an elevation as input and chooses a new output elevation. At the center of the map (distance 0), we’ll use a shaping function that always outputs land. At the border of the map (distance 1), we’ll use a shaping function that always outputs water. In between, we’ll allow both land and water. For simplicity, I’ll assume the water level is 0.5, so ≥0.5 means land and <0.5 means water. To calculate the distance , set and . These will range from -1 to +1. Then choose one of these distance functions recommended by /u/KdotJPG[4]: , when you have a square map and want to make the island fill as much of the space possible without reaching the borders. , when you want the island to be round, and plan to embed it in a larger world. The simplest way to shape the elevation is to linearly mix in . At the center of the map, is 0, and we want the elevation to be high (1). At the edges of the map, is 1, and we want the elevation to be low (0). Linear interpolation can do this: , for some value of between 0 and 1. Move the slider to 0 to see the original map and move it to 1 to see the constraining shape. There are many more things to try. Try shifting the distance function up or down by adding a constant, or slope it more or less by multiplying by a constant, or change the exponent from 2 to 4 or 6. Try applying the elevation reshaping to only the lower frequency octaves of the noise generator, and allow the high frequencies to work equally across the map. Try choosing the amount of land area you want, and then push all elevations up or down until you get the desired island size. Try using noise to create the island shape but use some other approach to assign the elevation. Try using a lookup table to allow arbitrary (piecewise linear) reshaping or distance functions. It will take some experimentation to find a combination you like. Try non-linear shaping functions to mix and .\n\nWe usually use fractal noise for elevation and moisture, but it can also be used for placing irregularly spaced objects like trees and rocks. For elevation we have higher amplitudes with lower frequencies (“red noise”). For object placement we want to use higher amplitudes with higher frequencies (“blue noise”). On the left is a blue noise pattern; on the right are the locations where the noise is greater than the nearby values: for (int y = 0; y < height; y++) { for (int x = 0; x < width; x++) { double nx = x/width - 0.5, ny = y/height - 0.5; // blue noise is high frequency; try varying this bluenoise[y][x] = noise(50 * nx, 50 * ny); } } for (int yc = 0; yc < height; yc++) { for (int xc = 0; xc < width; xc++) { double max = 0; // there are more efficient algorithms than this for (int dy = -R; dy <= R; dy++) { for (int dx = -R; dx <= R; dx++) { int xn = dx + xc, yn = dy + yc; // optionally check that (dx*dx + dy*dy <= R * (R + 1)) if (0 <= yn && yn < height && 0 <= xn && xn < width) { double e = bluenoise[yn][xn]; if (e > max) { max = e; } } } } if (bluenoise[yc][xc] == max) { // place tree at xc,yc } } } KDotJPG recommends checking to change the square overlap check to a circular overlap check, and also to allow non-integer radius values. Also consider that the radius doesn’t have to be a constant. By choosing a different R for each biome we can get a variable density of trees: Although it’s cool that Simplex/Perlin noise can be used to place trees, other algorithms are more efficient and produce a better distribution of trees. For trees and other object placement, I recommend using Poisson Disc[6] or a jittered grid instead of high frequency Simplex/Perlin noise as shown here. For Javascript, I use poisson-disk-sampling[7], fast-2d-poisson-disk-sampling[8], or jittered-hexagonal-grid-sampling[9]. Wang tiles and graphics dithering algorithms are also worth a look.\n\nSometimes we want the east edge of the map to match up with the west edge. This corresponds to a cylinder in 3D space. We can implement this with a minor change. We’ll interpret the x value on the flat map as an angle in the cylinder world. Then we convert the angle to cartesian coordinates. To also make the north and south edges match up, we can apply the same pattern again to turn the y value into an angle, and look things up in a 4D noise space. Let’s see how the maps look adjacent to copies of themselves: The first one wraps east-west but not north-south. The second one wraps in all four directions. Here’s some code: const TAU = 2 * M_PI; function cylindernoise(double nx, double ny) { double angle_x = TAU * nx; /* In \"noise parameter space\", we need nx and ny to travel the same distance. The circle created from nx needs to have circumference=1 to match the length=1 line created from ny, which means the circle's radius is 1/2π, or 1/tau */ return noise3D(cos(angle_x) / TAU, sin(angle_x) / TAU, ny); } function torusnoise(double nx, double ny) { double angle_x = TAU * nx, angle_y = TAU * ny; return noise4D(cos(angle_x) / TAU, sin(angle_x) / TAU, cos(angle_y) / TAU, sin(angle_y) / TAU); } In practice, you will probably have to scale these noise values up. Higher dimensional noise tends to have a narrower range of values than lower dimensional noise, so if your biome constants are tuned for 2D noise, then you can try multiplying noise3D by √1.5, and noise4D by √2, but you may have to tweak these values further to match your needs. See Rudi Chen’s article on Perlin Noise range[10]. For more on tileable noise, see Ron Valstar’s guide[11]. Another thing that may affect the quality is that the octaves may “bleed” into each other’s frequency ranges, according to the paper Wavelet Noise[12] by Cook and DeRose: When rendering, it is common to texture 2D surfaces by sampling a 3D noise function, but the resulting 2D texture will in general not be band-limited, even if the 3D function is perfectly band-limited.\n\nUsing noise for generating terrain is a popular technique, and you can find tutorials for many different languages and platforms. The map generation code is pretty similar across languages. Here’s the simplest loop, in three different languages:\n• Javascript: import { createNoise2D } from 'simplex-noise'; let gen = createNoise2D(); function noise(nx, ny) { // Rescale from -1.0:+1.0 to 0.0:1.0 return gen(nx, ny) / 2 + 0.5; } let value = []; for (let y = 0; y < height; y++) { value[y] = []; for (let x = 0; x < width; x++) { let nx = x/width - 0.5, ny = y/height - 0.5; value[y][x] = noise(nx, ny); } }\n• C++: module::Perlin gen; // if using libnoise double noise(double nx, double ny) { // if using libnoise // Rescale from -1.0:+1.0 to 0.0:1.0 return gen.GetValue(nx, ny, 0) / 2.0 + 0.5; } FastNoiseLite gen; // if using fastnoiselite double noise(double nx, double ny) { // if using fastnoiselite // Rescale from -1.0:+1.0 to 0.0:1.0 return gen.GetNoise(nx, ny) / 2.0 + 0.5; } double value[height][width]; for (int y = 0; y < height; y++) { for (int x = 0; x < width; x++) { double nx = x/width - 0.5, ny = y/height - 0.5; value[y][x] = noise(nx, ny); } }\n• Python: from opensimplex import OpenSimplex gen = OpenSimplex() def noise(nx, ny): # Rescale from -1.0:+1.0 to 0.0:1.0 return gen.noise2d(nx, ny) / 2.0 + 0.5 value = [] for y in range(height): value.append([0] * width) for x in range(width): nx = x/width - 0.5 ny = y/height - 0.5 value[y][x] = noise(nx, ny) Once you have a noise library, the code is similar. Beward: some libraries combine multiple octaves automatically, which is convenient but makes it hard to mix them in your own way.\n• C++: SimplexNoise[14] or FastNoiseLite[15] or libnoise[16] There are lots of noise libraries for most popular languages. Alternatively, you may want to spend time studying how Simplex/Perlin/OpenSimplex noise works, or implementing it yourself. I didn’t. I used the existing libraries. Once you have found a noise library for your favorite language, the details will vary (some will return numbers from 0.0 to 1.0 and others from -1.0 to +1.0) but the basic idea is the same. For a real project you may want to wrap the function and the object into a class but those details aren’t relevant here so I made them global. For this simple project it doesn’t matter that much whether you use Simplex noise, OpenSimplex noise, Perlin noise, value noise, midpoint displacement, diamond square[21] displacement, or an inverse Fourier transform. There are pros and cons of each of these but they all produce similar enough output for this type of map generator. The drawing of the map is going to be platform-specific and game-specific so I’m not providing that; this code is to generate the elevations and biomes, which you’ll want to draw yourself in whatever style your game uses. Feel free to copy, port, and use it for your own projects.\n\nThere are lots of cool things you can do with noise functions. If you search the web you’ll see variants such as turbulence, billow, ridged multifractal, amplitude damping, terraced, voronoi noise, analytical derivatives, domain warping, and others. Take a look at this page[34] for inspiration. I’m not covering them here; instead I’m focused on simplicity for this article. My previous map generation projects that influenced this one:\n• I used generic Perlin noise for my first Realm of the Mad God map generator[35]. We used that for the first six months of alpha testing, and then replaced it with a custom-designed Voronoi polygon map generator[36] based on the gameplay needs we identified during the alpha testing. The biomes in this article and their colors come from those projects.\n• While studying signal processing for audio, I wrote a tutorial on noise that covers concepts like frequency, amplitude, octaves, and “colors” of noise. The same concepts that work for audio also apply to noise-based map generation. I made some unpolished terrain generation demos at the time but never finished them.\n• Sometimes I experiment to find limits. I wanted to see how little code I could get away with while still producing reasonable maps. In this mini-project I got down to zero lines of code— it’s all image filters (turbulence, threshold, color gradients). I was both pleased and disturbed by this. How much of map generation can be done with image filters? Quite a lot. Everything in the “smooth gradient color scheme” I described earlier came from this experiment. The noise layer is a turbulence image filter; the octaves are images layered on top of each other; the exponent is called the “curves adjustment” tool in Photoshop. It bothers me somewhat that most of the code we game developers write for noise-based terrain generation (including midpoint displacement) turns out to be the same as audio and image filters. On the other hand, it produces decent results with very little code, so that’s why I wrote the article you’re reading. It’s a quick & easy starting point. I usually don’t use these types of maps for long; I’ll replace them with a custom map generator once more of the game is built and I have a better sense of what types of maps best match that game’s design. That’s a common pattern for me: start with something extremely simple, then replace it only after I better understand the system I’m working on. There are a lot of cool things you can do with noise, and I’ve barely explored them here. Try out the Noise Studio[37] to interactively explore lots of possibilities. Also:\n• Building Worlds Using Maths[39] - Sean Murray of No Man’s Sky; skip to 20 minutes in."
    },
    {
        "link": "https://github.com/jwagner/simplex-noise.js",
        "document": "simplex-noise.js is a simplex noise implementation in Javascript/TypeScript. It works in the browser and Node.js, using CommonJS and ES Modules. It is self-contained (dependency-free), relatively small (about 2k minified and gzipped) and fairly fast (about 20 nanoseconds for a sample of 2d noise) and tree shakeable.\n\nCreated something awesome with simplex-noise? Let me know so I can add it to the list.\n\nBy default simplex-noise.js will use Math.random() to seed the noise. You can pass in a PRNG function to use your own seed value.\n\nThe ALEA PRNG used in the example above can be found in the alea npm package.\n\nsimplex-noise.js is reasonably quick. According to I can perform about 70 million calls/second on a single thread on my desktop (Ryzen 5950X).\n\n// IMPORTANT: If you use multiple noise functions (for example 2d and 3d) // and want compatible output with 3.x you will need to pass a fresh instance // of alea to each create call. If you reuse the alea instance you will // get different outputs compared to simplex-noise 3.x.\n• Additional tweaks to PURE annotations to avoid warnings in rollup.js. Contributed by Damien Seguin.\n• Tweaked PURE annotations to avoid warnings in rollup.js. Contributed by Damien Seguin.\n• Explicitly defined the return type of to be . Contributed by satelllte.\n\nThis release changes the API and the output of the noise functions.\n• Reworked the API so that the noise functions can be imported individually. When combined with tree shaking this helps with build sizes.\n• Removed the built in version of the ALEA PRNG to focus the library to do only one thing. If you want to continue to use it you'll have to install and import it separately.\n• Noise values can be different from previous versions\n• Input coordinates bigger than 2^31 may not result in a noisy output anymore. If you have a use case that is affected by this change, please file an issue.\n• Test coverage is now at 100%.\n• A big thank you to @mreinstein, @redblobgames and everyone else involved for their comments and PRs which motivated me to create this new version.\n• Changed module structure. When using bundlers that import the es module even using require() the import might need to be updated.\n• Code converted to typescript, the package can of course still be used from regular JS\n• Included a PRNG based on ALEA to directly allow seeding\n\nThis release changes the output of the noise functions.\n\nIn the future such changes will be released as a new major version.\n\nCopyright (c) 2022 Jonas Wagner, licensed under the MIT License (enclosed)\n\nThis is mostly a direct javascript port of the Java implementation by Stefan Gustavson and Peter Eastman.\n\nThe initial typescript definition has been provided by Neonit."
    },
    {
        "link": "https://reddit.com/r/proceduralgeneration/comments/bz4pt8/can_someone_run_me_through_the_basics_of_using",
        "document": "Hi! Some of you may have seen my WIP terrain generator, and I have come to realize I need to switch how I’m doing it. I’ve read up on Perlin and Simplex noise, but it just isn’t clicking. Conceptually I understand it, but the implementation is making my head hurt. Could someone explain to me the basics on how to make and implement my own algorithm in Java?"
    }
]