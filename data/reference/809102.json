[
    {
        "link": "https://docs.python.org/3/library/ftplib.html",
        "document": "Return a new instance of the class.\n\nSeveral methods are available in two flavors: one for handling text files and another for binary files. The methods are named for the command which is used followed by for the text version or for the binary version.\n\ninstances have the following methods:\n\nConnect to the given host and port. This function should be called only once for each instance; it should not be called if a host argument was given when the instance was created. All other methods can only be called after a connection has successfully been made.\n• None host (str) – The host to connect to.\n• None port (int) – The TCP port to connect to (default: , as specified by the FTP protocol specification). It is rarely needed to specify a different port number.\n• None timeout (float | None) – A timeout in seconds for the connection attempt (default: the global default timeout setting).\n• None source_address (tuple | None) – A 2-tuple for the socket to bind to as its source address before connecting.\n\nInitiate a transfer over the data connection. If the transfer is active, send an or command and the transfer command specified by cmd, and accept the connection. If the server is passive, send an or command, connect to it, and start the transfer command. Either way, return the socket for the connection. If optional rest is given, a command is sent to the server, passing rest as an argument. rest is usually a byte offset into the requested file, telling the server to restart sending the file’s bytes at the requested offset, skipping over the initial bytes. Note however that the method converts rest to a string with the encoding parameter specified at initialization, but no check is performed on the string’s contents. If the server does not recognize the command, an exception will be raised. If this happens, simply call without a rest argument."
    },
    {
        "link": "https://pythonprogramming.net/ftp-transfers-python-ftplib",
        "document": "In this Python programming tutorial, we cover how to do FTP (file transfer protocol) transfers with ftplib. We'll cover both uploading and downloading files with a remote server.\n\nThe above will connect you to your remote server. You can then change into a specific directory with:\n\nNow, let's show how we might download a file:\n\nSo there are a few things here, so let's walk through it. First, we assign the file name to a variable. Then, we prepare our local file to be written in accordance with whatever the remote file contains.\n\nNext, we retrieve the binary data from the remote server, then we write to the local file what we find. The last parameter there, the 1024, is in reference to buffering. Basically, how much data at a time will we do? So at 1024, 1024 byte chunks will be transferred at a time until the full operation is complete.\n\nNext, how about uploading a file?\n\nAbout the same here, we take file name and assign it to a variable, then we store the binary data to the filename, with the read data from the file name locally."
    },
    {
        "link": "https://stackoverflow.com/questions/12613797/python-script-uploading-files-via-ftp",
        "document": "I just answered a similar question here IMHO, if your FTP server is able to communicate with Fabric please us Fabric. It is far better than doing raw .\n\nI have an FTP account from so I am not sure if this will work for other FTP accounts.\n\nsave the file as and run locally.\n\nOnce again, if you don't want to input password all the time, just add"
    },
    {
        "link": "https://geeksforgeeks.org/how-to-download-and-upload-files-in-ftp-server-using-python",
        "document": "How to Download and Upload Files in FTP Server using Python?\n\nHere, we will learn how to Download and Upload Files in FTP Server Using Python. Before we get started, first we will understand what is FTP.\n\nFile Transfer Protocol(FTP) is an application layer protocol that moves files between local and remote file systems. It runs on the top of TCP, like HTTP. To transfer a file, 2 TCP connections are used by FTP in parallel: control connection and data connection.\n\nFor uploading and downloading the file, we will use ftplib Module in Python. It is an in-built module in Python.\n\nThis module defines the class FTP and a few related items. The FTP class implements the client-side of the FTP protocol. You can use this to write Python programs that perform a variety of automated FTP jobs, such as mirroring other FTP servers.\n\nWe will use a test FTP server, it is called DLPTEST and we are going to use the below text file for all operations:\n• Enter Required Information, the information will be available click here.\n\nNote: Password will change time to time, make sure you visit their website for the correct credentials.\n• Upload the File (To upload a file, we will use storbinary() method)\n• Get the list of directories using dir() method. The test server will remove files after 30 minutes.\n• Download the File (To download a file, we will use retrbinary() method.\n\nBelow is the complete program for uploading the file in FTP Server:\n\nBelow is the complete program for downloading the file in FTP Server:"
    },
    {
        "link": "https://docs.python.org/ko/3.5/library/ftplib.html",
        "document": ""
    },
    {
        "link": "https://docs.paramiko.org/en/stable/api/sftp.html",
        "document": "Used to open an SFTP session across an open SSH and perform remote file operations. Instances of this class may be used as context managers. Create an SFTP client from an existing . The channel should already have requested the subsystem. An alternate way to create an SFTP client context is by using . sock (Channel) – an open using the subsystem – if there’s an exception while negotiating sftp Change the “current directory” of this SFTP session. Since SFTP doesn’t really have the concept of a current working directory, this is emulated by Paramiko. Once you use this method to set a working directory, all operations on this object will be relative to that path. You can pass in to stop using a current working directory. – if the requested path doesn’t exist on the server Change the mode (permissions) of a file. The permissions are unix-style and identical to those used by Python’s function.\n• None path (str) – path of the file to change the permissions of Change the owner ( ) and group ( ) of a file. As with Python’s function, you must pass both arguments, so if you only want to change one, use first to retrieve the current owner and group.\n• None path (str) – path of the file to change the owner and group of Close the SFTP session and its underlying channel. Open a file on the remote server. The arguments are the same as for Python’s built-in (aka ). A file-like object is returned, which closely mimics the behavior of a normal Python file object, including the ability to be used as a context manager. The mode indicates how the file is to be opened: for reading, for writing (truncating an existing file), for appending, for reading/writing, for reading/writing (truncating an existing file), for reading/appending. The Python flag is ignored, since SSH treats all files as binary. The flag is supported in a compatible way. Since 1.5.2, an flag indicates that the operation should only succeed if the file was created and did not previously exist. This has no direct mapping to Python’s file flags, but is commonly known as the flag in posix. The file will be buffered in standard Python style by default, but can be altered with the parameter. turns off buffering, uses line buffering, and any number greater than 1 ( ) uses that specific buffer size.\n• None filename (str) – name of the file to open – if the file could not be opened. Create an SFTP client channel from an open . Setting the window and packet sizes might affect the transfer speed. The default settings in the class are the same as in OpenSSH and should work adequately for both files transfers and interactive sessions.\n• None t (Transport) – an open which is already authenticated a new object, referring to an sftp session (channel) across the transport Changed in version 1.15: Added the and arguments. Copy a remote file ( ) from the SFTP server to the local host as . Any exception raised by operations will be passed through. This method is primarily provided as a convenience.\n• None localpath (str) – the destination path on the local host\n• None callback (callable) – optional callback function (form: ) that accepts the bytes transferred so far and the total bytes to be transferred\n• None max_concurrent_prefetch_requests (int) – The maximum number of concurrent read requests to prefetch. When this is (the default), do not limit the number of concurrent prefetch requests. Note: OpenSSH’s sftp internally imposes a limit of 64 concurrent requests, while Paramiko imposes no limit by default; consider setting a limit if a file can be successfully received with sftp but hangs with Paramiko. Return the underlying object for this SFTP session. This might be useful for doing things like setting a timeout on the channel. Return the “current working directory” for this SFTP session, as emulated by Paramiko. If no directory has been set with , this method will return . Copy a remote file ( ) from the SFTP server and write to an open file or file-like object, . Any exception raised by operations will be passed through. This method is primarily provided as a convenience.\n• None remotepath (object) – opened file or file-like object to copy to\n• None fl (str) – the destination path on the local host or open file object\n• None callback (callable) – optional callback function (form: ) that accepts the bytes transferred so far and the total bytes to be transferred\n• None max_concurrent_prefetch_requests (int) – The maximum number of concurrent read requests to prefetch. See (its param) for details. the of bytes written to the opened file object Return a list containing the names of the entries in the given . The list is in arbitrary order. It does not include the special entries and even if they are present in the folder. This method is meant to mirror as closely as possible. For a list of full objects, see . Return a list containing objects corresponding to files in the given . The list is in arbitrary order. It does not include the special entries and even if they are present in the folder. The returned objects will each have an additional field: , which may contain a formatted string of the file’s attributes, in unix format. The content of this string will probably depend on the SFTP server implementation. See the API docs for for overall details. This function adds one more kwarg on top of : , an integer controlling how many requests are made to the server. The default of 50 should suffice for most file listings as each request/response cycle may contain multiple files (dependent on server implementation.) Retrieve information about a file on the remote system, without following symbolic links (shortcuts). This otherwise behaves exactly the same as . an object containing attributes about the given file Create a folder (directory) named with numeric mode . The default mode is 0777 (octal). On some systems, mode is ignored. Where it is used, the current umask value is first masked out.\n• None path (str) – name of the folder to create Return the normalized path (on the server) of a given path. This can be used to quickly resolve symbolic links or determine what the server is considering to be the “current folder” (by passing as ). normalized form of the given path (as a ) – if the path can’t be resolved on the server Open a file on the remote server. The arguments are the same as for Python’s built-in (aka ). A file-like object is returned, which closely mimics the behavior of a normal Python file object, including the ability to be used as a context manager. The mode indicates how the file is to be opened: for reading, for writing (truncating an existing file), for appending, for reading/writing, for reading/writing (truncating an existing file), for reading/appending. The Python flag is ignored, since SSH treats all files as binary. The flag is supported in a compatible way. Since 1.5.2, an flag indicates that the operation should only succeed if the file was created and did not previously exist. This has no direct mapping to Python’s file flags, but is commonly known as the flag in posix. The file will be buffered in standard Python style by default, but can be altered with the parameter. turns off buffering, uses line buffering, and any number greater than 1 ( ) uses that specific buffer size.\n• None filename (str) – name of the file to open – if the file could not be opened. Rename a file or folder from to , following posix conventions.\n• None oldpath (str) – existing name of the file or folder\n• None newpath (str) – new name for the file or folder, will be overwritten if it already exists – if is a folder, posix-rename is not supported by the server or something else goes wrong Copy a local file ( ) to the SFTP server as . Any exception raised by operations will be passed through. This method is primarily provided as a convenience. The SFTP operations use pipelining for speed.\n• None remotepath (str) – the destination path on the SFTP server. Note that the filename should be included. Only specifying a directory may result in an error.\n• None callback (callable) – optional callback function (form: ) that accepts the bytes transferred so far and the total bytes to be transferred\n• None confirm (bool) – whether to do a stat() on the file afterwards to confirm the file size an object containing attributes about the given file Changed in version 1.7.4: and rich attribute return value added. Copy the contents of an open file object ( ) to the SFTP server as . Any exception raised by operations will be passed through. The SFTP operations use pipelining for speed.\n• None remotepath (str) – the destination path on the SFTP server\n• None file_size (int) – optional size parameter passed to callback. If none is specified, size defaults to 0\n• None callback (callable) – optional callback function (form: ) that accepts the bytes transferred so far and the total bytes to be transferred (since 1.7.4)\n• None confirm (bool) – whether to do a stat() on the file afterwards to confirm the file size (since 1.7.7) an object containing attributes about the given file. Return the target of a symbolic link (shortcut). You can use to create these. The result may be either an absolute or relative pathname. Remove the file at the given path. This only works on files; for removing folders (directories), use . path (str) – path (absolute or relative) of the file to remove – if the path refers to a folder (directory) Rename a file or folder from to . This method implements ‘standard’ SFTP behavior; those seeking the OpenSSH “POSIX rename” extension behavior should use .\n• None oldpath (str) – existing name of the file or folder\n• None newpath (str) – new name for the file or folder, must not exist already – if is a folder, or something else goes wrong path (str) – name of the folder to remove Retrieve information about a file on the remote system. The return value is an object whose attributes correspond to the attributes of Python’s structure as returned by , except that it contains fewer fields. An SFTP server may return as much or as little info as it wants, so the results may vary from server to server. Unlike a Python object, the result may not be accessed as a tuple. This is mostly due to the author’s slack factor. The fields supported are: , , , , , and . an object containing attributes about the given file Create a symbolic link to the path at . Change the size of the file specified by . This usually extends or shrinks the size of the file, just like the method on Python file objects.\n• None path (str) – path of the file to modify\n• None size (int) – the new size of the file Remove the file at the given path. This only works on files; for removing folders (directories), use . path (str) – path (absolute or relative) of the file to remove – if the path refers to a folder (directory) Set the access and modified times of the file specified by . If is , then the file’s access and modified times are set to the current time. Otherwise, must be a 2-tuple of numbers, of the form , which is used to set the access and modified times, respectively. This bizarre API is mimicked from Python for the sake of consistency – I apologize.\n• None path (str) – path of the file to modify\n• None times (tuple) – or a tuple of (access time, modified time) in standard internet epoch time (seconds since 01 January 1970 GMT)\n\nProxy object for a file on the remote server, in client mode SFTP. Instances of this class may be used as context managers in the same way that built-in Python file objects are. Ask the server for a hash of a section of this file. This can be used to verify a successful upload or download, or for various rsync-like operations. The file is hashed from , for bytes. If is 0, the remainder of the file is hashed. Thus, if both and are zero, the entire file is hashed. Normally, will be 0 (the default), and this method will return a byte string representing the requested hash (for example, a string of length 16 for MD5, or 20 for SHA-1). If a non-zero is given, each chunk of the file (from to ) of bytes is computed as a separate hash. The hash results are all concatenated and returned as a single string. For example, will return a string of length 40. The first 20 bytes will be the SHA-1 of the first 512 bytes of the file, and the last 20 bytes will be the SHA-1 of the next 512 bytes.\n• None hash_algorithm (str) – the name of the hash algorithm to use (normally or )\n• None offset – offset into the file to begin hashing (0 means to start from the beginning)\n• None length – number of bytes to hash (0 means continue to the end of the file)\n• None block_size (int) – number of bytes to hash per result (must not be less than 256; 0 means to compute only one hash of the entire segment) of bytes representing the hash of each block, concatenated together – if the server doesn’t support the “check-file” extension, or possibly doesn’t support the hash algorithm requested Many (most?) servers don’t support this extension yet. Change the mode (permissions) of this file. The permissions are unix-style and identical to those used by Python’s function. Change the owner ( ) and group ( ) of this file. As with Python’s function, you must pass both arguments, so if you only want to change one, use first to retrieve the current owner and group. Write out any data in the write buffer. This may do nothing if write buffering is not turned on. Returns the timeout in seconds (as a ) associated with the socket or ssh used for this file. Pre-fetch the remaining contents of this file in anticipation of future calls. If reading the entire file, pre-fetching can dramatically improve the download speed by avoiding roundtrip latency. The file’s contents are incrementally buffered in a background thread. The prefetched data is stored in a buffer until read via the method. Once data has been read, it’s removed from the buffer. The data may be read in a random order (using ); chunks of the buffer that haven’t been read will continue to be buffered.\n• None file_size (int) – When this is (the default), this method calls to determine the remote file size. In some situations, doing so can cause exceptions or hangs (see #562); as a workaround, one may call explicitly and pass its value in via this parameter.\n• None max_concurrent_requests (int) – The maximum number of concurrent read requests to prefetch. See (its param) for details. Changed in version 1.16.0: The parameter was added (with no default value). Changed in version 1.16.1: The parameter was made optional for backwards compatibility. Read at most bytes from the file (less if we hit the end of the file first). If the argument is negative or omitted, read all the remaining data in the file. mode flag is ignored ( in ), because SSH treats all files as binary, since we have no idea what encoding the file is in, or even if the file is text data. data read from the file (as bytes), or an empty string if EOF was encountered immediately Check if the file can be read from. if the file can be read from. If , will raise an exception. Read up to bytes into buff and return the number of bytes read. Read one entire line from the file. A trailing newline character is kept in the string (but may be absent when a file ends with an incomplete line). If the size argument is present and non-negative, it is a maximum byte count (including the trailing newline) and an incomplete line may be returned. An empty string is returned only when EOF is encountered immediately. Unlike stdio’s , the returned string contains null characters ( ) if they occurred in the input. next line of the file, or an empty string if the end of the file has been reached. If the file was opened in binary ( ) mode: bytes are returned Else: the encoding of the file is assumed to be UTF-8 and character strings ( ) are returned Read all remaining lines using and return them as a list. If the optional argument is present, instead of reading up to EOF, whole lines totalling approximately sizehint bytes (possibly after rounding up to an internal buffer size) are read. list of lines read from the file. Read a set of blocks from the file by (offset, length). This is more efficient than doing a series of and calls, since the prefetch machinery is used to retrieve all the requested blocks at once.\n• None chunks – a list of tuples indicating which sections of the file to read\n• None max_concurrent_prefetch_requests (int) – The maximum number of concurrent read requests to prefetch. See (its param) for details. a list of blocks read, in the same order as in if the file supports random access. If , will raise an exception Turn on/off the pipelining of write operations to this file. When pipelining is on, paramiko won’t wait for the server response after each write operation. Instead, they’re collected as they come in. At the first non-write operation (including ), all remaining server responses are collected. This means that if there was an error with one of your later writes, an exception might be thrown from within instead of . By default, files are not pipelined. pipelined (bool) – if pipelining should be turned on for this file; otherwise Set blocking or non-blocking mode on the underiying socket or ssh . Set a timeout on read/write operations on the underlying socket or ssh . timeout (float) – seconds to wait for a pending read/write operation before raising , or for no timeout Retrieve information about this file from the remote system. This is exactly like , except that it operates on an already-open file. an object containing attributes about this file. Return the file’s current position. This may not be accurate or useful if the underlying file doesn’t support random access, or was opened in append mode. Change the size of this file. This usually extends or shrinks the size of the file, just like the method on Python file objects. size – the new size of the file Set the access and modified times of this file. If is , then the file’s access and modified times are set to the current time. Otherwise, must be a 2-tuple of numbers, of the form , which is used to set the access and modified times, respectively. This bizarre API is mimicked from Python for the sake of consistency – I apologize. times (tuple) – or a tuple of (access time, modified time) in standard internet epoch time (seconds since 01 January 1970 GMT) Check if the file can be written to. if the file can be written to. If , will raise an exception. Write data to the file. If write buffering is on ( was specified and non-zero), some or all of the data may not actually be written yet. (Use or to force buffered data to be written out.) Write a sequence of strings to the file. The sequence can be any iterable object producing strings, typically a list of strings. (The name is intended to match ; does not add line separators.) Identical to . This is a deprecated file interface that predates Python iterator support.\n\nAbstraction of an SFTP file handle (for server mode).\n\nAn interface to override for SFTP server support.\n\nThis class defines an interface for controlling the behavior of paramiko when using the subsystem to provide an SFTP server. Methods on this class are called from the SFTP session’s thread, so you can block as long as necessary without affecting other sessions (even other SFTP sessions). However, raising an exception will usually cause the SFTP session to abruptly end, so you will usually want to catch exceptions and return an appropriate error code. All paths are in string form instead of unicode because not all SFTP clients & servers obey the requirement that paths be encoded in UTF-8. Create a new SFTPServerInterface object. This method does nothing by default and is meant to be overridden by subclasses. server (ServerInterface) – the server object associated with this channel and SFTP subsystem list of weak references to the object (if defined) Return the canonical form of a path on the server. For example, if the server’s home folder is , the path would be canonicalized to . Note the obvious security issues: if you’re serving files only from a specific folder, you probably don’t want this method to reveal path names outside that folder. You may find the Python methods in useful, especially and . Change the attributes of a file. The object will contain only those fields provided by the client in its request, so you should check for the presence of fields before using them.\n• None path (str) – requested path (relative or absolute) of the file to change.\n• None attr – requested attributes to change on the file (an object) Return a list of files within a given folder. The will use posix notation ( separates folder names) and may be an absolute or relative path. The list of files is expected to be a list of objects, which are similar in structure to the objects returned by . In addition, each object should have its field filled in, since this is important to a directory listing and not normally present in results. The method will usually do what you want. In case of an error, you should return one of the error codes, such as . path (str) – the requested path (relative or absolute) to be listed. a list of the files in the given folder, using objects. You should normalize the given first (see the module) and check appropriate permissions before returning the list of files. Be careful of malicious clients attempting to use relative paths to escape restricted folders, if you’re doing a direct translation from the SFTP server path to your local filesystem. Return an object for a path on the server, or an error code. If your server supports symbolic links (also known as “aliases”), you should not follow them – instead, you should return data on the symlink or alias itself. ( is the corresponding call that follows symlinks/aliases.) path (str) – the requested path (relative or absolute) to fetch file statistics for. an object for the given file, or an SFTP error code (like ). Create a new directory with the given attributes. The object may be considered a “hint” and ignored. The object will contain only those fields provided by the client in its request, so you should use to check for the presence of fields before using them. In some cases, the object may be completely empty.\n• None path (str) – requested path (relative or absolute) of the new folder.\n• None attr (SFTPAttributes) – requested attributes of the new folder. Open a file on the server and create a handle for future operations on that file. On success, a new object subclassed from should be returned. This handle will be used for future operations on the file (read, write, etc). On failure, an error code such as should be returned. contains the requested mode for opening (read-only, write-append, etc) as a bitset of flags from the module: The object contains requested attributes of the file if it has to be created. Some or all attribute fields may be missing if the client didn’t specify them. The SFTP protocol defines all files to be in “binary” mode. There is no equivalent to Python’s “text” mode.\n• None path (str) – the requested path (relative or absolute) of the file to be opened.\n• None flags (int) – flags or’d together from the module indicating the requested mode for opening the file.\n• None attr (SFTPAttributes) – requested attributes of the file if it is newly created. Rename (or move) a file, following posix conventions. If newpath already exists, it will be overwritten.\n• None oldpath (str) – the requested path (relative or absolute) of the existing file.\n• None newpath (str) – the requested new path of the file. Return the target of a symbolic link (or shortcut) on the server. If the specified path doesn’t refer to a symbolic link, an error should be returned. path (str) – path (relative or absolute) of the symbolic link. the target path of the symbolic link, or an error code like . path (str) – the requested path (relative or absolute) of the file to delete. Rename (or move) a file. The SFTP specification implies that this method can be used to move an existing file into a different folder, and since there’s no other (easy) way to move files via SFTP, it’s probably a good idea to implement “move” in this method too, even for files that cross disk partition boundaries, if at all possible. You should return an error if a file with the same name as already exists. (The rename operation should be non-desctructive.) This method implements ‘standard’ SFTP behavior; those seeking the OpenSSH “POSIX rename” extension behavior should use .\n• None oldpath (str) – the requested path (relative or absolute) of the existing file.\n• None newpath (str) – the requested new path of the file. Remove a directory if it exists. The should refer to an existing, empty folder – otherwise this method should return an error. path (str) – requested path (relative or absolute) of the folder to remove. The SFTP server session has just ended, either cleanly or via an exception. This method is meant to be overridden to perform any necessary cleanup before this object is destroyed. The SFTP server session has just started. This method is meant to be overridden to perform any necessary setup before handling callbacks from SFTP operations. Return an object for a path on the server, or an error code. If your server supports symbolic links (also known as “aliases”), you should follow them. ( is the corresponding call that doesn’t follow symlinks/aliases.) path (str) – the requested path (relative or absolute) to fetch file statistics for. an object for the given file, or an SFTP error code (like ). Create a symbolic link on the server, as new pathname , with as the target of the link.\n• None target_path (str) – path (relative or absolute) of the target for this new symbolic link.\n• None path (str) – path (relative or absolute) of the symbolic link to create."
    },
    {
        "link": "https://docs.paramiko.org/en/latest/api/sftp.html",
        "document": "Used to open an SFTP session across an open SSH and perform remote file operations. Instances of this class may be used as context managers. Create an SFTP client from an existing . The channel should already have requested the subsystem. An alternate way to create an SFTP client context is by using . sock (Channel) – an open using the subsystem – if there’s an exception while negotiating sftp Change the “current directory” of this SFTP session. Since SFTP doesn’t really have the concept of a current working directory, this is emulated by Paramiko. Once you use this method to set a working directory, all operations on this object will be relative to that path. You can pass in to stop using a current working directory. – if the requested path doesn’t exist on the server Change the mode (permissions) of a file. The permissions are unix-style and identical to those used by Python’s function.\n• None path (str) – path of the file to change the permissions of Change the owner ( ) and group ( ) of a file. As with Python’s function, you must pass both arguments, so if you only want to change one, use first to retrieve the current owner and group.\n• None path (str) – path of the file to change the owner and group of Close the SFTP session and its underlying channel. Open a file on the remote server. The arguments are the same as for Python’s built-in (aka ). A file-like object is returned, which closely mimics the behavior of a normal Python file object, including the ability to be used as a context manager. The mode indicates how the file is to be opened: for reading, for writing (truncating an existing file), for appending, for reading/writing, for reading/writing (truncating an existing file), for reading/appending. The Python flag is ignored, since SSH treats all files as binary. The flag is supported in a compatible way. Since 1.5.2, an flag indicates that the operation should only succeed if the file was created and did not previously exist. This has no direct mapping to Python’s file flags, but is commonly known as the flag in posix. The file will be buffered in standard Python style by default, but can be altered with the parameter. turns off buffering, uses line buffering, and any number greater than 1 ( ) uses that specific buffer size.\n• None filename (str) – name of the file to open – if the file could not be opened. Create an SFTP client channel from an open . Setting the window and packet sizes might affect the transfer speed. The default settings in the class are the same as in OpenSSH and should work adequately for both files transfers and interactive sessions.\n• None t (Transport) – an open which is already authenticated a new object, referring to an sftp session (channel) across the transport Changed in version 1.15: Added the and arguments. Copy a remote file ( ) from the SFTP server to the local host as . Any exception raised by operations will be passed through. This method is primarily provided as a convenience.\n• None localpath (str) – the destination path on the local host\n• None callback (callable) – optional callback function (form: ) that accepts the bytes transferred so far and the total bytes to be transferred\n• None max_concurrent_prefetch_requests (int) – The maximum number of concurrent read requests to prefetch. When this is (the default), do not limit the number of concurrent prefetch requests. Note: OpenSSH’s sftp internally imposes a limit of 64 concurrent requests, while Paramiko imposes no limit by default; consider setting a limit if a file can be successfully received with sftp but hangs with Paramiko. Return the underlying object for this SFTP session. This might be useful for doing things like setting a timeout on the channel. Return the “current working directory” for this SFTP session, as emulated by Paramiko. If no directory has been set with , this method will return . Copy a remote file ( ) from the SFTP server and write to an open file or file-like object, . Any exception raised by operations will be passed through. This method is primarily provided as a convenience.\n• None remotepath (object) – opened file or file-like object to copy to\n• None fl (str) – the destination path on the local host or open file object\n• None callback (callable) – optional callback function (form: ) that accepts the bytes transferred so far and the total bytes to be transferred\n• None max_concurrent_prefetch_requests (int) – The maximum number of concurrent read requests to prefetch. See (its param) for details. the of bytes written to the opened file object Return a list containing the names of the entries in the given . The list is in arbitrary order. It does not include the special entries and even if they are present in the folder. This method is meant to mirror as closely as possible. For a list of full objects, see . Return a list containing objects corresponding to files in the given . The list is in arbitrary order. It does not include the special entries and even if they are present in the folder. The returned objects will each have an additional field: , which may contain a formatted string of the file’s attributes, in unix format. The content of this string will probably depend on the SFTP server implementation. See the API docs for for overall details. This function adds one more kwarg on top of : , an integer controlling how many requests are made to the server. The default of 50 should suffice for most file listings as each request/response cycle may contain multiple files (dependent on server implementation.) Retrieve information about a file on the remote system, without following symbolic links (shortcuts). This otherwise behaves exactly the same as . an object containing attributes about the given file Create a folder (directory) named with numeric mode . The default mode is 0777 (octal). On some systems, mode is ignored. Where it is used, the current umask value is first masked out.\n• None path (str) – name of the folder to create Return the normalized path (on the server) of a given path. This can be used to quickly resolve symbolic links or determine what the server is considering to be the “current folder” (by passing as ). normalized form of the given path (as a ) – if the path can’t be resolved on the server Open a file on the remote server. The arguments are the same as for Python’s built-in (aka ). A file-like object is returned, which closely mimics the behavior of a normal Python file object, including the ability to be used as a context manager. The mode indicates how the file is to be opened: for reading, for writing (truncating an existing file), for appending, for reading/writing, for reading/writing (truncating an existing file), for reading/appending. The Python flag is ignored, since SSH treats all files as binary. The flag is supported in a compatible way. Since 1.5.2, an flag indicates that the operation should only succeed if the file was created and did not previously exist. This has no direct mapping to Python’s file flags, but is commonly known as the flag in posix. The file will be buffered in standard Python style by default, but can be altered with the parameter. turns off buffering, uses line buffering, and any number greater than 1 ( ) uses that specific buffer size.\n• None filename (str) – name of the file to open – if the file could not be opened. Rename a file or folder from to , following posix conventions.\n• None oldpath (str) – existing name of the file or folder\n• None newpath (str) – new name for the file or folder, will be overwritten if it already exists – if is a folder, posix-rename is not supported by the server or something else goes wrong Copy a local file ( ) to the SFTP server as . Any exception raised by operations will be passed through. This method is primarily provided as a convenience. The SFTP operations use pipelining for speed.\n• None remotepath (str) – the destination path on the SFTP server. Note that the filename should be included. Only specifying a directory may result in an error.\n• None callback (callable) – optional callback function (form: ) that accepts the bytes transferred so far and the total bytes to be transferred\n• None confirm (bool) – whether to do a stat() on the file afterwards to confirm the file size an object containing attributes about the given file Changed in version 1.7.4: and rich attribute return value added. Copy the contents of an open file object ( ) to the SFTP server as . Any exception raised by operations will be passed through. The SFTP operations use pipelining for speed.\n• None remotepath (str) – the destination path on the SFTP server\n• None file_size (int) – optional size parameter passed to callback. If none is specified, size defaults to 0\n• None callback (callable) – optional callback function (form: ) that accepts the bytes transferred so far and the total bytes to be transferred (since 1.7.4)\n• None confirm (bool) – whether to do a stat() on the file afterwards to confirm the file size (since 1.7.7) an object containing attributes about the given file. Return the target of a symbolic link (shortcut). You can use to create these. The result may be either an absolute or relative pathname. Remove the file at the given path. This only works on files; for removing folders (directories), use . path (str) – path (absolute or relative) of the file to remove – if the path refers to a folder (directory) Rename a file or folder from to . This method implements ‘standard’ SFTP behavior; those seeking the OpenSSH “POSIX rename” extension behavior should use .\n• None oldpath (str) – existing name of the file or folder\n• None newpath (str) – new name for the file or folder, must not exist already – if is a folder, or something else goes wrong path (str) – name of the folder to remove Retrieve information about a file on the remote system. The return value is an object whose attributes correspond to the attributes of Python’s structure as returned by , except that it contains fewer fields. An SFTP server may return as much or as little info as it wants, so the results may vary from server to server. Unlike a Python object, the result may not be accessed as a tuple. This is mostly due to the author’s slack factor. The fields supported are: , , , , , and . an object containing attributes about the given file Create a symbolic link to the path at . Change the size of the file specified by . This usually extends or shrinks the size of the file, just like the method on Python file objects.\n• None path (str) – path of the file to modify\n• None size (int) – the new size of the file Remove the file at the given path. This only works on files; for removing folders (directories), use . path (str) – path (absolute or relative) of the file to remove – if the path refers to a folder (directory) Set the access and modified times of the file specified by . If is , then the file’s access and modified times are set to the current time. Otherwise, must be a 2-tuple of numbers, of the form , which is used to set the access and modified times, respectively. This bizarre API is mimicked from Python for the sake of consistency – I apologize.\n• None path (str) – path of the file to modify\n• None times (tuple) – or a tuple of (access time, modified time) in standard internet epoch time (seconds since 01 January 1970 GMT)\n\nProxy object for a file on the remote server, in client mode SFTP. Instances of this class may be used as context managers in the same way that built-in Python file objects are. Ask the server for a hash of a section of this file. This can be used to verify a successful upload or download, or for various rsync-like operations. The file is hashed from , for bytes. If is 0, the remainder of the file is hashed. Thus, if both and are zero, the entire file is hashed. Normally, will be 0 (the default), and this method will return a byte string representing the requested hash (for example, a string of length 16 for MD5, or 20 for SHA-1). If a non-zero is given, each chunk of the file (from to ) of bytes is computed as a separate hash. The hash results are all concatenated and returned as a single string. For example, will return a string of length 40. The first 20 bytes will be the SHA-1 of the first 512 bytes of the file, and the last 20 bytes will be the SHA-1 of the next 512 bytes.\n• None hash_algorithm (str) – the name of the hash algorithm to use (normally or )\n• None offset – offset into the file to begin hashing (0 means to start from the beginning)\n• None length – number of bytes to hash (0 means continue to the end of the file)\n• None block_size (int) – number of bytes to hash per result (must not be less than 256; 0 means to compute only one hash of the entire segment) of bytes representing the hash of each block, concatenated together – if the server doesn’t support the “check-file” extension, or possibly doesn’t support the hash algorithm requested Many (most?) servers don’t support this extension yet. Change the mode (permissions) of this file. The permissions are unix-style and identical to those used by Python’s function. Change the owner ( ) and group ( ) of this file. As with Python’s function, you must pass both arguments, so if you only want to change one, use first to retrieve the current owner and group. Write out any data in the write buffer. This may do nothing if write buffering is not turned on. Returns the timeout in seconds (as a ) associated with the socket or ssh used for this file. Pre-fetch the remaining contents of this file in anticipation of future calls. If reading the entire file, pre-fetching can dramatically improve the download speed by avoiding roundtrip latency. The file’s contents are incrementally buffered in a background thread. The prefetched data is stored in a buffer until read via the method. Once data has been read, it’s removed from the buffer. The data may be read in a random order (using ); chunks of the buffer that haven’t been read will continue to be buffered.\n• None file_size (int) – When this is (the default), this method calls to determine the remote file size. In some situations, doing so can cause exceptions or hangs (see #562); as a workaround, one may call explicitly and pass its value in via this parameter.\n• None max_concurrent_requests (int) – The maximum number of concurrent read requests to prefetch. See (its param) for details. Changed in version 1.16.0: The parameter was added (with no default value). Changed in version 1.16.1: The parameter was made optional for backwards compatibility. Read at most bytes from the file (less if we hit the end of the file first). If the argument is negative or omitted, read all the remaining data in the file. mode flag is ignored ( in ), because SSH treats all files as binary, since we have no idea what encoding the file is in, or even if the file is text data. data read from the file (as bytes), or an empty string if EOF was encountered immediately Check if the file can be read from. if the file can be read from. If , will raise an exception. Read up to bytes into buff and return the number of bytes read. Read one entire line from the file. A trailing newline character is kept in the string (but may be absent when a file ends with an incomplete line). If the size argument is present and non-negative, it is a maximum byte count (including the trailing newline) and an incomplete line may be returned. An empty string is returned only when EOF is encountered immediately. Unlike stdio’s , the returned string contains null characters ( ) if they occurred in the input. next line of the file, or an empty string if the end of the file has been reached. If the file was opened in binary ( ) mode: bytes are returned Else: the encoding of the file is assumed to be UTF-8 and character strings ( ) are returned Read all remaining lines using and return them as a list. If the optional argument is present, instead of reading up to EOF, whole lines totalling approximately sizehint bytes (possibly after rounding up to an internal buffer size) are read. list of lines read from the file. Read a set of blocks from the file by (offset, length). This is more efficient than doing a series of and calls, since the prefetch machinery is used to retrieve all the requested blocks at once.\n• None chunks – a list of tuples indicating which sections of the file to read\n• None max_concurrent_prefetch_requests (int) – The maximum number of concurrent read requests to prefetch. See (its param) for details. a list of blocks read, in the same order as in if the file supports random access. If , will raise an exception Turn on/off the pipelining of write operations to this file. When pipelining is on, paramiko won’t wait for the server response after each write operation. Instead, they’re collected as they come in. At the first non-write operation (including ), all remaining server responses are collected. This means that if there was an error with one of your later writes, an exception might be thrown from within instead of . By default, files are not pipelined. pipelined (bool) – if pipelining should be turned on for this file; otherwise Set blocking or non-blocking mode on the underiying socket or ssh . Set a timeout on read/write operations on the underlying socket or ssh . timeout (float) – seconds to wait for a pending read/write operation before raising , or for no timeout Retrieve information about this file from the remote system. This is exactly like , except that it operates on an already-open file. an object containing attributes about this file. Return the file’s current position. This may not be accurate or useful if the underlying file doesn’t support random access, or was opened in append mode. Change the size of this file. This usually extends or shrinks the size of the file, just like the method on Python file objects. size – the new size of the file Set the access and modified times of this file. If is , then the file’s access and modified times are set to the current time. Otherwise, must be a 2-tuple of numbers, of the form , which is used to set the access and modified times, respectively. This bizarre API is mimicked from Python for the sake of consistency – I apologize. times (tuple) – or a tuple of (access time, modified time) in standard internet epoch time (seconds since 01 January 1970 GMT) Check if the file can be written to. if the file can be written to. If , will raise an exception. Write data to the file. If write buffering is on ( was specified and non-zero), some or all of the data may not actually be written yet. (Use or to force buffered data to be written out.) Write a sequence of strings to the file. The sequence can be any iterable object producing strings, typically a list of strings. (The name is intended to match ; does not add line separators.) Identical to . This is a deprecated file interface that predates Python iterator support.\n\nAbstraction of an SFTP file handle (for server mode).\n\nAn interface to override for SFTP server support.\n\nThis class defines an interface for controlling the behavior of paramiko when using the subsystem to provide an SFTP server. Methods on this class are called from the SFTP session’s thread, so you can block as long as necessary without affecting other sessions (even other SFTP sessions). However, raising an exception will usually cause the SFTP session to abruptly end, so you will usually want to catch exceptions and return an appropriate error code. All paths are in string form instead of unicode because not all SFTP clients & servers obey the requirement that paths be encoded in UTF-8. Create a new SFTPServerInterface object. This method does nothing by default and is meant to be overridden by subclasses. server (ServerInterface) – the server object associated with this channel and SFTP subsystem list of weak references to the object (if defined) Return the canonical form of a path on the server. For example, if the server’s home folder is , the path would be canonicalized to . Note the obvious security issues: if you’re serving files only from a specific folder, you probably don’t want this method to reveal path names outside that folder. You may find the Python methods in useful, especially and . Change the attributes of a file. The object will contain only those fields provided by the client in its request, so you should check for the presence of fields before using them.\n• None path (str) – requested path (relative or absolute) of the file to change.\n• None attr – requested attributes to change on the file (an object) Return a list of files within a given folder. The will use posix notation ( separates folder names) and may be an absolute or relative path. The list of files is expected to be a list of objects, which are similar in structure to the objects returned by . In addition, each object should have its field filled in, since this is important to a directory listing and not normally present in results. The method will usually do what you want. In case of an error, you should return one of the error codes, such as . path (str) – the requested path (relative or absolute) to be listed. a list of the files in the given folder, using objects. You should normalize the given first (see the module) and check appropriate permissions before returning the list of files. Be careful of malicious clients attempting to use relative paths to escape restricted folders, if you’re doing a direct translation from the SFTP server path to your local filesystem. Return an object for a path on the server, or an error code. If your server supports symbolic links (also known as “aliases”), you should not follow them – instead, you should return data on the symlink or alias itself. ( is the corresponding call that follows symlinks/aliases.) path (str) – the requested path (relative or absolute) to fetch file statistics for. an object for the given file, or an SFTP error code (like ). Create a new directory with the given attributes. The object may be considered a “hint” and ignored. The object will contain only those fields provided by the client in its request, so you should use to check for the presence of fields before using them. In some cases, the object may be completely empty.\n• None path (str) – requested path (relative or absolute) of the new folder.\n• None attr (SFTPAttributes) – requested attributes of the new folder. Open a file on the server and create a handle for future operations on that file. On success, a new object subclassed from should be returned. This handle will be used for future operations on the file (read, write, etc). On failure, an error code such as should be returned. contains the requested mode for opening (read-only, write-append, etc) as a bitset of flags from the module: The object contains requested attributes of the file if it has to be created. Some or all attribute fields may be missing if the client didn’t specify them. The SFTP protocol defines all files to be in “binary” mode. There is no equivalent to Python’s “text” mode.\n• None path (str) – the requested path (relative or absolute) of the file to be opened.\n• None flags (int) – flags or’d together from the module indicating the requested mode for opening the file.\n• None attr (SFTPAttributes) – requested attributes of the file if it is newly created. Rename (or move) a file, following posix conventions. If newpath already exists, it will be overwritten.\n• None oldpath (str) – the requested path (relative or absolute) of the existing file.\n• None newpath (str) – the requested new path of the file. Return the target of a symbolic link (or shortcut) on the server. If the specified path doesn’t refer to a symbolic link, an error should be returned. path (str) – path (relative or absolute) of the symbolic link. the target path of the symbolic link, or an error code like . path (str) – the requested path (relative or absolute) of the file to delete. Rename (or move) a file. The SFTP specification implies that this method can be used to move an existing file into a different folder, and since there’s no other (easy) way to move files via SFTP, it’s probably a good idea to implement “move” in this method too, even for files that cross disk partition boundaries, if at all possible. You should return an error if a file with the same name as already exists. (The rename operation should be non-desctructive.) This method implements ‘standard’ SFTP behavior; those seeking the OpenSSH “POSIX rename” extension behavior should use .\n• None oldpath (str) – the requested path (relative or absolute) of the existing file.\n• None newpath (str) – the requested new path of the file. Remove a directory if it exists. The should refer to an existing, empty folder – otherwise this method should return an error. path (str) – requested path (relative or absolute) of the folder to remove. The SFTP server session has just ended, either cleanly or via an exception. This method is meant to be overridden to perform any necessary cleanup before this object is destroyed. The SFTP server session has just started. This method is meant to be overridden to perform any necessary setup before handling callbacks from SFTP operations. Return an object for a path on the server, or an error code. If your server supports symbolic links (also known as “aliases”), you should follow them. ( is the corresponding call that doesn’t follow symlinks/aliases.) path (str) – the requested path (relative or absolute) to fetch file statistics for. an object for the given file, or an SFTP error code (like ). Create a symbolic link on the server, as new pathname , with as the target of the link.\n• None target_path (str) – path (relative or absolute) of the target for this new symbolic link.\n• None path (str) – path (relative or absolute) of the symbolic link to create."
    },
    {
        "link": "https://medium.com/@keagileageek/paramiko-how-to-ssh-and-file-transfers-with-python-75766179de73",
        "document": "So i’m employed at a social media type of company with a product working a lot like facebook and the past week had to sort out an issue with loosing the linking between video urls on our db with the actual content on the server. Some mismatch with Kaltura. But anyways long story short, I had to write a little script which would download videos from a remote server to upload to Kaltura to and get new urls to replace old ones int the db.\n\nSSH is the method typically used to access a remote machine and run commands, retrieve files or upload files.\n\nYou can transfer files from the remote machine to the local or vice versa using SFTP (Secure File Transfer Protocol) and SCP(Secure Copy Protocol).\n\nAccording to paramiko.org, The python paramiko model gives an abstraction of the SSHv2 protocol with both the client side and server side functionality. As a client, you can authenticate yourself using a password or key and as a server you can decide which users are allowed accesss and the channels you allow\n\nIn this blog I focus on the client side.\n\nLet’s get on with it\n\nThe primary client of Paramiko as documented in the API, is Paramiko.SSHClient. An instance of the Paramiko.SSHClient can be used to make connections to the remote server and transfer files\n\nwhen you try this, you get the following error:\n\nmissing_host_key raise SSHException(‘Server %r not found in known_hosts’ % hostname) paramiko.ssh_exception.SSHException: Server ‘hostname’ not found in known_hosts\n\nYou see this error because you have not informed your machine that the remote server you “trust” the server you are trying to access. If you go onto you command line or terminal and try to connect to a server for the first time, You will get a message similar to this:\n\n\n\nThe authenticity of host ‘hostname’ can’t be established.RSA key fingerprint is ‘key’. Are you sure you want to continue connecting (yes/no)?\n\n\n\nWhen you select yes here, you let your machine know that it can trust the machine and you can now access it without the prompt until the key for that machine changes.\n\nParamiko similarly requires that you validate your trust with the machine. This validation is handled by calling set_missing_host_key_policy() on the SSHClient an passing the policy you want implemented when accessing a new remote machine. By default, the paramiko.SSHclient sets the policy to the RejectPolicy. The policy rejects connection without validating as we saw above. Paramiko does however give you a way to sort of “Trust all” key policy, the AutoAddPolicy. Parsing an instance of the AutoAddPolicy to set_missing_host_key_policy() changes it to allow any host.\n\nYou should now be in the green\n\nRUNNING COMMANDS ON THE REMOTE MACHINE\n\nTo run a command exec_command is called on the SSHClient with the command passed. The response is returned as a tuple (stdin,stdout,stderr)\n\nFor example to list all the files in a directory:\n\nGetting the type for each of the returned,\n\ntype(stdin) and type(stdout) is ‘paramiko.channel.ChannelFile’\n\ntype(stderr) is class ‘paramiko.channel.ChannelStderrFile’\n\nAccording to paramiko.org they are all python file like objects.\n\nThe stdin is a write-only file which can be used for commands requiring input\n\nThe stdout file give the output of the command\n\nThe stderr gives the errors returned on executing the command. Will be empty if there is no error\n\nCOMMANDS REQUIRING INPUT\n\nSometimes you need to provide a password or extra input to run a command. This is what stdin is used for. Let’s run the same command above with sudo.\n\nShould return list of files and folders as above.\n\nFILE TRANSFERS\n\nFile transfers are handled by the paramiko.SFTPClient which you get from calling open_sftp() on an instance of Paramiko.SSHClient.\n\nGive it a go and correct me where you must :). Please do follow or subscribe to my blog to get an notified on any new posts"
    },
    {
        "link": "https://hackersandslackers.com/automate-ssh-scp-python-paramiko",
        "document": "Cloud providers have made a killing from neatly-packaged managed services for years. Whether it be databases or message brokers, developers like ourselves don't seem to have a problem paying a bit extra to have things taken care of. But wait, aren't we typically the last people to opt for less optimization and less control? Why is this the time we decide otherwise? If I had to make a guess, I'd wager it's partly because server-side DevOps kind of sucks.\n\nAs a developer, configuring or debugging a VPS is usually work which is unaccounted for, and it isn't particularly rewarding. At best, your application will probably end up running the same as your local environment. How could we make this inevitable part of our jobs better? Well, we could automate it.\n\nParamiko and SCP are two Python libraries we can use together to automate tasks we'd want to run on a remote host such as restarting services, making updates, or grabbing log files. We're going to take a look at what scripting with these libraries looks like. Fair warning: there's a sizable amount of code in this tutorial, which tends to make me excited enough to coerce others into my manic code-tutorial episodes. If you start to feel lost, the full repo can be found here:\n\nTo authenticate an SSH connection, we need to set up a private RSA SSH key. We can generate a key using the following command:\n\nThis will prompt us to provide a name for our key. Name it whatever you like:\n\nNext, you'll be prompted to provide a password (recommended, but up to you). This will result in the creation of two keys: a private key (which I'll refer to as ) and a public key that takes the naming scheme of :\n\nConsider the private key sacred; this key and everything about it should remain on your machine (the example I posted above is fake). The corresponding public key is what we put on remote hosts in our possession to authenticate a connection.\n\nThe easiest way to do this is by using , which is a command that exists for this exact purpose:\n\nThe above example, is the file path of the public key we created. should of course be replaced with the address of your remote host, where is the username of the preferred user to connect with.\n\nIt's always best to check our work. Go ahead and SSH into your remote host; if you didn't set a password when creating your key, you may be surprised that you're no longer prompted for a password. That's a good sign.\n\nCheck your host's directory for the public key we created:\n\nWe're looking for keys that begin with the following header:\n\nFeel free to do the same on your VPS.\n\nLet's install our libraries. Fire up whichever virtual environment you prefer and let em rip:\n\nJust one more thing before we write some meaningful Python code! Create a config file to hold the variables we'll need to connect to our host. Here are the barebones of what we need to get into our server:\n• Host: The IP address or URL of the remote host we're trying to access.\n• Username: This is the username you use to SSH into your server.\n• Passphrase (optional): If you specified a passphrase when you created your ssh key, specify that here. Remember that your SSH key passphrase is different from your user's password.\n• SSH Key: The file path of the key we created earlier. On OSX, these live in your system's ~/.ssh folder. SSH key we're targeting must have an accompanying key with a .pub file extension. This is our public key; if you were following along earlier, this should have already been generated for you.\n\nIf you're trying to upload or download files from your remote host, you'll need to include two more variables:\n• Remote Path: The path to the remote directory we're looking to target for file transfers. We can either upload things to this folder or download the contents of it.\n• Local Path: Same idea as above, but the reverse. For our convenience, the local path we'll be using is simply /data, and contains pictures of cute fox gifs.\n\nNow we have everything we need to make a respectable config.py file:\n\nWe're going to create a class called to handle the interactions we'll be having with our remote host. Before we get too fancy, let's just start things off by instantiating the class with the variables we created in config.py:\n\nYou'll notice I added a few things to our constructor, besides the config values we pass in:\n• : self.client will ultimately serve as the connection objection in our class, similar to how you have dealt with terminology like in database libraries. Our connection will be until we explicitly connect to our remote host.\n• isn't a variable, but rather a function to be run automatically whenever our client is instantiated. Calling is telling our object to check for local ssh keys immediately upon creation so we can try to pass them to our remote host. Otherwise, we wouldn't be able to establish a connection at all.\n\nWe've reached the section of this exercise where we need to knock out some devastatingly inglorious boilerplate code. This is typically where emotionally inferior individuals succumb to the sheer dull obscurity of understanding SSH keys and maintaining connections. Make no mistake: authenticating and managing connections to anything programmatically is overwhelmingly dull... unless your tour guide is an enchanting wordsmith, serving as your loving protector through perilous obscurity. Some people call this post a tutorial. I intend to call it art.\n\nwill start with two private methods: and . The former will fetch a locally stored public key, and if successful, the latter will deliver this public key to our remote host as an olive branch of access. Once a locally created public key exists on a remote machine, that machine will then forever trust us and our requests to connect to it: no passwords are required. We'll be including proper logging along the way, just in case we run into any trouble:\n\nis quite simple: it verifies that an SSH key exists at the path we specified in our config to be used for connecting to our host. If the file does exist, we happily set our variable so that this key can be uploaded and used by our client from here forward. Paramiko provides us with a submodule called to easily handle all things RSA key related, like parsing a private key file into a usable connection authentication. That's what we get here:\n\nIf our RSA key were incomprehensible nonsense instead of a real key, Paramiko's would have caught this and raised an exception early on explaining just that. Properly utilizing a library's error handling takes a lot of the guesswork out of \"what went wrong,\" especially in cases where there's potential for numerous unknowns in a niche space neither of us messes with often.\n\nis where we get to jam our SSH key down the throat of our remote server while shouting, \"LOOK! YOU CAN TRUST ME FOREVER NOW!\" To accomplish this, I go a bit \"old school\" by passing bash commands via Python's . Unless somebody makes me aware of a cleaner approach in the comments, I'll assume this is the most badass way to handle passing keys to a remote server.\n\nThe standard non-Python way of passing keys to a host looks like this:\n\nThis is precisely what we accomplish in our function in Python, which looks like this:\n\nI suppose you won't let me slip that bit by you? Fine. If you must know, here's some guy on StackOverflow explaining it better than I can:\n\nSo we're telling our remote server we're giving it something, and it's all like \"where do I put this thing,\" to which we reply \"nowhere in physical in space, as this is not an object, but rather an eternal symbol of our friendship. Our remote host is then flooded with gratitude and emotion, because yes, computers do have emotions, but we can't be bothered by that right now.\n\nWe'll add a method to our client called to handle connecting to our host:\n• sets the stage for creating an object representing our SSH client. The following lines will configure this object to make it more useful.\n• instructs our client to look for all the hosts we've connected to in the past by looking at our system's known_hosts file and finding the SSH keys our host expects. We've never connected to our host in the past, so we need to specify our SSH key explicitly.\n• tells Paramiko what to do in the event of an unknown key pair. This is expecting a \"policy\" built-in to Paramiko, to which we're going to specific . Setting our policy to \"auto-add\" means that if we attempt to connect to an unrecognized host, Paramiko will automatically add the missing key locally.\n• is SSHClient's most important method (as you might imagine). We're finally able to pass our host, user, and SSH key to achieve what we've all been waiting for: a glorious SSH connection to our server! The method allows flexibility via a vast array of optional keyword arguments. I happen to pass a few here: setting look_for_keys to give Paramiko permission to look around in our ~/.ssh folder to discover SSH keys on its own, and setting timeout will automatically close connections we'll probably forget to close. We could even pass variables for things like port and password, if we had elected to connect to our host this way.\n\nWe should close connections to our remote host whenever we're done using them. Failing to do so might not necessarily be disastrous, but I've had a few instances where enough hanging connections would eventually max out inbound traffic on port 22. Regardless of whether your use case might consider a reboot to be a disaster or mild inconvenience, let's just close our damn connections like adults as though we were wiping our butts after pooping. No matter your connection hygiene, I advocate setting a timeout variable (as we saw earlier). Anyway. voila:\n\nFun fact: setting sets to equal , which is useful when you want to check if a connection is already open.\n\nWe now have a wonderful Python class that can find RSA keys, connect, and disconnect. It does lack the ability to do, well, anything useful.\n\nWe can fix this and finally begin doing \"stuff\" with a brand new method to execute commands, which I'll aptly dub (that's correct: \"commands,\" as in potentially-more-than-one... we'll touch on that in a moment). The Paramiko client's built-in does the legwork of all this method, which accepts a single string as a command and executes it:\n\nThe function we just created expects a list of strings to execute as commands. That's partially for convenience, but it's also because Paramiko won't run any \"state\" changes (like changing directories) between commands, so each command we pass to Paramiko should assume we're working out of our server's root. I took the liberty of passing three such commands like so:\n\nI can view the contents of a directory by chaining , but running followed by would result in nothingness because the second time returns the list of files in our server's root.\n\nYou'll notice returns three values as opposed to one: this can be useful to see which input produced which output. For example, here are the full logs for the example I provided where I passed three commands to :\n\nSome beautiful stuff here. Now you can see which sites are on my server, which bots are spamming me, and how many node processes I'm running.\n\nI don't want to waste much more time on the art of executing commands, but it's worth mentioning the presence of why we call after each command. Waiting to come back after running forces our commands to be run synchronously, otherwise, there's a likely chance our remote machine won't be about to decipher commands as fast as we pass them along.\n\nSCP refers to the protocol for copying files to remote machines (secure copy protocol) and the Python library, which utilizes this. We've already installed the SCP library, so import that shit.\n\nThe SCP and Paramiko libraries complement one another to make uploading via SCP super easy. creates an object which expects \"transport\" from Paramiko, which we provide with . Creating an SCP connection piggybacks off of our SSH client in terms of syntax, but these connections are separate. It's possible to close an SSH connection and leave an SCP connection open, so don't do that. Open an SCP connection like this:\n\nUploading a single file is boring, so let's upload an entire directory of files instead. accepts a list of file paths:\n\nOur method expects to receive a list of strings, each representing the local path to a file, we'd like to upload.\n\nSCP's the method will upload any number of files to a remote host. This will replace existing files with the same name if they happen to exist at the destination we specify. That's all it takes!\n\nThe counterpart to SCP's is the method:\n\nWe now have a sick Python class to handle SSH and SCP with a remote host... let's put it to work! The following snippet is a quick way to test what we've built. In short, this script looks for a local folder filled with files (in my case, I filled the folder with fox gifs 🦊).\n\nCheck out how easy it is to create a main.py that handles complex tasks on remote machines thanks to our class:\n\nHere's the output of our upload function:\n\nIt worked! Don't believe me? Why don't we check for ourselves by running ?\n\nThere you have it. Straight from the fox's mouth.\n\nTake It And Run With It\n\nThis is where I'd like to take a moment to thank all of you and apologize that you're still here. I swore an oath to stop posting tutorials over two thousand words long, and this one is looking to push five thousand words of nonsense. I'll work on that. New year, new me.\n\nFor your convenience, I've uploaded the source for this tutorial to Github. Feel free to take this and run with it! To close things out, I'll leave you with the meat and potatoes of the the class we put together:\n\nThe full source code for this tutorial can be found here:"
    },
    {
        "link": "https://sftpcloud.io/learn/python/paramiko-sftp-examples",
        "document": "Python is a powerful language that can be used to automate various tasks, including file transfers over SFTP (SSH File Transfer Protocol). One such library that makes this possible is Paramiko. Paramiko is a Python implementation of the SSHv2 protocol, providing both client and server functionality.\n\nIn this article, we'll be taking a look at how you can use the Paramiko library to handle file transfers over SFTP.\n\nThe first step to setting up file transfers over SFTP using Paramiko is to establish an SSH client. You'll need to set the server's hostname, username, and password, as shown in the example below:\n\nImportant Note: Hardcoding sensitive details such as the server hostname, username, or password directly into your scripts is not recommended. These should be stored in a secure manner such as using environment variables or secure key storage mechanisms.\n\nis convenient for development, it's not recommended for production code as it automatically trusts and adds new host keys, which can be a potential security risk. In a production environment, you should handle host keys in a safer manner.\n\nWith the SFTP client established, you can now perform file transfer operations. Here's an example of how you can upload and download files:\n\nFinally, don't forget to close the connections once your file transfers are complete:\n\nRemember, this is just a basic example of what you can do with Paramiko. The library offers a lot more functionality, such as listing files in a directory, removing files, creating directories, and much more. With a little exploration and creativity, you can automate a wide variety of tasks using Python and Paramiko!"
    }
]