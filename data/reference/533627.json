[
    {
        "link": "https://unity.com/how-to/naming-and-code-style-tips-c-scripting-unity",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/gamedev/comments/3a1k33/top_10_unity_best_practices_naming_conventions",
        "document": "I wrote a little article outlining a few best practices I've picked up over time, regarding naming conventions.\n• Use descriptive names: It’s obvious, but it’s also the most important. Instead of using BallA and BallB, use BouncyBall and MetalBall. Instead of Button1 and Button2, use PauseButton, ExitButton. Serious game development means putting several months into a single project, which means you can count on yourself to forget what you were thinking when you wrote a script 4 months ago. Do yourself a favor and write your code as if a complete stranger is going to read it in the future.\n• Use proper parenting: Although not a naming convention, your lightBulb object should almost always be a child of your Lamp object. Hierarchies should always follow common sense. Always avoid grouping together unrelated objects. The hierarchy you come up with now, your future self must also be able to come up with independently.\n• Use CamelCase: Why? Because ThisIsEasierToRead than thislongabomination. As a bonus, most modern code completion tools have explicit support for camel cases. Which means that you can quickly call MyAwesomeFunction() by typing ‘maf’ in the editor (The characters in upper case).\n• Avoid abbreviations: I know it’s tempting to name SmallGun And BigGun as ‘sg’ and ‘bg’ because “Yeah, sure I’ll change it in the future, I just want to test one little thing quickly”. Before you know it, you’re in the middle of a complicated spiderweb of dependencies and finding objects in code using the same abbreviations you used to name them ‘temporarily’. Soon, it’s no longer worth the effort and you say to yourself that it’s okay because you know what those objects are so you don’t need to go through the trouble of refactoring a million things. All this to save 3 seconds which it would have taken you to type in a proper name.\n• Prefix Underscores to highlight items: Earlier, using underscores as the first character of an identifier meant that it will come up as the first item in the sorted list. Even though we can now sort our game objects arbitrarily in the hierarchy view, it’s still a good idea to highlight certain unique objects that are of greater importance or are used very frequently. For example, _SetupManager to set up initial conditions in your scene, _ScoreManager that keeps track of score change events from multiple sources. These objects will probably be used most often so it’s a good idea to give them a distinct and visible name.\n\nNot to make the post a giant wall of text, check out the complete post at my little blog :)"
    },
    {
        "link": "https://discussions.unity.com/t/what-is-a-good-naming-convention-for-script-components/780419",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/24586319/what-is-a-good-naming-convention-for-unity",
        "document": "The Unity convention is actually rather simple: everything is Pascal-cased, types (classes, structs, enums) and methods start with upper-case, fields and properties with lower-case. Enum values in upper-case, constants in lower-case (usually). So , , , , ... that's it.\n\nAs for your example, is a class, whereas is an accessor to the instance of in that particular GameObject/Component. Also, doesn't have a property, it has a property (always lower-case).\n\nThis is more or less based on C#'s conventions and the standard .NET library (MS has very precise guidelines about it), except standard .NET uses UpperCase for public/protected methods AND properties, and lower-case for private (again, usually; what's private is more left to the taste of the coder I think).\n\nAs a side-note, with any codebase, in any language, the best way is ALWAYS to follow the existing convention. Every seasoned programmer will tell you this. I understand about OCD, believe me, but in this case I suggest you let it go. There are very little objective arguments as to why a convention would be better than another (by definition a convention is arbitrary), and even if there was, the absolute worse thing you can do is mix several conventions, because then you have 0 convention at all and never know what to expect.\n\nAt least C# tries to standardize; I've worked on several C++ codebases and I fail to see a common denominator: , , , , , or not... it's rarely consistent, so the less you mix the better."
    },
    {
        "link": "https://medium.com/@derekanderson-dev/naming-conventions-unity-developer-8ee88e40ea88",
        "document": "They say that consistency in programming or coding is one of the most important things to keep in mind. Which is why I am ashamed to say that I didn’t stay consistent when it comes to the naming conventions of my variables during my first take at my space shooter game.\n\nC# naming conventions typically follow the standards set by Microsoft. Thier guidelines recommend the use of PascalCase and camelCase. As you can see from how the letters are capitalized, PascalCase has the first letter of each word capitalized. PascalCase is used primarily for methods and functions.\n\ncamelCase, which can also be referred to as lower camel case, is when the first letter of a variable is lower case. If the variable is made up of multiple words, the first letter of the first word is lower case.\n\nAs an independent developer, you may think that it doesn’t matter how the variables and methods are spelled out, especially if the code works as intended. However, if you’re working with a team or a large studio, it’s important to stick to the naming conventions that they set out for you. Reading code is easy for some, but it becomes easier if it is consistent throughout the entire program.\n\nIn order to put this into practice, I spent some time fixing up the naming conventions of my variables in my space shooter game. It’s a simple fix, but it’s one issue that can easily be avoided.\n\nIn my program, underscores were used to denote private variables, but for whatever reason, I missed putting them in initially. Time to fix that."
    },
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Random.Range.html",
        "document": "Suggest a change Thank you for helping us improve the quality of Unity Documentation. Although we cannot accept all submissions, we do read each suggested change from our users and will make updates where applicable. Close For some reason your suggested change could not be submitted. Please <a>try again</a> in a few minutes. And thank you for taking the time to help us improve the quality of Unity Documentation. Close Switch to Manual\n\nIf is greater than , then the numbers are automatically swapped.\n\n\n\nImportant: Both the lower and upper bounds are inclusive. Any given float value between them, including both minInclusive and maxInclusive, will appear on average approximately once every ten million random samples.\n\n\n\nThere is an overload of this function that operates slightly differently, especially regarding the range maximum. See its docs below.\n\n\n\nSee Random for details on the algorithm, and for examples of how may be different from other random number generators.\n\nThe maximum parameter is exclusive, so for example returns a value between 0 and 9, each with approximately equal probability.\n\n\n\nIf and are equal, the method returns .\n\n\n\nIf is greater than , the input parameters are swapped but retain their inclusivity or exclusivity based on their original positions, which means the method becomes after swapping.\n\n\n\nFor example, calling is not equivalent to . returns a value between 1 and 10 because 10 becomes an inclusive maximum and 0 becomes an exclusive minimum.\n\n\n\nThere is a overload of this function that operates slightly differently, especially regarding the range maximum, refer to its docs above.\n\n\n\nRefer to Random for details on the algorithm, and for examples of how may differ from other random number generators."
    },
    {
        "link": "https://wayline.io/blog/unity-random-range",
        "document": "As a game developer, I constantly use randomness to add variety to my game projects. Randomness can make or break a player’s experience. It plays a crucial role in generating complex, exciting games.\n\nYou can use randomness to make procedural levels, determine enemy behavior, or create surprise events in your game.\n\nUnity, one of the leading game development platforms, offers an invaluable tool: Unity Random.Range. This comprehensive guide will delve deep into this function. We will explore its applications and best practices and analyze how you can use it to make a better game.\n\nWhat is Random Range in Unity?\n\nGame developers know Unity for its versatility and user-friendliness. This powerful game engine empowers developers with tools that streamline the creative process. The Random.Range function is a straightforward method to generate randomness in your games. By the end of this article, you’ll understand how to use this function. And you’ll appreciate its significance in creating immersive gaming experiences. In C#, generating random numbers is actually pretty easy.\n\nAt its core, Unity random.range is a function that generates random numbers within a specified range. This function is a game developer’s Swiss army knife. It is capable of bringing diversity and unpredictability into various aspects of gameplay.\n\nLet’s start our journey by exploring the fundamental elements of this function.\n\nTo use Unity random.range, you should first be familiar with its syntax.\n\nHow do you generate a random number range in Unity?\n\nHere’s an example of how you can use this method to get a random number between 0 (inclusive) and 5 (exclusive). This number will be greater than or equal to 0. It will always be less than 5.\n\nInclusive of the minimum, exclusive of the maximum. One feature of Unity random.range is how it handles the min and max values.\n\nThis method includes the minimum value (min). But, it excludes the maximum value (max).\n\nLet’s take an example. If you call the method with a min of 0 and a max of 10, you can get a value of exactly 0, but you can never get a result of exactly 10.\n\nIf you know this subtlety, you can use the random range function without surprising bugs or errors.\n\nNow that we’ve covered the basics, let’s explore how you can apply the Unity random.range method in various game development scenarios.\n\nCreating diverse and unpredictable terrain is crucial in open-world games. Unity random.range can determine the elevation, texture, and other attributes of terrain features. Using this random number generator enables you as the developer to ensure that each playthrough, or even each level, is unique.\n\nFor engaging gameplay, enemies should exhibit varied behaviors. By using Unity random.range, you can randomize their actions. Randomization can make encounters less predictable and more exciting for players.\n\nIn many games, loot and rewards are essential to the gameplay system. The Random Range function can determine item type, quantity, and rarity. Randomizing the loot drops keeps players engaged as they strive for valuable loot.\n\nFrom weather changes to day-night cycles, environmental effects contribute to immersion. Unity random.range can control these effects. You can use these effects to improve the realism of your game and help players get more engaged.\n\nYou must surprise players and keep them on their toes. Random events can do this for you. The Random.Range function can create unforgettable moments, whether a sudden ambush or a rare item drop.\n\nTo make the most of Unity random.range, consider these best practices:\n\nFor reproducibility, set a seed value using Random.InitState(). When you call the Random.Range method, Unity uses the current state, then returns a number. Then, it sets a new state.\n\nWhen you use Random.InitState(), you will generate the same sequence of random numbers every time. Consistency in randomness makes it easier to debug, test, or create consistent experiences for your players.\n\nRunning this code will consistently generate the same value for the two Debug Logs: 26.\n\nWhile randomness adds excitement, excessive randomness can frustrate players. Strike a balance to maintain gameplay enjoyment.\n\nRandomness can introduce unexpected issues. Rigorously test your game to ensure random elements enhance the player experience rather than detract from it.\n\nHow can I use Unity random.range in a 2D game for generating random enemy spawn points?\n\nTo spawn enemies randomly in a 2D game, define a range for X and Y coordinates using random.range. Always ensure that the positions are within the game boundaries and that you’re spawning the enemy in a logical spot. Then, use the Instantiate method to spawn the enemy.\n\nHow do I generate random colors for in-game objects with Unity random.range?\n\nYes. You can use Unity random.range to generate RGB values for colors, allowing you to create a broad spectrum of hues. You can also use it to generate random HSV values that Unity automatically converts to RGB! Using HSV values gives you more control over the final hue, saturation, and value range.\n\nHere’s an example of using Random.Range with RGB Colors\n\nYes. This method works in both 2D and 3D modes. Since the Random.Range method is a simple utility, you can use the output in any context. It makes the random range a versatile tool for all types of games.\n\nWhat is Random.Range(0, 10) in Unity?\n\nWhen you call Random.Range(0,10) in Unity, you will get a random integer number between 0 (inclusive) and 10 (exclusive). So, you can get a result equal to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9.\n\nHow can I create a random chance-based event using Unity random.range?\n\nAssign a probability threshold to each event. Then, generate a random number with Unity random.range. Finally, trigger the event if the generated number falls within the desired range.\n\nHere’s an example of how you can do that:\n\nHow can I use Unity random.range to create procedural audio effects?\n\nYes. Unity random.range deals with numbers. So, you can use its output to select audio parameters randomly. With randomness, you gain the power of procedural audio generation. For example:\n\nIs there a performance impact when using Unity random.range in a game?\n\nYes, but it is small. The performance impact of Random.Range is minimal. Excessive use can affect performance.\n\nIf you need many random values, you can optimize by precomputing them. In general, try to avoid optimizing early. Identify specific problems using the Profiler, then optimize those pieces of code.\n\nWhat is the difference between Random and System.Random in Unity?\n\nUnityEngine.Random is a random number generator provided by Unity. System.Random is a random number generator provided by Microsoft (.NET). You can use whichever implementation you prefer.\n\nIn game development, harnessing the power of randomness can elevate your projects to new heights. Unity random.range is a versatile tool. This tool empowers developers to infuse their games with unpredictability and excitement. Master its application and adhere to best practices. Then, you can create immersive gaming experiences that keep players returning for more.\n\nUnleash the power of the Random.Range method in your game development journey. Watch your games come to life with creativity, unpredictability, and endless possibilities.\n\nTo continue to improve your games, level up your other Unity skills with our Unity basics series:\n• How to get the distance between two objects\n• How to use the Unity SetActive Method\n• How to use Unity MoveTowards method\n• How to GetComponentInParent in Unity\n• How to GetChildren of a Transform in Unity"
    },
    {
        "link": "https://docs.unity3d.com/2023.1/Documentation/Manual/class-Random.html",
        "document": "The Random class provides you with easy ways of generating various commonly required types of random values.\n\nThis page provides an overview of the Random class and its common uses when scripting with it. For an exhaustive reference of every member of the Random class and further technical details about it, see the Random script reference.\n\nFollow the links below for further details and examples of these useful methods.\n\ngives you a random floating point number between 0.0 and 1.0. A common usage is to convert it to a number between zero and a range of your choosing by multiplying the result.\n\ngives you a random number between a minimum and maximum value that you provide. It returns either an integer or a float, depending on whether the min and max values provided are integers or floats.\n\nreturns a randomly selected point inside a circle with a radius of 1 (Again you can multiply the result to get a random point within a circle of any size).\n\nreturns a randomly selected point on the surface of a sphere with a radius of 1.\n\nUnity’s random class also offers a few other types of random value.\n\nPicking an array element at random boils down to choosing a random integer between zero and the array’s maximum index value (which is equal to the length of the array minus one). This is easily done using the built-in function:-\n\nNote that returns a value from a range that includes the first parameter but excludes the second, so using here gives the correct result.\n\nSometimes, you need to choose items at random but with some items more likely to be chosen than others. For example, an NPC may react in several different ways when it encounters a player:-\n\nYou can visualize these different outcomes as a paper strip divided into sections each of which occupies a fraction of the strip’s total length. The fraction occupied is equal to the probability of that outcome being chosen. Making the choice is equivalent to picking a random point along the strip’s length (say by throwing a dart) and then seeing which section it is in.\n\nIn the script, the paper strip is actually an array of floats that contain the different probabilities for the items in order. The random point is obtained by multiplying by the total of all the floats in the array (they need not add up to 1; the significant thing is the relative size of the different values). To find which array element the point is “in”, firstly check to see if it is less than the value in the first element. If so, then the first element is the one selected. Otherwise, subtract the first element’s value from the point value and compare that to the second element and so on until the correct element is found. In code, this would look something like the following:-\n\nNote that the final return statement is necessary because can return a result of 1. In this case, the search will not find the random point anywhere. Changing the line\n\n…to a less-than-or-equal test would avoid the extra return statement but would also allow an item to be chosen occasionally even when its probability is zero.\n\nThe array of floats method works well if you have discrete outcomes, but there are also situations where you want to produce a more continuous result - say, you want to randomize the number of gold pieces found in a treasure chest, and you want it to be possible to end up with any number between 1 and 100, but to make lower numbers more likely. Using the array-of-floats method to do this would require that you set up an array of 100 floats (i.e. sections on the paper strip) which is unwieldy; and if you aren’t limited to whole numbers but instead want any number in the range, it’s impossible to use that approach.\n\nA better approach for continuous results is to use an to transform a ‘raw’ random value into a ‘weighted’ one; by drawing different curve shapes, you can produce different weightings. The code is also simpler to write:\n\nA ‘raw’ random value between 0 and 1 is chosen by reading from . It is then passed to , which treats it as a horizontal coordinate, and returns the corresponding vertical coordinate of the curve at that horizontal position. Shallow parts of the curve have a greater chance of being picked, while steeper parts have a lower chance of being picked.\n\nNotice that these curves are not probability distribution curves like you might find in a guide to probability theory, but are more like inverse cumulative probability curves.\n\nBy defining a public variable on one of your scriptsA piece of code that allows you to create your own Components, trigger game events, modify Component properties over time and respond to user input in any way you like. More info\n\nSee in Glossary, you will be able to see and edit the curve through the InspectorA Unity window that displays information about the currently selected GameObject, asset or project settings, allowing you to inspect and edit the values. More info\n\nSee in Glossary window visually, instead of needing to calculate values.\n\nThis technique produces floating-point numbers. If you want to calculate an integer result - for example, you want 82 gold pieces, rather than 82.1214 gold pieces - you can just pass the calculated value to a function like .\n\nA common game mechanic is to choose from a known set of items but have them arrive in random order. For example, a deck of cards is typically shuffled so they are not drawn in a predictable sequence. You can shuffle the items in an array by visiting each element and swapping it with another element at a random index in the array:-\n\nChoosing from a Set of Items Without Repetition\n\nA common task is to pick a number of items randomly from a set without picking the same one more than once. For example, you may want to generate a number of NPCs at random spawn points but be sure that only one NPC gets generated at each point. This can be done by iterating through the items in sequence, making a random decision for each as to whether or not it gets added to the chosen set. As each item is visited, the probability of its being chosen is equal to the number of items still needed divided by the number still left to choose from.\n\nAs an example, suppose that ten spawn points are available but only five must be chosen. The probability of the first item being chosen will be 5 / 10 or 0.5. If it is chosen then the probability for the second item will be 4 / 9 or 0.44 (ie, four items still needed, nine left to choose from). However, if the first was not chosen then the probability for the second will be 5 / 9 or 0.56 (ie, five still needed, nine left to choose from). This continues until the set contains the five items required. You could accomplish this in code as follows:-\n\nNote that although the selection is random, items in the chosen set will be in the same order they had in the original array. If the items are to be used one at a time in sequence then the ordering can make them partly predictable, so it may be necessary to shuffle the array before use.\n\nA random point in a cubic volume can be chosen by setting each component of a Vector3 to a value returned by :-\n\nThis gives a point inside a cube with sides one unit long. The cube can be scaled simply by multiplying the X, Y and Z components of the vector by the desired side lengths. If one of the axes is set to zero, the point will always lie within a single plane. For example, picking a random point on the “ground” is usually a matter of setting the X and Z components randomly and setting the Y component to zero.\n\nWhen the volume is a sphere (ie, when you want a random point within a given radius from a point of origin), you can use multiplied by the desired radius:-\n\nNote that if you set one of the resulting vector’s components to zero, you will not get a correct random point within a circle. Although the point is indeed random and lies within the right radius, the probability is heavily biased toward the center of the circle and so points will be spread very unevenly. You should use for this task instead:-"
    },
    {
        "link": "https://gamedevbeginner.com/how-to-use-random-values-in-unity-with-examples",
        "document": "Generating a random value in Unity can be very simple.\n\nWhich is useful, because in many games, random numbers are extremely important for creating varied gameplay and behaviours.\n\nWhile generating a random number in Unity can be very straightforward, actually randomizing different parts of your game can be more complex.\n\nFor example, perhaps you want to place an object at a random position.\n\nMaybe you want to create weighted probability, so that enemies drop rare loot less often than they drop common rewards.\n\nAnd what if you’re using random values to generate objects and worlds. How can you recreate predictable results, using random data?\n\nBut don’t worry, because in this article I’ll show you everything you need to know to get started with random values in Unity and how you can use them to add variation to different parts of your game.\n\nHere’s what you’ll find on this page:\n\nGenerating a random number in Unity is, generally, very straightforward.\n\nFor most uses, the Random Range function, which returns a random value between two numbers, will be all you need to use.\n\nHow to use Random Range in Unity\n\nTo create a single random number using the Random Range function, simply pass in the minimum and maximum values that you want to use.\n\nThe Random Range function is available in two versions, which will return either a random float value or a random integer, depending on the type of values that are passed into it.\n\nSo, for example, to generate a random integer, simply pass in whole numbers when using the Random Range function.\n\nThis works even if the target value is a float, because the random number that is returned is a whole number, an integer.\n\nWhich looks like this:\n\nTo generate a random float, simply pass float values into the function instead.\n\nThere may be times when generating a random number that you’d like to avoid picking the same number twice in a row.\n\nThere are lots of reasons you might want to do this but, generally speaking, it’s useful for avoiding repetition when you’re trying to create variation.\n\nSo, how does it work?\n\nTypically, it involves storing the last value that was picked and simply picking again if it’s chosen twice in a row.\n\nMost of the time, checking once and picking again if the value is the same will be enough to avoid repeated random results.\n\nHowever… if there’s a high chance that the same number could be picked twice in a row, because you’re picking from a small range, for example, one check may not be enough to reliably avoid repeated results.\n\nInstead, if it’s more likely that a number will be repeated, making multiple attempts to pick a new value can avoid repetition.\n\nThis works by checking to see if the new random number is the same as the last and, if it is, makes multiple attempts to pick a new number, up to a maximum of ten.\n\nIt’s often a good idea to limit checks like this to a maximum number of attempts.\n\nThat way, if a different number can’t actually be picked, the process is allowed to fail, avoiding an infinite loop.\n\nHow many attempts you should make will depend on how likely it is that a value could be repeated and whether or not it’s actually a problem if it is.\n\nRandom Range is extremely useful for generating a random number inside a range of values.\n\nHowever, there may also be times that you only want to generate a single float value between 0 and 1.\n\nIn which case, you don’t need to use Random Range to do it.\n\nMany of Unity’s settings, properties and values, typically accept a float value that’s between 0 and 1.\n\nBecause of this, it can be convenient to build float variables into scripts using the same scale, where a value can be 0, 1 or anything in between.\n\nSo, it makes sense that Unity’s Random Class also provides an option to generate a random float between 0 and 1, using Random Value.\n\nUsing the Random Value property of the Random class is more convenient, and can be more efficient, than specifying a range between 0 and 1.\n\nWhat’s more, the Random Value property can easily be checked against to create simple probability.\n\nFor example, I could use Random Value to test an outcome with a 30% chance of success.\n\nThe same method can be used to create probability with a 50/50 chance of success, which can be useful for randomly deciding if something is true or false.\n\nRandomly set a boolean value to true or false\n\nUsing Random Value, it’s possible to randomly set a boolean value to true or false.\n\nThis works by simply checking if the Random Value is more than 0.5, to create a 50/50 probability, setting the boolean to true if it is or false if it’s not.\n\nYou may already know that random numbers in Unity are not truly random. Instead, the numbers that Unity’s Random Class uses are generated from a starting number, a Seed, which is an integer value, that’s set when the game starts. The seed that Unity uses is always different, generating a different set of random numbers every time the game starts. The Seed value can also be set manually using the Init State function. Which generates a set of random numbers that are specific to that Seed. What this means is that one Seed will generate the same random numbers, in the same order, whenever it’s used. So, for example, setting the Seed to “1234” before generating three random values will produce the same results every time. Which means that a specific set of random numbers can be accurately recreated using the same Seed value. Generating predictable random results in this way can be very useful, as it allows you to recreate supposedly random objects, so long as the Seed, and the process used to create the object, are the same. Because Unity’s Random Class is Static, any script can access the same set of random values. And while this doesn’t necessarily cause a problem in isolation, in a more complex project any other script could easily alter the order of the randomly generated numbers, simply by requesting a random number or by resetting the Seed value. For this reason, if predictable randomness is important to you, it can make sense to use a local instance of the Random Class, not the Static class that other scripts can access, so that it can be used, and controlled, in isolation. For more information, try Edward Rowe’s article on predictable number generation here.\n\nRandom numbers are the foundation of randomisation in Unity.\n\nBut, chances are, that to create real variation, you’ll likely want to use those numbers to modify actual objects in your game, such as how they look, where they are, or how they behave.\n\nSo how can you use random numbers to change an object’s position, its rotation, or even its colour?\n\nWhile there isn’t a convenient function to randomise Vector 3 values in Unity, to create a random position for example, it is possible to create a random Vector 3 by randomising each of its values independently.\n\nThis works by randomising each of the floats that make up its X, Y and Z values, one by one.\n\nFor this to work, you’ll still need to know the possible range of each float value which, when combined, will define the area in which the random position can be picked.\n\nOne way to do this is to pick two points in the world, a minimum position and a maximum position.\n\nThe distances between these positions essentially form a cube-like area:\n\nThen, when the individual parts of the Vector 3 are randomised, a random position that’s inside the cube area will be returned.\n\nBut what if you don’t want to place an object randomly in a cube?\n\nWhat if, for example, you’d like to generate a position in a sphere instead?\n\nWhile there isn’t a built-in method for creating random Vector 3 values, the Random Class does include functions for generating a random point inside a unit sphere (3D) or a unit circle (2D).\n\nThe Inside Unit Sphere function, for example, will return a point inside a sphere with a radius of 1 unit, up to and including the sphere’s surface.\n\nSo, all you need to do to create a random position within a sphere area is multiply the random unit position that’s returned by the radius of the sphere area that you want to create.\n\nThis works by defining a point of origin, which is where you want the sphere to start from, and a radius, which is the distance from the origin to the edge of the sphere, in this case, 2 units.\n\nWhich, when used with a large number of objects, looks like this:\n\nThe Inside Unit Sphere function will return a random point inside of a sphere area.\n\nHowever, it’s also possible to return a random position on the outside of a sphere only, using the On Unit Sphere function.\n\nThe On Unit Sphere function works in the same way as Inside Unit Sphere, except that the random position that’s returned will be somewhere on the sphere’s surface, instead of inside it.\n\nThis can be useful for picking a random direction.\n\nBoth On Unit Sphere and Inside Unit Sphere can be used to generate a random direction vector.\n\nThe difference is that On Unit Sphere will always produce a vector with a magnitude of 1, whereas Inside Unit Sphere will generate a random direction vector with a magnitude of up to 1.\n\nThis means that if you used the direction vector that was generated to create movement, the value returned by Inside Unit Sphere would also randomise the movement speed, while On Unit Sphere would return a consistent speed in a random direction.\n\nWhile using Inside Unit Sphere and On Unit Sphere can be useful for creating a direction vector at random, if all you want to do is create a random rotation, there’s already a function for that.\n\nIt returns a Quaternion value, which means that it can be used directly with the rotation property of an object to set a new, random, rotation.\n\nAlternatively, a higher quality random rotation function, Rotation Uniform, is also available:\n\nThis generally returns a more uniform result but at the cost of performance, as it’s reportedly 40% slower than Random Rotation.\n• How to Rotate in Unity (complete beginner’s guide)\n\nJust as it’s possible to randomise positions and rotations in Unity, you can use the Random Class to generate random colours as well.\n\nThere are two ways to generate a random colour in Unity.\n\nThis works by using either the built-in Random Color HSV function or by setting a new colour using randomised RGB values.\n\nEach method randomises colours in a slightly different way, producing different results.\n\nThe first method uses the built-in Random Color HSV function, which will return a random colour based on HSV values\n\nWhich you can then use to change the colour of an object’s Renderer Material.\n\nHSV colours in Unity are made up of 3 float values, for Hue, Saturation and Value (brightness), ranging between 0 and 1.\n• Hue, determines the colour, measured as a point on a spectrum that starts and ends with Red.\n• Saturation affects how much of the colour is added, from 0, which is white, to 1, which is fully saturated.\n• Value, controls the brightness of the colour, between 0, which is black, and 1, the colour’s full brightness.\n\nBy default, the Random Color HSV function randomises all of the elements of the HSV colour, which creates colours of all hues, saturation and brightness.\n\nHowever, this can sometimes appear to produce colours that are closer to white, grey and black, more frequently than other colours.\n\nThis is because, while colour is decided by one value (Hue) the amount of White and the brightness of the colour (i.e. the amount of Black) are decided by individual values.\n\nHowever, it’s possible to control how much each element of the HSV colour value is randomised by limiting its range.\n\nBringing the Minimum Saturation and the Minimum Value variables up, closer to 1, removes the possibility of creating White and Black.\n\nThis can be useful, for example, if you want to create random, bright colours, that are always fully saturated.\n\nWhich looks like this:\n\nOr, if you want to randomise a colour’s Hue and its Saturation, but not its brightness, you’ll get colours that are vivid or pale, but not dark.\n\nExcluding, or limiting some parameters of the HSV colour value can create random colours within controlled limits.\n\nHowever, what can you do if you want to also include Black and White as possible colours?\n\nHow can you randomise a colour in a way that includes Black and White as equal options, that have as much chance of being generated as Blue, Red, or any other colour?\n\nJust like with Vector 3 values, there’s no built-in function for creating a random RGB colour, but it is possible to randomly create one by randomising its individual Red, Green and Blue values.\n\nThis works by passing a Random Value, between 0 and 1, to each of the parameters of a new Color variable.\n\nRandomising colours in this way, as opposed to using the built-in Random Color HSV function, generates colours that are generally more vivid, but that can also include Black and White.\n\nThis is useful for creating random colours that can include Black and White, but with an equal chance alongside other colours.\n\nWhile the Random Class in Unity is useful for creating variation, you can also use the random numbers it generates to make probability-based decisions.\n\nFor example, you can use Random to choose an item from a list, make weighted decisions or test if an action succeeds or fails based on a probability percentage.\n\nFor example, using a random number to choose an element from an Array, such as a list of names, for example, is fairly straightforward.\n\nIt works by generating a random number between 0 and the Length of the Array, and using it as an Array index number.\n\nThis works because the last index of an Array is one lower than the value of its Length so, because the range of random integers is exclusive, it won’t overshoot.\n\nChoosing a random element from a List works in the same way, by using the List’s Count as an upper limit instead of Length.\n\nHowever, when using a List, you also have the option of removing an element once it’s been selected.\n\nThis is because Lists, unlike Arrays, can be dynamically resized.\n\nWhich means that, by taking an option out, you can create a random selection process that works through all of the available options, until there aren’t any left.\n\nThis works by using the same index to read and remove the List element, until there are none left.\n\nSelecting an item randomly from a List is useful for picking an element from a range of options, equally.\n\nHowever, what if you want to select an item based on probability, where one item is more likely to be picked than another?\n\nGenerally speaking, there are two main approaches to making weighted decisions in Unity.\n\nWhich one you use will depend on what it is you’re trying to do.\n\nFor example, one method is to determine a probability percentage that an item can be chosen and then check against it.\n\nIn Unity, basic probability can be created by deciding how likely something is to happen, expressed as a percentage, and then simply checking against it with a random number.\n\nThis is useful for creating loot drops, for example, where there’s a chance that an item could be dropped, but also a chance that you could get nothing.\n\nSo how does it work?\n\nLet’s say, for example, you created a Loot Item Class, in which each item has a Drop Chance, which is the likelihood, out of 100, that it will be dropped when an enemy is defeated.\n\nYou could use a random number between 1 and 101 (which, when using integers, includes 100 but excludes 0) to check if that item was dropped.\n\nThis works by checking which of the droppable items are eligible, by comparing each of the items’ drop chance against the random number that was selected.\n\nFor example, a random number of 50, could return a common item, whereas 90 will return nothing.\n\nHowever, a low value, such as 5, could return a common item, a rare item, or a legendary item.\n\nIn this example, when more than one item can be dropped, one of the possible choices is then returned at random.\n\nHowever, you could choose instead to let the player have all 3 items or just the best one, by sorting the remaining results.\n\nThis method of determining probability is useful for deciding how likely it is that something should happen.\n\nThere’s a probability that it could happen, and an item could be dropped, but there’s also the possibility that the player gets nothing.\n\nWeighted choices, on the other hand, are typically relative probabilities.\n\nThe chance of one thing happening is balanced by the weight of an alternative option.\n\nSo how can you make weighted random decisions in Unity?\n\nChoosing between weighted options in Unity works in a similar way to checking against probability.\n\nExcept that, instead of checking against a percentage chance that an option will be picked, an option’s weight is relative to the other options alongside it.\n\nThis means that, instead of a total of 100%, the total value against which a probability is checked is the sum of all of the options’ individual weights.\n\nSo how does it work?\n\nIn this example, each Choice is an individual class, containing a string for its name and a Weight.\n\nWhich looks like this:\n\nFor this to work, the total weight of all of the options needs to be known before choosing from them.\n\nSo you may wish to keep track of the weight of each choice as it’s added to the list.\n\nThen, to choose an option, simply generate a random number between 1 and the total weight plus 1 (to include the highest value) and seek through each option, adding up the weight as you go.\n\nFor each entry in the list, if the random number that was generated is less than the weight of the current option, plus the sum of any options before it, that’s the one to return.\n\nWhich looks like this:\n\nWeighting available options like this works well when one choice must be selected, but the probability of each entry isn’t supposed to be equal."
    },
    {
        "link": "https://discussions.unity.com/t/generate-a-random-number-not-only-once/860529",
        "document": ""
    }
]