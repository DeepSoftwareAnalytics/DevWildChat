[
    {
        "link": "https://developer.android.com/guide/fragments/lifecycle",
        "document": "Each instance has its own lifecycle. When a user navigates and interacts with your app, your fragments transition through various states in their lifecycle as they are added, removed, and enter or exit the screen.\n\nTo manage lifecycle, implements , exposing a object that you can access through the method.\n\nEach possible state is represented in the enum.\n\nBy building on top of , you can use the techniques and classes available for Handling Lifecycles with Lifecycle-Aware Components. For example, you might display the device's location on the screen using a lifecycle-aware component. This component could automatically start listening when the fragment becomes active and stop when the fragment moves to an inactive state.\n\nAs an alternative to using a , the class includes callback methods that correspond to each of the changes in a fragment's lifecycle. These include , , , , , and .\n\nA fragment's view has a separate that is managed independently from that of the fragment's . Fragments maintain a for their view, which can be accessed using or . Having access to the view's is useful for situations where a Lifecycle-aware component should only perform work while a fragment's view exists, such as observing that is only meant to be displayed on the screen.\n\nThis topic discusses the lifecycle in detail, explaining some of the rules that determine a fragment's lifecycle state and showing the relationship between the states and the fragment lifecycle callbacks.\n\nWhen a fragment is instantiated, it begins in the state. For a fragment to transition through the rest of its lifecycle, it must be added to a . The is responsible for determining what state its fragment should be in and then moving them into that state.\n\nBeyond the fragment lifecycle, is also responsible for attaching fragments to their host activity and detaching them when the fragment is no longer in use. The class has two callback methods, and , that you can override to perform work when either of these events occur.\n\nThe callback is invoked when the fragment has been added to a and is attached to its host activity. At this point, the fragment is active, and the is managing its lifecycle state. At this point, methods such as return this fragment.\n\nis always called before any Lifecycle state changes.\n\nThe callback is invoked when the fragment has been removed from a and is detached from its host activity. The fragment is no longer active and can no longer be retrieved using .\n\nis always called after any Lifecycle state changes.\n\nNote that these callbacks are unrelated to the methods and . For more information on these methods, see Fragment transactions.\n\nWhen determining a fragment's lifecycle state, considers the following:\n• A fragment's maximum state is determined by its . A fragment cannot progress beyond the state of its .\n• As part of a , you can set a maximum lifecycle state on a fragment using .\n• A fragment's lifecycle state can never be greater than its parent. For example, a parent fragment or activity must be started before its child fragments. Likewise, child fragments must be stopped before their parent fragment or activity.\n\nFigure 1 shows each of the fragment's states and how they relate to both the fragment's lifecycle callbacks and the fragment's view .\n\nAs a fragment progresses through its lifecycle, it moves upward and downward through its states. For example, a fragment that is added to the top of the back stack moves upward from to to . Conversely, when a fragment is popped off of the back stack, it moves downward through those states, going from to to and finally .\n\nWhen moving upward through its lifecycle states, a fragment first calls the associated lifecycle callback for its new state. Once this callback is finished, the relevant is emitted to observers by the fragment's , followed by the fragment's view , if it has been instantiated.\n\nWhen your fragment reaches the state, it has been added to a and the method has already been called.\n\nThis would be the appropriate place to restore any saved state associated with the fragment itself through the fragment's . Note that the fragment's view has not been created at this time, and any state associated with the fragment's view should be restored only after the view has been created.\n\nThis transition invokes the callback. The callback also receives a argument containing any state previously saved by . Note that has a value the first time the fragment is created, but it is always non-null for subsequent recreations, even if you do not override . See Saving state with fragments for more details.\n\nThe fragment's view is created only when your provides a valid instance. In most cases, you can use the fragment constructors that take a , which automatically inflates the view at the appropriate time. You can also override to programmatically inflate or create your fragment's view.\n\nIf and only if your fragment's view is instantiated with a non-null , that is set on the fragment and can be retrieved using . The is then updated with the newly corresponding with the fragment's view. The lifecycle callback is also called at this time.\n\nThis is the appropriate place to set up the initial state of your view, to start observing instances whose callbacks update the fragment's view, and to set up adapters on any or instances in your fragment's view.\n\nAfter the fragment's view has been created, the previous view state, if any, is restored, and the view's is then moved into the state. The view lifecycle owner also emits the event to its observers. Here you should restore any additional state associated with the fragment's view.\n\nThis transition also invokes the callback.\n\nIt is strongly recommended to tie Lifecycle-aware components to the state of a fragment, as this state guarantees that the fragment's view is available, if one was created, and that it is safe to perform a on the child of the fragment. If the fragment's view is non-null, the fragment's view is moved to immediately after the fragment's is moved to .\n\nWhen the fragment becomes , the callback is invoked.\n\nWhen the fragment is visible, all and effects have finished, and the fragment is ready for user interaction. The fragment's moves to the state, and the callback is invoked.\n\nThe transition to is the appropriate signal to indicate that the user is now able to interact with your fragment. Fragments that are not should not manually set focus on their views or attempt to handle input method visibility.\n\nWhen a fragment moves downward to a lower lifecycle state, the relevant is emitted to observers by the fragment's view , if instantiated, followed by the fragment's . After a fragment's lifecycle event is emitted, the fragment calls the associated lifecycle callback.\n\nAs the user begins to leave the fragment, and while the fragment is still visible, the s for the fragment and for its view are moved back to the state and emit the event to their observers. The fragment then invokes its callback.\n\nOnce the fragment is no longer visible, the s for the fragment and for its view are moved into the state and emit the event to their observers. This state transition is triggered not only by the parent activity or fragment being stopped, but also by the saving of state by the parent activity or fragment. This behavior guarantees that the event is invoked before the fragment's state is saved. This makes the event the last point where it is safe to perform a on the child .\n\nAs shown in figure 2, the ordering of the callback and the saving of the state with differs based on API level. For all API levels prior to API 28, is invoked before . For API levels 28 and higher, the calling order is reversed.\n\nAfter all of the exit animations and transitions have completed, and the fragment's view has been detached from the window, the fragment's view is moved into the state and emits the event to its observers. The fragment then invokes its callback. At this point, the fragment's view has reached the end of its lifecycle and returns a value.\n\nAt this point, all references to the fragment's view should be removed, allowing the fragment's view to be garbage collected.\n\nIf the fragment is removed, or if the is destroyed, the fragment's is moved into the state and sends the event to its observers. The fragment then invokes its callback. At this point, the fragment has reached the end of its lifecycle.\n\nFor more information related to the fragment lifecycle, see the following additional resources."
    },
    {
        "link": "https://developer.android.com/topic/libraries/architecture/lifecycle",
        "document": "Save and categorize content based on your preferences.\n\nLifecycle-aware components perform actions in response to a change in the lifecycle status of another component, such as activities and fragments. These components help you produce better-organized, and often lighter-weight code, that is easier to maintain.\n\nA common pattern is to implement the actions of the dependent components in the lifecycle methods of activities and fragments. However, this pattern leads to a poor organization of the code and to the proliferation of errors. By using lifecycle-aware components, you can move the code of dependent components out of the lifecycle methods and into the components themselves.\n\nThe package provides classes and interfaces that let you build lifecycle-aware components—which are components that can automatically adjust their behavior based on the current lifecycle state of an activity or fragment.\n\nMost of the app components that are defined in the Android Framework have lifecycles attached to them. Lifecycles are managed by the operating system or the framework code running in your process. They are core to how Android works and your application must respect them. Not doing so may trigger memory leaks or even application crashes.\n\nImagine we have an activity that shows the device location on the screen. A common implementation might be like the following:\n\nEven though this sample looks fine, in a real app, you end up having too many calls that manage the UI and other components in response to the current state of the lifecycle. Managing multiple components places a considerable amount of code in lifecycle methods, such as and , which makes them difficult to maintain.\n\nMoreover, there's no guarantee that the component starts before the activity or fragment is stopped. This is especially true if we need to perform a long-running operation, such as some configuration check in . This can cause a race condition where the method finishes before the , keeping the component alive longer than it's needed.\n\nThe package provides classes and interfaces that help you tackle these problems in a resilient and isolated way.\n\nis a class that holds the information about the lifecycle state of a component (like an activity or a fragment) and allows other objects to observe this state.\n\nuses two main enumerations to track the lifecycle status for its associated component:\n\nThink of the states as nodes of a graph and events as the edges between these nodes.\n\nA class can monitor the component's lifecycle status by implementing and overriding corresponding methods such as , , etc. Then you can add an observer by calling the method of the class and passing an instance of your observer, as shown in the following example:\n\nIn the example above, the object implements the interface, which is explained in the following section.\n\nis a single method interface that denotes that the class has a . It has one method, , which must be implemented by the class. If you're trying to manage the lifecycle of a whole application process instead, see .\n\nThis interface abstracts the ownership of a from individual classes, such as and , and allows writing components that work with them. Any custom application class can implement the interface.\n\nComponents that implement work seamlessly with components that implement because an owner can provide a lifecycle, which an observer can register to watch.\n\nFor the location tracking example, we can make the class implement and then initialize it with the activity's in the method. This allows the class to be self-sufficient, meaning that the logic to react to changes in lifecycle status is declared in instead of the activity. Having the individual components store their own logic makes the activities and fragments logic easier to manage.\n\nA common use case is to avoid invoking certain callbacks if the isn't in a good state right now. For example, if the callback runs a fragment transaction after the activity state is saved, it would trigger a crash, so we would never want to invoke that callback.\n\nTo make this use case easy, the class allows other objects to query the current state.\n\nWith this implementation, our class is completely lifecycle-aware. If we need to use our from another activity or fragment, we just need to initialize it. All of the setup and teardown operations are managed by the class itself.\n\nIf a library provides classes that need to work with the Android lifecycle, we recommend that you use lifecycle-aware components. Your library clients can easily integrate those components without manual lifecycle management on the client side.\n\nFragments and Activities in Support Library 26.1.0 and later already implement the interface.\n\nIf you have a custom class that you would like to make a , you can use the LifecycleRegistry class, but you need to forward events into that class, as shown in the following code example:\n• Keep your UI controllers (activities and fragments) as lean as possible. They should not try to acquire their own data; instead, use a to do that, and observe a object to reflect the changes back to the views.\n• Try to write data-driven UIs where your UI controller’s responsibility is to update the views as data changes, or notify user actions back to the .\n• Put your data logic in your class. should serve as the connector between your UI controller and the rest of your app. Be careful though, it isn't 's responsibility to fetch data (for example, from a network). Instead, should call the appropriate component to fetch the data, then provide the result back to the UI controller.\n• Use Data Binding to maintain a clean interface between your views and the UI controller. This allows you to make your views more declarative and minimize the update code you need to write in your activities and fragments. If you prefer to do this in the Java programming language, use a library like Butter Knife to avoid boilerplate code and have a better abstraction.\n• If your UI is complex, consider creating a presenter class to handle UI modifications. This might be a laborious task, but it can make your UI components easier to test.\n• Avoid referencing a or context in your . If the outlives the activity (in case of configuration changes), your activity leaks and isn't properly disposed by the garbage collector.\n• Use Kotlin coroutines to manage long-running tasks and other operations that can run asynchronously.\n\nLifecycle-aware components can make it much easier for you to manage lifecycles in a variety of cases. A few examples are:\n• Switching between coarse and fine-grained location updates. Use lifecycle-aware components to enable fine-grained location updates while your location app is visible and switch to coarse-grained updates when the app is in the background. , a lifecycle-aware component, allows your app to automatically update the UI when your user changes locations.\n• Stopping and starting video buffering. Use lifecycle-aware components to start video buffering as soon as possible, but defer playback until app is fully started. You can also use lifecycle-aware components to terminate buffering when your app is destroyed.\n• Starting and stopping network connectivity. Use lifecycle-aware components to enable live updating (streaming) of network data while an app is in the foreground and also to automatically pause when the app goes into the background.\n• Pausing and resuming animated drawables. Use lifecycle-aware components to handle pausing animated drawables when the app is in the background and resume drawables after the app is in the foreground.\n\nWhen a belongs to an or , the 's state changes to and the event is dispatched when the or 's is called.\n\nWhen a or 's state is saved via , it's UI is considered immutable until is called. Trying to modify the UI after the state is saved is likely to cause inconsistencies in the navigation state of your application which is why throws an exception if the app runs a after state is saved. See for details.\n\nprevents this edge case out of the box by refraining from calling its observer if the observer's associated isn't at least . Behind the scenes, it calls before deciding to invoke its observer.\n\nUnfortunately, 's method is called after , which leaves a gap where UI state changes are not allowed but the has not yet been moved to the state.\n\nTo prevent this issue, the class in version and lower mark the state as without dispatching the event so that any code that checks the current state gets the real value even though the event isn't dispatched until is called by the system.\n\nUnfortunately, this solution has two major problems:\n• On API level 23 and lower, the Android system actually saves the state of an activity even if it is partially covered by another activity. In other words, the Android system calls but it doesn't necessarily call . This creates a potentially long interval where the observer still thinks that the lifecycle is active even though its UI state can't be modified.\n• Any class that wants to expose a similar behavior to the class has to implement the workaround provided by version and lower.\n\nTo learn more about handling lifecycles with lifecycle-aware components, consult the following additional resources."
    },
    {
        "link": "https://medium.com/@javainiyan/mastering-fragment-lifecycle-view-lifecycle-in-android-cd0359a2bec0",
        "document": "Understanding the Fragment Lifecycle and the View Lifecycle is critical when building robust Android apps. While both lifecycles are essential, mismanaging them can lead to memory leaks, unintended UI updates, and even app crashes. In this blog, we’ll dive into the lifecycle differences and why using is the key to avoiding memory leaks when observing .\n\nLet’s begin by breaking down the concepts.\n\nThe Fragment Lifecycle controls the fragment’s existence, from creation to destruction. Key callbacks include:\n• onCreate() — Initializes the fragment. Called only once.\n• onStart() — When the fragment becomes visible.\n• onDestroy() — Cleans up resources when the fragment is permanently removed.\n\nA fragment can persist in memory even when its view is destroyed, for example when navigating away using .\n\nIn contrast, the View Lifecycle manages the fragment’s UI. Important callbacks include:\n• onViewCreated() — Where you initialize views or set up data.\n• onDestroyView() — Cleans up the view hierarchy when the user navigates away from the fragment.\n\nThe Problem with LifecycleOwner in Fragments\n\nWhen you use in fragments to observe , observers are bound to the Fragment’s Lifecycle, not the View Lifecycle. This can lead to problems:\n• Memory Leaks — When the fragment’s view is destroyed (e.g., user navigates away), the observer is still active, causing the old view to hang around in memory.\n• Unintended UI Updates — Since the observer is still active, it may attempt to update the destroyed view, leading to crashes or inconsistent UI behavior.\n\nTo prevent these issues, always use to observe in fragments. This ensures that observers are active only while the view exists, meaning:\n• No memory leaks — Observers are automatically cleaned up when the view is destroyed.\n• UI updates are safe — Updates happen only when the view is visible and ready to receive data.\n\nLet’s see how we can apply this concept using a simple example.\n\nImagine you have a fragment that displays a list of items fetched from a . Here’s how you would set it up using .\n\nIn this example:\n• We observe the ( ) using , ensuring that the observer only remains active while the fragment’s view exists.\n• When navigating away from the fragment, is called, and the observer is automatically cleaned up, preventing memory leaks.\n• When you return to the fragment, the observer is re-established, and the UI updates correctly.\n• Always use in fragments to observe . This prevents memory leaks and ensures observers are cleaned up when the view is destroyed.\n• Re-establish observers when the view is recreated (e.g., when returning to the fragment) to ensure correct UI updates.\n• Understanding the difference between the Fragment Lifecycle and the View Lifecycle is essential for building high-quality apps.\n• Use for lifecycle-bound tasks that last the entire fragment lifecycle (e.g., data fetching).\n• Use for tasks bound to the view lifecycle (e.g., updating UI via ).\n• Properly handle , , and to avoid resource leaks and unintended behavior."
    },
    {
        "link": "https://stackoverflow.com/questions/60013144/fragment-lifecycle-oncreateview-ui-elements",
        "document": "You should be inflating your UI elements within , so they should be accessible there. As long as you're only accessing UI elements within your , it's safe to inflate and use them at that point - you don't need to wait for or anything like that."
    },
    {
        "link": "https://geeksforgeeks.org/fragment-lifecycle-in-android",
        "document": "In Android, the fragment is the part of the Activity that represents a portion of the User Interface(UI) on the screen. It is the modular section of the Android activity that is very helpful in creating UI designs that are flexible in nature and auto-adjustable based on the device screen size. The UI flexibility on all devices improves the user experience and adaptability of the application. that can exist only inside an activity as its lifecycle is dependent on the lifecycle of the host activity. For example, if the host activity is paused, then all the methods and operations of the fragment related to that activity will stop functioning, the fragment is also termed a sub-activity. Fragments in Android can be added, removed, or replaced dynamically i.e., while the activity is running.\n\nBelow is the pictorial representation of fragment interaction with the activity:\n• Single Fragment: Display only one single view on the device screen. This type of fragment in android is mostly used for mobile phones.\n• List Fragment: This Fragment is used to display a list-view from which the user can select the desired sub-activity. The menu drawer of apps like Gmail is the best example of this kind of android fragment.\n• Fragment Transaction: This kind of fragments in android supports the transition from one fragment in android to another at run time. Users can switch between multiple fragments like switching tabs.\n\nThe very first method to be called when the fragment has been associated with the activity. This method executes only once during the lifetime of a fragment. \n\n When we attach fragment(child) to Main(parent) activity then it call first and then not call this method any time(like you run an app and close and reopen) simple means that this method call only one time. This method initializes the fragment by adding all the required attributes and components. System calls this method to create the user interface of the fragment. The root of the fragment’s layout is returned as the View component by this method to draw the UI. \n\n You should inflate your layout in onCreateView but shouldn’t initialize other views using findViewById in onCreateView. It indicates that the activity has been created in which the fragment exists. View hierarchy of the fragment also instantiated before this function call. The system invokes this method to make the fragment visible on the user’s device. This method is called to make the visible fragment interactive. It indicates that the user is leaving the fragment. System call this method to commit the changes made to the fragment. Method to terminate the functioning and visibility of fragment from the user’s screen. System calls this method to clean up all kinds of resources as well as view hierarchy associated with the fragment. It will call when you can attach new fragment and destroy existing fragment Resoruce It is called to perform the final clean up of fragment’s state and its lifecycle. The system executes this method to disassociate the fragment from its host activity. \n\n It will call when your fragment Destroy(app crash or attach new fragment with existing fragment)\n\nConsider Fragment-1 is A and Fragment-2 is B and A is attached to the Main Activity\n\n 1. If you can replace B with A.\n\n A’s call back:\n\n onDestroyView()\n\n onDestroy()\n\n onDetach()\n\n2. If you can replace B with A without Losing resources.\n\n A’s call back:\n\n onDestroy()\n\n onDetach()\n\nFragments in android are always embedded in Activities i.e., they are added to the layout of activity in which they reside. Multiple fragments can be added to one activity. This task can be carried out in 2 ways:\n• None Statically: Explicitly mention the fragment in the XML file of the activity. This type of fragment can not be replaced during the run time.\n• FragmentManager is used to embed fragments with activities that enable the addition, deletion, or replacement of fragments at run time.\n\nAlmost all android app uses dynamic addition of fragments as it improves the user experience. Below is the step-by-step implementation of adding 2 fragments in one activity. A default fragment will be visible when the activity appears on the screen and the user can switch between the 2 fragments at the run time.\n• None Click on File, then New => New Project.\n• None Select the minimum SDK as per your need.\n\nAll the strings which are used in the activity are listed in this file\n\nOpen the activity_main.xml file and add 2 buttons to it which will be used to switch between the 2 fragments. Further, add the fragment element in the activity layout. It is the area in which the fragments in android will be displayed.\n\nThese files contain only the onCreateView() method to inflate the UI of the fragment and returns the root of the fragment layout. If the fragment does not have any UI, it will return null.\n\nStep 5: Creating Layouts for both the fragments\n\nCreate two Layout Resource Files for both the fragments. Fragment displays a text on the screen and have a background color to differentiate their area in the Activity layout. Below is the code to implement this layout.\n\nNow, the functionality of the button to perform operations on clicking will be defined in the MainActivity class. Moreover, the code for the replacement of fragments during run time is also mentioned in this file. Below is the code to implement this step."
    },
    {
        "link": "https://developer.android.com/training/data-storage/shared-preferences",
        "document": "If you have a relatively small collection of key-values that you'd like to save, you can use the APIs. A object points to a file containing key-value pairs and provides simple methods to read and write them. Each file is managed by the framework and can be private or shared.\n\nThis page shows you how to use the APIs to store and retrieve simple values.\n\nCaution: is a modern data storage solution that you should use instead of . It builds on Kotlin coroutines and Flow, and overcomes many of the drawbacks of . is a modern data storage solution that you should use instead of. It builds on Kotlin coroutines and Flow, and overcomes many of the drawbacks of Read the DataStore guide for more information.\n\nYou can create a new shared preference file or access an existing one by calling one of these methods:\n• : Use this if you need multiple shared preference files identified by name, which you specify with the first parameter. You can call this from any in your app.\n• : Use this from an if you need to use only one shared preference file for the activity. Because this retrieves a default shared preference file that belongs to the activity, you don't need to supply a name.\n\nFor example, the following code accesses the shared preferences file that's identified by the resource string and opens it using the private mode so the file is accessible by only your app:\n\nWhen naming your shared preference files, you should use a name that's uniquely identifiable to your app. A good way to do this is prefix the file name with your application ID. For example:\n\nAlternatively, if you need just one shared preference file for your activity, you can use the method:\n\nIf you're using the API to save app settings, you should instead use to get the default shared preference file for your entire app. For more information, see the Settings developer guide.\n\nTo write to a shared preferences file, create a by calling on your .\n\nPass the keys and values you want to write with methods such as: and . Then call or to save the changes. For example:\n\nchanges the in-memory object immediately but writes the updates to disk asynchronously. Alternatively, you can use to write the data to disk synchronously. But because is synchronous, you should avoid calling it from your main thread because it could pause your UI rendering.\n\nTo retrieve values from a shared preferences file, call methods such as and , providing the key for the value you want, and optionally a default value to return if the key isn't present. For example:"
    },
    {
        "link": "https://geeksforgeeks.org/shared-preferences-in-android-with-examples",
        "document": "One of the most Interesting Data Storage options Android provides its users is Shared Preferences. Shared Preferences is the way in which one can store and retrieve small amounts of primitive data as key/value pairs to a file on the device storage such as String, int, float, Boolean that make up your preferences in an XML file inside the app on the device storage. Shared Preferences can be thought of as a dictionary or a key/value pair. For example, you might have a key being “username” and for the value, you might store the user’s username. And then you could retrieve that by its key (here username). You can have a simple shared preference API that you can use to store preferences and pull them back as and when needed. The shared Preferences class provides APIs for reading, writing, and managing this data. A sample GIF is given below to get an idea about what we are going to do in this article.\n\nShared Preferences are suitable for different situations. For example, when the user’s settings need to be saved or to store data that can be used in different activities within the app. As you know, onPause() will always be called before your activity is placed in the background or destroyed, So for the data to be saved persistently, it’s preferred to save it in onPause(), which could be restored in onCreate() of the activity. The data stored using shared preferences are kept private within the scope of the application. However, shared preferences are different from that activity’s instance state.\n\nHow are Shared Preferences different from Saved Instance State?\n\nThe first thing we need to do is to create one shared preferences file per app. So name it with the package name of your app- unique and easy to associate with the app. When you want to get the values, call the getSharedPreferences() method. Shared Preferences provide modes of storing the data (private mode and public mode). It is for backward compatibility- use only MODE_PRIVATE to be secure.\n• SharedPreferences.Editor : Interface used to write(edit) data in the SP file. Once editing has been done, one must commit() apply() the changes made to the file.\n• SharedPreferences.OnSharedPreferenceChangeListener() : Called when a shared preference is changed, added, or removed. This may be called even if a preference is set to its existing value. This callback will be run on your main thread.\n• contains(String key) : This method is used to check whether the preferences contain a preference.\n• edit() : This method is used to create a new Editor for these preferences, through which you can make modifications to the data in the preferences and atomically commit those changes back to the SharedPreferences object.\n• getAll() : This method is used to retrieve all values from the preferences.\n• getBoolean(String key, boolean defValue) : This method is used to retrieve a boolean value from the preferences.\n• getFloat(String key, float defValue) : This method is used to retrieve a float value from the preferences.\n• getInt(String key, int defValue) : This method is used to retrieve an int value from the preferences.\n• getLong(String key, long defValue) : This method is used to retrieve a long value from the preferences.\n• getString(String key, String defValue) : This method is used to retrieve a String value from the preferences.\n• getStringSet(String key, Set defValues) : This method is used to retrieve a set of String values from the preferences.\n• registerOnSharedPreferencechangeListener(SharedPreferences.OnSharedPreferencechangeListener listener) : This method is used to register a callback to be invoked when a change happens to a preference.\n• unregisterOnSharedPreferencechangeListener(SharedPreferences.OnSharedPreferencechangeListener listener) : This method is used to unregister a previous callback.\n\nIf you don’t know how to create a new project in Android Studio then you can refer to How to Create/Start a New Project in Android Studio?\n\nBelow is the small demo for Shared Preferences. In this particular demo, there are two EditTexts, which save and retain the data entered earlier in them. This type of feature can be seen in applications with forms. Using Shared Preferences, the user will not have to fill in details again and again. Invoke the following code inside the activity_main.xml file to implement the UI.\n\nThis file will be used to handle the two of the EditText to save the data entered by the user inside the SharedPreferences. Below is the code for the MainActivity file. Comments are added inside the code to understand the code in more detail."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/android-shared-preferences-example-tutorial",
        "document": "In this tutorial we’ll use Shared Preferences in our android application to store data in the form of key-value pair. n\n\nShared Preferences allows activities and applications to keep preferences, in the form of key-value pairs similar to a Map that will persist even when the user closes the application. Android stores Shared Preferences settings as XML file in shared_prefs folder under DATA/data/{application package} directory. The DATA folder can be obtained by calling . SharedPreferences is application specific, i.e. the data is lost on performing one of the following options:\n• on clearing the application data (through Settings)\n\nAs the name suggests, the primary purpose is to store user-specified configuration details, such as user specific settings, keeping the user logged into the application. To get access to the preferences, we have three APIs to choose from:\n• getPreferences() : used from within your Activity, to access activity-specific preferences\n• getSharedPreferences() : used from within your Activity (or other application Context), to access application-level preferences\n• getDefaultSharedPreferences() : used on the PreferenceManager, to get the shared preferences that work in concert with Android’s overall preference framework\n\nIn this tutorial we’ll go with . The method is defined as follows: PREFS_NAME is the name of the file. mode is the operating mode. Following are the operating modes applicable:\n• MODE_PRIVATE: the default mode, where the created file can only be accessed by the calling application\n• MODE_WORLD_READABLE: Creating world-readable files is very dangerous, and likely to cause security holes in applications\n• MODE_WORLD_WRITEABLE: Creating world-writable files is very dangerous, and likely to cause security holes in applications\n• MODE_MULTI_PROCESS: This method will check for modification of preferences even if the Shared Preference instance has already been loaded\n• MODE_APPEND: This will append the new preferences with the already existing preferences\n• MODE_ENABLE_WRITE_AHEAD_LOGGING: Database open flag. When it is set, it would enable write ahead logging by default\n\nWe need an editor to edit and save the changes in shared preferences. The following code can be used to get the shared preferences.\n\neditor.commit() is used in order to save changes to shared preferences.\n\nData can be retrieved from saved preferences by calling getString() as follows:\n\nremove(“key_name”) is used to delete that particular value. clear() is used to remove all data\n\nThe layout consists of two EditText views which store and display name and email. The three buttons implement their respective onClicks in the .\n\nThe file is used to save and retrieve the data through keys.\n\nmypreference is the name of the file where the shared preferences key-value pair is stored. The image below shows the final output of our project: This brings an end to this tutorial. You can download the project Android Shared Preferences from the below link."
    },
    {
        "link": "https://medium.com/@EazSoftware/delving-into-android-data-storage-sharedpreferences-e39de269f7ba",
        "document": "Join us as we explore Android Data Storage. In this series, we delve into each data storage option for Android apps, uncovering their features, advantages, and ideal use cases for optimal data management in Android app development.\n\nEstablishing reliable data storage methods is crucial in Android development. While various options exist, such as Internal Storage, External Storage, and SQLite Databases, this discussion centers on SharedPreferences and its advanced alternatives: DataStore, SharedPreferences, and EncryptedSharedPreferences. Join us as we delve into these solutions, examining their intricacies, benefits, and practical applications within the Android landscape.\n\nSharedPreferences is a lightweight data storage mechanism in Android that stores key-value pairs persistently. It’s commonly used for storing small amounts of primitive data types, such as user preferences, settings, or application state. SharedPreferences provides a simple API for reading and writing data and is accessible across different components of an app. However, it lacks built-in encryption, making it less suitable for storing sensitive information.\n\nIt’s commonly used for storing user preferences, settings, or other app-related configurations. Here is some examples for it :\n\nFirst, we need to obtain an instance of SharedPreferences. We typically do this using the method, passing in a unique name for our SharedPreferences file and a mode (usually for private access within our app).\n\nis a unique identifier for the SharedPreferences file. Each SharedPreferences file is identified by a unique name, which allows multiple SharedPreferences files to coexist within the app or even across different apps on the same device. By providing a name for the SharedPreferences file, we can create separate instances of SharedPreferences to store different types of data or to maintain distinct sets of preferences/settings within the app.\n\nWe can use the interface to modify the contents of our SharedPreferences file. Let's say we want to save a user's name and email address:\n\nis used to persistently save the changes made to the SharedPreferences file. It applies the modifications asynchronously in the background and does not block the UI thread. Once is called, the changes are committed to the SharedPreferences file.\n\nIt’s important to note that is preferred over for asynchronous and non-blocking saving of SharedPreferences changes. is more efficient as it writes the changes to disk asynchronously, while writes the changes synchronously and may block the UI thread, causing potential performance issues, especially when dealing with larger datasets.\n\nTo retrieve data from SharedPreferences, we can use methods like , , , etc.\n\nThe second parameter in the method call represents the default value that will be returned if the specified preference key ( or ) is not found in the SharedPreferences file or if its value is null.\n\nTo modify existing data in SharedPreferences, we follow a similar process using the interface.\n\nIf we need to remove data from SharedPreferences, we can use the method.\n\nTo clear all data from SharedPreferences, we can use the method.\n\ncontains(): Checks if a preference with the specified key exists in the SharedPreferences file.\n\ngetAll(): Retrieves all key-value pairs from the SharedPreferences file as a Map.\n\nregisterOnSharedPreferenceChangeListener(): Registers a listener to be notified of changes to SharedPreferences values. in this example we will be updating UI based on Preference changes:\n\nHere are some additional usage patterns and best practices for working with SharedPreferences in Android development:\n\nUse Constants for Keys: Define constants for SharedPreferences keys to ensure consistency and avoid typos. This improves code readability and maintainability.\n\nEncapsulate SharedPreferences Access: Encapsulate SharedPreferences access within a dedicated class or object to abstract away implementation details and provide a clean interface for interacting with SharedPreferences.\n\nUse Default Values Effectively: Provide meaningful default values when retrieving SharedPreferences values. Avoid using empty strings ( ) or other default values that may not make sense in the context of your app.\n\nBatch Operations: If you need to perform multiple SharedPreferences operations together, batch them using a single call to minimize disk writes and improve efficiency.\n\nIf you like this post please don’t forget to follow me to get notify whenever there is new post in here :]"
    },
    {
        "link": "https://stackoverflow.com/questions/12074156/android-storing-retrieving-strings-with-shared-preferences",
        "document": "Where is your Context.\n\nIf you are getting multiple values, it may be more efficient to reuse the same instance.\n\nAnd if you are saving multiple values:\n\nNote: Saving with is better than using . The only time you need is if you require the return value, which is very rare."
    }
]