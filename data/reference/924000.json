[
    {
        "link": "https://pynput.readthedocs.io/en/latest/keyboard.html",
        "document": "The package contains classes for controlling and monitoring the keyboard.\n\nUse like this: A keyboard listener is a , and all callbacks will be invoked from the thread. Call from anywhere, raise or return from a callback to stop the listener. The parameter passed to callbacks is a , for special keys, a for normal alphanumeric keys, or just for unknown keys. When using the non-blocking version above, the current thread will continue executing. This might be necessary when integrating with other GUI frameworks that incorporate a main-loop, but when run from a script, this will cause the program to terminate immediately. The listener callbacks are invoked directly from an operating thread on some platforms, notably Windows. This means that long running procedures and blocking operations should not be invoked from the callback, as this risks freezing input for all processes. A possible workaround is to just dispatch incoming messages to a queue, and let a separate thread handle them. If a callback handler raises an exception, the listener will be stopped. Since callbacks run in a dedicated thread, the exceptions will not automatically be reraised. To be notified about callback errors, call on the listener instance: Once has been called, the listener cannot be restarted, since listeners are instances of . If your application requires toggling listening events, you must either add an internal flag to ignore events when not required, or create a new listener when resuming listening. To simplify scripting, synchronous event listening is supported through the utility class . This class supports reading single events in a non-blocking fashion, as well as iterating over all events. To read a single event, use the following code: # The event listener will be running in this block # Block at most one second 'You did not press a key within one second' To iterate over keyboard events, use the following code: # The event listener will be running in this block Please note that the iterator method does not support non-blocking operation, so it will wait for at least one keyboard event. The events will be instances of the inner classes found in . A common use case for keyboard monitors is reacting to global hotkeys. Since a listener does not maintain any state, hotkeys involving multiple keys must store this state somewhere. pynput provides the class for this purpose. It contains two methods to update the state, designed to be easily interoperable with a keyboard listener: and which can be directly passed as listener callbacks. The intended usage is as follows: This will create a hotkey, and then use a listener to update its state. Once all the specified keys are pressed simultaneously, will be invoked. Note that keys are passed through before being passed to the instance. This is to remove any modifier state from the key events, and to normalise modifiers with more than one physical button. The method is a convenience function to transform shortcut strings to key collections. Please see its documentation for more information. To register a number of global hotkeys, use the convenience class :\n\nA controller for sending virtual keyboard events to the system. The exception raised when an invalid character is encountered in the string passed to . Its first argument is the index of the character in the string, and the second the character. The exception raised when an invalid parameter is passed to either or . Its first argument is the parameter. Please note that this reflects only the internal state of this controller. See for more information. Whether any alt key is pressed. Please note that this reflects only the internal state of this controller. See for more information. Whether any ctrl key is pressed. Please note that this reflects only the internal state of this controller. See for more information. Please note that this reflects only the internal state of this controller, and not the state of the operating system keyboard buffer. This property cannot be used to determine whether a key is physically pressed. Only the generic modifiers will be set; when pressing either , or , only will be present. Use this property within a context block thus: This ensures that the modifiers cannot be modified by another thread. A key may be either a string of length 1, one of the members or a . Strings will be transformed to using . Members of will be translated to their .\n• InvalidKeyException – if the key is invalid\n• ValueError – if is a string, but its length is not keys – The keys to keep pressed. A key may be either a string of length 1, one of the members or a . Strings will be transformed to using . Members of will be translated to their . key – The key to release. If this is a string, it is passed to and the returned releases are used.\n• InvalidKeyException – if the key is invalid\n• ValueError – if is a string, but its length is not Whether any shift key is pressed, or caps lock is toggled. Please note that this reflects only the internal state of this controller. See for more information. This is equivalent to the following code:\n• InvalidKeyException – if the key is invalid\n• ValueError – if is a string, but its length is not Calls either or depending on the value of .\n• key – The key to press or release.\n• is_press (bool) – Whether to press the key. InvalidKeyException – if the key is invalid This method will send all key presses and releases necessary to type all characters in the string. InvalidCharacterException – if an untypable character is encountered Instances of this class can be used as context managers. This is equivalent to the following code: This class inherits from and supports all its methods. It will set to when created.\n• on_press (callable) – The callback to call when a button is pressed. It will be called with the argument , where is a , a or if the key is unknown.\n• on_release (callable) – The callback to call when a button is released. It will be called with the argument , where is a , a or if the key is unknown.\n• suppress (bool) – Whether to suppress events. Setting this to will prevent the input events from being passed to the rest of the system.\n• kwargs – Any non-standard platform dependent options. These should be prefixed with the platform name thus: , , or . A callable taking the arguments , where is or , and is a . This callable can freely modify the event using functions like . If this callable does not return the event, the event is suppressed system wide. A list of device paths. If this is specified, pynput will limit the number of devices checked for the capabilities needed to those passed, otherwise all system devices will be used. Passing this might be required if an incorrect device is chosen. A callable taking the arguments , where is the current message, and associated data as a KBDLLHOOKSTRUCT. If this callback returns , the event will not be propagated to the listener callback. If is called, the event is suppressed system wide. This constructor should always be called with keyword arguments. Arguments are: group should be None; reserved for future extension when a ThreadGroup class is implemented. target is the callable object to be invoked by the run() method. Defaults to None, meaning nothing is called. name is the thread name. By default, a unique name is constructed of the form “Thread-N” where N is a small decimal number. args is the argument tuple for the target invocation. Defaults to (). kwargs is a dictionary of keyword arguments for the target invocation. Defaults to {}. If a subclass overrides the constructor, it must make sure to invoke the base class constructor (Thread.__init__()) before doing anything else to the thread. Whether the listener is currently running. It must be called at most once per thread object. It arranges for the object’s run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. When this method returns, no more events will be delivered. Once this method has been called, the listener instance cannot be used any more, since a listener is a , and once stopped it cannot be restarted. To resume listening for event, a new listener must be created. Waits for this listener to become ready. A class representing various buttons that may not correspond to letters. This includes modifier keys and function keys. The actual values for these items differ between platforms. Some platforms may have additional buttons, but these are guaranteed to be present everywhere. The AltGr key. This is a modifier. The left Alt key. This is a modifier. The right Alt key. This is a modifier. A generic command button. On PC platforms, this corresponds to the Super key or Windows key, and on Mac it corresponds to the Command key. This may be a modifier. The left command button. On PC platforms, this corresponds to the Super key or Windows key, and on Mac it corresponds to the Command key. This may be a modifier. The right command button. On PC platforms, this corresponds to the Super key or Windows key, and on Mac it corresponds to the Command key. This may be a modifier. The left Ctrl key. This is a modifier. The right Ctrl key. This is a modifier. The function keys. F1 to F20 are defined. The Insert key. This may be undefined for some platforms. The Menu key. This may be undefined for some platforms. The NumLock key. This may be undefined for some platforms. The Pause/Break key. This may be undefined for some platforms. The PrintScreen key. This may be undefined for some platforms. The ScrollLock key. This may be undefined for some platforms. The left Shift key. This is a modifier. The right Shift key. This is a modifier. A represents the description of a key code used by the operating system. char – The dead key. This should be the unicode character representing the stand alone character, such as for COMBINING TILDE.\n• kwargs – Any other parameters to pass. Applies this dead key to another key and returns the result. Joining a dead key with space ( ) or itself yields the non-dead version of this key, if one exists; for example, equals and . key (KeyCode) – The key to join with this key. ValueError – if the keys cannot be joined"
    },
    {
        "link": "https://pypi.org/project/pynput",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://pynput.readthedocs.io",
        "document": "This library allows you to control and monitor input devices.\n\nIt contains subpackages for each type of input device supported:\n\nAll modules mentioned above are automatically imported into the package. To use any of them, import them from the main package:\n\npynput attempts to use the backend suitable for the current platform, but this automatic choice is possible to override.\n\nIf the environment variables or are set, their value will be used as backend name for the keyboard classes, and if or are set, their value will be used as backend name for the mouse classes.\n• , an optional backend for Linux requiring root privileges and supporting only keyboards.\n• , the default for other operating systems.\n• , a non-functional, but importable, backend. This is useful as mouse backend when using the backend."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-use-pynput-to-make-a-keylogger",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/24072790/how-to-detect-key-presses",
        "document": "I would like to make this cross-platform but, if that is not possible, then my main development target is Linux.\n\nAnyone know how to do this in a while loop?\n\nI am making a stopwatch type program in Python and I would like to know how to detect if a key is pressed (such as p for pause and s for stop), and I would not like it to be something like raw_input , which waits for the user's input before continuing execution.\n\nFor those who are on windows and were struggling to find an working answer here's mine: pynput. Here is the official \"Monitoring the keyboard\" source code example: from pynput.keyboard import Key, Listener def on_press(key): print('{0} pressed'.format( key)) def on_release(key): print('{0} release'.format( key)) if key == Key.esc: # Stop listener return False # Collect events until released with Listener( on_press=on_press, on_release=on_release) as listener: listener.join() The function above will print whichever key you are pressing plus start an action as you release the 'esc' key. The keyboard documentation is here for a more variated usage. Markus von Broady highlighted a potential issue that is: This answer doesn't require you being in the current window to this script be activated, a solution to windows would be: from win32gui import GetWindowText, GetForegroundWindow current_window = (GetWindowText(GetForegroundWindow())) desired_window_name = \"Stopwatch\" #Whatever the name of your window should be #Infinite loops are dangerous. while True: #Don't rely on this line of code too much and make sure to adapt this to your project. if current_window == desired_window_name: with Listener( on_press=on_press, on_release=on_release) as listener: listener.join()\n\nMore things can be done with module. You can install this module using Here are some of the methods: This is gonna break the loop as the key is pressed. It will wait for you to press and continue the code as it is pressed. It needs a callback function. I used because the keyboard function returns the keyboard event to that function. Once executed, it will run the function when the key is pressed. You can stop all hooks by running this line: This method is sort of already answered by user8167727 but I disagree with the code they made. It will be using the function but in an other way: It will break the loop as is pressed. You can use as well. It records all keys pressed and released until you press the key or the one you've defined in arg and returns a list of elements.\n• will read keypresses from the whole OS.\n\nI made this kind of game based on this post (using msvcr library and Python 3.7). The following is the main function of the game, that is detecting the keys pressed: import msvcrt def _secret_key(self): # Get the key pressed by the user and check if he/she wins. bk = chr(10) + \"-\"*25 + chr(10) while True: print(bk + \"Press any key(s)\" + bk) #asks the user to type any key(s) kp = str(msvcrt.getch()).replace(\"b'\", \"\").replace(\"'\", \"\") # Store key's value. if r'\\xe0' in kp: kp += str(msvcrt.getch()).replace(\"b'\", \"\").replace(\"'\", \"\") # Refactor the variable in case of multi press. if kp == r'\\xe0\\x8a': # If user pressed the secret key, the game ends. # \\x8a is CTRL+F12, that's the secret key. print(bk + \"CONGRATULATIONS YOU PRESSED THE SECRET KEYS!\\a\" + bk) print(\"Press any key to exit the game\") msvcrt.getch() break else: print(\" You pressed:'\", kp + \"', that's not the secret key(s)\n\n\") if self.select_continue() == \"n\": if self.secondary_options(): self._main_menu() break If you want the full source code of the program you can see it or download it from GitHub\n\nHere is a cross-platform solution, both blocking and non-blocking, not requiring any external libraries: import contextlib as _contextlib try: import msvcrt as _msvcrt # Length 0 sequences, length 1 sequences... _ESCAPE_SEQUENCES = [frozenset((\"\\x00\", \"\\xe0\"))] _next_input = _msvcrt.getwch _set_terminal_raw = _contextlib.nullcontext _input_ready = _msvcrt.kbhit except ImportError: # Unix import sys as _sys, tty as _tty, termios as _termios, \\ select as _select, functools as _functools # Length 0 sequences, length 1 sequences... _ESCAPE_SEQUENCES = [ frozenset((\"\\x1b\",)), frozenset((\"\\x1b\\x5b\", \"\\x1b\\x4f\"))] @_contextlib.contextmanager def _set_terminal_raw(): fd = _sys.stdin.fileno() old_settings = _termios.tcgetattr(fd) try: _tty.setraw(_sys.stdin.fileno()) yield finally: _termios.tcsetattr(fd, _termios.TCSADRAIN, old_settings) _next_input = _functools.partial(_sys.stdin.read, 1) def _input_ready(): return _select.select([_sys.stdin], [], [], 0) == ([_sys.stdin], [], []) _MAX_ESCAPE_SEQUENCE_LENGTH = len(_ESCAPE_SEQUENCES) def _get_keystroke(): key = _next_input() while (len(key) <= _MAX_ESCAPE_SEQUENCE_LENGTH and key in _ESCAPE_SEQUENCES[len(key)-1]): key += _next_input() return key def _flush(): while _input_ready(): _next_input() def key_pressed(key: str = None, *, flush: bool = True) -> bool: \"\"\"Return True if the specified key has been pressed Args: key: The key to check for. If None, any key will do. flush: If True (default), flush the input buffer after the key was found. Return: boolean stating whether a key was pressed. \"\"\" with _set_terminal_raw(): if key is None: if not _input_ready(): return False if flush: _flush() return True while _input_ready(): keystroke = _get_keystroke() if keystroke == key: if flush: _flush() return True return False def print_key() -> None: \"\"\"Print the key that was pressed Useful for debugging and figuring out keys. \"\"\" with _set_terminal_raw(): _flush() print(\"\\\\x\" + \"\\\\x\".join(map(\"{:02x}\".format, map(ord, _get_keystroke())))) def wait_key(key=None, *, pre_flush=False, post_flush=True) -> str: \"\"\"Wait for a specific key to be pressed. Args: key: The key to check for. If None, any key will do. pre_flush: If True, flush the input buffer before waiting for input. Useful in case you wish to ignore previously pressed keys. post_flush: If True (default), flush the input buffer after the key was found. Useful for ignoring multiple key-presses. Returns: The key that was pressed. \"\"\" with _set_terminal_raw(): if pre_flush: _flush() if key is None: key = _get_keystroke() if post_flush: _flush() return key while _get_keystroke() != key: pass if post_flush: _flush() return key You can use inside a while loop: You can also check for a specific key: while True: time.sleep(5) if key_pressed(\"\\x00\\x48\"): # Up arrow key on Windows. break Or wait until a certain key is pressed: >>> wait_key(\"a\") # Stop and ignore all inputs until \"a\" is pressed.\n\nUsing the package, especially on linux is not an apt solution because that package requires root privileges to run. We can easily implement this with the getkey package. This is analogous to the C language function getchar. from getkey import getkey while True: #Breaks when key is pressed key = getkey() print(key) #Optionally prints out the key. break We can add this in a function to return the pressed key. def Ginput(str): \"\"\" Now, this function is like the native input() function. It can accept a prompt string, print it out, and when one key is pressed, it will return the key to the caller. \"\"\" print(str, end='') while True: key = getkey() print(key) return key\n\nI was finding how to detect different key presses subsequently until e.g. break the program from listening and responding to different key presses accordingly. while True: if keyboard.is_pressed(\"down\"): print(\"Reach the bottom!\") if keyboard.is_pressed(\"up\"): print(\"Reach the top!\") if keyboard.is_pressed(\"ctrl+c\"): break It will cause the program to keep spamming the response text, if I pressed arrow down or arrow up. I believed because it's in a while-loop, and eventhough you only press once, but it will get triggered multiple times (as written in doc, I am awared of this after I read.) At that moment, I still haven't went to read the doc, I try adding in while True: if keyboard.is_pressed(\"down\"): print(\"Reach the bottom!\") time.sleep(0.5) if keyboard.is_pressed(\"up\"): print(\"Reach the top!\") time.sleep(0.5) if keyboard.is_pressed(\"ctrl+c\"): break But this is not a very good way as of subsequent very fast taps on the arrow key, will only trigger once instead of as many times as I pressed, because the program will sleep for 0.5 second right, meant the \"keyboard event\" happened at that 0.5 second will not be counted. So, I proceed to read the doc and get the idea to do this at this part. while True: # Wait for the next event. event = keyboard.read_event() if event.event_type == keyboard.KEY_DOWN and event.name == 'down': # do whatever function you wanna here if event.event_type == keyboard.KEY_DOWN and event.name == 'up': # do whatever function you wanna here if keyboard.is_pressed(\"ctrl+c\"): break Now, it's working fine and great! TBH, I am not deep dive into the doc, used to, but I have really forgetten the content, if you know or find any better way to do the similar function, please enlighten me! Thank you, wish you have a great day ahead!"
    },
    {
        "link": "https://simeononsecurity.com/articles/python-security-best-practices-protecting-code-data",
        "document": "Python Security Best Practices: Protecting Your Code and Data\n\nPython is a powerful and versatile programming language that is widely used for various purposes, including web development, data analysis, and machine learning. However, like any other software, Python applications are susceptible to security vulnerabilities. In this article, we will discuss best practices for Python security to help you protect your code and data from potential threats.\n\nEnsuring the security of your Python applications is crucial for several reasons:\n• None Data Protection: Python applications often handle sensitive data, such as user information, financial records, or intellectual property. A security breach can lead to data theft or unauthorized access, resulting in severe consequences.\n• None System Integrity: Vulnerabilities in Python code can be exploited to gain unauthorized access to systems, manipulate data, or disrupt services. By implementing security best practices, you can safeguard the integrity of your systems and prevent unauthorized activities.\n• None Reputation and Trust: Security breaches not only harm your organization but also erode the trust of your customers and users. By prioritizing security, you demonstrate a commitment to protecting their interests and data, enhancing your reputation as a reliable and trustworthy provider.\n\nImplementing robust security measures in your Python applications helps mitigate risks and ensures the confidentiality, integrity, and availability of your data. It is essential to establish a strong security foundation to protect against cyber threats and maintain the trust of your users and stakeholders.\n\nTo enhance the security of your Python applications, it is essential to follow these best practices:\n\nRegularly updating your Python interpreter to the latest stable version ensures that you have the latest security patches and bug fixes. The Python community actively addresses vulnerabilities and releases updates to improve the security and stability of the language. Visit the Python website to download the latest version.\n\nBy keeping your Python interpreter up to date, you benefit from the latest security enhancements that address known vulnerabilities. These updates are designed to mitigate risks and protect your applications from potential attacks. Additionally, staying updated allows you to leverage new features and improvements introduced in newer versions of Python.\n\nFor example, if you are using Python 3.7 and a critical security vulnerability is discovered, the Python community will release a patch specifically addressing that vulnerability. By updating your Python interpreter to the latest version, such as Python 3.9, you ensure that your code is protected against known security issues.\n\nUpdating your Python interpreter is a straightforward process. Simply visit the Python downloads page and choose the appropriate installer for your operating system. Follow the installation instructions provided to upgrade your Python interpreter to the latest version.\n\nRemember to periodically check for updates and make it a best practice to update your Python interpreter regularly to stay ahead of potential security risks.\n\nAdopting secure coding practices minimizes the likelihood of introducing security vulnerabilities into your Python code. By following these practices, you can strengthen the security posture of your applications and protect against common attack vectors. Let’s explore some key practices:\n• None Input Validation: Validate all user inputs to prevent injection attacks and other input-related security issues. Implement techniques such as whitelisting, input sanitization, and parameterized queries to ensure that user-supplied data is validated and safe to use. For example, when accepting user input through a web form, validate and sanitize the input before processing or storing it in a database. This helps prevent malicious code or unintended input from compromising the application.\n• None Avoid Code Injection: Never execute user-supplied code without proper validation and sanitization. Code injection attacks occur when an attacker is able to inject and execute arbitrary code within your application’s context. To prevent this, carefully evaluate and validate any code provided by users before executing it. Use secure coding practices and libraries that provide protection against code injection vulnerabilities.\n• None Secure Password Handling: When working with passwords, it is crucial to handle them securely. Hash and salt passwords using appropriate hashing algorithms and key stretching techniques. Storing plain-text passwords is highly discouraged as it exposes users to significant risks. Instead, store only the password hashes and ensure their secure storage. Use strong hashing algorithms such as bcrypt or Argon2 and consider applying techniques like salt and pepper to further enhance password security. By implementing secure password handling practices, you can protect user credentials even if the underlying database is compromised.\n\nIt is important to note that secure coding practices go beyond these examples. Always be vigilant and keep up with the latest security guidelines and recommendations to ensure that your Python code remains secure.\n\nRole-Based Access Control (RBAC) is a powerful security model that restricts access to resources based on the roles assigned to users. By implementing RBAC in your Python applications, you can ensure that users only have the necessary privileges to perform their assigned tasks, minimizing the risk of unauthorized access and reducing the attack surface.\n\nIn RBAC, each user is assigned one or more roles, and each role is associated with specific permissions and access rights. For example, in a web application, you may have roles like admin, user, and guest. The admin role may have full access to all features and functionalities, while the user role may have limited access, and the guest role may have minimal or read-only access.\n• None Identifying Roles: Analyze your application’s functionality and determine the different roles that users can have. Consider the specific permissions and privileges associated with each role.\n• None Assigning Roles: Assign roles to users based on their responsibilities and the level of access they require. This can be done through user management systems or databases.\n• None Defining Permissions: Define the permissions associated with each role. For example, an admin role might have permissions to create, read, update, and delete records, while a user role might only have read and update permissions.\n• None Enforcing RBAC: Implement RBAC mechanisms within your Python application to enforce role-based access control. This can involve using decorators, middleware, or access control libraries to check the role of the user and verify their permissions before allowing access to specific resources.\n\nBy implementing RBAC, you establish a granular access control system that ensures users have the appropriate level of access based on their roles. This helps prevent unauthorized actions and restricts potential damage in the event of a security breach.\n\nTo learn more about implementing RBAC in Python, you can refer to the official Python Security documentation or explore relevant Python libraries and frameworks that provide RBAC functionalities, such as Flask-Security, Django Guardian, or Pyramid Authorization.\n\nWhen handling sensitive data in your Python applications, it is crucial to employ strong encryption techniques to protect the confidentiality and integrity of the data. By using well-established encryption algorithms and protocols, such as AES (Advanced Encryption Standard) and TLS (Transport Layer Security), you can ensure that data is encrypted both at rest and in transit.\n\nEncryption is the process of transforming data into an unreadable format, known as ciphertext, using encryption algorithms and cryptographic keys. Only authorized parties with the corresponding decryption keys can decipher the ciphertext and access the original data.\n\nHere are some examples of how you can protect sensitive data in Python:\n• None Data Encryption: Use encryption algorithms like AES to encrypt sensitive data before storing it in databases or other storage systems. This helps ensure that even if the data is accessed without authorization, it remains unreadable and unusable.\n• None TLS Encryption: When transmitting sensitive data over networks, such as during API calls or user authentication, use TLS encryption to establish secure and encrypted connections. TLS ensures that data exchanged between a client and a server is encrypted, preventing eavesdropping and data tampering.\n\nBy applying encryption techniques to protect sensitive data, you add an extra layer of security to your Python applications. This significantly reduces the risk of data breaches and unauthorized access to sensitive information.\n\nTo learn more about encryption in Python and how to implement it effectively, you can refer to relevant libraries and documentation, such as the Python Cryptography library and the official TLS RFC for understanding the TLS protocol.\n\nRemember that encryption is just one aspect of protecting sensitive data. It is equally important to implement secure storage, access controls, and secure key management practices to ensure comprehensive data protection.\n\nIf your Python application interacts with databases, it is essential to follow security practices to protect against potential vulnerabilities. Consider the following best practices:\n• None Use Prepared Statements: When executing database queries, utilize prepared statements or parameterized queries to prevent SQL injection attacks. Prepared statements separate SQL code from user-provided data, reducing the risk of unauthorized database access. For example, in Python, you can use libraries like SQLAlchemy or psycopg2 to implement prepared statements and protect against SQL injection vulnerabilities.\n• None Implement Least Privilege: Ensure that the database user associated with your Python application has the minimum necessary privileges required for its functionality. By following the principle of least privilege, you restrict the capabilities of the database user to only what is necessary, minimizing the potential impact of a compromised database connection. For example, if your application only requires read-only access to certain tables, grant the database user read-only privileges for those specific tables rather than full access to the entire database.\n\nBy using prepared statements and implementing least privilege, you strengthen the security of your database access and mitigate the risks associated with common attack vectors. It is also important to stay updated with the latest security guidelines and best practices provided by database vendors and relevant documentation.\n\nTo learn more about secure database access in Python, you can refer to the documentation and resources of popular database libraries such as SQLAlchemy for working with relational databases, psycopg2 for PostgreSQL, or specific documentation provided by your chosen database management system.\n\nRemember, securing database access is a critical aspect of protecting your data and maintaining the integrity of your Python applications.\n\nPython projects often rely on third-party libraries and frameworks to enhance functionality and streamline development. However, it is crucial to regularly update these dependencies to ensure the security and stability of your project.\n\nStaying vigilant about updating dependencies allows you to benefit from security patches and bug fixes released by the library maintainers. By keeping your dependencies up to date, you mitigate the risk of potential vulnerabilities and ensure that your project is running on the latest stable versions.\n\nTo effectively manage dependencies, consider the following practices:\n• None Track Vulnerabilities: Stay informed about reported vulnerabilities in your project dependencies. Websites like Snyk provide vulnerability databases and tools that can help you identify and address vulnerabilities in your dependencies. By regularly monitoring these vulnerabilities, you can take timely actions to update or replace affected dependencies.\n• None Update Dependencies Promptly: When security patches or updates are released for your project dependencies, update them promptly. Delaying updates increases the risk of exploitation, as attackers may target known vulnerabilities in outdated versions.\n• None Automate Dependency Management: Consider using dependency management tools such as Pipenv or Conda to automate dependency installation, version control, and updates. These tools can simplify the process of managing dependencies, ensuring that updates are applied consistently across different environments.\n\nRemember, maintaining up-to-date dependencies is an ongoing process. Set up a regular schedule to review and update your project dependencies, keeping security as a top priority. By staying proactive and vigilant, you can significantly reduce the risk of potential security vulnerabilities in your Python projects.\n\nTo enhance the security of your Python applications, it is essential to implement comprehensive logging and monitoring mechanisms. Logging allows you to track events and activities within your application, while monitoring provides real-time visibility into the system’s behavior, enabling the detection and investigation of security incidents.\n\nBy enabling logging, you can capture relevant information about the execution of your application, including errors, warnings, and user activities. Properly configured logging helps you identify issues, debug problems, and trace security-related events. For example, you can log authentication attempts, access to sensitive resources, or suspicious activities that may indicate a security breach.\n\nAdditionally, monitoring enables you to observe your application’s runtime behavior and detect any anomalies or security-related patterns. This can be done using tools and services that provide real-time monitoring, log aggregation, and alerting capabilities. For instance, services like AWS CloudWatch, Datadog, or Prometheus offer monitoring solutions that can be integrated with your Python applications.\n\nBy enabling logging and monitoring, you can:\n• None Detect Security Incidents: Log entries and monitoring data can help you identify security incidents or suspicious activities, allowing you to respond quickly and effectively.\n• None Investigate Breaches: When a security incident occurs, logs and monitoring data provide valuable information for post-incident investigations and forensic analysis.\n• None Improve Security Posture: By analyzing logs and monitoring data, you can gain insights into the effectiveness of your security measures, identify potential vulnerabilities, and take proactive steps to enhance your application’s security posture.\n\nRemember to configure logging and monitoring appropriately, balancing the level of detail captured with the potential impact on performance and storage. It is also essential to regularly review and analyze the collected logs and monitoring data to stay proactive in identifying and addressing security concerns.\n\nImplementing log management solutions and utilizing monitoring tools empowers you to stay ahead of potential security threats and protect your Python applications effectively.\n\nTo reinforce Python security best practices, it is crucial to invest in educating and training your Python developers. By providing them with the necessary knowledge and skills, you empower your development team to write secure code and detect potential security issues early in the development lifecycle.\n\nHere are some steps you can take to promote developer education and training:\n• None Security Awareness Programs: Conduct regular security awareness programs to educate developers about common security vulnerabilities and secure coding practices. These programs can include workshops, webinars, or online training sessions tailored to Python application development.\n• None Secure Coding Guidelines: Establish secure coding guidelines specific to Python development, outlining recommended practices and code patterns that mitigate common vulnerabilities. These guidelines can cover topics such as input validation, secure authentication, data encryption, and secure handling of sensitive information.\n• None Code Reviews and Pair Programming: Encourage a culture of collaboration and learning through code reviews and pair programming. By reviewing code together, developers can share knowledge, identify security weaknesses, and suggest improvements. This helps in maintaining code quality and adherence to secure coding practices.\n• None Security-focused Tools: Integrate security-focused tools, such as static code analysis tools, into your development workflow. These tools can automatically identify potential security issues, insecure coding patterns, and vulnerabilities in the codebase. For Python, you can explore tools like Bandit or Pylint to analyze your code for security vulnerabilities.\n• None Continuous Learning: Encourage developers to stay updated with the latest security trends, best practices, and emerging threats in the Python ecosystem. This can be achieved through participation in security conferences, webinars, or by following reputable security resources like the OWASP (Open Web Application Security Project) community.\n\nBy investing in developer education and training, you create a strong foundation for building secure Python applications. Promoting a security-focused mindset among developers helps in preventing security incidents, reducing vulnerabilities, and ensuring the overall security of your software.\n\nRemember, security is a continuous process, and ongoing education and training are necessary to stay ahead of evolving threats and maintain the highest standards of security in your Python development projects.\n\nHere is a concise cheat sheet summarizing the Python security best practices discussed in this article:\n• None Keep your Python interpreter updated to the latest stable version to benefit from security patches and bug fixes. Visit the Python website - Downloads to download the latest version.\n• None Follow secure coding practices, including input validation to prevent injection attacks, avoiding code injection by validating and sanitizing user-supplied code, and secure password handling by using appropriate hashing algorithms and password storage techniques.\n• None Implement Role-Based Access Control (RBAC) to restrict unauthorized access. RBAC assigns roles to users based on their responsibilities and grants access privileges accordingly. Refer to the NIST - Role-Based Access Control documentation for more details.\n• None Protect sensitive data using strong encryption techniques. Utilize well-established encryption algorithms like AES (Advanced Encryption Standard) and ensure secure storage and transmission of sensitive information. You can refer to the AES Wikipedia page for more information.\n• None Secure database access by using prepared statements to prevent SQL injection attacks and implementing least privilege to restrict database user permissions. These practices minimize the risk of unauthorized access to sensitive data. Learn more about prepared statements in the SQLAlchemy documentation and least privilege in the OWASP RBAC Cheat Sheet .\n• None Regularly update dependencies to address security vulnerabilities and benefit from bug fixes. Tools like Snyk - Open Source Security Platform can help you identify vulnerabilities in your project dependencies.\n• None Enable logging and monitoring to detect and investigate security incidents. Logging captures relevant information about application events, while monitoring provides real-time visibility into system behavior. Consider using services like AWS CloudWatch, Datadog, or Prometheus for comprehensive monitoring.\n• None Educate and train developers on secure coding practices and common security vulnerabilities. Promote security awareness programs, establish secure coding guidelines, and encourage code reviews and pair programming. Explore security tools like Bandit or Pylint for static code analysis.\n\nFor a more comprehensive guide on Python security, refer to the official Python Security documentation .\n\nProtecting your Python code and data from security vulnerabilities should be a top priority for any developer or organization. By following the best practices outlined in this article, you can minimize the risk of security breaches and ensure the integrity and confidentiality of your applications. Stay informed about the latest security threats, adopt secure coding practices, and prioritize security throughout the development lifecycle.\n\nRemember, securing your Python applications is an ongoing process. Regularly update your code, stay informed about emerging threats, and continuously enhance your security practices to stay one step ahead of potential attackers."
    },
    {
        "link": "https://moldstud.com/articles/p-python-security-best-practices-preventing-common-vulnerabilities",
        "document": "We will also explore data encryption techniques in Python to ensure the confidentiality and integrity of your information.\n\nSecurity should be a top priority for any developer, regardless of the programming language they are using. With the rise of cyber threats and data breaches, it is more important than ever to ensure that your applications are secure. In Python development, security is crucial to protect sensitive data, prevent unauthorized access, and maintain the trust of your users.\n\nAccording to statistics, the number of data breaches is increasing each year, with millions of records exposed due to vulnerabilities in software applications. By following best practices and implementing secure coding practices, developers can minimize the risk of these breaches and protect their data from cyber attacks.\n\nThere are several common security vulnerabilities that developers should be aware of when working with Python. Some of these vulnerabilities include:\n\nThese vulnerabilities can be exploited by attackers to gain unauthorized access to your data, execute malicious code, or steal sensitive information. By understanding these vulnerabilities and implementing security measures, you can protect your applications from potential threats.\n\nTo prevent common vulnerabilities and enhance the security of your Python applications, consider the following best practices:\n• Input Validation: Validate all user input to prevent injection attacks and ensure data integrity.\n• Use Secure Libraries: Use secure and up-to-date libraries to prevent vulnerabilities in third-party dependencies.\n• Implement Access Controls: Use role-based access controls to restrict user privileges and prevent unauthorized access.\n• Encrypt Sensitive Data: Encrypt sensitive data at rest and in transit to protect it from unauthorized access.\n• Implement HTTPS: Use HTTPS to encrypt communications between clients and servers and prevent man-in-the-middle attacks.\n\nBy following these best practices, you can strengthen the security of your Python applications and reduce the risk of common vulnerabilities.\n\nData encryption is a critical component of any security strategy, as it helps protect sensitive information from unauthorized access. In Python, there are several encryption techniques that you can use to encrypt and decrypt data securely.\n\nOne common encryption technique in Python is the use of the cryptography library, which provides support for various encryption algorithms such as AES and RSA. Here is an example of how you can encrypt and decrypt data using the cryptography library:\n\nBy using encryption techniques like the cryptography library in Python, you can ensure the confidentiality and integrity of your data, protecting it from unauthorized access and tampering.\n\nIn conclusion, security is paramount in Python development to protect your data from common vulnerabilities and cyber attacks. By following best practices, implementing secure coding techniques, and using encryption techniques, you can strengthen the security of your applications and safeguard sensitive information.\n\nRemember, prioritizing security in your Python development process is essential to ensure the confidentiality, integrity, and availability of your data. By staying informed about security best practices and leveraging encryption techniques, you can mitigate the risks of potential threats and protect your applications from security breaches.\n\nWe will also explore the importance of implementing multi-factor authentication to further enhance the security of your applications.\n\nBefore we dive into best practices for securing Python applications, let's take a look at some common security vulnerabilities that can affect Python code:\n• Injection Attacks: One of the most common vulnerabilities in Python applications is injection attacks, such as SQL injection. This occurs when untrusted data is sent to an interpreter as part of a query or command, allowing attackers to execute arbitrary code.\n• Cross-Site Scripting (XSS): XSS vulnerabilities occur when attackers inject malicious scripts into web pages viewed by other users. This can lead to the theft of sensitive information or unauthorized actions on behalf of the user.\n• Insecure Dependencies: Using outdated or vulnerable third-party libraries and modules can introduce security vulnerabilities into your Python applications. It is crucial to keep dependencies up to date to avoid exploitation by attackers.\n\nNow that we have identified some common vulnerabilities, let's discuss some best practices for securing your Python applications:\n\nAlways validate and sanitize user input to prevent injection attacks. Use parameterized queries for database interactions to avoid SQL injection vulnerabilities:\n\nUse secure protocols like HTTPS for transmitting sensitive data over the network. You can use libraries like with SSL/TLS to ensure secure communication:\n\nHash and salt passwords before storing them in your database. Use strong cryptographic algorithms like bcrypt for password hashing:\n\nMulti-factor authentication (MFA) adds an extra layer of security to your Python applications by requiring users to provide multiple forms of verification to access their accounts. This can include something they know (password), something they have (mobile device), or something they are (biometric data).\n\nImplementing MFA in your Python applications can help prevent unauthorized access, even if a user's password is compromised. Here are some common methods for implementing MFA:\n• One-Time Passwords (OTP): Generate and send one-time passwords to users via SMS or email for authentication.\n• Time-Based One-Time Passwords (TOTP): Implement TOTP using libraries like to generate time-based one-time passwords.\n• Biometric Authentication: Use biometric data like fingerprints or facial recognition for user authentication.\n\nBy implementing MFA, you can significantly enhance the security of your Python applications and protect sensitive user data from unauthorized access.\n\nIn conclusion, securing your Python applications is essential to prevent common security vulnerabilities and protect your users' data. By following best practices such as input validation, secure communications, and secure password storage, you can minimize the risk of exploitation by attackers.\n\nAdditionally, implementing multi-factor authentication adds an extra layer of security to your applications and helps prevent unauthorized access. By combining these security measures, you can enhance the overall security posture of your Python applications and protect your users' sensitive information.\n\nRemember, security is an ongoing process, and staying informed about the latest security trends and best practices is crucial for protecting your applications from evolving threats.\n\nOne of the most important steps in ensuring the security of your Python code is to follow secure coding practices. This includes using input validation, sanitizing user input, and avoiding risky functions that can lead to vulnerabilities such as SQL injection or cross-site scripting.\n\nBy implementing these practices, you can significantly reduce the risk of security vulnerabilities in your Python code.\n\n2. Keep Your Dependencies Up to Date\n\nAnother important aspect of Python security is keeping your dependencies up to date. Third-party libraries and frameworks that you use in your Python projects may have vulnerabilities that can be exploited by attackers. By regularly updating your dependencies to the latest versions, you can ensure that you are protected against known security issues.\n\nAuthentication and authorization are crucial components of any secure application. In Python, you can use libraries like Flask-Login or Django-Auth to implement user authentication and authorization mechanisms. By properly verifying the identity of users and granting them appropriate levels of access, you can prevent unauthorized access to sensitive data.\n\nWhen storing sensitive data in your Python applications, such as passwords or credit card information, it is essential to encrypt this data to protect it from unauthorized access. You can use libraries like PyCrypto or cryptography to implement encryption and decryption algorithms in your code.\n\nRegular security audits of your Python code can help you identify and address potential security vulnerabilities before they are exploited by attackers. You can use tools like Bandit or PyLint to perform static code analysis and identify security issues in your codebase.\n\nWhen communicating with external services or APIs in your Python applications, it is essential to use secure communication protocols like HTTPS to encrypt data in transit and protect it from eavesdropping. You can use libraries like requests to make secure HTTP requests in Python.\n\nBy following these best practices and implementing secure coding practices in your Python applications, you can reduce the risk of security vulnerabilities and protect your code from potential attacks. Remember to keep your dependencies up to date, implement proper authentication and authorization mechanisms, encrypt sensitive data, perform regular security audits, and use secure communication protocols to ensure the security of your Python applications.\n\nPython, being one of the most popular programming languages for software development, is no exception when it comes to security vulnerabilities. This is the part where we discuss some best practices for securing your Python applications and preventing common vulnerabilities, with a focus on secure Python package management.\n\nPython package management plays a crucial role in the security of your applications. Packages are bundles of code that provide specific functionality to your Python application. However, using third-party packages without proper security measures can introduce vulnerabilities into your codebase. According to a recent report by Synopsys, 91% of Python applications contain open-source components with known vulnerabilities, highlighting the importance of secure package management.\n\nOne of the most common security risks associated with Python package management is using outdated or vulnerable packages. Hackers often target known vulnerabilities in popular packages to exploit applications. By keeping your dependencies up to date and using secure package repositories, you can significantly reduce the risk of a security breach.\n\nVirtual environments are isolated environments that allow you to install Python packages without affecting your system-wide installation. By using virtual environments, you can create a sandbox for your application, which helps prevent conflicts between different package versions and reduces the risk of security vulnerabilities.\n\nBefore installing a Python package, always verify its authenticity to ensure that it comes from a trusted source. Use package managers like pip that support package signing, which allows you to verify the integrity of the package before installation.\n\nRegularly updating your dependencies is crucial for maintaining the security of your Python applications. Check for updates to your packages frequently and apply security patches as soon as they are released. Automated dependency management tools can help streamline this process and ensure that your dependencies are always up to date.\n\nRestricting package installation to trusted repositories can help prevent malicious packages from being installed on your system. Use package managers that support repository whitelisting, such as pip, and only install packages from trusted sources to reduce the risk of security vulnerabilities.\n\nEnsuring the security of your Python applications is essential for protecting sensitive data and preventing security breaches. By following best practices for secure Python package management, such as using virtual environments, verifying package authenticity, updating dependencies regularly, and restricting package installation, you can mitigate common vulnerabilities and enhance the overall security of your codebase.\n\nRemember, security is a continuous process, and staying vigilant against emerging threats is key to maintaining a secure development environment. By incorporating secure Python package management practices into your software development process, you can build robust and secure applications that stand up to the challenges of today's cyber landscape."
    },
    {
        "link": "https://medium.com/@VAISHAK_CP/python-app-security-common-vulnerabilities-and-how-to-mitigate-them-914034931c11",
        "document": "In today’s digital landscape, ensuring the security of Python applications is paramount. As Python continues to gain popularity for developing web, mobile, and desktop applications, it becomes increasingly targeted by cyber threats and malicious actors. In this blog post, we’ll explore some of the common vulnerabilities that Python applications face and discuss effective strategies for mitigating them.\n\nInjection attacks, such as SQL injection and command injection, remain prevalent in Python applications. These attacks occur when untrusted data is executed as code, leading to unauthorized access or data leakage. To mitigate injection attacks, developers should use parameterized queries, input validation, and prepared statements to sanitize user inputs and prevent malicious code execution.\n\nCross-Site Scripting (XSS) vulnerabilities allow attackers to inject malicious scripts into web applications, which can then be executed in the browsers of unsuspecting users. To prevent XSS attacks in Python web applications, developers should implement input validation and output encoding to sanitize user inputs and escape special characters. Additionally, Content Security Policy (CSP) headers can be used to restrict the sources from which scripts can be loaded, further reducing the risk of XSS attacks.\n\nCross-Site Request Forgery (CSRF) attacks exploit the trust that a website has in a user’s browser to perform unauthorized actions on behalf of the user. To defend against CSRF attacks, developers can implement anti-CSRF tokens, which are unique tokens generated for each user session and included in all forms and requests. When a request is made, the server verifies the token to ensure that it originated from the legitimate user.\n\nInsecure authentication and session management practices can lead to unauthorized access to sensitive data and user accounts. Developers should avoid storing passwords in plain text and instead use secure hashing algorithms like bcrypt or Argon2 for password storage. Additionally, session IDs should be securely generated, encrypted, and validated to prevent session hijacking and fixation attacks.\n\nInsecure deserialization vulnerabilities arise when untrusted data is deserialized without proper validation, leading to remote code execution or denial-of-service attacks. To mitigate insecure deserialization vulnerabilities, developers should use safe deserialization libraries, validate input data before deserialization, and implement integrity checks to verify the authenticity of serialized objects.\n\nFailure to validate user input can result in a wide range of security vulnerabilities, including injection attacks, XSS, and CSRF. Developers should validate all user inputs on the server-side and enforce strict input validation rules to prevent malicious inputs from being processed. Regular expression patterns, whitelisting, and blacklisting can be used to enforce input validation rules effectively.\n\nSecurity misconfigurations, such as default passwords, unnecessary services, and overly permissive access controls, can expose Python applications to various security risks. Developers should follow secure coding practices, conduct regular security assessments, and adhere to industry-standard security guidelines, such as the OWASP Top 10, to identify and remediate security misconfigurations proactively.\n\nSecuring Python applications requires a proactive approach that addresses common vulnerabilities and implements robust security controls at every layer of the application stack. By understanding the risks associated with injection attacks, XSS, CSRF, insecure authentication, insecure deserialization, lack of input validation, and security misconfigurations, developers can develop more secure and resilient Python applications that withstand cyber threats and protect sensitive data and user privacy. Through diligent threat modeling, secure coding practices, regular security assessments, and continuous monitoring, organizations can effectively mitigate security risks and build trust with their users in an increasingly interconnected and digital world."
    },
    {
        "link": "https://medium.com/codex/top-python-security-practices-developers-should-follow-46a935cc93a3",
        "document": "There are a growing number of Python applications that are using sensitive information. Therefore, developers need to be up to date with the security vulnerabilities that Python poses. This blog aims to provide insight into the Python security best practices & examples for a better understanding of these secure coding practices, which help developers in development.\n\nAlways use the latest Python version.\n\nTo practice secure coding, Python must be updated frequently. By regularly upgrading and updating the Python, you can mitigate cybersecurity vulnerabilities, which will increase the codebase security, and the upgrades will enhance the performance and fix any bugs. This will increase the program’s stability and effectiveness and help skilled Python developers develop robust applications. Additionally, updated libraries and frameworks can be used, improving the readability and security of the code. In addition to improving efficiency and utilizing the most recent security advancements, this keeps developers informed.\n\nOne of the most important principles of secure coding is never to trust user input. Form input, query parameters, API calls, and even configuration files should all have their data checked before your software uses them. Let’s take an example of a login form for better understanding. For instance, think of a login form that requests a username and password. Before supplying the input to our authentication routines, it must be cleaned up:\n\nThis escapes any HTML special characters that could otherwise allow cross-site scripting attacks. We can also strip unwanted whitespace and truncate long inputs. In the same way, for numbers, dates, and other structured data, we can parse the input into the expected type and catch any exceptions:\n\nStandard libraries like validators can also help validate common inputs like emails.\n\nWhen working with databases, one of the biggest risks is SQL injection. This allows attackers to run arbitrary SQL code and access unauthorized data. We should never concatenate user input directly into SQL queries to prevent this. Instead, use query parameterization provided by libraries like psycopg:\n\nThe library handles proper escaping to prevent injection. Some ORM libraries like SQLAlchemy also automatically parameterize queries for safety.\n\nAny traffic sent over a network should use transport layer encryption via SSL/TLS. This prevents intermediaries from reading or modifying data in transit. Ensure any web applications or APIs enforce HTTPS connections and redirect any HTTP traffic. When using SSL sockets or other TLS APIs, require certificates to be valid and issued by a trusted certificate authority. Use certificates signed with SHA-256 rather than weaker MD5 or SHA-1 algorithms. Prioritize modern cipher suites like AES-256 and disable outdated ones like SSLv3. SSL Labs Server Test can help you evaluate the configuration.\n\nWhere possible, rely on tried-and-tested implementations from Python’s cryptography module instead of implementing custom cryptographic code. When hashing passwords, use a slow key derivation function like bcrypt, argon2 or scrypt to protect against brute force attacks if the hashes are stolen. For example:\n\nRandom salts prevent dictionary attacks against common passwords. Slow key derivation prevents brute force attacks. Only use random data from `secrets` module for cryptography, not the basic `random` module. Always generate unique initialization vectors and use authenticated modes like GCM when using block ciphers.\n\nLogging is crucial for security auditing and incident response. Ensure all login, access control failures, and input validation failures are logged with sufficient context. Use logging features appropriately — don’t log secrets or sensitive data!\n\nEnable OS-level access logging for production systems. Centralize logs to a secured server with restricted access. Alert on unusual events like repeated failed logins or rate limiting. Log analysis tools like the ELK stack can help identify security incidents.\n\nOutdated Python packages with known vulnerabilities can expose applications to attack. Keep dependencies like frameworks, libraries, and the Python interpreter up to date, especially for public-facing services.\n\nUse dependency management tools like Poetry or Pipenv to lock versions yet still receive notifications of new releases and vulnerabilities. Monitor public vulnerability databases for issues in packages you rely on. When using third-party packages, favor well-known and maintained software from trusted sources like PyPI. Review code and activity for lesser-known modules.\n\nLimit access to data and functionality according to the principle of least privilege. Require authentication for accessing non-public endpoints. For example, an admin API in Django REST Framework can limit views to admin users:\n\nFile access policies should lock down sensitive data. Web applications should also implement CSRF protection.\n\nBeyond just code, following secure processes during development can reduce risk:\n• Threat model new features and flows to identify vulnerabilities early\n• Use code reviews and analyzers to detect potential issues\n• Run services with principle of least privilege via containers or system accounts\n• Have an incident response plan for security events\n\nType hints like those in PEP 484 can catch bugs and reduce issues caused by Python’s dynamic typing. Tools like mypy can statically analyze type usage.\n\nTreat configuration files as untrusted input as well and validate/sanitize any values loaded from them. Avoid YAML/JSON parsing vulnerabilities.\n\nLimit memory usage, CPU time, process count, request rate etc to protect against denial of service. For example, using the resource module.\n\nCall external commands safely using subprocess. Pass arguments as a list rather than string format. Validate any input files.\n\nBe wary of vulnerabilities from deserializing untrusted data in formats like pickle. Where needed, only allow whitelisted types.\n\nFlake8 and other linters have security-focused plugins to catch common issues. Use them in CI/CD pipelines.\n\nInstead of manual resource handling, rely on context managers like with statements for file access, locks, connections, etc.\n\nEnable security modules like SELinux, AppArmor, and grsecurity on Linux to limit damage potential.\n\nUse key derivation functions like HKDF instead of random when generating long-term secrets and keys rather than just PRNGs.\n\nFor large untyped codebases, gradual typing can help introduce types incrementally for additional safety.\n\nTokens, passwords, keys, and other secrets should be rotated periodically to limit impact of leaks/theft.\n\nRun tests under a non-elevated user account with limited permissions to minimize test surface.\n\nFollowing these Python security best practices throughout the development process can help minimize bugs and vulnerabilities before going into production.\n\nPython is being used for increasingly security-sensitive applications. Following these evidence-based secure coding practices, we can write Python code that properly defends against common attacks like injection, broken authentication, sensitive data exposure, and more. Adopting these principles throughout the development lifecycle will lead to more robust and secure software."
    },
    {
        "link": "https://perception-point.io/guides/zero-trust/application-whitelisting-challenges-and-best-practices",
        "document": "Whitelisting is a way of creating an inventory of secure software applications that may run on an organization’s network. Whereas blacklists block specific application sets, whitelists specify which programs are allowed—with the objective of preventing harmful files and malicious software from running on a company’s infrastructure. This approach also improves resource management by prioritizing application traffic.\n\nAll the same, whitelisting limits the scope of solutions a team may implement, often causing frustration and impeding efficiency. Newly proposed software must go through an often lengthy vetting process before deployment. Managing a whitelist is time-consuming, requiring constant monitoring and modification.\n\nThis article is part of our series of articles about zero trust security.\n\nApplication whitelisting specifies which applications are allowed to run in the corporate environment—a list which may change over time to accommodate the needs of users on the network. The list can contain libraries, files, and executables.\n\nIT organizations can use the application whitelist feature built into some host operating systems, leverage a third-party application whitelist tool, or use the whitelisting feature within some endpoint protection tools.\n\nWhatever the method used for whitelisting, the main goal is to prevent unauthorized installation and execution of applications to specific network endpoints.\n\nTo implement application whitelisting in your infrastructure, you can follow these steps:\n• Benchmarking—scan storage drives of endpoints running on the network, to identify applications and processes required for your business needs, and identify unnecessary or potentially harmful applications and processes.\n• Create an initial whitelist—including legitimate, safe applications and required for business operations.\n• Activate application whitelist—activate the whitelisting software on the network. It will start comparing any new applications with the whitelist before allowing them to run.\n• Changes and updates—upon purchasing a license for new software applications, whitelist it, and add its executable files and libraries to your whitelist before running. When updating an application, you must change the whitelist to reflect the files and executables used by the new version.\n\nApplication whitelisting is one way to block unwanted content on your network. Another approach is web filtering – blocking unwanted websites and web content.\n\nThere are various attributes that can help determine if an application file or folder may be vetted for whitelisting. Each one has its limitations, so you should use two or more attributes to identify files and programs for whitelisting.\n\nBy whitelisting a file path, you allow all applications in that path to run. There are two options:\n• Directory-based whitelisting—this option allows all files in a directory and its subdirectories.\n• Complete file path whitelisting—this option only allows file names that match the specific file path. It may use wildcards to specify multiple files.\n\nUsing the file name as an attribute on its own potentially opens a path to malicious programs that replicate whitelisted filenames. Therefore, this attribute is usually used with other identifier.\n\nThis attribute is used under the assumption that a malicious version of an application has a different file size. Because this attribute is easy to manipulate, it must be used in conjunction with others.\n\nA much stronger attribute, almost impossible to replicate, is a cryptographic hash. Attributing a unique value to an application file serves as a stronger filter than names or file system locations.\n\nDigitally signing an application file helps verify its authenticity. This unique attribute helps determine if a file has been compromised.\n\nSome applications require a predetermined set of processes to run. Process whitelisting can lock down a system by enabling only legitimate processes while preventing other processes from executing.\n\nOne of the greatest concerns regarding whitelisting is its effect on end-users. Denying applications by default is a cumbersome mechanism, which often impedes business processes and frustrates employees.\n\nThe whitelisting process itself is also difficult to implement and manage. Automating the exception management process, and the whitelist management process itself, can be a great improvement.\n\nAn alternative to traditional application whitelisting is monitor-only whitelisting. This lets the organization visualize all executables running on endpoints, and alert when unrecognized applications are discovered, without blocking applications from running. This can provide many of the security advantages without frustrating users. However, it is a passive approach that makes it possible for malicious programs to infect endpoints.\n\nIt is important to create a comprehensive list of legitimate applications used by your organization, before deploying application whitelist software. All these applications must be included in the company’s whitelist policy. Software that is not explicitly listed in company-created policies cannot be run and will be unavailable to users.\n\nIt is best to use the publisher’s digital signature or an encrypted file hash to identify applications. Most application whitelisting tools allow you to create a whitelist strategy based on these two identifiers. Using weaker identifiers, like filenames or filesystem locations, may result in false negatives and false positives.\n\nConsult with business teams and identify which of the applications currently running on the network are essential for day-to-day operations, or non-essential. Many applications may have been installed but never used, employees may have transitioned to another tool and left the old one installed, and so on. Whitelist essential applications, while blocking non-essential ones, to reduce security risk and reclaim the wasted resources they utilize.\n\nA primary challenge associated with whitelisting is to integrate whitelisting and patch management processes. Most organizations have an automated patch management process. Patching will usually prevent whitelisted software from identifying the software, and the new version will be blocked by the whitelisting tool.\n\nIf you use a tool like Windows Server Update Services (WSUS) for patch management, the tools provide an opportunity for administrators to approve patches before automatically deploying them. This presents an opportunity for administrators to add patches to the whitelist policy, just before or after approving them for distribution.\n\nAnother solution is to create an application whitelist strategy based on the vendor’s digital signature. In this way, when a vendor releases a patch, the patch contains the same digital signature as the application it is trying to update, and the patch automatically receives permission to use it.\n\nSome employees, such as IT staff, will require access to administrative tools. You cannot whitelist these tools, but at the same time, you should not let any employees use them, because this can create operational and security risks.\n\nYou will need to identify and whitelist IT management tools, while restricting access to only those individuals who need the tools for their day-to-day jobs.\n\nPerception Point Advanced Browser Security adds enterprise-grade security to standard browsers like Chrome, Edge, and Safari. The solution fuses advanced threat detection with browser-level governance and DLP controls providing organizations of all sizes with unprecedented ability to detect, prevent and remediate web threats including sophisticated phishing attacks, ransomware, exploits, Zero-Days, and more.\n\nBy transforming the organizational browser into a protected work environment, the access to sensitive corporate infrastructure and SaaS applications is secure from data loss and insider threats. The solution is seamlessly deployed on the endpoints via a browser extension and is managed centrally from a cloud-based console. There is no need to tunnel/proxy traffic through Perception Point.\n\nAn all-included managed Incident Response service is available for all customers 24/7. Perception Point’s team of cybersecurity experts will manage incidents, provide analysis and reporting, and optimize detection on-the-fly. The service drastically minimizes the need for internal IT or SOC team resources, reducing the time required to react and mitigate web-borne attacks by up to 75%.\n\nCustomers deploying the solution will experience fewer breaches, while providing their users with a better experience as they have the freedom to browse the web, use SaaS applications that they require, and access privileged corporate data, confidently, securely, and without added latency.\n\nContact us for a demo of our Advanced Browser Security solution."
    }
]