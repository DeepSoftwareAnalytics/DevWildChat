[
    {
        "link": "https://geeksforgeeks.org/c-switch-statement",
        "document": "In C, switch statement is a control flow structure that allows you to execute one of many code blocks based on the value of an expression. It is often used in place of if-else ladder when there are multiple conditional codes.\n\nExplanation: In this program, the switch statement evaluates the variable var. Since var is 1, the code in case with value 1 executes, printing “Case 1 is Matched.” and then exiting the switch block due to the break statement. Other cases and the default case are skipped.\n• expression : This is the variable or value you want to evaluate.\n• case : Each case represents a possible value for the expression. If the expression matches a case, the corresponding block of code runs.\n• break : This is used to exit the switch statement once a case is executed. Without break, the program will continue executing the subsequent cases (this is called “fall through”).\n• default : This block of code is executed if none of the case values match the expression.\n\nFollowing are some of the rules that we need to follow while using the switch statement:\n• case value must be of char int\n• None There can be one or N number of cases.\n• None The values in the case must be unique\n• None Each statement of the case can have a break statement. It is optional.\n• None The default statement is also optional.\n\nThe working of the switch statement in C is as follows:\n• Step 2: The evaluated value is matched against all the present cases.\n• Step 3A: If the matching case value is found, the associated code is executed.\n• Step 3B: If the matching code is not found, then the default case is executed if present.\n• Step 4A: If the break keyword is present in the executed case, then program control breaks out of the switch statement.\n• Step 4B: If the break keyword is not present, then all the cases after the matching case are executed.\n• Step 5: Statements after the switch statement are executed.\n\nThe below flowchart helps in visualizing the working of the switch statement in C.\n\nExamples of switch Statement in C\n\nThe below programs shows some use cases of switch statement in practical scenario:\n\nPrint Day Name of the Week\n\n1. Break in switch case is optional by syntax but logically required.\n\nThe break keyword is used to stop the execution inside a switch block. It helps to terminate the switch block and break out of it. When a break statement is reached, the switch terminates, and the flow of control jumps to the next line following the switch statement.\n\nThe break statement is optional. If omitted, execution will continue on into the next case. The flow of control will fall through to subsequent cases until a break is reached. The below example illustrate the switch case without break.\n\nThe default keyword is used to specify the set of statements to execute if there is no case match.\n\nIt is optional to use the default keyword in a switch case. Even if the switch case statement does not have a default statement, it would run without any problem.\n\nIf the expression provided in the switch statement does not result in a constant value, it would not be valid. Some valid expressions for switch case will be,\n\n4. Expression value should be only of int or char type.\n\nThe switch statement can only evaluate the integer or character value. So the switch expression should return the values of type int or char only.\n\nIn the C switch statement, duplicate case values are not allowed.\n\nNesting of switch statements is allowed, which means you can have switch statements inside another switch. However nested switch statements should be avoided as it makes the program more complex and less readable.\n\n7. The default block can be placed anywhere\n\nRegardless of its placement, the default case only gets executed if none of the other case conditions are met. So, putting it at the beginning, middle, or end doesn’t change the core logic."
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/c-language/switch-statement-c?view=msvc-170",
        "document": "The and statements help control complex conditional and branching operations. The statement transfers control to a statement within its body.\n\nA statement causes control to transfer to one in its statement body, depending on the value of .\n\nThe values of and each must have an integral type. A must have an unambiguous constant integral value at compile time.\n\nControl passes to the statement whose value matches the value of . The statement can include any number of instances. However, no two values within the same statement can have the same value. Execution of the statement body begins at the first statement in or after the matching . Execution proceeds until the end of the body, or until a statement transfers control out of the body.\n\nUse of the statement usually looks something like this:\n\nYou can use the statement to end processing of a particular labeled statement within the statement. It branches to the end of the statement. Without , the program continues to the next labeled statement, executing the statements until a or the end of the statement is reached. This continuation may be desirable in some situations.\n\nThe statement is executed if no value is equal to the value of . If there's no statement, and no match is found, none of the statements in the body get executed. There can be at most one statement. The statement doesn't have to come at the end. It may appear anywhere in the body of the statement. A or label can only appear inside a statement.\n\nThe type of and must be integral. The value of each must be unique within the statement body.\n\nThe and labels of the statement's body are significant only in the initial test that determines where execution starts in the statement body. statements can be nested. Any static variables are initialized before executing into any statements.\n\nAll three statements of the body in this example are executed if is equal to , since no statement appears before the following . Execution control is transferred to the first statement ( ) and continues in order through the rest of the body. If is equal to , and are incremented. Only is incremented when doesn't equal or .\n\nIn this example, a statement follows each statement of the body. The statement forces an exit from the statement body after one statement is executed. If is equal to -1, only is incremented. The following the statement causes execution control to pass out of the statement body, bypassing the remaining statements. Similarly, if is equal to 0, only is incremented; if is equal to 1, only is incremented. The final statement isn't strictly necessary, since control passes out of the body at the end of the compound statement. It's included for consistency.\n\nA single statement can carry multiple labels, as the following example shows:\n\nIn this example, if equals any letter between and , the function is called.\n\nMicrosoft C doesn't limit the number of values in a statement. The number is limited only by the available memory. ANSI C requires at least 257 labels be allowed in a statement.\n\nThe default for Microsoft C is that the Microsoft extensions are enabled. Use the /Za compiler option to disable these extensions."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/language/switch",
        "document": "Transfers control to one of several statements, depending on the value of a condition.\n\nA condition can either be an expression or a simple declaration.\n• If it can be syntactically resolved as an expression, it is treated as an expression. Otherwise, it is treated as a declaration that is not a structured binding declaration .\n\nWhen control reaches condition, the condition will yield a value, which is used to determine which label the control will go to.\n\nIf condition is an expression, the value it yields is the the value of the expression.\n\nIf condition is a simple declaration, the value it yields is the value of the decision variable (see below).\n\nThe declaration has the following restrictions:\n• Syntactically conforms to the following form:\n• The declarator cannot specify a function or an array.\n• The can only contain type specifiers and , and it declaration specifier sequence can only contain type specifiers and, and it cannot define a class or enumeration.\n\nThe decision variable of the declaration is the declared variable.\n\ncondition can only yield the following types:\n\nIf the yielded value is of a class type, it is contextually implicitly converted to an integral or enumeration type.\n\nIf the (possibly converted) type is subject to integral promotions , the yielded value is converted to the promoted type.\n\nAny statement within the switch statement can be labeled with one or more following labels:\n\n\n\n A case or default label is associated with the innermost switch statement enclosing it.\n\nIf any of the following conditions is satisfied, the program is ill-formed:\n• A statement is associated with multiple labels whose ﻿s have the same value after conversions.\n• A statement is associated with multiple labels.\n\nWhen the condition of a switch statement yields a (possibly converted) value:\n• If one of the associated label constants has the same value, control is passed to the statement labeled by the matched label.\n• Otherwise, if there is an associated label, control is passed to the statement labeled by the label.\n• Otherwise, none of the statements in the statement will be executed.\n\ncase and default labels in themselves do not alter the flow of control. To exit from a switch statement from the middle, see break statements.\n\nCompilers may issue warnings on fallthrough (reaching the next case or default label without a break) unless the attribute appears immediately before the case label to indicate that the fallthrough is intentional(since C++17).\n\nBecause transfer of control is not permitted to enter the scope of a variable, if a declaration statement is encountered inside the statement, it has to be scoped in its own compound statement:\n\nThe following code shows several usage cases of the switch statement: main i i fallthrough // C++17 attribute to silent the warning on fallthrough i // there are no applicable constant expressions i // when enumerations are used in a switch statement, many compilers // issue warnings if one of the enumerators is not handled color RED, GREEN, BLUE RED RED GREEN BLUE // the C++17 init-statement syntax can be helpful when there is // no implicit conversion to integral or enumeration type Device State SLEEP, READY, BAD state m_state State m_state dev Device dev. Device Device Device // the statement does not have to be a compound statement // labels do not require a compound statement either n n\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://w3schools.com/c/c_switch.php",
        "document": "Instead of writing many statements, you can use the statement.\n\nThe statement selects one of many code blocks to be executed:\n\nThis is how it works:\n• The expression is evaluated once\n• The value of the expression is compared with the values of each\n• If there is a match, the associated block of code is executed\n• The statement breaks out of the switch block and stops the execution\n• The statement is optional, and specifies some code to run if there is no case match\n\nThe example below uses the weekday number to calculate the weekday name:\n\nWhen C reaches a keyword, it breaks out of the switch block.\n\nThis will stop the execution of more code and case testing inside the block.\n\nWhen a match is found, and the job is done, it's time for a break. There is no need for more testing.\n\nThe keyword specifies some code to run if there is no case match:\n\nNote: The default keyword must be used as the last statement in the switch, and it does not need a break."
    },
    {
        "link": "https://wscubetech.com/resources/c-programming/switch",
        "document": ""
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Increment",
        "document": "The operator is overloaded for two types of operands: number and BigInt. It first coerces the operand to a numeric value and tests the type of it. It performs BigInt increment if the operand becomes a BigInt; otherwise, it performs number increment.\n\nIf used postfix, with operator after operand (for example, ), the increment operator increments and returns the value before incrementing.\n\nIf used prefix, with operator before operand (for example, ), the increment operator increments and returns the value after incrementing.\n\nThe increment operator can only be applied on operands that are references (variables and object properties; i.e. valid assignment targets). itself evaluates to a value, not a reference, so you cannot chain multiple increment operators together."
    },
    {
        "link": "https://stackoverflow.com/questions/971312/why-avoid-increment-and-decrement-operators-in-javascript",
        "document": "Is the jslint highlighting them because there are some similar languages that lack the \" ++ \" and \" -- \" syntax or handle it differently, or are there other rationales for avoiding \" ++ \" and \" -- \" that I might be missing?\n\nI know that PHP constructs like $foo[$bar++] may easily result in off-by-one errors, but I couldn't figure out a better way to control the loop than a:\n\n++ and -- The ++ (increment) and -- (decrement) operators have been known to contribute to bad code by encouraging excessive trickiness. They are second only to faulty architecture in enabling to viruses and other security menaces. There is a plusplus option that prohibits the use of these operators.\n\nOne of the tips for jslint tool is:\n\nThere is a history in C of doing things like: to copy a string, perhaps this is the source of the excessive trickery he is referring to. And there's always the question of what actually do. It's defined in some languages, and in other's there's no guarantee what will happen. Those examples aside, I don't think there's anything more idiomatic than a for loop that uses to increment. In some cases you could get away with a foreach loop, or a while loop that checked a different condtion. But contorting your code to try and avoid using incrementing is ridiculous.\n\nIf you read JavaScript The Good Parts, you'll see that Crockford's replacement for i++ in a for loop is i+=1 (not i=i+1). That's pretty clean and readable, and is less likely to morph into something \"tricky.\" Crockford made disallowing autoincrement and autodecrement an option in jsLint. You choose whether to follow the advice or not. My own personal rule is to not do anything combined with autoincrement or autodecrement. I've learned from years of experience in C that I don't get buffer overruns (or array index out of bounds) if I keep use of it simple. But I've discovered that I do get buffer overruns if I fall into the \"excessively tricky\" practice of doing other things in the same statement. So, for my own rules, the use of i++ as the increment in a for loop is fine.\n\nI've been watching Douglas Crockford's video on this and his explanation for not using increment and decrement is that\n• It has been used in the past in other languages to break the bounds of arrays and cause all manners of badness and\n• That it is more confusing and inexperienced JS developers don't know exactly what it does. Firstly arrays in JavaScript are dynamically sized and so, forgive me if I'm wrong, it is not possible to break the bounds of an array and access data that shouldn't be accessed using this method in JavaScript. Secondly, should we avoid things that are complicated, surely the problem is not that we have this facility but the problem is that there are developers out there that claim to do JavaScript but don't know how these operators work?? It is simple enough. value++, give me the current value and after the expression add one to it, ++value, increment the value before giving me it. Expressions like a ++ + ++ b, are simple to work out if you just remember the above. var a = 1, b = 1, c; c = a ++ + ++ b; // c = 1 + 2 = 3; // a = 2 (equals two after the expression is finished); // b = 2; I suppose you've just got to remember who has to read through the code, if you have a team that knows JS inside out then you don't need to worry. If not then comment it, write it differently, etc. Do what you got to do. I don't think increment and decrement is inherently bad or bug generating, or vulnerability creating, maybe just less readable depending on your audience. Btw, I think Douglas Crockford is a legend anyway, but I think he's caused a lot of scare over an operator that didn't deserve it. I live to be proven wrong though...\n\nIn my experience, ++i or i++ has never caused confusion other than when first learning about how the operator works. It is essential for the most basic for loops and while loops that are taught by any highschool or college course taught in languages where you can use the operator. I personally find doing something like what is below to look and read better than something with a++ being on a separate line. In the end it is a style preference and not anything more, what is more important is that when you do this in your code you stay consistent so that others working on the same code can follow and not have to process the same functionality in different ways. Also, Crockford seems to use i-=1, which I find to be harder to read than --i or i--\n\nAs mentioned in some of the existing answers (which annoyingly I'm unable to comment on), the problem is that x++ ++x evaluate to different values (before vs after the increment), which is not obvious and can be very confusing - if that value is used. cdmckay suggests quite wisely to allow use of increment operator, but only in a way that the returned value is not used, e.g. on its own line. I would also include the standard use within a for loop (but only in the third statement, whose return value is not used). I can't think of another example. Having been \"burnt\" myself, I would recommend the same guideline for other languages as well. I disagree with the claim that this over-strictness is due to a lot of JS programmers being inexperienced. This is the exact kind of writing typical of \"overly-clever\" programmers, and I'm sure it's much more common in more traditional languages and with JS developers who have a background in such languages.\n\nMy 2cents is that they should be avoided in two cases: 1) When you have a variable that is used in many rows and you increase/decrease it on the first statement that uses it (or last, or, even worse, in the middle): // It's Java, but applies to Js too vi = list.get ( ++i ); vi1 = list.get ( i + 1 ) out.println ( \"Processing values: \" + vi + \", \" + vi1 ) if ( i < list.size () - 1 ) ... In examples like this, you can easily miss that the variable is auto-incremented/decremented or even remove the first statement. In other words, use it only in very short blocks or where the variable appears in the block on just a couple of close statements. 2) In case of multiple ++ and -- about the same variable in the same statement. It's very hard to remember what happens in cases like this: Exams and professional tests asks about examples like above and indeed I've stumbled upon this question while looking for documentation about one of them, but in real life one shouldn't be forced to think so much about a single line of code.\n\nIs Fortran a C-like language? It has neither ++ nor --. Here is how you write a loop: The index element i is incremented by the language rules each time through the loop. If you want to increment by something other than 1, count backwards by two for instance, the syntax is ... Is Python C-like? It uses range and list comprehensions and other syntaxes to bypass the need for incrementing an index: So based on this rudimentary exploration of exactly two alternatives, language designers may avoid ++ and -- by anticipating use cases and providing an alternate syntax. Are Fortran and Python notably less of a bug magnet than procedural languages which have ++ and --? I have no evidence. I claim that Fortran and Python are C-like because I have never met someone fluent in C who could not with 90% accuracy guess correctly the intent of non-obfuscated Fortran or Python."
    },
    {
        "link": "https://reddit.com/r/learnprogramming/comments/5xh7or/best_practice_pre_vs_post_increment_in_js",
        "document": "Best practice: pre vs post increment in JS\n\nHi, I vaguely remember my early tutorials saying post incrementing a variable can causing issues in rare circumstances. Is it a good best practice then, to pre-increment (++i)? If not, why not?\n\nArchived post. New comments cannot be posted and votes cannot be cast."
    },
    {
        "link": "https://stackoverflow.com/questions/14170143/is-it-a-good-programming-practice-to-use-a-operator-which-actually-does-a-pos",
        "document": "It's purely a matter of style. Personally, I'd use whichever one makes the most logical sense. If the increment is logically part of the operation, then use the post-increment. If not, use a separate increment operation.\n\nAlso, when you use an increment operator alone, it is generally preferred to use a pre-increment. While it won't matter with simple types like integers, with more complex types, it can be much more efficient in languages like C++ that have operator overloading because a pre-increment doesn't need two instances to be around at the same time. There's no performance impact with Java, because it doesn't have operator overloading, but if you want a consistent style rule, it should be pre-increment rather than post-increment."
    },
    {
        "link": "https://reddit.com/r/learnprogramming/comments/pvfqle/beginner_coder_having_a_hard_time_grasping",
        "document": "tldr; Completely new to coding of any kind. Learning JS. Need help conceptually understanding increment/decrement (in what situations it might be used, how it works, etc). Have looked at MDN documentation and other guides but still having trouble grasping it. Any help would be greatly appreciated!\n\nHey everyone, I've been learning how to code for about 2 months now (mainly HTML, CSS) without any sort of coding background whatsoever (current social worker trying to learn web dev). I've mainly been using Angela Yu's Web Dev course and just got to the Intro to JS lessons. While I started on freecodecamp, the lack of in-depth teaching for someone like me was a huge turn-off. Overall, I enjoy Angela's teaching style and have been able to follow through with her lessons fairly painlessly until \"Increment and Decrement Expressions\". I think I might be thinking too hard about it because when I first watched the video yesterday, it mostly made sense. However, when I tried to re-work some practice questions on the course, I feel like all my understanding went out the window and I just keep confusing myself more and more. I've been trying to research on my own, reviewing MDN docs and online video tutorials, and feel like I need a more conceptual understanding of it before I can really know what's going on.\n\nFrom what I understand so far, the increment and decrement expressions are just coding shortcuts to avoid writing longer expressions. I have a very very small understanding that the expression itself allows the variable to be dynamic and re-defined as the iterations continue in the code. When I see x++, it essentially is equivalent to x = x + 1. Hopefully these basic assumptions are correct? Where it starts coming apart for me is actually using it in an expression. For example, the question from Angela's course that stumps me is this:\n\nThe way it reads to me is:\n\n4 + (x + 1) => 4 + (3 + 1+) => So the solution is 8? (Which of course is wrong, but this is where I'm ending up now...)\n\nHow exactly is the above solved and where am I getting mixed up? Are my previously stated basic assumptions way off about increment/decrement, causing me to go a completely different direction? Where are my errors? Should I just give up now? (Just kidding, that won't happen.)\n\nSorry for the embarrassing arithmetic on something that is probably extremely simple for most of you. Like I said, I come from a social science/humanities background and felt lucky that after my core math classes I only had to take a few research classes, swearing that I'd never take another math class again when I graduated...\n\nWell here I am... Thanks in advance to anyone willing to help a guy out.\n\nEDIT: Thank you so much everyone! Your detailed answers have given me a lot to think about and so I'm going to move forward in my learning. I appreciate all of you taking the time to help out!"
    }
]