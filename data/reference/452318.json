[
    {
        "link": "https://docs.python.org/3/library/random.html",
        "document": "This module implements pseudo-random number generators for various distributions.\n\nFor integers, there is uniform selection from a range. For sequences, there is uniform selection of a random element, a function to generate a random permutation of a list in-place, and a function for random sampling without replacement.\n\nOn the real line, there are functions to compute uniform, normal (Gaussian), lognormal, negative exponential, gamma, and beta distributions. For generating distributions of angles, the von Mises distribution is available.\n\nAlmost all module functions depend on the basic function , which generates a random float uniformly in the half-open range . Python uses the Mersenne Twister as the core generator. It produces 53-bit precision floats and has a period of 2**19937-1. The underlying implementation in C is both fast and threadsafe. The Mersenne Twister is one of the most extensively tested random number generators in existence. However, being completely deterministic, it is not suitable for all purposes, and is completely unsuitable for cryptographic purposes.\n\nThe functions supplied by this module are actually bound methods of a hidden instance of the class. You can instantiate your own instances of to get generators that don’t share state.\n\nClass can also be subclassed if you want to use a different basic generator of your own devising: see the documentation on that class for more details.\n\nThe module also provides the class which uses the system function to generate random numbers from sources provided by the operating system.\n\nReturn a random element from the non-empty sequence seq. If seq is empty, raises . Return a k sized list of elements chosen from the population with replacement. If the population is empty, raises . If a weights sequence is specified, selections are made according to the relative weights. Alternatively, if a cum_weights sequence is given, the selections are made according to the cumulative weights (perhaps computed using ). For example, the relative weights are equivalent to the cumulative weights . Internally, the relative weights are converted to cumulative weights before making selections, so supplying the cumulative weights saves work. If neither weights nor cum_weights are specified, selections are made with equal probability. If a weights sequence is supplied, it must be the same length as the population sequence. It is a to specify both weights and cum_weights. The weights or cum_weights can use any numeric type that interoperates with the values returned by (that includes integers, floats, and fractions but excludes decimals). Weights are assumed to be non-negative and finite. A is raised if all weights are zero. For a given seed, the function with equal weighting typically produces a different sequence than repeated calls to . The algorithm used by uses floating-point arithmetic for internal consistency and speed. The algorithm used by defaults to integer arithmetic with repeated selections to avoid small biases from round-off error. Changed in version 3.9: Raises a if all weights are zero. To shuffle an immutable sequence and return a new shuffled list, use instead. Note that even for small , the total number of permutations of x can quickly grow larger than the period of most random number generators. This implies that most permutations of a long sequence can never be generated. For example, a sequence of length 2080 is the largest that can fit within the period of the Mersenne Twister random number generator. Return a k length list of unique elements chosen from the population sequence. Used for random sampling without replacement. Returns a new list containing elements from the population while leaving the original population unchanged. The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices). Members of the population need not be hashable or unique. If the population contains repeats, then each occurrence is a possible selection in the sample. Repeated elements can be specified one at a time or with the optional keyword-only counts parameter. For example, is equivalent to . To choose a sample from a range of integers, use a object as an argument. This is especially fast and space efficient for sampling from a large population: . If the sample size is larger than the population size, a is raised. Changed in version 3.11: The population must be a sequence. Automatic conversion of sets to lists is no longer supported.\n\nThe following functions generate specific real-valued distributions. Function parameters are named after the corresponding variables in the distribution’s equation, as used in common mathematical practice; most of these equations can be found in any statistics text. Return the next random floating-point number in the range Return a random floating-point number N such that for and for . The end-point value may or may not be included in the range depending on floating-point rounding in the expression . Return a random floating-point number N such that and with the specified mode between those bounds. The low and high bounds default to zero and one. The mode argument defaults to the midpoint between the bounds, giving a symmetric distribution. Beta distribution. Conditions on the parameters are and . Returned values range between 0 and 1. Exponential distribution. lambd is 1.0 divided by the desired mean. It should be nonzero. (The parameter would be called “lambda”, but that is a reserved word in Python.) Returned values range from 0 to positive infinity if lambd is positive, and from negative infinity to 0 if lambd is negative. Changed in version 3.12: Added the default value for . Gamma distribution. (Not the gamma function!) The shape and scale parameters, alpha and beta, must have positive values. (Calling conventions vary and some sources define ‘beta’ as the inverse of the scale). Normal distribution, also called the Gaussian distribution. mu is the mean, and sigma is the standard deviation. This is slightly faster than the function defined below. Multithreading note: When two threads call this function simultaneously, it is possible that they will receive the same return value. This can be avoided in three ways. 1) Have each thread use a different instance of the random number generator. 2) Put locks around all calls. 3) Use the slower, but thread-safe function instead. Changed in version 3.11: mu and sigma now have default arguments. Log normal distribution. If you take the natural logarithm of this distribution, you’ll get a normal distribution with mean mu and standard deviation sigma. mu can have any value, and sigma must be greater than zero. Normal distribution. mu is the mean, and sigma is the standard deviation. Changed in version 3.11: mu and sigma now have default arguments. mu is the mean angle, expressed in radians between 0 and 2*pi, and kappa is the concentration parameter, which must be greater than or equal to zero. If kappa is equal to zero, this distribution reduces to a uniform random angle over the range 0 to 2*pi. Weibull distribution. alpha is the scale parameter and beta is the shape parameter.\n\n# Even integer from 0 to 100 inclusive ['four', 'two', 'ace', 'three'] # of 52 playing cards, and determine the proportion of cards # Estimate the probability of getting 5 or more heads from 7 spins # of a biased coin that settles on heads 60% of the time. # Probability of the median of 5 samples being in middle two quartiles Example of statistical bootstrapping using resampling with replacement to estimate a confidence interval for the mean of a sample: Example of a resampling permutation test to determine the statistical significance or p-value of an observed difference between the effects of a drug versus a placebo: # Example from \"Statistics is Easy\" by Dennis Shasha and Manda Wilson 'at least as extreme as the observed difference of leads us to reject the null' 'hypothesis that there is no difference between the drug and the placebo.' Simulation of arrival times and service deliveries for a multiserver queue: # time when each server becomes available Statistics for Hackers a video tutorial by Jake Vanderplas on statistical analysis using just a few fundamental concepts including simulation, sampling, shuffling, and cross-validation. Economics Simulation a simulation of a marketplace by Peter Norvig that shows effective use of many of the tools and distributions provided by this module (gauss, uniform, sample, betavariate, choice, triangular, and randrange). A Concrete Introduction to Probability (using Python) a tutorial by Peter Norvig covering the basics of probability theory, how to write simulations, and how to perform data analysis using Python.\n\nThese recipes show how to efficiently make random selections from the combinatoric iterators in the module: \"Choose r elements with replacement. Order the result to match the iterable.\" # Result will be in set(itertools.combinations_with_replacement(iterable, r)). The default returns multiples of 2⁻⁵³ in the range 0.0 ≤ x < 1.0. All such numbers are evenly spaced and are exactly representable as Python floats. However, many other representable floats in that interval are not possible selections. For example, isn’t an integer multiple of 2⁻⁵³. The following recipe takes a different approach. All floats in the interval are possible selections. The mantissa comes from a uniform distribution of integers in the range 2⁵² ≤ mantissa < 2⁵³. The exponent comes from a geometric distribution where exponents smaller than -53 occur half as often as the next larger exponent. All real valued distributions in the class will use the new method: The recipe is conceptually equivalent to an algorithm that chooses from all the multiples of 2⁻¹⁰⁷⁴ in the range 0.0 ≤ x < 1.0. All such numbers are evenly spaced, but most have to be rounded down to the nearest representable Python float. (The value 2⁻¹⁰⁷⁴ is the smallest positive unnormalized float and is equal to .) Generating Pseudo-random Floating-Point Values a paper by Allen B. Downey describing ways to generate more fine-grained floats than normally generated by ."
    },
    {
        "link": "https://geeksforgeeks.org/python-random-sample-function",
        "document": "sample() is an built-in function of random module in Python that returns a particular length list of items chosen from the sequence i.e. list, tuple, string or set. Used for random sampling without replacement.\n\nSyntax : \n\nParameters:\n\nsequence : Can be a list, tuple, string, or set. \n\nk : An Integer value, it specify the length of a sample. \n\nReturns: k length new list of elements chosen from the sequence.\n\nOutput will be different everytime as it returns a random item.\n\nRaise Exception If the sample size i.e. k is larger than the sequence size, ValueError is raised."
    },
    {
        "link": "https://reddit.com/r/learnpython/comments/q3xqul/pythons_randomsample_deprecation",
        "document": "I've started using sets for the first time in my current project (Python 3.9.6), and the random.sample() method is returning a deprecation warning. I couldn't find in the module's documentation which was this method's replacer. Would it be random.choice?"
    },
    {
        "link": "https://stackoverflow.com/questions/22741319/what-does-the-random-sample-method-in-python-do",
        "document": "It is used for randomly sampling a sample of length from a population. returns a length list of unique elements chosen from the population sequence or set\n\nit returns a new list and leaves the original population unchanged and the resulting list is in selection order so that all sub-slices will also be valid random samples\n\nI am putting up an example in which I am splitting a dataset randomly. It is basically a function in which you pass as an argument and return indices of of the data as ."
    },
    {
        "link": "https://stackoverflow.com/questions/73010269/how-select-random-sampling-from-large-dict-whitout-converting-to-list-in-python",
        "document": "I have a (potentially) huge dict in Python 3.10 and want to randomly sample a few values. Alas, says:\n\nI don't want to pay the cost of converting my dictionary keys to a list, and I don't need them sorted.\n\nThere's an old question in a similar vein, but that's from before stuff got deprecated in Python and the person asking that question didn't mind converting to a list first.\n\nI also tried running multiple times to simulate . But that's even worse: it just throws an exception when you use it on a dict. (Instead of giving you a reasonable error message.)"
    },
    {
        "link": "https://stackoverflow.com/questions/42688431/resolve-valueerror-when-using-random-choice-from-a-list-with-restrictions",
        "document": "And I want to sample (without replacement) N out of X without the values in Y, I could do something like this:\n\nN is a user-input that is surely less then but given that I've no idea whether N is bigger than the subset of X-Y, I might get this situation that throws a :\n\nGiven that I would have to preset a max value for N, e.g.:\n\nBut in that case N is no longer 8, which the user inputs:\n\nSo I have to post-add the output:\n\nTo summarize, I have to sample N no. of elements without replacement from a subset of values of X that isn't in Y and I need to fill up the \"gaps\" with -1 if the length of the subset is less than N.\n\nI could do it with the code above but is there a less verbose (hopefully also more efficient) way to achieve the same output?"
    },
    {
        "link": "https://stackoverflow.com/questions/43800421/how-to-use-random-sample-and-not-get-valueerror-exception",
        "document": "The goal is to give start and end limit and the # of numbers to generate. For instance I want to generate 100 random numbers between 1-100.\n\nHow do I make sure that I don't get exception?\n\nThe code I am using is:"
    },
    {
        "link": "https://digitalocean.com/community/tutorials/python-valueerror-exception-handling-examples",
        "document": "Python ValueError is raised when a function receives an argument of the correct type but an inappropriate value. Also, the situation should not be described by a more precise exception such as IndexError.\n\nYou will get ValueError with mathematical operations, such as square root of a negative number.\n\nHere is a simple example to handle ValueError exception using try-except block.\n\nHere is the output of the program with different types of input.\n\nOur program can raise ValueError in int() and math.sqrt() functions. So, we can create a nested try-except block to handle both of them. Here is the updated snippet to take care of all the ValueError scenarios.\n\nHere is a simple example where we are raising ValueError for input argument of correct type but inappropriate value."
    },
    {
        "link": "https://labex.io/tutorials/python-how-to-handle-random-selection-errors-418945",
        "document": "In the realm of Python programming, random selection plays a crucial role in data analysis, machine learning, and statistical modeling. However, random selection processes can introduce unexpected errors that compromise data integrity and research outcomes. This tutorial explores comprehensive strategies for identifying, understanding, and effectively managing random selection errors in Python, empowering developers and data scientists to maintain robust and reliable sampling techniques.\n\n%%%%{init: {'theme':'neutral'}}%%%% flowchart RL python((\"Python\")) -.-> python/ErrorandExceptionHandlingGroup([\"Error and Exception Handling\"]) python((\"Python\")) -.-> python/AdvancedTopicsGroup([\"Advanced Topics\"]) python((\"Python\")) -.-> python/PythonStandardLibraryGroup([\"Python Standard Library\"]) python/ErrorandExceptionHandlingGroup -.-> python/catching_exceptions(\"Catching Exceptions\") python/ErrorandExceptionHandlingGroup -.-> python/raising_exceptions(\"Raising Exceptions\") python/ErrorandExceptionHandlingGroup -.-> python/custom_exceptions(\"Custom Exceptions\") python/AdvancedTopicsGroup -.-> python/generators(\"Generators\") python/PythonStandardLibraryGroup -.-> python/math_random(\"Math and Random\") subgraph Lab Skills python/catching_exceptions -.-> lab-418945{{\"How to handle random selection errors\"}} python/raising_exceptions -.-> lab-418945{{\"How to handle random selection errors\"}} python/custom_exceptions -.-> lab-418945{{\"How to handle random selection errors\"}} python/generators -.-> lab-418945{{\"How to handle random selection errors\"}} python/math_random -.-> lab-418945{{\"How to handle random selection errors\"}} end"
    },
    {
        "link": "https://rollbar.com/blog/python-valueerror",
        "document": "The Python is an exception that occurs when a function receives an argument of the correct data type but an inappropriate value. This error usually occurs in mathematical operations that require a certain kind of value.\n\nTo use an analogy, imagine trying to enroll an adult in a children's school. The person is a valid human, but their age is inappropriate for the setting. Similarly, a occurs when a function receives the correct type of input but with an unsuitable value.\n\nThe Python is raised when an object is assigned the right data type but the wrong value for a certain operation. Some of the most common scenarios where this can happen are:\n• If the value is invalid for the operation. For example, if a negative integer is passed to a square root operation.\n• Performing an operation when the value does not exist. For example, trying to remove a value from a list where it does not exist.\n• Trying to unpack more values than available. For example, trying to unpack values from a list with 5 items to 3 variables.\n\nHere’s an example of a Python raised when trying to perform a square root operation on a negative number:\n\nIn the above example, a negative integer is passed to the function. Since the function expects a positive integer, running the above code raises a :\n\nHere’s an example of a Python raised when trying to remove a value from a list where it does not exist:\n\nIn the above example, the variable with a value of is attempted to be removed from the list . Since does not contain the value, running the above code raises a :\n\nHere’s an example of a Python raised when trying to unpack more values from a list than available:\n\nIn the above example, the list containing 5 values is attempted to be unpacked and assigned to 3 variables. Since the number of values exceed the number of available variables, running the above code raises a :\n\nTo resolve the in Python code, a try-except block can be used. The lines of code that can throw the should be placed in the block, and the block can catch and handle the error.\n\nUsing this approach, the previous examples can be updated to handle the error:\n\nHere, a check is performed for the using the try-except block. When the above code is executed, the block catches the and handles it, producing the following output:\n\nManaging errors and exceptions in your code is challenging. It can make deploying production code an unnerving experience. Being able to track, analyze, and manage errors in real-time can help you to proceed with more confidence. Rollbar automates error monitoring and triaging, making fixing Python errors easier than ever. Try it today!"
    }
]