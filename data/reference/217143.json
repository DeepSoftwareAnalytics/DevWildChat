[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 . * Some parts of this feature may have varying levels of support.\n\nThe interface, part of the Canvas API, provides the 2D rendering context for the drawing surface of a element. It is used for drawing shapes, text, images, and other objects. The interface's properties and methods are described in the reference section of this page. The Canvas tutorial has more explanation, examples, and resources, as well. For , there is an equivalent interface that provides the rendering context. The offscreen rendering context inherits most of the same properties and methods as the and is described in more detail in the reference page.\n\nTo get a instance, you must first have an HTML element to work with: To get the canvas' 2D rendering context, call on the element, supplying as the argument: With the context in hand, you can draw anything you like. This code draws a house: The resulting drawing looks like this:\n\nThe following methods can be used to manipulate paths of objects. Starts a new path by emptying the list of sub-paths. Call this method when you want to create a new path. Causes the point of the pen to move back to the start of the current sub-path. It tries to draw a straight line from the current point to the start. If the shape has already been closed or has only one point, this function does nothing. Moves the starting point of a new sub-path to the (x, y) coordinates. Connects the last point in the current sub-path to the specified (x, y) coordinates with a straight line. Adds an arc to the current path with the given control points and radius, connected to the previous point by a straight line. Adds an elliptical arc to the current path. Creates a path for a rectangle at position (x, y) with a size that is determined by width and height. Creates a path for a rounded rectangle with a specified position, width, height, and corner radii.\n\nObjects in the rendering context have a current transformation matrix and methods to manipulate it. The transformation matrix is applied when creating the current default path, painting text, shapes and objects. The methods listed below remain for historical and compatibility reasons as objects are used in most parts of the API nowadays and will be used in the future instead. Retrieves the current transformation matrix being applied to the context. Adds a rotation to the transformation matrix. The angle argument represents a clockwise rotation angle and is expressed in radians. Adds a scaling transformation to the canvas units by x horizontally and by y vertically. Adds a translation transformation by moving the canvas and its origin x horizontally and y vertically on the grid. Multiplies the current transformation matrix with the matrix described by its arguments. Resets the current transform to the identity matrix, and then invokes the method with the same arguments. Resets the current transform by the identity matrix.\n\nThe rendering context contains a variety of drawing style states (attributes for line styles, fill styles, shadow styles, text styles). The following methods help you to work with that state: Saves the current drawing style state using a stack so you can revert any change you make to it using . Restores the drawing style state to the last element on the 'state stack' saved by . A read-only back-reference to the . Might be if it is not associated with a element. Returns an object containing the context attributes used by the browser. Context attributes can be requested when using to create the 2D context. Resets the rendering context, including the backing buffer, the drawing state stack, path, and styles. Returns if the rendering context was lost."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/arcTo",
        "document": "The demo shows the semi-infinite lines and circle with center C tangent to the lines at T and T used to determine the path rendered by .\n\nNote that will create a straight line from P to P when all points are in a line. Additionally, nothing is drawn by if P and P have the same coordinates.\n\nBesides being able to set the arc radius with the slider, the initial point P and control points P and P can be moved by dragging them with the mouse with the left button down. The numeric values can also be edited, and the arrow keys can be used to change an underlined element that is in focus."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/beginPath",
        "document": "This example creates two paths, each of which contains a single line.\n\nThe method is called before beginning each line, so that they may be drawn with different colors."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineTo",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 .\n\nThe method , part of the Canvas 2D API, adds a straight line to the current sub-path by connecting the sub-path's last point to the specified coordinates.\n\nLike other methods that modify the current path, this method does not directly render anything. To draw the path onto a canvas, you can use the or methods."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/arc",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 .\n\nThe method of the Canvas 2D API adds a circular arc to the current sub-path.\n\nThe method creates a circular arc centered at with a radius of . The path starts at , ends at , and travels in the direction given by (defaulting to clockwise).\n\nThe horizontal coordinate of the arc's center. The vertical coordinate of the arc's center. The arc's radius. Must be positive. The angle at which the arc starts in radians, measured from the positive x-axis. The angle at which the arc ends in radians, measured from the positive x-axis. An optional boolean value. If , draws the arc counter-clockwise between the start and end angles. The default is (clockwise).\n\nThis example draws a complete circle with the method. The arc is given an x-coordinate of 100, a y-coordinate of 75, and a radius of 50. To make a full circle, the arc begins at an angle of 0 radians (0°), and ends at an angle of 2π radians (360°).\n\nThis example draws various shapes to show what is possible with . const canvas = document.querySelector(\"canvas\"); const ctx = canvas.getContext(\"2d\"); // Draw shapes for (let i = 0; i <= 3; i++) { for (let j = 0; j <= 2; j++) { ctx.beginPath(); let x = 25 + j * 50; // x coordinate let y = 25 + i * 50; // y coordinate let radius = 20; // Arc radius let startAngle = 0; // Starting point on circle let endAngle = Math.PI + (Math.PI * j) / 2; // End point on circle let counterclockwise = i % 2 === 1; // Draw counterclockwise ctx.arc(x, y, radius, startAngle, endAngle, counterclockwise); if (i > 1) { ctx.fill(); } else { ctx.stroke(); } } }"
    },
    {
        "link": "https://stackoverflow.com/questions/15007903/html5-canvas-with-rounded-corner",
        "document": "I'd like to have an HTML5 canvas with rounded corner. I'm using the CSS property to round my corners.\n\nBut, when I draw something in the corner of my canvas, I can draw in the corner.\n\nDo you have any solution to avoid that? I thought about create a mask but I don't really know how to do.. For information, this works on Firefox but not on Chrome/Safari/Opera.\n\nThis is a small example:"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes",
        "document": "Before we can start drawing, we need to talk about the canvas grid or coordinate space. Our HTML skeleton from the previous page had a canvas element 150 pixels wide and 150 pixels high. Normally 1 unit in the grid corresponds to 1 pixel on the canvas. The origin of this grid is positioned in the top left corner at coordinate (0,0). All elements are placed relative to this origin. So the position of the top left corner of the blue square becomes x pixels from the left and y pixels from the top, at coordinate (x,y). Later in this tutorial we'll see how we can translate the origin to a different position, rotate the grid and even scale it, but for now we'll stick to the default.\n\nUnlike SVG, only supports two primitive shapes: rectangles and paths (lists of points connected by lines). All other shapes must be created by combining one or more paths. Luckily, we have an assortment of path drawing functions which make it possible to compose very complex shapes. First let's look at the rectangle. There are three functions that draw rectangles on the canvas: Clears the specified rectangular area, making it fully transparent. Each of these three functions takes the same parameters. and specify the position on the canvas (relative to the origin) of the top-left corner of the rectangle. and provide the rectangle's size. Below is the function from the previous page, but now it is making use of these three functions.\n\nNow let's look at paths. A path is a list of points, connected by segments of lines that can be of different shapes, curved or not, of different width and of different color. A path, or even a subpath, can be closed. To make shapes using paths, we take some extra steps:\n• First, you create the path.\n• Then you use drawing commands to draw into the path.\n• Once the path has been created, you can stroke or fill the path to render it. Here are the functions used to perform these steps: Creates a new path. Once created, future drawing commands are directed into the path and used to build the path up. Methods to set different paths for objects. Adds a straight line to the path, going to the start of the current sub-path. Draws the shape by stroking its outline. The first step to create a path is to call the . Internally, paths are stored as a list of sub-paths (lines, arcs, etc.) which together form a shape. Every time this method is called, the list is reset and we can start drawing new shapes. Note: When the current path is empty, such as immediately after calling , or on a newly created canvas, the first path construction command is always treated as a , regardless of what it actually is. For that reason, you will almost always want to specifically set your starting position after resetting a path. The second step is calling the methods that actually specify the paths to be drawn. We'll see these shortly. The third, and an optional step, is to call . This method tries to close the shape by drawing a straight line from the current point to the start. If the shape has already been closed or there's only one point in the list, this function does nothing. Note: When you call , any open shapes are closed automatically, so you don't have to call . This is not the case when you call .\n\nOne very useful function, which doesn't actually draw anything but becomes part of the path list described above, is the function. You can probably best think of this as lifting a pen or pencil from one spot on a piece of paper and placing it on the next. Moves the pen to the coordinates specified by and . When the canvas is initialized or is called, you typically will want to use the function to place the starting point somewhere else. We could also use to draw unconnected paths. Take a look at the smiley face below. To try this for yourself, you can use the code snippet below. Just paste it into the function we saw earlier. The result looks like this: If you'd like to see the connecting lines, you can remove the lines that call . Note: To learn more about the function, see the Arcs section below.\n\nFor drawing straight lines, use the method. Draws a line from the current drawing position to the position specified by and . This method takes two arguments, and , which are the coordinates of the line's end point. The starting point is dependent on previously drawn paths, where the end point of the previous path is the starting point for the following, etc. The starting point can also be changed by using the method. The example below draws two triangles, one filled and one outlined. This starts by calling to start a new shape path. We then use the method to move the starting point to the desired position. Below this, two lines are drawn which make up two sides of the triangle. You'll notice the difference between the filled and stroked triangle. This is, as mentioned above, because shapes are automatically closed when a path is filled, but not when they are stroked. If we left out the for the stroked triangle, only two lines would have been drawn, not a complete triangle.\n\nTo draw arcs or circles, we use the or methods. Draws an arc which is centered at (x, y) position with radius r starting at startAngle and ending at endAngle going in the given direction indicated by counterclockwise (defaulting to clockwise). Draws an arc with the given control points and radius, connected to the previous point by a straight line. Let's have a more detailed look at the method, which takes six parameters: and are the coordinates of the center of the circle on which the arc should be drawn. is self-explanatory. The and parameters define the start and end points of the arc in radians, along the curve of the circle. These are measured from the x axis. The parameter is a Boolean value which, when , draws the arc counterclockwise; otherwise, the arc is drawn clockwise. Note: Angles in the function are measured in radians, not degrees. To convert degrees to radians you can use the following JavaScript expression: . The following example is a little more complex than the ones we've seen above. It draws 12 different arcs all with different angles and fills. The two loops are for looping through the rows and columns of arcs. For each arc, we start a new path by calling . In the code, each of the parameters for the arc is in a variable for clarity, but you wouldn't necessarily do that in real life. The and coordinates should be clear enough. and are fixed. The starts at 180 degrees (half a circle) in the first column and is increased by steps of 90 degrees, culminating in a complete circle in the last column. The statement for the parameter results in the first and third row being drawn as clockwise arcs and the second and fourth row as counterclockwise arcs. Finally, the statement makes the top half stroked arcs and the bottom half filled arcs. Note: This example requires a slightly larger canvas than the others on this page: 150 x 200 pixels. function draw() { const canvas = document.getElementById(\"canvas\"); if (canvas.getContext) { const ctx = canvas.getContext(\"2d\"); for (let i = 0; i < 4; i++) { for (let j = 0; j < 3; j++) { ctx.beginPath(); const x = 25 + j * 50; // x coordinate const y = 25 + i * 50; // y coordinate const radius = 20; // Arc radius const startAngle = 0; // Starting point on circle const endAngle = Math.PI + (Math.PI * j) / 2; // End point on circle const counterclockwise = i % 2 !== 0; // clockwise or counterclockwise ctx.arc(x, y, radius, startAngle, endAngle, counterclockwise); if (i > 1) { ctx.fill(); } else { ctx.stroke(); } } } } }\n\nThe next type of paths available are Bézier curves, available in both cubic and quadratic varieties. These are generally used to draw complex organic shapes. Draws a quadratic Bézier curve from the current pen position to the end point specified by and , using the control point specified by and . Draws a cubic Bézier curve from the current pen position to the end point specified by and , using the control points specified by ( , ) and ( , ). The difference between these is that a quadratic Bézier curve has a start and an end point (blue dots) and just one control point (indicated by the red dot) while a cubic Bézier curve uses two control points. The and parameters in both of these methods are the coordinates of the end point. and are the coordinates of the first control point, and and are the coordinates of the second control point. Using quadratic and cubic Bézier curves can be quite challenging, because unlike vector drawing software like Adobe Illustrator, we don't have direct visual feedback as to what we're doing. This makes it pretty hard to draw complex shapes. In the following example, we'll be drawing some simple organic shapes, but if you have the time and, most of all, the patience, much more complex shapes can be created. There's nothing very difficult in these examples. In both cases we see a succession of curves being drawn which finally result in a complete shape. This example uses multiple quadratic Bézier curves to render a speech balloon. This example draws a heart using cubic Bézier curves.\n\nAs we have seen in the last example, there can be a series of paths and drawing commands to draw objects onto your canvas. To simplify the code and to improve performance, the object, available in recent versions of browsers, lets you cache or record these drawing commands. You are able to play back your paths quickly. Let's see how we can construct a object: The constructor returns a newly instantiated object, optionally with another path as an argument (creates a copy), or optionally with a string consisting of SVG path data. new Path2D(); // empty path object new Path2D(path); // copy from another Path2D object new Path2D(d); // path from SVG path data All path methods like , , or , etc., which we got to know above, are available on objects. The API also adds a way to combine paths using the method. This can be useful when you want to build objects from several components, for example. Adds a path to the current path with an optional transformation matrix."
    },
    {
        "link": "https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners",
        "document": "An invaluable function I use a lot is rounded polygon. It takes a set of 2D points that describe a polygon's vertices and adds arcs to round the corners.\n\nThe problem with rounding corners and keeping within the constraint of the polygons area is that you can not always fit a round corner that has a particular radius.\n\nIn these cases you can either ignore the corner and leave it as pointy or, you can reduce the rounding radius to fit the corner as best possible.\n\nThe following function will resize the corner rounding radius to fit the corner if the corner is too sharp and the lines from the corner not long enough to get the desired radius in.\n\nNote the code has comments that refer to the Maths section below if you want to know what is going on.\n\nYou may wish to add to each point a radius eg this will set the max radius for that point. A radius of zero will be no rounding.\n\nThe following illistration shows one of two possibilities, the angle to fit is less than 90deg, the other case (greater than 90) just has a few minor calculation differences (see code).\n\nThe corner is defined by the three points in red A, B, and C. The circle radius is r and we need to find the green points F the circle center and D and E which will define the start and end angles of the arc.\n\nFirst we find the angle between the lines from B,A and B,C this is done by normalising the vectors for both lines and getting the cross product. We also find the angle of line BC to the line at 90deg to BA as this will help determine which side of the line to put the circle.\n\nNow we have the angle between the lines, we know that half that angle defines the line that the center of the circle will sit F but we do not know how far that point is from B\n\nThere are two right triangles BDF and BEF which are identical. We have the angle at B and we know that the side DF and EF are equal to the radius of the circle r thus we can solve the triangle to get the distance to F from B\n\nFor convenience rather than calculate to F is solve for BD as I will move along the line BC by that distance then turn 90deg and move up to F This in the process gives the point D and moving along the line BA to E\n\nWe use points D and E and the circle center F (in their abstract form) to calculate the start and end angles of the arc.\n\nThe rest of the code is concerned with the directions to move along and away from lines and which direction to sweep the arc.\n\nThe code section (special part A) uses the lengths of both lines BA and BC and compares them to the distance from BD if that distance is greater than half the line length we know the arc can not fit. I then solve the triangles to find the radius DF if the line BD is half the length of shortest line of BA and BC\n\nThe snippet is a simple example of the above function in use. Click to add points to the canvas (needs a min of 3 points to create a polygon). You can drag points and see how the corner radius adapts to sharp corners or short lines. More info when snippet is running. To restart rerun the snippet. (there is a lot of extra code that can be ignored)\n\nThe corner radius is set to 30."
    },
    {
        "link": "https://konvajs.org/docs/shapes/Custom.html",
        "document": "To create a custom shape with , you can use the object and define a custom drawing function.\n\nWhen creating a custom shape, you need to define a drawing function that is passed a Konva.Context renderer and a shape instance. Here's a simple rectangle example:\n\nis a wrapper around native 2d canvas context that has the same properties and methods with some additional API.\n\nThere are two properties that can be used for drawing custom shapes:\n• - optional function to define custom hit region for events (see Custom Hit Region demo)\n• Optimize the function as it can be called many times per second. Avoid creating images or large objects.\n• The function should not have side effects like moving shapes, attaching events or changing app state.\n• Don't manually apply position and scaling in . Let Konva handle it through shape properties.\n• Avoid manual styling in . Use for styling.\n\nFor full list of properties and methods, see the Shape API Reference."
    },
    {
        "link": "https://eloquentjavascript.net/17_canvas.html",
        "document": "Browsers give us several ways to display graphics. The simplest way is to use styles to position and color regular DOM elements. This can get us quite far, as the game in the previous chapter showed. By adding partially transparent background images to the nodes, we can make them look exactly the way we want. It is even possible to rotate or skew nodes with the style.\n\nBut we’d be using the DOM for something that it wasn’t originally designed for. Some tasks, such as drawing a line between arbitrary points, are extremely awkward to do with regular HTML elements.\n\nThere are two alternatives. The first is DOM based but utilizes Scalable Vector Graphics (SVG) rather than HTML. Think of SVG as a document-markup dialect that focuses on shapes rather than text. You can embed an SVG document directly in an HTML document or include it with an tag.\n\nThe second alternative is called a canvas. A canvas is a single DOM element that encapsulates a picture. It provides a programming interface for drawing shapes onto the space taken up by the node. The main difference between a canvas and an SVG picture is that in SVG the original description of the shapes is preserved so that they can be moved or resized at any time. A canvas, on the other hand, converts the shapes to pixels (colored dots on a raster) as soon as they are drawn and does not remember what these pixels represent. The only way to move a shape on a canvas is to clear the canvas (or the part of the canvas around the shape) and redraw it with the shape in a new position.\n\nThis book won’t go into SVG in detail, but I’ll briefly explain how it works. At the end of the chapter, I’ll come back to the trade-offs that you must consider when deciding which drawing mechanism is appropriate for a given application.\n\nThis is an HTML document with a simple SVG picture in it:\n\nThe attribute changes an element (and its children) to a different XML namespace. This namespace, identified by a URL, specifies the dialect that we are currently speaking. The and tags, which do not exist in HTML, do have a meaning in SVG—they draw shapes using the style and position specified by their attributes.\n\nThese tags create DOM elements, just like HTML tags, that scripts can interact with. For example, this changes the element to be colored cyan instead:\n\nCanvas graphics can be drawn onto a element. You can give such an element and attributes to determine its size in pixels.\n\nA new canvas is empty, meaning it is entirely transparent and thus shows up as empty space in the document.\n\nThe tag is intended to allow different styles of drawing. To get access to an actual drawing interface, we first need to create a context, an object whose methods provide the drawing interface. There are currently three widely supported drawing styles: for two-dimensional graphics, for three-dimensional graphics through the OpenGL interface, and , a more modern and flexible alternative to WebGL.\n\nThis book won’t discuss WebGL or WebGPU—we’ll stick to two dimensions. But if you are interested in three-dimensional graphics, I do encourage you to look into WebGPU. It provides a direct interface to graphics hardware and allows you to render even complicated scenes efficiently, using JavaScript.\n\nYou create a context with the method on the DOM element.\n\nAfter creating the context object, the example draws a red rectangle that is 100 pixels wide and 50 pixels high, with its upper-left corner at coordinates (10, 10).\n\nJust like in HTML (and SVG), the coordinate system that the canvas uses puts (0, 0) at the upper-left corner, and the positive y-axis goes down from there. This means (10, 10) is 10 pixels below and to the right of the upper-left corner.\n\nIn the canvas interface, a shape can be filled, meaning its area is given a certain color or pattern, or it can be stroked, which means a line is drawn along its edge. SVG uses the same terminology.\n\nThe method fills a rectangle. It takes first the x- and y-coordinates of the rectangle’s upper-left corner, then its width, and then its height. A similar method called draws the outline of a rectangle.\n\nNeither method takes any further parameters. The color of the fill, thickness of the stroke, and so on, are not determined by an argument to the method, as you might reasonably expect, but rather by properties of the context object.\n\nThe property controls the way shapes are filled. It can be set to a string that specifies a color, using the color notation used by CSS.\n\nThe property works similarly but determines the color used for a stroked line. The width of that line is determined by the property, which may contain any positive number.\n\nWhen no or attribute is specified, as in the example, a canvas element gets a default width of 300 pixels and height of 150 pixels.\n\nA path is a sequence of lines. The 2D canvas interface takes a peculiar approach to describing such a path. It is done entirely through side effects. Paths are not values that can be stored and passed around. Instead, if you want to do something with a path, you make a sequence of method calls to describe its shape.\n\nThis example creates a path with a number of horizontal line segments and then strokes it using the method. Each segment created with starts at the path’s current position. That position is usually the end of the last segment, unless was called. In that case, the next segment would start at the position passed to .\n\nWhen filling a path (using the method), each shape is filled separately. A path can contain multiple shapes—each motion starts a new one. But the path needs to be closed (meaning its start and end are in the same position) before it can be filled. If the path is not already closed, a line is added from its end to its start, and the shape enclosed by the completed path is filled.\n\nThis example draws a filled triangle. Note that only two of the triangle’s sides are explicitly drawn. The third, from the lower-right corner back to the top, is implied and wouldn’t be there if you stroked the path.\n\nYou could also use the method to explicitly close a path by adding an actual line segment back to the path’s start. This segment is drawn when stroking the path.\n\nA path may also contain curved lines. These are unfortunately a bit more involved to draw.\n\nThe method draws a curve to a given point. To determine the curvature of the line, the method is given a control point as well as a destination point. Imagine this control point as attracting the line, giving it its curve. The line won’t go through the control point, but its direction at the start and end points will be such that a straight line in that direction would point toward the control point. The following example illustrates this:\n\nWe draw a quadratic curve from the left to the right, with (60, 10) as the control point, and then draw two line segments going through that control point and back to the start of the line. The result somewhat resembles a Star Trek insignia. You can see the effect of the control point: the lines leaving the lower corners start off in the direction of the control point and then curve toward their target.\n\nThe method draws a similar kind of curve. Instead of a single control point, this method has two—one for each of the line’s end points. Here is a similar sketch to illustrate the behavior of such a curve:\n\nThe two control points specify the direction at both ends of the curve. The farther they are away from their corresponding point, the more the curve will “bulge” in that direction.\n\nSuch curves can be hard to work with—it’s not always clear how to find the control points that provide the shape you are looking for. Sometimes you can compute them, and sometimes you’ll just have to find a suitable value by trial and error.\n\nThe method is a way to draw a line that curves along the edge of a circle. It takes a pair of coordinates for the arc’s center, a radius, and then a start angle and end angle.\n\nThose last two parameters make it possible to draw only part of the circle. The angles are measured in radians, not degrees. This means a full circle has an angle of 2π, or , which is about 6.28. The angle starts counting at the point to the right of the circle’s center and goes clockwise from there. You can use a start of 0 and an end bigger than 2π (say, 7) to draw a full circle.\n\nThe resulting picture contains a line from the right of the full circle (first call to ) to the right of the quarter-circle (second call).\n\nLike other path-drawing methods, a line drawn with is connected to the previous path segment.You can call or start a new path to avoid this.\n\nImagine you’ve just taken a job at EconomiCorp, Inc. Your first assignment is to draw a pie chart of its customer satisfaction survey results.\n\nThe binding contains an array of objects that represent the survey responses.\n\nTo draw a pie chart, we draw a number of pie slices, each made up of an arc and a pair of lines to the center of that arc. We can compute the angle taken up by each arc by dividing a full circle (2π) by the total number of responses and then multiplying that number (the angle per response) by the number of people who picked a given choice.\n\nBut a chart that doesn’t tell us what the slices mean isn’t very helpful. We need a way to draw text to the canvas.\n\nA 2D canvas drawing context provides the methods and . The latter can be useful for outlining letters, but usually is what you need. It will fill the outline of the given text with the current .\n\nYou can specify the size, style, and font of the text with the property. This example just gives a font size and family name. It is also possible to add or to the start of the string to select a style.\n\nThe last two arguments to and provide the position at which the font is drawn. By default, they indicate the position of the start of the text’s alphabetic baseline, which is the line that letters “stand” on, not counting hanging parts in letters such as j or p. You can change the horizontal position by setting the property to or and the vertical position by setting to , , or .\n\nWe’ll come back to our pie chart, and the problem of labeling the slices, in the exercises at the end of the chapter.\n\nIn computer graphics, a distinction is often made between vector graphics and bitmap graphics. The first is what we have been doing so far in this chapter—specifying a picture by giving a logical description of shapes. Bitmap graphics, on the other hand, don’t specify actual shapes but rather work with pixel data (rasters of colored dots).\n\nThe method allows us to draw pixel data onto a canvas. This pixel data can originate from an element or from another canvas. The following example creates a detached element and loads an image file into it. But the method cannot immediately start drawing from this picture because the browser may not have loaded it yet. To deal with this, we register a event handler and do the drawing after the image has loaded.\n\nBy default, will draw the image at its original size. You can also give it two additional arguments to specify the width and height of the drawn image, when those aren’t the same as the origin image.\n\nWhen is given nine arguments, it can be used to draw only a fragment of an image. The second through fifth arguments indicate the rectangle (x, y, width, and height) in the source image that should be copied, and the sixth to ninth arguments give the rectangle (on the canvas) into which it should be copied.\n\nThis can be used to pack multiple sprites (image elements) into a single image file and then draw only the part you need. For example, this picture contains a game character in multiple poses:\n\nBy alternating which pose we draw, we can show an animation that looks like a walking character.\n\nTo animate a picture on a canvas, the method is useful. It resembles , but instead of coloring the rectangle, it makes it transparent, removing the previously drawn pixels.\n\nWe know that each sprite, each subpicture, is 24 pixels wide and 30 pixels high. The following code loads the image and then sets up an interval (repeated timer) to draw the next frame:\n\nThe binding tracks our position in the animation. For each frame, it is incremented and then clipped back to the 0 to 7 range by using the remainder operator. This binding is then used to compute the x-coordinate that the sprite for the current pose has in the picture.\n\nWhat if we want our character to walk to the left instead of to the right? We could draw another set of sprites, of course. But we could also instruct the canvas to draw the picture the other way round.\n\nCalling the method will cause anything drawn after it to be scaled. This method takes two parameters, one to set a horizontal scale and one to set a vertical scale.\n\nScaling will cause everything about the drawn image, including the line width, to be stretched out or squeezed together as specified. Scaling by a negative amount will flip the picture around. The flipping happens around point (0, 0), which means it will also flip the direction of the coordinate system. When a horizontal scaling of -1 is applied, a shape drawn at x position 100 will end up at what used to be position -100.\n\nTo turn a picture around, we can’t simply add before the call to . That would move our picture outside of the canvas, where it won’t be visible. We could adjust the coordinates given to to compensate for this by drawing the image at x position -50 instead of 0. Another solution, which doesn’t require the code doing the drawing to know about the scale change, is to adjust the axis around which the scaling happens.\n\nThere are several other methods besides that influence the coordinate system for a canvas. You can rotate subsequently drawn shapes with the method and move them with the method. The interesting—and confusing—thing is that these transformations stack, meaning that each one happens relative to the previous transformations.\n\nIf we translate by 10 horizontal pixels twice, everything will be drawn 20 pixels to the right. If we first move the center of the coordinate system to (50, 50) and then rotate by 20 degrees (about 0.1π radians), that rotation will happen around point (50, 50).\n\nBut if we first rotate by 20 degrees and then translate by (50, 50), the translation will happen in the rotated coordinate system and thus produce a different orientation. The order in which transformations are applied matters.\n\nTo flip a picture around the vertical line at a given x position, we can do the following:\n\nWe move the y-axis to where we want our mirror to be, apply the mirroring, and finally move the y-axis back to its proper place in the mirrored universe. The following picture explains why this works:\n\nThis shows the coordinate systems before and after mirroring across the central line. The triangles are numbered to illustrate each step. If we draw a triangle at a positive x position, it would, by default, be in the place where triangle 1 is. A call to first does a translation to the right, which gets us to triangle 2. It then scales, flipping the triangle over to position 3. This is not where it should be, if it were mirrored in the given line. The second call fixes this—it “cancels” the initial translation and makes triangle 4 appear exactly where it should.\n\nWe can now draw a mirrored character at position (100, 0) by flipping the world around the character’s vertical center.\n\nTransformations stick around. Everything else we draw after drawing that mirrored character would also be mirrored. That might be inconvenient.\n\nIt is possible to save the current transformation, do some drawing and transforming, and then restore the old transformation. This is usually the proper thing to do for a function that needs to temporarily transform the coordinate system. First, we save whatever transformation the code that called the function was using. Then the function does its thing, adding more transformations on top of the current transformation. Finally, we revert to the transformation we started with.\n\nThe and methods on the 2D canvas context do this transformation management. They conceptually keep a stack of transformation states. When you call , the current state is pushed onto the stack, and when you call , the state on top of the stack is taken off and used as the context’s current transformation. You can also call to fully reset the transformation.\n\nThe function in the following example illustrates what you can do with a function that changes the transformation and then calls a function (in this case itself), which continues drawing with the given transformation.\n\nThis function draws a treelike shape by drawing a line, moving the center of the coordinate system to the end of the line, and calling itself twice—first rotated to the left and then rotated to the right. Every call reduces the length of the branch drawn, and the recursion stops when the length drops below 8.\n\nIf the calls to and were not there, the second recursive call to would end up with the position and rotation created by the first call. It would be connected not to the current branch but rather to the innermost, rightmost branch drawn by the first call. The resulting shape might also be interesting, but it is definitely not a tree.\n\nWe now know enough about canvas drawing to start working on a canvas-based display system for the game from the previous chapter. The new display will no longer be showing just colored boxes. Instead, we’ll use to draw pictures that represent the game’s elements.\n\nWe define another display object type called , supporting the same interface as from Chapter 16—namely, the methods and .\n\nThis object keeps a little more information than . Rather than using the scroll position of its DOM element, it tracks its own viewport, which tells us which part of the level we are currently looking at. Finally, it keeps a property so that even when the player is standing still, it keeps facing the direction in which it last moved.\n\nThe method first computes a new viewport and then draws the game scene at the appropriate position.\n\nContrary to , this display style does have to redraw the background on every update. Because shapes on a canvas are just pixels, after we draw them there is no good way to move them (or remove them). The only way to update the canvas display is to clear it and redraw the scene. We may also have scrolled, which requires the background to be in a different position.\n\nThe method is similar to ’s method. It checks whether the player is too close to the edge of the screen and moves the viewport when this is the case.\n\nThe calls to and ensure that the viewport does not end up showing space outside of the level. makes sure the resulting number is not less than zero. similarly guarantees that a value stays below a given bound.\n\nWhen clearing the display, we’ll use a slightly different color depending on whether the game is won (brighter) or lost (darker).\n\nTo draw the background, we run through the tiles that are visible in the current viewport, using the same trick used in the method from the previous chapter.\n\nTiles that are not empty are drawn with . The image contains the pictures used for elements other than the player. It contains, from left to right, the wall tile, the lava tile, and the sprite for a coin.\n\nBackground tiles are 20 by 20 pixels, since we’ll use the same scale as in . Thus, the offset for lava tiles is 20 (the value of the binding), and the offset for walls is 0.\n\nWe don’t bother waiting for the sprite image to load. Calling with an image that hasn’t been loaded yet will simply do nothing. Thus, we might fail to draw the game properly for the first few frames while the image is still loading, but that isn’t a serious problem. Since we keep updating the screen, the correct scene will appear as soon as the loading finishes.\n\nThe walking character shown earlier will be used to represent the player. The code that draws it needs to pick the right sprite and direction based on the player’s current motion. The first eight sprites contain a walking animation. When the player is moving along a floor, we cycle through them based on the current time. We want to switch frames every 60 milliseconds, so the time is divided by 60 first. When the player is standing still, we draw the ninth sprite. During jumps, which are recognized by the fact that the vertical speed is not zero, we use the tenth, rightmost sprite.\n\nBecause the sprites are slightly wider than the player object—24 instead of 16 pixels to allow some space for feet and arms—the method has to adjust the x-coordinate and width by a given amount ( ).\n\nThe method is called by , which is responsible for drawing all the actors in the game.\n\nWhen drawing something that is not the player, we look at its type to find the offset of the correct sprite. The lava tile is found at offset 20, and the coin sprite is found at 40 (two times ).\n\nWe have to subtract the viewport’s position when computing the actor’s position, since (0, 0) on our canvas corresponds to the top left of the viewport, not the top left of the level. We could also have used for this. Either way works.\n\nThis document plugs the new display into :\n\nWhen you need to generate graphics in the browser, you can choose between plain HTML, SVG, and canvas. There is no single best approach that works in all situations. Each option has strengths and weaknesses.\n\nPlain HTML has the advantage of being simple. It also integrates well with text. Both SVG and canvas allow you to draw text, but they won’t help you position that text or wrap it when it takes up more than one line. In an HTML-based picture, it is much easier to include blocks of text.\n\nSVG can be used to produce crisp graphics that look good at any zoom level. Unlike HTML, it is designed for drawing and is thus more suitable for that purpose.\n\nBoth SVG and HTML build up a data structure (the DOM) that represents your picture. This makes it possible to modify elements after they are drawn. If you need to repeatedly change a small part of a big picture in response to what the user is doing or as part of an animation, doing it in a canvas can be needlessly expensive. The DOM also allows us to register mouse event handlers on every element in the picture (even on shapes drawn with SVG). You can’t do that with canvas.\n\nBut canvas’s pixel-oriented approach can be an advantage when drawing a huge number of tiny elements. The fact that it does not build up a data structure but only repeatedly draws onto the same pixel surface gives canvas a lower cost per shape. There are also effects that are only practical with a canvas element, such as rendering a scene one pixel at a time (for example, using a ray tracer) or postprocessing an image with JavaScript (blurring or distorting it).\n\nIn some cases, you may want to combine several of these techniques. For example, you might draw a graph with SVG or canvas but show textual information by positioning an HTML element on top of the picture.\n\nFor nondemanding applications, it really doesn’t matter much which interface you choose. The display we built for our game in this chapter could have been implemented using any of these three graphics technologies, since it does not need to draw text, handle mouse interaction, or work with an extraordinarily large number of elements.\n\nIn this chapter we discussed techniques for drawing graphics in the browser, focusing on the element.\n\nA canvas node represents an area in a document that our program may draw on. This drawing is done through a drawing context object, created with the method.\n\nThe 2D drawing interface allows us to fill and stroke various shapes. The context’s property determines how shapes are filled. The and properties control the way lines are drawn.\n\nRectangles and pieces of text can be drawn with a single method call. The and methods draw rectangles, and the and methods draw text. To create custom shapes, we must first build up a path.\n\nCalling starts a new path. A number of other methods add lines and curves to the current path. For example, can add a straight line. When a path is finished, it can be filled with the method or stroked with the method.\n\nMoving pixels from an image or another canvas onto our canvas is done with the method. By default, this method draws the whole source image, but by giving it more parameters, you can copy a specific area of the image. We used this for our game by copying individual poses of the game character out of an image that contained many such poses.\n\nTransformations allow you to draw a shape in multiple orientations. A 2D drawing context has a current transformation that can be changed with the , , and methods. These will affect all subsequent drawing operations. A transformation state can be saved with the method and restored with the method.\n\nWhen showing an animation on a canvas, the method can be used to clear part of the canvas before redrawing it.\n\nWrite a program that draws the following shapes on a canvas:\n• A trapezoid (a rectangle that is wider on one side)\n\nWhen drawing the last two shapes, you may want to refer to the explanation of and in Chapter 14, which describes how to get coordinates on a circle using these functions.\n\nI recommend creating a function for each shape. Pass the position, and optionally other properties such as the size or the number of points, as parameters. The alternative, which is to hardcode numbers all over your code, tends to make the code needlessly hard to read and modify.\n\nEarlier in the chapter, we saw an example program that drew a pie chart. Modify this program so that the name of each category is shown next to the slice that represents it. Try to find a pleasing-looking way to automatically position this text that would work for other datasets as well. You may assume that categories are big enough to leave enough room for their labels.\n\nYou might need and again, which are described in Chapter 14.\n\nUse the technique that we saw in Chapter 14 and Chapter 16 to draw a box with a bouncing ball in it. The ball moves at a constant speed and bounces off the box’s sides when it hits them.\n\nOne unfortunate thing about transformations is that they slow down the drawing of bitmaps. The position and size of each pixel have to be transformed, and though it is possible that browsers will get cleverer about transformation in the future, they currently cause a measurable increase in the time it takes to draw a bitmap.\n\nIn a game like ours, where we are drawing only a single transformed sprite, this is a nonissue. But imagine that we need to draw hundreds of characters or thousands of rotating particles from an explosion.\n\nThink of a way to draw an inverted character without loading additional image files and without having to make transformed calls every frame."
    }
]