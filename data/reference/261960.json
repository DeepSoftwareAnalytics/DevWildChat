[
    {
        "link": "https://docs.djangoproject.com/en/5.1/topics/http/file-uploads",
        "document": "When Django handles a file upload, the file data ends up placed in (for more on the object see the documentation for request and response objects). This document explains how files are stored on disk and in memory, and how to customize the default behavior.\n\nA view handling this form will receive the file data in , which is a dictionary containing a key for each (or , or other subclass) in the form. So the data from the above form would be accessible as . Note that will only contain data if the request method was , at least one file field was actually posted, and the that posted the request has the attribute . Otherwise, will be empty. Most of the time, you’ll pass the file data from into the form as described in Binding uploaded files to a form. This would look something like: Notice that we have to pass into the form’s constructor; this is how file data gets bound into a form. Here’s a common way you might handle an uploaded file: Looping over instead of using ensures that large files don’t overwhelm your system’s memory. There are a few other methods and attributes available on objects; see for a complete reference. If you’re saving a file on a with a , using a makes this process much easier. The file object will be saved to the location specified by the argument of the corresponding when calling : If you are constructing an object manually, you can assign the file object from to the file field in the model: If you are constructing an object manually outside of a request, you can assign a like object to the : If you want to upload multiple files using one form field, create a subclass of the field’s widget and set its class attribute to . In order for such files to be all validated by your form (and have the value of the field include them all), you will also have to subclass . See below for an example. Django is likely to have a proper multiple file field support at some point in the future. Then override the method of your subclass to handle multiple file uploads: # Replace with your URL or reverse(). # Do something with each file. This will allow you to handle multiple files at the form level only. Be aware that you cannot use it to put multiple files on a single model instance (in a single field), for example, even if the custom widget is used with a form field related to a model .\n\nWhen a user uploads a file, Django passes off the file data to an upload handler – a small class that handles file data as it gets uploaded. Upload handlers are initially defined in the setting, which defaults to: Together and provide Django’s default file upload behavior of reading small files into memory and large ones onto disk. You can write custom handlers that customize how Django handles files. You could, for example, use custom handlers to enforce user-level quotas, compress data on the fly, render progress bars, and even send data to another storage location directly without storing it locally. See Writing custom upload handlers for details on how you can customize or completely replace upload behavior. Before you save uploaded files, the data needs to be stored somewhere. By default, if an uploaded file is smaller than 2.5 megabytes, Django will hold the entire contents of the upload in memory. This means that saving the file involves only a read from memory and a write to disk and thus is very fast. However, if an uploaded file is too large, Django will write the uploaded file to a temporary file stored in your system’s temporary directory. On a Unix-like platform this means you can expect Django to generate a file called something like . If an upload is large enough, you can watch this file grow in size as Django streams the data onto disk. These specifics – 2.5 megabytes; ; etc. – are “reasonable defaults” which can be customized as described in the next section. There are a few settings which control Django’s file upload behavior. See File Upload Settings for details. Sometimes particular views require different upload behavior. In these cases, you can override upload handlers on a per-request basis by modifying . By default, this list will contain the upload handlers given by , but you can modify the list as you would any other list. For instance, suppose you’ve written a that provides feedback on upload progress to some sort of AJAX widget. You’d add this handler to your upload handlers like this: You’d probably want to use in this case (instead of ) because a progress bar handler would need to run before any other handlers. Remember, the upload handlers are processed in order. If you want to replace the upload handlers completely, you can assign a new list: You can only modify upload handlers before accessing or – it doesn’t make sense to change upload handlers after upload handling has already started. If you try to modify after reading from or Django will throw an error. Thus, you should always modify uploading handlers as early in your view as possible. Also, is accessed by which is enabled by default. This means you will need to use on your view to allow you to change the upload handlers. You will then need to use on the function that actually processes the request. Note that this means that the handlers may start receiving the file upload before the CSRF checks have been done. Example code: If you are using a class-based view, you will need to use on its method and on the method that actually processes the request. Example code:"
    },
    {
        "link": "https://docs.djangoproject.com/fr/4.2/topics/http/file-uploads",
        "document": "When Django handles a file upload, the file data ends up placed in (for more on the object see the documentation for request and response objects). This document explains how files are stored on disk and in memory, and how to customize the default behavior.\n\nA view handling this form will receive the file data in , which is a dictionary containing a key for each (or , or other subclass) in the form. So the data from the above form would be accessible as . Note that will only contain data if the request method was , at least one file field was actually posted, and the that posted the request has the attribute . Otherwise, will be empty. Most of the time, you’ll pass the file data from into the form as described in Liaison de fichiers téléversés avec un formulaire. This would look something like: Notice that we have to pass into the form’s constructor; this is how file data gets bound into a form. There are a few other methods and attributes available on objects; see for a complete reference. If you’re saving a file on a with a , using a makes this process much easier. The file object will be saved to the location specified by the argument of the corresponding when calling : If you are constructing an object manually, you can assign the file object from to the file field in the model: If you are constructing an object manually outside of a request, you can assign a like object to the : If you want to upload multiple files using one form field, create a subclass of the field’s widget and set the attribute on it to . In order for such files to be all validated by your form (and have the value of the field include them all), you will also have to subclass . See below for an example. Django is likely to have a proper multiple file field support at some point in the future. Then override the method of your subclass to handle multiple file uploads: This will allow you to handle multiple files at the form level only. Be aware that you cannot use it to put multiple files on a single model instance (in a single field), for example, even if the custom widget is used with a form field related to a model . In previous versions, there was no support for the class attribute, and users were advised to create the widget with the HTML attribute set through the argument. However, this caused validation of the form field to be applied only to the last file submitted, which could have adverse security implications.\n\nWhen a user uploads a file, Django passes off the file data to an upload handler – a small class that handles file data as it gets uploaded. Upload handlers are initially defined in the setting, which defaults to: Together and provide Django’s default file upload behavior of reading small files into memory and large ones onto disk. You can write custom handlers that customize how Django handles files. You could, for example, use custom handlers to enforce user-level quotas, compress data on the fly, render progress bars, and even send data to another storage location directly without storing it locally. See Écriture de gestionnaires de téléversement personnalisés for details on how you can customize or completely replace upload behavior. Before you save uploaded files, the data needs to be stored somewhere. By default, if an uploaded file is smaller than 2.5 megabytes, Django will hold the entire contents of the upload in memory. This means that saving the file involves only a read from memory and a write to disk and thus is very fast. However, if an uploaded file is too large, Django will write the uploaded file to a temporary file stored in your system’s temporary directory. On a Unix-like platform this means you can expect Django to generate a file called something like . If an upload is large enough, you can watch this file grow in size as Django streams the data onto disk. These specifics – 2.5 megabytes; ; etc. – are « reasonable defaults » which can be customized as described in the next section. There are a few settings which control Django’s file upload behavior. See File Upload Settings for details. Sometimes particular views require different upload behavior. In these cases, you can override upload handlers on a per-request basis by modifying . By default, this list will contain the upload handlers given by , but you can modify the list as you would any other list. For instance, suppose you’ve written a that provides feedback on upload progress to some sort of AJAX widget. You’d add this handler to your upload handlers like this: You’d probably want to use in this case (instead of ) because a progress bar handler would need to run before any other handlers. Remember, the upload handlers are processed in order. If you want to replace the upload handlers completely, you can assign a new list: You can only modify upload handlers before accessing or – it doesn’t make sense to change upload handlers after upload handling has already started. If you try to modify after reading from or Django will throw an error. Thus, you should always modify uploading handlers as early in your view as possible. Also, is accessed by which is enabled by default. This means you will need to use on your view to allow you to change the upload handlers. You will then need to use on the function that actually processes the request. Note that this means that the handlers may start receiving the file upload before the CSRF checks have been done. Example code: If you are using a class-based view, you will need to use on its method and on the method that actually processes the request. Example code:"
    },
    {
        "link": "https://stackoverflow.com/questions/64130859/django-filefield-imagefield-validation-when-the-file-upload-is-being-done-from-t",
        "document": "When ever client wants to upload a file it first request the Django server for a URL the server then generates a URL and sends it back to the client.\n\nThe client can use this URL to upload to file directly to S3. Once the upload is successful the client sends the file key back to the server (the file key is also present in the response given by the server along with the URL).\n\nNow I'm confused as to how to pass the FileField validation given that I only have the file key with me and not the actual file. For example:\n\nWithin the serializer I'm first replacing the file key with the actual file using the which is hooked up to S3 using . Then once the file has been successfully validated, I then again replace the actual file with the file key in the function.\n\nThe reason I replace the actual file with the file is because it is slowing down the method (upto 30s).\n\nI feel like this is a very hacky method and wanted to know if there is a better way to handle this situation. Should I replace the / with a and not do any validation?\n\nOr maybe use celery to do the validation? But then what if the validation fails? How should the server inform the client that the validation has failed for some reason in the background?"
    },
    {
        "link": "https://python.plainenglish.io/django-filefield-and-imagefield-explained-a-comprehensive-guide-for-beginners-and-advanced-users-4054245f634a",
        "document": "Django FileField and ImageField Explained: A Comprehensive Guide for Beginners and Advanced Users Managing files and images in web applications is a common task for developers, and Django provides a robust solution for handling file uploads through and . These fields are powerful yet easy to use once you understand how they work. In this article, we’ll dive deep into the details of both and , covering everything from basic setup to more advanced use cases. Whether you’re a beginner looking to upload your first file in Django or an experienced developer working on more complex projects, this guide will provide the information you need to get the job done effectively.\n\nWhat are Django FileField and ImageField? is a Django model field used to upload and store files. You can upload any type of file—documents, PDFs, videos, etc. Django handles the file path, and you can customize how and where the files are saved. is a specialized version of that only allows image uploads. It validates that the uploaded file is indeed an image, ensuring your application doesn't receive non-image files by mistake. Both fields work similarly in most cases, but they cater to slightly different needs. Let’s explore their use cases in detail.\n\nHow to Set Up FileField and ImageField Before you start working with , make sure you have the Pillow library installed. Pillow is a powerful image processing library that Django uses to handle image files. You can install it using pip: There are no extra dependencies required for . To add file or image handling to your Django project, you’ll need to modify your model. Here’s an example of how to define models for and . parameter: This specifies the folder where the files or images will be saved. In the example above, documents will be stored in a folder named , and images will go to the folder.\n\nNow that you have your models defined, let’s handle file uploads in a Django view. You’ll need to create a form to handle file input from the user. Here’s an example: from django.shortcuts import render, redirect\n\nfrom .forms import DocumentForm\n\n\n\ndef upload_document(request):\n\n if request.method == 'POST':\n\n form = DocumentForm(request.POST, request.FILES)\n\n if form.is_valid():\n\n form.save()\n\n return redirect('document_success')\n\n else:\n\n form = DocumentForm()\n\n\n\n return render(request, 'upload_document.html', {'form': form}) Create an HTML file ( ) to render the form. After uploading a file, it will be saved to the folder specified in the argument ( ). You can now retrieve and display the uploaded file from the database."
    },
    {
        "link": "https://simpleisbetterthancomplex.com/tutorial/2016/08/01/how-to-upload-files-with-django.html",
        "document": "In this tutorial you will learn the concepts behind Django file upload and how to handle file upload using model forms. In the end of this post you will find the source code of the examples I used so you can try and explore.\n\nThis tutorial is also available in video format:\n\nThe Basics of File Upload With Django\n\nWhen files are submitted to the server, the file data ends up placed in .\n\nIt is mandatory for the HTML form to have the attribute set correctly. Otherwise the will be empty.\n\nThe form must be submitted using the POST method.\n\nDjango have proper model fields to handle uploaded files: and .\n\nThe files uploaded to or are not stored in the database but in the filesystem.\n\nand are created as a string field in the database (usually VARCHAR), containing the reference to the actual file.\n\nIf you delete a model instance containing or , Django will not delete the physical file, but only the reference to the file.\n\nThe is a dictionary-like object. Each key in is the name from the .\n\nEach value in is an instance.\n\nYou will need to set and in your project’s settings.py.\n\nIn the development server you may serve the user uploaded files (media) using django.contrib.staticfiles.views.serve() view.\n\nTo access the in template you must add to your inside the config.\n\nFollowing is a minimal file upload example using . Use it just to learn about the flow of the process.\n\nNow, this is a way more convenient way. Model forms perform validation, automatically builds the absolute path for the upload, treats filename conflicts and other common tasks.\n\nSee the example below:\n\nNote the parameter. The files will be automatically uploaded to .\n\nIt is also possible to do something like:\n\nA file uploaded today would be uploaded to .\n\nThe can also be a callable that returns a string. This callable accepts two parameters, instance and filename.\n\nThe code used in this post is available on Github."
    },
    {
        "link": "https://pillow.readthedocs.io/en/stable/handbook/image-file-formats.html",
        "document": "The Python Imaging Library supports a wide variety of raster file formats. Over 30 different file formats can be identified and read by the library. Write support is less extensive, but most common interchange and presentation formats are supported.\n\nThe function identifies files from their contents, not their names, but the method looks at the name to determine which format to use, unless the format is given explicitly.\n\nWhen an image is opened from a file, only that instance of the image is considered to have the format. Copies of the image will contain data loaded from the file, but not the file itself, meaning that it can no longer be considered to be in the original format. So if is called on an image, or another method internally creates a copy of the image, then any methods or attributes specific to the format will no longer be present. The (file pointer) attribute will no longer be present, and the attribute will be .\n\nBLP is the Blizzard Mipmap Format, a texture format used in World of Warcraft. Pillow supports reading Compressed or raw images, and all types of images. Pillow supports writing BLP images. The method can take the following keyword arguments: If present and set to “BLP1”, images will be saved as BLP1. Otherwise, images will be saved as BLP2. Pillow reads and writes Windows and OS/2 BMP files containing , , , or data. 16-colour images are read as images. Support for reading 8-bit run-length encoding was added in Pillow 9.1.0. Support for reading 4-bit run-length encoding was added in Pillow 9.3.0. The method sets the following properties: Set to 1 if the file is a 256-color run-length encoded image. Set to 2 if the file is a 16-color run-length encoded image. DDS is a popular container texture format used in video games and natively supported by DirectX. DXT1 and DXT5 pixel formats can be read, only in mode. Added in version 3.4.0: DXT3 images can be read in mode and DX10 images can be read in and mode. Added in version 6.0.0: Uncompressed images can be read. Added in version 8.3.0: BC5S images can be opened in mode, and uncompressed images can be read. Uncompressed data can also be saved to image files. Added in version 9.3.0: ATI1 images can be opened in mode and ATI2 images can be opened in mode. Added in version 9.4.0: Uncompressed (“luminance”) and images can be opened and saved. Added in version 10.1.0: BC5U can be read in mode, and 8-bit color indexed images can be read in mode. Pillow reads and writes DIB files. DIB files are similar to BMP files, so see above for more information. Pillow identifies EPS files containing image data, and can read files that contain embedded raster images (ImageData descriptors). If Ghostscript is available, other EPS files can be read as well. The EPS driver can also write EPS images. The EPS driver can read EPS images in , , and mode, but Ghostscript may convert the images to mode rather than leaving them in the original color space. The EPS driver can write images in , and modes. To use Ghostscript, Pillow searches for the “gs” executable. On Windows, it also searches for “gswin32c” and “gswin64c”. To customise this behaviour, will set the name of the executable to use. will prevent Ghostscript use. If Ghostscript is available, you can call the method with the following parameters to affect how Ghostscript renders the EPS. Affects the scale of the resultant rasterized image. If the EPS suggests that the image be rendered at 100px x 100px, setting this parameter to 2 will make the Ghostscript render a 200px x 200px image instead. The relative position of the bounding box is maintained: If true, generates an RGBA image with a transparent background, instead of the default behaviour of an RGB image with a white background. Pillow reads GIF87a and GIF89a versions of the GIF file format. The library writes files in GIF87a by default, unless GIF89a features are used or GIF89a is already in use. Files are written with LZW encoding. GIF files are initially read as grayscale ( ) or palette mode ( ) images. Seeking to later frames in a image will change the image to (or if the first frame had transparency). mode images are changed to because each frame of a GIF may contain its own individual palette of up to 256 colors. When a new frame is placed onto a previous frame, those colors may combine to exceed the mode limit of 256 colors. Instead, the image is converted to handle this. If you would prefer the first image frame to be as well, so that every frame is converted to or mode, there is a setting available: GIF frames do not always contain individual palettes however. If there is only a global palette, then all of the colors can fit within mode. If you would prefer the frames to be kept as in that case, there is also a setting available: To restore the default behavior, where mode images are only converted to or after the first frame: The method sets the following properties: Transparency color index. This key is omitted if the image is not transparent. May not be present. The time to display the current frame of the GIF, in milliseconds. May not be present. The number of times the GIF should loop. 0 means that it will loop forever. May not be present. A comment about the image. This is the last comment found before the current frame’s image. May not be present. Contains application specific information. The GIF loader supports the and methods. You can combine these methods to seek to the next frame ( ). raises an if you try to seek after the last frame. When calling to write a GIF file, the following options are available: If present and true, all frames of the image will be saved. If not, then only the first frame of a multiframe image will be saved. A list of images to append as additional frames. Each of the images in the list can be single or multiframe images. This is currently supported for GIF, PDF, PNG, TIFF, and WebP. It is also supported for ICO and ICNS. If images are passed in of relevant sizes, they will be used instead of scaling down the main image. Whether or not to include local color table. Whether or not the image is interlaced. By default, it is, unless the image is less than 16 pixels in width or height. Indicates the way in which the graphic is to be treated after being displayed. Pass a single integer for a constant disposal, or a list or tuple to set the disposal for each frame separately. Use the specified palette for the saved image. The palette should be a bytes or bytearray object containing the palette entries in RGBRGB… form. It should be no more than 768 bytes. Alternately, the palette can be passed in as an object. Whether to attempt to compress the palette by eliminating unused colors (this is only useful if the palette can be compressed to the next smaller power of 2 elements) and whether to mark all pixels that are not new in the next frame as transparent. This is attempted by default, unless a palette is specified as an option or as part of the first image’s dictionary. Note that if the image you are saving comes from an existing GIF, it may have the following properties in its dictionary. For these options, if you do not pass them in, they will default to their values. The display duration of each frame of the multiframe gif, in milliseconds. Pass a single integer for a constant duration, or a list or tuple to set the duration for each frame separately. Integer number of times the GIF should loop. 0 means that it will loop forever. If omitted or , the image will not loop. The GIF loader creates an image memory the same size as the GIF file’s logical screen size, and pastes the actual pixel data (the local image) into this image. If you only want the actual pixel rectangle, you can crop the image: # only read the first \"local image\" from this GIF file Pillow reads and writes macOS files. By default, the largest available icon is read, though you can override this by setting the property before calling . The method sets the following property: Prior to version 8.3.0, Pillow could only write ICNS files on macOS. A list of supported sizes found in this icon file; these are a 3-tuple, , where is 2 for a retina icon and 1 for a standard icon. You can call the method with the following parameter. Affects the scale of the resultant image. If the size is set to , after loading at scale 2, the final value of will be . The method can take the following keyword arguments: A list of images to replace the scaled down versions of the image. The order of the images does not matter, as their use is determined by the size of each image. ICO is used to store icons on Windows. The largest available icon is read. The method supports the following options: A list of sizes including in this ico file; these are a 2-tuple, ; Default to . Any sizes bigger than the original size or 256 will be ignored. The method can take the following keyword arguments: A list of images to replace the scaled down versions of the image. The order of the images does not matter, as their use is determined by the size of each image. By default, the image data will be saved in PNG format. With a bitmap format of “bmp”, image data will be saved in BMP format instead. IM is a format used by LabEye and other applications based on the IFUNC image processing library. The library reads and writes most uncompressed interchange versions of this format. IM is the only format that can store all internal Pillow formats. Pillow reads JPEG, JFIF, and Adobe JPEG files containing , , or data. It writes standard and progressive JFIF files. Using the method, you can speed things up by converting images to , and resize images to 1/2, 1/4 or 1/8 of their original size while loading them. By default Pillow doesn’t allow loading of truncated JPEG files, set to override this. The method may set the following properties if available: JFIF application marker found. If the file is not a JFIF file, this key is not present. A tuple representing the pixel density of the image, in units specified by jfif_unit. A tuple representing the reported pixel density in pixels per inch, if the file is a jfif file and the units are in inches. Adobe application marker found. If the file is not an Adobe JPEG file, this key is not present. Indicates that this is a progressive JPEG file. The ICC color profile for the image. The method supports the following options: The image quality, on a scale from 0 (worst) to 95 (best), or the string . The default is 75. Values above 95 should be avoided; 100 disables portions of the JPEG compression algorithm, and results in large files with hardly any gain in image quality. The value is only valid for JPEG files and will retain the original image quality level, subsampling, and qtables. If present and true, indicates that the encoder should make an extra pass over the image in order to select optimal encoder settings. If present and true, indicates that this image should be stored as a progressive JPEG file. If present and true, the image is stored with the provided ICC profile. If this parameter is not provided, the image will be saved with no profile attached. To preserve the existing profile: If present, the image will be stored with the provided raw EXIF data. By default, libjpeg converts images with an RGB color space to YCbCr. If this option is present and true, those images will be stored as RGB instead. When this option is enabled, attempting to chroma-subsample RGB images with the option will raise an . If present, sets the subsampling for the encoder.\n• None : Only valid for JPEG files, will retain the original image setting. If absent, the setting will be determined by libjpeg or libjpeg-turbo. If present, emit a restart marker whenever the specified number of MCU blocks has been produced. If present, emit a restart marker whenever the specified number of MCU rows has been produced. If present, sets the qtables for the encoder. This is listed as an advanced option for wizards in the JPEG documentation. Use with caution. can be one of several types of values:\n• None a list, tuple, or dictionary (with integer keys = range(len(keys))) of lists of 64 integers. There must be between 2 and 4 tables. Allows storing images without quantization and Huffman tables, or with these tables but without image data. This is useful for container formats or network protocols that handle tables separately and share them between images. To enable JPEG support, you need to build and install the IJG JPEG library before building the Python Imaging Library. See the distribution README for details. Pillow reads and writes JPEG 2000 files containing , , , , or data. When reading, data is converted to or depending on whether or not there is an alpha channel. Added in version 8.3.0: Pillow can read (but not write) , , and images with subsampled components. Added in version 10.4.0: Pillow can read images with OpenJPEG 2.5.1 and later. Added in version 11.1.0: Pillow can write images with OpenJPEG 2.5.3 and later. Pillow supports JPEG 2000 raw codestreams ( files), as well as boxed JPEG 2000 files ( or files). When loading, if you set the on the image prior to the method being invoked, you can ask Pillow to convert the image to either or rather than choosing for itself. It is also possible to set to the number of resolutions to discard (each one reduces the size of the resulting image by a factor of 2), and to specify the number of quality layers to load. The method supports the following options: The image offset, as a tuple of integers, e.g. (16, 16) The tile offset, again as a 2-tuple of integers. The tile size as a 2-tuple. If not specified, or if set to None, the image will be saved without tiling. Either or depending on the units you want to use to specify image quality. A sequence of numbers, each of which represents either an approximate size reduction (if quality mode is ) or a signal to noise ratio value in decibels. If not specified, defaults to a single layer of full quality. The number of different image resolutions to be stored (which corresponds to the number of Discrete Wavelet Transform decompositions plus one). The code-block size as a 2-tuple. Minimum size is 4 x 4, maximum is 1024 x 1024, with the additional restriction that no code-block may have more than 4096 coefficients (i.e. the product of the two numbers must be no greater than 4096). The precinct size as a 2-tuple. Must be a power of two along both axes, and must be greater than the code-block size. If , use the lossy discrete waveform transformation DWT 9-7. Defaults to , which uses the lossless DWT 5-3. If then enable multiple component transformation when encoding, otherwise use for no component transformation (default). If MCT is enabled and is then the Irreversible Color Transformation will be applied, otherwise encoding will use the Reversible Color Transformation. MCT works best with a of and is only applicable when the image data has 3 components. Controls the progression order; must be one of , , , , . The letters stand for Component, Position, Resolution and Layer respectively and control the order of encoding, the idea being that e.g. an image encoded using LRCP mode can have its quality layers decoded as they arrive at the decoder, while one encoded using RLCP mode will have increasing resolutions decoded as they arrive, and so on. If true, then tell the encoder to save the image as signed. Set the encoder to produce output compliant with the digital cinema specifications. The options here are (the default), for 24fps 2K, for 48fps 2K, and for 24fps 4K. Note that for compliant 2K files, at least one of your image dimensions must match 2048 x 1080, while for compliant 4K files, at least one of the dimensions must match 4096 x 2160. If then don’t wrap the raw codestream in the JP2 file format when saving, otherwise the extension of the filename will be used to determine the format (default). Adds a custom comment to the file, replacing the default “Created by OpenJPEG version” comment. If and OpenJPEG 2.4.0 or later is available, then include a PLT (packet length, tile-part header) marker in the produced file. Defaults to . To enable JPEG 2000 support, you need to build and install the OpenJPEG library, version 2.0.0 or higher, before building the Python Imaging Library. Windows users can install the OpenJPEG binaries available on the OpenJPEG website, but must add them to their PATH in order to use Pillow (if you fail to do this, you will get errors about not being able to load the DLL). Pillow reads and writes Multi Picture Object (MPO) files. When first opened, it loads the primary image. The and methods may be used to read other pictures from the file. The pictures are zero-indexed and random access is supported. When calling to write an MPO file, by default only the first frame of a multiframe image will be saved. If the argument is present and true, then all frames will be saved, and the following option will also be available. A list of images to append as additional pictures. Each of the images in the list can be single or multiframe images. Pillow identifies and reads MSP files from Windows 1 and 2. The library writes uncompressed (Windows 1) versions of this format. Pillow reads and writes PCX files containing , , , or data. The function sets the following properties: The absolute value of the number stored in the Scale Factor / Endianness line. Pillow identifies, reads, and writes PNG files containing , , , , , or data. Interlaced files are supported as of v1.1.7. As of Pillow 6.0, EXIF data can be read from PNG images. However, unlike other image formats, EXIF data is not guaranteed to be present in until has been called. By default Pillow doesn’t allow loading of truncated PNG files, set to override this. The function sets the following properties, when appropriate: The chromaticity points, as an 8 tuple of floats. ( , , , , , , , ) The sRGB rendering intent as an integer. For images: Either the palette index for full transparent pixels, or a byte string with alpha values for each palette entry. For , , and images, the color that represents full transparent pixels in this image. This key is omitted if the image is not a transparent palette image. also sets to a dictionary of the values of the , , and chunks of the PNG image. Individual compressed chunks are limited to a decompressed size of , by default 1MB, to prevent decompression bombs. Additionally, the total size of all of the text chunks is limited to , defaulting to 64MB. The method supports the following options: If present and true, instructs the PNG writer to make the output file as small as possible. This includes extra processing in order to find optimal encoder settings. For , , , , and images, this option controls what color from the image to mark as transparent. For images, this can be a either the palette index, or a byte string with alpha values for each palette entry. A tuple of two numbers corresponding to the desired dpi in each direction. ZLIB compression level, a number between 0 and 9: 1 gives best speed, 9 gives best compression, 0 gives no compression at all. Default is 6. When option is True has no effect (it is set to 9 regardless of a value passed). The ICC Profile to include in the saved file. The exif data to include in the saved file. For images, this option controls how many bits to store. If omitted, the PNG writer uses 8 bits (256 colors). To enable PNG support, you need to build and install the ZLIB compression library before building the Python Imaging Library. See the installation documentation for details. The PNG loader includes limited support for reading and writing Animated Portable Network Graphics (APNG) files. When an APNG file is loaded, will return . The value of the property will be when the property is greater than 1. For APNG files, the property depends on both the animation frame count as well as the presence or absence of a default image. See the property documentation below for more details. The and methods are supported. raises an if you try to seek after the last frame. These properties will be set for APNG frames, where applicable: Specifies whether or not this APNG file contains a separate default image, which is not a part of the actual APNG animation. When an APNG file contains a default image, the initially loaded image (i.e. the result of ) will be the default image. To account for the presence of the default image, the property will be set to , where is the actual APNG animation frame count. To load the first APNG animation frame, must be called.\n• None - The APNG contains default image, which is not an animation frame.\n• None - The APNG does not contain a default image. The property will be set to the actual APNG animation frame count. The initially loaded image (i.e. ) will be the first APNG animation frame. The number of times to loop this APNG, 0 indicates infinite looping. The time to display this APNG frame (in milliseconds). The APNG loader returns images the same size as the APNG file’s logical screen size. The returned image contains the pixel data for a given frame, after applying any APNG frame disposal and frame blend operations (i.e. it contains what a web browser would render for this frame - the composite of all previous frames and this frame). Any APNG file containing sequence errors is treated as an invalid image. The APNG loader will not attempt to repair and reorder files containing sequence errors. When calling , by default only a single frame PNG file will be saved. To save an APNG file (including a single frame APNG), the parameter must be set to . The following parameters can also be set: Boolean value, specifying whether or not the base image is a default image. If , the base image will be used as the default image, and the first image from the sequence will be the first APNG animation frame. If , the base image will be used as the first APNG animation frame. Defaults to . A list or tuple of images to append as additional frames. Each of the images in the list can be single or multiframe images. The size of each frame should match the size of the base image. Also note that if a frame’s mode does not match that of the base image, the frame will be converted to the base image mode. Integer number of times to loop this APNG, 0 indicates infinite looping. Defaults to 0. Integer (or list or tuple of integers) length of time to display this APNG frame (in milliseconds). Defaults to 0. An integer (or list or tuple of integers) specifying the APNG disposal operation to be used for this frame before rendering the next frame. Defaults to 0.\n• None 0 ( , default) - No disposal is done on this frame before rendering the next frame.\n• None 1 ( ) - This frame’s modified region is cleared to fully transparent black before rendering the next frame.\n• None 2 ( ) - This frame’s modified region is reverted to the previous frame’s contents before rendering the next frame. An integer (or list or tuple of integers) specifying the APNG blend operation to be used for this frame before rendering the next frame. Defaults to 0.\n• None 0 ( ) - All color components of this frame, including alpha, overwrite the previous output image contents.\n• None 1 ( ) - This frame should be alpha composited with the previous output image contents. The , and parameters can be set to lists or tuples to specify values for each individual frame in the animation. The length of the list or tuple must be identical to the total number of actual frames in the APNG animation. If the APNG contains a default image (i.e. is set to ), these list or tuple parameters should not include an entry for the default image. Pillow reads and writes PBM, PGM, PPM and PNM files containing , , or data. “Raw” (P4 to P6) formats can be read, and are used when writing. Since Pillow 9.2.0, “plain” (P1 to P3) formats can be read as well. Pillow also reads SPIDER stack files containing sequences of SPIDER images. The and methods are supported, and random access is allowed. The method sets the following attributes: Set to 1 if the file is an image stack, else 0. Set to the number of images in the stack. A convenience method, , is provided for converting floating point data to byte data (mode ): The extension of SPIDER files may be any 3 alphanumeric characters. Therefore the output format must be specified explicitly: For more information about the SPIDER image processing package, see https://github.com/spider-em/SPIDER Pillow reads and writes TGA images containing , , , , and data. Pillow can read and write both uncompressed and run-length encoded TGAs. The method can take the following keyword arguments: If set to “tga_rle”, the file will be run-length encoded. If present and a positive number, the first pixel is for the top left corner, rather than the bottom left corner. Pillow reads and writes TIFF files. It can read both striped and tiled images, pixel and plane interleaved multi-band images. If you have libtiff and its headers installed, Pillow can read and write many kinds of compressed TIFF files. If not, Pillow will only read and write uncompressed files. Beginning in version 5.0.0, Pillow requires libtiff to read or write compressed files. Prior to that release, Pillow had buggy support for reading Packbits, LZW and JPEG compressed TIFFs without using libtiff. The method sets the following properties: Image resolution as an tuple, where applicable. You can use the attribute to get more detailed information about the image resolution. Image resolution as an tuple, where applicable. This is a measurement in whichever unit is specified by the file. The attribute contains a dictionary of TIFF metadata. The keys are numerical indexes from . Values are strings or numbers for single items, multiple values are returned in a tuple of values. Rational numbers are returned as a object. For compatibility with legacy code, the attribute contains a dictionary of decoded TIFF fields as returned prior to version 3.0.0. Values are returned as either strings or tuples of numeric values. Rational numbers are returned as a tuple of . The TIFF loader supports the and methods, taking and returning frame numbers within the image file. You can combine these methods to seek to the next frame ( ). Frames are numbered from 0 to , and can be accessed in any order. raises an if you try to seek after the last frame. The method can take the following keyword arguments: If true, Pillow will save all frames of the image to a multiframe tiff document. A list of images to append as additional frames. Each of the images in the list can be single or multiframe images. Note however, that for correct results, all the appended images should have the same and properties. A object or dict object containing tiff tags and values. The TIFF field type is autodetected for Numeric and string values, any other types require using an object and setting the type in with the appropriate numerical value from . Metadata values that are of the rational type should be passed in using a object. For compatibility with legacy code, a object may be passed in this field. However, this is deprecated. Previous versions only supported some tags when writing using libtiff. The supported list is found in . Added support for signed types (e.g. ) and multiple values. Multiple values for a single tag must be to as a tuple and require a matching type in tagtype. Alternate keyword to “tiffinfo”, for consistency with other formats. If true, the image will be saved as a BigTIFF. A string containing the desired compression method for the file. (valid only with libtiff installed) Valid compression methods are: , , , , , , , , , , , , , , The image quality for JPEG compression, on a scale from 0 (worst) to 100 (best). The default is 75. These arguments to set the tiff header fields are an alternative to using the general tags available through tiffinfo. The ICC Profile to include in the saved file. An integer. 1 for no unit, 2 for inches and 3 for centimeters. Either an integer or a float, used for both the x and y resolution. Either an integer or a float. Either an integer or a float. A tuple of , with inches as the resolution unit. For consistency with other image formats, the x and y resolutions of the dpi will be rounded to the nearest integer. Pillow reads and writes WebP files. Requires libwebp v0.5.0 or later. The method supports the following options: If present and true, instructs the WebP writer to use lossless compression. Integer, 0-100, defaults to 80. For lossy, 0 gives the smallest size and 100 the largest. For lossless, this parameter is the amount of effort put into the compression: 0 is the fastest, but gives larger files compared to the slowest, but best, 100. Integer, 0-100, defaults to 100. For lossy compression only. 0 gives the smallest size and 100 is lossless. If true, preserve the transparent RGB values. Otherwise, discard invisible RGB values for better compression. Defaults to false. The ICC Profile to include in the saved file. The exif data to include in the saved file. The XMP data to include in the saved file. When calling to write a WebP file, by default only the first frame of a multiframe image will be saved. If the argument is present and true, then all frames will be saved, and the following options will also be available. A list of images to append as additional frames. Each of the images in the list can be single or multiframe images. The display duration of each frame, in milliseconds. Pass a single integer for a constant duration, or a list or tuple to set the duration for each frame separately. Number of times to repeat the animation. Defaults to [0 = infinite]. Background color of the canvas, as an RGBA tuple with values in the range of (0-255). Minimum and maximum distance between consecutive key frames in the output. The library may insert some key frames as needed to satisfy this criteria. Note that these conditions should hold: kmax > kmin and kmin >= kmax / 2 + 1. Also, if kmax <= 0, then key-frame insertion is disabled; and if kmax == 1, then all frames will be key-frames (kmin value does not matter for these special cases). If true, use mixed compression mode; the encoder heuristically chooses between lossy and lossless for each frame.\n\nCUR is used to store cursors on Windows. The CUR decoder reads the largest available cursor. Animated cursors are not supported. DCX is a container file format for PCX files, defined by Intel. The DCX format is commonly used in fax applications. The DCX decoder can read files containing , , , or data. When the file is opened, only the first image is read. You can use or to read other images. Pillow identifies and reads FITS files, commonly used for astronomy. Uncompressed and GZIP_1 compressed images can be read. The method sets the following properties: The delay (in milliseconds) between each frame. Pillow reads Kodak FlashPix files. Only the highest resolution image is read from the file, and the viewing transform is not taken into account. To enable FPX support, you must install olefile. To enable full FlashPix support, you need to build and install the IJG JPEG library before building the Python Imaging Library. See the distribution README for details. The FTEX decoder reads textures used for 3D objects in Independence War 2: Edge Of Chaos. The plugin reads a single texture per file, in the compressed and uncompressed formats. The method sets the following properties: The spacing between the brushes, in pixels. Version 2 only. Pillow reads uncompressed GD2 files. Note that you must use to read such a file. The method sets the following properties: Transparency color index. This key is omitted if the image is not transparent. Pillow identifies and reads Microsoft Image Composer (MIC) files. When opened, the first sprite in the file is loaded. You can use and to read other sprites from the file. Note that there may be an embedded gamma of 2.2 in MIC files. To enable MIC support, you must install olefile. Pillow reads PhotoCD files containing data. This only reads the 768x512 resolution image from the file. Higher resolutions are encoded in a proprietary encoding. Pillow provides limited support for PIXAR raster files. The library can identify and read “dumped” RGB files. Pillow identifies and reads PSD files written by Adobe Photoshop 2.5 and 3.0. Pillow reads images in Quite OK Image format using a Python decoder. If you wish to write code specifically for this format, qoi is an alternative library that uses C to decode the image and interfaces with NumPy. Note that this file format cannot be automatically identified, so you must use the open function in the module to read files in this format. By default, a Quake2 standard palette is attached to the texture. To override the palette, use the method. On Windows, it can read WMF and EMF files. By default, it will load the image at 72 dpi. To load it at another resolution: To add other read or write support, use to register a WMF and EMF handler. Pillow reads X pixmap files (mode ) with 256 colors or less. The method sets the following properties: Transparency color index. This key is omitted if the image is not transparent."
    },
    {
        "link": "https://pillow.readthedocs.io/en/stable/reference/Image.html",
        "document": "The module provides a class with the same name which is used to represent a PIL image. The module also provides a number of factory functions, including functions to load images from files, and to create new images.\n\nInstances of the class have the following attributes: The filename or path of the source file. Only images created with the factory function have a filename attribute. If the input is a file like object, the filename attribute is set to an empty string. The file format of the source file. For images created by the library itself (via a factory function, or by running a method on an existing image), this attribute is set to . Image mode. This is a string specifying the pixel format used by the image. Typical values are “1”, “L”, “RGB”, or “CMYK.” See Modes for a full list. Image size, in pixels. The size is given as a 2-tuple (width, height). Colour palette table, if any. If mode is “P” or “PA”, this should be an instance of the class. Otherwise, it should be set to . A dictionary holding data associated with the image. This dictionary is used by file handlers to pass on various non-image information read from the file. See documentation for the various file handlers for details. Most methods ignore the dictionary when returning new images; since the keys are not standardized, it’s not possible for a method to know if the operation affects the dictionary. If you need the information later on, keep a reference to the info dictionary returned from the open method. Unless noted elsewhere, this dictionary does not affect saving files. if this image has more than one frame, or otherwise. This attribute is only defined by image plugins that support animated images. Plugins may leave this attribute undefined if they don’t support loading animated images, even if the given format supports animated images. Given that this attribute is not present for all images use to check if Pillow is aware of multiple frames in an image regardless of its format. The number of frames in this image. This attribute is only defined by image plugins that support animated images. Plugins may leave this attribute undefined if they don’t support loading animated images, even if the given format supports animated images. Given that this attribute is not present for all images use to check the number of frames that Pillow is aware of in an image regardless of its format. Determine if an image has transparency data, whether in the form of an alpha channel, a palette with an alpha channel, or a “transparency” key in the info dictionary. Note the image might still appear solid, if all of the values shown within are opaque."
    },
    {
        "link": "https://auth0.com/blog/image-processing-in-python-with-pillow",
        "document": "If you’re building your application with Python and it needs to process images, you have a choice of libraries, including OpenCV, scikit-image, Python Imaging Library and Pillow.\n\nWe won't debate which library is the best here; they all have their merits. This article will focus on Pillow, a powerful library that provides a wide array of image processing features and is simple to use. To make the tutorial more interactive and easy to follow, we'll run all the code using Jupyter Notebooks.\n\nPillow is a fork of the Python Imaging Library (PIL). PIL is a library that offers several standard functions for manipulating images. It's a powerful library but hasn't been updated since 2009 and doesn't support Python 3.\n\nPillow builds on PIL, adding more features and support for Python 3. It supports a range of image file formats such as PNG, JPEG, PPM, GIF, TIFF, and BMP. We'll see how to perform various operations on images using this library, such as cropping, resizing, adding text to images, rotating, greyscaling, and more.\n\nYou can follow along by downloading our sample Jupyter notebook from GitHub, or you can create your own project and install the following packages:\n\nTo follow along, you can download the images (courtesy of Unsplash) that we'll use in the article.\n\nAll the code examples will assume the required images are in the same directory as your Jupyter Notebook file.\n\nYou’ll find the code for all the Pillow exercise in this article in a Jupyter Notebook in this GitHub repository.\n\nOf all the classes in Pillow, you’ll probably use\n\nthe most. It's defined in themodule and is the class that represents images and provides methods for loading or creating them, processing them, and displaying them.\n\nTo load an image from a file, use the\n\nfunction in themodule, which takes thefor the image as its argument:\n\nRun the cell. Here’s what it should look like in Jupyter Notebook:\n\nIf you’re using a command-line Python REPL (or something similar) instead of a Jupyter Notebook, you’ll need to call on an external viewer application to see the image. You can do this with\n\nGetting information about an image\n\nlaunches your system’s external viewer, using it to display the image. On Windows, it will usually launch Paint; on macOS, it will launch Preview; and on Linux and other Unix-based systems, it will launch xv.\n\nYou can get some information about an\n\nobject using its attributes. Enter the following into a new cell and run it:\n\nFor more on what you can do with the\n\n’smethod takes a two-integer tuple argument representing the width and height of the new resized image.\n\nHere’s an example that takes the image you loaded and resizes both its width and height to 300 pixels — enter it into a new cell and run it:\n\ndoesn't modify the image but returns anotherinstance with the new dimensions.\n\nchanges the image’s dimensions to the ones you provide, it doesn’t preserve the image’s aspect ratio unless you purposely do so. The resulting image may end up looking stretched or compressed, which may not be the effect you want. You can see this in the newly-created image from the code above; it looks a bit squished horizontally:\n\nIf you want to resize images and keep their aspect ratios, use\n\n’smethod instead. Liketakes a two-integer tuple argument. However, the values in the tuple represent the maximum x- and y-sizes allowed while also preserving the image’s aspect ratio.\n\nEnter the code below into a new cell and run it:\n\n, themethod does not create a newinstance. Instead, it modifies the original. That’s why the code above first makes a copy of the image.\n\nThe code above resize the image to 300 × 200 and preserves the original’s aspect ratio:\n\nAnother significant difference between the\n\nandmethods is thatenalrges an image if given parameters that are larger than the original image, whiledoesn't.\n\nFor example, given an image of size 400 × 200, a call to\n\nwill create a larger-sized image 1200 pixels wide and 600 pixels tall, along with the expected loss of sharpness. A similar call tousing the original image will not enlarge the image since themethod cannot expand an image beyond either of its original dimensions.\n\nThe rise of retrocomputing and retrogaming has created a lot of interest in old-school “pixelated” graphics. You can use a combination of\n\n’sandmethods to turn a modern, high-resolution image into a “retro” one like the one below:\n\nHere’s the code that produces this effect:\n\nThe code above takes advantage of the\n\nmethod’s optionalparameter, which specifies how to draw pixels when resizing the image. When making an image larger, the “nearest neighbor” resampling method creates a “retro” pixel effect.\n\nclass provides themethod for quick image flipping.takes the following arguments:\n\nHere’s how you would create a horizontal mirror image of the original:\n\nThe resulting image can be seen below. Notice that the puffin with the open beak is now on the left side of the photo:\n\narguments rotate the image counterclockwise 90, 180, and 270 degrees, respectively. The following rotates the image 180 degrees:\n\nTransposing an image means mirroring it along the diagonal line that runs from the top left to the bottom right, while tranversing it means mirroring it along the diagonal line running from the bottom left to the top right. This is yet another case where showing is better than telling, so let’s make the code do that.\n\nYou can rotate images with Pillow using\n\n’smethod. This takes an integer or float argument representing the degrees to rotate an image (positive for counterclockwise, negative for clockwise) and returns a newobject for the rotated image.\n\nBy default, the rotated image keeps the dimensions of the original image. This means that for angles other than multiples of 180, the image will be cut and/or padded to fit the original dimensions. Consider this code, which rotates an image 90 degrees counterclockwise:\n\nNotice that the image has been “clipped” to fit the original height, and its sides have been padded with black background (on some operating systems, the padding will be made of transparent pixels) to fit the original width.\n\nThe example below, where the original image is rotated 18 degrees counterclockwise, shows this “clipping” effect more clearly.\n\nThe resulting image is shown below:\n\nTo expand the dimensions of the rotated image to fit the entire view, you pass a second argument to\n\nNow the contents of the image will be fully visible, and the dimensions of the image will have increased to account for this:\n\n’smethod to create a new image by cropping a section from an existing one. This method takes a 4-tuple that defines the position and size of the cropped region, as shown in the method call example below:\n\nPillow’s coordinate system starts with (0, 0) in the upper left corner, with x increasing from left to right and y increasing from top to bottom:\n\nThe cropped section includes the left column and the upper row of pixels and goes up to — but doesn't include — the right column and bottom row of pixels. This is better explained with a diagram:\n\nHere’s an example that creates a new image by cropping the rectangle described below:\n\nPasting an Image onto Another Image\n\nPillow enables you to paste an image onto another one. Some example use cases where this could be useful is in the protection of publicly available images by adding watermarks on them, the branding of images by adding a company logo, and in any other case where there is a need to merge two images.\n\nclass’method pastes another image onto the current one. This is useful for protecting publicly available images by adding watermarks, branding images with a company logo, or simply creating compositions of two or more images.\n\nis unlike manymethods (but like) in that it modifies theobject in place rather than returning a new `one. Because of this, we'll first make a copy of our puffin image before performing the paste to continue with the other examples using the original.\n\nThe code above loads a new image,\n• A 2-tuple specifying the upper left corner of the pasted image,\n• a 4-tuple defining the left, upper, right, and lower pixel coordinates of the pasted image, or\n• , which simply pastes the image at the coordinates (0, 0).\n\n, and makes a copy of the puffin image. We want to paste the logo image onto the puffin image copy at the bottom right corner. The code calculates the coordinates for pasting the logo, which can be:\n\nIn this case, we’re pasting the logo using a 2-tuple coordinate:\n\nYou can see the result below:\n\n, transparent pixels are pasted as solid pixels by default. Hence the black (white on some OSs) box surrounding the logo. Most of the time, this isn't what you want. You can't have your watermark covering the underlying image's content. We would rather have transparent pixels appear as such.\n\nTo achieve this, you need to pass in an optional third argument to the\n\nmethod. This argument is anobject that acts as an opacity mask.\n\nAn opacity mask is an\n\nobject where only the alpha value is significant, while its green, red, and blue values are ignored. If a mask is provided as an optional third argument to, the method updates only the regions the mask indicated. You can use either, orimages for masks. Pasting an RGBA image and using it as the mask pastes only the opaque portion of the image — not its transparent background.\n\nThe code below provides an example of this approach:\n\nWith Pillow, you can also draw on an image using the ImageDraw module. You can draw lines, points, ellipses, rectangles, arcs, bitmaps, chords, pie slices, polygons, shapes, and text.\n\nThe code below draws a black rectangle with a fine white outline near the lower left corner of the puffin image from the previous code example. It then draws the text message “Hello, puffins!” in large white text inside the rectangle:\n\nConverting an image from color to grayscale\n\n’smethod can convert images between different pixel representations, such as the RGB (red-green-blue) format used by screens and the CMYK (cyan-magenta-yellow-black) format used in printing. Like mostmethods,returns a newobject.\n\nalso supports converting images to the(luminance) format, which is a grayscale image format. The code below converts our puffin image from color to grayscale monochrome:\n\nReducing the number of colors in an image\n\nIn addition to pixelation, another way to make an image look “retro” is to reduce the number of colors it uses to 256 or fewer. You can do this with a single call to\n\nThe code below reduces the number of colors in our puffin photo to 16, producing an effect that should remind you of 1990s computer graphics:\n\nmethod of Pillow’sclass makes it possible to split a multi-band image into individual bands, such as the R, G, and B bands from an RGB image.creates new images, each containing one band from the original image.\n\nhas an inverse function,, which merges a set of single band images into a new multi-band image.takes a mode and a tuple of images and combines them into a new image.\n\nThe code below takes the original “puffin” image, splits it into three images — one for each of the R, G, and B bands — and then merges them so that:\n\nPillow allows you to enhance an image by adjusting its contrast, color, brightness, and sharpness using classes in the\n\nHere’s code that boosts the contrast of the “puffin” image:\n\nHere’s the image after enhancing its contrast:\n\nThe code above adjusts the image contrast by a factor of 3; smaller values will produce more subtle effects. A factor of 1.0 returns a copy of the original image; lower factors produce images with lower contrast.\n\nBelow, we increase the color of the image. If we used a factor of\n\n, we would get a black and white image.\n\nBelow we make the image brighter. A factor of\n\nBelow, we make the image sharper. An enhancement factor of\n\nTo save an image, use\n\n’smethod. For example, here’s how you’d save the image from the Enhancing sharpness exercise above as a PNG file:\n\nPillow sees the file extension has been specified as\n\nand converts it to PNG before saving it to a file.\n\nTo save it as a JPEG image, use this:\n\nYou can provide a second argument to\n\nto explicitly specify a file format.will do the same thing as the previous save(). Usually, it's unnecessary to supply this second argument as Pillow will determine the file storage format to use from the filename extension, but if you're using non-standard extensions, you should always specify the format this way.\n\nIn this article, we've covered some of the more common image-processing operations in applications. Pillow is a powerful library, and we have yet to discuss everything it can do. If you want to find out more, be sure to read the documentation."
    },
    {
        "link": "https://geeksforgeeks.org/python-pil-image-resize-method",
        "document": "PIL is the Python Imaging Library which provides the python interpreter with image editing capabilities. The Image module provides a class with the same name which is used to represent a PIL image. The module also provides a number of factory functions, including functions to load images from files, and to create new images.\n\nImage.resize() Returns a resized copy of this image.\n\n\n\nSyntax: Image.resize(size, resample=0) \n\nParameters: \n\nsize – The requested size in pixels, as a 2-tuple: (width, height). \n\nresample – An optional resampling filter. This can be one of PIL.Image.NEAREST (use nearest neighbour), PIL.Image.BILINEAR (linear interpolation), PIL.Image.BICUBIC (cubic spline interpolation), or PIL.Image.LANCZOS (a high-quality downsampling filter). If omitted, or if the image has mode “1” or “P”, it is set PIL.Image.NEAREST. Otherwise, the default filter is Resampling.BICUBIC. \n\nReturns type: An Image object.\n\n\n\nAnother example:Here we use the different newsize value.\n\n\n\n\n\n What is the PIL Function in Python?\n\nWhat Does PIL Stand For in Python?\n\nHow to Import PIL Image in Python?\n\nTo import an image using PIL (now Pillow), you first need to install Pillow, then use the module to open and manipulate images. Here’s how to import and open an image: \n\n\n\n\n\n \n\n img.show() # Displays the image using an external viewer\n\nWhat is the Difference Between Numpy and PIL?\n\nNumpy and PIL (Pillow) are both powerful libraries in Python but serve different purposes:\n• Numpy : Primarily used for numerical operations and serves as the foundational package for scientific computing with Python. It provides a high-performance multidimensional array object and tools for working with these arrays. It’s typically used for large-scale numerical computations.\n• PIL/Pillow : Focused on image processing capabilities. It can read, write, and manipulate image data in various formats. Pillow provides functionality that is specifically geared towards image editing, such as cropping, rotating, converting between formats, and applying filters. Both can be used together, for example, converting a PIL image into a NumPy array to perform complex numerical operations on image data, then converting it back to a PIL image for saving or further manipulation.\n\nHow to Install PIL in Python Command?\n\nSince the original PIL is no longer maintained, you should install Pillow, the friendly PIL fork, which is fully backward compatible with PIL. You can install it using pip: This command installs Pillow, and you can start using it under the namespace, as shown in the import example earlier. Pillow continues to use the namespace to make it a drop-in replacement for legacy PIL installations"
    },
    {
        "link": "https://stackoverflow.com/questions/7970637/how-to-resize-the-new-uploaded-images-using-pil-before-saving",
        "document": "I searched for a solution to resize uploaded photo before saving. There are a lot of info bit and bit here and there (in StackOverflow). Yet, no complete solution. Here is my final solution that I think works for people who wants it.\n• Using Pillow for image processing (two packages required: libjpeg-dev, zlib1g-dev)\n• Using Model and ImageField as storage\n• Using HTTP POST or PUT with multipart/form\n• No need to save the file to disk manually.\n• Did not modify the Model itself\n\nThis model saves a photo with thumbnail and an optional caption. This should be similar to the real-world use case.\n\nOur goal is to resize the photo to 640x640 and generate a 150x150 thumbnail. We also need to return the dimension of the photo in our web API. and is a cached dimension in table. Note that we need to add quota ' when we declare an ImageField. However, does not need the width and height field (so you can see the different).\n\nThat's the model. We don't need to override or add any functions to the model.\n\nWe will use a to process the incoming data from HTTP POST.\n\nWe do not want the serializer to handle the uploaded photo - we will do it ourself. So, no need to include 'image' in fields.\n\nHere, we do not use Image.thumbnail because it will change the original image. This code is suitable if we want to store multiple resolutions (such as low res and high res for different purpose). I found that resizing the incoming message twice will degrade the quality.\n\nWe also do not save the image directly to disk. We push the image via a ContentFile (a File object for content in memory) to ImageField and let the ImageField do its job. We wants the multiple copies of image have the same file name with different postfix.\n\nHere are the links of codes that I had references to build this solution:\n• Use of ContentFile in ImageField.save, by Martey: https://stackoverflow.com/a/7022005/3731039\n• Use of StringIO for reading multipart/form, by johndoevodka: https://stackoverflow.com/a/15523422/3731039\n\nIf you want to validate the image as well, see this: https://stackoverflow.com/a/20762344/3731039"
    }
]