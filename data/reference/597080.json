[
    {
        "link": "https://stackoverflow.com/questions/951021/what-is-the-javascript-version-of-sleep",
        "document": "This is not a duplicate of Sleep in JavaScript - delay between actions ; I want a real sleep in the middle of a function, and not a delay before a piece of code executes.\n\nIs there a better way to engineer a sleep in JavaScript than the following pausecomp function ( taken from here )?\n\nI think it's perfectly reasonable to want to perform an action, wait, and then perform another action. If you are used to writing in multi-threaded languages, you probably have the idea of yielding execution for a set amount of time until your thread wakes up. The issue here is that JavaScript is a single-thread event-based model. While in a specific case, it might be nice to have the whole engine wait for a few seconds, in general it is bad practice. Suppose I wanted to make use of your functions while writing my own? When I called your method, my methods would all freeze up. If JavaScript could somehow preserve your function's execution context, store it somewhere, then bring it back and continue later, then sleep could happen, but that would basically be threading. So you are pretty much stuck with what others have suggested -- you'll need to break your code up into multiple functions. Your question is a bit of a false choice, then. There is no way to sleep in the way you want, nor should you pursue the solution you suggest.\n\nIn JavaScript, I rewrite every function so that it can end as soon as possible. You want the browser back in control so it can make your DOM changes. Every time I've wanted a sleep in the middle of my function, I refactored to use a . The infamous sleep, or delay, function within any language is much debated. Some will say that there should always be a signal or callback to fire a given functionality, others will argue that sometimes an arbitrary moment of delay is useful. I say that to each their own and one rule can never dictate anything in this industry. Writing a sleep function is simple and made even more usable with JavaScript Promises: // sleep time expects milliseconds function sleep (time) { return new Promise((resolve) => setTimeout(resolve, time)); } // Usage! sleep(500).then(() => { // Do something after the sleep! }); If you are inside an function you can do a proper await step with the above definition of : // Available inside async functions: await sleep(500); // Do something after the sleep…\n\nI agree with the other posters. A busy sleep is just a bad idea. However, setTimeout does not hold up execution. It executes the next line of the function immediately after the timeout is SET, not after the timeout expires, so that does not accomplish the same task that a sleep would accomplish. The way to do it is to breakdown your function into before and after parts. function doStuff() { // Do some things setTimeout(continueExecution, 10000) // Wait ten seconds before continuing } function continueExecution() { // Finish doing things after the pause } Make sure your function names still accurately describe what each piece is doing (i.e., GatherInputThenWait and CheckInput, rather than funcPart1 and funcPart2) This method achieves the purpose of not executing the lines of code you decide until after your timeout, while still returning control back to the client PC to execute whatever else it has queued up. As pointed out in the comments this will absolutely not work in a loop. You could do some fancy (ugly) hacking to make it work in a loop, but in general that will just make for disastrous spaghetti code.\n\nMost of the answers here are misguided or at the very least outdated. There is no reason JavaScript has to be single threaded, and indeed it isn't. Today all the mainstream browsers support workers. Before this was the case, other JavaScript runtimes like Rhino and Node.js supported multithreading. 'JavaScript is single threaded' is not a valid answer. For example, running a sleep function within a worker would not block any of the code running in the UI thread. In newer runtimes supporting generators and yield, one could bring similar functionality to the sleep function in a singlethreaded environment: // This is based on the latest ES6 drafts. // JavaScript 1.7+ (SpiderMonkey/Firefox 2+) syntax is slightly different // Run code you want to sleep here (omit star if using JavaScript 1.7) function* main(){ for (var i = 0; i < 10; i++) { // To sleep for 10 milliseconds 10 times in a row yield 10; } yield 5; console.log('I just slept 5 milliseconds!'); } // Resume the given generator after ms milliseconds function resume(ms, generator){ setTimeout(function(){ // Omit .value if using JavaScript 1.7 var nextSleep = generator.next().value; resume(nextSleep, generator); }, ms); } // Initialize a generator and get first sleep for the recursive function var generator = main(), firstSleep = generator.next().value; // Initialize recursive resume function resume(firstSleep, generator); This imitation of sleep is different from a true sleep function as it does not block the thread. It is simply sugar on top of JavaScript's current setTimeout function. This functionality type has been implemented in Task.js and should work today in Firefox.\n\nI have searched/googled quite a few webpages on JavaScript sleep/wait... and there is no answer if you want JavaScript to \"RUN, DELAY, RUN\"... what most people got was either, \"RUN, RUN(useless stuff), RUN\" or \"RUN, RUN + delayed RUN\"... I thought: here is a solution that works... but you have to chop up your running codes...: Yes, I know, this is just an easier to read refactoring... still... <html> <body> <div id=\"id1\">DISPLAY</div> <script> // JavaScript sleep by \"therealdealsince1982\"; copyrighted 2009 // setInterval var i = 0; function run() { // Pieces of codes to run if (i == 0){document.getElementById(\"id1\").innerHTML= \"<p>code segment \" + i + \" is ran</p>\"; } if (i == 1){document.getElementById(\"id1\").innerHTML= \"<p>code segment \" + i + \" is ran</p>\"; } if (i == 2){document.getElementById(\"id1\").innerHTML= \"<p>code segment \" + i + \" is ran</p>\"; } if (i >2){document.getElementById(\"id1\").innerHTML= \"<p>code segment \" + i + \" is ran</p>\"; } if (i == 5){document.getElementById(\"id1\").innerHTML= \"<p>all code segment finished running</p>\"; clearInterval(t); } // End interval, stops run i++; // Segment of code finished running, next... } run(); t = setInterval(\"run()\", 1000); </script> </body> </html> <html> <body> <div id=\"id1\">DISPLAY</div> <script> // JavaScript sleep by \"therealdealsince1982\"; copyrighted 2009 // setTimeout var i = 0; function run() { // Pieces of codes to run, can use switch statement if (i == 0){document.getElementById(\"id1\").innerHTML= \"<p>code segment \" + i + \" ran</p>\"; sleep(1000);} if (i == 1){document.getElementById(\"id1\").innerHTML= \"<p>code segment \" + i + \" ran</p>\"; sleep(2000);} if (i == 2){document.getElementById(\"id1\").innerHTML= \"<p>code segment \" + i + \" ran</p>\"; sleep(3000);} if (i == 3){document.getElementById(\"id1\").innerHTML= \"<p>code segment \" + i + \" ran</p>\";} //stops automatically i++; } function sleep(dur) {t=setTimeout(\"run()\", dur);} // Starts flow control again after 'dur' run(); // Starts </script> </body> </html> <html> <body> <div id=\"id1\">DISPLAY</div> <script> // JavaScript sleep by \"therealdealsince1982\"; copyrighted 2009 // setTimeout var i = 0; function flow() { run(i); i++; // Code segment finished running, increment i; can put elsewhere sleep(1000); if (i == 5) {clearTimeout(t);} // Stops flow, must be after sleep() } function run(segment) { // Pieces of codes to run, can use switch statement if (segment == 0){document.getElementById(\"id1\").innerHTML= \"<p>code segment \" + segment + \" is ran</p>\"; } if (segment == 1){document.getElementById(\"id1\").innerHTML= \"<p>code segment \" + segment + \" is ran</p>\"; } if (segment == 2){document.getElementById(\"id1\").innerHTML= \"<p>code segment \" + segment + \" is ran</p>\"; } if (segment >2){document.getElementById(\"id1\").innerHTML= \"<p>code segment \"+ segment +\" is ran</p>\"; } } function sleep(dur) {t=setTimeout(\"flow()\", dur);} // Starts flow control again after 'dur' flow(); // Starts flow </script> </body> </html> <html> <body> <div id=\"id1\">DISPLAY</div> <script> // JavaScript sleep by \"therealdealsince1982\"; copyrighted 2009 // setTimeout, switch var i = 0; function flow() { switch(i) { case 0: run(i); sleep(1000); break; case 1: run(i); sleep(2000); break; case 5: run(i); clearTimeout(t); // Stops flow break; default: run(i); sleep(3000); break; } } function run(segment) { // Pieces of codes to run, can use switch statement if (segment == 0){document.getElementById(\"id1\").innerHTML= \"<p>code segment \" + segment + \" is ran</p>\"; } if (segment == 1){document.getElementById(\"id1\").innerHTML= \"<p>code segment \" + segment + \" is ran</p>\"; } if (segment == 2){document.getElementById(\"id1\").innerHTML= \"<p>code segment \" + segment + \" is ran</p>\"; } if (segment >2){document.getElementById(\"id1\").innerHTML= \"<p>code segment \" + segment + \" is ran</p>\"; } i++; // Current segment of code finished running, next... } function sleep(dur) {t=setTimeout(\"flow()\", dur);} // Starts flow control again after 'dur' flow(); // Starts flow control for first time... </script> </body> </html>"
    },
    {
        "link": "https://dev.to/noamsauerutley/getting-sleep-with-promises-in-js-5f09",
        "document": "Note: this post was originally published on Medium in November, 2019\n\nRecently, I started building a very basic single page app to illustrate Fetch API usage in a cute and simple way.\n\nWhen the user clicks a button styled like a tennis ball, a new dog image is fetched from the Dog API, and given a name fetched from the Namey API.\n\nThe dog’s image is loaded onto the page, and with each fetch, a name is added onto a list of fetched dogs.\n\nHowever, once a few dogs were fetched, the document content stretched down quite far, and required a bit of scrolling to view. I decided to add a handy little link in the page footer which would scroll the viewer right up to the top, and re-fire the fetch cycle.\n\nWe can just scroll up the window, then trigger a newclick event on the button we’ve assigned to the variable button.\n\nHowever, the the combo of the page scrolling up and the image fetch simultaneously re-firing looks pretty messy.\n\nI wanted a way to slow things down, so the user would only see one thing happening on the page at a time.\n\nI knew that if I could just pause for half a second between the scroll and the API Fetch, everything would look much smoother.\n\nSuddenly, I missed Ruby’s sleep method. It was so nice to be able to schedule events to the exact time I wanted them to run!\n\nI decided there had to be a way to construct my own dupe of that handy little method.\n\nIf you’re not familiar with JS Promises, it’s important to first understand that while Javascript is single-threaded (meaning it can only process one statement at a time), it is also asynchronous (meaning it can start processing a new statement before the previous statement has resolved, allowing it to multitask time-consuming processes in the background.).\n\nJavascript uses Promises to track the resolution of those background processes, allowing us to set certain statements to run only when a time-consuming process has resolved and returned its completed result.\n\nThis is great for handling fetch requests and other time consuming processes, but it also gives us a way to tell our app to wait to process certain statements until exactly when we want them to be run.\n\nI realized that I could exploit this functionality by building a Promise around Javascript’s built-in setTimeout() method.\n\n1: A function to be executed after the timer expires. 2: The time, in milliseconds (thousandths of a second), the timer should wait before the specified function or code is executed. If this argument is omitted, a value of 0 is used, meaning execute “immediately”, or more accurately, as soon as possible. Note that in either case, the actual delay may be longer than intended\n\nWe can create a new Promise, and tell setTimeout to pass the Promise resolve statement as setTimeout’s first parameter. setTimeout will delay for ms milliseconds, then resolve the promise. If we throw this in a function, we now have a handle little delay function ready to go!\n\nGreat! Now we made our replacement for Ruby’s sleep method.\n\nNow let’s put it to use.\n\nI decided to take advantage of one of ES6’s fresher bits of syntax for Promise handling: Async/await.\n\ndelayedClick() knows from the get that it’s awaiting a promise resolution. We’re using our brand new sleep() function as the awaited promise, passing in our desired number of milliseconds (in this case, 700ms , or 7/10ths of a second ). Once that promise resolves, we can enter the action we want delayedClick() to enact. In this case, we’re going to click the button that re-starts the fetch and display cycle.\n\nNow that we have our delay and desired action plugged into a method, we can plug delayedClick() into our existing scrollAndThrow() method as a replacement to button.click() to slow things down and clean up the onscreen process.\n\nThe result: no more jaggedy mid-scroll fetch return and image load!\n\nSometimes, it’s just good to get some sleep!\n• Want to fetch a dog? Check out the repo here.\n• For dog pics, I used the Dog API: https://dog.ceo/dog-api/ .\n• for random first names, I used the muffinlabs Namey API: https://namey.muffinlabs.com/\n• Using Node.js? Turns out that there’s a handy little module built by Wes Bos that keeps this functionality ready to go for you. Check out Waait: https://www.npmjs.com/package/waait."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
        "document": "A is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action's eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future. A is in one of these states:\n• fulfilled: meaning that the operation was completed successfully. The eventual state of a pending promise can either be fulfilled with a value or rejected with a reason (error). When either of these options occur, the associated handlers queued up by a promise's method are called. If the promise has already been fulfilled or rejected when a corresponding handler is attached, the handler will be called, so there is no race condition between an asynchronous operation completing and its handlers being attached. A promise is said to be settled if it is either fulfilled or rejected, but not pending. You will also hear the term resolved used with promises — this means that the promise is settled or \"locked-in\" to match the eventual state of another promise, and further resolving or rejecting it has no effect. The States and fates document from the original Promise proposal contains more details about promise terminology. Colloquially, \"resolved\" promises are often equivalent to \"fulfilled\" promises, but as illustrated in \"States and fates\", resolved promises can be pending or rejected as well. For example: This promise is already resolved at the time when it's created (because the is called synchronously), but it is resolved with another promise, and therefore won't be fulfilled until 1 second later, when the inner promise fulfills. In practice, the \"resolution\" is often done behind the scenes and not observable, and only its fulfillment or rejection are. Note: Several other languages have mechanisms for lazy evaluation and deferring a computation, which they also call \"promises\", e.g. Scheme. Promises in JavaScript represent processes that are already happening, which can be chained with callback functions. If you are looking to lazily evaluate an expression, consider using a function with no arguments e.g. to create the lazily-evaluated expression, and to evaluate the expression immediately. itself has no first-class protocol for cancellation, but you may be able to directly cancel the underlying asynchronous operation, typically using .\n\nThe promise methods , , and are used to associate further action with a promise that becomes settled. The method takes up to two arguments; the first argument is a callback function for the fulfilled case of the promise, and the second argument is a callback function for the rejected case. The and methods call internally and make error handling less verbose. For example, a is really just a without passing the fulfillment handler. As these methods return promises, they can be chained. For example: We will use the following terminology: initial promise is the promise on which is called; new promise is the promise returned by . The two callbacks passed to are called fulfillment handler and rejection handler, respectively. The settled state of the initial promise determines which handler to execute.\n• If the initial promise is fulfilled, the fulfillment handler is called with the fulfillment value.\n• If the initial promise is rejected, the rejection handler is called with the rejection reason. The completion of the handler determines the settled state of the new promise.\n• If the handler returns a thenable value, the new promise settles in the same state as the returned value.\n• If the handler returns a non-thenable value, the new promise is fulfilled with the returned value.\n• If the handler throws an error, the new promise is rejected with the thrown error.\n• If the initial promise has no corresponding handler attached, the new promise will settle to the same state as the initial promise — that is, without a rejection handler, a rejected promise stays rejected with the same reason. For example, in the code above, if rejects, will be called, and if completes normally (without throwing or returning a rejected promise), the promise returned by the first will be fulfilled instead of staying rejected. Therefore, if an error must be handled immediately, but we want to maintain the error state down the chain, we must throw an error of some type in the rejection handler. On the other hand, in the absence of an immediate need, we can leave out error handling until the final handler. Using arrow functions for the callback functions, implementation of the promise chain might look something like this: myPromise .then((value) => `${value} and bar`) .then((value) => `${value} and bar again`) .then((value) => `${value} and again`) .then((value) => `${value} and again`) .then((value) => { console.log(value); }) .catch((err) => { console.error(err); }); Note: For faster execution, all synchronous actions should preferably be done within one handler, otherwise it would take several ticks to execute all handlers in sequence. JavaScript maintains a job queue. Each time, JavaScript picks a job from the queue and executes it to completion. The jobs are defined by the executor of the constructor, the handlers passed to , or any platform API that returns a promise. The promises in a chain represent the dependency relationship between these jobs. When a promise settles, the respective handlers associated with it are added to the back of the job queue. A promise can participate in more than one chain. For the following code, the fulfillment of will cause both and to be added to the job queue. Because is registered first, it will be invoked first. An action can be assigned to an already settled promise. In this case, the action is added immediately to the back of the job queue and will be performed when all existing jobs are completed. Therefore, an action for an already \"settled\" promise will occur only after the current synchronous code completes and at least one loop-tick has passed. This guarantees that promise actions are asynchronous. const promiseA = new Promise((resolve, reject) => { resolve(777); }); // At this point, \"promiseA\" is already settled. promiseA.then((val) => console.log(\"asynchronous logging has val:\", val)); console.log(\"immediate logging\"); // produces output in this order: // immediate logging // asynchronous logging has val: 777\n\nThe class offers four static methods to facilitate async task concurrency: Fulfills when all of the promises fulfill; rejects when any of the promises rejects. Fulfills when any of the promises fulfills; rejects when all of the promises reject. Settles when any of the promises settles. In other words, fulfills when any of the promises fulfills; rejects when any of the promises rejects. All these methods take an iterable of promises (thenables, to be exact) and return a new promise. They all support subclassing, which means they can be called on subclasses of , and the result will be a promise of the subclass type. To do so, the subclass's constructor must implement the same signature as the constructor — accepting a single function that can be called with the and callbacks as parameters. The subclass must also have a static method that can be called like to resolve values to promises. Note that JavaScript is single-threaded by nature, so at a given instant, only one task will be executing, although control can shift between different promises, making execution of the promises appear concurrent. Parallel execution in JavaScript can only be achieved through worker threads.\n\nThis example shows diverse techniques for using Promise capabilities and diverse situations that can occur. To understand this, start by scrolling to the bottom of the code block, and examine the promise chain. Upon provision of an initial promise, a chain of promises can follow. The chain is composed of calls, and typically (but not necessarily) has a single at the end, optionally followed by . In this example, the promise chain is initiated by a custom-written construct; but in actual practice, promise chains more typically start with an API function (written by someone else) that returns a promise. The example function shows that a promise generator will utilize while setting up an asynchronous call, or within the call-back, or both. The function illustrates how an API function might generate and return a promise in a self-contained manner. Note that the function ends with a . That is forced because a promise chain goes through all the promises, even after an error, and without the , the error would seem \"fixed\". This is a hassle, and for this reason, it is common to omit throughout the chain of promises, and just have a single in the final . This code can be run under NodeJS. Comprehension is enhanced by seeing the errors actually occur. To force more errors, change the values. // To experiment with error handling, \"threshold\" values cause errors randomly const THRESHOLD_A = 8; // can use zero 0 to guarantee error function tetheredGetNumber(resolve, reject) { setTimeout(() => { const randomInt = Date.now(); const value = randomInt % 10; if (value < THRESHOLD_A) { resolve(value); } else { reject(`Too large: ${value}`); } }, 500); } function determineParity(value) { const isOdd = value % 2 === 1; return { value, isOdd }; } function troubleWithGetNumber(reason) { const err = new Error(\"Trouble getting number\", { cause: reason }); console.error(err); throw err; } function promiseGetWord(parityInfo) { return new Promise((resolve, reject) => { const { value, isOdd } = parityInfo; if (value >= THRESHOLD_A - 1) { reject(`Still too large: ${value}`); } else { parityInfo.wordEvenOdd = isOdd ? \"odd\" : \"even\"; resolve(parityInfo); } }); } new Promise(tetheredGetNumber) .then(determineParity, troubleWithGetNumber) .then(promiseGetWord) .then((info) => { console.log(`Got: ${info.value}, ${info.wordEvenOdd}`); return info; }) .catch((reason) => { if (reason.cause) { console.error(\"Had previously handled error\"); } else { console.error(`Trouble with promiseGetWord(): ${reason}`); } }) .finally((info) => console.log(\"All done\"));\n\nThis small example shows the mechanism of a . The method is called each time the is clicked. It creates a promise that will be fulfilled, using , to the promise count (number starting from 1) every 1-3 seconds, at random. The constructor is used to create the promise. The fulfillment of the promise is logged, via a fulfill callback set using . A few logs show how the synchronous part of the method is decoupled from the asynchronous completion of the promise. By clicking the button several times in a short amount of time, you'll even see the different promises being fulfilled one after another. \"use strict\"; let promiseCount = 0; function testPromise() { const thisPromiseCount = ++promiseCount; const log = document.getElementById(\"log\"); // begin log.insertAdjacentHTML(\"beforeend\", `${thisPromiseCount}) Started<br>`); // We make a new promise: we promise a numeric count of this promise, // starting from 1 (after waiting 3s) const p1 = new Promise((resolve, reject) => { // The executor function is called with the ability // to resolve or reject the promise log.insertAdjacentHTML( \"beforeend\", `${thisPromiseCount}) Promise constructor<br>`, ); // This is only an example to create asynchronism setTimeout( () => { // We fulfill the promise resolve(thisPromiseCount); }, Math.random() * 2000 + 1000, ); }); // We define what to do when the promise is resolved with the then() call, // and what to do when the promise is rejected with the catch() call p1.then((val) => { // Log the fulfillment value log.insertAdjacentHTML(\"beforeend\", `${val}) Promise fulfilled<br>`); }).catch((reason) => { // Log the rejection reason console.log(`Handle rejected promise (${reason}) here.`); }); // end log.insertAdjacentHTML(\"beforeend\", `${thisPromiseCount}) Promise made<br>`); } const btn = document.getElementById(\"make-promise\"); btn.addEventListener(\"click\", testPromise);\n\nA settings object is an environment that provides additional information when JavaScript code is running. This includes the realm and module map, as well as HTML specific information such as the origin. The incumbent settings object is tracked in order to ensure that the browser knows which one to use for a given piece of user code. To better picture this, we can take a closer look at how the realm might be an issue. A realm can be roughly thought of as the global object. What is unique about realms is that they hold all of the necessary information to run JavaScript code. This includes objects like and . Each settings object has its own \"copy\" of these and they are not shared. That can cause some unexpected behavior in relation to promises. In order to get around this, we track something called the incumbent settings object. This represents information specific to the context of the user code responsible for a certain function call. To illustrate this a bit further we can take a look at how an embedded in a document communicates with its host. Since all web APIs are aware of the incumbent settings object, the following will work in all browsers: <!doctype html> <iframe></iframe> <!-- we have a realm here --> <script> // we have a realm here as well const bound = frames[0].postMessage.bind(frames[0], \"some data\", \"*\"); // bound is a built-in function — there is no user // code on the stack, so which realm do we use? setTimeout(bound); // this still works, because we use the youngest // realm (the incumbent) on the stack </script> The same concept applies to promises. If we modify the above example a little bit, we get this: <!doctype html> <iframe></iframe> <!-- we have a realm here --> <script> // we have a realm here as well const bound = frames[0].postMessage.bind(frames[0], \"some data\", \"*\"); // bound is a built in function — there is no user // code on the stack — which realm do we use? Promise.resolve(undefined).then(bound); // this still works, because we use the youngest // realm (the incumbent) on the stack </script> If we change this so that the in the document is listening to post messages, we can observe the effect of the incumbent settings object: <!-- x.html --> <!doctype html> <script> window.addEventListener( \"message\", (event) => { document.querySelector(\"#text\").textContent = \"hello\"; // this code will only run in browsers that track the incumbent settings object console.log(event); }, false, ); </script> In the above example, the inner text of the will be updated only if the incumbent settings object is tracked. This is because without tracking the incumbent, we may end up using the wrong environment to send the message. Note: Currently, incumbent realm tracking is fully implemented in Firefox, and has partial implementations in Chrome and Safari."
    },
    {
        "link": "https://stackoverflow.com/questions/53995144/implementing-a-verbose-sleep-function-using-a-chain-of-promises",
        "document": "If you want to compose two promises, you can return the second one in a callback passed to of the first promise.\n\nHave a look at the following code:\n\nThe function is a higher order function which returns another function that returns a promise. This promise is resolved in the call to parametrized by the passed to .\n\nAs you can see the executions are interleaved and you will see the log output for the statement of the second promise before the output for of the first one."
    },
    {
        "link": "https://medium.com/@noamsauerutley/getting-sleep-with-promises-in-js-9a5400b48cda",
        "document": "Getting Sleep() with Promises in JS\n\nRecently, I started building a very basic single page app to illustrate Fetch API usage in a cute and simple way.\n\nWhen the user clicks a button styled like a tennis ball, a new dog image is fetched from the Dog API, and given a name fetched from the Namey API.\n\nThe dog’s image is loaded onto the page, and with each fetch, a name is added onto a list of fetched dogs.\n\nHowever, once a few dogs were fetched, the document content stretched down quite far, and required a bit of scrolling to view. I decided to add a handy little link in the page footer which would scroll the viewer right up to the top, and re-fire the fetch cycle.\n\nWe can just scroll up the window, then trigger a new click event on the button we’ve assigned to the variable button.\n\nHowever, the the combo of the page scrolling up and the image fetch simultaneously re-firing looks pretty messy.\n\nI wanted a way to slow things down, so the user would only see one thing happening on the page at a time.\n\nI knew that if I could just pause for half a second between the scroll and the API Fetch, everything would look much smoother.\n\nSuddenly, I missed Ruby’s sleep method. It was so nice to be able to schedule events to the exact time I wanted them to run!\n\nI decided there had to be a way to construct my own dupe of that handy little method.\n\nIf you’re not familiar with JS Promises, it’s important to first understand that while Javascript is single-threaded (meaning it can only process one statement at a time), it is also asynchronous (meaning it can start processing a new statement before the previous statement has resolved, allowing it to multitask time-consuming processes in the background.).\n\nJavascript uses Promises to track the resolution of those background processes, allowing us to set certain statements to run only when a time-consuming process has resolved and returned its completed result.\n\nThis is great for handling fetch requests and other time consuming processes, but it also gives us a way to tell our app to wait to process certain statements until exactly when we want them to be run.\n\nI realized that I could exploit this functionality by building a Promise around Javascript’s built-in setTimeout() method.\n\n1: A function to be executed after the timer expires. 2: The time, in milliseconds (thousandths of a second), the timer should wait before the specified function or code is executed. If this argument is omitted, a value of 0 is used, meaning execute “immediately”, or more accurately, as soon as possible. Note that in either case, the actual delay may be longer than intended\n\nWe can create a new Promise, and tell setTimeout to pass the Promise resolve statement as setTimeout’s first parameter. setTimeout will delay for ms milliseconds, then resolve the promise. If we throw this in a function, we now have a handle little delay function ready to go!\n\nGreat! Now we made our replacement for Ruby’s sleep method.\n\nNow let’s put it to use.\n\nI decided to take advantage of one of ES6’s fresher bits of syntax for Promise handling: Async/await.\n\ndelayedClick() knows from the get that it’s awaiting a promise resolution. We’re using our brand new sleep() function as the awaited promise, passing in our desired number of milliseconds (in this case, 700ms, or 7/10ths of a second). Once that promise resolves, we can enter the action we want delayedClick() to enact. In this case, we’re going to click the button that re-starts the fetch and display cycle.\n\nNow that we have our delay and desired action plugged into a method, we can plug delayedClick() into our existing scrollAndThrow() method as a replacement to button.click() to slow things down and clean up the onscreen process.\n\nThe result: no more jaggedy mid-scroll fetch return and image load!\n\nSometimes, it’s just good to get some sleep!"
    },
    {
        "link": "https://kentpawson123.medium.com/procedural-generation-an-overview-1b054a0f8d41",
        "document": "Procedural Generation, also known as Procedural Content Generation (PCG), is the creation of data using an algorithm, as opposed to manually creating the data. This data is generated during runtime.\n\nImagine you’re walking in a meadow with mountains surrounding you, birds chirping, elk grazing on the grass nearby, and wildflowers all around your feet. You feel alive and say to yourself, “Wow… This is beautiful!” As you arrive back home from this amazing experience, you remember your game development skills that you’ve been learning. After quickly booting up your PC, you open your favorite game engine and try to manually recreate this extraordinary mountain meadow experience. You fail miserably after realizing the amount of work involved in manually creating a landscape. Just as all seems lost, the term procedural generation comes into your head. After conducting enough research, you become an expert in procedural generation and soon generate your beautiful mountain landscape using an algorithmic approach rather than manual creation. Success!\n\nNow, the scenario I gave above is a bit extreme. Landscapes or environments can very well be created through a manual process without even using procedural generation. Likely with enough experience, you could manually create a similar setup to the mountain landscape I explained in my scenario, instead of using procedural generation. However, the point I was trying to get across was that procedural generation is often desired in the generation of terrain or landscapes to reduce the amount of manual labor. Moreover, if you intended to create a very detailed landscape that appeared to be infinite in size, this would be close to impossible to create manually. This is where procedural generation can be used to generate this type of landscape.\n\nThe reason I chose landscape generation for my scenario is because I’m very passionate about it. Apparently a lot of other people are too because this seems to be one of the most common topics for PCG when searching the web. Landscape generation is not the only form of PCG however. In fact, there are many forms ranging from generating animations to music and more!\n\nAh yes, our favorite topic. History! It seems that people either love it or hate it. I’ll keep this section relatively short, but I believe it’s always important to know the history of something that you’re learning.\n\nWhile its difficult to find on the web which game was the first to use PCG, two of the most notable games are Rogue(1980) and Elite(1984). Rogue started a new genre of video games called rogue-like games. These featured procedurally generated levels where the player navigates a labyrinth type environment (referred to as a dungeon). Although some of these games predate Rogue, such as Beneath Apple Manor(1978), Rogue is considered the ancestor of all rogue-like games.\n\nThe early history of games had memory limitations which is one of the driving factors of their decision to use procedural generation so they could compress the data and decrease their file sizes.\n\nNowadays, computers are more advanced and don’t have as many memory or hardware restrictions. Even still, PCG is commonly used as a way for data compression. Modern uses of PCG often include creating terrain, levels, storylines, or other data that is unique for each playthrough.\n\nProcedural generation is generally used for increasing the replay value, data compression, reusing data, and for greater scalability in games.\n\nWithin game development there are many areas where procedural generation can be used. I’ve listed a few of these areas below, and although these are not all of them, they seem to be the most common ones used in games.\n\nOften 2D games will use algorithms to generate levels in their games. This approach is seen in rogue-like games.\n\nMany open world games procedural generate their landscape in some way. No Man’s Sky, a game developed by Hello Games, used procedural generation to create an entire galaxy of planets, each containing their own atmosphere and wildlife.\n\nAnimation, such as character animation, is another use of procedural generation. PCG may help the animation appear more unique and flow smoothly.\n\nOften to create a unique playthrough, games will procedurally generate the dialogue. Moreover, the decisions the player makes in the game may affect the storyline and allow the storyline to generate its own content based on how the character responds to a certain event.\n\nInstantiating objects is one of the most common uses of PCG in games. Often this is referred to as spawning. The objects that are spawned may be enemies, animals, trees, loot, particle systems, and more!\n\nOften quest-based games will use an algorithm to create a loot system. This algorithm may generate loot based on the player’s current level. If the player has a high rank, the generated loot will likely be more rare as opposed to that of a low ranked player."
    },
    {
        "link": "https://reddit.com/r/howdidtheycodeit/comments/1dhok0k/how_do_i_properly_generate_procedural_terrain",
        "document": "I love this topic, and i'd like to program an API that allows me to easily create lots of stuff. But i just don't know how to tackle everything at once.\n\nI gotten past the noise generation and the mesh generation (using terrain elevation and isosurface techniques), but how do i go further??\n\nIs there a set of techniques that are used for each process (placing rocks, structures, rivers, biomes)?\n\nAnd then another technique that joins everything together?"
    },
    {
        "link": "https://reddit.com/r/roguelikedev/comments/1f7s4e3/procedural_generation",
        "document": "I am new to game dev and I want to make a simple rougelike so I have a question regarding procedural generation so I want to make levels to be procedurally generated much like rouge like games but I don't know how to go about it like which algorithms to use the next problem is that I want to pass a list of premade rooms that can be placed randomly through and the those will be connected through corridors and lastly I want to define like a exact section for the spawn and the boss room are or alternatively I want a set numbers of rooms that must exist in between the boss and the spawn room Links to any tutorials, forums and any suggestions/solutions would be appreciated"
    },
    {
        "link": "https://gamedev.stackexchange.com/questions/48897/methods-of-procedural-terrain-generation-that-can-work-using-directx-9-sm2-0",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://javascript.plainenglish.io/procedural-generation-of-an-infinite-world-aaea8e70ef4a",
        "document": "Using procedural generation to create the terrain for a simple platform game in JavaScript\n\nProcedural generation is a technique that can be used in video games to create an infinite amount of data for maps, textures and sounds to make game worlds that never end.\n\nAs described in my previous post, I recently entered the JS13k Games competition and I wanted to make a game that felt big but would fit within the 13 kilobytes size limit imposed by the competition. I chose to use procedural generation since it meant I could generate the game world within the game code, thereby keeping the size of the overall package small.\n\nHere I discuss some of the background behind how I did it. Although I used procedural generation to make the terrain for a 2d platform game, the techniques also work for generating game structures, sprites, textures and sounds.\n\nProcedural generation in general uses a procedure that creates features according to some fixed input arguments. Given the same inputs, the same feature will be output. To create an infinite terrain for my game I needed a source for the inputs with the following characteristics:\n• apparently random and never repeating, so that the world is interesting to play\n• the same inputs are generated every time the game is run, so that the world is the same every time we play\n• the current output doesn’t depend on any previous output, so that we can generate any part of the world in any order\n\nIn other words, a function that maps its inputs to its outputs in an unpredictable yet repeatable way.\n\nHere is an example of one such function that returns unpredictable values between 0 and 255.\n\nThe function has only a single input parameter. To generate a 2D terrain, I needed a function that gave a repeatable output for every coordinate in the world. To use the function above I needed to map the and values to a single number.\n\nA way to do this is to treat the pair as a vector and calculate the dot product of that vector with some other fixed vector. Here’s how that looks. It’s the same function as above, modified to take two inputs.\n\nPlotting the output of this in a plane looks like this:\n\nAlthough many pairs of numbers have the same dot product, they are skewed across the 2D plane so the repetition isn’t apparent.\n\nThe noise here looks random enough, but it’s quite harsh and not very natural. A more natural effect can be achieved by combining several layers of noise at different scales.\n\nEach layer is generated by “zooming in” on the noise, skipping pixels and interpolating the values between them.\n\nHere’s how it looks when we zoom in 128 times, i.e. only one pixel in every 128 comes from the pseudo-random function and the rest are interpolated.\n\nI’ve used linear interpolation here, which means the brightness varies in a straight line from point to point. That makes the regular sampling grid very much apparent — you can still see ‘squares’ in the output.\n\nThere are more sophisticated approaches to interpolation. (Perlin noise is a well known example.) However, the simple linear interpolation shown here is sufficient for the world I wanted to generate.\n\nHere are four different sample spacings (or periods), shown as separate layers, then overlaid.\n\nThis gives a slightly more natural looking noise, known as “fractal noise” because the different layers are essentially the same but at different scales. It’s often used in computer graphics to generate natural looking textures like rust or clouds.\n\nYou might be able to see how this type of noise could be used to create a world for a game. It could be interpreted as a map of hilly or bumpy ground, viewed from above.\n\nIn my game I used it to create a network of underground caves, viewed from the side. By applying a simple threshold function, where every pixel value above the threshold is drawn and the rest is left empty, the noise looks like this:\n\nThis is the basis of the network of caves in my game. The caves here go on forever, but I wanted the caves to begin and end at fixed levels. By adjusting the cutoff value of the threshold function away from 50% I could vary the density of thecaves between entirely solid and entirely empty. This let me create different bands of sky, caves and bedrock:\n\nBy using a second threshold function I added a layer of earth, and by shading the background different below a fixed coordinate I created the effect of water.\n\nI added grass as a thin layer on top of the earth. To ensure that it only appears on the top surface and not underneath I modified the code to test the gradient of the underlying noise field. Since empty areas have lower noise values that the solid ones, the -component of the gradient at any point can be used to tell whether the surface is facing upwards or downwards.\n\nFinally, in order to confine the player horizontally, I created the effect of an island by varying the threshold along the axis as well as the axis. I did this by offsetting the coordinate according to the square of the coordinate.\n\nThis formed the basic terrain for my game. It makes for a reasonably sized game world that doesn’t consume much space in the game bundle. To complete the world, and make it a bit more fun to play, I added a castle and a few other platforms and ladders, which you can discover for yourself by playing the finished game.\n\nI’m a software engineer based in London. I help companies to build web applications."
    }
]