[
    {
        "link": "https://geeksforgeeks.org/new-and-delete-operators-in-cpp-for-dynamic-memory",
        "document": "Dynamic memory allocation in C/C++ refers to performing memory allocation manually by a programmer. Dynamically allocated memory is allocated on Heap, and non-static and local variables get memory allocated on Stack (Refer to Memory Layout C Programs for details).\n• None One use of dynamically allocated memory is to allocate memory of variable size, which is not possible with compiler allocated memory except for\n• None The most important use is the flexibility provided to programmers. We are free to allocate and deallocate memory whenever we need it and whenever we don’t need it anymore. There are many cases where this flexibility helps. Examples of such cases are\n\nHow is it different from memory allocated to normal variables?\n\nFor normal variables like “int a”, “char str[10]”, etc, memory is automatically allocated and deallocated. For dynamically allocated memory like “int *p = new int[10]”, it is the programmer’s responsibility to deallocate memory when no longer needed. If the programmer doesn’t deallocate memory, it causes a memory leak (memory is not deallocated until the program terminates).\n\nHow is memory allocated/deallocated in C++? \n\nC uses the malloc() and calloc() function to allocate memory dynamically at run time and uses a free() function to free dynamically allocated memory. C++ supports these functions and also has two operators new and delete, that perform the task of allocating and freeing the memory in a better and easier way.\n\nThe new operator denotes a request for memory allocation on the Free Store. If sufficient memory is available, a new operator initializes the memory and returns the address of the newly allocated and initialized memory to the pointer variable.\n\nSyntax to use new operator\n\nHere, the pointer variable is the pointer of type data-type. Data type could be any built-in data type including array or any user-defined data type including structure and class. \n\nExample:\n\nInitialize memory: We can also initialize the memory for built-in data types using a new operator. For custom data types, a constructor is required (with the data type as input) for initializing the value. Here’s an example of the initialization of both data types :\n\nAllocate a block of memory: a new operator is also used to allocate a block(an array) of memory of type data type.\n\nwhere size(a variable) specifies the number of elements in an array.\n\nDynamically allocates memory for 10 integers continuously of type int and returns a pointer to the first element of the sequence, which is assigned top(a pointer). p[0] refers to the first element, p[1] refers to the second element, and so on.\n\nNormal Array Declaration vs Using new \n\nThere is a difference between declaring a normal array and allocating a block of memory using new. The most important difference is, that normal arrays are deallocated by the compiler (If the array is local, then deallocated when the function returns or completes). However, dynamically allocated arrays always remain there until either they are deallocated by the programmer or the program terminates.\n\nWhat if enough memory is not available during runtime? \n\nIf enough memory is not available in the heap to allocate, the new request indicates failure by throwing an exception of type std::bad_alloc, unless “nothrow” is used with the new operator, in which case it returns a NULL pointer (scroll to section “Exception handling of new operator” in this article). Therefore, it may be a good idea to check for the pointer variable produced by the new before using its program.\n\nSince it is the programmer’s responsibility to deallocate dynamically allocated memory, programmers are provided delete operator in C++ language.\n\nHere, the pointer variable is the pointer that points to the data object created by new.\n\nTo free the dynamically allocated array pointed by pointer variable, use the following form of delete:\n\nTime Complexity: O(n), where n is the given memory size.\n• None Quiz on new and delete"
    },
    {
        "link": "https://cplusplus.com/doc/tutorial/dynamic",
        "document": "std; main () { i,n; * p; cout << \"How many numbers would you like to type? \" ; cin >> i; p= (nothrow) [i]; (p == ) cout << \"Error: memory could not be allocated\" ; { (n=0; n<i; n++) { cout << ; cin >> p[n]; } cout << ; (n=0; n<i; n++) cout << p[n] << ; [] p; } 0; }\n\nHow many numbers would you like to type? 5 Enter number : 75 Enter number : 436 Enter number : 1067 Enter number : 8 Enter number : 32 You have entered: 75, 436, 1067, 8, 32,"
    },
    {
        "link": "https://isocpp.org/wiki/faq/freestore-mgmt",
        "document": "How do I deal with memory leaks?\n\nBy writing code that doesn’t have any. Clearly, if your code has operations, operations, and pointer arithmetic all over the place, you are going to mess up somewhere and get leaks, stray pointers, etc. This is true independently of how conscientious you are with your allocations: eventually the complexity of the code will overcome the time and effort you can afford.\n\nIt follows that successful techniques rely on hiding allocation and deallocation inside more manageable types: For single objects, prefer or . For multiple objects, prefer using standard containers like and as they manage memory for their elements better than you could without disproportionate effort. Consider writing this without the help of and :\n\nWhat would be your chance of getting it right the first time? And how would you know you didn’t have a leak?\n\nNote the absence of explicit memory management, macros, casts, overflow checks, explicit size limits, and pointers. By using a function object and a standard algorithm, the code could additionally have eliminated the pointer-like use of the iterator, but that seemed overkill for such a tiny program.\n\nThese techniques are not perfect and it is not always easy to use them systematically. However, they apply surprisingly widely and by reducing the number of explicit allocations and deallocations you make the remaining examples much easier to keep track of. As early as 1981, Stroustrup pointed out that by reducing the number of objects that he had to keep track of explicitly from many tens of thousands to a few dozens, he had reduced the intellectual effort needed to get the program right from a Herculean task to something manageable, or even easy.\n\nIf your application area doesn’t have libraries that make programming that minimizes explicit memory management easy, then the fastest way of getting your program complete and correct might be to first build such a library.\n\nTemplates and the standard libraries make this use of containers, resource handles, etc., much easier than it was even a few years ago. The use of exceptions makes it close to essential.\n\nIf you cannot handle allocation/deallocation implicitly as part of an object you need in your application anyway, you can use a resource handle to minimize the chance of a leak. Here is an example where you need to return an object allocated on the free store from a function. This is an opportunity to forget to delete that object. After all, we cannot tell just looking at pointer whether it needs to be deallocated and if so who is responsible for that. Using a resource handle, here the standard library , makes it clear where the responsibility lies:\n\nThink about resources in general, rather than simply about memory.\n\nIf systematic application of these techniques is not possible in your environment (you have to use code from elsewhere, part of your program was written by Neanderthals, etc.), be sure to use a memory leak detector as part of your standard development procedure, or plug in a garbage collector.\n\nCan I use just as in Java?\n\nSort of, but don’t do it blindly, if you do want it prefer to spell it as or , and there are often superior alternatives that are simpler and more robust than any of that. Consider:\n\nThe clumsy use of for is unnecessary and slow compared with the idiomatic use of a local variable ( ). You don’t need to use to create an object if you also that object in the same scope; such an object should be a local variable.\n\nShould I use or or ?\n\nYou should use as the null pointer value. The others still work for backward compatibility with older code.\n\nA problem with both and as a null pointer value is that is a special “maybe an integer value and maybe a pointer” value. Use only for integers, and that confusion disappears.\n\nDoes delete the pointer , or the pointed-to-data ?\n\nThe keyword should really be . The same abuse of English occurs when ing the memory pointed to by a pointer in C: really means .\n\nIs it safe to the same pointer twice?\n\nNo! (Assuming you didn’t get that pointer back from in between.)\n\nFor example, the following is a disaster:\n\nThat second line might do some really bad things to you. It might, depending on the phase of the moon, corrupt your heap, crash your program, make arbitrary and bizarre changes to objects that are already out there on the heap, etc. Unfortunately these symptoms can appear and disappear randomly. According to Murphy’s law, you’ll be hit the hardest at the worst possible moment (when the customer is looking, when a high-value transaction is trying to post, etc.).\n\nNote: some runtime systems will protect you from certain very simple cases of double . Depending on the details, you might be okay if you happen to be running on one of those systems and if no one ever deploys your code on another system that handles things differently and if you are deleting something that doesn’t have a destructor and if you don’t do anything significant between the two s and if no one ever changes your code to do something significant between the two s and if your thread scheduler (over which you likely have no control!) doesn’t happen to swap threads between the two s and if, and if, and if. So back to Murphy: since it can go wrong, it will, and it will go wrong at the worst possible moment.\n\nDo NOT email me saying you tested it and it doesn’t crash. Get a clue. A non-crash doesn’t prove the absence of a bug; it merely fails to prove the presence of a bug.\n\nTrust me: double- is bad, bad, bad. Just say no.\n\nCan I pointers allocated with ? Can I pointers allocated with ?\n\nNo! In brief, conceptually and allocate from different heaps, so can’t or each other’s memory. They also operate at different levels – raw memory vs. constructed objects.\n\nYou can use and in the same program. But you cannot allocate an object with and free it using . Nor can you allocate with and with or use on an array allocated by .\n\nThe C++ operators and guarantee proper construction and destruction; where constructors or destructors need to be invoked, they are. The C-style functions , , , and don’t ensure that. Furthermore, there is no guarantee that the mechanism used by and to acquire and release raw memory is compatible with and . If mixing styles works on your system, you were simply “lucky” – for now.\n\nIf you feel the need for – and many do – then consider using a standard library . For example\n\nSee also the examples and discussion in “Learning Standard C++ as a New Language”, which you can download from Stroustrup’s publications list.\n\nWhat is the difference between and ?\n\nFirst, (or ) are nearly always superior to both and and completely eliminate and .\n\nHaving said that, here’s the difference between those two:\n\nis a function that takes a number (of bytes) as its argument; it returns a pointing to unitialized storage. is an operator that takes a type and (optionally) a set of initializers for that type as its arguments; it returns a pointer to an (optionally) initialized object of its type. The difference is most obvious when you want to allocate an object of a user-defined type with non-trivial initialization semantics. Examples:\n\nNote that when you specify a initializer using the “(value)” notation, you get initialization with that value. Often, a is a better alternative to a free-store-allocated array (e.g., consider exception safety).\n\nWhenever you use you must consider initialization and conversion of the return pointer to a proper type. You will also have to consider if you got the number of bytes right for your use. There is no performance difference between and when you take initialization into account.\n\nreports memory exhaustion by returning . reports allocation and initialization errors by throwing exceptions ( ).\n\nObjects created by are destroyed by . Areas of memory allocated by are deallocated by .\n\nWhy should I use instead of trustworthy old ?\n\nFirst, (or ) are nearly always superior to both and and completely eliminate and .\n\nHaving said that, benefits of using instead of are: Constructors/destructors, type safety, overridability.\n• Type safety: returns a which isn’t type safe. returns a pointer of the right type (a ).\n• Overridability: is an that can be overridden by a class, while is not overridable on a per-class basis.\n\nCan I use on pointers allocated via ?\n\nWhen has to copy the allocation, it uses a bitwise copy operation, which will tear many C++ objects to shreds. C++ objects should be allowed to copy themselves. They use their own copy constructor or assignment operator.\n\nBesides all that, the heap that uses may not be the same as the heap that and use!\n\nWhy doesn’t C++ have an equivalent to ?\n\nIf you want to, you can of course use . However, is only guaranteed to work on arrays allocated by (and similar functions) containing objects without user-defined copy constructors. Also, please remember that contrary to naive expectations, occasionally does copy its argument array.\n\nIn C++, a better way of dealing with reallocation is to use a standard library container, such as , and let it grow naturally.\n\nDo I need to check for null after ?\n\nNo! (But if you have an ancient, stone-age compiler, you may have to force the operator to an exception if it runs out of memory.)\n\nIt turns out to be a real pain to always write explicit tests after every allocation. Code like the following is very tedious:\n\nIf your compiler doesn’t support (or if you refuse to use) exceptions, your code might be even more tedious:\n\nTake heart. In C++, if the runtime system cannot allocate bytes of memory during , a exception will be thrown. Unlike , never returns null!\n\nTherefore you should simply write:\n\nOn the second thought. Scratch that. You should simply write:\n\nThere, there… Much better now!\n\nHowever, if your compiler is ancient, it may not yet support this. Find out by checking your compiler’s documentation under “ ”. If it is ancient, you may have to force the compiler to have this behavior.\n\nHow can I convince my (older) compiler to automatically check to see if it returns null?\n\nIf you have an old compiler that doesn’t automagically perform the null test, you can force the runtime system to do the test by installing a “new handler” function. Your “new handler” function can do anything you want, such as an exception, some objects and return (in which case will retry the allocation), print a message and the program, etc.\n\nHere’s a sample “new handler” that prints a message and s an exception. The handler is installed using :\n\nAfter the line is executed, will call your if/when it runs out of memory. This means that will never return null:\n\nNote: If your compiler doesn’t support exception handling, you can, as a last resort, change the line … to:\n\nNote: If some namespace-scope / global / static object’s constructor uses , it might not use the function since that constructor often gets called before begins. Unfortunately there’s no convenient way to guarantee that the will be called before the first use of . For example, even if you put the call in the constructor of a global object, you still don’t know if the module (“compilation unit”) that contains that global object will be elaborated first or last or somewhere inbetween. Therefore you still don’t have any guarantee that your call of will happen before any other namespace-scope / global’s constructor gets invoked.\n\nDo I need to check for null before ?\n\nThe C++ language guarantees that will do nothing if is null. Since you might get the test backwards, and since most testing methodologies force you to explicitly test every branch point, you should not put in the redundant test.\n\nWhat are the two steps that happen when I say ?\n\nis a two-step process: it calls the destructor, then releases the memory. The code generated for is functionally similar to this (assuming is of type ):\n\nThe statement calls the destructor for the object pointed to by .\n\nThe statement calls the memory deallocation primitive, . This primitive is similar in spirit to . (Note, however, that these two are not interchangeable; e.g., there is no guarantee that the two memory deallocation primitives even use the same heap!)\n\nWhy doesn’t null out its operand?\n\nFirst, you should normally be using smart pointers, so you won’t care – you won’t be writing anyway.\n\nFor those rare cases where you really are doing manual memory management and so do care, consider:\n\nIf the part doesn’t touch then the second is a serious error that a C++ implementation cannot effectively protect itself against (without unusual precautions). Since deleting a null pointer is harmless by definition, a simple solution would be for to do a after it has done whatever else is required. However, C++ doesn’t guarantee that.\n\nOne reason is that the operand of need not be an lvalue. Consider:\n\nHere, the implementation of does not have a pointer to which it can null out. These examples may be rare, but they do imply that it is not possible to guarantee that “any pointer to a deleted object is null.” A simpler way of bypassing that “rule” is to have two pointers to an object:\n\nC++ explicitly allows an implementation of to null out an lvalue operand, but that idea doesn’t seem to have become popular with implementers.\n\nIf you consider zeroing out pointers important, consider using a destroy function:\n\nConsider this yet-another reason to minimize explicit use of and by relying on standard library smart pointers, containers, handles, etc.\n\nNote that passing the pointer as a reference (to allow the pointer to be nulled out) has the added benefit of preventing from being called for an rvalue:\n\nWhy isn’t the destructor called at the end of scope?\n\nThe simple answer is “of course it is!”, but have a look at the kind of example that often accompany that question:\n\nThat is, there was some (mistaken) assumption that the object created by would be destroyed at the end of a function.\n\nBasically, you should only use heap allocation if you want an object to live beyond the lifetime of the scope you create it in. Even then, you should normally use or . In those rare cases where you do want heap allocation and you opt to use , you need to use to destroy the object. For example:\n\nIf you want an object to live in a scope only, don’t use heap allocation at all but simply define a variable:\n\nThe variable is implicitly destroyed at the end of the scope.\n\nCode that creates an object using and then s it at the end of the same scope is ugly, error-prone, inefficient, and usually not exception-safe. For example:\n\nIn , does the memory “leak” if the constructor throws an exception?\n\nIf an exception occurs during the constructor of , the C++ language guarantees that the memory bytes that were allocated will automagically be released back to the heap.\n\nHere are the details: is a two-step process:\n• bytes of memory are allocated using the primitive . This primitive is similar in spirit to . (Note, however, that these two are not interchangeable; e.g., there is no guarantee that the two memory allocation primitives even use the same heap!).\n• It constructs an object in that memory by calling the constructor. The pointer returned from the first step is passed as the parameter to the constructor. This step is wrapped in a … block to handle the case when an exception is thrown during this step.\n\nThus the actual generated code is functionally similar to:\n\nThe statement marked “Placement ” calls the constructor. The pointer becomes the pointer inside the constructor, .\n\nHow do I allocate / unallocate an array of things?\n\nAny time you allocate an array of objects via (usually with the n in the expression), you must use in the statement. This syntax is necessary because there is no syntactic difference between a pointer to a thing and a pointer to an array of things (something we inherited from C).\n\nWhat if I forget the when ing an array allocated via ?\n\nAll life comes to a catastrophic end.\n\nIt is the programmer’s —not the compiler’s— responsibility to get the connection between and correct. If you get it wrong, neither a compile-time nor a run-time error message will be generated by the compiler. Heap corruption is a likely result. Or worse. Your program will probably die.\n\nCan I drop the when ing an array of some built-in type ( , , etc)?\n\nSometimes programmers think that the in the only exists so the compiler will call the appropriate destructors for all elements in the array. Because of this reasoning, they assume that an array of some built-in type such as or can be d without the . E.g., they assume the following is valid code:\n\nBut the above code is wrong, and it can cause a disaster at runtime. In particular, the code that’s called for is , but the code that’s called for is . The default behavior for the latter is to call the former, but users are allowed to replace the latter with a different behavior (in which case they would normally also replace the corresponding code in ). If they replaced the code so it wasn’t compatible with the code, and you called the wrong one (i.e., if you said rather than ), you could end up with a disaster at runtime.\n\nAfter , how does the compiler know there are objects to be destructed during ?\n\nLong answer: The run-time system stores the number of objects, , somewhere where it can be retrieved if you only know the pointer, . There are two popular techniques that do this. Both these techniques are in use by commercial-grade compilers, both have tradeoffs, and neither is perfect. These techniques are:\n• Over-allocate the array and put just to the left of the first object.\n• Use an associative array with as the key and as the value.\n\nIs it legal (and moral) for a member function to say ?\n\nAs long as you’re careful, it’s okay (not evil) for an object to commit suicide ( ).\n• You must be absolutely 100% positively sure that object was allocated via (not by , nor by placement , nor a local object on the stack, nor a namespace-scope / global, nor a member of another object; but by plain ordinary ).\n• You must be absolutely 100% positively sure that your member function will be the last member function invoked on object.\n• You must be absolutely 100% positively sure that the rest of your member function (after the line) doesn’t touch any piece of object (including calling any other member functions or touching any data members). This includes code that will run in destructors for any objects allocated on the stack that are still alive.\n• You must be absolutely 100% positively sure that no one even touches the pointer itself after the line. In other words, you must not examine it, compare it with another pointer, compare it with , print it, cast it, do anything with it.\n\nNaturally the usual caveats apply in cases where your pointer is a pointer to a base class when you don’t have a virtual destructor.\n\nHow do I allocate multidimensional arrays using ?\n\nThere are many ways to do this, depending on how flexible you want the array sizing to be. On one extreme, if you know all the dimensions at compile-time, you can allocate multidimensional arrays statically (as in C):\n\nMore commonly, the size of the matrix isn’t known until run-time but you know that it will be rectangular. In this case you need to use the heap (“freestore”), but at least you are able to allocate all the elements in one freestore chunk.\n\nFinally at the other extreme, you may not even be guaranteed that the matrix is rectangular. For example, if each row could have a different length, you’ll need to allocate each row individually. In the following function, is the number of columns in row number , where varies between and inclusive.\n\nNote the funny use of in the deletion process. This prevents wrap-around of the value when goes one step below zero.\n\nFinally, note that pointers and arrays are evil. It is normally much better to encapsulate your pointers in a class that has a safe and simple interface. The following FAQ shows how to do this.\n\nBut the previous FAQ’s code is SOOOO tricky and error prone! Isn’t there a simpler way?\n\nThe reason the code in the previous FAQ was so tricky and error prone was that it used pointers, and we know that pointers and arrays are evil. The solution is to encapsulate your pointers in a class that has a safe and simple interface. For example, we can define a class that handles a rectangular matrix so our user code will be vastly simplified when compared to the the rectangular matrix code from the previous FAQ:\n\nThe main thing to notice is the lack of clean-up code. For example, there aren’t any statements in the above code, yet there will be no memory leaks, assuming only that the destructor does its job correctly.\n\nHere’s the code that makes the above possible:\n\nNote that the above class accomplishes two things: it moves some tricky memory management code from the user code (e.g., ) to the class, and it reduces the overall bulk of program. The latter point is important. For example, assuming is even mildly reusable, moving complexity from the users [plural] of into itself [singular] is equivalent to moving complexity from the many to the few. Anyone who has seen Star Trek 2 knows that the good of the many outweighs the good of the few… or the one.\n\nBut the above class is specific to ! Isn’t there a way to make it generic?\n\nHere’s how this can be used:\n\nNow it’s easy to use for things other than . For example, the following uses a of (where is the standard string class):\n\nYou can thus get an entire family of classes from a template. For example, , , , etc.\n\nHere’s one way that the template can be implemented:\n\nWhat’s another way to build a template?\n\nUse the standard template, and make a of .\n\nThe following uses a .\n\nNote how much simpler this is than the previous: there is no explicit in the constructor, and there is no need for any of The Big Three (destructor, copy constructor or assignment operator). Simply put, your code is a lot less likely to have memory leaks if you use than if you use explicit and .\n\nNote also that doesn’t force you to allocate numerous chunks of memory. If you prefer to allocate only one chunk of memory for the entire matrix, as was done in the previous, just change the type of to and add member variables and . You’ll figure out the rest: initialize using , change to , etc.\n\nDoes C++ have arrays whose length can be specified at run-time?\n\nYes, in the sense that the standard library has a template that provides this behavior.\n\nNo, in the sense that built-in array types need to have their length specified at compile time.\n\nYes, in the sense that even built-in array types can specify the first index bounds at run-time. E.g., comparing with the previous FAQ, if you only need the first array dimension to vary then you can just ask new for an array of arrays, rather than an array of pointers to arrays:\n\nYou can’t do this if you need anything other than the first dimension of the array to change at run-time.\n\nBut please, don’t use arrays unless you have to. Arrays are evil. Use some object of some class if you can. Use arrays only when you have to.\n\nHow can I force objects of my class to always be created via rather than as local, namespace-scope, global, or ?\n\nAs usual with the Named Constructor Idiom, the constructors are all or , and there are one or more methods (the so-called “named constructors”), one per constructor. In this case the methods allocate the objects via . Since the constructors themselves are not , there is no other way to create objects of the class.\n\nNow the only way to create objects is via :\n\nMake sure your constructors are in the section if you expect to have derived classes.\n\nNote also that you can make another class a of if you want to allow a to have a member object of class , but of course this is a softening of the original goal, namely to force objects to be allocated via .\n\nHow do I do simple reference counting?\n\nIf all you want is the ability to pass around a bunch of pointers to the same object, with the feature that the object will automagically get d when the last pointer to it disappears, you can use something like the following “smart pointer” class:\n\nNaturally you can use nested classes to rename to .\n\nNote that you can soften the “never ” rule above with a little more checking in the constructor, copy constructor, assignment operator, and destructor. If you do that, you might as well put a check into the “ ” and “ ” operators (at least as an ). I would recommend against an method, since that would let people accidentally get at the .\n\nOne of the implicit constraints on is that it must only point to objects which have been allocated via . If you want to be really safe, you can enforce this constraint by making all of ’s constructors , and for each constructor have a ( ) method which allocates the object via and returns a (not a ). That way the only way anyone could create a object would be to get a (“ ” would be replaced by “ ”). Thus no one could accidentally subvert the reference counting mechanism.\n\nFor example, if had a and a , the changes to would be:\n\nThe end result is that you now have a way to use simple reference counting to provide “pointer semantics” for a given object. Users of your explicitly use objects, which act more or less like pointers. The benefit is that users can make as many copies of their “smart pointer” objects, and the pointed-to object will automagically get d when the last such object vanishes.\n\nIf you’d rather give your users “reference semantics” rather than “pointer semantics,” you can use reference counting to provide “copy on write”.\n\nHow do I provide reference counting with copy-on-write semantics?\n\nReference counting can be done with either pointer semantics or reference semantics. The previous FAQ shows how to do reference counting with pointer semantics. This FAQ shows how to do reference counting with reference semantics.\n\nThe basic idea is to allow users to think they’re copying your objects, but in reality the underlying implementation doesn’t actually do any copying unless and until some user actually tries to modify the underlying object.\n\nClass houses all the data that would normally go into the . also has an extra data member, , to manage the reference counting. Class ends up being a “smart reference” that (internally) points to a .\n\nIf it is fairly common to call ’s default constructor, you can avoid all those calls by sharing a common object for all s that are constructed via . To avoid initialization order problems, this shared object is created “on first use” inside a function. Here are the changes that would be made to the above code (note that the shared object’s destructor is never invoked; if that is a problem, either hope you don’t have any initialization order problems, or drop back to the approach described above):\n\nNote: You can also provide reference counting for a hierarchy of classes if your class would normally have been a base class.\n\nHow do I provide reference counting with copy-on-write semantics for a hierarchy of classes?\n\nThe previous FAQ presented a reference counting scheme that provided users with reference semantics, but did so for a single class rather than for a hierarchy of classes. This FAQ extends the previous technique to allow for a hierarchy of classes. The basic difference is that is now the root of a hierarchy of classes, which probably cause it to have some functions. Note that class itself will still not have any functions.\n\nThe Virtual Constructor Idiom is used to make copies of the objects. To select which derived class to create, the sample code below uses the Named Constructor Idiom, but other techniques are possible (a statement in the constructor, etc). The sample code assumes two derived classes: and . Methods in the derived classes are unaware of the reference counting.\n\nNaturally the constructors and methods for and will need to be implemented in whatever way is appropriate.\n\nCan I absolutely prevent people from subverting the reference counting mechanism, and if so, should I?\n\nNo, and (normally) no.\n\nThere are two basic approaches to subverting the reference counting mechanism:\n• The scheme could be subverted if someone got a (rather than being forced to use a ). Someone could get a if class has an that returns a : . Yes it’s bizarre and unexpected, but it could happen. This hole could be closed in two ways: overload so it returns a , or change the return type of so it returns a ( would be a class that simulates a reference; it would need to have all the methods that has, and it would need to forward all those method calls to the underlying object; there might be a performance penalty for this second choice depending on how good the compiler is at inlining methods). Another way to fix this is to eliminate — and lose the corresponding ability to get and use a . But even if you did all this, someone could still generate a by explicitly calling : .\n• The scheme could be subverted if someone had a leak and/or dangling pointer to a . Basically what we’re saying here is that is now safe, but we somehow want to prevent people from doing stupid things with objects. (And if we could solve that via objects, we’d have the same problem again with them). One hole here is if someone created a using , then allowed the to leak (worst case this is a leak, which is bad but is usually a little better than a dangling pointer). This hole could be plugged by declaring as , thus preventing someone from saying . Another hole here is if someone creates a local object, then takes the address of that and passed around the . If that lived longer than the , you could have a dangling pointer — shudder. This hole could be plugged by preventing people from taking the address of a (by overloading as ), with the corresponding loss of functionality. But even if you did all that, they could still create a which is almost as dangerous as a , simply by doing this: (or by passing the to someone else).\n\nAnd even if we closed all those holes, C++ has those wonderful pieces of syntax called pointer casts. Using a pointer cast or two, a sufficiently motivated programmer can normally create a hole that’s big enough to drive a proverbial truck through. (By the way, pointer casts are evil.)\n\nSo the lessons here seem to be: (a) you can’t prevent espionage no matter how hard you try, and (b) you can easily prevent mistakes.\n\nSo I recommend settling for the “low hanging fruit”: use the easy-to-build and easy-to-use mechanisms that prevent mistakes, and don’t bother trying to prevent espionage. You won’t succeed, and even if you do, it’ll (probably) cost you more than it’s worth.\n\nSo if we can’t use the C++ language itself to prevent espionage, are there other ways to do it? Yes. I personally use old fashioned code reviews for that. And since the espionage techniques usually involve some bizarre syntax and/or use of pointer-casts and unions, you can use a tool to point out most of the “hot spots.”\n\nCan I use a garbage collector in C++?\n\nIf you want automatic garbage collection, there are good commercial and public-domain garbage collectors for C++. For applications where garbage collection is suitable, C++ is an excellent garbage collected language with a performance that compares favorably with other garbage collected languages. See The C++ Programming Language (4th Edition) for a discussion of automatic garbage collection in C++. See also, Hans-J. Boehm’s site for C and C++ garbage collection.\n\nAlso, C++ supports programming techniques that allows memory management to be safe and implicit without a garbage collector. Garbage collection is useful for specific needs, such as inside the implementation of lock-free data structures to avoid ABA issues, but not as a general-purpose default way of handling for resource management. We are not saying that GC is not useful, just that there are better approaches in many situations.\n\nCompared with the “smart pointer” techniques, the two kinds of garbage collector techniques are:\n• usually more efficient (especially when the average object size is small or in multithreaded environments)\n• able to handle “cycles” in the data (reference counting techniques normally “leak” if the data structures can form a cycle)\n• sometimes leak other objects (since the garbage collectors are necessarily conservative, they sometimes see a random bit pattern that appears to be a pointer into an allocation, especially if the allocation is large; this can allow the allocation to leak)\n• work better with existing libraries (since smart pointers need to be used explicitly, they may be hard to integrate with existing libraries)\n\nWhat are the two kinds of garbage collectors for C++?\n\nIn general, there seem to be two flavors of garbage collectors for C++:\n• Conservative garbage collectors. These know little or nothing about the layout of the stack or of C++ objects, and simply look for bit patterns that appear to be pointers. In practice they seem to work with both C and C++ code, particularly when the average object size is small. Here are some examples, in alphabetical order:\n• Hybrid garbage collectors. These usually scan the stack conservatively, but require the programmer to supply layout information for heap objects. This requires more work on the programmer’s part, but may result in improved performance. Here are some examples, in alphabetical order:\n\nSince garbage collectors for C++ are normally conservative, they can sometimes leak if a bit pattern “looks like” it might be a pointer to an otherwise unused block. Also they sometimes get confused when pointers to a block actually point outside the block’s extent (which is illegal, but some programmers simply must push the envelope; sigh) and (rarely) when a pointer is hidden by a compiler optimization. In practice these problems are not usually serious, however providing the collector with hints about the layout of the objects can sometimes ameliorate these issues.\n\nWhere can I get more info on garbage collectors for C++?\n\nFor more information, see the Garbage Collector FAQ.\n\nWhat is an and why isn’t there an ?\n\nIt’s now spelled , which supports both single objects and arrays.\n\nis an old standard smart pointer that has been deprecated, and is only being kept in the standard for backward compatibility with older code. It should not be used in new code."
    },
    {
        "link": "https://stackoverflow.com/questions/68620780/dynamic-memory-allocation-in-std",
        "document": "The options you listed are pretty comprehensive, I think I would just add some practical color to a couple of them.\n\nOption 1: if you have the source code for the specific standard library implementation you're using, you can \"simplify\" the process of reading it by generating a static call graph and reading that instead. In fact the llvm tool can do this for you, as demonstrated in this question. If you were to do this, in theory you could just look at a given method and see if goes to an allocation function of any kind. No source code reading required, purely visual.\n\nOption 4: scripting this is easier than you think. Prerequisites: make sure you're building with , which allows the linker to completely discard functions which are never called. When you generate a release build, you can simply use and grep on the ELF file to see if for example appears in the binary at all.\n\nFor example I have a bare metal cortex-M based embedded system which I know for a fact has no dynamic memory allocation, but links against a common standard library implementation. On the debug build I can do the following:\n\nHere malloc is found because dead code has not been stripped.\n\nOn the release build it looks like this:\n\ngrep here will return \"0\" if a match was found and something other than \"0\" if it wasn't, so if you were to use this in a script it would be something like:\n\nThere's a mountain of disclaimers and caveats that come with any of these approaches. Keep in mind that embedded systems in particular use a wide variety of different standard library implementations, and each implementation is free to do pretty much whatever it wants with regard to memory management.\n\nIn fact they don't even have to call and , they could implement their own dynamic allocators. Granted this is somewhat unlikely, but it is possible, and thus grepping for isn't actually sufficient unless you know for a fact that all memory management in your standard library implementation goes through and .\n\nIf you're serious about avoiding all forms of dynamic memory allocation, the only sure way I know of (and have used myself) is simply to remove the heap entirely. On most bare metal embedded systems I've worked with, the heap start address, end address, and size are almost always provided a symbols in the linker script. You should remove or rename these symbols. If anything is using the heap, you'll get a linker error, which is what you want.\n\nTo give a very concrete example, newlib is a very common libc implementation for embedded systems. Its malloc implementation requires that the common function be present in the system. For bare metal systems, is just implemented by incrementing a pointer that starts at the symbol provided by the linker script.\n\nIf you were using newlib, and you didn't want to mess with the linker script, you could still replace with a function that simply hard faults so you catch any attempt to allocate memory immediately. This in my opinion would still be much better than trying to stare at heap pointers on a running system.\n\nOf course your actual system may be different, and you may have a different libc implementation that you're using. This question can really only answered to any reasonable satisfaction in the exact context of your system, so you'll probably have to do some of your own homework. Chances are it's pretty similar to what I've described here.\n\nOne of the great things about bare metal embedded systems is the amount of flexibility that they provide. Unfortunately this also means there are so many variables that it's almost impossible to answer questions directly unless you know all of the details, which we don't here. Hopefully this will give you a better starting point than staring at a debugger window."
    },
    {
        "link": "https://learncpp.com/cpp-tutorial/dynamic-memory-allocation-with-new-and-delete",
        "document": "The need for dynamic memory allocation\n\nC++ supports three basic types of memory allocation, of which you’ve already seen two.\n• Static memory allocation happens for static and global variables. Memory for these types of variables is allocated once when your program is run and persists throughout the life of your program.\n• Automatic memory allocation happens for function parameters and local variables. Memory for these types of variables is allocated when the relevant block is entered, and freed when the block is exited, as many times as necessary.\n• Dynamic memory allocation is the topic of this article.\n\nBoth static and automatic allocation have two things in common:\n• The size of the variable / array must be known at compile time.\n• Memory allocation and deallocation happens automatically (when the variable is instantiated / destroyed).\n\nMost of the time, this is just fine. However, you will come across situations where one or both of these constraints cause problems, usually when dealing with external (user or file) input.\n\nFor example, we may want to use a string to hold someone’s name, but we do not know how long their name is until they enter it. Or we may want to read in a number of records from disk, but we don’t know in advance how many records there are. Or we may be creating a game, with a variable number of monsters (that changes over time as some monsters die and new ones are spawned) trying to kill the player.\n\nIf we have to declare the size of everything at compile time, the best we can do is try to make a guess the maximum size of variables we’ll need and hope that’s enough:\n\nThis is a poor solution for at least four reasons:\n\nFirst, it leads to wasted memory if the variables aren’t actually used. For example, if we allocate 25 chars for every name, but names on average are only 12 chars long, we’re using over twice what we really need. Or consider the rendering array above: if a rendering only uses 10,000 polygons, we have 20,000 Polygons worth of memory not being used!\n\nSecond, how do we tell which bits of memory are actually used? For strings, it’s easy: a string that starts with a \\0 is clearly not being used. But what about monster[24]? Is it alive or dead right now? Has it even been initialized in the first place? That necessitates having some way to tell the status of each monster, which adds complexity and can use up additional memory.\n\nThird, most normal variables (including fixed arrays) are allocated in a portion of memory called the stack. The amount of stack memory for a program is generally quite small -- Visual Studio defaults the stack size to 1MB. If you exceed this number, stack overflow will result, and the operating system will probably close down the program.\n\nOn Visual Studio, you can see this happen when running this program:\n\nBeing limited to just 1MB of memory would be problematic for many programs, especially those that deal with graphics.\n\nFourth, and most importantly, it can lead to artificial limitations and/or array overflows. What happens when the user tries to read in 600 records from disk, but we’ve only allocated memory for a maximum of 500 records? Either we have to give the user an error, only read the 500 records, or (in the worst case where we don’t handle this case at all) overflow the record array and watch something bad happen.\n\nFortunately, these problems are easily addressed via dynamic memory allocation. Dynamic memory allocation is a way for running programs to request memory from the operating system when needed. This memory does not come from the program’s limited stack memory -- instead, it is allocated from a much larger pool of memory managed by the operating system called the heap. On modern machines, the heap can be gigabytes in size.\n\nTo allocate a single variable dynamically, we use the scalar (non-array) form of the new operator:\n\nIn the above case, we’re requesting an integer’s worth of memory from the operating system. The new operator creates the object using that memory, and then returns a pointer containing the address of the memory that has been allocated.\n\nMost often, we’ll assign the return value to our own pointer variable so we can access the allocated memory later.\n\nWe can then dereference the pointer to access the memory:\n\nIf it wasn’t before, it should now be clear at least one case in which pointers are useful. Without a pointer to hold the address of the memory that was just allocated, we’d have no way to access the memory that was just allocated for us!\n\nNote that accessing heap-allocated objects is generally slower than accessing stack-allocated objects. Because the compiler knows the address of stack-allocated objects, it can go directly to that address to get a value. Heap allocated objects are typically accessed via pointer. This requires two steps: one to get the address of the object (from the pointer), and another to get the value.\n\nYour computer has memory (probably lots of it) that is available for applications to use. When you run an application, your operating system loads the application into some of that memory. This memory used by your application is divided into different areas, each of which serves a different purpose. One area contains your code. Another area is used for normal operations (keeping track of which functions were called, creating and destroying global and local variables, etc…). We’ll talk more about those later. However, much of the memory available just sits there, waiting to be handed out to programs that request it.\n\nWhen you dynamically allocate memory, you’re asking the operating system to reserve some of that memory for your program’s use. If it can fulfill this request, it will return the address of that memory to your application. From that point forward, your application can use this memory as it wishes. When your application is done with the memory, it can return the memory back to the operating system to be given to another program.\n\nUnlike static or automatic memory, the program itself is responsible for requesting and disposing of dynamically allocated memory.\n\nWhen you dynamically allocate a variable, you can also initialize it via direct initialization or uniform initialization:\n\nWhen we are done with a dynamically allocated variable, we need to explicitly tell C++ to free the memory for reuse. For single variables, this is done via the scalar (non-array) form of the delete operator:\n\nWhat does it mean to delete memory?\n\nThe delete operator does not actually delete anything. It simply returns the memory being pointed to back to the operating system. The operating system is then free to reassign that memory to another application (or to this application again later).\n\nAlthough the syntax makes it look like we’re deleting a variable, this is not the case! The pointer variable still has the same scope as before, and can be assigned a new value (e.g. ) just like any other variable.\n\nNote that deleting a pointer that is not pointing to dynamically allocated memory may cause bad things to happen.\n\nC++ does not make any guarantees about what will happen to the contents of deallocated memory, or to the value of the pointer being deleted. In most cases, the memory returned to the operating system will contain the same values it had before it was returned, and the pointer will be left pointing to the now deallocated memory.\n\nA pointer that is pointing to deallocated memory is called a dangling pointer. Dereferencing or deleting a dangling pointer will lead to undefined behavior. Consider the following program:\n\nIn the above program, the value of 7 that was previously assigned to the allocated memory will probably still be there, but it’s possible that the value at that memory address could have changed. It’s also possible the memory could be allocated to another application (or for the operating system’s own usage), and trying to access that memory will cause the operating system to shut the program down.\n\nDeallocating memory may create multiple dangling pointers. Consider the following example:\n\nThere are a few best practices that can help here.\n\nFirst, try to avoid having multiple pointers point at the same piece of dynamic memory. If this is not possible, be clear about which pointer “owns” the memory (and is responsible for deleting it) and which pointers are just accessing it.\n\nSecond, when you delete a pointer, if that pointer is not going out of scope immediately afterward, set the pointer to nullptr. We’ll talk more about null pointers, and why they are useful in a bit.\n\nWhen requesting memory from the operating system, in rare circumstances, the operating system may not have any memory to grant the request with.\n\nBy default, if new fails, a bad_alloc exception is thrown. If this exception isn’t properly handled (and it won’t be, since we haven’t covered exceptions or exception handling yet), the program will simply terminate (crash) with an unhandled exception error.\n\nIn many cases, having new throw an exception (or having your program crash) is undesirable, so there’s an alternate form of new that can be used instead to tell new to return a null pointer if memory can’t be allocated. This is done by adding the constant std::nothrow between the new keyword and the allocation type:\n\nIn the above example, if new fails to allocate memory, it will return a null pointer instead of the address of the allocated memory.\n\nNote that if you then attempt to dereference this pointer, undefined behavior will result (most likely, your program will crash). Consequently, the best practice is to check all memory requests to ensure they actually succeeded before using the allocated memory.\n\nBecause asking new for memory only fails rarely (and almost never in a dev environment), it’s common to forget to do this check!\n\nNull pointers (pointers set to nullptr) are particularly useful when dealing with dynamic memory allocation. In the context of dynamic memory allocation, a null pointer basically says “no memory has been allocated to this pointer”. This allows us to do things like conditionally allocate memory:\n\nDeleting a null pointer has no effect. Thus, there is no need for the following:\n\nInstead, you can just write:\n\nIf ptr is non-null, the dynamically allocated memory will be deleted. If ptr is null, nothing will happen.\n\nDynamically allocated memory stays allocated until it is explicitly deallocated or until the program ends (and the operating system cleans it up, assuming your operating system does that). However, the pointers used to hold dynamically allocated memory addresses follow the normal scoping rules for local variables. This mismatch can create interesting problems.\n\nConsider the following function:\n\nThis function allocates an integer dynamically, but never frees it using delete. Because pointers variables are just normal variables, when the function ends, ptr will go out of scope. And because ptr is the only variable holding the address of the dynamically allocated integer, when ptr is destroyed there are no more references to the dynamically allocated memory. This means the program has now “lost” the address of the dynamically allocated memory. As a result, this dynamically allocated integer can not be deleted.\n\nThis is called a memory leak. Memory leaks happen when your program loses the address of some bit of dynamically allocated memory before giving it back to the operating system. When this happens, your program can’t delete the dynamically allocated memory, because it no longer knows where it is. The operating system also can’t use this memory, because that memory is considered to be still in use by your program.\n\nMemory leaks eat up free memory while the program is running, making less memory available not only to this program, but to other programs as well. Programs with severe memory leak problems can eat all the available memory, causing the entire machine to run slowly or even crash. Only after your program terminates is the operating system able to clean up and “reclaim” all leaked memory.\n\nAlthough memory leaks can result from a pointer going out of scope, there are other ways that memory leaks can result. For example, a memory leak can occur if a pointer holding the address of the dynamically allocated memory is assigned another value:\n\nThis can be fixed by deleting the pointer before reassigning it:\n\nRelatedly, it is also possible to get a memory leak via double-allocation:\n\nThe address returned from the second allocation overwrites the address of the first allocation. Consequently, the first allocation becomes a memory leak!\n\nSimilarly, this can be avoided by ensuring you delete the pointer before reassigning.\n\nOperators new and delete allow us to dynamically allocate single variables for our programs.\n\nDynamically allocated memory has dynamic duration and will stay allocated until you deallocate it or the program terminates.\n\nBe careful not to perform dereference a dangling or null pointers.\n\nIn the next lesson, we’ll take a look at using new and delete to allocate and delete arrays."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/io/manip/setw",
        "document": "When used in an expression out << std::setw(n) or in >> std::setw(n), sets the parameter of the stream out or in to exactly n.\n\nSome operations reset the width to zero (see below), so may need to be repeatedly called to set the width for multiple operations.\n\nAn object of unspecified type such that\n• if is an object of type , the expression\n• behaves as if it called\n• if is an object of type , the expression\n• behaves as if it called\n\nwhere the function f is defined as:\n\nThe width property of the stream will be reset to zero (meaning \"unspecified\") if any of the following functions are called:\n\nThe exact effects this modifier has on the input and output vary between the individual I/O functions and are described at each operator<< and operator>> overload page individually.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://medium.com/@ryan_forrester_/using-setw-in-c-practical-guide-2ce6ce50fc7a",
        "document": "If you’ve ever tried to format output in C++ and found yourself wrestling with spaces and alignment, you’re not alone.\n\nEnter `setw`, a handy tool that can save you hours of frustration. Short for “set width,” `setw` is an I/O manipulator that helps you control the width of the output field. It’s part of the `<iomanip>` library and works with both `cout` and `cin`.\n\nLet’s dive into how `setw` works and explore some practical examples that will make your C++ output look professional and polished.\n\nBefore we jump into examples, make sure you include the necessary header:\n\nThe basic syntax for using `setw` is straightforward:\n\nHere, `n` is the width you want to set for the output field, and `value` is what you’re outputting.\n\nLet’s start with a basic example to see `setw` in action:\n\nIn this example, we’ve set a width of 10 for both “Hello” and “World”. By default, `setw` right-aligns the text within the specified width.\n\nWhat if you want left alignment instead? You can combine `setw` with the `left` manipulator:\n\n`setw` is particularly useful when working with numbers, especially when you need to create neat, tabular output:\n\nBy default, `setw` pads with spaces, but you can change this using `setfill`:\n\nUsing setw with Strings and Precision\n\nWhen working with strings and floating-point numbers, `setw` behaves a bit differently:\n\nNotice that `setw` doesn’t truncate the string “Long string” even though we set a width of 5. For floating-point numbers, `setw` affects the entire output width, including the decimal point and any padding.\n\nLet’s put our `setw` skills to use in a more practical scenario — creating a simple table:\n\nThis example demonstrates how `setw` can help create well-formatted, easy-to-read tables in C++.\n\nSometimes, you might need to calculate the width dynamically based on the content. Here’s an example that determines the maximum width needed for each column:\n\nThis approach ensures that your table looks good regardless of the input data’s length.\n\nCommon Pitfalls and How to Avoid Them\n\nWhile `setw` is a useful tool, there are a few things to watch out for:\n\n1. setw is not sticky: It only affects the next output operation. If you want to maintain a certain width for multiple outputs, you need to use `setw` before each one.\n\n2. Interaction with precision: When used with floating-point numbers, remember that `setw` sets the total field width, including the decimal point and any padding.\n\n3. Truncation of strings: `setw` doesn’t truncate strings that are longer than the specified width. If you need truncation, you’ll have to handle it manually.\n\n4. Buffer overflow: Be cautious when using `setw` with user input to avoid buffer overflow vulnerabilities.\n\n`setw` is a versatile tool in C++ that can significantly improve the presentation of your output.\n\nFrom simple alignment tasks to creating complex tables, using `setw` will give you fine-grained control over your program’s output formatting.\n\nRemember, good output formatting isn’t just about aesthetics — it can make your data more readable and your programs more user-friendly. So the next time you find yourself adding spaces manually or struggling with alignment, reach for `setw` and watch your output transform into neatly organized, professional-looking text."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/io/manip",
        "document": "Manipulators are helper functions that make it possible to control input/output streams using operator<< or operator>>.\n\nThe manipulators that are invoked without arguments (e.g. std::cout << std::boolalpha; or std::cin >> std::hex;) are implemented as functions that take a reference to a stream as their only argument. The special overloads of and accept pointers to these functions. These functions (or instantiations of function templates) are the only addressable functions in the standard library.(since C++20)\n\nThe manipulators that are invoked with arguments (e.g. std::cout << std::setw(10);) are implemented as functions returning objects of unspecified type. These manipulators define their own or which perform the requested manipulation."
    },
    {
        "link": "https://stackoverflow.com/questions/60481700/how-to-properly-use-setw-to-format-output",
        "document": "As mentioned in comments, the manipulator only applies to the next string, so\n\nwill set a width of 15 only for the character (similarly in the line with , etc.). It is also worth noting that if a string exceeds the specified width, then it will push the next contents and break the alignment of your columns; so you need to set the width thinking about the largest possible contents.\n\nHere is a working example to implement what you want, using a to form the string before printing it (in order for to apply to the entire thing):\n\nNote that I have set different widths for each field, depending on the expected lengths of the contents. For example, e-mail addresses can be quite long, but the age will rarely exceed two digits."
    },
    {
        "link": "https://reddit.com/r/cpp_questions/comments/aabvc4/how_exactly_do_stdcout_and_stdcin_work_and_why_do",
        "document": "I've been coding in C++ for quite a while now and knowing that prints stuff onto terminal and that takes input from terminal was kinda enough.\n\nBut how exactly do they work? Especially considering the whole part with the and ? What makes it different to, let's say, and ? Or compared to other languages with Python's or Java's ? Why do we use instead of ?"
    },
    {
        "link": "https://stackoverflow.com/questions/24531770/c-string-constructor-with-char-memory-leak",
        "document": "As per my understanding when we call ctor with deep copying happens so the passed can be easily deleted after constructor call of string (is it?) and the new string can be used safely afterward.\n\nHow can i prevent memory leak when i am using char* to initialize string? Or is it automatically cleaned ? What if i use something like:\n\nIs delete necessary in this case?"
    },
    {
        "link": "https://stackoverflow.com/questions/4250281/possible-memory-leak-using-c-string",
        "document": "Others are correct, you are leaking because you are calling exit. To be clear, the leak isn't the string allocated on the stack, it is memory allocated on the heap by the string. For example:\n\nwill not cause valgrind to report a leak.\n\nThe leak is probable (instead of definite) because you have an interior pointer to memory allocated on the heap. basic_string is responsible for this. From the header on my machine:\n\nThey key is that _M_p doesn't point to the start of the memory allocated on the heap, it points to the first character in the string. Here is a simple example:\n\nThis will report a probable leak in valgrind. If you comment out the lines where I move m_data valgrind will report 'still reachable'. If you uncomment the line where I set m_data to 0 you'll get a definite leak.\n\nThe valgrind documentation has more information on probable leaks and interior pointers."
    },
    {
        "link": "https://federicosarrocco.com/blog/cpp-memory-management-blog-post",
        "document": "In the realm of robotics and high-performance computing, efficient memory management is crucial. C++ provides powerful tools for manual memory management, offering fine-grained control that can lead to highly optimized code. However, this power comes with great responsibility. Mismanaging memory can result in bugs that are notoriously difficult to track down, from subtle performance issues to catastrophic system failures.\n\nC++'s approach to memory management is a double-edged sword. On one hand, it allows for precise control over resource allocation and deallocation, which can be crucial in resource-constrained environments often encountered in robotics. On the other hand, this manual approach opens the door to a host of potential issues, including memory leaks, dangling pointers, and buffer overflows.\n\nConsider a scenario where we're developing software for a robot's sensor system. We might need to allocate memory dynamically to store incoming sensor data:\n\nThis simple example already presents several potential pitfalls. What if an exception is thrown during processing? We might never reach the statement, resulting in a memory leak. What if we accidentally use instead of ? We'd have undefined behavior on our hands.\n\nThe RAII Paradigm: A Cornerstone of Modern C++\n\nTo mitigate these risks, modern C++ emphasizes the RAII (Resource Acquisition Is Initialization) paradigm. RAII ties the lifetime of resources to the lifetime of objects, ensuring that resources are properly released when an object goes out of scope.\n\nLet's revisit our sensor data example using RAII:\n\nBy using , we've eliminated the risk of memory leaks and incorrect deallocation. The memory is automatically freed when goes out of scope, even if an exception is thrown.\n\nWhile RAII is powerful, there are scenarios where dynamic allocation is necessary. For these cases, C++11 introduced smart pointers, which automate memory management for dynamically allocated objects.\n\nConsider a robot with multiple sensors, each represented by a class:\n\nHere, ensures that each object is automatically deleted when it's no longer needed, either when it's removed from the vector or when the object is destroyed.\n\nOne common pitfall in C++ development, especially in performance-critical fields like robotics, is the temptation of premature optimization. Developers might shy away from using standard library containers or smart pointers, believing that manual memory management will yield better performance.\n\nHowever, this approach often leads to more problems than it solves. Modern C++ compilers are highly optimized, and standard library implementations are typically very efficient. Unless profiling has identified a specific performance bottleneck, it's generally better to prioritize correctness and maintainability over hypothetical performance gains.\n\nTo navigate the complexities of memory management in C++, consider the following best practices:\n• Favor stack allocation over heap allocation when possible. Stack-allocated objects have automatic lifetime management and typically better performance.\n• Use RAII and standard library containers to automate resource management.\n• When dynamic allocation is necessary, prefer smart pointers over raw pointers.\n• If you must use raw pointers, clearly document ownership semantics and follow the rule of three/five/zero.\n• Use tools like AddressSanitizer, Valgrind, and static analyzers to catch memory-related bugs early.\n• Regularly review and refactor your code to eliminate redundant or unsafe memory management practices.\n\nMemory management in C++ is a balancing act between control and safety. While the language provides the tools for fine-grained memory control, it's often better to err on the side of safety by leveraging modern C++ features and idioms.\n\nAs robotics developers, our goal should be to write code that is not only efficient but also robust and maintainable. By understanding the pitfalls of manual memory management and embracing modern C++ practices, we can create systems that are both powerful and reliable.\n\nRemember, in the world of robotics, a memory leak or dangling pointer isn't just a bug – it could be the difference between a successful mission and a costly failure. Master these concepts, and you'll be well-equipped to tackle the complex challenges of robotics software development."
    },
    {
        "link": "https://ptolemy.berkeley.edu/ptolemyclassic/almagest/docs/prog/html/ptlang.doc7.html",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/cpp/comments/16nfksr/how_often_do_you_create_memory_leak_or_segfault",
        "document": "I am a data scientist, thus working primarily in Python, R, and JavaScript; but also learnt some C++ and Rust, and I want to decide which language out of these two shall I learn deeper (for my goals, that is: writing Python extensions and writing high performance infrastructure e.g. APIs). For some particular reasons I better enjoy programming in C++, just wondering: in your daily work, how big problem it is to manage all the memory safety issues under modern C++, which are addressed by Rust?"
    }
]