[
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html",
        "document": "\n• Converts the object to a string. The string representation is the string \"class\" or \"interface\", followed by a space, and then by the fully qualified name of the class in the format returned by . If this object represents a primitive type, this method returns the name of the primitive type. If this object represents void this method returns \"void\".\n• , including information about modifiers and type parameters. The string is formatted as a list of type modifiers, if any, followed by the kind of type (empty string for primitive types and , , , or , as appropriate), followed by the type's name, followed by an angle-bracketed comma-separated list of the type's type parameters, if any. A space is used to separate modifiers from one another and to separate any modifiers from the kind of type. The modifiers occur in canonical order. If there are no type parameters, the type parameter list is elided. Returns a string describing this, including information about modifiers and type parameters. The string is formatted as a list of type modifiers, if any, followed by the kind of type (empty string for primitive types and, or, as appropriate), followed by the type's name, followed by an angle-bracketed comma-separated list of the type's type parameters, if any. A space is used to separate modifiers from one another and to separate any modifiers from the kind of type. The modifiers occur in canonical order. If there are no type parameters, the type parameter list is elided. Note that since information about the runtime representation of a type is being generated, modifiers not present on the originating source code or illegal on the originating source code may be present. a string describing this , including information about modifiers and type parameters\n• object associated with the class or interface with the given string name. Invoking this method is equivalent to: where denotes the defining class loader of the current class. Returns theobject associated with the class or interface with the given string name. Invoking this method is equivalent to:wheredenotes the defining class loader of the current class. For example, the following code fragment returns the runtime descriptor for the class named : A call to causes the class named to be initialized. - the fully qualified name of the desired class. the object for the class with the specified name. - if the initialization provoked by this method fails - if the class cannot be located\n• object associated with the class or interface with the given string name, using the given class loader. Given the fully qualified name for a class or interface (in the same format returned by ) this method attempts to locate, load, and link the class or interface. The specified class loader is used to load the class or interface. If the parameter is null, the class is loaded through the bootstrap class loader. The class is initialized only if the parameter is and if it has not been initialized earlier. Returns theobject associated with the class or interface with the given string name, using the given class loader. Given the fully qualified name for a class or interface (in the same format returned by) this method attempts to locate, load, and link the class or interface. The specified class loader is used to load the class or interface. If the parameteris null, the class is loaded through the bootstrap class loader. The class is initialized only if theparameter isand if it has not been initialized earlier. If denotes a primitive type or void, an attempt will be made to locate a user-defined class in the unnamed package whose name is . Therefore, this method cannot be used to obtain any of the objects representing primitive types or void. If denotes an array class, the component type of the array class is loaded but not initialized. For example, in an instance method the expression: is equivalent to: Note that this method throws errors related to loading, linking or initializing as specified in Sections 12.2, 12.3 and 12.4 of The Java Language Specification. Note that this method does not check whether the requested class is accessible to its caller. is equivalent to:Note that this method throws errors related to loading, linking or initializing as specified in Sections 12.2, 12.3 and 12.4 of The Java Language Specification. Note that this method does not check whether the requested class is accessible to its caller. If the is , and a security manager is present, and the caller's class loader is not null, then this method calls the security manager's method with a permission to ensure it's ok to access the bootstrap class loader. - fully qualified name of the desired class - if the class will be initialized. See Section 12.4 of The Java Language Specification. - class loader from which the class must be loaded - if the initialization provoked by this method fails - if the class cannot be located by the specified class loader\n• object. The class is instantiated as if by a expression with an empty argument list. The class is initialized if it has not already been initialized. Creates a new instance of the class represented by thisobject. The class is instantiated as if by aexpression with an empty argument list. The class is initialized if it has not already been initialized. Note that this method propagates any exception thrown by the nullary constructor, including a checked exception. Use of this method effectively bypasses the compile-time exception checking that would otherwise be performed by the compiler. The method avoids this problem by wrapping any exception thrown by the constructor in a (checked) . a newly allocated instance of the class represented by this object. - if the class or its nullary constructor is not accessible. - if this represents an abstract class, an interface, an array class, a primitive type, or void; or if the class has no nullary constructor; or if the instantiation fails for some other reason. - if the initialization provoked by this method fails. - If a security manager, s, is present and the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of denies access to the package of this class.\n• is assignment-compatible with the object represented by this . This method is the dynamic equivalent of the Java language operator. The method returns if the specified argument is non-null and can be cast to the reference type represented by this object without raising a It returns otherwise. Determines if the specifiedis assignment-compatible with the object represented by this. This method is the dynamic equivalent of the Java languageoperator. The method returnsif the specifiedargument is non-null and can be cast to the reference type represented by thisobject without raising aIt returnsotherwise. Specifically, if this object represents a declared class, this method returns if the specified argument is an instance of the represented class (or of any of its subclasses); it returns otherwise. If this object represents an array class, this method returns if the specified argument can be converted to an object of the array class by an identity conversion or by a widening reference conversion; it returns otherwise. If this object represents an interface, this method returns if the class or any superclass of the specified argument implements this interface; it returns otherwise. If this object represents a primitive type, this method returns . true if is an instance of this class\n• object is either the same as, or is a superclass or superinterface of, the class or interface represented by the specified parameter. It returns if so; otherwise it returns . If this object represents a primitive type, this method returns if the specified parameter is exactly this object; otherwise it returns . Determines if the class or interface represented by thisobject is either the same as, or is a superclass or superinterface of, the class or interface represented by the specifiedparameter. It returnsif so; otherwise it returns. If thisobject represents a primitive type, this method returnsif the specifiedparameter is exactly thisobject; otherwise it returns Specifically, this method tests whether the type represented by the specified parameter can be converted to the type represented by this object via an identity conversion or via a widening reference conversion. See The Java Language Specification, sections 5.1.1 and 5.1.4 , for details. - the object to be checked the value indicating whether objects of the type can be assigned to objects of this class - if the specified Class parameter is null.\n• Determines if the specified object represents an interface type. if this object represents an interface; otherwise.\n• Determines if this object represents an array class. if this object represents an array class; otherwise.\n• object represents a primitive type. There are nine predefined objects to represent the eight primitive types and void. These are created by the Java Virtual Machine, and have the same names as the primitive types that they represent, namely , , , , , , , and . These objects may only be accessed via the following public static final variables, and are the only objects for which this method returns . true if and only if this class represents a primitive type\n• object represents an annotation type. Note that if this method returns true, Returns true if thisobject represents an annotation type. Note that if this method returns true, would also return true, as all annotation types are also interfaces. if this class object represents an annotation type; otherwise\n• Returns if this class is a synthetic class; returns otherwise. if and only if this class is a synthetic class as defined by the Java Language Specification.\n• object, as a . Returns the name of the entity (class, interface, array class, primitive type, or void) represented by thisobject, as a If this class object represents a reference type that is not an array type then the binary name of the class is returned, as specified by . If this class object represents a primitive type or void, then the name returned is a equal to the Java language keyword corresponding to the primitive type or void. If this class object represents a class of arrays, then the internal form of the name consists of the name of the element type preceded by one or more ' ' characters representing the depth of the array nesting. The encoding of element type names is as follows: The class or interface name classname is the binary name of the class specified above. the name of the class or interface represented by this object.\n• Returns the class loader for the class. Some implementations may use null to represent the bootstrap class loader. This method will return null in such implementations if this class was loaded by the bootstrap class loader. If a security manager is present, and the caller's class loader is not null and the caller's class loader is not the same as or an ancestor of the class loader for the class whose class loader is requested, then this method calls the security manager's method with a permission to ensure it's ok to access the class loader for the class. If this object represents a primitive type or void, null is returned. the class loader that loaded the class or interface represented by this object. - if a security manager exists and its method denies access to the class loader for the class.\n• Returns an array of objects that represent the type variables declared by the generic declaration represented by this object, in declaration order. Returns an array of length 0 if the underlying generic declaration declares no type variables. an array of objects that represent the type variables declared by this generic declaration - if the generic signature of this generic declaration does not conform to the format specified in\n• Returns the representing the superclass of the entity (class, interface, primitive type or void) represented by this . If this represents either the class, an interface, a primitive type, or void, then null is returned. If this object represents an array class then the object representing the class is returned. the superclass of the class represented by this object.\n• representing the direct superclass of the entity (class, interface, primitive type or void) represented by this . Returns therepresenting the direct superclass of the entity (class, interface, primitive type or void) represented by this If the superclass is a parameterized type, the object returned must accurately reflect the actual type parameters used in the source code. The parameterized type representing the superclass is created if it had not been created before. See the declaration of for the semantics of the creation process for parameterized types. If this represents either the class, an interface, a primitive type, or void, then null is returned. If this object represents an array class then the object representing the class is returned. the superclass of the class represented by this object - if the generic class signature does not conform to the format specified in - if the generic superclass refers to a non-existent type declaration - if the generic superclass refers to a parameterized type that cannot be instantiated for any reason\n• Gets the package for this class. The class loader of this class is used to find the package. If the class was loaded by the bootstrap class loader the set of packages loaded from CLASSPATH is searched to find the package of the class. Null is returned if no package object was created by the class loader of this class. Packages have attributes for versions and specifications only if the information was defined in the manifests that accompany the classes, and if the class loader created the package instance with the attributes from the manifest. the package of the class, or null if no package information is available from the archive or codebase.\n• Determines the interfaces implemented by the class or interface represented by this object. If this object represents a class, the return value is an array containing objects representing all interfaces implemented by the class. The order of the interface objects in the array corresponds to the order of the interface names in the clause of the declaration of the class represented by this object. For example, given the declaration: suppose the value of is an instance of ; the value of the expression: is the object that represents interface ; and the value of: is the object that represents interface . suppose the value ofis an instance of; the value of the expression:is theobject that represents interface; and the value of:is theobject that represents interface If this object represents an interface, the array contains objects representing all interfaces extended by the interface. The order of the interface objects in the array corresponds to the order of the interface names in the clause of the declaration of the interface represented by this object. If this object represents a class or interface that implements no interfaces, the method returns an array of length 0. If this object represents a primitive type or void, the method returns an array of length 0. If this object represents an array type, the interfaces and are returned in that order. an array of interfaces implemented by this class.\n• s representing the interfaces directly implemented by the class or interface represented by this object. Returns thes representing the interfaces directly implemented by the class or interface represented by this object. If a superinterface is a parameterized type, the object returned for it must accurately reflect the actual type parameters used in the source code. The parameterized type representing each superinterface is created if it had not been created before. See the declaration of for the semantics of the creation process for parameterized types. If this object represents a class, the return value is an array containing objects representing all interfaces implemented by the class. The order of the interface objects in the array corresponds to the order of the interface names in the clause of the declaration of the class represented by this object. In the case of an array class, the interfaces and are returned in that order. If this object represents an interface, the array contains objects representing all interfaces directly extended by the interface. The order of the interface objects in the array corresponds to the order of the interface names in the clause of the declaration of the interface represented by this object. If this object represents a class or interface that implements no interfaces, the method returns an array of length 0. If this object represents a primitive type or void, the method returns an array of length 0. an array of interfaces implemented by this class - if the generic class signature does not conform to the format specified in - if any of the generic superinterfaces refers to a non-existent type declaration - if any of the generic superinterfaces refer to a parameterized type that cannot be instantiated for any reason\n• Returns the representing the component type of an array. If this class does not represent an array class this method returns null. the representing the component type of this class if this class is an array\n• , , , , , and ; they should be decoded using the methods of class . Returns the Java language modifiers for this class or interface, encoded in an integer. The modifiers consist of the Java Virtual Machine's constants forand; they should be decoded using the methods of class If the underlying class is an array class, then its , and modifiers are the same as those of its component type. If this represents a primitive type or void, its modifier is always , and its and modifiers are always . If this object represents an array class, a primitive type or void, then its modifier is always and its interface modifier is always . The values of its other modifiers are not determined by this specification. The modifier encodings are defined in The Java Virtual Machine Specification, table 4.1. the representing the modifiers for this class\n• Gets the signers of this class. the signers of this class, or null if there are no signers. In particular, this method returns null if this object represents a primitive type or void.\n• object represents a local or anonymous class within a method, returns a otherwise. In particular, this method returns if the underlying class is a local or anonymous class immediately enclosed by a type declaration, instance initializer or static initializer. If thisobject represents a local or anonymous class within a method, returns a object representing the immediately enclosing method of the underlying class. Returnsotherwise. In particular, this method returnsif the underlying class is a local or anonymous class immediately enclosed by a type declaration, instance initializer or static initializer. the immediately enclosing method of the underlying class, if that class is a local or anonymous class; otherwise . - If a security manager, s, is present and any of the following conditions is met:\n• the caller's class loader is not the same as the class loader of the enclosing class and invocation of method with denies access to the methods within the enclosing class\n• the caller's class loader is not the same as or an ancestor of the class loader for the enclosing class and invocation of denies access to the package of the enclosing class\n• object represents a local or anonymous class within a constructor, returns a otherwise. In particular, this method returns if the underlying class is a local or anonymous class immediately enclosed by a type declaration, instance initializer or static initializer. If thisobject represents a local or anonymous class within a constructor, returns a object representing the immediately enclosing constructor of the underlying class. Returnsotherwise. In particular, this method returnsif the underlying class is a local or anonymous class immediately enclosed by a type declaration, instance initializer or static initializer. the immediately enclosing constructor of the underlying class, if that class is a local or anonymous class; otherwise . - If a security manager, s, is present and any of the following conditions is met:\n• the caller's class loader is not the same as the class loader of the enclosing class and invocation of method with denies access to the constructors within the enclosing class\n• the caller's class loader is not the same as or an ancestor of the class loader for the enclosing class and invocation of denies access to the package of the enclosing class\n• If the class or interface represented by this object is a member of another class, returns the object representing the class in which it was declared. This method returns null if this class or interface is not a member of any other class. If this object represents an array class, a primitive type, or void,then this method returns null. the declaring class for this class - If a security manager, s, is present and the caller's class loader is not the same as or an ancestor of the class loader for the declaring class and invocation of denies access to the package of the declaring class\n• Returns the immediately enclosing class of the underlying class. If the underlying class is a top level class this method returns . the immediately enclosing class of the underlying class - If a security manager, s, is present and the caller's class loader is not the same as or an ancestor of the class loader for the enclosing class and invocation of denies access to the package of the enclosing class\n• Returns the simple name of the underlying class as given in the source code. Returns an empty string if the underlying class is anonymous. The simple name of an array is the simple name of the component type with \"[]\" appended. In particular the simple name of an array whose component type is anonymous is \"[]\". the simple name of the underlying class\n• Return an informative string for the name of this type. an informative string for the name of this type\n• Returns the canonical name of the underlying class as defined by the Java Language Specification. Returns null if the underlying class does not have a canonical name (i.e., if it is a local or anonymous class or an array whose component type does not have a canonical name). the canonical name of the underlying class if it exists, and otherwise.\n• Returns if and only if the underlying class is an anonymous class. if and only if this class is an anonymous class.\n• Returns if and only if the underlying class is a local class. if and only if this class is a local class.\n• Returns if and only if the underlying class is a member class. if and only if this class is a member class.\n• Returns an array containing objects representing all the public classes and interfaces that are members of the class represented by this object. This includes public class and interface members inherited from superclasses and public class and interface members declared by the class. This method returns an array of length 0 if this object has no public member classes or interfaces. This method also returns an array of length 0 if this object represents a primitive type, an array class, or void. the array of objects representing the public members of this class - If a security manager, s, is present and the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of denies access to the package of this class.\n• objects reflecting all the accessible public fields of the class or interface represented by this object. Returns an array containingobjects reflecting all the accessible public fields of the class or interface represented by thisobject. If this object represents a class or interface with no no accessible public fields, then this method returns an array of length 0. If this object represents a class, then this method returns the public fields of the class and of all its superclasses. If this object represents an interface, then this method returns the fields of the interface and of all its superinterfaces. If this object represents an array type, a primitive type, or void, then this method returns an array of length 0. The elements in the returned array are not sorted and are not in any particular order. the array of objects representing the public fields - If a security manager, s, is present and the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of denies access to the package of this class.\n• objects reflecting all the public methods of the class or interface represented by this object, including those declared by the class or interface and those inherited from superclasses and superinterfaces. Returns an array containingobjects reflecting all the public methods of the class or interface represented by thisobject, including those declared by the class or interface and those inherited from superclasses and superinterfaces. If this object represents a type that has multiple public methods with the same name and parameter types, but different return types, then the returned array has a object for each such method. If this object represents a type with a class initialization method , then the returned array does not have a corresponding object. If this object represents an array type, then the returned array has a object for each of the public methods inherited by the array type from . It does not contain a object for . If this object represents an interface then the returned array does not contain any implicitly declared methods from . Therefore, if no methods are explicitly declared in this interface or any of its superinterfaces then the returned array has length 0. (Note that a object which represents a class always has public methods, inherited from .) If this object represents a primitive type or void, then the returned array has length 0. Static methods declared in superinterfaces of the class or interface represented by this object are not considered members of the class or interface. The elements in the returned array are not sorted and are not in any particular order. the array of objects representing the public methods of this class - If a security manager, s, is present and the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of denies access to the package of this class.\n• Returns an array containing objects reflecting all the public constructors of the class represented by this object. An array of length 0 is returned if the class has no public constructors, or if the class is an array class, or if the class reflects a primitive type or void. Note that while this method returns an array of objects (that is an array of constructors from this class), the return type of this method is and not as might be expected. This less informative return type is necessary since after being returned from this method, the array could be modified to hold objects for different classes, which would violate the type guarantees of . the array of objects representing the public constructors of this class - If a security manager, s, is present and the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of denies access to the package of this class.\n• object that reflects the specified public member field of the class or interface represented by this object. The parameter is a specifying the simple name of the desired field. Returns aobject that reflects the specified public member field of the class or interface represented by thisobject. Theparameter is aspecifying the simple name of the desired field. The field to be reflected is determined by the algorithm that follows. Let C be the class or interface represented by this object:\n• If C declares a public field with the name specified, that is the field to be reflected.\n• If no field was found in step 1 above, this algorithm is applied recursively to each direct superinterface of C. The direct superinterfaces are searched in the order they were declared.\n• If no field was found in steps 1 and 2 above, and C has a superclass S, then this algorithm is invoked recursively upon S. If C has no superclass, then a is thrown. If this object represents an array type, then this method does not find the field of the array type. the object of this class specified by - if a field with the specified name is not found. - If a security manager, s, is present and the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of denies access to the package of this class.\n• object that reflects the specified public member method of the class or interface represented by this object. The parameter is a specifying the simple name of the desired method. The parameter is an array of objects that identify the method's formal parameter types, in declared order. If is , it is treated as if it were an empty array. Returns aobject that reflects the specified public member method of the class or interface represented by thisobject. Theparameter is aspecifying the simple name of the desired method. Theparameter is an array ofobjects that identify the method's formal parameter types, in declared order. Ifis, it is treated as if it were an empty array. If the is \" \" or \" \" a is raised. Otherwise, the method to be reflected is determined by the algorithm that follows. Let C be the class or interface represented by this object:\n• C is searched for a matching method, as defined below. If a matching method is found, it is reflected.\n• If no matching method is found by step 1 then:\n• If C is a class other than , then this algorithm is invoked recursively on the superclass of C.\n• If C is the class , or if C is an interface, then the superinterfaces of C (if any) are searched for a matching method. If any such method is found, it is reflected. To find a matching method in a class or interface C: If C declares exactly one public method with the specified name and exactly the same formal parameter types, that is the method reflected. If more than one such method is found in C, and one of these methods has a return type that is more specific than any of the others, that method is reflected; otherwise one of the methods is chosen arbitrarily. Note that there may be more than one matching method in a class because while the Java language forbids a class to declare multiple methods with the same signature but different return types, the Java virtual machine does not. This increased flexibility in the virtual machine can be used to implement various language features. For example, covariant returns can be implemented with bridge methods; the bridge method and the method being overridden would have the same signature but different return types. If this object represents an array type, then this method does not find the method. Static methods declared in superinterfaces of the class or interface represented by this object are not considered members of the class or interface. - the name of the method the object that matches the specified and - if a matching method is not found or if the name is \"<init>\"or \"<clinit>\". - If a security manager, s, is present and the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of denies access to the package of this class.\n• object that reflects the specified public constructor of the class represented by this object. The parameter is an array of objects that identify the constructor's formal parameter types, in declared order. If this object represents an inner class declared in a non-static context, the formal parameter types include the explicit enclosing instance as the first parameter. Returns aobject that reflects the specified public constructor of the class represented by thisobject. Theparameter is an array ofobjects that identify the constructor's formal parameter types, in declared order. If thisobject represents an inner class declared in a non-static context, the formal parameter types include the explicit enclosing instance as the first parameter. The constructor to reflect is the public constructor of the class represented by this object whose formal parameter types match those specified by . the object of the public constructor that matches the specified - if a matching method is not found. - If a security manager, s, is present and the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of denies access to the package of this class.\n• Returns an array of objects reflecting all the classes and interfaces declared as members of the class represented by this object. This includes public, protected, default (package) access, and private classes and interfaces declared by the class, but excludes inherited classes and interfaces. This method returns an array of length 0 if the class declares no classes or interfaces as members, or if this object represents a primitive type, an array class, or void. the array of objects representing all the declared members of this class - If a security manager, s, is present and any of the following conditions is met:\n• the caller's class loader is not the same as the class loader of this class and invocation of method with denies access to the declared classes within this class\n• the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of denies access to the package of this class\n• objects reflecting all the fields declared by the class or interface represented by this object. This includes public, protected, default (package) access, and private fields, but excludes inherited fields. Returns an array ofobjects reflecting all the fields declared by the class or interface represented by thisobject. This includes public, protected, default (package) access, and private fields, but excludes inherited fields. If this object represents a class or interface with no declared fields, then this method returns an array of length 0. If this object represents an array type, a primitive type, or void, then this method returns an array of length 0. The elements in the returned array are not sorted and are not in any particular order. the array of objects representing all the declared fields of this class - If a security manager, s, is present and any of the following conditions is met:\n• the caller's class loader is not the same as the class loader of this class and invocation of method with denies access to the declared fields within this class\n• the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of denies access to the package of this class\n• objects reflecting all the declared methods of the class or interface represented by this object, including public, protected, default (package) access, and private methods, but excluding inherited methods. Returns an array containingobjects reflecting all the declared methods of the class or interface represented by thisobject, including public, protected, default (package) access, and private methods, but excluding inherited methods. If this object represents a type that has multiple declared methods with the same name and parameter types, but different return types, then the returned array has a object for each such method. If this object represents a type that has a class initialization method , then the returned array does not have a corresponding object. If this object represents a class or interface with no declared methods, then the returned array has length 0. If this object represents an array type, a primitive type, or void, then the returned array has length 0. The elements in the returned array are not sorted and are not in any particular order. the array of objects representing all the declared methods of this class - If a security manager, s, is present and any of the following conditions is met:\n• the caller's class loader is not the same as the class loader of this class and invocation of method with denies access to the declared methods within this class\n• the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of denies access to the package of this class\n• objects reflecting all the constructors declared by the class represented by this object. These are public, protected, default (package) access, and private constructors. The elements in the array returned are not sorted and are not in any particular order. If the class has a default constructor, it is included in the returned array. This method returns an array of length 0 if this object represents an interface, a primitive type, an array class, or void. Returns an array ofobjects reflecting all the constructors declared by the class represented by thisobject. These are public, protected, default (package) access, and private constructors. The elements in the array returned are not sorted and are not in any particular order. If the class has a default constructor, it is included in the returned array. This method returns an array of length 0 if thisobject represents an interface, a primitive type, an array class, or void. the array of objects representing all the declared constructors of this class - If a security manager, s, is present and any of the following conditions is met:\n• the caller's class loader is not the same as the class loader of this class and invocation of method with denies access to the declared constructors within this class\n• the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of denies access to the package of this class\n• object that reflects the specified declared field of the class or interface represented by this object. The parameter is a that specifies the simple name of the desired field. Returns aobject that reflects the specified declared field of the class or interface represented by thisobject. Theparameter is athat specifies the simple name of the desired field. If this object represents an array type, then this method does not find the field of the array type. - the name of the field the object for the specified field in this class - if a field with the specified name is not found. - If a security manager, s, is present and any of the following conditions is met:\n• the caller's class loader is not the same as the class loader of this class and invocation of method with denies access to the declared field\n• the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of denies access to the package of this class\n• object that reflects the specified declared method of the class or interface represented by this object. The parameter is a that specifies the simple name of the desired method, and the parameter is an array of objects that identify the method's formal parameter types, in declared order. If more than one method with the same parameter types is declared in a class, and one of these methods has a return type that is more specific than any of the others, that method is returned; otherwise one of the methods is chosen arbitrarily. If the name is \"<init>\"or \"<clinit>\" a is raised. Returns aobject that reflects the specified declared method of the class or interface represented by thisobject. Theparameter is athat specifies the simple name of the desired method, and theparameter is an array ofobjects that identify the method's formal parameter types, in declared order. If more than one method with the same parameter types is declared in a class, and one of these methods has a return type that is more specific than any of the others, that method is returned; otherwise one of the methods is chosen arbitrarily. If the name is \" If this object represents an array type, then this method does not find the method. - the name of the method the object for the method of this class matching the specified name and parameters - if a matching method is not found. - If a security manager, s, is present and any of the following conditions is met:\n• the caller's class loader is not the same as the class loader of this class and invocation of method with denies access to the declared method\n• the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of denies access to the package of this class\n• Returns a object that reflects the specified constructor of the class or interface represented by this object. The parameter is an array of objects that identify the constructor's formal parameter types, in declared order. If this object represents an inner class declared in a non-static context, the formal parameter types include the explicit enclosing instance as the first parameter. The object for the constructor with the specified parameter list - if a matching method is not found. - If a security manager, s, is present and any of the following conditions is met:\n• the caller's class loader is not the same as the class loader of this class and invocation of method with denies access to the declared constructor\n• the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of denies access to the package of this class\n• Finds a resource with a given name. The rules for searching resources associated with a given class are implemented by the defining class loader of the class. This method delegates to this object's class loader. If this object was loaded by the bootstrap class loader, the method delegates to Before delegation, an absolute resource name is constructed from the given resource name using this algorithm:\n• If the begins with a ( ), then the absolute name of the resource is the portion of the following the .\n• Otherwise, the absolute name is of the following form: Where the is the package name of this object with substituted for ( ). - name of the desired resource A object or if no resource with this name is found\n• Finds a resource with a given name. The rules for searching resources associated with a given class are implemented by the defining class loader of the class. This method delegates to this object's class loader. If this object was loaded by the bootstrap class loader, the method delegates to Before delegation, an absolute resource name is constructed from the given resource name using this algorithm:\n• If the begins with a ( ), then the absolute name of the resource is the portion of the following the .\n• Otherwise, the absolute name is of the following form: Where the is the package name of this object with substituted for ( ). - name of the desired resource A object or if no resource with this name is found\n• Returns the of this class. If there is a security manager installed, this method first calls the security manager's method with a permission to ensure it's ok to get the . the ProtectionDomain of this class - if a security manager exists and its method doesn't allow getting the ProtectionDomain.\n• Returns the assertion status that would be assigned to this class if it were to be initialized at the time this method is invoked. If this class has had its assertion status set, the most recent setting will be returned; otherwise, if any package default assertion status pertains to this class, the most recent setting for the most specific pertinent package default assertion status is returned; otherwise, if this class is not a system class (i.e., it has a class loader) its class loader's default assertion status is returned; otherwise, the system class default assertion status is returned. Few programmers will have any need for this method; it is provided for the benefit of the JRE itself. (It allows a class to determine at the time that it is initialized whether assertions should be enabled.) Note that this method is not guaranteed to return the actual assertion status that was (or will be) associated with the specified class when it was (or will be) initialized. the desired assertion status of the specified class.\n• Returns true if and only if this class was declared as an enum in the source code. true if and only if this class was declared as an enum in the source code\n• Returns the elements of this enum class or null if this Class object does not represent an enum type. an array containing the values comprising the enum class represented by this Class object in the order they're declared, or null if this Class object does not represent an enum type\n• Casts an object to the class or interface represented by this object. - the object to be cast the object after casting, or null if obj is null - if the object is not null and is not assignable to the type T.\n• object to represent a subclass of the class represented by the specified class object. Checks that the cast is valid, and throws a if it is not. If this method succeeds, it always returns a reference to this class object. Casts thisobject to represent a subclass of the class represented by the specified class object. Checks that the cast is valid, and throws aif it is not. If this method succeeds, it always returns a reference to this class object. This method is useful when a client needs to \"narrow\" the type of a object to pass it to an API that restricts the objects that it is willing to accept. A cast would generate a compile-time warning, as the correctness of the cast could not be checked at runtime (because generic types are implemented by erasure). - the type to cast this class object to - the class of the type to cast this class object to this object, cast to represent a subclass of the specified class object. - if this object does not represent a subclass of the specified class (here \"subclass\" includes the class itself).\n• Returns this element's annotation for the specified type if such an annotation is present, else null. - the type of the annotation to query for and return if present - the Class object corresponding to the annotation type this element's annotation for the specified annotation type if present on this element, else null - if the given annotation class is null\n• Returns true if an annotation for the specified type is present on this element, else false. This method is designed primarily for convenient access to marker annotations. The truth value returned by this method is equivalent to: The body of the default method is specified to be the code above. - the Class object corresponding to the annotation type true if an annotation for the specified annotation type is present on this element, else false - if the given annotation class is null\n• Returns annotations that are associated with this element. If there are no annotations associated with this element, the return value is an array of length 0. The difference between this method and is that this method detects if its argument is a repeatable annotation type (JLS 9.6), and if so, attempts to find one or more annotations of that type by \"looking through\" a container annotation. The caller of this method is free to modify the returned array; it will have no effect on the arrays returned to other callers. - the type of the annotation to query for and return if present - the Class object corresponding to the annotation type all this element's annotations for the specified annotation type if associated with this element, else an array of length zero - if the given annotation class is null\n• Returns annotations that are present on this element. If there are no annotations present on this element, the return value is an array of length 0. The caller of this method is free to modify the returned array; it will have no effect on the arrays returned to other callers.\n• Returns this element's annotation for the specified type if such an annotation is directly present, else null. This method ignores inherited annotations. (Returns null if no annotations are directly present on this element.) - the type of the annotation to query for and return if directly present - the Class object corresponding to the annotation type this element's annotation for the specified annotation type if directly present on this element, else null - if the given annotation class is null\n• Returns this element's annotation(s) for the specified type if such annotations are either directly present or indirectly present. This method ignores inherited annotations. If there are no specified annotations directly or indirectly present on this element, the return value is an array of length 0. The difference between this method and is that this method detects if its argument is a repeatable annotation type (JLS 9.6), and if so, attempts to find one or more annotations of that type by \"looking through\" a container annotation if one is present. The caller of this method is free to modify the returned array; it will have no effect on the arrays returned to other callers. - the type of the annotation to query for and return if directly or indirectly present - the Class object corresponding to the annotation type all this element's annotations for the specified annotation type if directly or indirectly present on this element, else an array of length zero - if the given annotation class is null\n• Returns annotations that are directly present on this element. This method ignores inherited annotations. If there are no annotations directly present on this element, the return value is an array of length 0. The caller of this method is free to modify the returned array; it will have no effect on the arrays returned to other callers.\n• object that represents the use of a type to specify the superclass of the entity represented by this object. (The use of type Foo to specify the superclass in '... extends Foo' is distinct from the declaration of type Foo.) Returns anobject that represents the use of a type to specify the superclass of the entity represented by thisobject. (The use of type Foo to specify the superclass in '... extends Foo' is distinct from the declaration of type Foo.) If this object represents a type whose declaration does not explicitly indicate an annotated superclass, then the return value is an object representing an element with no annotations. If this represents either the class, an interface type, an array type, a primitive type, or void, the return value is .\n• objects that represent the use of types to specify superinterfaces of the entity represented by this object. (The use of type Foo to specify a superinterface in '... implements Foo' is distinct from the declaration of type Foo.) Returns an array ofobjects that represent the use of types to specify superinterfaces of the entity represented by thisobject. (The use of type Foo to specify a superinterface in '... implements Foo' is distinct from the declaration of type Foo.) If this object represents a class, the return value is an array containing objects representing the uses of interface types to specify interfaces implemented by the class. The order of the objects in the array corresponds to the order of the interface types used in the 'implements' clause of the declaration of this object. If this object represents an interface, the return value is an array containing objects representing the uses of interface types to specify interfaces directly extended by the interface. The order of the objects in the array corresponds to the order of the interface types used in the 'extends' clause of the declaration of this object. If this object represents a class or interface whose declaration does not explicitly indicate any annotated superinterfaces, the return value is an array of length 0. If this object represents either the class, an array type, a primitive type, or void, the return value is an array of length 0."
    },
    {
        "link": "https://medium.com/@aariff.deen/an-adventure-in-java-concurrency-callable-vs-runnable-explained-496ba004ba99",
        "document": "I recently began focusing on Java as my core programming language in an attempt to solidify my backend development skills and immerse myself in the world of Object Oriented Programming. My latest personal project has been a implementation of the Raft Consensus Algorithm, in which I utilize concurrency in Java along with socket programming.\n\nWhile working on my implementation of Raft, I wanted the code that I ran in a separate thread of execution to be able to throw exceptions. Seeing that this is not possible in the Runnable interface, I had to turn my head towards another interface in Java: Callable.\n\nCallable is an Java (5) interface that can be run in a separate thread of execution and is capable of returning a value as well as throwing an exception.\n\nI found the differences between Runnable and Callable to be interesting. Therefore, I wanted to write about what I learned regarding the topic in hopes that someone exploring the same concept in the future can make use of this post.\n\nRunnable is an interface that requires you to override the abstract method public void run(). An implementation of the Runnable interface would look like the following.\n\nIf we want to run our class in a separate thread of execution we can use the Thread class. In the code below, a Thread object is created by passing a Runnable object as the parameter.\n\nBy calling the method start() of our Thread object, we can run the code in the public void run() method of our Runnable Example class as a separate process.\n\nNote that we can still handle exceptions using Runnable, we just need to handle all exceptions within the run() method that we override.\n\nHow does this compare to Callable?\n\nAs a reminder, Callable, like Runnable, is a Java interface that can be run in a separate thread of execution. However, Callable can be used to return data from and throw exceptions from the code that is run in these computations.\n\nJust as Runnable requires us to override the public void run() method, Callable requires us to override the public <?> call() method. The return type of the method is determined by type we specify in the generic interface of the Callable class.\n\nWe can run Callable in separate thread and obtain the result via a Future Object. The Future class graciously provides us methods which can be called to handle the result of our computation.\n\nIn this fashion, we can use Callable and Future to run our code in a separate thread of execution and utilize the returned data in original context of our code.\n\nOne of the benefits of the Callable interface is the fact that it enables us to throw exceptions that are handled outside of the separate thread of execution.\n\nFor example, suppose we alter our implementation of Callable to force an exception in our call() method.\n\nThis will result in an exception being thrown by future.get, which can be handled in the try catch statement surrounding the method call.\n\nThanks for reading my post! I hope I was able to communicate the differences between the Callable and Runnable interfaces and their use cases.\n\nI would love to hear from you in the comments! If you notice any errors or incorrect information in the post, please let me know and I’ll be sure to make the appropriate correction."
    },
    {
        "link": "https://blog.convisoappsec.com/en/finding-classes-to-exploit-insecure-unchecked-vulnerabilities-in-java-with-joern",
        "document": "During a pentest engagement we found a Java application vulnerable to unsafe reflection [1]. This application allowed us to instantiate an arbitrary class with a controlled string passed to its constructor as argument. When we became aware of the dependencies used by the application, we posed the following question: How could we automate the process to find good classes?\n\nFor good class we mean classes that match the criteria (the constructor receives a string) and has security implications (could be used to exploit the application). This blogpost will document how we automated this process.\n\nThe vulnerability we encountered during a pentest was PostgreSQL JDBC Driver Unchecked Class Instantiation (CVE-2022-21724) [9], in which an arbitrary class could be instantiated, taking a controllable argument of type string via JDBC URL. An example of payload can be seen below:\n\nWhen looking for writeups we found some interesting attacks [10] [11] using classes from Spring and other libraries, such as:\n\nHowever none of these classes were available in our target. Fortunately we managed to get access to the list of libraries used by the application with another vulnerability and with that we decided to automate the process of finding good classes for our attack.\n\nTo address our problem we can employ static analysis with data flow, which aims to identify paths from data sources to data sinks where processing occurs. In this particular scenario, we define our sources and sinks as follows:\n\nsource – classes with constructors that accept string as arguments\n\nsink – any method that could be used to exploit the application\n\nAfter understanding the problem and defining our sources and sinks, we realized the need for a tool to aid in this analysis. Since we anticipated the need to analyze dependencies in cases where only the compiled Java code would be available, we sought a tool capable of running analysis directly on JAR files. Consequently, we opted to use Joern [2], which offers support for JAR files, as seen in [3].\n\nFor those who are unfamiliar with Joern, it is a code analysis platform that utilizes a structure known as Code Property Graph (CPG) [4]. This platform enables us to execute queries on code using a Scala-based language, facilitating comprehensive code analysis. We can also use Joern to perform dataflow analysis, for instance, take a look at this code snippet:\n\nWe can use the following Joern script to find the path from source to sink:\n\nWhen running the script, we should obtain a result similar to the table below:\n\nThis example illustrates the type of analysis we will be conducting, with the distinction that instead of running it against the source code, we will execute it against the compiled code. It is worth mentioning that during our tests, we encountered an issue with Joern where it failed to capture paths when the source data was assigned to a class’s field member in compiled code. We have reported this issue [5] [6].\n\nTo validate the process of identifying suitable classes, we conducted experiments on several well-known Java libraries. To accomplish this, we used the following methodology:\n\nTo choose the sinks to be used in the dataflow analysis, we enumerated some of the most common types of vulnerabilities and attacks in Java applications with direct server-side impact. The list can be seen below:\n\nThen, for each one, we select a set of methods that can lead to such vulnerabilities when called with user-controlled data.\n\nWe created a script (https://github.com/convisolabs/java_unsafe_reflection/blob/main/downloader/download.py) to download the most relevant Java libraries in order to run our experiments. In short, it goes over an ordered list [8] of popular/relevant libraries and downloads each JAR file to a local directory.\n\nAfter enumerating the sinks and downloading the JARs, we have developed a Joern script (https://github.com/convisolabs/java_unsafe_reflection/blob/main/joern_scripts/all_sinks_each_file.sc) that accepts two folders as arguments. One folder represents the location of the JAR files, while the other folder is designated for storing the results.\n\nTo execute the script, use the following command:\n\nThe script will generate the results in JSON format. The output files will contain paths that link sources to sinks. To enhance readability, we have also created a separate script (https://github.com/convisolabs/java_unsafe_reflection/blob/main/utils/pretty_print_result.py) that facilitates the interpretation of the output.\n\nSome of the problems we had when developing and running this analysis were:\n• We encountered an issue with Joern where it failed to capture paths when the source data was assigned to a class’s field member in compiled code [5] [6];\n• It was slow if you did not have a good amount of RAM memory available. Also, bigger files would take more processing time. We skipped some of the larger libraries we downloaded;\n• We encountered some Java constructs that were not handled well by Joern and would make it unable to correctly track data flow, leading to miss good constructors (false negatives).\n\nDespite these problems, the analysis was still able to find good results.\n\nOne way to validate the results would be to directly access the source code (if available) or decompile the JAR file and attempt to follow the identified paths. However, this approach would only be feasible for a limited number of results or when the paths are relatively small, which is not the case in our scenario. Instead, we opted for dynamic validation. We developed a code that accepts a class and its corresponding argument, and attempts to instantiate it.\n\nWe then automated the process of retrieving the results, extracting the constructors, and instantiating them using a pre-established list of arguments. This list consisted of values carefully selected to validate various scenarios, including accessing servers, creating files, executing system commands, and more. We also logged all execution to be able to manually inspect it. The script can be seen at https://github.com/convisolabs/java_unsafe_reflection/blob/main/utils/tester.py.\n\nIn the GIF, the upper part of screen shows the tester.py script running and the lower part shows a live inspection of the generated log (tail -f /tmp/tester.dd-mm-yyyy_HHhMMmSSs.log).\n\nThis dynamic validation approach allowed us to verify the findings more efficiently and effectively.\n\nDue to the amount of results obtained, we reviewed only a small part of them and below are just a few of the interesting constructors we found:\n\nArg: some non existing file name (e.g. xxx)\n\nIn this blog we presented a simple approach to automate the discovery of interesting classes to be used when attacking unsafe reflection in Java applications. We showed how to use Joern to execute a customized dataflow analysis suited for our needs.\n\nAn interesting research titled “A New Attack Interface In Java Applications” presented by Xu Yuanzhen and Peter Mularien at Blackhat Asia 2023 [7] shows other examples of the process of finding good classes to exploit similar vulnerabilities via JDBC URLs.\n\nFollow-up work could be to run our analysis in the Java code itself, to discover interesting constructors that do not depend on an external library. Another one could be to take advantage of the script to find security vulnerabilities in Java applications by just redefining the source to represent user-controlled data such as HTTP request parameters, for example."
    },
    {
        "link": "https://javanexus.com/blog/stop-memory-leaks-anonymous-classes-java",
        "document": "Memory management is a crucial aspect of programming in Java. It not only optimizes the application's performance but also prevents potential crashes. Among the various features Java provides, anonymous classes are both powerful and perilous. When mismanaged, they can lead to memory leaks that can cripple your application. In this blog post, we will explore anonymous classes in Java, how they function, their best practices, and strategies to prevent memory leaks.\n\nWhat is an Anonymous Class?\n\nAn anonymous class in Java is a kind of inner class without a name. It enables you to instantiate a class and at the same time override some of its methods. Anonymous classes are often used to implement interfaces or extend class behavior in a concise manner. Consider the following code snippet:\n• Conciseness: They allow for more compact code.\n• Immediate implementation: Ideal for quick and simple event listeners.\n• Encapsulation: They keep implementation details close to their usage.\n\nWhile these attributes are advantageous, they come with risks that can lead to memory-related problems.\n\nA memory leak occurs when objects are no longer accessible but still occupy memory. In Java, this can lead to exhausting the heap space, causing the application to slow down or crash.\n\nIn the context of anonymous classes, memory leaks often arise due to unintended references to the outer classes. Here's an example to illustrate this concept:\n\nIn the example above, the anonymous class keeps a reference to its containing class instance ( ). If you create multiple instances of , those outer instances remain in memory until the threads are terminated, leading to a memory leak. Now, let’s explore how to prevent this.\n\nWhere possible, avoid using member variables from the outer class in the anonymous class. If you need to pass data, consider using method parameters or local variables.\n\nIn this example, we use a final local variable instead of an outer class member, which limits the scope of the reference.\n\nFor scenarios where you must keep a reference to the outer class, consider using . This allows garbage collection to clean up the reference when needed.\n\nThis way, if isn’t strongly referenced anywhere else, it can be garbage collected, preventing a memory leak.\n\nIf you do not need to access the outer class instance, consider using a nested class instead of an anonymous class. Static nested classes do not hold an implicit reference to the outer class.\n\nBy employing a static nested class, you create a clear demarcation from the outer class, lowering memory pressure.\n\nAnonymous classes in Java provide a convenient way to define classes on-the-fly. However, their use can complicate memory management if not handled with care. Memory leaks often result from unintended references to outer classes, leading to poor performance or application crashes.\n\nTo recap, here are three main strategies to combat memory leaks associated with anonymous classes:\n• Avoid unnecessary outer class references: Use local or final variables instead.\n• Use WeakReferences: This allows the garbage collector to reclaim memory if necessary.\n• Opt for static nested classes: Use them when you don't need direct access to the outer instance.\n\nBy understanding and implementing these strategies, you can harness the power of anonymous classes in Java without the fear of memory-related issues. If you're interested in further reading on memory management in Java, check out Java Memory Management and Understanding Memory Leaks in Java.\n\nEmbrace these techniques, and you'll be well on your way to writing efficient, leak-free Java applications!"
    },
    {
        "link": "https://en.verysource.com/code/32566867_1/CHANGELOG.html",
        "document": ""
    },
    {
        "link": "https://sematext.com/blog/java-logging-best-practices",
        "document": "Having visibility into your Java application is crucial for understanding how it works right now, how it worked some time in the past and increasing your understanding of how it might work in the future. More often than not, analyzing logs is the fastest way to detect what went wrong, thus making logging in Java critical to ensuring the performance and health of your app, as well as minimizing and reducing any downtime. Having a centralized logging and monitoring solution helps reduce the Mean Time To Repair by improving the effectiveness of your Ops or DevOps team.\n\nBy following good practices you will get more value out of your logs and make it easier to use them. You will be able to more easily pinpoint the root cause of errors and poor performance and solve problems before they impact end-users. So today, let me share some of the best practices you should swear by when working with Java applications. Let’s dig in.\n\nLogging in Java can be done in a few different ways. You can use a dedicated logging library, a common API, or even just write logs to file or directly to a dedicated logging system. However, when choosing the logging library for your system think ahead. Things to consider and evaluate are performance, flexibility, appenders for new log centralization solutions, and so on. If you tie yourself directly to a single framework the switch to a newer library can take a substantial amount of work and time. Keep that in mind and go for the API that will give you the flexibility to swap logging libraries in the future. Just like with the switch from Log4j to Logback and to Log4j 2, when using the SLF4J API the only thing you need to do is change the dependency, not the code.\n\nIf you’re new to Java logging libraries, check out our beginner’s guides:\n• JUL vs Log4j vs Log4j2 vs Logback vs SLF4J\n\nAppenders define where your log events will be delivered. The most common appenders are the Console and File Appenders. While useful and widely known, they may not fulfill your requirements. For example, you may want to write your logs in an asynchronous way or you may want to ship your logs over the network using appenders like the one for Syslog, like this:\n\nHowever, remember that using appenders like the one shown above makes your logging pipeline susceptible to network errors and communication disruptions. That may result in logs not being shipped to their destination, which may not be acceptable. You also want to avoid logging affecting your system if the appender is designed in a blocking way. To learn more, check our Logging libraries vs Log shippers blog post.\n\nOne of the crucial things when it comes to creating logs, yet one of the not-so-easy ones is using meaningful messages. Your log events should include messages that are unique to the given situation, clearly describe them and inform the person reading them. Imagine a communication error occurred in your application. You might do it like this:\n\nBut you could also create a message like this:\n\nYou can easily see that the first message will inform the person looking at the logs about communication issues. That person will probably have the context, the name of the logger, and the line number where the warning happened, but that is all. To get more context, that person would have to look at the code, know which version of the code the error is related to, and so on. This is not fun and often not easy, and certainly not something one wants to do while trying to troubleshoot a production issue as quickly as possible.\n\nThe second message is better. It provides exact information about what kind of communication error happened, what the application was doing at the time, what error code it got, and what the response from the remote server was. Finally, it also informs that sending the message will be retried. Working with such messages is definitely easier and more pleasant.\n\nFinally, think about the size and verbosity of the message. Don’t log information that is too verbose. This data needs to be stored somewhere in order to be useful. One very long message will not be a problem, but if that line is repeating hundreds of times in a minute and you have lots of verbose logs, keeping longer retention of such data may be problematic and, at the end of the day, will also cost more.\n\nOne of the very important parts of Java logging are the Java stack traces. Have a look at the following code:\n\nThe above code will result in an exception being thrown and a log message that will be printed to the console with our default configuration will look as follows:\n\nAs you can see there is not a lot of information there. We only know that the problem occurred, but we don’t know where it happened, or what the problem was, etc. Not very informative.\n\nNow, look at the same code with a slightly modified logging statement:\n\nAs you can see, this time we’ve included the exception object itself in our log message:\n\nThat would result in the following error log in the console with our default configuration:\n\nIt contains relevant information – i.e. the name of the class, the method where the problem occurred, and finally the line number where the problem happened. Of course, in real-life situations, the stack traces will be longer, but you should include them to give you enough information for proper debugging.\n\nTo learn more about handling Java stack traces with Logstash see Handling Multiline Stack Traces with Logstash or check out Logagent which can do that for you out of the box.\n\nWhen dealing with Java exceptions and stack traces you shouldn’t only think about the whole stack trace, the lines where the problem appeared, and so on. You should also think about how not to deal with exceptions.\n\nAvoid silently ignoring exceptions. You don’t want to ignore something important. For example, do not do this:\n\nAlso, don’t just log an exception and throw it further. That means that you just pushed the problem up the execution stack. Avoid things like this as well:\n\nIf you’re interested to learn more about exceptions, read our guide about Java exception handling where we cover everything from what they are to how to catch and fix them.\n\nWhen writing your application code think twice about a given log message. Not every bit of information is equally important and not every unexpected situation is an error or a critical message. Also, using the logging levels consistently – information of a similar type should be on a similar severity level.\n\nBoth SLF4J facade and each Java logging framework that you will be using provide methods that can be used to provide a proper log level. For example:\n\nIf we plan to log and look at the data manually in a file or the standard output then the planned logging will be more than fine. It is more user friendly – we are used to it. But that is only viable for very small applications and even then it is suggested to use something that will allow you to correlate JVM metrics data with Java logs. Doing such operations in a terminal window ain’t fun and sometimes it is simply not possible. If you want to store logs in the log management and centralization system you should log in JSON. That’s because parsing doesn’t come for free – it usually means using regular expressions. Of course, you can pay that price in the log shipper, but why do that if you can easily log in JSON. Logging in JSON also means easy handling of stack traces, so yet another advantage. Well, you can also just log to a Syslog compatible destination, but that is a different story.\n\nIn most cases, to enable logging in JSON in your Java logging framework it is enough to include the proper configuration. For example, let’s assume that we have the following log message included in our code:\n\nTo configure Log4J 2 to write log messages in JSON we would include the following configuration:\n\nThe result would look as follows:\n\nThe structure of your log events should be consistent. This is not only true within a single application or set of microservices, but should be applied across your whole application stack. With similarly structured logs it will be easier to look into them, compare them, correlate them, or simply store them in a dedicated data store. It is easier to look into data coming from your systems when you know they have common fields like severity and hostname, so you can easily slice and dice the data based on that information. For inspiration, have a look at Sematext Common Schema even if you are not a Sematext user.\n\nOf course, keeping the structure is not always possible because your full stack consists of externally developed servers, databases, search engines, queues, etc., each with its own set of logs and log formats. However, to keep your and your team’s sanity, minimize the number of different log message structures that you can control.\n\nOne way of keeping a common structure is to use the same pattern for your logs, at least the ones that use the same logging framework. For example, if your applications and microservices use Log4J 2 you could use a pattern like this:\n\nBy using a single or a very limited set of patterns you can be sure that the number of log formats will remain small and manageable.\n\nInformation context is important and for us developers and DevOps a log message is information. Look at the following log entry:\n\nWe know that an error appeared somewhere in the application. We don’t know where it happened, we don’t know what kind of error it was, we only know when it happened. Now look at a message with slightly more contextual information:\n\nThe same log record, but a lot more contextual information. We know the thread in which it happened, we know what class the error was generated at. We modified the message as well to include the user that the error happened for, so we can get back to the user if needed. We could also include additional information like diagnostic contexts. Think about what you need and include it.\n\nTo include context information you don’t have to do much when it comes to the code that is responsible for generating the log message. For example, the PatternLayout in Log4J 2 gives you all that you need to include context information. You can go with a very simple pattern like this:\n\nThat will result in a log message similar to the following one:\n\nBut you can also include a pattern that will include way more information:\n\nThat will result in a log message like this:\n\nThink about the environment your application is going to be running in. There is a difference in logging configuration when you are running your Java code in a VM or on a bare-metal machine, it is different when running it in a containerized environment, and of course, it is different when you run your Java or Kotlin code on an Android device.\n\nTo set up logging in a containerized environment you need to choose the approach you want to take. You can use one of the provided logging drivers – like the journald, logagent, Syslog, or JSON file. To do that, remember that your application shouldn’t write the log file to the container ephemeral storage, but to the standard output. That can be easily done by configuring your logging framework to write the log to the console. For example, with Log4J 2 you would just use the following appender configuration:\n\nYou can also completely omit the logging drivers and ship logs directly to your centralized logs solution like our Sematext Cloud:\n\n11. Don’t Log Too Much or Too Little\n\nAs developers we tend to think that everything might be important – we tend to mark each step of our algorithm or business code as important. On the other hand, we sometimes do the opposite – we don’t add logging where we should or we log only FATAL and ERROR log levels. Both approaches will not do very well. When writing your code and adding logging, think about what will be important to see if the application is working properly and what will be important to be able to diagnose a wrong application state and fix it. Use this as your guiding light to decide what and where to log. Keep in mind that adding too many logs will end up in information fatigue and not having enough information will result in the inability to troubleshoot.\n\n12. Keep the Audience in Mind\n\nIn most cases, you will not be the only person looking at the logs. Always remember that. There are multiple actors that may be looking at the logs.\n\nThe developer may be looking at the logs for troubleshooting or during debugging sessions. For such people, logs can be detailed, technical, and include very deep information related to how the system is running. Such a person will also have access to the code or will even know the code and you can assume that.\n\nThen there are DevOps. For them, log events will be needed for troubleshooting and should include information helpful in diagnostics. You can assume the knowledge of the system, its architecture, its components, and the configuration of the components, but you should not assume the knowledge about the code of the platform.\n\nFinally, your application logs may be read by your users themselves. In such a case, the logs should be descriptive enough to help fix the issue if that is even possible or give enough information to the support team helping the user. For example, using Sematext for monitoring involves installing and running a monitoring agent. If you are behind a very restrictive firewall and the agent cannot ship metrics to Sematext, it logs errors aimed that Sematext users themselves can look at, too.\n\nWe could go further and identify even more actors who might be looking into logs, but this shortlist should give you a glimpse into what you should think about when writing your log messages.\n\nSensitive information shouldn’t be present in logs or should be masked. Passwords, credit card numbers, social security numbers, access tokens, and so on – all of that may be dangerous if leaked or accessed by those who shouldn’t see that. There are two things you ought to consider.\n\nThink whether sensitive information is truly essential for troubleshooting. Maybe instead of a credit card number, it is enough to keep the information about the transaction identifier and the date of the transaction? Maybe it is not necessary to keep the social security number in the logs when you can easily store the user identifier. Think about such situations, think about the data that you store, and only write sensitive data when it is really necessary.\n\nThe second thing is shipping logs with sensitive information to a hosted logs service. There are very few exceptions where the following advice should not be followed. If your logs have and need to have sensitive information stored, mask or remove them before sending them to your centralized logs store. Most popular log shippers, like our own Logagent, include functionality that allows removal or masking of sensitive data.\n\nFinally, the masking of sensitive information can be done in the logging framework itself. Let’s look at how it can be done by extending Log4j 2. Our code that produces log events looks as follows (full example can be found at Sematext Github):\n\nIf you were to run the whole example from Github the output would be as follows:\n\nYou can see that the credit card number was masked. This was done because we added a custom Converter that checks if the given Marker is passed along the log event and tries to replace a defined pattern. The implementation of such Converter looks as follows:\n\nIt is very simple and could be written in a more optimized way and should also handle all the possible credit cards number formats, but it is enough for this purpose.\n\nBefore jumping into the code explanation I would also like to show you the log4j2.xml configuration file for this example:\n\nAs you can see, we’ve added the packages attribute in our Configuration to tell the framework where to look for our converter. Then we’ve used the %sc pattern to provide the log message. We do that because we can’t overwrite the default %m pattern. Once Log4j2 finds our %sc pattern it will use our converter which takes the formatted message of the log event and uses a simple regex and replaces the data if it was found. As simple as that.\n\nOne thing to notice here is that we are using the Marker functionality. Regex matching is expensive and we don’t want to do that for every log message. That’s why we mark the log events that should be processed with the created Marker, so only the marked ones are checked.\n\nWith the complexity of the applications, the volume of your logs will grow, too. You may get away with logging to a file and only using logs when troubleshooting is needed, but when the amount of data grows it quickly becomes difficult and slow to troubleshoot this way When this happens, consider using a log management solution to centralize and monitor your logs. You can either go for an in-house solution based on the open-source software, like Elastic Stack or use one of the log management tools available on the market like Sematext Logs.\n\nA fully managed log aggregation tool will give you the freedom of not needing to manage yet another, usually quite complex, part of your infrastructure. Instead, you will be able to focus on your application and will need to set up only log shipping. You may want to include logs like JVM garbage collection logs in your managed log solution. After turning them on for your applications and systems working on the JVM you will want to monitor logs and centralize them in a single place for log correlation, log analysis, and to help you tune the garbage collection in the JVM instances. Such logs correlated with metrics are an invaluable source of information for troubleshooting garbage collection-related problems.\n\nIf you’re interested to see how Sematext Logs stacks up against similar solutions, we wrote some in-depth reviews of the best log management software, log analysis tools, and cloud logging services but we recommend you jump right into the 14-day free trial to fully explore its features. Try it and see for yourself!\n\nOr, if you’d like a little more information on how Sematext Logs works, check out this short video below:\n\nIncorporating each and every good practice may not be easy to implement right away, especially for applications that are already live and working in production. But if you take the time and roll the suggestions out one after another you will start seeing an increase in the usefulness of your logs. For more tips on how to get the most out of your logs, we recommend you also go through our other article on logging best practices where we explain and ins and outs you should follow regardless of the type of app you’re working with. And remember that at Sematext we do help organizations with their logging setups by offering logging consulting, so reach out if you are having trouble and we will be happy to help."
    },
    {
        "link": "https://stackoverflow.com/questions/906233/logging-in-java-and-in-general-best-practices",
        "document": "For anylogger API, we have at leaset these Log Levels: ERROR > WARN > INFO > DEBUG > TRACE\n\nAnd we can use each log level to write different types of logs to achieve better understanding of our collected traces:\n\nTrace – It would be better if we write a trace in every method at entry point with method name and method argument as well as at exit point with return value/object,\n\nNote – It is better to follow our coding guidelines and write the methods modular, then in that case we don’t need to write multiple logs line in between the method to print the data.\n\nDebug – Debug log we will add in middle of method to show which if/else/switch condition got satisfied, also the data which we get it from DB and using it in the method and so on. Note –don’t add those data in debug which is being send as an argument or return as a value, since those data already getting printed by Trace level (try not to print same logs multiple times).\n\nInfo – Imagine client has log level info, so what message and all you want to show him if they see the log, so add those things in info. Example – Blabla connection created/deleted/modified successfully or Blabla link locked/Unlocked or blabla sync triggered for blabla node/nodes.\n\nWarn – It is rare condition but while writing the code we come across some condition which is not possible in normal case, it only come due to any stale entry or any breakage happens, normally we ignore this condition, but it would be better if we add such condition and add warring log there. Example – I was querying from one table with condition on column which is not primary key or unique but it was told that it will always return only one row so do , so in such case we should write one condition like if resultSet.size > 1 add some warning log with better messages.\n\nError – Error log should be present in every catch block which is not expected, and it should print complete stack trace properly (and not only the error message). Also in catch block people are throwing a new Exception without logging existing Exception trace, in such scenario we do not get the actual point of exception. So, writing Error log in every catch block with complete stack trace is very much mandatory."
    },
    {
        "link": "https://betterstack.com/community/guides/logging/how-to-start-logging-with-java",
        "document": "🔭 Want to centralize and monitor your Java logs?\n\nHead over to Logtail and start ingesting your logs in 5 minutes."
    },
    {
        "link": "https://loggly.com/ultimate-guide/java-logging-basics",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/1770442/java-custom-logger-logging-standards-or-and-best-practices",
        "document": "I would STRONGLY recommend that you use slf4j as your logging API, as it is designed to be able to switch backends at deployment time. In other words, if you ever outgrow your own logging framework or has to interface with others using something else, it is simple to change your mind.\n\nIt also allows you to use the {}-construction for easy inserting objects in your log strings without overhead if that string is not actually logged anyway (which is really nice).\n\nI'll suggest you consider adapting the \"Simple\" backend to your needs since it probably provides 90% of what you want.\n\nNote: Do not use any backend directly (like log4j or java.util.logging) as it will essentially lock your code to that backend. Use a facade."
    }
]