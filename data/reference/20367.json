[
    {
        "link": "https://spring.io/guides/gs/multi-module",
        "document": "This guide shows you how to create a multi-module project with Spring Boot. The project will have a library jar and a main application that uses the library. You could also use it to see how to build a library (that is, a jar file that is not an application) on its own.\n\nThis guide walks through building two projects, one of which is a dependency to the other. Consequently, you need to create two child projects under a root project. But first, create the build configuration at the top level. For Maven you will want a with listing the subdirectories: For Gradle, you will want a including the same directories: and (optionally) you could include an empty (to help IDEs identify the root directory). In the directory that you want to be your root directory, create the following subdirectory structure (for example, with on *nix systems): In the root of the project, you will need to set up a build system, and this guide shows you how to use Maven or Gradle.\n\nOne of the two projects serves as a library that the other project (the application) will use. In a the directory, create the following subdirectory structure (for example, by using on *nix systems): Now you need to configure a build tool (Maven or Gradle). In both cases, note that the Spring Boot plugin is not used in the library project at all. The main function of the plugin is to create an executable “über-jar”, which we neither need nor want for a library. Although the Spring Boot Maven plugin is not being used, you do want to take advantage of Spring Boot dependency management, so that is configured by using the from Spring Boot as a parent project. An alternative would be to import the dependency management as a Bill of Materials (BOM) in the section of the file. For the Library project, you need not add dependencies. The basic dependency provides everything you need. You can get a Maven build file with the necessary dependencies directly from the Spring Initializr. The following listing shows the file that is created when you choose Maven: You can get a Gradle build file with the necessary dependencies directly from the Spring Initializr. The following listing shows the file that is created when you choose Gradle: If you generated the Library project from it will contain a wrapper script for the build system ( or depending on the choice you made). You can move that script and its associated configuration up to the root directory: It is better that the library depends on the most narrowed dependencies, and not a starter. For our own use there has all the code that we need. Removing the of the existing entry makes sure the library doesn’t bring up too much dependencies. The Library project has no class with a main method (because it is not an application). Consequently, you have to tell the build system to not try to build an executable jar for the Library project. (By default, the Spring Initializr builds executable projects.) To tell Maven to not build an executable jar for the Library project, you must remove the following block from the created by the Spring Initializr: The following listing shows the final file for the Library project: To tell Gradle to not build an executable jar for the Library project, you must add the following blocks to the created by the Spring Initializr: The task tries to create an executable jar, and that requires a method. As a result, you need to disable it by disabling the the Spring Boot plugin, while keeping it for its dependency management features. Also, now that we have disabled the Spring Boot plugin, it no longer automatically configures the task to enable the option. This is important if you are using an expression that refers to a parameter name. The following enables this option: The following listing shows the final file for the Library project:\n\nYou will want to write unit tests for your library components. If you provide re-usable Spring configuration as part of the library, you might also want to write an integration test, to make sure that the configuration works. To do that, you can use JUnit and the annotation. The following listing (from ) shows how to do so: In the preceding listing, we have configured the for the test by using the default attribute of the annotation. We do not recommend putting in a library, because there might be a clash at runtime with the application that uses the library (only one is ever loaded from the classpath). You could put in the test classpath but not include it in the jar (for instance, by placing it in ).\n\nThe Application project uses the Library project, which offers a service that other projects can use. In the directory, create the following subdirectory structure (for example, with on *nix systems): Do not use the same package as the library (or a parent of the library package) unless you want to include all Spring components in the library by in the application. For the Application project, you need the Spring Web and Spring Boot Actuator dependencies. You can get a Maven build file with the necessary dependencies directly from the Spring Initializr. The following listing shows the file that is created when you choose Maven: You can get a Gradle build file with the necessary dependencies directly from the Spring Initializr. The following listing shows the file that is created when you choose Gradle: You can delete the and/or wrappers and their associated configuration files: The Application project needs to have a dependency on the Library project. You need to modify your Application build file accordingly. For Maven, add the following dependency: The following listing shows the finished file: For Gradle, add the following dependency: The following listing shows the finished file:\n\nThe main class in the application can be a that uses the from the library to render a message. The following listing (from ) shows such a class: is a convenience annotation that adds all of the following:\n• : Tags the class as a source of bean definitions for the application context.\n• : Tells Spring Boot to start adding beans based on classpath settings, other beans, and various property settings. For example, if is on the classpath, this annotation flags the application as a web application and activates key behaviors, such as setting up a .\n• : Tells Spring to look for other components, configurations, and services in the package, letting it find the controllers. The method uses Spring Boot’s method to launch an application. Did you notice that there was not a single line of XML? There is no file, either. This web application is 100% pure Java and you did not have to deal with configuring any plumbing or infrastructure. Because is inside a different package ( ) than ( ), cannot automatically detect it. There are different ways to let `MyService be picked up:\n• Fetch everything from its package by using .\n• Specifying the parent package by name: . (This guide uses this method) If your application also uses JPA or Spring Data, the and (and related) annotations inherit only their base package from when not explicitly specified. That is, once you specify or , you might also have to also explicitly use and with their package scans explicitly configured.\n\nTest the end-to-end result by starting the application. You can start the application in your IDE or use the command line. Once the application is running, visit the client application in the browser, at . There, you should see reflected in the response. If you use Gradle, the following command (really two commands run in sequence) will first build the library and then run the application: If you use Maven, the following command (really two commands run in sequence) will first build the library and then run the application:"
    },
    {
        "link": "https://stackoverflow.com/questions/63846115/overriden-application-yml-in-multi-module-spring-boot-app",
        "document": "There is a Spring Boot 2 app with such a structure:\n\nAlso, module-1 depends on module-2, specified in pom.xml section.\n\nThe problem is that when I specify some properties in module-2's - they are not visible in main module-1's components (via annotation).\n\nAs was answered here seems like module-1's overrides module-2's . There is a workaround - if I use name in module-2 everything works fine, but I'm going to add more modules and, finally, it's dirty hack.\n\nWhat I'm doing wrong? Should such an hierarchy of property files specified somehow? I will be happy to provide more details if it's needed."
    },
    {
        "link": "https://stackoverflow.com/questions/23138494/spring-boot-application-properties-maven-multi-module-projects",
        "document": "We are using spring boot in a multi-module project.\n\nWe have a Domain access module which has the common domain object classes, repositories, together with configuration for the datasource, JPA, Hibernate, etc. These are configured using a application.properties. We put all this configuration into the common module to save duplicating these common configurations in the higher level modules.\n\nThis all works fine when building the domain module, so the configurations are loaded correctly in the test units.\n\nHowever the problems start when we try to use the domain module in the higher layer modules; they have their own application.properties which means Spring loads them and not the the Domain module application.properties, which this means the data source is not configured because only the higher module application.properties are loaded.\n\nWhat we would like is both the domain module and higher level application properties to be loaded by Spring. But we can't see any easy way to do this.\n\nI'm thinking this must be a common problem, and wonder if there any recommended solutions for this problem?\n\nAs we are using spring-boot the solution should ideally use annotations instead of applictionContext.xml."
    },
    {
        "link": "https://baeldung.com/spring-boot-load-multiple-yaml-configuration-files",
        "document": "When designing a Spring Boot application, we typically want to use external configuration to define our application properties. This lets us use the same code across different environments. In some cases, we may want to have our properties defined across multiple YAML configuration files even for the same environment.\n\nIn this tutorial, we’ll learn two ways to load multiple YAML configuration files when creating a Spring Boot application.\n\nOne way to include multiple YAML configuration files in an application is by using Spring profiles.\n\nThis approach takes advantage of Spring’s autoloading of YAML configuration files associated with an application profile.\n\nNext, let’s walk through an example with two .yml files.\n\nOur first file lists students. We’ll name it application-students.yml and place it in our ./src/main/resources directory:\n\nLet’s name our second file application-teachers.yml and place in the same ./src/main/resources directory:\n\nNow, let’s set up our example application. We’ll use the CommandLineRunner in our application to see our properties loading:\n\nIn this example, we set our additional Spring profiles programmatically with the setAdditionalProfiles() method.\n\nWe could also use the spring.profiles.include parameter in a general application.yml file:\n\nEither method can set the profiles, and during application startup, Spring loads any YAML configuration file following the pattern application-{profile}.yml.\n\nTo finish our example, let’s create our configuration class. This loads the properties from the YAML files:\n\nLet’s check the logs after running our application:\n\nWhile this method works, a drawback is that it uses the Spring profiles functionality in a way that is most likely not intended by the implementation.\n\nGiven that, let’s look at a second, more robust method to include multiple YAML files.\n\nWe can specify multiple YAML configuration files via the @PropertySources annotation combined with using @PropertySource to load YAML.\n\nLet’s try again with a similar application:\n\nWe should note that, in this example, we’re not setting Spring profiles.\n\nThe @PropertySources annotation includes an @PropertySource for each YAML file we want to use in our application. The factory is a custom PropertySourceFactory that enables loading a YAML file:\n\nRunning our MultipleYamlApplication, we see our expected outputs:\n\nIn this article, we looked at two possible ways to load multiple YAML configuration files in a Spring Boot application."
    },
    {
        "link": "https://brightinventions.pl/blog/managing-spring-boot-properties-after-version-2-4",
        "document": "Managing Spring Boot properties in multi-module application could be quite intimidating. In this post, we take a look how Spring Boot will resolve properties conflicts and how to make our build more consistent. Changes introduced in version 2.4 are going to help us. Let's review how to take advantage of new features and incorporate them into the project.\n\nTo better understand what version 2.4 brings we need to take a step back and remind ourselves how things used to work before 2.4 release.\n\nLet's take this basic example. We could try to define the same value twice in a single file. Like this:\n\nBut this will fail, and the application will crash at the boot. You can't override properties in the same file. But it's more than fine to just create another property file (with a different format):\n\nIn this case, the system will pick up since values from files have higher priority over values from files. The full hierarchy of values looks like this: (starting from lowest to highest priorities)\n\nWith that out of the way let's step up a notch and see how we could manage properties in a multi-module application. To work on something real, let's assume our app contains 3 modules: main one, and . The tree structure of that project would look like this:\n\nNow if we define the same property in all three files which version is going to be picked up? Well... we could predict that is going to be the one from the main module and that would be correct. What if we remove the main file? Then Spring Boot will pick up the value from one of the two remaining files. Which one? It's non-deterministic. Let's avoid situations like this altogether. Any ambiguity is a potential risk hazard. And this is one is especially harmful since we might find out about our mistake when the app goes into production.\n\nContrary to what some people might assume, Spring Boot will not merge all tree config files from all the modules into a single file. Only one version of the file will be used and the rest would be thrown away.\n\nOne easy way out would be to define all properties in a single . Not even creating dedicated yaml files per module. But we have those modules for a reason, most likely our intention was to keep all the logic encapsulated. So why we should spread module-specific properties outside? It makes no sense.\n\nBefore Spring Boot 2.4, we could have handled this problem by using . However, after 2.4 release this feature is no longer present. Reasons for the deprecation are described in detail in the blog post. The short version is - this feature yield non-deterministic results. With that option out of the way, what's the alternative?\n\nWhat could be done after Spring Boot 2.4\n\nSpring Boot 2.4 introduced which is much more predictable. The idea of that property is simple: we just point to the other sources that we would like to use in the final config file. Let's see how we could use this new feature in the multi-module application.\n\nIn the main file we are loading additional configs files specific to the modules present in the app. Let's create those files. With those changes our source tree should look like this:\n\nIn the module dedicated files: and we can now place configuration specific to the module and that module alone.\n\nEven if we are using file only for the module-specific/ custom properties it's still possible to override global properties inside that file. For instance, if we set app port inside that value might override the property from the main . That could be confusing and breaks the original intention of profile-specific configuration. To make things neat and tidy let's prefix all properties with a custom namespace unique only to that module. For instance, all properties inside have to start with .\n\nTo sum it up: Keep all the generic configurations inside the main and only module-specific properties inside the module-specific files, only under module unique namespace.\n\nHow does it work with custom profiles?\n\nThey still work as expected! Meaning, if we create file alongside values from that file are going to be used to override properties from the base file. Neat! No additional changes are required to make it work!\n\nHow does it work with integration tests?\n\nIf the test configuration is simple enough it's fine to just place it inside module-specific , for instance:\n\nIf the configuration is more extensive and it doesn't feel right to have it copy-pasted all over every test configuration file, plus the configuration doesn't have to change from module to module, we can apply the same trick as before. By importing shared configuration file inside :\n\nPlease notice that is inside not directory!"
    },
    {
        "link": "https://docs.spring.io/spring-boot/reference/features/profiles.html",
        "document": "Spring Profiles provide a way to segregate parts of your application configuration and make it be available only in certain environments. Any , or can be marked with to limit when it is loaded, as shown in the following example: If beans are registered through instead of automatic scanning, the annotation needs to be specified on the class that has the annotation. In the case where are scanned, can be specified on the class itself. You can use a property to specify which profiles are active. You can specify the property in any of the ways described earlier in this chapter. For example, you could include it in your , as shown in the following example: You could also specify it on the command line by using the following switch: . If no profile is active, a default profile is enabled. The name of the default profile is and it can be tuned using the property, as shown in the following example: and can only be used in non-profile-specific documents. This means they cannot be included in profile specific files or documents activated by . For example, the second document configuration is invalid: # this document is valid spring: profiles: active: \"prod\" --- # this document is invalid spring: config: activate: on-profile: \"prod\" profiles: active: \"metrics\"\n\nThe property follows the same ordering rules as other properties: The highest wins. This means that you can specify active profiles in and then replace them by using the command line switch. Sometimes, it is useful to have properties that add to the active profiles rather than replace them. The property can be used to add active profiles on top of those activated by the property. The entry point also has a Java API for setting additional profiles. See the method in . For example, when an application with the following properties is run, the common and local profiles will be activated even when it runs using the switch: Similar to , can only be used in non-profile-specific documents. This means it cannot be included in profile specific files or documents activated by . Profile groups, which are described in the next section can also be used to add active profiles if a given profile is active.\n\nOccasionally the profiles that you define and use in your application are too fine-grained and become cumbersome to use. For example, you might have and profiles that you use to enable database and messaging features independently. To help with this, Spring Boot lets you define profile groups. A profile group allows you to define a logical name for a related group of profiles. For example, we can create a group that consists of our and profiles. Our application can now be started using to activate the , and profiles in one hit. Similar to and , can only be used in non-profile-specific documents. This means it cannot be included in profile specific files or documents activated by ."
    },
    {
        "link": "https://stackoverflow.com/questions/47368086/spring-spring-profiles-include-overrides",
        "document": "My intention is to have two profiles in a Spring Boot application - development and production one. Development profile is meant just to override some variables of production profile (like in-memory database instead of database in the cloud). As I expect some changes to be done to production profile in the future, duplicating variables in development profile doesn't seem to be a solution.\n\nSo, in Spring Reference I read that is supposed to only add properties from referenced profile.\n\nHowever, from what I've checked it rather overrides it. So, when having two profiles foo and bar, in separate yaml files:\n\nAnd setting variable in IDE, the runtime value of is 44. That means that , is overriden with which was supposed to only add properties, but not to override them. When starting the application, I get:\n\nI added to as suggested by this answer, in another question, but it has no effect - there is no difference when property is there or not (I also tried using dash listing instead of comma separated values).\n\nMy question is, is it how it is supposed to work (then Spring Reference is misleading)? If so, are there any solutions for that?\n\nAdding a link to the application source code on a GitHub."
    },
    {
        "link": "https://stackoverflow.com/questions/68837706/how-to-integrate-spring-profiles-in-spring-boot-2-4-application-properties",
        "document": "My current spring boot 2.3 and below config files are\n\nI have to include the profile in my profile and I have to include in all other profiles.\n\nFor spring boot 2.4+, I found that putting the below in my file works:\n\nMy question is, is there a better/cleaner way?"
    },
    {
        "link": "https://medium.com/@elouadinouhaila566/using-spring-profiles-profile-for-environment-specific-configurations-bb4b52e84d4c",
        "document": "Spring Profiles is a powerful feature in the Spring Framework that allows developers to manage and organize different configurations for various environments such as development, testing, and production. Profiles help you enable or disable beans, configurations, and properties based on the currently active environment. This ensures that your application behaves differently (and correctly) based on the environment it is running in.\n\nSpring Profiles allow you to define separate configurations for different environments. You can specify which profile is active at runtime, and Spring will load the appropriate beans and configurations based on that active profile. For instance, you can have a set of beans configured for the development environment and another set for production, and Spring will automatically select the correct one.\n\nHow to Use Spring Profiles You can use the annotation on Spring components (e.g., , , ) to specify that those beans should only be created when a specific profile is active. Example: Suppose you have two different data sources — one for development and one for production. In this example, Spring will load either the development or production data source configuration based on the active profile.\n\nYou can activate a profile using several methods, depending on your deployment strategy: Via or : You can activate a profile in your configuration file by setting the property. Via Command Line Arguments: When running your application, you can pass the active profile as a command-line argument: Via Environment Variables: You can also activate profiles using environment variables: Programmatically: You can activate a profile programmatically using the class in your main method:\n\nIn addition to using the annotation, Spring Boot supports profile-specific configuration files, which are automatically loaded based on the active profile. You can have different configuration files for different environments. Spring will load these files based on the active profile. If the profile is active, will be loaded in addition to the main file. Spring Boot automatically merges the profile-specific configurations with the main configuration, allowing for a clean and environment-specific setup.\n\nOne of the most useful aspects of Spring Profiles is the ability to conditionally create beans based on the active profile. This is especially useful for managing environment-specific services, security configurations, or data sources. Spring will automatically choose the correct implementation of based on the active profile, ensuring that you have different behaviors in different environments.\n\nSpring also supports multi-profile activation, which means you can activate multiple profiles simultaneously by separating them with commas. In this case, Spring will activate both the and profiles, allowing you to load configurations and beans from both profiles at the same time.\n\nIf no profile is explicitly activated, Spring will use the default profile. You can define configurations that apply to all environments unless a specific profile overrides them. Beans and configurations without a annotation will be loaded in all profiles. This bean will be loaded regardless of the active profile unless another bean of the same type is loaded by a specific profile."
    },
    {
        "link": "https://master-spring-ter.medium.com/mastering-spring-boot-profiles-a-deep-dive-into-environment-specific-configuration-66e406593807",
        "document": "Spring Boot is renowned for its simplicity and powerful features, and one of its most valuable features is the concept of profiles. Profiles allow you to define environment-specific configurations, enabling your application to adapt seamlessly to different environments like development, testing, and production. In this article, we’ll explore how to effectively use Spring Boot profiles to manage your application’s configuration and enhance its flexibility.\n\nSpring Boot profiles provide a way to segregate parts of your application configuration and make it available only in certain environments. This is particularly useful when you have different settings for various environments, such as database URLs, logging levels, or API keys.\n\nTo get started with profiles, you need to define different configuration files for each environment. Spring Boot uses a simple naming convention: or .\n\nIn the file, the property specifies which profile is currently active. You can change this value to switch between environments.\n\nSpring Boot also allows you to conditionally load beans based on the active profile using the annotation. This can be particularly useful for defining beans that should only be available in certain environments.\n\nIn this example, the bean will only be loaded if the profile is active, and the bean will only be loaded if the profile is active.\n\nYou can switch profiles without changing the configuration file by passing a JVM argument when running your application.\n\nThis approach is useful for deployment scripts and CI/CD pipelines where you need to control the active profile dynamically.\n\nSpring Boot also supports YAML for defining profiles, which can make managing complex configurations easier. Here’s how you can define multiple profiles in a single YAML file.\n\nExample: Using YAML for Profile Configuration\n\nIn this example, the YAML file is divided into sections using , where each section defines settings for a specific profile. The property is used to specify the profile to which the configuration belongs.\n\nSpring Boot profiles provide a powerful way to manage environment-specific configurations, making your application more flexible and easier to maintain. By leveraging profiles, you can ensure that your application behaves correctly in different environments without the need for manual configuration changes.\n\nEmbrace the power of Spring Boot profiles to streamline your development process and create robust, environment-aware applications. Happy coding!\n\nThis tutorial was generated using ChatGPT, specifically the Master Spring TER model. For more information, visit ChatGPT Master Spring TER."
    }
]