[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.string.substring?view=net-9.0",
        "document": "A string that is equivalent to the substring that begins at in this instance, or Empty if is equal to the length of this instance.\n\nThe following example demonstrates obtaining a substring from a string.\n\nThe following example uses the Substring method to separate key/value pairs that are delimited by an equals ( ) character.\n\nThe IndexOf method is used to get the position of the equals character in the string. The call to the Substring(Int32, Int32) method extracts the key name, which starts from the first character in the string and extends for the number of characters returned by the call to the IndexOf method. The call to the Substring(Int32) method then extracts the value assigned to the key. It starts at one character position beyond the equals character and extends to the end of the string.\n\nYou call the Substring(Int32) method to extract a substring from a string that begins at a specified character position and ends at the end of the string. The starting character position is zero-based; in other words, the first character in the string is at index 0, not index 1. To extract a substring that begins at a specified character position and ends before the end of the string, call the Substring(Int32, Int32) method.\n\nTo extract a substring that begins with a particular character or character sequence, call a method such as IndexOf or IndexOf to get the value of . The second example illustrates this; it extracts a key value that begins one character position after the character.\n\nIf is equal to zero, the method returns the original string unchanged."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/strings",
        "document": "A string is an object of type String whose value is text. Internally, the text is stored as a sequential read-only collection of Char objects. The Length property of a string represents the number of objects it contains, not the number of Unicode characters. To access the individual Unicode code points in a string, use the StringInfo object.\n\nIn C#, the keyword is an alias for String; therefore, and are equivalent. Use the provided alias as it works even without . The class provides many methods for safely creating, manipulating, and comparing strings. In addition, the C# language overloads some operators to simplify common string operations. For more information about the keyword, see string. For more information about the type and its methods, see String.\n\nYou can declare and initialize strings in various ways, as shown in the following example:\n\nYou don't use the new operator to create a string object except when initializing the string with an array of chars.\n\nInitialize a string with the Empty constant value to create a new String object whose string is of zero length. The string literal representation of a zero-length string is . By initializing strings with the Empty value instead of null, you can reduce the chances of a NullReferenceException occurring. Use the static IsNullOrEmpty(String) method to verify the value of a string before you try to access it.\n\nString objects are immutable: they can't be changed after they're created. All of the String methods and C# operators that appear to modify a string actually return the results in a new string object. In the following example, when the contents of and are concatenated to form a single string, the two original strings are unmodified. The operator creates a new string that contains the combined contents. That new object is assigned to the variable , and the original object that was assigned to is released for garbage collection because no other variable holds a reference to it.\n\nBecause a string \"modification\" is actually a new string creation, you must use caution when you create references to strings. If you create a reference to a string, and then \"modify\" the original string, the reference continues to point to the original object instead of the new object that was created when the string was modified. The following code illustrates this behavior:\n\nFor more information about how to create new strings that are based on modifications such as search and replace operations on the original string, see How to modify string contents.\n\nQuoted string literals start and end with a single double quote character ( ) on the same line. Quoted string literals are best suited for strings that fit on a single line and don't include any escape sequences. A quoted string literal must embed escape characters, as shown in the following example:\n\nVerbatim string literals are more convenient for multi-line strings, strings that contain backslash characters, or embedded double quotes. Verbatim strings preserve new line characters as part of the string text. Use double quotation marks to embed a quotation mark inside a verbatim string. The following example shows some common uses for verbatim strings:\n\nBeginning with C# 11, you can use raw string literals to more easily create strings that are multi-line, or use any characters requiring escape sequences. Raw string literals remove the need to ever use escape sequences. You can write the string, including whitespace formatting, how you want it to appear in output. A raw string literal:\n• Starts and ends with a sequence of at least three double quote characters ( ). You can use more than three consecutive characters to start and end the sequence to support string literals that contain three (or more) repeated quote characters.\n• Single line raw string literals require the opening and closing quote characters on the same line.\n• Multi-line raw string literals require both opening and closing quote characters on their own line.\n• In multi-line raw string literals, any whitespace to the left of the closing quotes is removed from all lines of the raw string literal.\n• In multi-line raw string literals, whitespace following the opening quote on the same line is ignored.\n• In multi-line raw string literals, whitespace only lines following the opening quote are included in the string literal.\n\nThe following examples demonstrate these rules:\n\nThe following examples demonstrate the compiler errors reported based on these rules:\n\nThe first two examples are invalid because multiline raw string literals require the opening and closing quote sequence on its own line. The third example is invalid because the text is outdented from the closing quote sequence.\n\nYou should consider raw string literals when you're generating text that includes characters that require escape sequences when using quoted string literals or verbatim string literals. Raw string literals are easier for you and others to read because it more closely resembles the output text. For example, consider the following code that includes a string of formatted JSON:\n\nA format string is a string whose contents are determined dynamically at run time. Format strings are created by embedding interpolated expressions or placeholders inside of braces within a string. Everything inside the braces ( ) is resolved to a value and output as a formatted string at run time. There are two methods to create format strings: string interpolation and composite formatting.\n\nYou declare Interpolated strings with the special character. An interpolated string includes interpolated expressions in braces. If you're new to string interpolation, see the String interpolation - C# interactive tutorial for a quick overview.\n\nUse string interpolation to improve the readability and maintainability of your code. String interpolation achieves the same results as the method, but improves ease of use and inline clarity.\n\nYou can use string interpolation to initialize a constant string when all the expressions used for placeholders are also constant strings.\n\nBeginning with C# 11, you can combine raw string literals with string interpolations. You start and end the format string with three or more successive double quotes. If your output string should contain the or character, you can use extra characters to specify how many and characters start and end an interpolation. Any sequence of fewer or characters is included in the output. The following example shows how you can use that feature to display the distance of a point from the origin, and place the point inside braces:\n\nC# also allows verbatim string interpolation, for example across multiple lines, using the or syntax.\n\nTo interpret escape sequences literally, use a verbatim string literal. An interpolated verbatim string starts with the character followed by the character. You can use the and tokens in any order: both and are valid interpolated verbatim strings.\n\nThe String.Format utilizes placeholders in braces to create a format string. This example results in similar output to the string interpolation method used in the preceding sample.\n\nFor more information on formatting .NET types, see Formatting Types in .NET.\n\nA substring is any sequence of characters that is contained in a string. Use the Substring method to create a new string from a part of the original string. You can search for one or more occurrences of a substring by using the IndexOf method. Use the Replace method to replace all occurrences of a specified substring with a new string. Like the Substring method, Replace actually returns a new string and doesn't modify the original string. For more information, see How to search strings and How to modify string contents.\n\nYou can use array notation with an index value to acquire read-only access to individual characters, as in the following example:\n\nIf the String methods don't provide the functionality that you must have to modify individual characters in a string, you can use a StringBuilder object to modify the individual chars \"in-place,\" and then create a new string to store the results by using the StringBuilder methods. In the following example, assume that you must modify the original string in a particular way and then store the results for future use:\n\nAn empty string is an instance of a System.String object that contains zero characters. Empty strings are used often in various programming scenarios to represent a blank text field. You can call methods on empty strings because they're valid System.String objects. Empty strings are initialized as follows:\n\nBy contrast, a null string doesn't refer to an instance of a System.String object and any attempt to call a method on a null string causes a NullReferenceException. However, you can use null strings in concatenation and comparison operations with other strings. The following examples illustrate some cases in which a reference to a null string does and doesn't cause an exception to be thrown:\n\nString operations in .NET are highly optimized and in most cases don't significantly impact performance. However, in some scenarios such as tight loops that are executing many hundreds or thousands of times, string operations can affect performance. The StringBuilder class creates a string buffer that offers better performance if your program performs many string manipulations. The StringBuilder string also enables you to reassign individual characters, something the built-in string data type doesn't support. This code, for example, changes the content of a string without creating a new string:\n\nIn this example, a StringBuilder object is used to create a string from a set of numeric types:\n\nBecause the String type implements IEnumerable<T>, you can use the extension methods defined in the Enumerable class on strings. To avoid visual clutter, these methods are excluded from IntelliSense for the String type, but they're available nevertheless. You can also use LINQ query expressions on strings. For more information, see LINQ and Strings.\n• How to modify string contents: Illustrates techniques to transform strings and modify the contents of strings.\n• How to compare strings: Shows how to perform ordinal and culture specific comparisons of strings.\n• How to concatenate multiple strings: Demonstrates various ways to join multiple strings into one.\n• How to parse strings using String.Split: Contains code examples that illustrate how to use the String.Split method to parse strings.\n• How to search strings: Explains how to use search for specific text or patterns in strings.\n• How to determine whether a string represents a numeric value: Shows how to safely parse a string to see whether it has a valid numeric value.\n• String interpolation: Describes the string interpolation feature that provides a convenient syntax to format strings.\n• Basic String Operations: Provides links to articles that use System.String and System.Text.StringBuilder methods to perform basic string operations.\n• Parsing Strings: Describes how to convert string representations of .NET base types to instances of the corresponding types.\n• Parsing Date and Time Strings in .NET: Shows how to convert a string such as \"01/24/2008\" to a System.DateTime object.\n• Comparing Strings: Includes information about how to compare strings and provides examples in C# and Visual Basic.\n• Using the StringBuilder Class: Describes how to create and modify dynamic string objects by using the StringBuilder class.\n• LINQ and Strings: Provides information about how to perform various string operations by using LINQ queries."
    },
    {
        "link": "https://ironpdf.com/blog/net-help/csharp-substring",
        "document": "Test in production without watermarks.\n\nWorks wherever you need it to."
    },
    {
        "link": "https://geeksforgeeks.org/c-sharp-substring-method",
        "document": "In C#, Substring() is a string method. It is used to retrieve a substring from the current instance of the string. This method can be overloaded by passing the different number of parameters to it as follows:\n\nThis method is used to retrieves a substring from the current instance of the string. The parameter “startIndex” will specify the starting position of substring and then substring will continue to the end of the string.\n• Parameter: This method accept one parameter “startIndex”. This parameter will specify the starting position of the substring which has to be retrieve. The type of this parameter is System.Int32.\n• Return Value: This method will return the substring which begins from startIndex and continues to the end of the string. The return value type is System.String.\n\nException: If startIndex is less than zero or greater than the length of current instance then it will arise ArgumentOutOfRangeException.\n\nThis method is used to extract a substring that begins from specified position describe by parameter startIndex and has a specified length. If startIndex is equal to the length of string and parameter length is zero, then it will return nothing substring.\n• Parameter: This method accept two parameters “startIndex” and length. First parameter will specify the starting position of the substring which has to be retrieve and second parameter will specify the length of the substring. The type of both the parameters is System.Int32.\n• Return Value: This method will return the substring which begins from specified position and substring will have a specified length. The return value type is System.String.\n\nException: This method can arise ArgumentOutOfRangeException in two conditions:\n• if the parameters startIndex or length is less than zero.\n• If startIndex + length indicates a position which is not within current instance."
    },
    {
        "link": "https://stackoverflow.com/questions/9468950/cut-a-string-with-a-known-start-end-index",
        "document": "If points to the last character that you want to have included in the extracted substring:\n\nIf points to the first character following the desired substring (i.e. to the start of the remaining text):\n\nSee String.Substring Method (Int32, Int32) for the official description on Microsoft Docs.\n\nSince C# 8.0, in .NET Core and .NET 5+ only, you can use Indices and ranges\n\nwhere the position at endIndex is excluded. This corresponds to my second example with where points to the first character following the desired substring (i.e. to the start of the remaining text).\n\nIf is intended to point to the last character that you want to have included, just add one to :"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/how-to/search-strings",
        "document": "You can use two main strategies to search for text in strings. Methods of the String class search for specific text. Regular expressions search for patterns in text.\n\nThe string type, which is an alias for the System.String class, provides many useful methods for searching the contents of a string. Among them are Contains, StartsWith, EndsWith, IndexOf, LastIndexOf. The System.Text.RegularExpressions.Regex class provides a rich vocabulary to search for patterns in text. In this article, you learn these techniques and how to choose the best method for your needs.\n\nThe String.Contains, String.StartsWith, and String.EndsWith methods search a string for specific text. The following example shows each of these methods and a variation that uses a case-insensitive search:\n\nThe preceding example demonstrates an important point for using these methods. Searches are case-sensitive by default. You use the StringComparison.CurrentCultureIgnoreCase enumeration value to specify a case-insensitive search.\n\nWhere does the sought text occur in a string?\n\nThe IndexOf and LastIndexOf methods also search for text in strings. These methods return the location of the text being sought. If the text isn't found, they return . The following example shows a search for the first and last occurrence of the word \"methods\" and displays the text in between.\n\nThe System.Text.RegularExpressions.Regex class can be used to search strings. These searches can range in complexity from simple to complicated text patterns.\n\nThe following code example searches for the word \"the\" or \"their\" in a sentence, ignoring case. The static method Regex.IsMatch performs the search. You give it the string to search and a search pattern. In this case, a third argument specifies case-insensitive search. For more information, see System.Text.RegularExpressions.RegexOptions.\n\nThe search pattern describes the text you search for. The following table describes each element of the search pattern. (The following table uses the single , which must be escaped as in a C# string).\n\nThe following code uses regular expressions to validate the format of each string in an array. The validation requires that each string is formatted as a telephone number: three groups of digits separated by dashes where the first two groups contain three digits and the third group contains four digits. The search pattern uses the regular expression . For more information, see Regular Expression Language - Quick Reference.\n\nThis single search pattern matches many valid strings. Regular expressions are better to search for or validate against a pattern, rather than a single text string.\n• Best practices for using strings in .NET"
    },
    {
        "link": "https://stevejgordon.co.uk/string-manipulation-in-csharp-best-practices",
        "document": "Last week my sixth Pluralsight course, “String Manipulation in C#: Best Practices” was released. This new course dives into creating, modifying, searching and parsing strings in .NET. Strings are one of the most used types in .NET applications and In this course, you’ll uncover everything you need to know about strings to use them effectively in your applications.\n\nThe course is designed to provide useful content to developers of all levels. Beginners of C# will learn the fundamentals of using the string and char types. More experienced developers will learn about key implementation details and advanced string manipulation techniques. Along the way, I explain the current best practices for each area of string manipulation so that viewers can easily apply them in their projects.\n\nThis module serves as an introduction to the string and char types in .NET. This is crucial content for new .NET developers but includes implementation details which I expect will be interesting and useful to all developers. I cover the important concept of immutability which is extremely important to understand when manipulating strings. The demos in this module show how strings and chars can be initialised.\n\nOnce you begin using strings in your applications, comparing them will be an extremely common operation. This module describes the conceptual differences between comparison and equality in .NET types and demonstrates how to apply both in practice. When you are interested in determining equality or sort order, this content will help you apply the best practices to your operations. I also discuss the key role that culture plays when comparing strings.\n\nAnother extremely common operation, once you use strings in .NET, is searching within those strings for partial or complete matches. This module describes some of the most useful techniques and considerations that you should apply when searching strings. It covers finding content within strings, locating the position of the content and applying regular expressions to match patterns within strings. For advanced developers, it touches on how the new Span type in .NET can be used to search within string data efficiently.\n\nIt’s often useful to format values from types representing data such as numbers and dates into their string representation. This often happens when persisting and logging data. This module describes techniques for formatting the common types, including how to control the way that the data is represented.\n\nOnce you have strings in your applications, you will frequently need to combine them for output and persistence. In this module, I demonstrate techniques for joining, concatenating and formatting strings. Viewers will learn how to use composite formatting and to control the final structure of the produced strings. I also demonstrate how to use interpolated strings as a very convenient way to format simple string data.\n\nBuilding on the topics from the previous module, the clips in this module focus on how developers can be more efficient when manipulating strings, avoiding the potential pitfalls that string immutability introduces. The primary focus will be learning about the StringBuilder type, demonstrating its use and explaining how it works. Later, the demos show some advanced low and zero overhead techniques for manipulating strings, benchmarking them to compare the performance gains they can offer.\n• When to Use StringBuilder\n\nThis module focuses on modifying strings with techniques for splitting strings, extracting substring, and dealing with case and whitespace. The demos include examples of how regular expressions can assist with more complex matching requirements.\n\nEarlier in the course, we learned how to format .NET types such as numerics and dates into their string representations. This module describes techniques for reversing this operation to parse instances of these types from string data. It discusses the important role that culture plays in such operations and how to control how data is interpreted during parsing.\n\nThe final module in the course expands on the topic of encoding and how it affects the way that characters are represented. We learn about the Unicode standard and how its code points are represented in .NET, including how larger code points representing emojis are supported through surrogate pairs. The demos show how string data can be encoded into different forms for transmission over networks. The module concludes by explaining advanced concepts such as runes and grapheme clusters.\n\nIn all, the course is 3 hours and 24 minutes in length, split over 10 modules for easy bitesize viewing. It took me over 180 hours to research, script, record and edit the final content. Strings are a core concept in .NET, which all developers must master. This course will teach you everything you need to know about the best practices for working with strings using C#.\n\nI really hope that many developers find it helpful in their day-to-day work and that the distilled best practices help improve their code. Please let me know how you get on with the course. You can watch the course today with your Pluralsight subscription.\n\nIf you haven’t already, you can check out my previous courses:\n• Using Configuration and Options in .NET Core and ASP.NET Core Apps\n\nOf course, you can also follow me directly on Pluralsight to get notified when I release new content."
    },
    {
        "link": "https://stackoverflow.com/questions/12113044/better-option-for-string-manipulation-net",
        "document": "For \"huge\" strings, it may make sense to take a streamed approach and not load the whole thing into memory. For the best raw performance, you can sometimes squeeze a little more speed out by using pointer math to search and capture pieces of strings.\n\nTo be clear, I'm stating two completely different approaches.\n\n1 - Stream\n\n The OP doesn't say how big these strings are, but it may be impractical to load them into memory. Perhaps they are being read from a file, from a data reader connected to a DB, from an active network connection, etc.\n\nIn this scenario, I would open a stream, read forward, buffering my input in a until the criteria was met.\n\n2 - Unsafe Char Manipulation\n\n This requires that you do have the complete string. You can obtain a char* to the start of a string quite simply:\n\nYou can now increment and examine each character. You can buffer it (e.g. if you want to examine multiple adjacent characters) or not as you choose. Once you determine the ending memory location, you now have a range of data that you can work with.\n\nUnsafe Code and Pointers in c#\n\nIf you are familiar with unsafe code, it is very fast, expressive, and flexible. If not, I would still use a similar approach, but without the pointer math. This is similar to the approach which @supercat suggested, namely:\n• Read through it character by character.\n• Buffer where needed. is good for this; set an initial size and reuse the instance.\n• Do something with the buffer when it contains the desired match.\n\nAnd an obligatory disclaimer for unsafe code: The vast majority of the time the framework methods are a better solution. They are safe, tested, and invoked millions of times per second. Unsafe code puts all of the responsibility on the developer. It does not make any assumptions; it's up to you to be a good framework/OS citizen (e.g. not overwriting immutable strings, allowing buffer overruns, etc.). Because it does not make any assumptions and removes the safeguards, it will often yield a performance increase. It's up to the developer to determine if there is indeed a benefit, and to decide if the advantages are significant enough."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/strings",
        "document": "A string is an object of type String whose value is text. Internally, the text is stored as a sequential read-only collection of Char objects. The Length property of a string represents the number of objects it contains, not the number of Unicode characters. To access the individual Unicode code points in a string, use the StringInfo object.\n\nIn C#, the keyword is an alias for String; therefore, and are equivalent. Use the provided alias as it works even without . The class provides many methods for safely creating, manipulating, and comparing strings. In addition, the C# language overloads some operators to simplify common string operations. For more information about the keyword, see string. For more information about the type and its methods, see String.\n\nYou can declare and initialize strings in various ways, as shown in the following example:\n\nYou don't use the new operator to create a string object except when initializing the string with an array of chars.\n\nInitialize a string with the Empty constant value to create a new String object whose string is of zero length. The string literal representation of a zero-length string is . By initializing strings with the Empty value instead of null, you can reduce the chances of a NullReferenceException occurring. Use the static IsNullOrEmpty(String) method to verify the value of a string before you try to access it.\n\nString objects are immutable: they can't be changed after they're created. All of the String methods and C# operators that appear to modify a string actually return the results in a new string object. In the following example, when the contents of and are concatenated to form a single string, the two original strings are unmodified. The operator creates a new string that contains the combined contents. That new object is assigned to the variable , and the original object that was assigned to is released for garbage collection because no other variable holds a reference to it.\n\nBecause a string \"modification\" is actually a new string creation, you must use caution when you create references to strings. If you create a reference to a string, and then \"modify\" the original string, the reference continues to point to the original object instead of the new object that was created when the string was modified. The following code illustrates this behavior:\n\nFor more information about how to create new strings that are based on modifications such as search and replace operations on the original string, see How to modify string contents.\n\nQuoted string literals start and end with a single double quote character ( ) on the same line. Quoted string literals are best suited for strings that fit on a single line and don't include any escape sequences. A quoted string literal must embed escape characters, as shown in the following example:\n\nVerbatim string literals are more convenient for multi-line strings, strings that contain backslash characters, or embedded double quotes. Verbatim strings preserve new line characters as part of the string text. Use double quotation marks to embed a quotation mark inside a verbatim string. The following example shows some common uses for verbatim strings:\n\nBeginning with C# 11, you can use raw string literals to more easily create strings that are multi-line, or use any characters requiring escape sequences. Raw string literals remove the need to ever use escape sequences. You can write the string, including whitespace formatting, how you want it to appear in output. A raw string literal:\n• Starts and ends with a sequence of at least three double quote characters ( ). You can use more than three consecutive characters to start and end the sequence to support string literals that contain three (or more) repeated quote characters.\n• Single line raw string literals require the opening and closing quote characters on the same line.\n• Multi-line raw string literals require both opening and closing quote characters on their own line.\n• In multi-line raw string literals, any whitespace to the left of the closing quotes is removed from all lines of the raw string literal.\n• In multi-line raw string literals, whitespace following the opening quote on the same line is ignored.\n• In multi-line raw string literals, whitespace only lines following the opening quote are included in the string literal.\n\nThe following examples demonstrate these rules:\n\nThe following examples demonstrate the compiler errors reported based on these rules:\n\nThe first two examples are invalid because multiline raw string literals require the opening and closing quote sequence on its own line. The third example is invalid because the text is outdented from the closing quote sequence.\n\nYou should consider raw string literals when you're generating text that includes characters that require escape sequences when using quoted string literals or verbatim string literals. Raw string literals are easier for you and others to read because it more closely resembles the output text. For example, consider the following code that includes a string of formatted JSON:\n\nA format string is a string whose contents are determined dynamically at run time. Format strings are created by embedding interpolated expressions or placeholders inside of braces within a string. Everything inside the braces ( ) is resolved to a value and output as a formatted string at run time. There are two methods to create format strings: string interpolation and composite formatting.\n\nYou declare Interpolated strings with the special character. An interpolated string includes interpolated expressions in braces. If you're new to string interpolation, see the String interpolation - C# interactive tutorial for a quick overview.\n\nUse string interpolation to improve the readability and maintainability of your code. String interpolation achieves the same results as the method, but improves ease of use and inline clarity.\n\nYou can use string interpolation to initialize a constant string when all the expressions used for placeholders are also constant strings.\n\nBeginning with C# 11, you can combine raw string literals with string interpolations. You start and end the format string with three or more successive double quotes. If your output string should contain the or character, you can use extra characters to specify how many and characters start and end an interpolation. Any sequence of fewer or characters is included in the output. The following example shows how you can use that feature to display the distance of a point from the origin, and place the point inside braces:\n\nC# also allows verbatim string interpolation, for example across multiple lines, using the or syntax.\n\nTo interpret escape sequences literally, use a verbatim string literal. An interpolated verbatim string starts with the character followed by the character. You can use the and tokens in any order: both and are valid interpolated verbatim strings.\n\nThe String.Format utilizes placeholders in braces to create a format string. This example results in similar output to the string interpolation method used in the preceding sample.\n\nFor more information on formatting .NET types, see Formatting Types in .NET.\n\nA substring is any sequence of characters that is contained in a string. Use the Substring method to create a new string from a part of the original string. You can search for one or more occurrences of a substring by using the IndexOf method. Use the Replace method to replace all occurrences of a specified substring with a new string. Like the Substring method, Replace actually returns a new string and doesn't modify the original string. For more information, see How to search strings and How to modify string contents.\n\nYou can use array notation with an index value to acquire read-only access to individual characters, as in the following example:\n\nIf the String methods don't provide the functionality that you must have to modify individual characters in a string, you can use a StringBuilder object to modify the individual chars \"in-place,\" and then create a new string to store the results by using the StringBuilder methods. In the following example, assume that you must modify the original string in a particular way and then store the results for future use:\n\nAn empty string is an instance of a System.String object that contains zero characters. Empty strings are used often in various programming scenarios to represent a blank text field. You can call methods on empty strings because they're valid System.String objects. Empty strings are initialized as follows:\n\nBy contrast, a null string doesn't refer to an instance of a System.String object and any attempt to call a method on a null string causes a NullReferenceException. However, you can use null strings in concatenation and comparison operations with other strings. The following examples illustrate some cases in which a reference to a null string does and doesn't cause an exception to be thrown:\n\nString operations in .NET are highly optimized and in most cases don't significantly impact performance. However, in some scenarios such as tight loops that are executing many hundreds or thousands of times, string operations can affect performance. The StringBuilder class creates a string buffer that offers better performance if your program performs many string manipulations. The StringBuilder string also enables you to reassign individual characters, something the built-in string data type doesn't support. This code, for example, changes the content of a string without creating a new string:\n\nIn this example, a StringBuilder object is used to create a string from a set of numeric types:\n\nBecause the String type implements IEnumerable<T>, you can use the extension methods defined in the Enumerable class on strings. To avoid visual clutter, these methods are excluded from IntelliSense for the String type, but they're available nevertheless. You can also use LINQ query expressions on strings. For more information, see LINQ and Strings.\n• How to modify string contents: Illustrates techniques to transform strings and modify the contents of strings.\n• How to compare strings: Shows how to perform ordinal and culture specific comparisons of strings.\n• How to concatenate multiple strings: Demonstrates various ways to join multiple strings into one.\n• How to parse strings using String.Split: Contains code examples that illustrate how to use the String.Split method to parse strings.\n• How to search strings: Explains how to use search for specific text or patterns in strings.\n• How to determine whether a string represents a numeric value: Shows how to safely parse a string to see whether it has a valid numeric value.\n• String interpolation: Describes the string interpolation feature that provides a convenient syntax to format strings.\n• Basic String Operations: Provides links to articles that use System.String and System.Text.StringBuilder methods to perform basic string operations.\n• Parsing Strings: Describes how to convert string representations of .NET base types to instances of the corresponding types.\n• Parsing Date and Time Strings in .NET: Shows how to convert a string such as \"01/24/2008\" to a System.DateTime object.\n• Comparing Strings: Includes information about how to compare strings and provides examples in C# and Visual Basic.\n• Using the StringBuilder Class: Describes how to create and modify dynamic string objects by using the StringBuilder class.\n• LINQ and Strings: Provides information about how to perform various string operations by using LINQ queries."
    },
    {
        "link": "https://stackoverflow.com/questions/43241271/best-practices-before-doing-string-manipulation-in-c-sharp",
        "document": "Use in .NET 4.0 or later, or in .NET 3.x.\n\nC# 6.0 adds the operator, which is \"null-safe\", it just returns null and skips the rest of the navigation expression:\n\nAs I remarked in my comment, if you're accessing a database using ADO.NET ( , , , etc) then you should check for which is used to indicate SQL values, which are distinct from in C#:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/visualstudio/profiling/performance-insights-string-startswith?view=vs-2022",
        "document": "Avoid using or inside a performance-sensitive context because it involves a culture-sensitive comparison, which leads to more CPU/memory overhead. Instead, use overrides that specify the needed comparison, leveraging or if possible.\n\nIn the CPU Usage tool, click View source code to go to the call tree and source line highlighting view, which shows where the most amount of time is spent in . From this point, trace back to where the method is used and check whether you can avoid using these methods with strings of length == 1."
    },
    {
        "link": "https://stackoverflow.com/questions/3120056/contains-is-faster-than-startswith",
        "document": "A consultant came by yesterday and somehow the topic of strings came up. He mentioned that he had noticed that for strings less than a certain length, is actually faster than . I had to see it with my own two eyes, so I wrote a little app and sure enough, is faster!\n\nHow is this possible?\n\nI've tried it with longer strings too!"
    },
    {
        "link": "https://stackoverflow.com/questions/717855/why-is-function-isprefix-faster-than-startswith-in-c",
        "document": "I think it's mostly fetching the thread's current culture.\n\nIf you change Marc's test to use this form of :\n\nIf you use it's a lot faster than using (depending on the of course). On my box the results are (not scientifically):\n\nObviously that's because it's really just comparing 16 bit integers at each point, which is pretty cheap. If you don't want culture-sensitive checking, and performance is particularly important to you, that's the overload I'd use."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.string.startswith?view=net-9.0",
        "document": "if matches the beginning of this string; otherwise, .\n\nThe following example defines a method that uses the StartsWith(String) method to remove HTML start tags from the beginning of a string. Note that the method is called recursively to ensure that multiple HTML start tags at the beginning of the line are removed. The example does not remove HTML tags embedded in a string.\n\nThis method compares to the substring at the beginning of this instance that is the same length as , and returns an indication whether they are equal. To be equal, must be an empty string (String.Empty), must be a reference to this same instance, or must match the beginning of this instance.\n\nThis method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.\n\nAs explained in Best Practices for Using Strings, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified. To determine whether a string begins with a particular substring by using the string comparison rules of the current culture, signal your intention explicitly by calling the StartsWith(String, StringComparison) method overload with a value of CurrentCulture for its parameter. If you don't need linguistic-aware comparison, consider using Ordinal."
    },
    {
        "link": "https://github.com/dotnet/runtime/issues/27682",
        "document": "I like using String.StartsWith because it's self explanatory and make code easy to read.\n\n How ever on some occasions I ran into performance issues and had to change my code, to faster less readable code.\n\nI created an example and a benchmark. The code with char compare is over 20 times faster.\n\nCan't the JIT-compiler to this kind of optimisation for me?"
    }
]