[
    {
        "link": "https://learn.microsoft.com/en-us/troubleshoot/developer/visualstudio/csharp/language-compilers/file-io-operation",
        "document": "Use Visual C# to do basic file I/O\n\nThis article describes how to do basic file I/O in Visual C#, and provides a code sample to illustrate how to perform this task.\n\nThis step-by-step article shows you how to do six basic file input/output (I/O) operations in Visual C#. If you are new to the .NET Framework, you will find that the object model for file operations in .NET is similar to the (FSO) that is popular with many Visual Studio 6.0 developers. To make the transition easier, the functionality that is demonstrated in How To Use FileSystemObject with Visual Basic.\n\nYou can still use the in .NET. Because the is a Component Object Model (COM) component, .NET requires that access to the object be through the Interop layer. Microsoft .NET generates a wrapper for the component for you if you want to use it. However, the , , , classes, and other related classes in the .NET Framework, offer functionality that is not available with the FSO, without the overhead of the Interop layer.\n\nThe examples in this article describe basic file I/O operations. The Step-by-step example section describes how to create a sample program that demonstrates the following file I/O operations:\n\nIf you want to use the following code samples directly, be aware of the following:\n• None Include the namespace, as follows:\n• None Declare the variable as follows:\n• None The function is declared as follows: Instead of declaring and using the function, you can use the following statement directly:\n\nThe following sample code uses a class to read the System.ini file. The contents of the file are added to a ListBox control. The block is used to alert the program if the file is empty. There are many ways to determine when the end of the file is reached; this sample uses the method to examine the next line before reading it.\n\nThis sample code uses a class to create and write to a file. If you have an existing file, you can open it in the same way.\n\nThis sample code uses a object to access a file's properties. Notepad.exe is used in this sample. The properties appear in a ListBox control.\n\nThis sample code uses the and classes to list the logical drives on a system. For this sample, the results appear in a ListBox control.\n\nThis sample code uses the method of the class to get a list of folders.\n\nThis sample code uses the method of the class to get a listing of files.\n\nMany things can go wrong when a user gains access to files. The files may not exist, the files may be in use, or users may not have rights on the files or folders that they are trying to access. It is important to consider these possibilities when you write code and to handle the exceptions that may be generated.\n• None In Visual C#, create a new Windows Forms Application. By default, Form1 is created.\n• None Delete all of the code in the Form1.cs.\n• None Paste the following code in the Code-Behind Editor window. using System.Windows.Forms; using System.IO; namespace fso_cs { public partial class Form1 : Form { string winDir = System.Environment.GetEnvironmentVariable(\"windir\"); public Form1() { InitializeComponent(); } private void button1_Click(object sender, System.EventArgs e) { //How to read a text file. //try...catch is to deal with a 0 byte file. this.listBox1.Items.Clear(); StreamReader reader = new StreamReader(winDir + \"\\\\system.ini\"); try { do { addListItem(reader.ReadLine()); } while (reader.Peek()!= -1); } catch { addListItem(\"File is empty\"); } finally { reader.Close(); } } private void button2_Click(object sender, System.EventArgs e) { //Demonstrates how to create and write to a text file. StreamWriter writer = new StreamWriter(\"c:\\\\KBTest.txt\"); writer.WriteLine(\"File created using StreamWriter class.\"); writer.Close(); this.listBox1.Items.Clear(); addListItem(\"File Written to C:\\\\KBTest.txt\"); } private void button3_Click(object sender, System.EventArgs e) { //How to retrieve file properties (example uses Notepad.exe). this.listBox1.Items.Clear(); FileInfo FileProps = new FileInfo(winDir + \"\\\n\notepad.exe\"); addListItem(\"File Name = \" + FileProps.FullName); addListItem(\"Creation Time = \" + FileProps.CreationTime); addListItem(\"Last Access Time = \" + FileProps.LastAccessTime); addListItem(\"Last Write TIme = \" + FileProps.LastWriteTime); addListItem(\"Size = \" + FileProps.Length); FileProps = null; } private void button4_Click(object sender, System.EventArgs e) { //Demonstrates how to obtain a list of disk drives. this.listBox1.Items.Clear(); string[] drives = Directory.GetLogicalDrives(); foreach (string drive in drives) { addListItem(drive); } } private void button5_Click(object sender, System.EventArgs e) { //How to get a list of folders (example uses Windows folder). this.listBox1.Items.Clear(); string[] dirs = Directory.GetDirectories(winDir); foreach (string dir in dirs) { addListItem(dir); } } private void button6_Click(object sender, System.EventArgs e) { //How to obtain list of files (example uses Windows folder). this.listBox1.Items.Clear(); string[] files = Directory.GetFiles(winDir); foreach (string i in files) { addListItem(i); } } private void Form1_Load(object sender, System.EventArgs e) { this.button1.Text = \"Read Text File\"; this.button2.Text = \"Write Text File\"; this.button3.Text = \"View File Information\"; this.button4.Text = \"List Drives\"; this.button5.Text = \"List Subfolders\"; this.button6.Text = \"List Files\"; } private void addListItem(string value) { this.listBox1.Items.Add(value); } } }\n• None Delete all of the code in Form1.Designer.cs.\n• None Paste the following code in Form1.Designer.cs. namespace fso_cs { partial class Form1 { /// <summary> /// Required designer variable. /// </summary> private System.ComponentModel.IContainer components = null; /// <summary> /// Clean up any resources being used. /// </summary> /// <param name=\"disposing\">true if managed resources should be disposed; otherwise, false.</param> protected override void Dispose(bool disposing) { if (disposing && (components != null)) { components.Dispose(); } base.Dispose(disposing); } #region Windows Form Designer generated code /// <summary> /// Required method for Designer support - do not modify /// the contents of this method with the code editor. /// </summary> private void InitializeComponent() { this.button1 = new System.Windows.Forms.Button(); this.button2 = new System.Windows.Forms.Button(); this.button3 = new System.Windows.Forms.Button(); this.button4 = new System.Windows.Forms.Button(); this.button5 = new System.Windows.Forms.Button(); this.button6 = new System.Windows.Forms.Button(); this.listBox1 = new System.Windows.Forms.ListBox(); this.SuspendLayout(); // button1 this.button1.Location = new System.Drawing.Point(53, 30); this.button1.Name = \"button1\"; this.button1.Size = new System.Drawing.Size(112, 23); this.button1.TabIndex = 1; this.button1.Text = \"button1\"; this.button1.Click += new System.EventHandler(this.button1_Click); // button2 this.button2.Location = new System.Drawing.Point(53, 62); this.button2.Name = \"button2\"; this.button2.Size = new System.Drawing.Size(112, 23); this.button2.TabIndex = 2; this.button2.Text = \"button2\"; this.button2.Click += new System.EventHandler(this.button2_Click); // button3 this.button3.Location = new System.Drawing.Point(53, 94); this.button3.Name = \"button3\"; this.button3.Size = new System.Drawing.Size(112, 23); this.button3.TabIndex = 3; this.button3.Text = \"button3\"; this.button3.Click += new System.EventHandler(this.button3_Click); // button4 this.button4.Location = new System.Drawing.Point(53, 126); this.button4.Name = \"button4\"; this.button4.Size = new System.Drawing.Size(112, 23); this.button4.TabIndex = 4; this.button4.Text = \"button4\"; this.button4.Click += new System.EventHandler(this.button4_Click); // button5 this.button5.Location = new System.Drawing.Point(53, 158); this.button5.Name = \"button5\"; this.button5.Size = new System.Drawing.Size(112, 23); this.button5.TabIndex = 5; this.button5.Text = \"button5\"; this.button5.Click += new System.EventHandler(this.button5_Click); // button6 this.button6.Location = new System.Drawing.Point(53, 190); this.button6.Name = \"button6\"; this.button6.Size = new System.Drawing.Size(112, 23); this.button6.TabIndex = 6; this.button6.Text = \"button6\"; this.button6.Click += new System.EventHandler(this.button6_Click); // listBox1 this.listBox1.FormattingEnabled = true; this.listBox1.Location = new System.Drawing.Point(204, 30); this.listBox1.Name = \"listBox1\"; this.listBox1.Size = new System.Drawing.Size(270, 199); this.listBox1.TabIndex = 7; // Form1 this.AutoScaleBaseSize = new System.Drawing.Size(5, 13); this.ClientSize = new System.Drawing.Size(525, 273); this.Controls.Add(this.button6); this.Controls.Add(this.button5); this.Controls.Add(this.button4); this.Controls.Add(this.button3); this.Controls.Add(this.button2); this.Controls.Add(this.button1); this.Controls.Add(this.listBox1); this.Name = \"Form1\"; this.Text = \"Form1\"; this.Load += new System.EventHandler(this.Form1_Load); this.ResumeLayout(false); } #endregion private System.Windows.Forms.Button button1; private System.Windows.Forms.Button button2; private System.Windows.Forms.Button button3; private System.Windows.Forms.Button button4; private System.Windows.Forms.Button button5; private System.Windows.Forms.Button button6; private System.Windows.Forms.ListBox listBox1; } }\n• None By default, Visual C# adds one form to the project when you create a Windows Forms project. This form is named Form1. The two source code files that represent the form are named Form1.cs and Form1.Designer.cs. You write your code in the Form1.cs file. The Windows Forms Designer writes designer-generated code in the Form1.Designer.cs file. The code in the preceding steps reflects that organization.\n• None Press F5 to build and then run the program. Click the buttons to view the different actions. When you view the sample code, you may want to collapse the area named Windows Form Designer Generated Code to hide this code."
    },
    {
        "link": "https://geeksforgeeks.org/introduction-to-c-sharp-windows-forms-applications",
        "document": "Windows Forms is a Graphical User Interface(GUI) class library which is bundled in .Net Framework. Its main purpose is to provide an easier interface to develop the applications for desktop, tablet, PCs. It is also termed as the WinForms. The applications which are developed by using Windows Forms or WinForms are known as the Windows Forms Applications that runs on the desktop computer. WinForms can be used only to develop the Windows Forms Applications not web applications. WinForms applications can contain the different type of controls like labels, list boxes, tooltip etc.\n• First, open the Visual Studio then Go to File -> New -> Project to create a new project and then select the language as Visual C# from the left menu. Click on Windows Forms App(.NET Framework) in the middle of current window. After that give the project name and Click OK. Here the solution is like a container which contains the projects and files that may be required by the program.\n• After that following window will display which will be divided into three parts as follows:\n• Editor Window or Main Window: Here, you will work with forms and code editing. You can notice the layout of form which is now blank. You will double click the form then it will open the code for that.\n• Solution Explorer Window: It is used to navigate between all items in solution. For example, if you will select a file form this window then particular information will be display in the property window.\n• Properties Window: This window is used to change the different properties of the selected item in the Solution Explorer. Also, you can change the properties of components or controls that you will add to the forms.\n• Now to add the controls to your WinForms application go to Toolbox tab present in the extreme left side of Visual Studio. Here, you can see a list of controls. To access the most commonly used controls go to Common Controls present in Toolbox tab.\n• Now drag and drop the controls that you needed on created Form. For example, if you can add TextBox, ListBox, Button etc. as shown below. By clicking on the particular dropped control you can see and change its properties present in the right most corner of Visual Studio. In the above image, you can see the TextBox is selected and its properties like TextAlign, MaxLength etc. are opened in right most corner. You can change its properties’ values as per the application need. The code of controls will be automatically added in the background. You can check the Form1.Designer.cs file present in the Solution Explorer Window.\n• To run the program you can use an F5 key or Play button present in the toolbar of Visual Studio. To stop the program you can use pause button present in the ToolBar. You can also run the program by going to Debug->Start Debugging menu in the menubar.\n\nC# Windows Forms is a graphical user interface (GUI) framework that enables developers to create desktop applications for the Windows operating system. Windows Forms applications are created using the C# programming language and the .NET framework. They are built by dragging and dropping controls such as buttons, text boxes, labels, and other user interface elements onto a form.\n• The Windows Forms framework provides a rich set of controls that developers can use to build applications with. These controls are designed to provide a consistent and familiar user interface for Windows users. Developers can customize the appearance and behavior of these controls by setting various properties and handling events.\n• To create a Windows Forms application in C#, you can use Microsoft Visual Studio, which is an integrated development environment (IDE) that provides a visual designer to create and layout the user interface elements. The visual designer is a drag-and-drop interface for building your UI, and you can easily configure each control’s properties through a user-friendly interface.\n• In addition to the visual designer, Visual Studio also provides a code editor that enables developers to write the C# code for the application’s logic. Developers can handle events and perform tasks such as data validation, data manipulation, and business logic implementation.\n• Windows Forms applications are versatile and can be used to create various types of applications such as data entry, management, and reporting applications, as well as games and multimedia applications.\n\nOverall, Windows Forms applications provide an easy-to-use and familiar graphical user interface for Windows users, making it an ideal choice for building desktop applications that require a high degree of interactivity and user engagement."
    },
    {
        "link": "https://stackoverflow.com/questions/6442697/how-to-implement-a-in-program-documentation-in-c-sharp-winforms",
        "document": "For a student project we want to implement a help / documentation form.\n\nIn this form we want to display text and images that should describe / help with the application.\n\nThe information could be represented in some kind of FAQ with questions and answers. These questions could the grouped into different categories like: (General information, function X, function y, function z, ...)\n\nUnfortunately I don't know what would be a good way to implement / display this. The following possibilites come into my mind:\n• Create a PDF for each category, use a treeview for the category selection and display the PDF for the selected category\n• Use a richtext textbox in the design time and set the editable function to false in the runtime. (I do dislike this idea)\n\nI also think that updating the documentation will also be a issue. I guess I'd prefer to use an external program to write the documentation and to just include it into the program.\n\nHas anyone some advice on this issue? (C# 4.0, Winforms)"
    },
    {
        "link": "https://stackoverflow.com/questions/69984251/file-handling-with-windows-forms-in-c-sharp",
        "document": "Let's just make WritePets do one thing, and do it fairly well. This is how we should write our methods in c#; a method named WritePets (note the pascal case) should write the pets to disk, only. It shouldn't show them in a list, it shouldn't read pets. If you want to show pets, make a ShowPets, if you want to read pets make a ReadPets; there is no penalty for making more methods\n\nPlease note, because I strongly suspect that this is homework the code above contains 3 deliberate, but minor, errors that I'd like you to fix so that you think about the code rather than just paste in. One of them will probably require taking a quick look at the documentation for File.\n\nThere is also a good chance that I've guessed the names of the properties of a pet incorrectly (like that 500 isn't the pet's weight..) which you'll need to patch up. If you don't want a csv you can adjust the format of a line by tweaking the placeholder string in the AppendFormat call"
    },
    {
        "link": "https://learn.microsoft.com/en-us/visualstudio/ide/create-csharp-winform-visual-studio?view=vs-2022",
        "document": "Tutorial: Create a Windows Forms app in Visual Studio with C#\n\nIn this tutorial, you create a simple C# application that has a Windows-based user interface (UI). The app has a button that changes the text of a label. This simple app has all the components used for more complicated Windows Forms programs.\n\nFirst, create a C# application project. The project type comes with all the template files you need to create your application.\n\nAfter you select your C# project template and name your project, Visual Studio opens a form for you. A form is a Windows user interface. Create a Hello World application by adding controls to the form. Then run the app.\n• If you don't see the Toolbox option, you can open it from the menu bar. Select View > Toolbox or Ctrl+Alt+X.\n• None Select the Pin icon to dock the Toolbox window.\n• None Select the Button control and then drag it onto the form.\n• None In the Properties window, locate Text, change the name from Button1 to , and then select Enter. If you don't see the Properties window, you can open it from the menu bar. Select View > Properties Window or F4.\n• None In the Design section of the Properties window, change the name from Button1 to , and then select Enter. If you alphabetized the list in the Properties window, Button1 appears in the (DataBindings) section, instead. You can dock or anchor the controls on your form to help with automatic placement and sizing, when the form changes size. After you add a button control to create an action, add a label control to receive the text.\n• None Select the Label control from the Toolbox. Then drag it onto the form and drop it beneath the Click this button.\n• None In either the Design section or the (DataBindings) section of the Properties window, change the name of Label1 to . Then select Enter.\n• None In the Form1.cs [Design] window, double-click the Click this button to open the Form1.cs window. Alternatively, you can expand Form1.cs in Solution Explorer, and then choose View Code or select F7 from the shortcut menu on Form1.cs.\n• None In the Form1.cs window, after the private void line, type or enter as shown in the following screenshot.\n\nAfter you select your C# project template and name your project, Visual Studio opens a form for you. A form is a Windows user interface. Create a Hello World application by adding controls to the form. Then run the app.\n• If you don't see the Toolbox option, you can open it from the menu bar. Select View > Toolbox or Ctrl+Alt+X.\n• None Expand Common Controls and select the Pin icon to dock the Toolbox window.\n• None Select the Button control and then drag it onto the form.\n• None In the Properties window, locate Text. Change the name from button1 to , and then select Enter. If you don't see the Properties window, you can open it from the menu bar. Select View > Properties Window or F4.\n• None In the Design section of the Properties window, change the name from button1 to , and then select Enter. If you alphabetized the list in the Properties window, Button1 appears in the (DataBindings) section, instead. You can dock or anchor the controls on your form to help with automatic placement and sizing, when the form changes size. After you add a button control to create an action, add a label control to receive the text.\n• None Select the Label control from the Toolbox. Then drag it onto the form and drop it beneath the Click this button.\n• None In either the Design section or the (DataBindings) section of the Properties window, change the name of label1 to . Then select Enter.\n• None In the Form1.cs [Design] window, double-click the Click this button to open the Form1.cs window. Alternatively, you can expand Form1.cs in Solution Explorer, and then choose Form1.\n• None In the Form1.cs window, after the private void line, type or enter as shown in the following screenshot.\n• None Select the Start button to run the application. Several things happen. In the Visual Studio IDE, the Diagnostics Tools window opens, and an Output window opens, too. But outside of the IDE, a Form1 dialog box appears. It includes your Click this button and text that says label1.\n• None Select the Click this button in the Form1 dialog box. Notice that the label1 text changes to Hello World!.\n• None Close the Form1 dialog box to stop running the app.\n\nCongratulations on completing this tutorial. To learn more, continue with the following tutorial:\n\nOr try these other tutorials:"
    },
    {
        "link": "https://stackoverflow.com/questions/1716609/how-to-match-cyrillic-characters-with-a-regular-expression",
        "document": "To match only Russian Cyrillic characters use:\n\nwhich is the equivalent of:\n\nwhere is Cyrillic, not Latin. (Despite looking the same they have different codes)\n\n, , which others suggested will match all variants of Cyrillic, not only Russian"
    },
    {
        "link": "https://stackoverflow.com/questions/7926514/matching-cyrillic-symbols-in-c-sharp",
        "document": "I have a huge file of code with many lines like this:\n\nWhat i`m trying to do is to find every part of the code with string of cyrilic symbols with another text that i provide. My problem is that i cant seem to make good enought expressions so i can catch the lines. Another problem is that some times the lines contain only one such string but other times they contain 2 or more on one line.\n\nEvery such string is similar and it look like this:\n\nI tried to make it with Regex class but I can't seem to make good enough pattern to the strings."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference",
        "document": "A regular expression is a pattern that the regular expression engine attempts to match in input text. A pattern consists of one or more character literals, operators, or constructs. For a brief introduction, see .NET Regular Expressions.\n\nEach section in this quick reference lists a particular category of characters, operators, and constructs that you can use to define regular expressions.\n\nWe've also provided this information in two formats that you can download and print for easy reference:\n\nThe backslash character (\\) in a regular expression indicates that the character that follows it either is a special character (as shown in the following table), or should be interpreted literally. For more information, see Character Escapes.\n\nA character class matches any one of a set of characters. Character classes include the language elements listed in the following table. For more information, see Character Classes.\n\nAnchors, or atomic zero-width assertions, cause a match to succeed or fail depending on the current position in the string, but they do not cause the engine to advance through the string or consume characters. The metacharacters listed in the following table are anchors. For more information, see Anchors.\n\nGrouping constructs delineate subexpressions of a regular expression and typically capture substrings of an input string. Grouping constructs include the language elements listed in the following table. For more information, see Grouping Constructs.\n\nWhen the regular expression engine hits a lookaround expression, it takes a substring reaching from the current position to the start (lookbehind) or end (lookahead) of the original string, and then runs Regex.IsMatch on that substring using the lookaround pattern. Success of this subexpression's result is then determined by whether it's a positive or negative assertion.\n\nOnce they have matched, atomic groups won't be re-evaluated again, even when the remainder of the pattern fails due to the match. This can significantly improve performance when quantifiers occur within the atomic group or the remainder of the pattern.\n\nA quantifier specifies how many instances of the previous element (which can be a character, a group, or a character class) must be present in the input string for a match to occur. Quantifiers include the language elements listed in the following table. For more information, see Quantifiers.\n\nA backreference allows a previously matched subexpression to be identified subsequently in the same regular expression. The following table lists the backreference constructs supported by regular expressions in .NET. For more information, see Backreference Constructs.\n\nAlternation constructs modify a regular expression to enable either/or matching. These constructs include the language elements listed in the following table. For more information, see Alternation Constructs.\n\nSubstitutions are regular expression language elements that are supported in replacement patterns. For more information, see Substitutions. The metacharacters listed in the following table are atomic zero-width assertions.\n\nYou can specify options that control how the regular expression engine interprets a regular expression pattern. Many of these options can be specified either inline (in the regular expression pattern) or as one or more RegexOptions constants. This quick reference lists only inline options. For more information about inline and RegexOptions options, see the article Regular Expression Options.\n\nYou can specify an inline option in two ways:\n• By using the miscellaneous construct , where a minus sign (-) before an option or set of options turns those options off. For example, turns case-insensitive matching ( ) on, turns multiline mode ( ) off, and turns unnamed group captures ( ) off. The option applies to the regular expression pattern from the point at which the option is defined, and is effective either to the end of the pattern or to the point where another construct reverses the option.\n• By using the grouping construct subexpression , which defines options for the specified group only.\n\nThe .NET regular expression engine supports the following inline options:\n\nMiscellaneous constructs either modify a regular expression pattern or provide information about it. The following table lists the miscellaneous constructs supported by .NET. For more information, see Miscellaneous Constructs."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/base-types/character-classes-in-regular-expressions",
        "document": "A character class defines a set of characters, any one of which can occur in an input string for a match to succeed. The regular expression language in .NET supports the following character classes:\n• None Positive character groups. A character in the input string must match one of a specified set of characters. For more information, see Positive Character Group.\n• None Negative character groups. A character in the input string must not match one of a specified set of characters. For more information, see Negative Character Group.\n• None Any character. The (dot or period) character in a regular expression is a wildcard character that matches any character except . For more information, see Any Character.\n• None A general Unicode category or named block. A character in the input string must be a member of a particular Unicode category or must fall within a contiguous range of Unicode characters for a match to succeed. For more information, see Unicode Category or Unicode Block.\n• None A negative general Unicode category or named block. A character in the input string must not be a member of a particular Unicode category or must not fall within a contiguous range of Unicode characters for a match to succeed. For more information, see Negative Unicode Category or Unicode Block.\n• None A word character. A character in the input string can belong to any of the Unicode categories that are appropriate for characters in words. For more information, see Word Character.\n• None A non-word character. A character in the input string can belong to any Unicode category that is not a word character. For more information, see Non-Word Character.\n• None A white-space character. A character in the input string can be any Unicode separator character, as well as any one of a number of control characters. For more information, see White-Space Character.\n• None A non-white-space character. A character in the input string can be any character that is not a white-space character. For more information, see Non-White-Space Character.\n• None A decimal digit. A character in the input string can be any of a number of characters classified as Unicode decimal digits. For more information, see Decimal Digit Character.\n• None A non-decimal digit. A character in the input string can be anything other than a Unicode decimal digit. For more information, see Decimal Digit Character.\n\n.NET supports character class subtraction expressions, which enables you to define a set of characters as the result of excluding one character class from another character class. For more information, see Character Class Subtraction.\n\nA positive character group specifies a list of characters, any one of which may appear in an input string for a match to occur. This list of characters may be specified individually, as a range, or both.\n\nThe syntax for specifying a list of individual characters is as follows:\n\nwhere character_group is a list of the individual characters that can appear in the input string for a match to succeed. character_group can consist of any combination of one or more literal characters, escape characters, or character classes.\n\nThe syntax for specifying a range of characters is as follows:\n\nwhere firstCharacter is the character that begins the range and lastCharacter is the character that ends the range. A character range is a contiguous series of characters defined by specifying the first character in the series, a hyphen (-), and then the last character in the series. Two characters are contiguous if they have adjacent Unicode code points. firstCharacter must be the character with the lower code point, and lastCharacter must be the character with the higher code point.\n\nTo include a hyphen as a nonperipheral member of a character group, escape it. For instance, to create a character group for the character and the characters from to , the correct syntax is .\n\nSome common regular expression patterns that contain positive character classes are listed in the following table.\n\nThe following example defines a positive character group that contains the characters \"a\" and \"e\" so that the input string must contain the words \"grey\" or \"gray\" followed by another word for a match to occur.\n\nThe regular expression is defined as follows:\n\nThe following example matches words that begin with any capital letter. It uses the subexpression to represent the range of capital letters from A to Z.\n\nThe regular expression is defined as shown in the following table.\n\nA negative character group specifies a list of characters that must not appear in an input string for a match to occur. The list of characters may be specified individually, as a range, or both.\n\nThe syntax for specifying a list of individual characters is as follows:\n\nwhere character_group is a list of the individual characters that cannot appear in the input string for a match to succeed. character_group can consist of any combination of one or more literal characters, escape characters, or character classes.\n\nThe syntax for specifying a range of characters is as follows:\n\nwhere firstCharacter is the character that begins the range and lastCharacter is the character that ends the range. A character range is a contiguous series of characters defined by specifying the first character in the series, a hyphen (-), and then the last character in the series. Two characters are contiguous if they have adjacent Unicode code points. firstCharacter must be the character with the lower code point, and lastCharacter must be the character with the higher code point.\n\nTwo or more character ranges can be concatenated. For example, to specify the range of decimal digits from \"0\" through \"9\", the range of lowercase letters from \"a\" through \"f\", and the range of uppercase letters from \"A\" through \"F\", use .\n\nThe leading caret character ( ) in a negative character group is mandatory and indicates the character group is a negative character group instead of a positive character group.\n\nSome common regular expression patterns that contain negative character groups are listed in the following table.\n\nThe following example matches any word that begins with the characters \"th\" and is not followed by an \"o\".\n\nThe regular expression is defined as shown in the following table.\n\nThe period character (.) matches any character except (the newline character), with the following two qualifications:\n• None If a regular expression pattern is modified by the RegexOptions.Singleline option, or if the portion of the pattern that contains the character class is modified by the option, matches any character. For more information, see Regular Expression Options. The following example illustrates the different behavior of the character class by default and with the RegexOptions.Singleline option. The regular expression starts at the beginning of the string and matches every character. By default, the match ends at the end of the first line; the regular expression pattern matches the carriage return character, , but it does not match . Because the RegexOptions.Singleline option interprets the entire input string as a single line, it matches every character in the input string, including . using System; using System.Text.RegularExpressions; public class Example { public static void Main() { string pattern = \"^.+\"; string input = \"This is one line and\" + Environment.NewLine + \"this is the second.\"; foreach (Match match in Regex.Matches(input, pattern)) Console.WriteLine(Regex.Escape(match.Value)); Console.WriteLine(); foreach (Match match in Regex.Matches(input, pattern, RegexOptions.Singleline)) Console.WriteLine(Regex.Escape(match.Value)); } } // The example displays the following output: // This\\ is\\ one\\ line\\ and\\r // // This\\ is\\ one\\ line\\ and\\r\n\nthis\\ is\\ the\\ second\\. Imports System.Text.RegularExpressions Module Example Public Sub Main() Dim pattern As String = \"^.+\" Dim input As String = \"This is one line and\" + vbCrLf + \"this is the second.\" For Each match As Match In Regex.Matches(input, pattern) Console.WriteLine(Regex.Escape(match.Value)) Next Console.WriteLine() For Each match As Match In Regex.Matches(input, pattern, RegexOptions.SingleLine) Console.WriteLine(Regex.Escape(match.Value)) Next End Sub End Module ' The example displays the following output: ' This\\ is\\ one\\ line\\ and\\r ' ' This\\ is\\ one\\ line\\ and\\r\n\nthis\\ is\\ the\\ second\\.\n• None In a positive or negative character group, a period is treated as a literal period character, and not as a character class. For more information, see Positive Character Group and Negative Character Group earlier in this topic. The following example provides an illustration by defining a regular expression that includes the period character ( ) both as a character class and as a member of a positive character group. The regular expression begins at a word boundary, matches any character until it encounters one of five punctuation marks, including a period, and then matches either a white-space character or the end of the string. using System; using System.Text.RegularExpressions; public class Example { public static void Main() { string pattern = @\"\\b.*[.?!;:](\\s|\\z)\"; string input = \"this. what: is? go, thing.\"; foreach (Match match in Regex.Matches(input, pattern)) Console.WriteLine(match.Value); } } // The example displays the following output: // this. what: is? go, thing. Imports System.Text.RegularExpressions Module Example Public Sub Main() Dim pattern As STring = \"\\b.*[.?!;:](\\s|\\z)\" Dim input As String = \"this. what: is? go, thing.\" For Each match As Match In Regex.Matches(input, pattern) Console.WriteLine(match.Value) Next End Sub End Module ' The example displays the following output: ' this. what: is? go, thing.\n\nThe Unicode standard assigns each character a general category. For example, a particular character can be an uppercase letter (represented by the category), a decimal digit (the category), a math symbol (the category), or a paragraph separator (the category). Specific character sets in the Unicode standard also occupy a specific range or block of consecutive code points. For example, the basic Latin character set is found from \\u0000 through \\u007F, while the Arabic character set is found from \\u0600 through \\u06FF.\n\nmatches any character that belongs to a Unicode general category or named block, where name is the category abbreviation or named block name. For a list of category abbreviations, see the Supported Unicode General Categories section later in this topic. For a list of named blocks, see the Supported Named Blocks section later in this topic.\n\nThe following example uses the name construct to match both a Unicode general category (in this case, the , or Punctuation, Dash category) and a named block (the and named blocks).\n\nThe regular expression is defined as shown in the following table.\n\nThe Unicode standard assigns each character a general category. For example, a particular character can be an uppercase letter (represented by the category), a decimal digit (the category), a math symbol (the category), or a paragraph separator (the category). Specific character sets in the Unicode standard also occupy a specific range or block of consecutive code points. For example, the basic Latin character set is found from \\u0000 through \\u007F, while the Arabic character set is found from \\u0600 through \\u06FF.\n\nmatches any character that does not belong to a Unicode general category or named block, where name is the category abbreviation or named block name. For a list of category abbreviations, see the Supported Unicode General Categories section later in this topic. For a list of named blocks, see the Supported Named Blocks section later in this topic.\n\nThe following example uses the name construct to remove any currency symbols (in this case, the , or Symbol, Currency category) from numeric strings.\n\nThe regular expression pattern matches one or more characters that are not currency symbols; it effectively strips any currency symbol from the result string.\n\nmatches any word character. A word character is a member of any of the Unicode categories listed in the following table.\n\nIf ECMAScript-compliant behavior is specified, is equivalent to . For information on ECMAScript regular expressions, see the \"ECMAScript Matching Behavior\" section in Regular Expression Options.\n\nThe following example uses the language element to match duplicate characters in a word. The example defines a regular expression pattern, , which can be interpreted as follows.\n\nmatches any non-word character. The \\W language element is equivalent to the following character class:\n\nIn other words, it matches any character except for those in the Unicode categories listed in the following table.\n\nIf ECMAScript-compliant behavior is specified, is equivalent to . For information on ECMAScript regular expressions, see the \"ECMAScript Matching Behavior\" section in Regular Expression Options.\n\nThe following example illustrates the character class. It defines a regular expression pattern, , that matches a word followed by one or two non-word characters, such as white space or punctuation. The regular expression is interpreted as shown in the following table.\n\nBecause the Group object for the second capturing group contains only a single captured non-word character, the example retrieves all captured non-word characters from the CaptureCollection object that is returned by the Group.Captures property.\n\nmatches any whitespace character. It is equivalent to the escape sequences and Unicode categories listed in the following table.\n\nIf ECMAScript-compliant behavior is specified, is equivalent to . For information on ECMAScript regular expressions, see the \"ECMAScript Matching Behavior\" section in Regular Expression Options.\n\nThe following example illustrates the character class. It defines a regular expression pattern, , that matches a word ending in either \"s\" or \"es\" followed by either a white-space character or the end of the input string. The regular expression is interpreted as shown in the following table.\n\nmatches any non-white-space character. It is equivalent to the regular expression pattern, or the opposite of the regular expression pattern that is equivalent to , which matches white-space characters. For more information, see White-Space Character: \\s.\n\nIf ECMAScript-compliant behavior is specified, is equivalent to . For information on ECMAScript regular expressions, see the \"ECMAScript Matching Behavior\" section in Regular Expression Options.\n\nThe following example illustrates the language element. The regular expression pattern matches strings that are delimited by white-space characters. The second element in the match's GroupCollection object contains the matched string. The regular expression can be interpreted as shown in the following table.\n\nmatches any decimal digit. It is equivalent to the regular expression pattern, which includes the standard decimal digits 0-9 as well as the decimal digits of a number of other character sets.\n\nIf ECMAScript-compliant behavior is specified, is equivalent to . For information on ECMAScript regular expressions, see the \"ECMAScript Matching Behavior\" section in Regular Expression Options.\n\nThe following example illustrates the language element. It tests whether an input string represents a valid telephone number in the United States and Canada. The regular expression pattern is defined as shown in the following table.\n\nmatches any non-digit character. It is equivalent to the regular expression pattern.\n\nIf ECMAScript-compliant behavior is specified, is equivalent to . For information on ECMAScript regular expressions, see the \"ECMAScript Matching Behavior\" section in Regular Expression Options.\n\nThe following example illustrates the \\D language element. It tests whether a string such as a part number consists of the appropriate combination of decimal and non-decimal characters. The regular expression pattern is defined as shown in the following table.\n\nUnicode defines the general categories listed in the following table. For more information, see the \"UCD File Format\" and \"General Category Values\" subtopics at the Unicode Character Database, Sec. 5.7.1, Table 12.\n\nYou can determine the Unicode category of any particular character by passing that character to the GetUnicodeCategory method. The following example uses the GetUnicodeCategory method to determine the category of each element in an array that contains selected Latin characters.\n\n.NET provides the named blocks listed in the following table. The set of supported named blocks is based on Unicode 4.0 and Perl 5.6. For a regular expression that uses named blocks, see the Unicode category or Unicode block: \\p{} section.\n\nA character class defines a set of characters. Character class subtraction yields a set of characters that is the result of excluding the characters in one character class from another character class.\n\nA character class subtraction expression has the following form:\n\nThe square brackets ( ) and hyphen ( ) are mandatory. The base_group is a positive character group or a negative character group. The excluded_group component is another positive or negative character group, or another character class subtraction expression (that is, you can nest character class subtraction expressions).\n\nFor example, suppose you have a base group that consists of the character range from \"a\" through \"z\". To define the set of characters that consists of the base group except for the character \"m\", use . To define the set of characters that consists of the base group except for the set of characters \"d\", \"j\", and \"p\", use . To define the set of characters that consists of the base group except for the character range from \"m\" through \"p\", use .\n\nConsider the nested character class subtraction expression, . The expression is evaluated from the innermost character range outward. First, the character range from \"m\" through \"o\" is subtracted from the character range \"d\" through \"w\", which yields the set of characters from \"d\" through \"l\" and \"p\" through \"w\". That set is then subtracted from the character range from \"a\" through \"z\", which yields the set of characters .\n\nYou can use any character class with character class subtraction. To define the set of characters that consists of all Unicode characters from \\u0000 through \\uFFFF except white-space characters ( ), the characters in the punctuation general category ( ), the characters in the named block ( ), and the Unicode NEXT LINE control character (\\x85), use .\n\nChoose character classes for a character class subtraction expression that will yield useful results. Avoid an expression that yields an empty set of characters, which cannot match anything, or an expression that is equivalent to the original base group. For example, the empty set is the result of the expression , which subtracts all characters in the character range from the general category. Similarly, the original base group is the result of the expression . This is because the base group, which is the character range of letters from \"a\" through \"z\", does not contain any characters in the excluded group, which is the character range of decimal digits from \"0\" through \"9\".\n\nThe following example defines a regular expression, , that matches zero and odd digits in an input string. The regular expression is interpreted as shown in the following table."
    },
    {
        "link": "https://imperiumdynamics.com/blog/Regular-Expression-in-CSharp.html",
        "document": "Did you know regular expressions can revolutionize your C# programming experience, allowing you to manipulate and validate data efficiently? With C# regular expressions, you can simplify complex pattern matching, streamline data validation, and supercharge your text manipulation tasks. \n\n\n\n This article will delve into the world of regular expressions in C#. We will explore their syntax, learn how to apply them effectively and discover advanced techniques to maximize their potential in .NET projects. \n\n\n\n If you're ready to unlock the power of C# regular expressions, join us as we uncover the secrets of efficient pattern matching, data validation, and text manipulation in C#.\n• Regular expressions in C# simplify pattern matching, data validation, and text manipulation.\n• Understanding the basic syntax and usage of regular expressions is crucial for effective implementation.\n• Advanced techniques such as pattern replacement and specific pattern matching offer more flexibility.\n• Regular expressions can handle various patterns, including email addresses and currency values.\n• Regex options in C# provide additional control over the behavior of regular expressions.\n\nGetting Started with C# Regex\n\nBefore diving into the details, let's start by understanding the fundamentals of working with regular expressions in C#. Regular expressions, or regex, are powerful tools for pattern matching, data validation, and text manipulation in .NET projects. \n\n\n\n In C#, regular expressions are implemented using the Regex class from the System.Text.RegularExpressions namespace. This class provides various methods and properties to work with regex patterns. \n\n\n\n Using regular expressions in C# involves creating patterns that define what you're searching for or manipulating in a text. These patterns can range from simple sequences of characters to more complex combinations of characters, metacharacters, and quantifiers.\n\nRegular expressions in C# can be used for various tasks, including\n\nLet's look at how regular expressions work and how you can use them in your C# projects.\n\nAt the core of regular expressions in C# are patterns and metacharacters. A pattern is a sequence of characters that defines a search pattern. On the other hand, Metacharacters have a special meaning in regular expressions. They allow you to specify quantifiers, character classes, anchors, etc. \n\n\n\n Here are some commonly used metacharacters in C# regex:\n\nCombining these metacharacters with regular characters allows you to create powerful search patterns for matching or manipulating text.\n\nConsider a simple example of using regular expressions in C# to match email addresses. \n\n\n\n string pattern = @\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\"; \n\n\n\n string email = \"example@example.com\"; \n\n\n\n Match match = Regex.Match(email, pattern); \n\n\n\n If (match. Success) \n\n { \n\n Console.WriteLine(\"Valid email address.\"); \n\n } \n\n else \n\n { \n\n Console.WriteLine(\"Invalid email address.\"); \n\n } \n\n\n\n In this example, we define a pattern that matches the structure of a standard email address. We then use the Regex.Match() method to test if the email address matches the pattern. If it does, we consider it a valid email address. \n\n\n\n This is just a simple example, but it demonstrates the power of regular expressions in C# and how they can be used for data validation and pattern matching. \n\n\n\n The following section will delve into the basic syntax and usage of regular expressions in C#. We'll explore how to create patterns and perform matching operations.\n\nThis section will explore the basic syntax and usage of regular expressions in C#. Regular expressions are powerful for matching patterns and text manipulation in .NET projects. Understanding the syntax and usage of regular expressions allows you to create patterns and perform matching operations.\n\nWhen using regular expressions in C#, patterns are created using a combination of characters and special symbols. Here are some commonly used symbols: \n\n\n\n . - Matches any character except a newline \n\n * - Matches the preceding element zero or more times \n\n + - Matches the preceding element one or more times \n\n ? - Matches the preceding element zero or one time \n\n [ ] - Matches any single character within the brackets \n\n | - Matches the expression before or after the pipe symbol. \n\n\n\n These symbols can be combined and modified to create complex patterns matching specific string patterns.\n\nIn C#, regular expressions are typically used with the Regex. Match or Regex.Matches methods to perform matching operations on strings. \n\n\n\n Regex.Match - Returns the first occurrence of a pattern in a string. \n\n\n\n Regex. Matches - Returns all occurrences of a pattern in a string. \n\n\n\n These methods return a Match or MatchCollection object, which can be used to obtain information about the matched pattern and perform further operations. \n\n\n\n Here's an example of using Regex.Match to find the first occurrence of a pattern: \n\n\n\n // Input string \n\n\n\n string text = \"The quick brown fox jumps over the lazy dog\"; \n\n\n\n // Pattern \n\n\n\n string pattern = \"brown\"; \n\n\n\n // Perform matching operation \n\n\n\n Match match = Regex.Match(text, pattern); \n\n\n\n // Output the result \n\n\n\n Console.WriteLine($\"Match found: {match.Value}\"); \n\n\n\n The above example will output: \n\n\n\n Match found: brown \n\n\n\n Similarly, Regex.Matches can be used to find all pattern occurrences in a string.\n\nThis section will explore more advanced techniques of using regular expressions in C#. Building on the knowledge gained in the previous section, we'll delve deeper into the power of regular expressions and discover how they can be used to replace patterns, match specific patterns, and more.\n\nOne of the most powerful features of regular expressions in C# is the ability to replace patterns within a given text. Using the c# regex replace method, you can effortlessly search for a specific pattern and replace it with desired content. This allows for efficient text manipulation and data processing, saving time and effort in your coding endeavors.\n\nAnother critical aspect of working with regular expressions in C# is matching specific patterns. With the c# match pattern capability, you can specify a regex pattern to search for within a given text and retrieve the matching results. This enables you to extract specific information from a string, validate input, or perform complex pattern-matching tasks. \n\n\n\n By utilizing the regex replace pattern c# and c# match pattern, you can unlock many possibilities in your C# development projects. Whether you need to manipulate text, validate data, or perform complex pattern matching, regular expressions in C# provide the tools you need to achieve your goals. \n\n\n\n Regular expressions are a game-changer in C# development. With the ability to replace patterns and match specific patterns, you can simplify your coding tasks and achieve more efficient and elegant solutions. \n\n\n\n Stay tuned for the next section, where we'll explore various examples of patterns that can be used with regular expressions in C#. Through practical examples, you'll gain a deeper understanding of how to leverage the power of regex in your projects.\n\nRegular expressions in C# offer a powerful way to work with various patterns, allowing you to perform advanced text manipulation, matching, and validation operations. This section will explore practical examples of patterns you can use with regular expressions in C#.\n\nEmail addresses follow a specific pattern, and regular expressions can help you efficiently validate and extract email addresses from text. Here's an example of a regular expression pattern that matches email addresses: \n\n\n\n [a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,} \n\n\n\n Using this pattern, you can quickly validate whether a given string follows the standard email address format in C#.\n\nRegular expressions can simplify validating and extracting these values from text if you need to work with currency values in your C# application. Here's an example of a regular expression pattern that matches currency values: \n\n\n\n \\$[0-9]{1,3}(?:,?[0-9]{3})?(?:\\.[0-9]{2})? \n\n \n\nThis pattern allows you to match currency values in dollars and cents, with optional thousands of separators and decimal points.\n\nRegular expressions in C# can also replace specific patterns within a string. For example, if you want to hide or replace email addresses in a text, you can use the following regular expression pattern: \n\n\n\n (?i)\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}\\b \n\n\n\n Using this pattern and the Regex.Replace method in C#. You can easily replace email addresses with a masked or dummy value.\n\nThese examples demonstrate a few possibilities when using regular expressions in C# with different patterns. By leveraging the power of C# regex, you can handle complex data validation and manipulation tasks more efficiently.\n\nDate formatting is a common task in many applications. Whether capturing user input, working with APIs, or storing data in databases, handling different date formats is crucial. Regular expressions can be a powerful tool in C# to ensure consistent and precise date formatting. \n\n\n\n Regular expressions provide a flexible and efficient way to match and manipulate text patterns. You can create dynamic patterns that match specific date formats and extract relevant information from date strings by leveraging regular expressions. This allows you to validate, parse, and transform data according to your application's requirements.\n\nWhy Use Regular Expressions for Date Formatting?\n\nUsing regular expressions for date formatting in C# offers several advantages:\n• Flexibility: Regular expressions allow you to define custom date formats and handle a wide range of date representations, such as \"MM/dd/yyyy,\" \"dd-MM-yyyy,\" or \"yyyy/MM/dd.\"\n• Pattern Matching: With regular expressions, you can easily identify and validate if a given date string matches the expected format, ensuring data integrity.\n• String Manipulation: Regular expressions enable you to extract and transform specific date components, such as the day, month, or year from a date string.\n\nHere are some common regular expressions that can be used for date formatting in C#: \n\n\n\n \"\\d{2}/\\d{2}/\\d{4}\" - Matches dates in the format month/day/year, such as \"01/24/2022\". \n\n\n\n \"\\d{4}-\\d{2}-\\d{2}\" - Matches dates in the format year-month-day, such as \"2022-01-24\". \n\n\n\n \"\\d{2}-\\d{2}-\\d{4}\" - Matches dates in the format day-month-year, such as \"24-01-2022\". \n\n\n\n These regular expressions can be a starting point for handling common date formats. However, it's essential to customize them according to the specific date formats you encounter in your application.\n\nImplementing date formatting with regular expressions in C# involves several steps:\n• Use the Regex.Match or Regex.IsMatch methods to check if a date string matches the pattern.\n• If a match is found, extract the relevant date components using capturing groups or other regex techniques.\n• Perform necessary transformations, such as converting the extracted components to a standardized date format or performing calculations.\n\nFollowing these steps, you can handle various date formats effectively and ensure consistent date processing in your C# applications.\n\nC# offers several options and flags that can be used with regular expressions. These options allow you to modify the behavior of regular expressions and customize them to suit your specific needs. Whether you're parsing complex data or searching for patterns in a text, these regex options can help optimize your code and improve performance.\n\nOne essential option in C# regex is the ability to parse a regular expression and convert it into a Regex object. This is done using the RegexOptions.Compiled option compiles the regular expression pattern into a more efficient format for faster matching. \n\n\n\n Here's an example of how you can use the RegexOptions.Compiled option: \n\n\n\n string pattern = \"your regex pattern\"; \n\n\n\n Regex regex = new Regex(pattern, RegexOptions.Compiled);\n\nIn addition to the RegexOptions.Compiled option, C# provides several other useful options:\n• RegexOptions.IgnoreCase: This option enables case-insensitive matching, allowing you to ignore the difference between uppercase and lowercase letters.\n• RegexOptions.Multiline: When this option is used, the ^ and $ anchors match each line's beginning and end rather than the entire string's beginning and end.\n• RegexOptions.Singleline: This option changes the behavior of the dot (.) metacharacter to match any character, including newline characters.\n• RegexOptions.ExplicitCapture: By default, capturing groups in a regex pattern are assigned numbers. This option allows you to name-capture groups and refer to them by name instead of number.\n\nThese options can be combined using the bitwise OR operator (|) to create customized regex behavior that meets your requirements. \n\n\n\n Understanding and utilizing these regex options in C# can greatly enhance your ability to handle complex pattern-matching and data manipulation tasks. By leveraging the power of regular expressions alongside these options, you can optimize your code and improve the efficiency of your applications.\n\nRegular expressions are powerful tools for validating and manipulating text in C#. With their versatile pattern-matching capabilities, regular expressions provide a flexible solution for tasks such as data validation, input sanitization, and text extraction. \n\n\n\n Let's examine how regular expressions can validate and manipulate text in different scenarios.\n\nEmail addresses are commonly used in web applications for user registration and communication. Validating email addresses ensures the input follows a specific format and avoids accepting invalid or malformed addresses. \n\n\n\n In C#, you can use regular expressions to validate email addresses by checking for specific patterns. \n\n\n\n \\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}\\b \n\n\n\n The above regular expression checks for the basic structure of an email address. It verifies that the address contains alphanumeric characters, special characters like dot (.), underscore (_), percent (%), and (+) before the \"@\", and a valid domain after the \"@\".\n\nValidating currency formats is crucial in financial applications and e-commerce platforms to ensure that the input follows the correct monetary format. Regular expressions can be used to validate and extract currency values from text. \n\n\n\n Here's an example of a regular expression that validates currency in a specific format: \n\n\n\n \\$[0-9]{1,3}(?:,?[0-9]{3})*(?:\\.[0-9]{2})? \n\n\n\n This regular expression validates currency values with thousands of optional separators (commas) and ensures the value has up to two decimal places.\n\nRegular expressions are also handy for replacing specific patterns in text. In C#, you can use regular expressions for find and replace operations, enabling you to manipulate text effectively. \n\n\n\n For example, you can use a regular expression to replace all occurrences of a specific word or phrase in a string: \n\n\n\n Regex.Replace(inputText, \"oldWord\", \"newWord\"); \n\n\n\n This will replace all occurrences of \"oldWord\" with \"newWord\" in the input text.\n\nRegular expressions support capturing groups, which allow you to extract specific parts of a matched pattern. This feature can be useful when you need to extract and manipulate specific portions of a text. \n\n\n\n For example, you can use a capturing group to extract the username from an email address: \n\n\n\n Regex.Match(email, @\"^([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5})$\").Groups[1].Value; \n\n\n\n This extracts the username part of the email address before the \"@\" symbol. \n\n\n\n Regular expressions provide a powerful and flexible way to validate and manipulate text in C#. By understanding the syntax and using the appropriate patterns, you can efficiently handle a wide range of text-related tasks in your .NET projects.\n\nIn this tutorial section, we'll walk through the process of building a Regex-driven application in C#. Regular expressions, also known as regex, are powerful tools for pattern matching and text manipulation in programming. By understanding how to use regex effectively, you can enhance the functionality and flexibility of your C# applications.\n\nWhy Use Regular Expressions in Your Application?\n\nRegular expressions provide a concise and efficient way to search for specific patterns within text and perform various operations, such as validating user input or extracting specific data. By leveraging regex patterns in your application, you can simplify complex string manipulation tasks and achieve more accurate and efficient results.\n\nBest Practices for Using C# Regex Patterns\n\nWhen working with regular expressions in C#, it's important to follow best practices to ensure the reliability and maintainability of your code. Here are some tips:\n• Start with a clear objective: Identify the specific pattern you want to match or manipulate.\n• Test and validate your regex pattern: Use online regex testers or built-in regex tools in your development environment to verify the correctness of your pattern.\n• Consider performance implications: Regular expressions can be resource-intensive, so optimize your patterns to achieve better performance when working with large datasets.\n• Document your regex patterns: Provide clear explanations and comments to make it easier for other developers (and yourself) to understand and modify the patterns in the future.\n• Use regex options and modifiers when necessary: C# provides various options and flags that you can apply to modify the behavior of regular expressions, such as case sensitivity or multiline matching.\n\nIn this walkthrough, we'll demonstrate the process of building a C# console application that uses regex patterns to validate and manipulate user input. We'll create a simple form validation scenario where the user is prompted to enter an email address and a password.\n• Create a new C# console application project in your preferred development environment.\n• Add the necessary input validation logic using regular expressions to ensure the email address and password meet the required criteria.\n• Test the application by entering various email addresses and passwords to ensure the validation works correctly.\n• Enhance the application by adding additional regex patterns to validate other input fields, such as phone numbers or postal codes.\n• Document your code and add comments to explain the purpose and functionality of the regex patterns you've used.\n\nBy following this tutorial and applying the principles of regex, you'll have a solid foundation for building regex-driven applications in C#. With regular expressions, you can unlock the power of pattern matching and text manipulation, making your applications more versatile and efficient.\n\nIn conclusion, regular expressions in C# offer developers a robust and versatile tool for handling pattern matching, data validation, and text manipulation in .NET projects. With a thorough understanding of C# regex, developers can simplify complex tasks and streamline development. \n\n\n\n Regular expressions provide a concise and powerful syntax for defining patterns, making searching and extracting specific information from strings easier. Whether you need to validate user input, extract data from a text file, or replace specific patterns in a document, C# regex can help you achieve these goals efficiently. \n\n\n\n By leveraging the power of regular expressions, developers can enhance the functionality of their applications and improve the overall user experience. Regular expressions can save development time and effort with proper implementation, enabling developers to focus on other critical aspects of their projects. \n\n\n\n Stay tuned for more articles on C# and regex, where we will delve deeper into specific use cases, advanced techniques, and practical examples. Mastering regular expressions in C# will undoubtedly open up new possibilities and empower you to tackle even the most complex challenges in your coding journey!\n\nRegular expressions, or regex, are powerful tools for pattern matching and manipulating text in C# and other programming languages. They provide a concise and flexible way to search, replace, and validate strings based on complex patterns.\n\nHow can regular expressions be used in C#?\n\nRegular expressions can be used in C# to perform tasks such as validating user input, extracting specific data from strings, manipulating and transforming text, and more. They are commonly used in form validation, data parsing, and text processing.\n\nHow do I create a regex pattern in C#?\n\nIn C#, you can create a regex pattern using the `Regex` class provided by the .NET Framework. You can construct a regex pattern using symbols and modifiers to define the desired matching criteria.\n\nWhat are some everyday use cases for regular expressions in C#?\n\nRegular expressions can be used in C# for various tasks, including: - Validating email addresses or other input formats. - Searching and extracting specific patterns from text. - Replacing specific patterns in a string with another value. - Parsing and validating dates, times, and other formats. - Identifying and extracting numbers, URLs, and other specific data types. These are just a few examples, and the possibilities for using regular expressions in C# are virtually endless.\n\nAre regular expressions case-sensitive in C#?\n\nBy default, regular expressions in C# are case-sensitive. This means that the regex pattern will match strings with the same casing specified in the pattern. However, you can use regex options such as `RegexOptions.IgnoreCase` to make the matching process case-insensitive.\n\nCan I use regular expressions to validate an email address in C#?\n\nYes, regular expressions commonly validate email addresses in C#. You can create a regex pattern that matches the required email format, including the correct placement of the \"@\" symbol, domain name, and top-level domain.\n\nAre there online resources or tools for testing regular expressions in C#?\n\nYes, various online resources and tools are available for testing and debugging regular expressions in C#. Some popular options include regex101.com, regexr.com, and RegexBuddy. These tools provide a convenient way to validate and experiment with regex patterns."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.openfiledialog?view=windowsdesktop-9.0",
        "document": "The following code example creates an OpenFileDialog, sets several properties to define the file extension filter and dialog behavior, and displays the dialog box using the CommonDialog.ShowDialog method. The example requires a form with a Button placed on it and a reference to the System.IO namespace added to it.\n\nThis class allows you to check whether a file exists and to open it. The ShowReadOnly property determines whether a read-only check box appears in the dialog box. The ReadOnlyChecked property indicates whether the read-only check box is checked.\n\nMost of the core functionality for this class is found in the FileDialog class.\n\nOn a right-to-left operating system, setting the containing form's RightToLeft property to RightToLeft.Yes localizes the dialog's File Name, Open, and Cancel buttons. If the property is not set to RightToLeft.Yes, English text is used instead.\n\nIf you want to give the user the ability to select a folder instead of a file, use FolderBrowserDialog instead.\n\nInitializes an instance of the OpenFileDialog class. Gets or sets a value indicating whether the dialog box automatically adds an extension to a file name if the user omits the extension. (Inherited from FileDialog) Gets or sets a value indicating whether the dialog box adds the file being opened or saved to the recent list. (Inherited from FileDialog) Gets or sets a value indicating whether this FileDialog instance should automatically upgrade appearance and behavior when running on Windows Vista. (Inherited from FileDialog) Gets a value indicating whether the component can raise an event. (Inherited from Component) Gets or sets a value indicating whether the dialog box displays a warning if the user specifies a file name that does not exist. Gets or sets a value indicating whether the dialog box displays a warning if the user specifies a path that does not exist. (Inherited from FileDialog) Gets or sets the GUID to associate with this dialog state. Typically, state such as the last visited folder and the position and size of the dialog is persisted based on the name of the executable file. By specifying a GUID, an application can have different persisted states for different versions of the dialog within the same application (for example, an import dialog and an open dialog). This functionality is not available if an application is not using visual styles or if AutoUpgradeEnabled is set to . (Inherited from FileDialog) Gets the IContainer that contains the Component. (Inherited from Component) Gets the custom places collection for this FileDialog instance. (Inherited from FileDialog) Gets or sets the default file name extension. (Inherited from FileDialog) Gets or sets a value indicating whether the dialog box returns the location of the file referenced by the shortcut or whether it returns the location of the shortcut (.lnk). (Inherited from FileDialog) Gets a value that indicates whether the Component is currently in design mode. (Inherited from Component) Gets the list of event handlers that are attached to this Component. (Inherited from Component) Gets or sets a string containing the file name selected in the file dialog box. (Inherited from FileDialog) Gets the file names of all selected files in the dialog box. (Inherited from FileDialog) Gets or sets the current file name filter string, which determines the choices that appear in the \"Save as file type\" or \"Files of type\" box in the dialog box. (Inherited from FileDialog) Gets or sets the index of the filter currently selected in the file dialog box. (Inherited from FileDialog) Gets or sets the initial directory displayed by the file dialog box. (Inherited from FileDialog) Gets the Win32 instance handle for the application. (Inherited from FileDialog) Gets or sets a value indicating whether the dialog box allows multiple files to be selected. Gets or sets a value indicating whether the OK button of the dialog box is disabled until the user navigates the view or edits the filename (if applicable). (Inherited from FileDialog) Gets values to initialize the FileDialog. (Inherited from FileDialog) Gets or sets a value indicating whether the read-only check box is selected. Gets or sets a value indicating whether the dialog box restores the directory to the previously selected directory before closing. (Inherited from FileDialog) Gets the file name and extension for the file selected in the dialog box. The file name does not include the path. Gets an array of file names and extensions for all the selected files in the dialog box. The file names do not include the path. Gets or sets a value indicating whether the dialog box allows selection of read-only files. Gets or sets a value indicating whether the Help button is displayed in the file dialog box. (Inherited from FileDialog) Gets or sets a value indicating whether the dialog box displays hidden and system files. (Inherited from FileDialog) Gets or sets a value indicating whether the items shown by default in the view's navigation pane are shown. (Inherited from FileDialog) Gets or sets a value indicating whether the dialog box shows a preview for selected files. Gets or sets a value indicating whether the dialog box contains a read-only check box. Gets or sets the ISite of the Component. (Inherited from Component) Gets or sets whether the dialog box supports displaying and saving files that have multiple file name extensions. (Inherited from FileDialog) Gets or sets an object that contains data about the control. (Inherited from CommonDialog) Gets or sets the file dialog box title. (Inherited from FileDialog) Gets or sets a value indicating whether the dialog box accepts only valid Win32 file names. (Inherited from FileDialog) Creates an object that contains all the relevant information required to generate a proxy used to communicate with a remote object. (Inherited from MarshalByRefObject) Releases all resources used by the Component. (Inherited from Component) Releases the unmanaged resources used by the Component and optionally releases the managed resources. (Inherited from Component) Determines whether the specified object is equal to the current object. (Inherited from Object) Retrieves the current lifetime service object that controls the lifetime policy for this instance. (Inherited from MarshalByRefObject) Returns an object that represents a service provided by the Component or by its Container. (Inherited from Component) Gets the Type of the current instance. (Inherited from Object) Defines the common dialog box hook procedure that is overridden to add specific functionality to the file dialog box. (Inherited from FileDialog) Obtains a lifetime service object to control the lifetime policy for this instance. (Inherited from MarshalByRefObject) Opens the file selected by the user, with read-only permission. The file is specified by the FileName property. Defines the owner window procedure that is overridden to add specific functionality to a common dialog box. (Inherited from CommonDialog) Resets all properties to their default values. Runs a common dialog box with the specified owner. (Inherited from CommonDialog) Provides a string version of this object. (Inherited from FileDialog) Occurs when the component is disposed by a call to the Dispose() method. (Inherited from Component) Occurs when the user clicks on the Open or Save button on a file dialog box. (Inherited from FileDialog) Occurs when the user clicks the Help button on a common dialog box. (Inherited from CommonDialog)\n• How to: Read Text from a File"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.filedialog?view=windowsdesktop-9.0",
        "document": "The following code example uses the OpenFileDialog implementation of FileDialog and illustrates creating, setting of properties, and showing the dialog box. The example uses the ShowDialog method to display the dialog box and return the DialogResult. The example requires a form with a Button placed on it and the System.IO namespace added to it.\n\nFileDialog is an abstract class that contains common behavior for the OpenFileDialog and SaveFileDialog classes. It is not intended to be used directly but contains common behavior for those two classes. You cannot create an instance of FileDialog. Although the class is declared public, you cannot inherit from it, as it contains internal abstract methods. To create a dialog box to select or save a file, use OpenFileDialog or SaveFileDialog.\n\nFileDialog is a modal dialog box; therefore, when shown, it blocks the rest of the application until the user has chosen a file. When a dialog box is displayed modally, no input (keyboard or mouse click) can occur except to objects on the dialog box. The program must hide or close the dialog box (usually in response to some user action) before input to the calling program can occur.\n\nIf you want to enable users to select a folder instead of a file, use the FolderBrowserDialog.\n\nDepending upon the type of application, how data associated with the application is stored, and the reason for accessing the file system, there are many possible ways in which you can create a directory path. The following table shows the techniques for creating paths dynamically.\n\nNotice that a full path may be built up using one or more of the described techniques. For example, the GetFolderPath method might be used to obtain the path to the MyDocuments folder, then an application setting may be used to add a relative subdirectory portion.\n\nThe System.IO.Path class contains static members to assist in manipulating absolute and relative path strings, whereas the System.IO.File and System.IO.Directory classes have static members that actually manipulate files and directories, respectively.\n\nGets or sets a value indicating whether the dialog box automatically adds an extension to a file name if the user omits the extension. Gets or sets a value indicating whether the dialog box adds the file being opened or saved to the recent list. Gets or sets a value indicating whether this FileDialog instance should automatically upgrade appearance and behavior when running on Windows Vista. Gets a value indicating whether the component can raise an event. (Inherited from Component) Gets or sets a value indicating whether the dialog box displays a warning if the user specifies a file name that does not exist. Gets or sets a value indicating whether the dialog box displays a warning if the user specifies a path that does not exist. Gets or sets the GUID to associate with this dialog state. Typically, state such as the last visited folder and the position and size of the dialog is persisted based on the name of the executable file. By specifying a GUID, an application can have different persisted states for different versions of the dialog within the same application (for example, an import dialog and an open dialog). This functionality is not available if an application is not using visual styles or if AutoUpgradeEnabled is set to . Gets the IContainer that contains the Component. (Inherited from Component) Gets the custom places collection for this FileDialog instance. Gets or sets the default file name extension. Gets or sets a value indicating whether the dialog box returns the location of the file referenced by the shortcut or whether it returns the location of the shortcut (.lnk). Gets a value that indicates whether the Component is currently in design mode. (Inherited from Component) Gets the list of event handlers that are attached to this Component. (Inherited from Component) Gets or sets a string containing the file name selected in the file dialog box. Gets the file names of all selected files in the dialog box. Gets or sets the current file name filter string, which determines the choices that appear in the \"Save as file type\" or \"Files of type\" box in the dialog box. Gets or sets the index of the filter currently selected in the file dialog box. Gets or sets the initial directory displayed by the file dialog box. Gets the Win32 instance handle for the application. Gets or sets a value indicating whether the OK button of the dialog box is disabled until the user navigates the view or edits the filename (if applicable). Gets values to initialize the FileDialog. Gets or sets a value indicating whether the dialog box restores the directory to the previously selected directory before closing. Gets or sets a value indicating whether the Help button is displayed in the file dialog box. Gets or sets a value indicating whether the dialog box displays hidden and system files. Gets or sets a value indicating whether the items shown by default in the view's navigation pane are shown. Gets or sets the ISite of the Component. (Inherited from Component) Gets or sets whether the dialog box supports displaying and saving files that have multiple file name extensions. Gets or sets an object that contains data about the control. (Inherited from CommonDialog) Gets or sets the file dialog box title. Gets or sets a value indicating whether the dialog box accepts only valid Win32 file names. Creates an object that contains all the relevant information required to generate a proxy used to communicate with a remote object. (Inherited from MarshalByRefObject) Releases all resources used by the Component. (Inherited from Component) Releases the unmanaged resources used by the Component and optionally releases the managed resources. (Inherited from Component) Determines whether the specified object is equal to the current object. (Inherited from Object) Retrieves the current lifetime service object that controls the lifetime policy for this instance. (Inherited from MarshalByRefObject) Returns an object that represents a service provided by the Component or by its Container. (Inherited from Component) Gets the Type of the current instance. (Inherited from Object) Defines the common dialog box hook procedure that is overridden to add specific functionality to the file dialog box. Obtains a lifetime service object to control the lifetime policy for this instance. (Inherited from MarshalByRefObject) Defines the owner window procedure that is overridden to add specific functionality to a common dialog box. (Inherited from CommonDialog) Resets all properties to their default values. Runs a common dialog box with the specified owner. (Inherited from CommonDialog) Provides a string version of this object. Occurs when the component is disposed by a call to the Dispose() method. (Inherited from Component) Occurs when the user clicks on the Open or Save button on a file dialog box. Occurs when the user clicks the Help button on a common dialog box. (Inherited from CommonDialog)"
    },
    {
        "link": "https://stackoverflow.com/questions/12283145/create-write-to-and-open-a-text-file-from-savefiledialog",
        "document": "I am displaying a SaveFileDialog and when OK is clicked I am creating new file, writing some default content to it and then attempting to Open it via the OpenFile() method of the SaveFileDialog. However, the moment I call OpenFile() the content of the file are deleted.\n\nCan someone explain why this happens and what I need to be doing to successfully Open the newly created file?"
    },
    {
        "link": "https://informit.com/articles/article.aspx?p=102639&seqNum=22",
        "document": "Using the OpenFileDialog and SaveFileDialog Controls\n\nA common task for an application is to open or save a file that represents its application data. In Windows applications the Open and Save file dialog boxes provide an easy way for the user to locate a file. The .NET Compact Framework provides the and controls to interact with these dialog boxes. On Windows CE and Pocket PC, these controls allow you to navigate only the folder and one folder underneath. Because of this, you may want to create a folder underneath that will be the default location for application data.\n\nThere are a few interesting properties that you may consider setting before displaying one of the file dialog boxes to the user. First, set the property, which determines valid file types and their associated file extensions to be listed in either file dialog box. For example, the following string would allow only files with the or extensions to be listed in the dialog box:\n\nEach file filter will be added to the Files Type drop-down menu in the Open or Save dialog box. You can change the currently selected file filter by setting the property. The default value of this property is because the index is not zero-based.\n\nFinally, the property determines a folder under that will initially be enumerated by the dialog boxes. If this property is not set or the folder does not exist, then is enumerated.\n\nTo display an Open or Save file dialog box, call the method on either the or control. This method will block until the user clicks either the OK button or the Cancel button. returns a enumeration value. The enumeration has several members, but the method will only return either or . If is returned, the user has clicked the OK button, and you can check the property to retrieve the complete path of the file the user selected. If is returned, the user clicked the Cancel button to discard the dialog.\n\nThese controls have different visual representations depending on the OS they are running on. On Pocket PC the dialog boxes will appear full screen. On Windows CE a dialog box will appear as a pop-up dialog window above the application, similar to its desktop counterpart.\n\nThe following code demonstrates how to display an control that lists files with the or extension. If a file is selected, then a message box appears with the complete filename."
    },
    {
        "link": "https://github.com/dotnet/docs-desktop/blob/main/dotnet-desktop-guide/framework/winforms/controls/how-to-save-files-using-the-savefiledialog-component.md",
        "document": "Display the Save File dialog box and call a method to save the file selected by the user.\n\nUse the xref:System.Windows.Forms.SaveFileDialog component's xref:System.Windows.Forms.SaveFileDialog.OpenFile%2A method to save the file. This method gives you a xref:System.IO.Stream object you can write to.\n\nThe example below uses the xref:System.Windows.Forms.DialogResult property to get the name of the file, and the xref:System.Windows.Forms.OpenFileDialog.OpenFile%2A method to save the file. The xref:System.Windows.Forms.SaveFileDialog.OpenFile%2A method gives you a stream to write the file to.\n\nIn the example below, there is a xref:System.Windows.Forms.Button control with an image assigned to it. When you click the button, a xref:System.Windows.Forms.SaveFileDialog component is instantiated with a filter that allows files of type .gif, .jpeg, and .bmp. If a file of this type is selected in the Save File dialog box, the button's image is saved.\n\nThe example assumes your form has a xref:System.Windows.Forms.Button control with its xref:System.Windows.Forms.ButtonBase.Image%2A property set to a file of type .gif, .jpeg, or .bmp.\n\n[!NOTE] The xref:System.Windows.Forms.FileDialog class's xref:System.Windows.Forms.FileDialog.FilterIndex%2A property (which, due to inheritance, is part of the xref:System.Windows.Forms.SaveFileDialog class) uses a one-based index. This is important if you are writing code to save data in a specific format (for example, saving a file in plain text versus binary format). This property is featured in the example below.\n\n' Displays a SaveFileDialog so the user can save the Image ' If the file name is not an empty string open it for saving. ' Saves the Image via a FileStream created by the OpenFile method. ' Saves the Image in the appropriate ImageFormat based upon the ' NOTE that the FilterIndex property is one-based.\n\n// Displays a SaveFileDialog so the user can save the Image // If the file name is not an empty string open it for saving. // Saves the Image via a FileStream created by the OpenFile method. // Saves the Image in the appropriate ImageFormat based upon the // NOTE that the FilterIndex property is one-based.\n\nSystem::Void (System::Object ^ sender, System::EventArgs ^ e) { Displays a SaveFileDialog so the user can save the Image SaveFileDialog ^ saveFileDialog1 = (); saveFileDialog1-> = ; saveFileDialog1-> = ; saveFileDialog1-> (); If the file name is not an empty string, open it for saving. (saveFileDialog1-> != ) { Saves the Image through a FileStream created by System::IO::FileStream ^ fs = safe_cast\\<System::IO::FileStream*>( saveFileDialog1-> ()); Saves the Image in the appropriate ImageFormat based on the file type selected in the dialog box. Note that the FilterIndex property is one based. (saveFileDialog1-> ) { : -> -> -> (fs, System::Drawing::Imaging::ImageFormat::Jpeg); ; : -> -> -> (fs, System::Drawing::Imaging::ImageFormat::Bmp); ; : -> -> -> (fs, System::Drawing::Imaging::ImageFormat::Gif); ; } fs-> (); } }\n\n(Visual C# and Visual C++) Place the following code in the form's constructor to register the event handler.\n\nFor more information about writing file streams, see xref:System.IO.FileStream.BeginWrite%2A and xref:System.IO.FileStream.Write%2A."
    }
]