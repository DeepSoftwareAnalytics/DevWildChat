[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules",
        "document": "Throughout this article, we've used extensions for our module files, but in other resources you may see the extension used instead. V8's documentation recommends this, for example. The reasons given are:\n• It is good for clarity, i.e. it makes it clear which files are modules, and which are regular JavaScript.\n• It ensures that your module files are parsed as a module by runtimes such as Node.js, and build tools such as Babel. However, we decided to keep using , at least for the moment. To get modules to work correctly in a browser, you need to make sure that your server is serving them with a header that contains a JavaScript MIME type such as . If you don't, you'll get a strict MIME type checking error along the lines of \"The server responded with a non-JavaScript MIME type\" and the browser won't run your JavaScript. Most servers already set the correct type for files, but not yet for files. Servers that already serve files correctly include GitHub Pages and for Node.js. This is OK if you are using such an environment already, or if you aren't but you know what you are doing and have access (i.e. you can configure your server to set the correct for files). It could however cause confusion if you don't control the server you are serving files from, or are publishing files for public use, as we are here. For learning and portability purposes, we decided to keep to . If you really value the clarity of using for modules versus using for \"normal\" JavaScript files, but don't want to run into the problem described above, you could always use during development and convert them to during your build step. It is also worth noting that:\n• Some tools may never support .\n• The attribute is used to denote when a module is being pointed to, as you'll see below.\n\nOnce you've exported some features out of your module, you need to import them into your script to be able to use them. The simplest way to do this is as follows: You use the statement, followed by a comma-separated list of the features you want to import wrapped in curly braces, followed by the keyword , followed by the module specifier. The module specifier provides a string that the JavaScript environment can resolve to a path to the module file. In a browser, this could be a path relative to the site root, which for our example would be . However, here we are instead using the dot ( ) syntax to mean \"the current location\", followed by the relative path to the file we are trying to find. This is much better than writing out the entire absolute path each time, as relative paths are shorter and make the URL portable — the example will still work if you move it to a different location in the site hierarchy. You can see such lines in action in . Note: In some module systems, you can use a module specifier like that isn't a relative or absolute path, and that doesn't have a file extension. This kind of specifier can be used in a browser environment if you first define an import map. Once you've imported the features into your script, you can use them just like they were defined inside the same file. The following is found in , below the import lines: Note: The imported values are read-only views of the features that were exported. Similar to variables, you cannot re-assign the variable that was imported, but you can still modify properties of object values. The value can only be re-assigned by the module exporting it. See the reference for an example.\n\nAbove we saw how a browser can import a module using a module specifier that is either an absolute URL, or a relative URL that is resolved using the base URL of the document: import { name as squareName, draw } from \"./shapes/square.js\"; import { name as circleName } from \"https://example.com/shapes/circle.js\"; Import maps allow developers to instead specify almost any text they want in the module specifier when importing a module; the map provides a corresponding value that will replace the text when the module URL is resolved. For example, the key in the import map below defines a \"module specifier map\" JSON object where the property names can be used as module specifiers, and the corresponding values will be substituted when the browser resolves the module URL. The values must be absolute or relative URLs. Relative URLs are resolved to absolute URL addresses using the base URL of the document containing the import map. The import map is defined using a JSON object inside a element with the attribute set to . Note that an import map only applies to the document — the specification does not cover how to apply an import map in a worker or worklet context. With this map you can now use the property names above as module specifiers. If there is no trailing forward slash on the module specifier key then the whole module specifier key is matched and substituted. For example, below we match bare module names, and remap a URL to another path. // Bare module names as module specifiers import { name as squareNameOne } from \"shapes\"; import { name as squareNameTwo } from \"shapes/square\"; // Remap a URL to another URL import { name as squareNameThree } from \"https://example.com/shapes/square.js\"; If the module specifier has a trailing forward slash then the value must have one as well, and the key is matched as a \"path prefix\". This allows remapping of whole classes of URLs. // Remap a URL as a prefix ( https://example.com/shapes/) import { name as squareNameFour } from \"https://example.com/shapes/moduleshapes/square.js\"; It is possible for multiple keys in an import map to be valid matches for a module specifier. For example, a module specifier of could match the module specifier keys and . In this case the browser will select the most specific (longest) matching module specifier key. Import maps allow modules to be imported using bare module names (as in Node.js), and can also simulate importing modules from packages, both with and without file extensions. While not shown above, they also allow particular versions of a library to be imported, based on the path of the script that is importing the module. Generally they let developers write more ergonomic import code, and make it easier to manage the different versions and dependencies of modules used by a site. This can reduce the effort required to use the same JavaScript libraries in both browser and server. The following sections expand on the various features outlined above.\n\nEcosystems like Node use package managers such as npm to manage modules and their dependencies. The package manager ensures that each module is separated from other modules and their dependencies. As a result, while a complex application might include the same module multiple times with several different versions in different parts of the module graph, users do not need to think about this complexity. Note: You can also achieve version management using relative paths, but this is subpar because, among other things, this forces a particular structure on your project, and prevents you from using bare module names. Import maps similarly allow you to have multiple versions of dependencies in your application and refer to them using the same module specifier. You implement this with the key, which allows you to provide module specifier maps that will be used depending on the path of the script performing the import. The example below demonstrates this. With this mapping, if a script with an URL that contains imports , the version in will be used. The map in is used as a fallback if there is no matching scope in the scoped map, or the matching scopes don't contain a matching specifier. For example, if is imported from a script with a non-matching scope path, then the module specifier map in will be used instead, mapping to the version in . Note that the path used to select a scope does not affect how the address is resolved. The value in the mapped path does not have to match the scopes path, and relative paths are still resolved to the base URL of the script that contains the import map. Just as for module specifier maps, you can have many scope keys, and these may contain overlapping paths. If multiple scopes match the referrer URL, then the most specific scope path is checked first (the longest scope key) for a matching specifier. The browsers will fall back to the next most specific matching scoped path if there is no matching specifier, and so on. If there is no matching specifier in any of the matching scopes, the browser checks for a match in the module specifier map in the key.\n\nA recent addition to JavaScript modules functionality is dynamic module loading. This allows you to dynamically load modules only when they are needed, rather than having to load everything up front. This has some obvious performance advantages; let's read on and see how it works. This new functionality allows you to call as a function, passing it the path to the module as a parameter. It returns a , which fulfills with a module object (see Creating a module object) giving you access to that object's exports. For example: import(\"./modules/myModule.js\").then((module) => { // Do something with the module. }); Note: Dynamic import is permitted in the browser main thread, and in shared and dedicated workers. However will throw if called in a service worker or worklet. Let's look at an example. In the dynamic-module-imports directory we've got another example based on our classes example. This time however we are not drawing anything on the canvas when the example loads. Instead, we include three buttons — \"Circle\", \"Square\", and \"Triangle\" — that, when pressed, dynamically load the required module and then use it to draw the associated shape. In this example we've only made changes to our and files — the module exports remain the same as before. Over in we've grabbed a reference to each button using a call, for example: We then attach an event listener to each button so that when pressed, the relevant module is dynamically loaded and used to draw the shape: Note that, because the promise fulfillment returns a module object, the class is then made a subfeature of the object, hence we now need to access the constructor with prepended to it, e.g. . Another advantage of dynamic imports is that they are always available, even in script environments. Therefore, if you have an existing tag in your HTML that doesn't have , you can still reuse code distributed as modules by dynamically importing it. <script> import(\"./modules/square.js\").then((module) => { // Do something with the module. }); // Other code that operates on the global scope and is not // ready to be refactored into modules yet. var btn = document.querySelector(\".square\"); </script>\n\nThe introduction of modules encourages the JavaScript ecosystem to distribute and reuse code in a modular fashion. However, that doesn't necessarily mean a piece of JavaScript code can run in every environment. Suppose you discovered a module that generates SHA hashes of your user's password. Can you use it in the browser front end? Can you use it on your Node.js server? The answer is: it depends. Modules still have access to global variables, as demonstrated previously. If the module references globals like , it can run in the browser, but will throw an error in your Node.js server, because is not available there. Similarly, if the code requires access to to be functional, it can only be used in Node.js. In order to maximize the reusability of a module, it is often advised to make the code \"isomorphic\" — that is, exhibits the same behavior in every runtime. This is commonly achieved in three ways:\n• Separate your modules into \"core\" and \"binding\". For the \"core\", focus on pure JavaScript logic like computing the hash, without any DOM, network, filesystem access, and expose utility functions. For the \"binding\" part, you can read from and write to the global context. For example, the \"browser binding\" may choose to read the value from an input box, while the \"Node binding\" may read it from , but values read from either place will be piped to the same core function and handled in the same way. The core can be imported in every environment and used in the same way, while only the binding, which is usually lightweight, needs to be platform-specific.\n• Detect whether a particular global exists before using it. For example, if you test that , you know that you are probably in a Node.js environment, and should not read DOM. // myModule.js let password; if (typeof process !== \"undefined\") { // We are running in Node.js; read it from `process.env` password = process.env.PASSWORD; } else if (typeof window !== \"undefined\") { // We are running in the browser; read it from the input box password = document.getElementById(\"password\").value; } This is preferable if the two branches actually end up with the same behavior (\"isomorphic\"). If it's impossible to provide the same functionality, or if doing so involves loading significant amounts of code while a large part remains unused, better use different \"bindings\" instead.\n• Use a polyfill to provide a fallback for missing features. For example, if you want to use the function, which is only supported in Node.js since v18, you can use a similar API, like the one provided by . You can do so conditionally through dynamic imports: // myModule.js if (typeof fetch === \"undefined\") { // We are running in Node.js; use node-fetch globalThis.fetch = (await import(\"node-fetch\")).default; } // … The variable is a global object that is available in every environment and is useful if you want to read or create global variables within modules. These practices are not unique to modules. Still, with the trend of code reusability and modularization, you are encouraged to make your code cross-platform so that it can be enjoyed by as many people as possible. Runtimes like Node.js are also actively implementing web APIs where possible to improve interoperability with the web."
    },
    {
        "link": "https://docs.ckan.org/en/latest/contributing/frontend/javascript-module-tutorial.html",
        "document": "CKAN makes heavy use of modules to add additional functionality to the page. Essentially all a module consists of is an object with an and method.\n\nHere we will go through the basic functionality of building a simple module that sends a “favourite” request to the server when the user clicks a button.\n\nThe idea behind modules is that the element should already be in the document when the page loads. For example our favourite button will work just fine without our module JavaScript loaded. Here it’s the that tells the CKAN module loader to create a new instance for this element.\n\nModules reside in the javascript/modules directory and should share the same name as the module. We use hyphens to delimit spaces in both filenames and modules. A module can be created by calling : We pass in the module name and a factory function that should return our module object. This factory gets passed a local jQuery object and a translation object. In order to include a module for page render inclusion within an extension it is recommended that you use within your templates. See the Assets Documentation Once ckan has found an element on the page it creates a new instance of your module and if present calls the method. Here we can set up event listeners and other setup functions. initialize: function () { // Grab our button and assign it to a property of our module. this.button = this.$('button'); // Watch for our favourite button to be clicked. this.button.on('submit', jQuery.proxy(this._onClick, this)); }, _onClick: function (event) {} Now we create our click handler for the button: And this calls a method. It’s generally best not to do too much in event handlers it means that you can’t use the same functionality elsewhere. This submits the dataset to the API but ideally we want to tell the user what we’re doing. // The client on the sandbox should always be used to talk to the api. // Notify allows global messages to be displayed to the user. Displaying an id to the user isn’t very friendly. We can use the attributes to pass options through to the module. This will override the defaults in the options object. \"this dataset is: my dataset\" When ever we make an Ajax request we want to make sure that we notify the user if the request fails. Again we can use to do this. You may have noticed we keep making calls to within these methods. This is to ensure that when the callback is called is the module it belongs to. We have a shortcut method called that can be used in the method to do all the binding at once. It can accept method names or simply a regexp."
    },
    {
        "link": "https://stackoverflow.com/questions/48129365/how-to-create-module-in-javascript",
        "document": "You can read good article explain what are module how you can implement it. https://medium.freecodecamp.org/javascript-modules-a-beginner-s-guide-783f7d7a5fcc\n\nYou can you use the above module shown below"
    },
    {
        "link": "https://docs.ckan.org/en/2.10/contributing/frontend/javascript-module-tutorial.html",
        "document": "CKAN makes heavy use of modules to add additional functionality to the page. Essentially all a module consists of is an object with an and method.\n\nHere we will go through the basic functionality of building a simple module that sends a “favourite” request to the server when the user clicks a button.\n\nThe idea behind modules is that the element should already be in the document when the page loads. For example our favourite button will work just fine without our module JavaScript loaded. Here it’s the that tells the CKAN module loader to create a new instance for this element.\n\nModules reside in the javascript/modules directory and should share the same name as the module. We use hyphens to delimit spaces in both filenames and modules. A module can be created by calling : We pass in the module name and a factory function that should return our module object. This factory gets passed a local jQuery object and a translation object. In order to include a module for page render inclusion within an extension it is recommended that you use within your templates. See the Assets Documentation Once ckan has found an element on the page it creates a new instance of your module and if present calls the method. Here we can set up event listeners and other setup functions. initialize: function () { // Grab our button and assign it to a property of our module. this.button = this.$('button'); // Watch for our favourite button to be clicked. this.button.on('submit', jQuery.proxy(this._onClick, this)); }, _onClick: function (event) {} Now we create our click handler for the button: And this calls a method. It’s generally best not to do too much in event handlers it means that you can’t use the same functionality elsewhere. This submits the dataset to the API but ideally we want to tell the user what we’re doing. // The client on the sandbox should always be used to talk to the api. // Notify allows global messages to be displayed to the user. Displaying an id to the user isn’t very friendly. We can use the attributes to pass options through to the module. This will override the defaults in the options object. \"this dataset is: my dataset\" When ever we make an Ajax request we want to make sure that we notify the user if the request fails. Again we can use to do this. You may have noticed we keep making calls to within these methods. This is to ensure that when the callback is called is the module it belongs to. We have a shortcut method called that can be used in the method to do all the binding at once. It can accept method names or simply a regexp."
    },
    {
        "link": "https://academy.jahia.com/documentation/jahia-cms/jahia-8.2/developer/javascript-module-development/javascript-modules-under-the-hood-how-it-works",
        "document": "In this section, we will go under the hood of how JavaScript modules actually work in Jahia’s DXP. We will also dive deeper into some related technologies.\n\nThe central NPM packaging descriptor, the file, can contain scripts that are basically used to perform tasks such as building, deploying, or even watching the current project.\n\nThe NPM package manager is responsible for using the file, downloading all the required dependencies, and then executing the requested scripts.\n\nThe package manager can offer some useful tooling, such as the watch feature that makes it possible to have the package manager watch the project for any changes, and then launch scripts upon detected changes, that could rebuild and redeploy the changes to a server for testing.\n\nJahia, starting with version 8.2, is now capable of deploying JavaScript modules built using a package manager. Jahia by default uses the Yarn package manager, and although it is possible to use another one, it is usually a good idea to only use a single package manager across multiple projects to avoid maintenance complexities over time.\n\nOn deployment, NPM packages (in tgz file format) are dynamically transformed into OSGi bundles and then treated exactly the same way that Jahia handles regular OSGi bundles. This transformation has two main parts: file/folder relocation and metadata transformation.\n\nDuring the transformation process, the first step is to move some of the files coming from the NPM tgz package into directories inside an OSGi bundle that Jahia can then process and understand. The table below details which relocations are performed.\n\nThe metadata transformation process extracts the data from the file and copies it to the OSGi bundle descriptor file. The table below explains how the data is transformed:\n\nYarn is an established open-source package manager who manages dependencies in JavaScript projects. It assists with installing, updating, configuring, and removing package dependencies.\n\nOther package managers exist, the most notable one being NPM, which is provided directly by the NodeJS project. However, Yarn is usually more innovative and faster than NPM. You can find below a quick comparison table of NPM and Yarn.\n\nYarn is a project that is evolving quickly, and it has undergone a major rewrite in version 2. Currently, the most recent version of Yarn is version 4, and it is the recommended one to use for Jahia JavaScript modules. It is not recommended to use Yarn version 1 anymore.\n\nYarn 4 uses by default a new “linker” (a way to reference dependencies) that is called PnP, which might cause some issues with tools that don’t yet support Yarn 4 (such as the ), so PnP is deactivated in jahia's projects. But you can configure it by removing this line from the file :\n\nYou can find more information about nodeLinkers .\n\nFrom WebPack’s official website: “At its core, Webpack is a static module bundler for modern JavaScript applications. When Webpack processes your application, it internally builds a dependency graph from one or more entry points and then combines every module your project needs into one or more bundles, which are static assets from which to serve your content.”\n\nThe official definition is a little difficult to understand for people with less experience with JavaScript, so we will present a more generic one. WebPack is basically a script that is launched from an NPM package manager such as Yarn, and that will analyze all the project’s dependencies and resources and optimize them to build a more optimized version that will allow faster loading from a browser. It uses a configuration that can define different rules depending on the type of resources to “compile” such as JavaScript, CSS, SASS, and others. For example, it might aggregate all the JavaScript located in different files across a project to generate a single JavaScript file that will be faster to load as it requires fewer HTTP requests.\n\nJahia’s NPX project creator will automatically create projects that include WebPack as the default bundler and provide a default configuration that should fit most simple to medium complex projects (it even includes support for client-side JavaScript bundling).\n\nThe GraalVM JDK, and especially its GraalJS sub-project, are the underlying technologies that enable the functionality of Jahia’s JavaScript modules. We will now introduce all the different parts of these technologies, including some that are not used and why.\n\nGraalVM is a high-performance virtual machine designed to improve the efficiency and performance of Java applications. It extends the Java Virtual Machine (JVM) by introducing a new just-in-time compiler that is written in Java. GraalVM supports not only Java but also additional programming languages such as JavaScript, Ruby, Python, and R. It can run standalone or be embedded into other systems.\n\nGraalVM Native Image, part of GraalVM, allows for ahead-of-time (AOT) compilation of Java applications into standalone executable files. These native executables do not require a JVM to run, which reduces applications' startup time and memory footprint. However, since these executables compile at build time, they do not dynamically optimize at runtime, which traditional JVMs do. Also, they cannot be compatible with dynamic class-loading applications, such as OSGi applications and therefore Jahia DXP is not compatible with Native Image.\n\nGraalJS is a high-performance JavaScript runtime implemented on top of the GraalVM. It aims to provide better performance compared to Nashorn, the previous JavaScript engine bundled with JDK. GraalJS is fully ECMAScript 2019 compliant and supports Node.js applications and libraries.\n\nOpenJDK is the open-source implementation of the Java Platform, Standard Edition. It includes the Java Runtime Environment (JRE), the Java Development Kit (JDK), and the JVM. OpenJDK operates only Java applications and uses the HotSpot JVM with the Just-In-Time (JIT) compiler. In contrast, GraalVM offers a pluggable architecture that supports multiple languages and enables both JIT and AOT compilation strategies.\n\nNashorn was introduced in Java 8 as a replacement for the older Rhino JavaScript engine. It provided a JavaScript runtime in Java and was implemented as part of the JDK. However, Nashorn has been deprecated since Java 11 due to the advent of more efficient alternatives like GraalJS. Unlike Nashorn, GraalJS can interoperate with code written in other languages supported by GraalVM and provides better performance and support for modern JavaScript features.\n\nFor Jahia JavaScript modules, the DXP server must be configured to execute with GraalVM to take advantage of modern JavaScript features and improved performance. Although GraalVM offers the GraalVM Native Image feature, it is not compatible with OSGi (a fundamental framework used by Jahia for modularity). Consequently, Jahia does not utilize GraalVM Native Image. Although it is technically possible to use GraalJS without the full GraalVM JDK on top of OpenJDK, this combination comes at a performance cost and is not recommended for production.\n\nThe default Jahia Docker images come fully packaged with all necessary components for usage, including the configured GraalVM environment. This setup ensures that developers can use Jahia with minimal initial configuration and harness the full capabilities of GraalVM and its supported technologies right out of the box.\n\nThe initialization process of the npm-modules-engine module contains a lot of different steps that are summarized in the following sequence diagram:\n\nHere are the details of the steps:\n• The OSGi Framework requests the global variables factory from the . This factory is crucial for initializing global variables across JavaScript contexts.\n• The OSGi Framework calls the activate method of the , which triggers the engine to start its services and prepare for execution.\n• Within the , the main initialization script is retrieved. This script contains essential startup procedures for the engine. Initialization properties are also fetched. These properties configure the behavior and settings of the .\n• The initializes the , which manages the pooling of s, which is essential for managing multiple JavaScript execution contexts.\n• The instructs the to create s. These providers handle the creation and lifecycle management of JavaScript contexts.\n• The initializes JavaScript instances. These contexts are environments where JavaScript code is executed.\n• s are initialized with a JavaScript . Each provider manages a specific JavaScript , ensuring isolated execution environments.\n• Global variables are added to each JavaScript . These variables are typically shared across various scripts and provider helper classes to JavaScript code.\n• All relevant initialization scripts are executed within each JavaScript . This step is critical for setting up the environment, loading libraries, and performing startup tasks specific to the application's needs.\n• The OSGi Framework activates the object, which listens for changes in JavaScript modules, such as their loading and unloading.\n• The communicates with the to enable or disable modules.\n• The registers or unregisters the initialization scripts associated with different bundles. This ensures that each bundle's JavaScript environment is correctly set up or torn down.\n• The increments its version number whenever significant changes occur, such as adding or removing scripts. The version number is used to invalidate previously created s that might not contain the latest context for the currently deployed scripts.\n• The registers itself with the OSGi Framework as a so that it can reactivate to module deployment/undeployment\n• Upon a bundle change event signaled by the OSGi Framework, the reacts by enabling or disabling modules again, as necessary, ensuring that the system remains responsive to the changes in the module's lifecycle.\n• Similar to earlier steps, the continues to manage the registration of scripts and increment its version to reflect ongoing changes and ensure system integrity.\n• Browser to Jahia servlet: a request comes in for a page with a specific URL\n• Jahia Servlet to : the template node filter retrieves the template identifier for the page\n• The asks the ( ) is asked to resolve the JavaScript for the template\n• The returned asks the to render the template\n• The retrieves a from its pool and renders the template using the GraalJS JavaScript engine\n• While the template is rendered, it might call the or a React Component that may call the to render some views.\n• The will call the to resolve any views for the content that needs to be displayed.\n• The will return a to be executed\n• The will call the to render the view\n• The will retrieve a from its pool to render the view\n• The will render the view using the GraalJS JavaScript runtime\n• Once all the views for the template have been executed, they are aggregated in the template, and the final HTML is returned to the browser\n\nThe GraalVM engine serves as the core component for executing NPM plugin modules. It facilitates the creation of a pool of polyglot contexts, enabling the execution of JavaScript or any other language supported by GraalVM.\n\nThe service consists of a shared GraalVM Engine and a pool of JavaScript (JS) polyglot contexts (aka Context Pool). JavaScript code can be executed within these polyglot contexts. It's important to note that polyglot contexts are not thread-safe and should only be utilized by a single thread at a time. To accommodate multiple threads executing JavaScript in different contexts, we provide a pool of instances, each containing a polyglot context. When a new context is created, global variables from Java objects are bound, facilitated by instances of . Initialization scripts - including the main script from which initializes available frameworks and provides polyfills - are executed with each new context creation. Additionally, every NPM plugin provides its own initialization script executed on context creation. In order to properly manage script changes, a local version number is incremented whenever a new script is added or removed, indicating outdated contexts that should be removed from the pool.\n\nThe engine can be configured using the configuration file. Keys prefixed by are passed as options to the engine builder. For instance, enables experimental features, while enables the JavaScript debugger. All available options can be explored using shell commands installed by the GraalVM SDK.\n\nA bundle listener, , listens to starting and stopping bundles. When a bundle is started, the following flow is executed:\n• Check for the presence of a at the root level with a entry, indicating an NPM module.\n• The initialization script that is referenced by the entry is a single executable JS file compiled with Webpack and is added to the list of scripts for execution.\n• An internal version number is incremented to invalidate existing contexts in the pool.\n• A new context is obtained from the pool, and all available registrars are called to register Jahia extensions by transforming JS objects in the registry into OSGi services.\n\nWhen a bundle is stopped, the script is unregistered, and the version number is incremented to invalidate existing contexts.\n\nNote: Initialization scripts initialize the JavaScript context immediately after creation, rather than executing code on module start. These scripts are called whenever a JavaScript context needs to be created.\n\nJahia uses PAX-URL to handle URLs to OSGi bundles. The introduces a new npm protocol ( ). This protocol acts as a wrapper around any other protocol, enabling the installation of NPM modules with URLs like or . You can learn more about PAX URL here:\n\nThis setup enables the use of in the JavaScript context. Translations are directly read from within the current bundle.\n\nJahia uses a Javascript object registry to share objects between various scripts. The registry is similar to an OSGi service registry for those familiar with OSGi. Here is the interface of the registry:\n\nRegistrars play a crucial role in parsing NPM modules to detect and register specific extensions, typically written in JavaScript or any language requiring the GraalVM engine. They are invoked when an NPM plugin is started, following the execution of the initialization script.\n\nHere is the interface for a Registrar:\n• The dynamically registers and unregisters JavaScript-defined render filters. It manages lifecycle events to ensure filters are available as services when needed and are properly cleaned up on bundle deactivation.\n• The handles the registration and management of JavaScript views and templates, integrating them into Jahia's rendering pipeline as part of the template and script resolution processes.\n\nThe render filter registrar's objective is to register \"render filters\" written in JavaScript, sourced from the registry with the type. It accomplishes this by creating an OSGi service ( ) that delegates to the JS prepare/execute functions.\n\nRender filters can be added to the registry in the form of a pair of two methods: and .\n\nThe target must be rendered, followed by the filter priority.\n\nThe in Jahia’s npm-modules-engine is a versatile class responsible for dynamically managing JavaScript views within the context of OSGi bundles. It functions as both a and , identifying and applying appropriate JavaScript scripts and templates to content resources based on their context. Upon bundle activation, it registers JavaScript views by scanning the bundle, parsing files, and storing representations, which are then made available for rendering. Conversely, it unregisters these views upon bundle deactivation to maintain system integrity and free resources. The registrar optimizes performance through caching mechanisms, speeding up the resolution process and responding efficiently to system events that require cache updates. This integration allows for a seamless blend of traditional Java-based management and modern JavaScript-driven web technologies within Jahia’s platform, enhancing content management capabilities and rendering flexibility.\n\nAlthough it is possible to use Java classes from JavaScript, there are some limitations around this functionality as well as some good reasons as to why this shouldn’t be done systematically. In general it is better to provide additional functionality to JavaScript modules through Java modules provides new JavaScript helper functions (see next section about how to do this) for security and maintenance reasons.\n\nThe built-in mechanism that GraalJS provides for accessing Java class is illustrated in the following example:\n\nWe can see in this example that a statement is provided by GraalJS to enable access to a Java class.\n\nImportant class accessibility limitation: This mechanism only works with Java classes provided by Jahia’s core. It will not work with classes packaged and exposed by modules."
    },
    {
        "link": "https://medium.com/@robwierzbowski/organizing-css-in-js-f43c4ad65b2f",
        "document": "With our elements and selectors transformed, we can treat each component’s stylesheet as an isolated environment. The selectors we write can be terse and expressive, and still only apply in the small, contained context we expect.\n\nThough our styles are programmatically scoped, a naming convention is still useful to distinguish between types of classes in our component stylesheets. When reading a stylesheet, CSS properties and values show us what each ruleset does; class names should describe where, when, and why we’re applying them.\n\nI choose to make a distinction between element, modifier, and state classes. These categories help break styles into single responsibility rulesets, and improve our ability to understand, maintain, refactor, and delete CSS. They help us clearly communicate the intent of our classes to collaborators and our future selves.\n\nLet’s illustrate each of these types with a pretend component. We want to render a compact version of the component, and apply loading styles to the user image until a high res version downloads. I use double and single dashes to indicate modifier and state, but the format doesn’t matter as long as the difference is obvious when skimming a file.\n\nElement classes apply basic, unmodified styles to a single element in the template. They are not atomic or helper classes; each HTML element references only one Element class.\n\nModifier classes apply an alternate style to an element or its descendants, and are static over the lifetime of the instance. They’re set on creation of a component instance. Modifier classes always modify an existing Element class — they never exist on their own.\n\nState classes apply an alternate style to an element or its descendants, and are added and removed during the lifetime of the component. State styles represent a particular state of the system, often the result of a user or server action. State classes always modify an existing Element class — they never exist on their own.\n\nWhere CSS Modules and Scoped Styles isolate, PostCSS variables and mixins can be used to share values and declarations between stylesheets.\n\nIn other systems we may have shared styles with utility or helper classes. Sharing via classes requires global scope, which doesn’t mesh well with scoped, CSS-in-JS systems. Utility classes should be abandoned.\n\nRepeated, standardized values can be shared with variables. PostCSS Simple Vars allow us to define compile-time variables in a stylesheet, which can then be exposed in component stylesheets using PostCSS Import.\n\nGood candidates for variables include complex, repeated values like colors and font-families.\n\nNote: CSS custom properties serve a different purpose than compile-time variables. Use compile time variables for static, repeated values; use custom properties for values that change during runtime.\n\nGroups of repeated styles can be shared with mixins. PostCSS Mixins adds the ability to define a block of declarations, then apply it in any number of selectors or other mixins. I store related mixins in small, single purpose files like , , and . Just like variables, mixins stylesheets are imported into component stylesheets using PostCSS Import.\n\nGood candidates for mixins include type sizes and treatments, form styles, theme helpers, and other complex rulesets shared between components.\n\nMixins should be constructed for maximum compositional reuse. I keep box model properties (margins and padding especially) out of mixins; it’s my experience that spacing, especially when connected to text, is rarely standardized site wide. That’s a personal choice — whatever you decide to include, take care that component styles aren’t often overwriting the mixins they use.\n\nEven though we’re working in a component based, scoped system, there’s still opportunity for tangled, hard to maintain CSS. This is especially true with CSS layout. No matter how perfectly we modularize our code, our users experience a site as pages, not components in isolation. Layouts are designed from the page in, not the component out, and responsive layout is built on viewport size (at least until container queries become a reality).\n\nIn order to avoid common interdependencies and entanglements, we need to define clear boundaries for layout code in parent and child components.\n\nIn order to be reusable, a component should never define layout styles on its root element. It should never give itself a , , , , or .\n\nWhen rendered in a parent component, a child component should act like a standard inline or block HTML element. One with an inline root element expands naturally to contain its content. One with a block level root element takes up 100% of its container.\n\nA component uses its own HTML to manage internal layout\n\nA component can only write style rules for HTML in its template. It can never use selectors that target child component elements (that would break our carefully constructed CSS scope).\n\nThis often requires child components to be rendered in a wrapper element. I know we hate wrapper elements, but these ones are good, trust me. They help keep all of our layout styles in the parent component.\n\nThe parent can add modifier classes on the child component, to apply alternate child component layout, colors, et cetera. The modifier styles are defined in the child component.\n\nSome CSS layout modules, e.g., Flexbox and Grid, have related container/item properties. If you create a Flexbox or Grid container in a component, any item or child styles must be applied to elements in the same component. Never split container and item declarations between components.\n\nDefining in a parent component and or values in a child component breaks isolation, limits reuse, and is gonna cause a big bucket of other problems. Use a wrapper element to avoid this can of worms.\n\nLet’s look at an example\n\nIn the component, we can add styles to , , , and classes.\n\nThe unordered list can be laid out with flexbox, and list items can have flex item styles.\n\nshould not include any of the blacklisted external layout styles. Neither should the root element in the component.\n\nThe component can use the prop to apply a modifier class, and use that to modify its internal layout for this context.\n\nAs we move from general to specific² areas in the application, styles should be added, not reset to previous values. Resetting to a previous or default value creates dependencies and entanglements between selectors, and over time causes a dark combo of unnecessary and dead code.\n\nLet’s look at an example of adding styles inside a component, and how the technique of forking classes can keep our styles additive. First, a bad example:\n\nThis is no good. We’re resetting and to default values, and unnecessarily re-declaring some styles. Every time we revise element styles there’s a chance we’ll have to update or delete declarations in .\n\nIn this case we can make our styles additive by forking the modifier:\n\nNice! Now our styles are additive. The element class contains only the styles shared between all modifications, and modifiers add their additional styles. We can safely edit or delete each selector in isolation. Forking is useful for any alteration of an element class: modifiers, states, and media queries.\n\nIn a real application it’s rarely possible to code purely additive CSS. Often, there’s a tension between DRY styles and additive styles. It’s OK to have a here and there, but attempting to keep styles additive will improve an application’s maintainability over a long period of time.\n\nWell, that ended up a bit longer than I expected. I hope you find this collection of ideas and experiences useful. If you have any thoughts, please leave a comment, or write me on Twitter at @robwierzbowski (where I tweet about code slightly more than none of the time).\n\nIf you’d like to share this article, here’s my original tweet. 👋🏼"
    },
    {
        "link": "https://stackoverflow.com/questions/23193248/how-to-manage-css-and-js-files-structure-in-web-application-custom-vs-plugins",
        "document": "I searched over the internet but I could not find an answer to my question. I am just trying to figure out a clean way to structure my CSS and JS files inside my project. Let us say for example I have a folder and I have a custom my.css file and also I have a folder and I have inside it a . I understand that will go in the folder and will go under the folder in this folder setup :\n\nMy question is, if I want to use a jQuery plugin like jstree for example. This library require me to add one js and one css file. Should I keep these files under the and folder ?\n\nOr should I separate them into a different folder for cleaner structure like this\n\nIs this structure acceptable? Any standard ways for achieving this ?\n\nAny help is appreciated."
    },
    {
        "link": "https://reddit.com/r/reactjs/comments/18fr47x/how_do_you_structure_individual_css_files_for",
        "document": "Hi! I would love to know how you structure individual CSS files for each component in your project and what are the best practices.\n\nSo I'm thinking these scenarios in my mind:\n• Creating individual CSS files for each component under folder then\n• Importing all of them in one file\n• Importing them individually in each component\n• Creating individual folder for each component under then creating both files and files for that component under that folder and importing the to the respective file.\n\nI would love to know which one of these is the best practice and how you structure it. Thank you for your time. Cheers."
    },
    {
        "link": "https://blog.pixelfreestudio.com/advanced-css-techniques-for-building-modular-stylesheets",
        "document": "CSS is a powerful tool for web designers, allowing us to create beautiful and responsive websites. But as projects grow, our stylesheets can become unwieldy and hard to manage. That’s where modular CSS comes in. By breaking down our styles into manageable, reusable pieces, we can keep our code clean and maintainable. In this article, we’ll explore advanced CSS techniques to build modular stylesheets, helping you create efficient and scalable web designs.\n\nModular CSS is all about dividing your CSS into smaller, reusable components. Instead of having one giant stylesheet, you break it down into modules that can be reused across different parts of your website.\n\nThis approach makes it easier to manage and update your styles.\n\nModular CSS offers several advantages. First, it promotes reusability, which saves time and effort. You can apply the same styles to multiple elements without duplicating code. Second, it improves maintainability.\n\nWith modular CSS, you can update a single module without affecting the entire stylesheet. This reduces the risk of introducing bugs and makes it easier to manage your codebase.\n\nTo build modular stylesheets, start by organizing your CSS logically. Group related styles together and use clear, descriptive names for your classes and IDs.\n\nThis helps you quickly find and update specific styles when needed.\n\nCSS preprocessors like Sass and LESS are invaluable tools for modular CSS. They allow you to use variables, mixins, and nested rules, making your stylesheets more modular and easier to maintain.\n\nFor example, you can define a color palette with variables and reuse them throughout your stylesheets.\n\nBase styles are the foundation of your modular CSS. These include global styles for typography, colors, and layout. By defining consistent base styles, you ensure a cohesive look and feel across your website.\n\nUtility classes are small, reusable classes that apply specific styles. For example, you might have utility classes for margin, padding, or text alignment.\n\nThese classes can be applied to any element, making it easy to adjust styles without writing new CSS.\n\nComponents are the building blocks of your website. They include buttons, forms, cards, and other UI elements. When creating component styles, focus on making them self-contained and reusable.\n\nUse class names that clearly describe the component and its purpose.\n\nWhile utility classes are useful, it’s important not to overuse them. Too many utility classes can make your HTML cluttered and difficult to read.\n\nStrike a balance between using utility classes and writing custom styles for specific components.\n\nHigh specificity can make your stylesheets hard to manage. Avoid using overly specific selectors, such as IDs and inline styles. Instead, use class selectors and keep your specificity as low as possible.\n\nThis makes it easier to override styles and maintain consistency.\n\nDependencies between modules can lead to tangled code. Minimize dependencies by keeping modules self-contained and independent.\n\nIf modules need to share styles, use mixins or extend existing classes rather than creating direct dependencies.\n\nCSS Grid and Flexbox are powerful layout tools that can simplify your CSS and make it more modular. With Grid, you can create complex layouts with a few lines of code, making it easier to build reusable components.\n\nFlexbox, on the other hand, is perfect for aligning items within a container. Both techniques reduce the need for complex float-based layouts, resulting in cleaner, more modular CSS.\n\nCSS variables, also known as custom properties, allow you to store values in your CSS that can be reused throughout your stylesheets. This is incredibly useful for maintaining consistency and making global changes.\n\nFor example, you can define a primary color as a variable and use it across multiple components. Changing the variable updates the color everywhere it is used.\n\nMixins are a feature of CSS preprocessors like Sass and LESS that let you define reusable chunks of CSS. Mixins can include properties, selectors, and even other mixins. By using mixins, you can avoid repeating code and keep your stylesheets DRY (Don’t Repeat Yourself).\n\nThey are especially useful for common patterns like buttons or form elements.\n\nThe BEM (Block, Element, Modifier) methodology is a popular naming convention for writing modular CSS. It helps you create reusable and maintainable components by breaking them down into blocks, elements, and modifiers.\n\nA block is a standalone component, an element is a part of a block, and a modifier is a variation of a block or element. BEM encourages consistency and predictability in your stylesheets.\n\nAtomic Design is a methodology for creating design systems. It breaks down interfaces into fundamental building blocks: atoms, molecules, organisms, templates, and pages. Atoms are the smallest building blocks, such as buttons or input fields. Molecules are groups of atoms that form more complex components, like a search form.\n\nOrganisms are groups of molecules that form distinct sections of an interface, like a header or footer. Templates are wireframes that combine organisms into page layouts, and pages are instances of templates with real content. Using Atomic Design principles helps create a modular and scalable CSS architecture.\n\nDesign tokens are a way to store design decisions such as colors, typography, spacing, and more in a central location. They can be used across multiple platforms, ensuring consistency and maintainability. By using design tokens, you can create a single source of truth for your design system.\n\nThis makes it easier to update styles and ensures consistency across different parts of your application.\n\nTo illustrate these concepts, let’s build a modular button component. Start by defining base styles for buttons, such as padding, border, and font size. Use CSS variables for colors and other values that might change.\n\nNext, create utility classes for different button states, like hover and active. Finally, use mixins to apply these styles to different button variations, such as primary, secondary, and disabled buttons.\n\nA flexible grid system is essential for building responsive layouts. Define grid container styles using CSS Grid or Flexbox. Create utility classes for different grid configurations, such as columns, gaps, and alignments.\n\nUse CSS variables to manage spacing and other values. This approach allows you to create complex layouts with simple, reusable classes.\n\nModular CSS should work across different browsers and devices. Test your stylesheets in various environments to ensure compatibility. Use tools like BrowserStack or Sauce Labs to automate cross-browser testing.\n\nIf you encounter issues, use feature queries and fallbacks to ensure your styles degrade gracefully.\n\nOptimizing the performance of your CSS is crucial for a fast-loading website. Minimize the size of your stylesheets by removing unused CSS and compressing your files.\n\nUse tools like PurgeCSS to automatically remove unused styles. Additionally, consider using a CSS-in-JS solution like styled-components or Emotion for better performance and maintainability.\n\nA clean codebase is essential for maintaining modular CSS. Regularly review your stylesheets to remove unused or redundant code. Use consistent naming conventions and organize your files logically.\n\nThis makes it easier for you and your team to understand and work with the code.\n\nDocumenting your CSS is crucial for long-term maintainability. Use comments to explain complex or non-obvious code. Create documentation for your design system, including descriptions of components, utility classes, and design tokens.\n\nThis helps new team members get up to speed quickly and ensures consistency across your project.\n\nUse version control systems like Git to manage changes to your CSS. This allows you to track changes, collaborate with team members, and roll back to previous versions if needed.\n\nUse branching and pull requests to manage new features and bug fixes. This ensures that your codebase remains stable and allows for smooth collaboration.\n\nCSS frameworks and libraries can provide a solid foundation for your modular CSS. Frameworks like Bootstrap and Foundation offer pre-built components and utility classes that can speed up your development process.\n\nLibraries like Tailwind CSS provide a utility-first approach that aligns well with modular CSS principles.\n\nCSS linting and formatting tools help you maintain consistent and error-free stylesheets. Tools like Stylelint and Prettier can automatically check your code for errors and enforce formatting rules.\n\nIntegrate these tools into your development workflow to catch issues early and maintain a clean codebase.\n\nCSS-in-JS solutions, such as styled-components and Emotion, allow you to write CSS directly within your JavaScript files. This approach offers several benefits, including scoped styles, better performance, and easier maintenance.\n\nCSS-in-JS is especially useful for component-based frameworks like React and Vue.js.\n\nUtility-first frameworks like Tailwind CSS are gaining popularity for their simplicity and flexibility. These frameworks provide a large set of utility classes that can be combined to create any design.\n\nThis approach aligns well with modular CSS principles and can speed up development.\n\nCSS Houdini is a set of low-level APIs that give developers more control over the CSS rendering process. Houdini allows you to create custom properties and functions, making it easier to create advanced styles and animations.\n\nAs Houdini becomes more widely adopted, it will open up new possibilities for modular CSS.\n\nCSS-in-JS solutions are becoming more popular, especially in the React and Vue.js ecosystems. These solutions offer scoped styles, better performance, and easier maintenance.\n\nAs more developers adopt component-based frameworks, CSS-in-JS will continue to play a significant role in modular CSS.\n\nReact’s component-based architecture aligns perfectly with modular CSS principles. Each React component can have its own stylesheet, making it easier to manage styles.\n\nTools like styled-components and Emotion enable you to write CSS directly within your JavaScript files. This approach ensures that styles are scoped to their respective components, reducing the risk of style conflicts.\n\nIn this example, is a styled component with its styles defined using template literals. The styles are scoped to the component, ensuring modularity and maintainability.\n\nVue.js also supports a component-based architecture, making it a great fit for modular CSS. Vue’s single-file components allow you to include HTML, JavaScript, and CSS in a single file.\n\nScoped styles in Vue ensure that the styles are applied only to the specific component, preventing unintended side effects.\n\nIn this Vue component, the tag with the attribute ensures that the styles are applied only to the component, maintaining modularity.\n\nWeb Components are a set of web platform APIs that allow you to create custom, reusable HTML elements. They encapsulate their styles and functionality, ensuring that they are self-contained and modular.\n\nUsing Shadow DOM, you can encapsulate the styles and markup of your components, preventing style conflicts with the rest of your application.\n\nIn this example, the Web Component uses Shadow DOM to encapsulate its styles and markup, ensuring modularity and preventing style leakage.\n\nCSS Grid Layout is a powerful tool for creating complex, responsive layouts. By defining grid containers and grid items, you can create layouts that are both flexible and modular.\n\nCSS Grid is especially useful for building layouts with multiple columns and rows, making it easier to create consistent designs.\n\nIn this example, the grid layout adjusts the number of columns based on the available space, ensuring a responsive and modular design.\n\nFlexbox is another powerful layout tool that allows you to create flexible and responsive designs. Flexbox is ideal for aligning items within a container and distributing space between them. By using Flexbox, you can create modular layouts that adapt to different screen sizes and content.\n\nIn this example, the flex items adjust their size and wrap to the next line when there is not enough space, ensuring a flexible and modular layout.\n\nAdvanced Techniques and Best Practices for Modular CSS\n\nCSS custom properties, also known as CSS variables, provide a way to store values that can be reused throughout your stylesheets. This technique enhances modularity by allowing you to manage design tokens, such as colors and spacing, in a centralized manner.\n\nThis makes it easy to update and maintain your styles.\n\nIn this example, the custom properties are defined at the level, making them available throughout the entire stylesheet. This approach allows for consistent design and easy updates.\n\nOptimizing the size of your CSS files can significantly improve the performance of your website. Tools like PurgeCSS can help you remove unused CSS, reducing the file size.\n\nAdditionally, minifying your CSS files using tools like CSSNano or CleanCSS can further enhance performance by removing whitespace and comments.\n\nPurgeCSS analyzes your HTML and JavaScript files to determine which CSS selectors are actually used. It then removes unused selectors from your CSS files, reducing their size.\n\nIn this configuration, PurgeCSS is used in conjunction with CSSNano to minify and optimize your CSS files.\n\nPostCSS is a tool that allows you to use plugins to transform your CSS. It offers a wide range of plugins that can help you write more modular and maintainable CSS.\n\nFor example, you can use Autoprefixer to add vendor prefixes automatically, ensuring cross-browser compatibility.\n\nExample: Using PostCSS with Autoprefixer\n\nIn this example, Autoprefixer and the postcss-nested plugin are used to enhance the functionality of your CSS, making it more modular and maintainable.\n\nEnsuring that your CSS adheres to the DRY principle is crucial for maintainability. Avoid duplicating styles by using mixins, functions, and extends provided by CSS preprocessors like Sass.\n\nIn this example, the mixin is used to define reusable button styles, reducing duplication and ensuring consistency.\n\nTesting your CSS is essential for ensuring that your styles work as expected across different browsers and devices. Tools like BackstopJS can help you perform visual regression testing, identifying any unintended changes in your styles.\n\nBackstopJS captures screenshots of your website and compares them against baseline images, highlighting any visual differences.\n\nIn this configuration, BackstopJS is set up to test the homepage on both desktop and mobile viewports, ensuring that your styles look correct on different devices.\n\nStaying up-to-date with new CSS features ensures that your stylesheets remain modern and efficient. Features like CSS Grid, Flexbox, and custom properties provide powerful tools for building modular and responsive designs.\n\nKeep an eye on emerging CSS specifications and browser support to incorporate these features into your projects.\n\nThe field of web development is constantly evolving. To stay ahead, continuously learn and adapt to new tools, techniques, and best practices. Participate in web development communities, attend conferences, and follow industry blogs to keep your skills sharp and up-to-date.\n\nSingle Page Applications (SPAs) often require a unique approach to CSS due to their dynamic nature and component-based structure. Implementing modular CSS in SPAs can greatly enhance maintainability and performance.\n\nIn a React SPA, each component can have its own scoped CSS. Tools like styled-components or Emotion allow you to write CSS-in-JS, ensuring styles are tightly coupled with their respective components.\n\nIn this example, the component has its styles defined using styled-components, ensuring that the styles are modular and scoped to the component.\n\nLarge-scale projects can benefit significantly from a modular CSS approach. By breaking down styles into smaller, reusable components, you can manage complexity and ensure consistency across the project.\n\nFor a large-scale project, organize your CSS files into a clear and logical structure. This might involve creating directories for base styles, components, utilities, and themes.\n\nEach of these files should focus on a specific aspect of your styles, promoting modularity and maintainability. For example, might contain all styles related to button components, while includes reusable mixins.\n\nDesign tokens are a great way to manage styles in a large project. They provide a single source of truth for design decisions, ensuring consistency across different parts of the application.\n\nIn this example, design tokens are defined in and used throughout the project, ensuring consistency and making it easy to update styles globally.\n\nE-commerce websites often have complex layouts and a wide variety of components. Modular CSS can help manage this complexity and ensure a consistent look and feel.\n\nProduct cards are a common component in e-commerce websites. Using a modular approach, you can create reusable and consistent styles for these components.\n\nIn this example, the class encapsulates all styles related to the product card component, ensuring modularity and reusability.\n\nDesign systems provide a comprehensive approach to maintaining design consistency and modularity across an entire organization. By integrating a design system with your CSS, you can ensure that your styles are scalable and maintainable.\n\nStart by defining core principles and components in your design system. Use design tokens for colors, typography, and spacing, and create reusable components for common UI elements.\n\nIn this example, the design system includes base styles, components, and utilities. Each component uses mixins and design tokens to ensure consistency and modularity.\n\nBuilding modular CSS is essential for creating scalable, maintainable, and efficient web designs. By using advanced techniques such as CSS Grid, Flexbox, CSS variables, and adopting methodologies like BEM and Atomic Design, you can ensure your styles are clean and organized. Embracing tools like CSS preprocessors, CSS-in-JS solutions, and design tokens enhances modularity and consistency across your projects.\n\nWhether you’re working on single-page applications, large-scale projects, or e-commerce websites, modular CSS allows for better maintainability and performance. Continuously learning and adapting to new trends and technologies will keep your CSS effective and future-proof.\n\nBy integrating modular CSS with modern frameworks and maintaining a clean codebase, you can create responsive, accessible, and beautiful websites that provide an excellent user experience and streamline the development process."
    },
    {
        "link": "https://stackoverflow.com/questions/10807141/html-css-modules-best-practice",
        "document": "I'm starting to pull out independent pieces of HTML into their own files and include them using the PHP keyword.\n\nI have a CSS file about 1500 lines long. What' I'm considering doing is placing embedded CSS with the corresponding HTML files.\n\nOf course leaving components that are used in different HTML blocks.\n\nThis way I have modular HTML / CSS blocks that I just include on the server using PHP\n\nIs this best practice? Yes/No, Why"
    }
]