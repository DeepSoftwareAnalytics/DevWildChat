[
    {
        "link": "https://github.com/coryrylan/reusable-ui-component-api-guide",
        "document": "Define and outline API best practices for creating highly reusable UI components that work in any Web framework or library. These recommendations are ideal for stateless components commonly used in UI component libraries and design systems.\n\nThis guidance is not intended to define best practices around UI component API design in the use cases for high-level application UI components and state. However, many of the best practices described here may still be applicable.\n\nOver the years, I have worked in various aspects of design systems, open source, and maintenance of UI libraries. You can find other related resources and guides in the list below.\n• 🚧 Warning: risks of not following guidance\n• 📘 Tip: details on reasoning or rationale for guidance\n\nConsistent API design improves not only the developer experience but also the consistency and compatibility across various UI frameworks and libraries. This guide focuses on building reusable UI via Web Components to ensure maximum compatibility across the Web ecosystem. While the code examples are Web Component focused, most of the concepts also apply to framework-specific component models.\n\nCustom Elements are registered to a global scope. This means collisions can occur if two elements attempt to register using the same tag name. To minimize this risk, prefix the element unique to your application or library.\n\n🎓 Learn: A Scoped Element Registry spec is in progress with an experimental polyfill. Lit also provides an experimental integration @lit-labs/scoped-registry-mixin.\n\nProperties and attributes should represent the visual state of a component. There are various types of states, but most fall under the following:\n\nProperties and attributes can represent the same value and \"reflect\" or keep in sync between the two.\n\nAvoid creating \"impossible states\" in your component APIs. Impossible states are typically caused by different API options describing the same visual state.\n\nBy leveraging attribute or property values, we can create enum-style APIs that prevent impossible states, such as an alert being both in a success and warning state.\n\nMany Web Component authoring libraries, such as lit, can easily keep attributes and properties in sync. This allows your component APIs to accept data with HTML attributes or JavaScript properties. However, HTML attributes are always treated as a string values. Because of this behavior, only use complex types such as and when setting properties.\n\nFrameworks have property binding syntax that allows the JavaScript property to explicitly be set rather than the attribute.\n\nComplex types should be avoided for highly reusable UI components as they can cause compatibility and usability issues requiring explicit JavaScript to define and render content. In addition, this can make the component challenging to use for user-generated content in CMS systems or SSR/low code applications that typically render static HTML.\n\nFollowing the native HTML boolean attribute rules can make your components consistent and easy to use across frameworks. Boolean style attributes in HTML are truthy when present and falsy when absent.\n\n🚧 Warning: Avoid double negations with APIs as it breaks common expectations with boolean behavior in HTML. ( , )\n\nEvents communicate user intent. Examples of custom user events can include , , . Events should remain stateless by emitting based on user interactions with the component and not from component state changes.\n\nAvoid using verb/action prefixes to events such as . Most frameworks de-sugar event handlers or auto-prefix the event name within the syntax. For example Angular and Preact .\n\n🚧 Warning: For maximum compatibility use lower case events as some frameworks incorrectly ignore case sensitivity with Custom Events.\n\n🚧 Warning: Avoid overriding existing event names from . Overloading events can break behavior and expectations with components. Example: eslint rule.\n\nSlot or content projection enables a flexible API for consumers to provide dynamic content within a component. Slots are ideal for any content an application may render. Slots are commonly used in container-style components such as cards and tabs. Slots give complete control of the content to the host application in ways that properties and attributes would be limiting.\n\n📘 Tip: If the text content is visible to the user then likely the API should use a slot\n\n📘 Tip: Slots enable consumers to use the i18n solution of their choice\n\nAllowing composition makes API flexible to different i18n solutions and use cases that properties or attributes would prevent.\n\nProviding reasonable defaults for a component to improve the developer experience is important. However, sometimes the defaults themselves need to be customized. For example, an alert message may have different status states (e.g., success, warning, danger), each displaying a different icon within the alert. In these cases, it may be necessary to customize the component's default behavior to meet the application's specific needs.\n\nWe can leverage default slots to provide customization hooks to avoid the risk of the alert element absorbing parts of the icon API (as discussed above). This allows the alert component to internally provide default icons for different status states while allowing developers to customize the icons as needed. Using default slots, we can mitigate the risk of tightly coupled APIs and maintain a clear separation of concerns between the alert and icon elements.\n\nSlots can provide default content if no content is provided. For example, in an alert element, we can set an internal icon with a status icon that matches the status of the alert. If consumers want to customize the icon, they can do so by projecting their icon into the icon slot, overriding the default. This enables complete control over the custom icon without the alert element needing to expose the icon through a series of inherited attributes and properties. As with all API design choices, tradeoffs are involved, and it is important to consider each approach's benefits and potential challenges.\n\nSlots can have names or specific locations where content should be rendered. Encapsulating named slots as custom elements allows for more declarative flexibility for the component.\n\nComposition-based APIs with slots allow consumers to determine the most appropriate rendering strategy. This is important for large lists of elements. For example, a treeview component theoretically may represent a dataset with hundreds or thousands of nodes.\n\nWith slots the host application can use the native rendering APIs.\n\nThis allows the app to make optimizations that the treeview cannot assume, such as what nodes to render safely.\n\nReusable components should remain as stateless as possible. The visual output of a component should represent the state passed into it via properties and attributes. In this example, we will use a dialog component.\n\nThe dialog component should render conditionally based on the application state. For example, we provide a event rather than defining an or property. The dialog will only emit the event when the user has clicked the close interaction. The event notifies and allows the host application to determine if the dialog should be hidden.\n\nThis subtle API difference prevents \"escape hatch\" APIs. If our dialog controls its visibility state, this can cause additional APIs to be needed. For example, suppose an application needs to validate a form before closing the dialog. In that case, we have to introduce some life cycle events such as to prevent the dialog from closing automatically by the user.\n\nSince we pushed the state to the application, the consumer has complete control of when and how the dialog should be rendered, including dynamically showing via the HTML attribute or conditionally rendering DOM.\n\n📘 Tip: Reusable and stateless test, \"Can you prototype/demo any visual state of the component with just HTML?\"\n\nStateless components prevent the UI state from becoming out of sync. For example, suppose the dialog component controls or modifies its visibility state. In that case, it can open up situations where the dialog state is closed, but the host application state keeps its dialog visibility marked as open.\n\nAvoid emitting events in response to state changes of a component. As a consumer of a component, this creates unnecessary noise. For example, if an app sets a component's state property, then it does not need a or event to fire as it initiates the state change. Instead, events should only be triggered by user interactions.\n\n🚧 Warning: Reflective state events can cause excessive rendering or infinite redner loops.\n\nComponents should default to composition whenever possible to maximize flexibility, compatibility, and simplicity. API Inheritance occurs when an API unknowingly or over time re-implements another element's API to expose additional access to its internal implementation details. For example, using a button and icon element can illustrate some of the tradeoffs involved in this approach.\n\nWhile it may be tempting to encapsulate other components and expose their APIs to the host component, this approach can quickly lead to API conflicts. For example, if a button has an icon, we may want to provide an icon API to set the button icon. However, this could conflict with the native button API, which already has a name attribute. To avoid these conflicts, it is crucial to consider the tradeoffs involved in exposing APIs and carefully design the API to minimize conflicts and maximize compatibility.\n\nWe may encounter layout conflicts as we continue to encapsulate other components and expose their APIs. For example, if we want to change the icon's position, we may need to provide a secondary \"escape hatch\" API to modify this behavior. This illustrates the tradeoffs involved in encapsulating other components and exposes the potential challenges when designing APIs.\n\nEncapsulating other components and exposing their APIs can introduce \"escape hatch\" APIs that the host component must support, which can complicate internationalization use cases where reading order and the elements are reversed for right-to-left languages. This approach may work in some cases, but it is important to consider the tradeoffs and potential challenges involved in exposing APIs in this way.\n\nAs the API for the icon component grows over time, there may be pressure for the host component's API (e.g., the button API) to absorb and expose additional API endpoints for the icon. This pressure, known as \"API inheritance,\" can create tightly coupled and non-explicit APIs that only exist for certain component combinations. As a result, the API becomes more complex and verbose as more \"escape hatches\" are required. In this example, API inheritance leads to an API with 66 characters, while composition and slots result in an API with only 59 characters. By leveraging composition and slots, we can avoid supporting tightly coupled APIs and keep the supported API surface area smaller and easier to learn in the long term.\n\nWhen designing composition-based APIs, it is important to push the semantics of the HTML into the light DOM or the control of the consumer. This helps to create a correct DOM structure and improved accessibility. For example, if a card element includes an heading, this makes an incorrect DOM structure, as there should only be one element within the page. By pushing the semantics of the heading up into the light DOM, the consumer can control the heading level and ensure that the page structure is correct.\n\nIt is important to push the semantic meaning of elements up to the consumer rather than obfuscating it internally. This enables the consumer to control which heading level is appropriate for their page, which is important for accessibility and features like aria-describedby, used to associate content. Furthermore, by exposing the semantic meaning of elements to the consumer, we can enable more accessible and flexible behaviors in our components and libraries.\n\nComposition-based APIs may be more verbose than other approaches. However, they have the advantage of lowering the overall API surface area of the system and ensuring that there is only one way to use any component. This makes it easier for consumers to learn and use the APIs, as the usage remains predictable and reliable throughout the system.\n\nAdding a layer of abstraction on top of the components is possible to provide more opinionated, terse APIs while enabling consumers to access the reusable components directly as needed. However, it is essential to carefully consider the tradeoffs involved in using abstractions. It can be easier to add new abstractions but much more difficult to fix or remove the wrong abstraction.\n\nIt is better to use shorthand values instead of specific properties. This gives the user more flexibility without making the public API surface bigger. When it can be done, keep the names of CSS Custom Properties simple and match them one-to-one with the native CSS property. This makes the API easier to learn and consistent with other components in the project.\n\nThe internal host element pattern offers protection for the element styles in the API. When customizing the look of a custom element, try not to add styles to the host element beyond simple display properties and custom properties. The more styles that are added to the host, the more likely it is for the user to modify them in unexpected ways, potentially affecting the desired appearance.\n\nThis component attaches styles directly to the element. Sometimes this is necessary for certain styles like display types. However, it also makes it easy for consumers to override your component styles unexpectedly. For example, the component is set to display flex but is being overridden to block by the consumer.\n\nStyle overrides like this are possible because the component allows its styles to leak into the public API. However, this API leak makes future changes or migrations of those components more problematic as it could have an unintended impact on the consumer application.\n\nApplying an internal host element for styles prevents or mitigates style leakage. This will allow more control over explicitly available styles on the public API.\n\nAdding an internal containing element prevents accidental style API leakage for the component. Now the consumer must use the exposed CSS Custom Properties in a predictable way to customize the component.\n\nLeverage the selector with CSS Custom Properties to customize the visual states of a component. Using the host avoids expanding the public API of the component and provides a single consistent CSS API of the component. Each visual variant is responsible for modifying the existing public API to reflect the component's visual state.\n\nWith this approach, we define the look and feel of our component once. Then leveraging CSS Custom Properties, we \"theme\" the component for the new visual state. Also, by modifying the CSS Custom Properties, we keep the CSS specificity low and easy to maintain.\n\nWith this pattern, we also enable future customizations for consumers. By leveraging the state-based attributes, consumers can create their own custom-style states with the same API.\n\nWhen using custom elements, use the Custom States API to style visual states of your component while avoiding the need to attach attributes or classes to the DOM and host element.\n\nBy leveraging the Custom States API, we can add custom CSS pseudo-classes to represent visual states without modifying DOM. This selector can be used internally in a component or externally as part of the public API.\n\nLogical Properties can ensure the component styles will support various RTL languages. Logical Properties apply styles based on block and inline axis that can be inverted based on the browser language settings.\n\nCSS Parts enable components to expose internal elements as a public API that usually are encapsulated via Shadow DOM.\n\n🚧 Warning: CSS Parts expose a significant amount of components' internal details, including DOM structure and style properties. Be cautious in using CSS Parts as it increases the maintenance and risk of visual breaking changes of your component.\n\nCSS Parts enable complete control of a DOM element to the consuming developer. However, this has a significant tradeoff. Exposing additional elements creates a more extensive public API surface. Over time this increases the difficulty of maintaining the API and changes to the internal template causing unexpected and brittle changes.\n\nExposing a component that is a versioned and controlled API can reduce this risk of API overexposure.\n\nThe has a controlled and versioned API, so exposing the is slightly less risky since consumers can only use it via the public API defined by .\n\nWell-encapsulated components should avoid projecting outer margins or whitespace outside the visible containment of the component. Margins on any reusable component make assumptions about the host layout and can tightly couple layout and component responsibilities. The layout or white space between components should be managed separately via layout components or utilities. If working in a Design System layout, utilities should be driven by consistent design tokens that manage both size and spacing values.\n\nAvoiding margins also can add a performance boost using the CSS Containment API. This API enables your components to provide hints to the browser about how it renders its layout. By avoiding margins, we can tell the browser that the layout will remain within our component's host element. This allows the browser to make performance optimizations when rendering.\n\nFonts can have a significant impact on white space and the accuracy of layouts. New CSS proposals like CSS Leading Trim can ensure typography is precise and adds no additional excess whitespace to layouts. Tools like Capsize CSS allow components to use leading trim-like features today.\n\nComponents should be responsive by default, enabling them to be used in various contexts and devices. Leveraging APIs such as CSS Container Queries and Resize Observers can enable a component to be responsive relative to its container size and not just the viewport.\n\nTools like the Custom Elements Analyzer and Custom Elements Manefest provides a standard way to document and generate metadata for our components.\n\nUsing JSDoc syntax, we can add additional information to document the public API of the component that tools like TypeScript cannot.\n\nFor highly reusable components, be cautious about what dependencies are added. Consider the following when deciding if a dependency should be used:\n• Is this something that is built into the Web Platform?\n• Is this something that could be polyfilled until available in most browsers?\n\nList dependencies within the rather than bundling them into the component. This enables the consuming application to de-dupe dependencies and properly tree shake/remove unused code.\n\nOptional features or polyfills can be listed under the .\n\nEach component should have a single entry point. This help ensures each component is isolated and can be imported independently from other components or dependencies within the same package.\n\nCustom Elements must register via the API. This associates the Class definition to the tag instance used in the HTML. This registration step is a global side effect. The side effect means the tag name is globally available to the HTML document once registered.\n\nTo ensure global side effects are not unexpected such as cases like unit testing or Scoped Element Registries, they should be isolated from the component implementation.\n\nThe isolated registration and imported dependencies ensure that the global registration only happens when explicitly included by the consumer.\n\nThe needs to have a property that explicitly lists all side effect files provided by the library package. This entry enables build tooling like Rollup and Webpack to optimize tree shaking while ensuring the side effects are included correctly in the final application bundle."
    },
    {
        "link": "https://oluwadaprof.medium.com/writing-reusable-components-in-react-with-typescript-25be49021612",
        "document": "Reusable components lie at the heart of efficient and maintainable React applications. They allow developers to encapsulate functionality into modular pieces, which can be used across various parts of an application. This approach reduces redundancy, promotes consistency, and simplifies code management.\n\nWhen combining React’s component-based architecture with TypeScript’s type system, we unlock a powerful duo for building robust applications. React’s declarative approach to UI components complements TypeScript’s type safety seamlessly. TypeScript ensures that we catch type-related issues during development, preventing runtime errors and enhancing code quality.\n\nLet’s consider a scenario where we’re building a simple button component using React and TypeScript. Here’s how the synergy plays out;\n\nIn this example, TypeScript enforces that the prop must be a string and must be a function, enhancing type safety. Any deviation from this contract would be caught during development, reducing runtime errors.\n\nMoreover, TypeScript’s type annotations make the code more self-documenting. Developers can quickly understand what props a component accepts and what each prop’s type is. This promotes code readability and collaboration among team members.\n\nBy leveraging TypeScript’s type system in conjunction with React’s component architecture, we build components that are not only reusable but also reliable and well-documented.\n\nIn the next sections, we’ll dive deeper into creating reusable components, utilizing TypeScript’s type system, and exploring various techniques to enhance development efficiency.\n\nLet’s start by building a basic reusable button component using React and TypeScript.\n\nComponent Structure: Set up a folder structure for your component;\n\nButton Component: Create the file and define the component;\n\nUsing the Component: Now you can use the component in your app;\n\nIn this example, we’ve created a component that accepts a prop (string) and an prop (function). TypeScript ensures that the props match the specified types. By using this component in the example, you're building a reusable UI element that can be used throughout your application.\n\nNext, we’ll explore more advanced prop types and ways to enhance the reusability of our components with TypeScript.\n\nWhile basic prop types are essential, TypeScript enables us to handle more intricate scenarios, ensuring stricter type checking and minimizing errors in our reusable components.\n\nOptional Props: Sometimes, certain props are optional. You can denote optional props with a in TypeScript;\n\nRequired Props: TypeScript also supports specifying required props by omitting the ;\n\nDefault Values: You can set default values for props in TypeScript;\n\nType Checking and Errors: TypeScript’s type checking ensures that props adhere to their specified types. If you attempt to use a prop incorrectly, TypeScript will catch it during development;\n\nBy leveraging TypeScript’s advanced prop type features, you create components that are more adaptable, more robust, and less prone to unexpected issues. These features enhance the predictability and maintainability of your components.\n\nIn the next section, we’ll delve into styling reusable components and how TypeScript contributes to this aspect.\n\nStyling is a crucial aspect of component development. TypeScript can play a role in enhancing both the organization and safety of your styles.\n\nCSS Modules: CSS Modules allow scoped styling for your components. TypeScript can aid in maintaining type safety for class names;\n\nStyled-Components: Styled-components offer a more dynamic way to style components. TypeScript provides type safety for styled-components’ props;\n\nType-Safe Styling: TypeScript ensures that your styles adhere to the correct structure, minimizing styling-related errors;\n\nMaking Components Even More Reusable with Generics\n\nGenerics empower components to work with various data types, boosting their versatility and reusability.\n\nIntroducing Generics: Generics are a TypeScript feature that allows us to create reusable components and functions that can work with a range of data types. They enable us to parameterize a component’s types, making them adaptable.\n\nCreating a Generic Component: Let’s create a generic component that can work with arrays of different types;\n\nUsing Generics for Different Data Types: Here’s how you can use the component with different data types;\n\nBy utilizing generics, you’ve created a highly reusable component that can adapt to various types of data.\n\nIn the next section, we’ll explore how component composition and context can further enhance the reusability of your components.\n\nComponent composition and the Context API in React provide powerful ways to enhance reusability and manage complex applications.\n\nStrategies for Composition: Breaking down larger components into smaller, reusable ones promotes a more modular approach. For example;\n\nEnhancing Reusability with Context: React’s Context API enables data sharing across components without prop drilling. It’s especially useful for global states like themes, user data, etc.\n\nType-Safe Context Usage with TypeScript: TypeScript can ensure type safety when using context, minimizing potential runtime errors;\n\nBy understanding and implementing component composition strategies and utilizing React’s Context API, you create components that are modular, scalable, and highly reusable. TypeScript adds an additional layer of safety, ensuring that your components work seamlessly together.\n\nIn the upcoming section, we’ll explore best practices for testing and documenting reusable components effectively.\n\nTesting and documentation are critical aspects of building reliable and maintainable components. TypeScript plays a significant role in both areas, ensuring clarity and accuracy.\n\nClearer Tests with TypeScript: TypeScript’s type annotations provide more context for testing. For instance, when testing a component, you can confidently use props knowing their types match the expectations;\n\nImportance of Documentation: Well-documented components are easier for other developers to understand and use. TypeScript encourages documenting props and behavior using comments;\n\nGenerating Accurate Documentation: TypeScript’s type annotations help generate accurate documentation automatically. Tools like can create documentation from TypeScript files, reducing the chance of documentation and code getting out of sync;\n\nIncorporating TypeScript into testing and documentation processes elevates the quality of your components, making them easier to test, understand, and use. This ensures that your components remain reliable even as your application evolves.\n\nIn the final section, we’ll summarize the key takeaways and the benefits of using TypeScript with React for creating reusable components.\n\nMaintaining and evolving reusable components in large projects can be challenging, but TypeScript offers tools and practices to overcome these hurdles effectively.\n• Versioning: Use semantic versioning to manage changes and updates to your components.\n• Clear Interfaces: Maintain clear and stable interfaces for your components, minimizing breaking changes.\n• Deprecation: Deprecate old props or components with clear messages, and provide alternatives.\n• Type Safety: TypeScript ensures that changes to components are type-safe, reducing the risk of runtime errors.\n• Refactoring Confidence: Renaming or changing prop types becomes safer with TypeScript’s refactoring support.\n• Prop Drilling: TypeScript enables more accurate prop typing, reducing the chances of wrong prop usage.\n• Ambiguous Types: TypeScript clarifies the types of props and states, reducing confusion and bugs.\n\nBy adhering to these best practices and leveraging TypeScript’s benefits, you ensure that your reusable components are maintainable, adaptable, and user-friendly throughout the lifecycle of your project.\n\nIn conclusion, the seamless integration of TypeScript and React not only enhances the development process but also results in more reliable, maintainable, and scalable reusable components."
    },
    {
        "link": "https://reddit.com/r/reactjs/comments/1acdozf/is_it_always_a_good_practice_to_do_reusable",
        "document": "Hello all, i'm a junior dev working on a React app and i'm in the process of coding a simple data table with pagination and such .. Usually i'm trying to set up reusable components for buttons and inputs as it is simple to do but for the data table it's taking the complexity of the component to a new level if i try to make it reusable.\n\nSo the question is : Is it always a good idea to make components reusable even if they're used like 6 times at most in the whole app and it makes the code more complex ?"
    },
    {
        "link": "https://telerik.com/blogs/building-reusable-ui-components-in-asp-net-core",
        "document": "In recent years, the modern web platform has propelled itself forward at the speed of light. Open source web development communities have popped up on GitHub like canvas tents at peak-season campsites; and state-of-the-art technologies have emerged like fireflies in the night sky.\n\nWhere was our friend ASP.NET, you ask? Startled by the clamor, it settled in unfashionably late at the desolate campground next door. Accompanied by a bag of Jet-Puffed marshmallows, roasting skewers, and a crackling campfire, it was comfortable and contemplated its next move through a pair of binoculars.\n\nFast-forward to the launch of ASP.NET Core, a caffeine-fueled reincarnation of ASP.NET proper. Microsoft had undoubtedly learned some invaluable lessons from competing technologies and was listening intently to its customers. ASP.NET Core MVC resuscitated a stale and stagnated collection of tools used by web developers for creating server-rendered, reusable UI components on the Microsoft technology stack. We can all agree that this was a long-overdue product refresh - if not, let's agree to disagree.\n\nThis article aims to provide clarity to the befuddled and skeptical. If you had previously deemed ASP.NET incapable of meeting your UI component needs, ASP.NET welcomes you back with open arms. This article also assumes a basic understanding of Partial Views, Child Actions, and HTML Helpers.\n\nVersion 1.0 of ASP.NET Core introduced Tag Helpers and View Components to the MVC application model. On the surface, Tag Helpers seemed to render HTML Helpers obsolete; and, View Components were peculiar constructs that felt like Partial Views with Child Actions.\n\nFast-forward to ASP.NET Core 1.1, where we witnessed the melding of the two concepts together by enabling View Component invocation as a Tag Helper. Indisputably, if both concepts are being used together, there must be something worth learning in this space.\n\nThe leap from ASP.NET proper to ASP.NET Core demands careful thought in planning an MVC application's architecture. Consider this a positive characteristic of the framework. There are more choices partly because best practices have evolved and partly because Microsoft has sought out the needs of previously-neglected Dark Matter Developers. The smorgasbord of options is intentional — this reinvigorated MVC application model caters to a much broader audience.\n\nTag Helpers aspire to be the server-side rendition of what the popular SPA frameworks offer in terms of UI components for the client. Think back to creating custom AngularJS directives, or the simpler-to-configure Angular components. Directives could take multiple forms. Here are a few examples:\n\nThat first line of markup appears to be our own custom HTML tag. Likewise, the next line of markup appears to be a custom HTML attribute affixed to a span tag. This modest markup is a facade backed by JavaScript, which handles any necessary processing — for example, requesting an external HTML template file from the server and hydrating the template's placeholders with the results of a current weather API request.\n\nTag Helpers offer the same feature set as described above. Aside from the syntactical disparities, the distinguishing factors are the use of C# instead of JavaScript and the shift from client-side to server-side processing. The point is Microsoft isn't reinventing the wheel with Tag Helpers. These concepts were already popularized and proven by other communities.\n\nTag Helpers are consumed by Razor views ( files) and are relatively simple to create. Before deciding to create one, however, remember that Microsoft ships around 18 of them in the NuGet package. Also, be conscious of the thriving community forming around Tag Helper authoring. You may save both time and money by shopping around and reaping the benefits of a third party's hard work. Progress is one company with an expanding presence in the Tag Helper marketplace.\n\nProgress has developed the Telerik UI for ASP.NET Core suite, which disguises the most popular Kendo UI widgets as Tag Helpers. At the time of writing, there are a dozen Tag Helpers in existence. See the complete list here.\n\nWith some basic markup inside a Razor view, a date picker widget can be added to the page:\n\nThe ASP.NET Core application is made aware of the Telerik Tag Helpers via the extension method call in the file:\n\nThe view becomes aware of the element via the final directive in the file:\n\nThe Telerik Tag Helpers handle a plethora of accessibility concerns for developers, including the addition of Accessible Rich Internet Applications (ARIA) attributes. The harsh reality is that accessibility is, at best, an afterthought in enterprise development. ARIA is rarely used because many decision makers categorize it as an additional expense with little-to-no return on investment. Consequently, the application's reach to assistive devices, such as screen readers, is inhibited by the pages' lack of machine-readable semantics. This feature alone makes the Tag Helpers worth adopting.\n\nAside from the attractive accessibility benefits, take into consideration the other time savings. When your development team needs a date picker widget, there's no longer a debate over how to optimally structure or style the widget for various form factors. These decisions have been made intelligently for you:\n\nThis is far from an exhaustive inventory of the benefits, but hopefully now you're recognizing the potential when using third-party Tag Helpers.\n\nFor those situations where a third-party Tag Helper either doesn't exist or doesn't quite fulfill your needs, it's time to roll up your sleeves and get your hands dirty. Building Tag Helpers can be a simple and rewarding endeavor. But what if you're stuck in a rut and aren't sure where to begin?\n\nThe official ASP.NET Core documentation offers moral support and dives into great detail with Authoring Tag Helpers in ASP.NET Core, a walkthrough with samples. Instead of rehashing what's already clearly documented there, read through it from top to bottom. Employ this knowledge to better understand how Microsoft has built their own Tag Helpers. You can view the source code in the ASP.NET Core MVC GitHub repository. This is a fantastic starting point if you're building a Tag Helper similar to one offered by Microsoft.\n\nAs an additional resource, I previously blogged about some Tag Helper fringe cases in which the terrain gets rough: Building Complex UI Components with ASP.NET Core MVC Tag Helpers. These rough edges are likely to disappear with future product iterations. Associated with the blog post is a sample application demonstrating how to represent a deck of playing cards with Tag Helpers.\n\nConsider the following elegant markup inside of a Razor view:\n\nFor the sake of brevity, the supporting C# classes are omitted; however, recognize that those classes are an important implementation detail. Tag Helpers are not automatically discovered by the application. The magic is explained by the last two directives in the file, which expose the and elements to the view:\n\nThe nested Tag Helper markup yields two hands of cards:\n\nView Components are reserved for more complex scenarios than Tag Helpers. These are overarching, data-driven widgets typically included in the master layout file. A great example is a location-specific current weather widget which connects to a third-party weather API to retrieve its data. This View Component might also include specialized business logic for manipulating the API response before data-binding to the view. The Weather Channel uses this style of widget, except it's written in Angular.\n\nThink of View Components as a disciplined progression of Partial Views — they reach into the dark corners which Partial Views never addressed. Additionally, View Components are a wholesale replacement for Child Actions in ASP.NET Core MVC.\n\nSince you're reading this article, my assumption is you're capable of creating a C# class and a Razor view. These are the essential building blocks of a View Component. See Microsoft's detailed instructions at Creating a view component.\n\nNow consider a sample application in which the following View Component invocation exists:\n\nThe preceding code initiates a request to a current weather API and displays the results for the provided city/state combination:\n\nThe power in this example lies in the fact that application developers needing this type of widget need not understand the underlying implementation details. Instead, the developers can focus on solving the business problem by simply passing the desired city and state via this terse C# snippet.\n\nRecall the current weather View Component in the previous section. The Razor syntax responsible for rendering it may have disgusted some. Here is the equivalent View Component invocation using the Tag Helper invocation syntax:\n\nThe significance of the prefix is that it's reserved for View Component invocation as a Tag Helper. Moreover, the assembly in which the View Component exists must be registered as a Tag Helper. That's accomplished via the last line in the following file:\n\nUsing the right tool for the job is important, which means understanding the differences between the UI options is paramount. Furthermore, just because ASP.NET Core MVC introduced new tools doesn't mean they're valuable or applicable to every application. The seasoned HTML Helpers and Partial Views, born in ASP.NET proper, are here to stay as well. There's no need to panic and pivot.\n\nPrefer Tag Helpers when Razor syntax is unappealing, but HTML is appealing. This may not completely eliminate the Razor syntax. For example, passing an enum value to a Tag Helper property necessitates it. This concept was demonstrated by the Tag Helper's and properties.\n\nSome developers, including myself, have long complained about weaving in-and-out of HTML and C# code inside Razor views. The context switching can decrease productivity, which is why Tag Helpers promote the use of a unified syntax all throughout the view.\n\nThere's another camp of developers who love the power of Razor. If peppering your views with the following statements doesn't bother you, stick with it:\n\nIntelliSense is yet another consideration. In the preceding HTML Helper code snippet, the IDE wouldn't have been able to assist when working with the third parameter, the anonymous object. Strongly-typed properties represent attributes within a Tag Helper element. For this reason, IntelliSense is a strong point of Tag Helpers.\n\nCustomers porting \"legacy\" MVC applications from ASP.NET proper to ASP.NET Core should consider whether the time investment to migrate from HTML Helpers to Tag Helpers is justified. Rewriting custom HTML Helpers could be a painful endeavor. Although, if the HTML Helpers exist without unit tests and if high test coverage is a goal, you may have a sound case for migrating. Tag Helpers were designed with testability in mind, thanks in part to the separation of concerns.\n\nView Components are ideal when the markup abstraction power of Partial Views seems appropriate but there's a dynamic aspect of the widget requiring complex rendering logic. API data retrieval and the application of specialized business rules on that response data are responsibilities better left to a View Component.\n\nPartial Views would require the use of C# in the view itself. When code scalability and testability are things you're willing to sacrifice, this approach could be acceptable. Through the enforcement of separation of concerns, View Components don't sacrifice these things. A class inheriting from houses the C# code associated with the view. Again, thanks to separation of concerns, writing meaningful unit tests is a much easier feat.\n\nPrefer Partial Views when porting your existing ASP.NET proper application to ASP.NET Core. I'll let you be the judge, but it's unlikely to be worth the investment in time to refactor those Partial Views into View Components. An exception to that statement may be the situation where testability is a goal. Remember that Child Actions are absent in ASP.NET Core, so a View Component makes sense as a Partial View / Child Action duo replacement.\n\nIn this article, we briefly touched on ASP.NET proper's hardened tools for building reusable UI components. From there, two new ASP.NET Core tools for this purpose were presented: Tag Helpers and View Components. Finally, recommendations were made for when each of these tools is best to use.\n\nAs with virtually anything in the real world, there are always exceptions to the rules. As such, use this guidance with a grain of salt and deviate where it makes sense. Much of this guidance has been gathered from my own personal experiences."
    },
    {
        "link": "https://diva-portal.org/smash/get/diva2:753217/FULLTEXT01.pdf",
        "document": ""
    },
    {
        "link": "https://vuejs.org/guide/components/slots.html",
        "document": "We have learned that components can accept props, which can be JavaScript values of any type. But how about template content? In some cases, we may want to pass a template fragment to a child component, and let the child component render the fragment within its own template.\n\nFor example, we may have a component that supports usage like this:\n\nThe template of looks like this:\n\nThe element is a slot outlet that indicates where the parent-provided slot content should be rendered.\n\nWith slots, the is responsible for rendering the outer (and its fancy styling), while the inner content is provided by the parent component.\n\nAnother way to understand slots is by comparing them to JavaScript functions:\n\nSlot content is not just limited to text. It can be any valid template content. For example, we can pass in multiple elements, or even other components:\n\nBy using slots, our is more flexible and reusable. We can now use it in different places with different inner content, but all with the same fancy styling.\n\nVue components' slot mechanism is inspired by the native Web Component element, but with additional capabilities that we will see later.\n\nSlot content has access to the data scope of the parent component, because it is defined in the parent. For example:\n\nHere both interpolations will render the same content.\n\nSlot content does not have access to the child component's data. Expressions in Vue templates can only access the scope it is defined in, consistent with JavaScript's lexical scoping. In other words:\n\nThere are cases when it's useful to specify fallback (i.e. default) content for a slot, to be rendered only when no content is provided. For example, in a component:\n\nWe might want the text \"Submit\" to be rendered inside the if the parent didn't provide any slot content. To make \"Submit\" the fallback content, we can place it in between the tags:\n\nNow when we use in a parent component, providing no content for the slot:\n\nThis will render the fallback content, \"Submit\":\n\nBut if we provide content:\n\nThen the provided content will be rendered instead:\n\nThere are times when it's useful to have multiple slot outlets in a single component. For example, in a component with the following template:\n\nFor these cases, the element has a special attribute, , which can be used to assign a unique ID to different slots so you can determine where content should be rendered:\n\nA outlet without implicitly has the name \"default\".\n\nIn a parent component using , we need a way to pass multiple slot content fragments, each targeting a different slot outlet. This is where named slots come in.\n\nTo pass a named slot, we need to use a element with the directive, and then pass the name of the slot as an argument to :\n\nhas a dedicated shorthand , so can be shortened to just . Think of it as \"render this template fragment in the child component's 'header' slot\".\n\nHere's the code passing content for all three slots to using the shorthand syntax:\n\nWhen a component accepts both a default slot and named slots, all top-level non- nodes are implicitly treated as content for the default slot. So the above can also be written as:\n\nNow everything inside the elements will be passed to the corresponding slots. The final rendered HTML will be:\n\nAgain, it may help you understand named slots better using the JavaScript function analogy:\n\nSometimes you want to render something based on whether or not content has been passed to a slot.\n\nYou can use the $slots property in combination with a v-if to achieve this.\n\nIn the example below we define a Card component with three conditional slots: , and the one. When content for the header / footer / default is present, we want to wrap it to provide additional styling:\n\nTry it in the Playground\n\nDynamic directive arguments also work on , allowing the definition of dynamic slot names:\n\nDo note the expression is subject to the syntax constraints of dynamic directive arguments.\n\nAs discussed in Render Scope, slot content does not have access to state in the child component.\n\nHowever, there are cases where it could be useful if a slot's content can make use of data from both the parent scope and the child scope. To achieve that, we need a way for the child to pass data to a slot when rendering it.\n\nIn fact, we can do exactly that - we can pass attributes to a slot outlet just like passing props to a component:\n\nReceiving the slot props is a bit different when using a single default slot vs. using named slots. We are going to show how to receive props using a single default slot first, by using directly on the child component tag:\n\nThe props passed to the slot by the child are available as the value of the corresponding directive, which can be accessed by expressions inside the slot.\n\nYou can think of a scoped slot as a function being passed into the child component. The child component then calls it, passing props as arguments:\n\nIn fact, this is very close to how scoped slots are compiled, and how you would use scoped slots in manual render functions.\n\nNotice how matches the slot function signature. Just like with function arguments, we can use destructuring in :\n\nNamed scoped slots work similarly - slot props are accessible as the value of the directive: . When using the shorthand, it looks like this:\n\nNote the of a slot won't be included in the props because it is reserved - so the resulting would be .\n\nIf you are mixing named slots with the default scoped slot, you need to use an explicit tag for the default slot. Attempting to place the directive directly on the component will result in a compilation error. This is to avoid any ambiguity about the scope of the props of the default slot. For example:\n\nUsing an explicit tag for the default slot helps to make it clear that the prop is not available inside the other slot:\n\nYou may be wondering what would be a good use case for scoped slots. Here's an example: imagine a component that renders a list of items - it may encapsulate the logic for loading remote data, using the data to display a list, or even advanced features like pagination or infinite scrolling. However, we want it to be flexible with how each item looks and leave the styling of each item to the parent component consuming it. So the desired usage may look like this:\n\nInside , we can render the same multiple times with different item data (notice we are using to pass an object as slot props):\n\nThe use case we discussed above encapsulates both reusable logic (data fetching, pagination etc.) and visual output, while delegating part of the visual output to the consumer component via scoped slots.\n\nIf we push this concept a bit further, we can come up with components that only encapsulate logic and do not render anything by themselves - visual output is fully delegated to the consumer component with scoped slots. We call this type of component a Renderless Component.\n\nAn example renderless component could be one that encapsulates the logic of tracking the current mouse position:\n\nWhile an interesting pattern, most of what can be achieved with Renderless Components can be achieved in a more efficient fashion with Composition API, without incurring the overhead of extra component nesting. Later, we will see how we can implement the same mouse tracking functionality as a Composable.\n\nThat said, scoped slots are still useful in cases where we need to both encapsulate logic and compose visual output, like in the example."
    },
    {
        "link": "https://stackoverflow.com/questions/68548682/how-to-pass-props-to-slot-vue-3",
        "document": "Making a custom select box component. But having some trouble when I try to pass to slot.\n\nis slot and I am calling it in component.\n\nWhen I try to pass to slot as a prop. I can't listen/watch it in the\n\nWhat is right way to achieve this? Watching props inside the slot for changes."
    },
    {
        "link": "https://en.uniapp.dcloud.io/vue-components.html",
        "document": "\n• Components are the basic building blocks of the view layer.\n• The component is an encapsulation of a single functional module.\n• A component includes a start tag and an end tag. Attributes can be written on the label and assigned values to the attributes. The content is written in two labels.\n• Root is , this case can only and must have a root component. This is the vue single file component specification .\n• The data option of a component must be a function.\n\nThe following is an example of a basic component. Introduce a component again under the root component, and bind a data to the text area of the component.\n\nBasic components are built in the uni-app framework, including dozens of basic components such as view, text, input, button and video. See the list for details: Uni-app basic components (opens new window)\n\nBut basic components alone are not enough. There will be many encapsulated components in actual development.\n\nFor example, if we need a pentagram click rating component, it is available in the DCloud plug-in market: https://ext.dcloud.net.cn/plugin?id=33 (opens new window)\n\nImport this uni-rate component into your uni-app project, refer to it in the required vue page, and you can display this five-pointed star component in the specified place.\n• The components can be reused any number of times.\n• The code is more convenient to organize and manage, and it is more extensible, facilitating collaborative development by multiple people.\n\nWhen registering a component, we always need to give it a name. There are two ways to define component names:\n\nWhen using kebab-case (name separated by dashes) to define a component, you must also use kebab-case when referencing this custom element, for example .\n\nWhen defining a component using PascalCase (name with initial capital letters), you can use both nomenclatures when referencing this custom element. Both and are acceptable.\n\nCreate and store custom components in the directory under the root directory of the uni-app project:\n\nsupports the configuration of global components. Global registration is required in , and the component can be used in all pages after registration.\n• The first parameter of Vue.component must be a static string.\n• The nvue page does not currently support global components.\n• Components can be used directly in\n\nBefore partial registration, import the component you want to use on the page that needs to reference the component.\n\nThe way the page introduces components\n\nThe following two ways to import a corner label component libraryhttps://ext.dcloud.net.cn/plugin?id=21 (opens new window), recommended to use to introduce\n• Traditional vue specifications: On the index.vue page, import the component as ,and define the you want to use in the Components option.\n\nFor the object of each property, its property name is the name of the custom elements, objects whose property value is the option of this component.\n\nPutting a variable name similar to uniBadge in the object is actually uniBadge: short for uniBadge, that is, the variable name is also:\n• The name of the custom element used in the template\n• The variable name that contains this component option (Only hump naming is supported)\n• easycom : introduce the components into one step. As long as the components are installed in the project directory, and in accordance with the directory structure. You can use it directly on the page without quoting or registering.\n• None Easycom (opens new window) is automatically turned on , you do not need to manually open ,when there is a demand of nodes personalize .\n• None No matter how many components are installed in the components directory, easycom will automatically remove unused components after packaging, which is particularly friendly to the use of component libraries.\n\nComponent is a very important part of the technology in .Components allow UI-related wheels to be easily manufactured and shared, which in turn makes development efficiency for users significantly higher.\n\nhas built a component plug-in market, in which there are many ready-made components. If you download components that conform to the components/ component name/component name. vue directory structure, you can use them directly. uni-app plug-in market (opens new window)\n\nCan be an array or object, used to receive data from the parent component. It can be a simple array, or use an object as an alternative. The object allows configuration of advanced options such as type detection, custom validation, and setting default values.\n• You can give like this passed in a static value:\n• Pass in all of an object\n\nIf you want to pass in all of an object as a prop, you can use without parameters (replace v-bind: prop-name) . For example, for a given object :\n\nAll props form a one -line downward binding between their parent and child props : updates to the parent prop will flow down to the child components, but the reverse is not possible. This will prevent accidental changes to the state of the parent component from the child component, which will make the data flow of your application difficult to understand.\n• This is used to pass an initial value; the desired sub-assembly to the next as a local used data.\n• This with a primitive values passed and the need for conversion. In this case, it is preferable to use the value of a calculated attribute to define:\n\nref is used to register a reference to an element or a child component. The reference will be registered under the parent component’s $refs object.\n\nIf used on a plain DOM element, the reference will be that element; if used on a child component, the reference will be component instance:\n\nWhen used on elements/components with v-for, the registered reference will be an Array containing DOM nodes or component instances.\n\n**An important note about the ref registration timing: **\n\nbecause the refs themselves are created as a result of the render function, you cannot access them on the initial render - they don’t exist yet! $refs is also non-reactive, therefore you should not attempt to use it in templates for data-binding.\n\nDespite the existence of props and events, sometimes you might still need to directly access a child component in . To achieve this you can assign a reference ID to the child component using the . For example:\n\nNow in the component where you’ve defined this ref, you can use:\n\nThus allowing the parent component to focus the input inside with:\n\nhere may be times when you want to listen directly to a native event on the root element of a component. In these cases, you can use the modifier for :\n• Note: the performance of app and h5 are inconsistent, and h5 gets the browser native event.\n\nWhen a child component changes the value of a , the change is synchronized with the binding in the parent component. It is extended as a listener that automatically updates the properties of the parent component.\n\nVue implements a content distribution API, using elements as outlets for hosting content distribution.\n\nIt allows you to synthesize components like this:\n\nIn the template may be written as:\n\nWhen the component is rendered, it will be replaced with \"Your Profile\". The slot can contain any template code, including :\n\nIf a does not contain an element, then anything between the start tag and an end tag assembly is discarded.\n\nWhen you want to use data in a slot, for example:\n\nThis slot has access to the same instance (that is, the same \"scope\") as the rest of the template, but not to the scope of .For example, a visit of less than:\n\nSometimes it is useful to set a specific fallback (that is, the default) content for a slot, which will only be rendered when no content is provided. In one example, component:\n\nWe may hope that the vast majority of cases are rendered within the text \"Submit\". In order to \"Submit\" content as a backup, we can put it in the label:\n• When I use a parent component when slot and does not provide any content:\n• When I use a parent assembly time and provides a slot content:\n\nWhen multiple slots are required, you can define named slots using a special feature of the element:\n• When providing content to a named slot, We can use directive on a element, and provide their name as a parameter of v-slot:\n\nNow all the content elements will have to be passed in the appropriate slot. Any not been wrapped with the v-slot in is considered the default slot content in the content .\n\nLike v-on and v-bind, it also has abbreviations, that is, replace everything before the parameter (v-slot:) with the character # . For example, it can be rewritten as :\n\nIn the scope slot, the parent component can get the data of the child component. Subassembly may be bound label on the attribute value.\n\nSometimes it is useful to allow the contents of the slot to access data that is only available in the subcomponent.\n\nWe may want to change the default content and display it by first name instead of last name. as follows:\n\nHowever, the above code does not work properly, because only components can access the user and the content we provide is in the parent rendering.\n\nTo make user available in the parent slot contents, we can bind user as an of the element:\n\nBinding on the element is called slot prop .Now in the parent scope, we can use the valued to define the name of the we provide:\n\nIn this example, we select will contain all the slots object name , but you can use any name you like.\n\nLike assume unspecified content corresponding slot as the default, with no arguments is assumed to correspond to the default slot:\n\nThe abbreviated syntax of the default slot cannot be mixed with the named slot , because it will cause the scope to be ambiguous:\n\nAlways use the full -based syntax for all slots whenever multiple slots are present:\n\nThe internal working principle of scoped slots is to wrap the contents of your slot in a function with a single parameter:\n\nThis means that the value of a can actually be any expression that can be used as a parameter in a function definition. So with the support of the environment ( single file component ), you can also use the ES2015 deconstructed to pass specific slot , as follows:\n\nThis makes the template more compact, especially if the slot provides more than one .It also opens up other possibilities, such as renaming,for example, rename :\n\nYou can even define a backup for the case where in the slot is :\n\nThe following are reserved keywords and can not be used as component names.\n• In addition to the names in the above list, standard HTML and SVG tag names cannot be used as component names.\n• Methods cannot use a method name with the same name as a lifecycle."
    },
    {
        "link": "https://stackoverflow.com/questions/46341493/access-component-data-in-other-component-using-slots-in-vuejs",
        "document": "I am trying to build a VueJS component. I have two other components which I want to use in a parent child manner. Now, I want to pass parent's data to child. It is like this:\n\nI want from to be accessible in . I don't want to expose on . How can I do this? I placed the consuming parentMsg inside (and after too) unnamed slot in parent.vue template and thought that with each instance of child.vue, a copy of div will be rendered. It does not work."
    },
    {
        "link": "https://dev.to/johnpaul/unleashing-the-power-of-slots-in-vuejs-m1a",
        "document": "Vue.js is a popular JavaScript framework used for building user interfaces. One important aspect of Vue.js is understanding how to use slots. With the recent release of Vue 3, the syntax for using slots has been made more succinct.\n\nThis change to slots has gotten me re-interested in discovering the potential power of slots to provide reusability, and clearer readability to our Vue-based projects.\n\nWith Vue slots, you can turn a part or all of your components into reusable templates that will render differently based on different use cases. All you need to do is embed them in slots.\n\n In this article, I’ll help you understand the concept of Vue slots and show you how to use them.\n\nSlots in Vue.js are a powerful feature that allows components to be reused and display dynamic content. Slots allow you to pass content into a component and define how it is displayed. This can make your code more modular and reusable, allowing you to create complex applications with ease. Slots are the Vue equivalent to transclusion in Angular and child props in React.\n\nIn Vue.js, there are basically two types of slots:\n\nWe understand the whole concept from the definition of slots — it’s about making components reusable. The best way to understand them is to see them in action. Let’s start with a simple example:\n\n\n\nThe component above has a wrapper . Let’s assume that is there to create a stylistic frame around its content. This component is able to be used generically to wrap a frame around any content you want. Let’s see what it looks like to use it.\n\n\n\nThe content that is between the opening and closing example tags will get inserted into the example component where the slot is, replacing the slot tags. This is the most basic way of doing it. It will look like this:\n\nYou can also specify default content to go into a slot simply by filling it in:\n\n\n\nSo now if we use it like this instead:\n\n\n\nThe default text of “This is the default content if nothing gets specified to go here” will show up, but if we use it as we did before, the default text will be overridden by the tag:\n\nDefault slots are a way to pass content from the parent component to a child component. The content passed to a default slot is rendered inside the child component, allowing the parent component to customize the content of the child component.\n\nA default slot is defined in the child component template using the element without a attribute. When using a default slot, the content passed from the parent component is placed directly inside the child component, replacing the element.\n\nFor example, consider a Card component that contains a , area, and :\n\n\n\nThis component creates a card with a header, main content area, and footer. The default slot is defined in the section, where the content passed from the parent component will be rendered.\n\nTo pass content to the default slot, the parent component uses the child component in its template, placing the content directly inside:\n\n\n\nThe content will be rendered in the main section of the component as shown below:\n\nThe best way to organize a slot-based component system is to name your slots. Named slots are a way to pass content from the parent component to a child component, similar to default slots. However, named slots allow the parent component to specifically target and customize different parts of the child component.\n\nA named slot is defined in the child component template using the element with a name attribute. The name attribute specifies the name of the slot and is used by the parent component to target and customize that specific part of the child component.\n\nFor example, consider a component called :\n\n\n\nThis component creates a layout with a , area, and . The named slots are defined in the header and footer sections, where the content passed from the parent component will be rendered.\n\nTo pass content to a named slot, the parent component uses the child component in its template and specifies the name of the slot using the directive:\n\n\n\nThe content Header will be rendered in the header section of MyLayout component, and the content Footer will be rendered in the footer section. The content Main Content will be rendered in the default slot, which is located in the main section just like below:\n\nProps are a great way to reuse components, but they have their limitations depending on your use case. Props tend to work best in components that have the same format and content, but just different values.\n\nSometimes you need to make your components a little more flexible and adaptable: maybe you want some components to have certain sections while depending on the page it’s on, you want to remove other sections.\n\n By injecting your content using slots, it makes it easier to switch around the content of a component without having to worry about using template logic to handle rendering.\n\nWhile Vue slots are a pretty simple concept, it’s super powerful in designing amazing components. We have seen the different ways to reuse properties of a component by using the slot property. This takes component-based development to a whole new level, and while I’ve demonstrated a lot of great ways slots can be used, there are countless more out there. Feel free to explore them.\n\nYou can read more about Vue slots on Vue’s official site."
    }
]