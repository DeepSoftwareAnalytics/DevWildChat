[
    {
        "link": "https://stackoverflow.com/questions/46440399/c-hermite-interpolation-algorithm-in-boost",
        "document": "I'm trying to use Boost c++ library for Hermite interpolation, but it's not well documented and I'm not well understand.\n\nMy case is to calculate y values at some x position from data points such as:\n\nAnd get result with equal x spaces (x space 0.5):\n\nCan boost be helpful for me? I had found more implementations of Hermite in web, but examples and it's result output was not what I'm looking for. I think thats because I don't understand how it works. When I read about Hermite I tought that algorithm should ask for some points, spacing value and might few other input values and then calculate and return new points, but I was wrong and now lost..\n\nMaybe someone has experience using Hermite and had similar case?"
    },
    {
        "link": "https://stackoverflow.com/questions/46440399/c-hermite-interpolation-algorithm-in-boost/46440732",
        "document": "I'm trying to use Boost c++ library for Hermite interpolation, but it's not well documented and I'm not well understand.\n\nMy case is to calculate y values at some x position from data points such as:\n\nAnd get result with equal x spaces (x space 0.5):\n\nCan boost be helpful for me? I had found more implementations of Hermite in web, but examples and it's result output was not what I'm looking for. I think thats because I don't understand how it works. When I read about Hermite I tought that algorithm should ask for some points, spacing value and might few other input values and then calculate and return new points, but I was wrong and now lost..\n\nMaybe someone has experience using Hermite and had similar case?"
    },
    {
        "link": "https://geeksforgeeks.org/hermite-curve-in-computer-graphics",
        "document": "In computer graphics, we often need to draw different types of objects onto the screen. Objects are not flat all time and we need to draw curves many times to draw an object.\n\nBefore going into Hermite curves, we will discuss in this article about curves. Spline curves are of two types:\n\n1. Approximation Spline Curve: Here the curve passes close to the control point. As we can see in the diagram below. Examples are the Bezier curve, the B-spline curve, etc.\n\n2. Interpolation Spline Curve: In this case, the curve passes through all the control points. An example is the Hermite curve.\n\nHermite curve named after the French mathematician Charles Hermite is an interpolating piecewise cubic polynomial. It has a specified tangent at each control point. Hermite spline curves can be adjusted locally because each section is only dependent on its endpoint constraints.\n\nIf represents a parametric cubic point function for the curve section between control points P and P, then boundary conditions that define the Hermite curve section are\n\nwith DP and DP specifying the value for parametric derivatives(slope of the curve) at control points P and P . The resulting Hermite curve is something like the below:\n\nAs we know Hermite curve is a cubic polynomial. So we will write here:\n\nNow we will differentiate the cubic polynomial P(u). On differentiating, we get,\n\nNow we will apply the boundary conditions u=0 and u=1 to P(u).\n\nFor the derivative of P, we apply boundary conditions now. First, we apply u=0\n\nSo these are the four linear equations that we get on applying the boundary conditions to P(u) and P'(u). Now we will write these four equations in the form of a matrix as shown in the image below.\n\nWe can calculate the value of a, b, c, and d by performing the required matrix operations as shown below.\n\nThe matrix calculated above is known as the Hermite matrix and is denoted by M . So we can write the equation as shown below.\n\nwe know that\n\nAfter multiplying the matrices on the right-hand side in the above image, we will get:\n\nThe Hermite curve is used to interpolate sample points on a 2-D plane that results in a smooth curve, but not a free form, unlike the Bezier and B-spline curves. The most commonly used cubic spline is a 3-D planar curve.\n\nHermite curves are easily calculatable. They are used to smoothly interpolate through control points. Understanding the mathematical background of Hermite curves will help us to understand the entire family of splines.\n• First-order derivatives are required; it is not suitable for a designer to provide first-order derivatives.\n• There is no local control support.\n• The order of the curve is constant in spite of the number of data points.\n• Physically, the values of parameters that is the blending function H0, H1, H2, and H3 do not contain any meaning. If we know these values, we can’t imagine the shape of the curve."
    },
    {
        "link": "https://reddit.com/r/opengl/comments/17q5nnr/help_with_hermite_curves",
        "document": "Hello everyone. For our computer graphics assignment I should add Hermite curves to our C++ OpenGL programs in order to make some kind of 2D mountains in the background. We were taught some theory, but I have no clue about where to start: how am I supposed to translate derivatives and tangents into code? I have been looking around for resources but I haven't had luck when it comes to concrete implementations."
    },
    {
        "link": "https://orangewire.xyz/mathematics/gamedev/2022/01/02/arclen-hermite.html",
        "document": "I won’t give you a full overview of Bezier curves here as there is too much to talk about, read [2] for a quick jump start. But as we will use them, I should at least give some basic definitions that we can refer to.\n\nThe Bezier curves are a family of parametric curves that are wildly used in computer graphics. An order Bezier curve is specified by a set of control points , and expressed using the order Bernstein polynomials. The control points can be anything you like as long as they can be added and multiplied by a scalar, but we consider them as vectors in this article. Let be the Bernstein polynomials of order :\n\nThen an order Bezier curve of parameter is simply:\n\nIt is often desirable to work with a polynomial expansion of , which is better suited for fast interpolation on a computer:\n\nwith the coefficients given by:\n\nThis can be obtained by binomial expansion of the factor in the Bernstein form. In an implementation, the coefficients can be pre-computed once the control points are set, and the interpolations are performed using , so we just have a weighted sum of a few vectors to process.\n\nCubic Hermite splines are used a lot as an interpolation tool, especially in game programming where they can represent agent or camera trajectories, or be used for procedural mesh generation to name a few common examples. In this context, they are often referred to as csplines. I happen to use them quite a lot to interpolate between colors too, I coded a whole daylight cycle / atmosphere system based on these a few years ago.\n\nThey are piecewise smooth curves whose sections are described by cubic polynomials. A cubic Hermite spline is fully specified by the control points it passes through, two additional free tangents at both ends, and a set of intervals that serve as parameter domains on the segments. The curve obtained is smooth by construction, thanks to a constraint on tangents at the inner control points. All of the inner tangents can indeed be computed as functions of the control points , such that the curve and its first derivative are continuous at the control points. There is no way however to constrain the outer tangents which therefore remain free. There are many ways to compute the inner tangents, giving rise to various families of Hermite splines, but we will focus on a specific model today, called the cardinal spline.\n\nLet denote the curve parameter. On the interval , the interpolated point can be written as a polynomial function of the control points and and the tangents and . Let be the following affine transformation applied on :\n\nThis transformation maps a parameter value to the local parameter of the -th segment. Then we have the following definition for :\n\nwhere the functions are the following basis polynomials:\n\nAs stated previously, we will restrict ourselves to the family of cardinal splines, whose inner tangents are modelled this way:\n\nThe parameter called the tension controls the lengths of the tangents. The higher is, the tighter the bends, and when the spline degenerates to a broken line.\n\nBy expansion of we can show that our basis functions can be expressed in terms of the order Bernstein polynomials:\n\nThis means that our segments can in fact be expressed as Bezier curves! Indeed, the following set of Bezier control points:\n\nwhen substituted into and using , define a cubic patch of the form between the Hermite control points and . The two inner Bezier control points of determine the tangents at the segment’s ends.\n\nI find it more useful to define Hermite splines in terms of Bezier patches as it opens the way to useful algorithms such as De Casteljau splitting, and allows to reuse an existing Bezier spline implementation (if you happen to have one in your codebase, which most of the game devs do). So that’s a design choice I’m going to make in the following implementation.\n\nLet’s see if we can find a closed-form formula for the arc length of an order Bezier curve . Going through the maths developped in part 1 and using , the arc length function is written as:\n\nWe can already stop right there, because for arbitrary control points, the norm in the integrand will evaluate to the square root of a degree polynomial. This is what is called an elliptic integral, and there’s nothing we can do to express it using elementary functions. Of course, this implies that there is no closed-form formula for the inverse either. Then if we can’t do it for the spline segments, we surely can’t do it for the whole spline: we’re toast. And this situation is far from uncommon it turns out: even a simple ellipse -that is not also a circle- does not admit a closed-form formula for its length, precisely because the arc length integral is of this form (that’s why it is called an elliptic integral, by the way).\n\nThis doesn’t mean however, that we can’t evaluate or approximate this beast numerically. The spline does have a length of course, it’s just not expressible in terms of elementary functions. If we can compute a series of values that approximate close enough in , a numerical method can be used to compute a series of values that approximate , and we’re going to do exactly this!\n\nYou can find my original C++ implementation in my personal GitHub here, and an example on how to use it here. This is part of a library project called Kibble that I use mainly for game development. This implementation has much more features than what I’ll cover in this article, for example, it handles the computation of first and second derivatives along the spline, De Casteljau splits and can perform accurate length estimations. So it’s a beast, but a well documented one.\n\nThe demo I’m showcasing today will be done in Python with . shares a lot of spirit with Matlab, and its constructs tend to hide some loops as we address vectors and matrices as a whole. So be aware of this conceptual leap if you’re coming from the lands of C / C++ / Rust / Java.\n\nWe will start by coding Bezier splines that we’ll then use as segments in a Hermite spline implementation. The arc length parametrization will be handled by a wrapper around a Hermite spline.\n\nWe will consider Hermite splines defined using control points, which means there are segments. Without loss of generality, we will assume that for our curve parameter . We will also impose that all the intervals are of same length, and as such, is constant for all . Then all the intervals partition the unit interval uniformly. This simplifies a lot of things in the equations above and therefore in the implementation itself. But what works for me may not work for you, just go back to the general definitions if you want to do something fancier.\n\nAs the tangents always appear multiplied by a factor in and , I chose to pre-multiply them by during their calculation, which simplifies their expressions even more. You’ll see a note explaining the details in the relevant section down below.\n\nFirst, we should write code for our Hermite spline segments. Each segment of a Hermite spline can be defined as a cubic Bezier spline as we saw previously. We are going to define a generic Bezier spline in this section, and when the time comes to use it, we are going to feed it four control points so it’s always cubic (remember that the order of a Bezier spline is the number of control points minus one). Thanks to we can compute the coefficients in advance, so when we sample the Bezier spline, we only need to calculate the weighted sum of four precomputed vectors:\n\nThe function will take care of computing the coefficients:\n\nIt looks heavy, but it is a direct implementation of . Of course, if you’re going to change the control points dynamically, you must recalculate the coefficients. Now, to interpolate along the Bezier spline, we define this function using :\n\nThe and shenanigans allow us to feed an array of parameter values as , so we only need to call this function once. But under the hood it will evaluate the power series for each value of , that’s all. You will need to modify the code a little bit if you want it to work with scalars as control points. And we’re done for this part! Let’s build and sample a cubic Bezier spline to test this:\n\nThe plotting code was omitted, but you can find it in the full source code (link below). This is what we get:\n\nwhich is exactly what we expect. The curve passes through the first and last control points, and is “attracted” to the control points in the middle. More precisely, if you draw a line between the control points and , you observe that this line is tangent to the curve at . So imposes a tangent at . Same spiel for and respectively. In fact, specifying the inner control points in a cubic Bezier spline is equivalent to specifying the tangents at both ends. The size of the tangents matter too: the lengthier the tangent, the more the curve will stick to it. This is important to understand, as these tangents will play a crucial role in the next part.\n\nBecause of the way we defined the Bezier spline, you could feed it control points in 3D space (or even 5D if you ascended to a higher plane of existence) and it would work the same. Neat. But in practice, you will need to interpolate other things than just vectors, quaternions come to mind. In this case, you will have to adapt your code to perform a Slerp for example, read [1] for a detailed explanation on how to construct a so-called quaternion curve.\n\nNow, we can use our class as a building block for Hermite splines. We will restrict ourselves to the cardinal splines family that we discussed in the first section, which means that we use as a model to choose the tangents at each inner control point. However, the tangents at both ends of the Hermite spline remain free, and we must specify them during construction. The construction of a generic Hermite spline will then require three pieces of data:\n• The control points which the spline must pass through\n• The unconstrained tangents at both ends\n\nOur method should calculate the tangents at each control point (except at the beginning and end of the curve, where they are manually specified), and also initialize a object for each segment:\n\nThe tangents are stored in a numpy array as usual. To calculate the (inner) tangents, we just use the formula for generic cardinal splines:\n\nAnd each segment is calculated according to :\n\nTechnically, for each segment, we are defining four control points for the underlying Bezier spline, two of which are successive control points of the Hermite spline, and the other two in the middle are constrained by the tangents. Don’t get mixed up between “Hermite control points” on the one hand, and “Bezier control points” on the other.\n\nNow, this is where things get wild, and I apologize for that in advance. Our Hermite spline admits a parameter between and . Each segment of the Hermite spline also admits a parameter in the same range, and we will refer to it as the local space parameter. If we want to sample the Hermite spline at a given parameter value, we need in fact to sample the appropriate Bezier spline segment at the appropriate local space parameter value. So we must:\n• Find the segment index corresponding to the value of\n• Calculate the local space parameter as a function of and\n\nGiven that there are segments, the index can be calculated like so:\n\nwith the floor function. At only, the value output by the floor function will be which is out of bounds in our array of segments. So we need to make sure that the value of stays within bounds, hence the .\n\nTo calculate , we just need to extract the fractional part of :\n\nNow, because we are using for this demo, we must make this work for arbitrary arrays of parameter values . So we write a helper function that takes in as an input, and spits out one pair for each value of :\n\nThe function of the expects an array of as input, so we must group the local space parameter values by index, and submit each group to the appropriate segment:\n\nFinally, we concatenate all the sample values returned by each segment. I know it’s a tough one to digest (writing it was no less of an arduous task), but take your time, add a few statements here and there, and you’ll see that it makes sense. The C++ implementation I mentioned at the beginning of the section is much more straightforward in that regard (albeit way lengthier in general), so maybe take a look at it.\n\nStill with me? Let’s display a Hermite spline:\n\nI chose the same values for the control points as before, not in an attempt to confuse you even more, but to make more obvious the difference with a Bezier spline: the Hermite spline passes through all of its control points. This one has three segments, all of which begin and end at a Hermite spline control point. As you can see, the inner control points of each segment (shown in green) prescribe a tangent at each segment end. Let’s plot Hermite splines using the same set of control points and free tangents for multiple values of to observe the effect it has:\n\nIt’s as if the curve had some elastic quality to it, and we were pulling it from one end, the other being attached, hence the name “tension” for . When the tension is equal to , by all the tangents vanish, and the spline looks like a broken line.\n\nAs stated earlier, there is no closed-form expression for the arc length function of a Hermite spline, so the next best thing to do is to sample the spline at multiple locations and approximate the arc length numerically at these locations. Then, we can use a binary search algorithm to invert the arc length table numerically, giving us an inverse arc length table that we will use as a lookup table (LUT) for uniform sampling.\n\nFirst, let’s define another class that will wrap a and allow uniform sampling:\n\nThe constructor argument specifies the number of sample points along the spline used for the calculation of the arc length table.\n\nThere are multiple ways to approximate the arc length along the spline. The easiest is to sample the spline densely enough, and compute pairwise Euclidean distances between consecutive points. Then, a prefix sum of these distances is performed, and we obtain the cumulative distance at each sample point. This can be done succinctly in Python using array slices and :\n\nIf the sample points are densely packed along the curve, the lengths will be approximated correctly. If you need more precision, consider using a De Casteljau split algorithm on the spline segments. This is possible because we defined segments as Bezier splines! Maybe I’ll write about this in a future article.\n\nSo we have a table containing the arc lengths of the spline for multiple sample points. This table approximates the arc length function , so in essence, the indices of this table should correspond to the parameter . Let’s call the value in this table corresponding to the index .\n\nIf we want to invert numerically, that is, to find an approximation for , then for multiple values of the arc length we must find the index such that is the largest value that verifies . To rephrase this, we are looking for the largest that is smaller than . This is a job for a binary search algorithm:\n\nBasically, we initialize a lower bound and an upper bound to cover the whole search interval, the index we’re looking for being somewhere inbetween. Then we iteratively narrow down this interval until and converge to the same integer. At this point, we know that this integer is either the index we’re looking for, or the integer just above that, and we decide based on an ultimate comparison test.\n\nThis algorithm will be called iteratively for monotonically increasing values of . Because the values are also monotonically increasing, we know that at a given iteration, we won’t find our target value before the index returned by the previous iteration, so we can cut down costs by initializing the lower bound to this last index instead of as we would normally do.\n\nLet’s now write a function that takes in a normalized arc length parameter and returns an approximation for the curve parameter :\n\nFirst we compute by multiplying by the total length of the spline ( is the last element of the arc lengths array ). Then we find the index in the arc lengths table thanks to our function. We could return which corresponds to the fraction of the table size covered by , but this is too crude of an approximation, and we can do better that that.\n\nWe know that our target length will be located between ( ) and ( ) by construction. We can then compute a fractional part between and that tells us exactly where is located within this interval. Then we return as our approximation for .\n\nWe also take care of returning for the next binary search iteration to use.\n\nFinally, we can write the used by the constructor, to build the arc length lookup table:\n\nThat’s pretty straightforward: for multiple values of homogeneously distributed in we use the function to compute the corresponding values of the curve parameter . The last line of code seems out of place, but we’ll discuss its raison d’être soon enough.\n\nAll that is left to do is write a function that will remap an array of to their corresponding values of and sample the Hermite spline with it:\n\nFor all values of we compute an index in the lookup table:\n\nThen, the corresponding must be between ( ) and ( ), and we use a simple lerp to obtain a better approximation:\n\nBecause we are querying in this function, care must be taken so as to avoid an out of bounds error. As a simple fix, we repeated the last value of the lookup table in the function, so returns exactly when .\n\nLet’s see how it looks:\n\nI modified the control points a bit as compared to the previous figure, so the last segment is shorter and the last bend tighter. This makes more obvious the uniformity defect of the default parametrization. You can see on the other hand that sampling the curve with an arc length parametrization gives equally spaced sample points.\n\nThis concludes this article. If you made it here, congratulations! I know it’s a tough subject to wrap one’s head around.\n• [1] Myoung-Jun Kim, Myung-Soo Kim, and Sung Yong Shin (1995). “A General Construction Scheme for Unit Quaternion Curves with Simple High Order Derivatives”\n• [2] Bezier Curves from the Ground Up - Jamie Wong’s article on Bezier curves, with awesome animations."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/language/operators",
        "document": "Customizes the C++ operators for operands of user-defined types.\n\nThe behaviors of non-punctuation operators are described in their own respective pages. Unless otherwise specified, the remaining description in this page does not apply to these functions.\n\nWhen an operator appears in an expression, and at least one of its operands has a class type or an enumeration type, then overload resolution is used to determine the user-defined function to be called among all the functions whose signatures match the following:\n\nOverloaded operators (but not the built-in operators) can be called using function notation:\n• An operator function must have at least one function parameter or implicit object parameter whose type is a class, a reference to a class, an enumeration, or a reference to an enumeration.\n• The operators (scope resolution), (member access), (member access through pointer to member), and (ternary conditional) cannot be overloaded.\n• New operators such as , , or cannot be created.\n• It is not possible to change the precedence, grouping, or number of operands of operators.\n• The overload of operator must either return a raw pointer, or return an object (by reference or by value) for which operator is in turn overloaded.\n• The overloads of operators and lose short-circuit evaluation.\n\nBesides the restrictions above, the language puts no other constraints on what the overloaded operators do, or on the return type (it does not participate in overload resolution), but in general, overloaded operators are expected to behave as similar as possible to the built-in operators: operator+ is expected to add, rather than multiply its arguments, operator= is expected to assign, etc. The related operators are expected to behave similarly (operator+ and operator+= do the same addition-like operation). The return types are limited by the expressions in which the operator is expected to be used: for example, assignment operators return by reference to make it possible to write a = b = c = d, because the built-in operators allow that.\n\nCommonly overloaded operators have the following typical, canonical forms:[1]\n\nThe assignment operator operator= has special properties: see copy assignment and move assignment for details.\n\nThe canonical copy-assignment operator is expected to be safe on self-assignment, and to return the lhs by reference:\n\nIn those situations where copy assignment cannot benefit from resource reuse (it does not manage a heap-allocated array and does not have a (possibly transitive) member that does, such as a member std::vector or std::string), there is a popular convenient shorthand: the copy-and-swap assignment operator, which takes its parameter by value (thus working as both copy- and move-assignment depending on the value category of the argument), swaps with the parameter, and lets the destructor clean it up.\n\nThis form automatically provides strong exception guarantee, but prohibits resource reuse.\n\nThe overloads of and that take a std::istream& or std::ostream& as the left hand argument are known as insertion and extraction operators. Since they take the user-defined type as the right argument ( in ), they must be implemented as non-members.\n\nThese operators are sometimes implemented as friend functions.\n\nWhen a user-defined class overloads the function call operator operator(), it becomes a FunctionObject type.\n\nAn object of such a type can be used in a function call expression:\n\nMany standard library algorithms accept FunctionObjects to customize behavior. There are no particularly notable canonical forms of operator(), but to illustrate the usage:\n\nWhen the postfix increment or decrement operator appears in an expression, the corresponding user-defined function (operator++ or operator--) is called with an integer argument ​0​. Typically, it is declared as T operator++(int) or T operator--(int), where the argument is ignored. The postfix increment and decrement operators are usually implemented in terms of the prefix versions:\n\nAlthough the canonical implementations of the prefix increment and decrement operators return by reference, as with any operator overload, the return type is user-defined; for example the overloads of these operators for std::atomic return by value.\n\nBinary operators are typically implemented as non-members to maintain symmetry (for example, when adding a complex number and an integer, if operator+ is a member function of the complex type, then only complex + integer would compile, and not integer + complex). Since for every binary arithmetic operator there exists a corresponding compound assignment operator, canonical forms of binary operators are implemented in terms of their compound assignments:\n\nStandard library algorithms such as std::sort and containers such as std::set expect operator< to be defined, by default, for the user-provided types, and expect it to implement strict weak ordering (thus satisfying the Compare requirements). An idiomatic way to implement strict weak ordering for a structure is to use lexicographical comparison provided by std::tie:\n\nTypically, once operator< is provided, the other relational operators are implemented in terms of operator<.\n\nLikewise, the inequality operator is typically implemented in terms of operator==:\n\nWhen three-way comparison (such as std::memcmp or std::string::compare) is provided, all six two-way comparison operators may be expressed through that:\n\nUser-defined classes that provide array-like access that allows both reading and writing typically define two overloads for operator[]: const and non-const variants:\n\nIf the value type is known to be a scalar type, the const variant should return by value.\n\nWhere direct access to the elements of the container is not wanted or not possible or distinguishing between lvalue c[i] = v; and rvalue v = c[i]; usage, operator[] may return a proxy. See for example std::bitset::operator[].\n\nUser-defined classes and enumerations that implement the requirements of BitmaskType are required to overload the bitwise arithmetic operators operator&, operator|, operator^, operator~, operator&=, operator|=, and operator^=, and may optionally overload the shift operators operator<< operator>>, operator>>=, and operator<<=. The canonical implementations usually follow the pattern for binary arithmetic operators described above.\n\nThe following operators are rarely overloaded:\n• The address-of operator, . If the unary & is applied to an lvalue of incomplete type and the complete type declares an overloaded , it is unspecified whether the operator has the built-in meaning or the operator function is called. Because this operator may be overloaded, generic libraries use to obtain addresses of objects of user-defined types. The best known example of a canonical overloaded is the Microsoft class . An example of this operator's use in EDSL can be found in boost.spirit.\n• The boolean logic operators, and . Unlike the built-in versions, the overloads cannot implement short-circuit evaluation. Also unlike the built-in versions, they do not sequence their left operand before the right one. In the standard library, these operators are only overloaded for .\n• The comma operator, . Unlike the built-in version, the overloads do not sequence their left operand before the right one. Because this operator may be overloaded, generic libraries use expressions such as instead of to sequence execution of expressions of user-defined types. The boost library uses in boost.assign, boost.spirit, and other libraries. The database access library SOCI also overloads .\n• The member access through pointer to member . There are no specific downsides to overloading this operator, but it is rarely used in practice. It was suggested that it could be part of a smart pointer interface, and in fact is used in that capacity by actors in boost.phoenix. It is more common in EDSLs such as cpp.react.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://geeksforgeeks.org/operator-overloading-cpp",
        "document": "in C++, Operator overloading is a compile-time polymorphism. It is an idea of giving special meaning to an existing operator in C++ without changing its original meaning.\n\nIn this article, we will further discuss about operator overloading in C++ with examples and see which operators we can or cannot overload in C++.\n\nC++ has the ability to provide the operators with a special meaning for a data type, this ability is known as operator overloading. Operator overloading is a compile-time polymorphism. For example, we can overload an operator ‘+’ in a class like String so that we can concatenate two strings by just using +. Other example classes where arithmetic operators may be overloaded are Complex Numbers, Fractional Numbers, Big integers, etc.\n\nHere, variables “a” and “b” are of types “int” and “float”, which are built-in data types. Hence the addition operator ‘+’ can easily add the contents of “a” and “b”. This is because the addition operator “+” is predefined to add variables of built-in data type only.\n\n\n\nIn this example, we have 3 variables “a1”, “a2” and “a3” of type “class A”. Here we are trying to add two objects “a1” and “a2”, which are of user-defined type i.e. of type “class A” using the “+” operator. This is not allowed, because the addition operator “+” is predefined to operate only on built-in data types. But here, “class A” is a user-defined type, so the compiler generates an error. This is where the concept of “Operator overloading” comes in.\n\nNow, if the user wants to make the operator “+” add two class objects, the user has to redefine the meaning of the “+” operator such that it adds two class objects. This is done by using the concept of “Operator overloading”. So the main idea behind “Operator overloading” is to use C++ operators with class variables or class objects. Redefining the meaning of operators really does not change their original meaning; instead, they have been given additional meaning along with their existing ones.\n\nExample of Operator Overloading in C++\n\nOperator functions are the same as normal functions. The only differences are, that the name of an operator function is always the operator keyword followed by the symbol of the operator, and operator functions are called when the corresponding operator is used.\n\nCan We Overload All Operators?\n\nAlmost all operators can be overloaded except a few. Following is the list of operators that cannot be overloaded.\n\nOperators that can be Overloaded in C++\n\nBut, among them, there are some operators that cannot be overloaded. They are\n\nWhy can’t the above-stated operators be overloaded?\n\nThis returns the size of the object or datatype entered as the operand. This is evaluated by the compiler and cannot be evaluated during runtime. The proper incrementing of a pointer in an array of objects relies on the sizeof operator implicitly. Altering its meaning using overloading would cause a fundamental part of the language to collapse.\n\nThis provides a CPP program with the ability to recover the actually derived type of the object referred to by a pointer or reference. For this operator, the whole point is to uniquely identify a type. If we want to make a user-defined type ‘look’ like another type, polymorphism can be used but the meaning of the typeid operator must remain unaltered, or else serious issues could arise.\n\nThis helps identify and specify the context to which an identifier refers by specifying a namespace. It is completely evaluated at runtime and works on names rather than values. The operands of scope resolution are note expressions with data types and CPP has no syntax for capturing them if it were overloaded. So it is syntactically impossible to overload this operator.\n\nThe importance and implicit use of class member access operators can be understood through the following example:\n\nThe statement ComplexNumber c3 = c1 + c2; is internally translated as ComplexNumber c3 = c1.operator+ (c2); in order to invoke the operator function. The argument c1 is implicitly passed using the ‘.’ operator. The next statement also makes use of the dot operator to access the member function print and pass c3 as an argument.\n\nBesides, these operators also work on names and not values and there is no provision (syntactically) to overload them.\n\nThe ternary or conditional operator is a shorthand representation of an if-else statement. In the operator, the true/false expressions are only evaluated on the basis of the truth value of the conditional expression.\n\nconditional statement ? expression1 (if statement is TRUE) : expression2 (else)\n\nA function overloading the ternary operator for a class say ABC using the definition\n\nwould not be able to guarantee that only one of the expressions was evaluated. Thus, the ternary operator cannot be overloaded.\n\n1) For operator overloading to work, at least one of the operands must be a user-defined class object.\n\n2) Assignment Operator: Compiler automatically creates a default assignment operator with every class. The default assignment operator does assign all members of the right side to the left side and works fine in most cases (this behavior is the same as the copy constructor). See this for more details.\n\n3) Conversion Operator: We can also write conversion operators that can be used to convert one type to another type.\n\nOverloaded conversion operators must be a member method. Other operators can either be the member method or the global method.\n\n4) Any constructor that can be called with a single argument works as a conversion constructor, which means it can also be used for implicit conversion to the class being constructed."
    },
    {
        "link": "https://isocpp.org/wiki/faq/operator-overloading",
        "document": "It allows you to provide an intuitive interface to users of your class, plus makes it possible for templates to work equally well with classes and built-in/intrinsic types.\n\nOperator overloading allows C/C++ operators to have user-defined meanings on user-defined types (classes). Overloaded operators are syntactic sugar for function calls:\n\nWhat are the benefits of operator overloading?\n\nBy overloading standard operators on a class, you can exploit the intuition of the users of that class. This lets users program in the language of the problem domain rather than in the language of the machine.\n\nThe ultimate goal is to reduce both the learning curve and the defect rate.\n\nWhat are some examples of operator overloading?\n\nHere are a few of the many examples of operator overloading:\n• might access an element of an object\n• might dereference a “smart pointer” that “points” to a disk record — it could seek to the location on disk where “points” and return the appropriate record into\n\nBut overloading makes my class look ugly; isn’t it supposed to make my code clearer?\n\nOperator overloading makes life easier for the users of a class, not for the developer of the class!\n\nConsider the following example.\n\nSome people don’t like the keyword or the somewhat funny syntax that goes with it in the body of the class itself. But the overloading syntax isn’t supposed to make life easier for the developer of a class. It’s supposed to make life easier for the users of the class:\n\nRemember: in a reuse-oriented world, there will usually be many people who use your class, but there is only one person who builds it (yourself); therefore you should do things that favor the many rather than the few.\n\nMost can be overloaded. The only C operators that can’t be are and (and , which is technically an operator). C++ adds a few of its own operators, most of which can be overloaded except and .\n\nHere’s an example of the subscript (it returns a reference). First without overloading:\n\nNow the same logic is presented with operator overloading:\n\nMost operators can be overloaded by a programmer. The exceptions are\n\nThere is no fundamental reason to disallow overloading of . So far the committee just hasn’t seen the need to introduce the special case of overloading a ternary operator. Note that a function overloading would not be able to guarantee that only one of and was executed.\n\ncannot be overloaded because built-in operations, such as incrementing a pointer into an array implicitly depends on it. Consider:\n\nThus, could not be given a new and different meaning by the programmer without violating basic language rules.\n\nWhat about ? In neither nor are expressions with values; and are names known to the compiler and performs a (compile time) scope resolution rather than an expression evaluation. One could imagine allowing overloading of where is an object rather than a namespace or a class, but that would – contrary to first appearances – involve introducing new syntax (to allow ). It is not obvious what benefits such a complication would bring.\n\n(dot) could in principle be overloaded using the same technique as used for . However, doing so can lead to questions about whether an operation is meant for the object overloading or an object referred to by . For example:\n\nThis problem can be solved in several ways. So far in standardization, it has not been obvious which way would be best. For more details, see D&E.\n\nCan I define my own operators?\n\nSorry, no. The possibility has been considered several times, but each time it was decided that the likely problems outweighed the likely benefits.\n\nIt’s not a language-technical problem. Even when Stroustrup first considered it in 1983, he knew how it could be implemented. However, the experience has been that when we go beyond the most trivial examples people seem to have subtly different opinions of “the obvious” meaning of uses of an operator. A classical example is . Assume that has been made to mean exponentiation. Now should mean or ? Experts have thought the answer was obvious and their friends agreed – and then found that they didn’t agree on which resolution was the obvious one. Such problems seem prone to lead to subtle bugs.\n\nCan I overload so it lets me compare two using a string comparison?\n\nNo: at least one operand of any overloaded must be of some user-defined type (most of the time that means a ).\n\nBut even if C++ allowed you to do this, which it doesn’t, you wouldn’t want to do it anyway since you really should be using a -like class rather than an array of in the first place since arrays are evil.\n\nThe names of, precedence of, associativity of, and arity of operators is fixed by the language. There is no in C++, so you cannot create one for a type.\n\nIf you’re in doubt, consider that is the same as (in other words, the compiler assumes is a pointer). Besides, overloading is just syntactic sugar for function calls. Although this particular syntactic sugar can be very sweet, it doesn’t add anything fundamental. I suggest you overload (a double precision version is in ).\n\nBy the way, can work for to-the-power-of, except it has the wrong precedence and associativity.\n\nThe previous FAQs tell me which operators I can override; but which operators should I override?\n\nRemember the purpose of operator overloading: to reduce the cost and defect rate in code that uses your class. If you create operators that confuse your users (because they’re cool, because they make the code faster, because you need to prove to yourself that you can do it; doesn’t really matter why), you’ve violated the whole reason for using operator overloading in the first place.\n\nWhat are some guidelines / “rules of thumb” for overloading operators?\n\nHere are a few guidelines / rules of thumb (but be sure to read the previous FAQ before reading this list):\n• Use common sense. If your overloaded operator makes life easier and safer for your users, do it; otherwise don’t. This is the most important guideline. In fact it is, in a very real sense, the only guideline; the rest are just special cases.\n• If you define arithmetic operators, maintain the usual arithmetic identities. For example, if your class defines and , then ought to return an object that is behaviorally equivalent to . The term behaviorally equivalent is defined in the bullet on below, but simply put, it means the two objects should ideally act like they have the same state. This should be true even if you decide not to define an operator for objects of your class.\n• You should provide arithmetic operators only when they make logical sense to users. Subtracting two dates makes sense, logically returning the duration between those dates, so you might want to allow for objects of your class (provided you have a reasonable class/type to represent the duration between two objects). However adding two dates makes no sense: what does it mean to add July 4, 1776 to June 5, 1959? Similarly it makes no sense to multiply or divide dates, so you should not define any of those operators.\n• You should provide mixed-mode arithmetic operators only when they make logical sense to users. For example, it makes sense to add a duration (say 35 days) to a date (say July 4, 1776), so you might define to return a . Similarly could also return a . But does not make sense at the conceptual level (what does it mean to subtract July 4, 1776 from 35 days?) so you should not define that operator.\n• If you provide constructive operators, they should return their result by value. For example, should return its result by value. If it returns by reference, you will probably run into lots of problems figuring out who owns the referent and when the referent will get destructed. Doesn’t matter if returning by reference is more efficient; it is probably wrong. See the next bullet for more on this point.\n• If you provide constructive operators, they should not change their operands. For example, should not change . For some crazy reason, programmers often define to be logically the same as because the latter is faster. But remember, your users expect to make a copy. In fact they selected the operator (over, say, the operator) precisely because they wanted a copy. If they wanted to modify , they would have used whatever is equivalent to instead. Don’t make semantic decisions for your users; it’s their decision, not yours, whether they want the semantics of vs. . Tell them that one is faster if you want, but then step back and let them make the final decision — they know what they’re trying to achieve and you do not.\n• If you provide constructive operators, they should allow promotion of the left-hand operand (at least in the case where the class has a single-parameter ctor that is not marked with the keyword). For example, if your class supports promotion from to (via the non- ctor ), and if you allow for two objects, you should also allow . In practice that simply means that your should not be a member function of . Typically you will make it a friend, if for no other reason than to force it into the part of the class, but even if it is not a friend, it should not be a member.\n• In general, your operator should change its operand(s) if and only if the operands get changed when you apply the same operator to intrinsic types. and should not change either operand; and should (but only the left-hand operand).\n• If you define and , maintain the usual identities. For example, and should have the same observable effect on , and should differ only in what they return. should return by reference; should either return a copy (by value) of the original state of or should have a return-type. You’re usually better off returning a copy of the original state of by value, especially if your class will be used in generic algorithms. The easy way to do that is to implement using three lines: make a local copy of , call (i.e., ), then return the local copy. Similar comments for and .\n• If you define and , maintain the usual identities. For example, these expressions should have the same observable behavior, including the same result. Among other things, that means your operator should return by reference. Similar comments for and .\n• If you define and for pointer-like objects, maintain the usual identities. For example, these two expressions should have the same result and neither should change .\n• If you define and for pointer-like objects, maintain the usual identities. For example, these two expressions should have the same result and neither should change . Similar comments for and .\n• Subscript operators generally come in pairs; see on -overloading.\n• If you define , then should be true if and only if the two objects are behaviorally equivalent. In this bullet, the term “behaviorally equivalent” means the observable behavior of any operation or sequence of operations applied to will be the same as when applied to . The term “operation” means methods, friends, operators, or just about anything else you can do with these objects (except, of course, the address-of operator). You won’t always be able to achieve that goal, but you ought to get close, and you ought to document any variances (other than the address-of operator).\n• If you define and , maintain the usual identities. For example, after an assignment, the two objects should be equal. Even if you don’t define , the two objects should be behaviorally equivalent (see above for the meaning of that phrase) after an assignment.\n• If you define and , you should maintain the usual identities. For example, these expressions should return something convertible to , neither should change its operands, and should have the same result as , and vice versa.\n• If you define inequality operators like and , you should maintain the usual identities. For example, if and are both true, then should also be true, etc. Similar comments for and .\n• If you define inequality operators like and , you should maintain the usual identities. For example, should have the result as . You can’t always do that, but you should get close and you should document any variances. Similar comments for and , etc.\n• Avoid overloading short-circuiting operators: or . The overloaded versions of these do not short-circuit — they evaluate both operands even if the left-hand operand “determines” the outcome, so that confuses users.\n• Avoid overloading the comma operator: . The overloaded comma operator does not have the same ordering properties that it has when it is not overloaded, and that confuses users.\n• Don’t overload an operator that is non-intuitive to your users. This is called the Doctrine of Least Surprise. For example, although C++ uses for printing, and although printing is technically called inserting, and although inserting sort of sounds like what happens when you push an element onto a stack, don’t overload to push an element onto a stack. It might make sense when you’re really tired or otherwise mentally impaired, and a few of your friends might think it’s “kewl,” but just say No.\n• Use common sense. If you don’t see “your” operator listed here, you can figure it out. Just remember the ultimate goals of operator overloading: to make life easier for your users, in particular to make their code cheaper to write and more obvious.\n\nCaveat: the list is not exhaustive. That means there are other entries that you might consider “missing.” I know.\n\nCaveat: the list contains guidelines, not hard and fast rules. That means almost all of the entries have exceptions, and most of those exceptions are not explicitly stated. I know.\n\nCaveat: please don’t email me about the additions or exceptions. I’ve already spent way too much time on this particular answer.\n\nHow do I create a subscript for a class?\n\nUse rather than .\n\nWhen you have multiple subscripts, the cleanest way to do it is with rather than with . The reason is that always takes exactly one parameter, but can take any number of parameters (in the case of a rectangular matrix, two parameters are needed).\n\nThen you can access an element of using rather than :\n\nSee the next FAQ for more detail on the reasons to use vs. .\n\nWhy shouldn’t my class’s interface look like an array-of-array?\n\nHere’s what this FAQ is really all about: Some people build a Matrix class that has an that returns a reference to an object (or perhaps to a raw array, shudder), and that object has an that returns an element of the Matrix (e.g., a reference to a ). Thus they access elements of the matrix using syntax like rather than syntax like .\n\nThe array-of-array solution obviously works, but it is less flexible than the approach. Specifically, there are easy performance tuning tricks that can be done with the approach that are more difficult in the approach, and therefore the approach is more likely to lead to bad performance, at least in some cases.\n\nFor example, the easiest way to implement the approach is to use a physical layout of the matrix as a dense matrix that is stored in row-major form (or is it column-major; I can’t ever remember). In contrast, the approach totally hides the physical layout of the matrix, and that can lead to better performance in some cases.\n\nPut it this way: the approach is never worse than, and sometimes better than, the approach.\n• The approach is never worse because it is easy to implement the dense, row-major physical layout using the approach, so when that configuration happens to be the optimal layout from a performance standpoint, the approach is just as easy as the approach (perhaps the approach is a tiny bit easier, but I won’t quibble over minor nits).\n• The approach is sometimes better because whenever the optimal layout for a given application happens to be something other than dense, row-major, the implementation is often significantly easier using the approach compared to the approach.\n\nAs an example of when a physical layout makes a significant difference, a recent project happened to access the matrix elements in columns (that is, the algorithm accesses all the elements in one column, then the elements in another, etc.), and if the physical layout is row-major, the accesses can “stride the cache”. For example, if the rows happen to be almost as big as the processor’s cache size, the machine can end up with a “cache miss” for almost every element access. In this particular project, we got a 20% improvement in performance by changing the mapping from the logical layout (row,column) to the physical layout (column,row).\n\nOf course there are many examples of this sort of thing from numerical methods, and sparse matrices are a whole other dimension on this issue. Since it is, in general, easier to implement a sparse matrix or swap row/column ordering using the approach, the approach loses nothing and may gain something — it has no down-side and a potential up-side.\n\nI still don’t get it. Why shouldn’t my class’s interface look like an array-of-array?\n\nThe same reasons you encapsulate your data structures, and the same reason you check parameters to make sure they are valid.\n\nA few people use despite its limitations, arguing that is better because it is faster or because it uses C-syntax. The problem with the “it’s faster” argument is that it’s not — at least not on the latest version of two of the world’s best known C++ compilers. The problem with the “uses C-syntax” argument is that C++ is not C. Plus, oh yea, the C-syntax makes it harder to change the data structure and harder to check parameter values.\n\nThe point of the previous two FAQs is that gives you a clean, simple way to check all the parameters and to hide (and therefore, if you want to, change) the internal data structure. The world already has way too many exposed data structures and way too many out-of-bounds parameters, and those cost way too much money and cause way too many delays and way too many defects.\n\nNow everybody knows that you are different. You are clairvoyant with perfect knowledge of the future, and you know that no one will ever find any benefit from changing your matrix’s internal data structure. Plus you are a good programmer, unlike those slobs out there that occasionally pass wrong parameters, so you don’t need to worry about pesky little things like parameter checking. But even though you don’t need to worry about maintenance costs (no one ever needs to change your code), there might be one or two other programmers who aren’t quite perfect yet. For them, maintenance costs are high, defects are real, and requirements change. Believe it or not, every once in a while they need to (better sit down) change their code.\n\nAdmittedly my thongue wath in my theek. But there was a point. The point was that encapsulation and parameter-checking are not crutches for the weak. It’s smart to use techniques that make encapsulation and/or parameter checking easy. The syntax is one of those techniques.\n\nHaving said all that, if you find yourself maintaining a billion-line app where the original team used , or even if you are writing a brand new app and you just plain want to use , you can still encapsulate the data structure and/or check all your parameters. It’s not even that hard. However it does require a level of sophistication that, like it or not, average C++ programmers fear. Fortunately you are not average, so read on.\n\nIf you merely want to check parameters, just make sure the outer returns an object rather than a raw array, then that object’s can check its parameter in the usual way. Beware that this can slow down your program. In particular, if these inner array-like objects end up allocating their own block of memory for their row of the matrix, the performance overhead for creating / destroying your matrix objects can grow dramatically. The theoretical cost is still O(rows × cols), but in practice, the overhead of the memory allocator ( or ) can be much larger than anything else, and that overhead can swamp the other costs. For instance, on two of the world’s best known C++ compilers, the separate-allocation-per-row technique was 10x slower than the one-allocation-for-the-entire-matrix technique. 10% is one thing, 10x is another.\n\nIf you want to check the parameters without the above overhead and/or if you want to encapsulate (and possibly change) the matrix’s internal data structure, follow these steps:\n• Create nested class . It should have a ctor with parameters , and it should store those two values in its object.\n• Change so it returns an object of class , e.g., .\n• Class then defines its own which turns around and calls, you guessed it, . If the data members are called and , the code for will be\n\nNext you will enable overloading by repeating the above steps. You will create the version of the various methods, and you will create a new nested class, probably called . Don’t forget to use instead of .\n\nFinal step: find the joker who failed to read the previous FAQ and thonk him in the noggin.\n\nIf you have a decent compiler and if you judiciously use inlining, the compiler should optimize away the temporary objects. In other words, the -approach above will hopefully not be slower than what it would have been if you had directly called in the first place. Of course you could have made your life simpler and avoided most of the above work by directly calling in the first place. So you might as well directly call in the first place.\n\nShould I design my classes from the outside (interfaces first) or from the inside (data first)?\n\nFrom the outside!\n\nA good interface provides a simplified view that is expressed in the vocabulary of a user. In the case of OO software, the interface is normally the set of public methods of either a single class or a tight group of classes.\n\nFirst think about what the object logically represents, not how you intend to physically build it. For example, suppose you have a class that will be built by containing a :\n\nShould the Stack have a method that returns the ? Or a method that takes a ? Or a constructor that takes a ? Obviously the answer is No, since you should design your interfaces from the outside-in. I.e., users of objects don’t care about s; they care about pushing and popping.\n\nNow for another example that is a bit more subtle. Suppose class is built using a linked list of objects, where each object has a pointer to the next :\n\nShould the class have a method that will let users access the first ? Should the object have a method that will let users follow that to the next in the chain? In other words, what should a look like from the outside? Is a really a chain of objects? Or is that just an implementation detail? And if it is just an implementation detail, how will the let users access each of the elements in the one at a time?\n\nThe key insight is the realization that a is not a chain of s. That may be how it is built, but that is not what it is. What it is is a sequence of elements. Therefore the abstraction should provide a as well, and that might have an to go to the next element, and it might have a / pair to access its value stored in the (the value in the element is solely the responsibility of the user, which is why there is a / pair that allows the user to freely manipulate that value).\n\nStarting from the user’s perspective, we might want our to support operations that look similar to accessing an array using pointer arithmetic:\n\nTo implement this interface, will need a method and an method. These return a object. The will need a method to go forward, ; a method to access the current element, ; and a comparison operator, .\n\nThe code follows. The important thing to notice is that does not have any methods that let users access s. s are an implementation technique that is completely buried. This makes the class safer (no chance a user will mess up the invariants and linkages between the various nodes), easier to use (users don’t need to expend extra effort keeping the node-count equal to the actual number of nodes, or any other infrastructure stuff), and more flexible (by changing a single , users could change their code from using to some other list-like class and the bulk of their code would compile cleanly and hopefully with improved performance characteristics).\n\nHere are the methods that are obviously inlinable (probably in the same header file):\n\nConclusion: The linked list had two different kinds of data. The values of the elements stored in the linked list are the responsibility of the user of the linked list (and only the user; the linked list itself makes no attempt to prohibit users from changing the third element to 5), and the linked list’s infrastructure data ( pointers, etc.), whose values are the responsibility of the linked list (and only the linked list; e.g., the linked list does not let users change (or even look at!) the various pointers).\n\nThus the only / methods were to get and set the elements of the linked list, but not the infrastructure of the linked list. Since the linked list hides the infrastructure pointers/etc., it is able to make very strong promises regarding that infrastructure (e.g., if it were a doubly linked list, it might guarantee that every forward pointer was matched by a backwards pointer from the next ).\n\nSo, we see here an example of where the values of some of a class’s data is the responsibility of users (in which case the class needs to have / methods for that data) but the data that the class wants to control does not necessarily have / methods.\n\nNote: the purpose of this example is not to show you how to write a linked-list class. In fact you should not “roll your own” linked-list class since you should use one of the “container classes” provided with your compiler. Ideally you’ll use one of the standard container classes such as the template.\n\nHow can I overload the prefix and postfix forms of operators and ?\n\nSince the prefix and postfix operators can have two definitions, the C++ language gives us two different signatures. Both are called , but the prefix version takes no parameters and the postfix version takes a dummy . (Although this discussion revolves around the operator, the operator is completely symmetric, and all the rules and guidelines that apply to one also apply to the other.)\n\nNote the different return types: the prefix version returns by reference, the postfix version by value. If that’s not immediately obvious to you, it should be after you see the definitions (and after you remember that and set to different things).\n\nThe other option for the postfix version is to return nothing:\n\nHowever you must not make the postfix version return the object by reference; you have been warned.\n\nHere’s how you use these operators:\n\nAssuming the return types are not ‘void’, you can use them in larger expressions:\n\nWhich is more efficient: or ?\n\nis sometimes faster than, and is never slower than, .\n\nFor intrinsic types like , it doesn’t matter: and are the same speed. For class types like iterators or the previous FAQ’s class, very well might be faster than since the latter might make a copy of the object.\n\nThe overhead of , if it is there at all, won’t probably make any practical difference unless your app is CPU bound. For example, if your app spends most of its time waiting for someone to click a mouse, doing disk I/O, network I/O, or database queries, then it won’t hurt your performance to waste a few CPU cycles. However it’s just as easy to type as , so why not use the former unless you actually need the old value of .\n\nSo if you’re writing as a statement rather than as part of a larger expression, why not just write instead? You never lose anything, and you sometimes gain something. Old line C programmers are used to writing instead of . E.g., they’ll say, . Since this uses as a statement, not as a part of a larger expression, then you might want to use instead. For symmetry, I personally advocate that style even when it doesn’t improve speed, e.g., for intrinsic types and for class types with postfix operators that return .\n\nObviously when appears as a part of a larger expression, that’s different: it’s being used because it’s the only logically correct solution, not because it’s an old habit you picked up while programming in C."
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/standard-library/overloading-the-output-operator-for-your-own-classes?view=msvc-170",
        "document": "Overloading the Operator for Your Own Classes\n\nOutput streams use the insertion ( ) operator for standard types. You can also overload the operator for your own classes.\n\nThe function example showed the use of a structure. A date is an ideal candidate for a C++ class in which the data members (month, day, and year) are hidden from view. An output stream is the logical destination for displaying such a structure. This code displays a date using the object:\n\nTo get to accept a object after the insertion operator, overload the insertion operator to recognize an object on the left and a on the right. The overloaded operator function must then be declared as a friend of class so it can access the private data within a object.\n\nThe overloaded operator returns a reference to the original object, which means you can combine insertions:"
    },
    {
        "link": "https://stackoverflow.com/questions/4421706/what-are-the-basic-rules-and-idioms-for-operator-overloading",
        "document": "Most of the work in overloading operators is boilerplate code. That is little wonder, since operators are merely syntactic sugar. Their actual work could be done by (and often is forwarded to) plain functions. But it is important that you get this boilerplate code right. If you fail, either your operator’s code won’t compile, your users’ code won’t compile, or your users’ code will behave surprisingly.\n\nThere's a lot to be said about assignment. However, most of it has already been said in GMan's famous Copy-And-Swap FAQ, so I'll skip most of it here, only listing the perfect assignment operator for reference:\n\nThe bitwise shift operators and , although still used in hardware interfacing for the bit-manipulation functions they inherit from C, have become more prevalent as overloaded stream input and output operators in most applications.\n\nThe stream operators, among the most commonly overloaded operators, are binary infix operators for which the syntax does not specify any restriction on whether they should be members or non-members. However, their left operands are streams from the standard library, and you cannot add member functions to those1, so you need to implement these operators for your own types as non-member functions2. The canonical forms of the two are these:\n\nWhen implementing , manually setting the stream’s state is only necessary when the reading itself succeeded, but the result is not what would be expected.\n\n1 Note that some of the overloads of the standard library are implemented as member functions, and some as free functions. Only the locale-dependent functions are member functions, such as .\n\n2 According to the rules of thumb, the insertion/extraction operators should be member functions because they modify the left operand. However, we cannot follow the rules of thumb here.\n\nThe function call operator, used to create function objects, also known as functors, must be defined as a member function, so it always has the implicit argument of member functions. Other than this, it can be overloaded to take any number of additional arguments, including zero.\n\nHere's an example of the syntax:\n\nThroughout the C++ standard library, function objects are always copied. Your own function objects should therefore be cheap to copy. If a function object absolutely needs to use data which is expensive to copy, it is better to store that data elsewhere and have the function object refer to it.\n\nIn the most simple case, you can overload all comparison comparison operators by defaulting in C++20:\n\nIf you can't do this, continue to the linked answer.\n\nThe unary prefix negation should be implemented as a member function. It is usually not a good idea to overload it because of how rare and surprising it is.\n\nThe remaining binary logical operators ( , ) should be implemented as free functions. However, it is very unlikely that you would find a reasonable use case for these1.\n\n1 It should be noted that the built-in version of and use shortcut semantics. While the user defined ones (because they are syntactic sugar for method calls) do not use shortcut semantics. User will expect these operators to have shortcut semantics, and their code may depend on it, Therefore it is highly advised NEVER to define them.\n\nThe unary increment and decrement operators come in both prefix and postfix flavor. To tell one from the other, the postfix variants take an additional dummy int argument. If you overload increment or decrement, be sure to always implement both prefix and postfix versions.\n\nHere is the canonical implementation of increment, decrement follows the same rules:\n\nNote that the postfix variant is implemented in terms of prefix. Also note that postfix does an extra copy.1\n\nOverloading unary minus and plus is not very common and probably best avoided. If needed, they should probably be overloaded as member functions.\n\n1 Also note that the postfix variant does more work and is therefore less efficient to use than the prefix variant. This is a good reason to generally prefer prefix increment over postfix increment. While compilers can usually optimize away the additional work of postfix increment for built-in types, they might not be able to do the same for user-defined types (which could be something as innocently looking as a list iterator). Once you got used to do , it becomes very hard to remember to do instead when is not of a built-in type (plus you'd have to change code when changing a type), so it is better to make a habit of always using prefix increment, unless postfix is explicitly needed.\n\nFor the binary arithmetic operators, do not forget to obey the third basic rule operator overloading: If you provide , also provide , if you provide , do not omit , etc. Andrew Koenig is said to have been the first to observe that the compound assignment operators can be used as a base for their non-compound counterparts. That is, operator is implemented in terms of , is implemented in terms of , etc.\n\nAccording to our rules of thumb, and its companions should be non-members, while their compound assignment counterparts ( , etc.), changing their left argument, should be a member. Here is the exemplary code for and ; the other binary arithmetic operators should be implemented in the same way:\n\nreturns its result per reference, while returns a copy of its result. Of course, returning a reference is usually more efficient than returning a copy, but in the case of , there is no way around the copying. When you write , you expect the result to be a new value, which is why has to return a new value.1\n\nAlso note that can be slightly shortened by passing by value, not by reference. However, this would be leaking implementation details, make the function signature asymmetric, and would prevent named return value optimization where is the same object as the one being returned.\n\nSometimes, it's impractical to implement in terms of , such as for matrix multiplication. In that case, you can also delegate to :\n\nThe bit manipulation operators should be implemented in the same way as the arithmetic operators. However, (except for overloading and for output and input) there are very few reasonable use cases for overloading these.\n\n1 Again, the lesson to be taken from this is that is, in general, more efficient than and should be preferred if possible.\n\nThe subscript operator is a binary operator which must be implemented as a class member. It is used for container-like types that allow access to their data elements by a key. The canonical form of providing these is this:\n\nUnless you do not want users of your class to be able to change data elements returned by (in which case you can omit the non-const variant), you should always provide both variants of the operator.\n\nFor defining your own iterators or smart pointers, you have to overload the unary prefix dereference operator and the binary infix pointer member access operator :\n\nNote that these, too, will almost always need both a const and a non-const version. For the operator, if is of (or or ) type, another is called recursively, until an returns a value of non-class type.\n\nThe unary address-of operator should never be overloaded.\n\nFor (and more details about ) see this question. is rarely used and thus rarely ever overloaded. In fact, even iterators do not overload it."
    },
    {
        "link": "https://quora.com/How-do-you-code-the-roots-of-a-cubic-equation-in-C",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://stackoverflow.com/questions/13328676/c-solving-cubic-equations",
        "document": "This site solves cubic equations, and has the equations it uses\n\nI wrote this function to get the same results but it's not working\n\nWhat could be the problem, is there something I am missing?\n\nFor instance, using these values\n\nThe discriminant is less then zero, so r13 is nan\n\nBut the site mentioned above and a couple of online solvers I've tested find the three roots\n\nAll of them real numbers"
    },
    {
        "link": "https://stackoverflow.com/questions/1204553/are-there-any-good-libraries-for-solving-cubic-splines-in-c",
        "document": "I had to write spline routine for an \"entity\" that was following a path (series of connected waypoints) in a game I am working on.\n\nI created a base class to handle a \"SplineInterface\" and the created two derived classes, one based on the classic spline technique (e.g. Sedgewick/Algorithms) an a second one based on Bezier Splines.\n\nHere is the code. It is a single header file, which contains all the splining classes:\n• The classic spline will crash if you give it a vertical set of points. That is why I created the Bezier...I have lots of vertical lines/paths to follow. It could be modified to just give a straight line.\n• The base class has an option to remove collinear points as you add them. This uses a simple slope comparison of two lines to figure out if they are on the same line. You don't have to do this, but for long paths that are straight lines, it cuts down on cycles. When you do a lot of pathfinding on a regular-spaced graph, you tend to get a lot of continuous segments.\n\nHere is an example of using the Bezier Spline:\n• While the whole path could be smoothed, in this application, since the path was changing every so often, it was better to just smooth the first points and then connect it up.\n• The points are loaded in \"reverse\" order into the path vector. This may or may not save cycles (I've slept since then).\n\nThis code is part of a much larger code base, but you can download it all on github and see a blog entry about it here.\n\nYou can look at this in action in this video."
    },
    {
        "link": "https://reddit.com/r/cpp_questions/comments/13qta0s/c_library_for_solving_equations",
        "document": "Hi everyone. So for my application i want to simplify user's life and generate inverse functions of functions they create in text file. i found the solution, but now in order to achieve that i want to find an existing library that solves EQUATIONS. An example would be: \"63 = x *1000\". If there is a library that can find the value of x, i will be endlessly grateful.\n\ni found TinyExpr and ExprTk but if i am not mistaken - they can handle expressions, not equations (with one unknown)."
    },
    {
        "link": "https://math.ivanovo.ac.ru/dalgebra/Khashin/poly/index.html",
        "document": "Solution of cubic and quartic equations C++\n\nLinear and quadratic equations with real coefficients are easy to solve. For the solution of the cubic equation we take a trigonometric Viete method, C++ code takes about two dozen lines. The roots of equation\n\nIn the case of three real roots function returns the number 3, the roots themselves back in .\n\nRemark 1. Roots are not necessarily ordered! \n\nIf two roots are match, the function returns 2 and in the array still there are a three numbers.\n\nIf the function returns 1, then is a real root and is a pair of coplex-conjugated roots.\n\nRemark 2. Due to rounding errors pair of complex conjugate roots with a very small imaginary part can sometimes be a real root of multiplicity 2. For example, for equation x3 - 5x2 + 8x - 4 = 0 with roots we obtain roots . If the absolute value of the imaginary part of the root not greater than 1e-14, the itself replaces a pair on one valid double root, but the user must still be aware of the possibility of such a situation.\n\nFor the solution of a quartic equation we take a Descartes-Euler method. Roots of the equation\n\nIn the case of 4 real roots function returns the number 4, the roots themselves back in .\n\nIn the case of 2 real and a pair of complex conjugate roots function returns the number 2, are the real roots and is a complex.\n\nIf the equation has two pairs of pairs of complex conjugate roots, the function returns 0, the root are and . \n\nRemark 3. Numerical experiments show that in some cases the resulting tolerance is quite large, up to 10-12. So at the end each found real root are specified with a single step of Newton's method.\n\nAll roots of the quintic equation\n\nQuintic equation have at least one real root. To find it, starting with the interval [-brd, brd] make 6 \"bisections\". Then check the root using the Newton method.\n\nFinding one real root x , divide it original polynomial f(x) and find the roots of the resulting polynomial of degree 4.\n\nThe solution of a quintic equation may be computed by the function\n\nIn the case of 5 real roots function returns the number 5, the roots themselves back in .\n\nIn the case of 3 real and a pair of complex conjugate roots function returns the number 3, are the real roots and is a complex.\n\nIf the equation has one real root and two pairs of pairs of complex conjugate roots, the function returns 1, is a real root and , are a complex roots.\n\nSolution of cubic equations is performed in a single function SolveP3. To solve the equations of degree 4 are three auxiliary functions:\n\nThe first is to extract the square root of a complex number: .\n\nSecond to solve the biquadratic equation, the third for the solutions of the depressed equation. \n\nRemark 4. As in the case of cubic equations the root of multiplicity 2 or a pair of very close real roots can be shown as a pair of complex conjugate roots with small imaginary part.\n\nSolution of quintic equations is performed in a function SolveP5:"
    }
]