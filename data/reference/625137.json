[
    {
        "link": "https://stackoverflow.com/questions/44305170/nil-slices-vs-non-nil-slices-vs-empty-slices-in-go-language",
        "document": "and empty slices (with 0 capacity) are not the same, but their observable behavior is the same (almost all the time). By this I mean:\n‚Ä¢ You can pass them to the builtin and functions\n‚Ä¢ You can over them (will be 0 iterations)\n‚Ä¢ You can slice them (by not violating the restrictions outlined at Spec: Slice expressions; so the result will also be an empty slice)\n‚Ä¢ Since their length is 0, you can't change their content (appending a value creates a new slice value)\n\nSee this simple example (a slice and 2 non- empty slices):\n\nOutput (try it on the Go Playground):\n\nBesides an exception, you can only tell the difference by comparing the slice value to the predeclared identifier , they behave the same in every other aspect. Do note however that many packages do compare slices to and may act differently based on that (e.g. and packages).\n\nThe only difference is by converting the slice to an array pointer (which was added to the language in Go 1.17). Converting a non- slice to an array pointer will result in a non- pointer, converting a slice to an array pointer will result in a pointer.\n\nTo tell if a slice is empty, simply compare its length to : . It doesn't matter if it's the slice or a non- slice, it also doesn't matter if it has a positive capacity; if it has no elements, it's empty.\n\nPrints (try it on the Go Playground):\n\nA slice value is represented by a struct defined in :\n\nIn case of a slice, this struct will have its zero value which is all its fields will be their zero value, that is: .\n\nHaving a non- slice with both capacity and length equal to , and fields will most certainly be , but the pointer may not be. It will not be, that is what differentiates it from the slice. It will point to a zero-sized underlying array.\n\nNote that the Go spec allows for values of different types having 0 size to have the same memory address. Spec: System considerations: Size and alignment guarantees:\n\nLet's check this. For this we call the help of the package, and \"obtain\" the struct \"view\" of our slice values:\n\nOutput (try it on the Go Playground):\n\nWhat do we see?\n‚Ä¢ All slices (slice headers) have different memory addresses\n‚Ä¢ and slices do have the same data pointer, sharing / pointing to the same 0-sized memory value"
    },
    {
        "link": "https://stackoverflow.com/questions/31707064/why-is-iterating-over-a-map-so-much-slower-than-iterating-over-a-slice-in-golang",
        "document": "This comes down to the representation in memory. How familiar are you with the representation of different data structures and the concept of algorithmic complexity? Iterating over an array or slice is simple. Values are contiguous in memory. However iterating over a map requires traversing the key space and doing lookups into the hash-table structure.\n\nThe dynamic ability of maps to insert keys of any value without using up tons of space allocating a sparse array, and the fact that look-ups can be done efficiently over the key space despite being not as fast as an array, are why hash tables are sometimes preferred over an array, although arrays (and slices) have a faster \"constant\" lookup time given an index.\n\nIt all comes down to whether you need the features of this or that data structure and whether you're willing to deal with the side-effects or gotchas involved."
    },
    {
        "link": "https://reddit.com/r/golang/comments/1586ab1/how_come_i_can_range_over_a_slice_map_etc_if_they",
        "document": "Found this surprising, but I believe there is some consistency here. Help me out, please."
    },
    {
        "link": "https://rezakhademix.medium.com/slices-in-golang-common-mistakes-and-best-practices-76c30857d4e4",
        "document": "In this story we want to discuss about slices in Golang and see some different scenarios to avoid common mistakes. Let‚Äôs dive in!\n\nA slice in Golang is a dynamically size data structure that is a reference to an underlying array. We must consider passing a slice to a function that modifies it will affect the original slice outside the function.\n\nSince we already know the fundamental of slices in Golang, we will skip the part of introducing , and other basic concepts about slices.\n\nAlthough nil slices and empty slices have the same behavior, it is important to know a slice has no underlying array while an empty slice referencing an underlying array with zero length.\n\nBe aware appending to a or zero-length slice needs allocation even though appending to a non-nil slice with enough capacity doesn‚Äôt need allocation. So, in most situations having a non-zero capacity (with well predicted value) is advantageous.\n\nLet‚Äôs imagine, we want to pop an item from an original slice to a new one, as below example: (we want to modify that only contains )\n\nAs we saw in the above code this result could be dangerous to our program so the correct way of doing this kind of operation could be:\n\nIf we define a new slice and set it equal to an existing slice, the new defined slice is of a reference type.\n\nThe correct way to make a separate copy of an existing slice is by using function, as below:\n\nAnother quick note is referencing new slice to an existing array, like below:\n\nThis will create a slice referencing . Modifying will also modify .\n\nSince Golang 1.21, we can use a generic function from the standard library like below:\n\nBut In previous versions of Golang we could use .\n\nslices in Golang are not thread safe. Passing slices without managing the potential race conditions will make our program to behave unpredictable.\n\nWe must use to protect concurrency.\n\nUsing function inside a for loop can lead our program to a reallocation iteration and it will consume too much resource so we should avoid it as long as we can.\n\nPreallocating with function is a viable option when we are working with large datasets.\n\nThat‚Äôs it. Here is the summary of what we have reviewed so far about slices in Golang.\n‚Ä¢ We should be careful about loops and\n\nIf you like this article please Clap üëè and follow me to get more of these Golang contents.\n‚Ä¢ Defer functions in Golang: Common Mistakes and Best Practices\n‚Ä¢ Strings in Golang: Common Mistakes and Best Practices\n‚Ä¢ Slices in Golang: Common Mistakes and Best Practices"
    },
    {
        "link": "https://ardanlabs.com/blog/2013/09/iterating-over-slices-in-go.html",
        "document": "Slices are used everywhere in my code. If I am working with data from MongoDB, it is stored in a slice. If I need to keep track of a collection of problems after running an operation, it is stored in a slice. If you don‚Äôt understand how slices work yet or have been avoiding them like I did when I started, read these two posts to learn more.\n\n\n\npackage main\n\n\n\nimport (\n\n \"fmt\"\n\n)\n\n\n\ntype Dog struct {\n\n Name string\n\n Age int\n\n}\n\n\n\nfunc main() {\n\n jackie := Dog{\n\n Name: \"Jackie\",\n\n Age: 19,\n\n }\n\n\n\n fmt.Printf(\"Jackie Addr: %p\n\n\", &jackie)\n\n\n\n sammy := Dog{\n\n Name: \"Sammy\",\n\n Age: 10,\n\n }\n\n\n\n fmt.Printf(\"Sammy Addr: %p\n\n\", &sammy)\n\n\n\n dogs := []Dog{jackie, sammy}\n\n\n\n fmt.Println(\"\")\n\n\n\n for _, dog := range dogs {\n\n fmt.Printf(\"Name: %s Age: %d\n\n\", dog.Name, dog.Age)\n\n fmt.Printf(\"Addr: %p\n\n\", &dog)\n\n\n\n fmt.Println(\"\")\n\n }\n\n}\n\nHere is the output for the program:\n\n\n\n\n\npackage main\n\n\n\nimport (\n\n \"fmt\"\n\n)\n\n\n\ntype Dog struct {\n\n Name string\n\n Age int\n\n}\n\n\n\nfunc main() {\n\n jackie := &Dog{\n\n Name: \"Jackie\",\n\n Age: 19,\n\n }\n\n\n\n fmt.Printf(\"Jackie Addr: %p\n\n\", jackie)\n\n\n\n sammy := &Dog{\n\n Name: \"Sammy\",\n\n Age: 10,\n\n }\n\n\n\n fmt.Printf(\"Sammy Addr: %p\n\n\n\n\", sammy)\n\n\n\n dogs := []*Dog{jackie, sammy}\n\n\n\n for _, dog := range dogs {\n\n fmt.Printf(\"Name: %s Age: %d\n\n\", dog.Name, dog.Age)\n\n fmt.Printf(\"Addr: %p\n\n\n\n\", dog)\n\n }\n\n}\n\npackage main\n\n\n\nimport (\n\n \"fmt\"\n\n)\n\n\n\ntype Dog struct {\n\n Name string\n\n Age int\n\n}\n\n\n\ntype DogCollection struct {\n\n Data []*Dog\n\n}\n\n\n\nfunc (this *DogCollection) Init() {\n\n cloey := &Dog{\"Cloey\", 1}\n\n ralph := &Dog{\"Ralph\", 5}\n\n jackie := &Dog{\"Jackie\", 10}\n\n bella := &Dog{\"Bella\", 2}\n\n jamie := &Dog{\"Jamie\", 6}\n\n\n\n this.Data = []*Dog{cloey, ralph, jackie, bella, jamie}\n\n}\n\n\n\nfunc (this *DogCollection) CollectionChannel() chan *Dog {\n\n dataChannel := make(chan *Dog, len(this.Data))\n\n\n\n for _, dog := range this.Data {\n\n dataChannel <- dog\n\n }\n\n\n\n close(dataChannel)\n\n\n\n return dataChannel\n\n}\n\n\n\nfunc main() {\n\n dc := DogCollection{}\n\n dc.Init()\n\n\n\n for dog := range dc.CollectionChannel() {\n\n fmt.Printf(\"Channel Name: %s\n\n\", dog.Name)\n\n }\n\n}\n\nChannel Name: Cloey\n\nChannel Name: Ralph\n\nChannel Name: Jackie\n\nChannel Name: Bella\n\nChannel Name: Jamie"
    },
    {
        "link": "https://betterstack.com/community/guides/scaling-go/json-in-go",
        "document": "JavaScript Object Notation (JSON) is a data format that has gained popularity since its introduction in the early 2000s. It has become a ubiquitous standard for data transfer across systems (such as API request bodies), surpassing previous formats like XML.\n\nGo, with its strong typing and emphasis on simplicity and efficiency, is well-suited for working with JSON data. Whether you're building web applications, working with APIs, or storing data in databases, Go provides a range of tools and techniques for working with JSON data.\n\nIn this article, we will provide a complete guide to working with JSON in Go. We will start by covering the serialization and deserialization of JSON data in Go, and then discuss how to validate JSON payloads. We will also cover best practices and common pitfalls to avoid when working with JSON data in Go.\n\nBy the end of this article, you'll have a deep understanding of how to work with JSON data in Go, and be well-equipped to write efficient, maintainable, and error-free code that works seamlessly with JSON data.\n\nTo follow along with this article, ensure that you have the latest version of Go installed on your machine. If you are missing Go, you can find the installation instructions here .\n\nYou can view and run the examples in this tutorial by setting up the demo repository :\n\nThen, install the necessary dependencies:\n\nThis article also assumes that you are comfortable with JSON syntax. If you are unfamiliar with JSON, refer to this resource for more information .\n\nThere are two key terminologies to note when working with JSON in Go:\n‚Ä¢ Marshalling: the act of converting a Go data structure into valid JSON.\n‚Ä¢ Unmarshalling: the act of parsing a valid JSON string into a data structure in Go.\n\nIn other languages, marshalling is often referred to as ‚Äúserializing‚Äù, while unmarshalling is referred to as ‚Äúdeserializing‚Äù. For the rest of this article, we will sticking with Go's terminology.\n\nThe following diagram illustrates these processes.\n\nWe will start by looking at how JSON access is achieved through the built-in package.\n\nWe will start by discussing the unmarshalling process using the method:\n\nThis methods accepts two arguments: the first is a which represents the JSON object to unmarshal, and the second is (introduced in Go 1.18 as an alias for ) which should be a pointer to the target data structure for storing the result of unmarshalling the JSON data.\n\nHere's an example that unmarshals a JSON object to a type:\n\nThe data type in Go is a generic container that can hold values of any type, including complex nested structures. In this case, the JSON keys will be unmarshalled into the type, and their corresponding values will be unmarshalled into the type of the . A map is permissible here as will allocate a new map in such cases. You can refer to the official documentation on for more information .\n\nThe expected output looks like this:\n\nIf an invalid JSON object is provided, an error will be returned by . A common example of an invalid JSON object is one that has a trailing comma :\n\nAttempting to unmarshal the JSON object above would yield the following error:\n\nWhile can be used to unmarshal JSON, it is not the most optimal solution for several reasons:\n‚Ä¢ None You lose the type safety and compile-time checks that are provided by Go's static type system. This can make it harder to catch errors and maintain code over time.\n‚Ä¢ None It can be slower than working with typed structs or custom types that implement the interface. This is because accessing fields in a map requires a dynamic lookup, whereas accessing fields in a struct is done statically at compile-time.\n‚Ä¢ None It can make it more difficult to reason about the structure of the JSON data being unmarshalled, as the values can be of any type. This can lead to more verbose and error-prone code.\n\nIn general, it's best to use typed structs or custom types whenever possible for JSON unmarshalling in Go. These types provide better type safety, performance, and maintainability than using .\n\nWhen using structs for unmsarshalling JSON objects, the field names in the object are mapped to the field names in the and the values are assigned accordingly. Let's look at a simple example of a struct type and how unmarshalling works with structs below:\n\nIn this example, the function takes the data, along with a pointer to a struct. The function then populates the fields in the struct with the corresponding values from the JSON data.\n\nYou can also unmarshal more complex JSON objects such as the one shown below:\n\nYou must design your target struct to include other structs as fields and allow to handle the mapping of fields accordingly.\n\nAs you can see, easily handles both nested JSON objects and nested JSON arrays. Do note that any nested structs must also match the same fields in the JSON.\n\nNow that we've explored how JSON unmarshalling works in Go, let's look at some gotchas when unmarshalling into structs in Go.\n\nCommon pitfalls with JSON unmarshalling in Go\n\nWhile JSON unmarshalling is a relatively simple task in Go, there are several common pitfalls that you should be aware of to avoid mistakes in your business logic. In this section, we will discuss some of the most common gotchas that you might face when unmarshalling JSON in Go and provide tips on how to avoid them\n\n1. Extra fields are omitted in the target struct\n\nIf the input JSON contains additional fields that are not a part of the target struct fields, they will be discarded when unmarshalled. Using the same struct declared above, we can demonstrate this behavior:\n\nNotice that the input JSON contains the additional field but that field is not included in the target struct. Therefore, it is discarded:\n\nMissing fields in the input JSON will cause the zero value of the corresponding struct field to be used instead:\n\nSince the field is been omitted from the input JSON, it will be an empty string in the resulting struct. If you wish to guarantee that a field is not omitted in the input JSON, you must use a validation library which will be discussed in a subsequent section.\n\nThe method will match the field name of the input JSON to the field in the in a case insensitive manner as long as the characters and their order are the same.\n\nNotice how the struct was populated successfully despite the casing of the fields in the input JSON.\n\nWhen defining structs for unmarshalling JSON, it's important to ensure that the names of struct fields match the keys in the JSON data exactly. If there is a mismatch, the field will not be populated with the corresponding value from the JSON data.\n\nAs you can see, the input JSON uses the key but the struct declares the field as so the unmarshalled does not use the input JSON‚Äôs value for . There is a workaround using struct tags that will be discussed in a subsequent section.\n\nIf there are type alias fields in your struct, their values and type alias will be preserved when unmarshalled:\n\nNow that we have understood some of the gotchas of unmarshalling data into structs, let us explore the more complex components of unmarshalling.\n\nThe method does the opposite of by converting a given data structure into a JSON. When working with the basic types in Go (strings, integers, slices, maps), it generates the corresponding JSON accordingly.\n\nNote that we have abstracted into a separate function to simplify the error handling process. Regardless, the example above illustrates how basic types in Go will be marshalled accordingly.\n\nIn most cases, you'll be working with more complex types like structs that represent database models or server responses. Marshalling these types requires more careful handling of the data, as the structure of the JSON output will depend on the structure of the Go type being marshalled.\n\nSimilar to unmarshalling JSON into structs, you can also marshal a struct into JSON.\n\nThe method produces a valid JSON from the given struct, including any nested JSON arrays or JSON objects.\n\nNotice that the generated JSON is a single line without proper formatting. Although this is an ideal form when transmitting information through a network, it is not a very user friendly representation of the JSON.\n\nIf you wish to format the JSON object, you can use the method which performs the same function as but applies some indentation to format the output.\n\nYou should now observe the following output:\n\nYou can configure two aspects of formatting with . The first is the prefix per line which appears at the start of every line. For most purposes, you would set this parameter to be an empty string. The second configures the indentation level which is two spaces in the above example.\n\nIn Go, struct tags are annotations that can be added to the fields of a struct to provide additional information about how the fields should be treated by various tools and libraries. Struct tags are strings that are added to the end of a field declaration, enclosed in backticks.\n\nThe most common use case for struct tags is to specify how a struct should be marshalled and unmarshalled to and from JSON. By adding tags to the fields of a struct, you can control how the fields are named, which fields are ignored, and how they are encoded and decoded.\n\nFor example, consider the following struct definition:\n\nAt the moment, the variable will be marshalled into the following JSON object where the properties correspond exactly to the struct field names:\n\nYou can customize this output by using struct tags on the type:\n\nNote the syntax of the struct tag. It appears after the type of the field, surrounded by \"``\", and takes on the following format: . Here, the field will be mapped to the JSON key \"name\", will be mapped to the JSON key \"age\", to \"favorite_treat\", and to \"breed\". You will now observe the following JSON output:\n\nIt also works the same way for unmarshalling. Assuming you have the following JSON input:\n\nYou can unmarshal it into the struct shown below:\n\nDo note that the case insensitivity and symbol sensitivity of unmarshalling will still apply with struct tags, but only to the standardized name declared in the tag (not the original field name).\n\nBeyond customizing the field names, struct tags can also be used to omit empty fields or to ignore fields altogether during marshalling and unmarshalling.\n\nTo omit an empty field (one with its zero value in Go), add the struct tag to the existing struct tag. To ignore a field whether it is empty or not, use .\n\nThe above code generates the following JSON:\n\nNotice that the field excluded from the marshalled JSON since it is ignored through . This can be useful in situations where you want to include a field in a struct for internal use, but you don't want it to be exposed or serialized in the JSON output. Do note that ignored fields will not be populated during unmarshalling.\n\nOn the other hand, the field is omitted since it was not initialized to a value in the variable. This creates a more concise JSON output that only includes the necessary fields.\n\nSuppose you're working with an external API with complex JSON responses. For instance, the Spotify API has the following JSON schema for fetching a user:\n\nTo manually map the JSON schema to a struct in Go would be a time consuming process, but this task can be eased through tools that can perform this conversion such as JSON-to-Go and JSON Typedef .\n\nFor instance, the following is generated using the JSON-to-Go web interface. As you can see, the generated code is not entirely perfect, but it provides a good starting point for working with the JSON responses from the API.\n\nWhile these tools can reduce the time spent manually converting the JSON schema to a Go , the generated code must be checked to ensure that the output meets your requirements.\n\nThere are two main forms of JSON validation. The first kind is involves validating that a given JSON string is proper (i.e. not malformed). The second kind checks if the input JSON conforms to a predefined schema.\n\nFirst, let's use the method to check for malformed JSON in Go:\n\nThe input JSON string does not wrap the key in double quotes.\n\nAs expected, the JSON string will return while the one will return . This is a good first step to ensure that you are working with valid JSON data. However, its often necessary to enforce a particular schema for the input JSON. This can be achieved using third-party validation packages such as go-playground/validator . It also relies on struct tags to perform data validation.\n\nTo begin using , install the package in your project. It has already been installed in the demo repository:\n\nThe package provides several struct tags that can be used to validate JSON input. However, we will only go through a handful of the most commonly used ones in this section.\n\nTo implement data validation on a struct, you must use the tags shown below:\n\nNotice that the validation rules are provided as a set of comma-separated values with some properties having a value after an symbol.\n\nIn English, the validation rules can be understood as such:\n‚Ä¢ Email must be present and it must follow the standard email format.\n‚Ä¢ Age must be present and it must at least 18 and at most 99.\n\nWe can test these validation rules by attempting to unmarshal a valid and invalid JSON.\n\nGiven the following invalid JSON, we should expect the validation to flag out the invalid fields:\n\nAs expected, the validator returns an error that flags the erroneous fields in the input JSON after unmarshalling:\n\nNote that the prior to using the package, the JSON was successfully unmarshalled since the validation struct tags are only evaluated when explicitly called.\n\nBy altering the input JSON to abide by the validation rules set out above, we can expect the validation to pass.\n\nThis time, with a valid JSON input, the validation passes:\n\nThe package supports many more struct tags for validation so you are encouraged to give the official documentation a thorough read.\n\nIn Go, you can define custom behavior for marshalling data by implementing the interface. This interface defines a single method, which takes no arguments and returns a byte slice and an error.\n\nTo implement the interface, you need to define a new type that wraps the original type you want to marshal. This new type should have a method named that returns a byte slice and an error.\n\nIn the above snippet, we defined a new type that wraps a value. In is subsequently used in the struct as the type of the value.\n\nHere's an example that marshals a value of type below:\n\nYou will observe the following output:\n\nNotice how the presented in the RFC 3339 format . You can now define the custom marshalling behavior that will return a different format for values (such as ) instead of the default RFC 3339 timestamp format.\n\nYou only need to define a method for the type as shown below:\n\nNow, when you marshal the variable once more, you will observe the new format for :\n\nCustomizing the unmarshalling behavior for a type works in a similar way. You need to implement the type instead:\n\nFor example, you can use the dateparse package to ensure that various date formats can be used to supply a birth date instead of the fixed formats allowed by :\n\nHere, the method unmarshals a JSON string in variety of formats into a value as long as it is supported by the package. With this in place, any of the following date formats (and many others) will be unmarshalled successfully:\n\nAs you can see, customizing the unmarshalling behavior allows for tremendous flexibility when parsing all kinds of JSON data.\n\nThe difference between JSON encoding and marshalling\n\nThe package also provides two other constructs for working with JSON in Go which are and . These types essentially do the same thing as and but they operate on streams of data instead of JSON objects that are already fully loaded in memory.\n\nFor example, can read from an (such as an ) and decode JSON values into a struct:\n\nYou will observe the following output:\n\nOne difference between and is that the former allows you to display an error when the input JSON contains properties that do not match any non-ignored, exported fields in the destination unlike the latter where such fields are simply ignored.\n\nThis is done through the method on the :\n\nAssuming the input JSON contains a property that is not present in the struct:\n\nYou will observe the following error:\n\nThe type, on the other hand, writes the JSON encoding of a Go type into a provided writable stream ( ). It is often used to write a JSON response to a client request:\n\nWhen you start the server and make a request to it, you will observe the following response:\n\nWhile is relatively dynamic and powerful, it is not the fastest JSON package out there. In performance critical situations, it might be worthwhile to consider a using a third-party package such as the ones shown below (not a comprehensive list):\n\nEach library has their pros and cons so be sure to investigate each one thoroughly before making a decision on what to use.\n\nWork is currently being done on a reimplementation of the encoding/json package that aims to provide a more flexible, performant, and easy to use package for JSON access in Go. It eventually aims to be proposed for addition to the Go standard library, but it remains in the design and experimentation phase\n\nThere are many behavior changes introduced in this new implementation. Some of the key ones to note include:\n‚Ä¢ Unmarshalling will now be case-sensitive (it was case-insensitive name matching previously),\n‚Ä¢ slices will be marshalled as an empty JSON array (it currently produces )\n‚Ä¢ maps will be marshalled as an empty JSON object (it currently produces ).\n‚Ä¢ To improve performance, JSONv2 no longer sorts the keys of a Go map.\n‚Ä¢ and several more .\n\nGiven that this is still at an experimental stage, it may not become a part of the standard library if it does not provide significant benefit over the existing package. As such, do not depend on it until it has been officially added to the Go standard library.\n\nTo sum up, Go delivers solid capabilities for handling JSON data. With its package, a diverse set of powerful tools is provided for encoding, decoding, marshalling, and unmarshalling JSON data within your Go applications.\n\nThroughout this article, we have explored various aspects of JSON handling in Go, such as the fundamentals of encoding and decoding JSON data, employing structs for marshalling and unmarshalling purposes, and identifying common gotchas to avoid when working with JSON data in Go.\n\nBy mastering these concepts and adhering to the presented best practices, you will be well-prepared to manage JSON data in your Go applications, leading to more efficient, maintainable, and error-free code."
    },
    {
        "link": "https://ron-liu.medium.com/mastering-json-in-go-a-comprehensive-guide-to-marshaling-and-unmarshaling-3c1206816351",
        "document": "Golang is increasingly popular for backend services, where JSON stands as the pivotal data format for communication. Its robust built-in support for JSON, a universally accepted data interchange format, is a key strength. Mastery of JSON marshaling and unmarshaling ‚Äî the conversion of Go data structures to JSON and back ‚Äî is essential for developers engaged in building web APIs, microservices, and any applications that necessitate data exchange.\n\nLet‚Äôs give a simple example to marshal and unmarshal JSON in Go."
    },
    {
        "link": "https://pkg.go.dev/encoding/json",
        "document": "HTMLEscape appends to dst the JSON-encoded src with <, >, &, U+2028 and U+2029 characters inside string literals changed to \\u003c, \\u003e, \\u0026, \\u2028, \\u2029 so that the JSON will be safe to embed inside HTML <script> tags. For historical reasons, web browsers don't honor standard HTML escaping within <script> tags, so an alternative JSON encoding must be used.\n\nIndent appends to dst an indented form of the JSON-encoded src. Each element in a JSON object or array begins on a new, indented line beginning with prefix followed by one or more copies of indent according to the indentation nesting. The data appended to dst does not begin with the prefix nor any indentation, to make it easier to embed inside other formatted JSON data. Although leading space characters (space, tab, carriage return, newline) at the beginning of src are dropped, trailing space characters at the end of src are preserved and copied to dst. For example, if src has no trailing spaces, neither will dst; if src ends in a trailing newline, so will dst.\n\nMarshal traverses the value v recursively. If an encountered value implements Marshaler and is not a nil pointer, Marshal calls [Marshaler.MarshalJSON] to produce JSON. If no [Marshaler.MarshalJSON] method is present but the value implements encoding.TextMarshaler instead, Marshal calls encoding.TextMarshaler.MarshalText and encodes the result as a JSON string. The nil pointer exception is not strictly necessary but mimics a similar, necessary exception in the behavior of [Unmarshaler.UnmarshalJSON].\n\nOtherwise, Marshal uses the following type-dependent default encodings:\n\nFloating point, integer, and Number values encode as JSON numbers. NaN and +/-Inf values will return an UnsupportedValueError.\n\nString values encode as JSON strings coerced to valid UTF-8, replacing invalid bytes with the Unicode replacement rune. So that the JSON will be safe to embed inside HTML <script> tags, the string is encoded using HTMLEscape, which replaces \"<\", \">\", \"&\", U+2028, and U+2029 are escaped to \"\\u003c\",\"\\u003e\", \"\\u0026\", \"\\u2028\", and \"\\u2029\". This replacement can be disabled when using an Encoder, by calling Encoder.SetEscapeHTML(false).\n\nArray and slice values encode as JSON arrays, except that []byte encodes as a base64-encoded string, and a nil slice encodes as the null JSON value.\n\nStruct values encode as JSON objects. Each exported struct field becomes a member of the object, using the field name as the object key, unless the field is omitted for one of the reasons given below.\n\nThe encoding of each struct field can be customized by the format string stored under the \"json\" key in the struct field's tag. The format string gives the name of the field, possibly followed by a comma-separated list of options. The name may be empty in order to specify options without overriding the default field name.\n\nThe \"omitempty\" option specifies that the field should be omitted from the encoding if the field has an empty value, defined as false, 0, a nil pointer, a nil interface value, and any array, slice, map, or string of length zero.\n\nAs a special case, if the field tag is \"-\", the field is always omitted. Note that a field with name \"-\" can still be generated using the tag \"-,\".\n\nExamples of struct field tags and their meanings:\n\nThe \"omitzero\" option specifies that the field should be omitted from the encoding if the field has a zero value, according to rules:\n\n1) If the field type has an \"IsZero() bool\" method, that will be used to determine whether the value is zero.\n\n2) Otherwise, the value is zero if it is the zero value for its type.\n\nIf both \"omitempty\" and \"omitzero\" are specified, the field will be omitted if the value is either empty or zero (or both).\n\nThe \"string\" option signals that a field is stored as JSON inside a JSON-encoded string. It applies only to fields of string, floating point, integer, or boolean types. This extra level of encoding is sometimes used when communicating with JavaScript programs:\n\nThe key name will be used if it's a non-empty string consisting of only Unicode letters, digits, and ASCII punctuation except quotation marks, backslash, and comma.\n\nEmbedded struct fields are usually marshaled as if their inner exported fields were fields in the outer struct, subject to the usual Go visibility rules amended as described in the next paragraph. An anonymous struct field with a name given in its JSON tag is treated as having that name, rather than being anonymous. An anonymous struct field of interface type is treated the same as having that type as its name, rather than being anonymous.\n\nThe Go visibility rules for struct fields are amended for JSON when deciding which field to marshal or unmarshal. If there are multiple fields at the same level, and that level is the least nested (and would therefore be the nesting level selected by the usual Go rules), the following extra rules apply:\n\n1) Of those fields, if any are JSON-tagged, only tagged fields are considered, even if there are multiple untagged fields that would otherwise conflict.\n\n2) If there is exactly one field (tagged or not according to the first rule), that is selected.\n\n3) Otherwise there are multiple fields, and all are ignored; no error occurs.\n\nHandling of anonymous struct fields is new in Go 1.1. Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of an anonymous struct field in both current and earlier versions, give the field a JSON tag of \"-\".\n\nMap values encode as JSON objects. The map's key type must either be a string, an integer type, or implement encoding.TextMarshaler. The map keys are sorted and used as JSON object keys by applying the following rules, subject to the UTF-8 coercion described for string values above:\n‚Ä¢ keys of any string type are used directly\n\nPointer values encode as the value pointed to. A nil pointer encodes as the null JSON value.\n\nInterface values encode as the value contained in the interface. A nil interface value encodes as the null JSON value.\n\nChannel, complex, and function values cannot be encoded in JSON. Attempting to encode such a value causes Marshal to return an UnsupportedTypeError.\n\nJSON cannot represent cyclic data structures and Marshal does not handle them. Passing cyclic structures to Marshal will result in an error."
    },
    {
        "link": "https://stackoverflow.com/questions/58240704/is-json-tag-in-struct-really-necessary-for-marshaling",
        "document": "I was interested to learn if there is a way to have this:\n\nand still allow for JSON marhaling/unmarshaling? Is there a library or a way to automatically assume or inject these tags without having to be explicit in every struct field?"
    },
    {
        "link": "https://stackoverflow.com/questions/34638717/golang-marshal-unmarshal-json-with-a-custom-tag",
        "document": "I think the way you wrote your example might have been a bit incorrect?\n\nWhen I run your code using inplace of I get not as I think your example would imply. Here is that code running in the Go Playground to illustrate the output:\n\nAssuming I am correct about what you wanted then that would imply what you really wanted was for your output to be when you call .\n\nBased on that assumption you could accomplish with the following code ‚Äî which you can see in the Go Playground ‚Äî after which I will explain the code. (If my assumption was not correct I will address that too):\n‚Ä¢ None You cannot add a method to the the package because Go does not allow for safe monkey patching. However, you can add a method to your struct, and this example also shows you how to call it:\n‚Ä¢ None Next you need to add a method to your struct. This will get called when you call and pass an instance of to it.\n\n\n\nThe following is a simple example that hard-codes a return value of so you can see in the playground how adding a to affects : The output for this will be:\n‚Ä¢ None Inside the method we need to produce JSON with the tags instead of the tags meaning we will need to generate JSON within the method because Go does not provide us with the JSON; it expects us to generate it.\n\n\n\n And the easiest way to generate JSON in Go is to use . However, if we use where is an instance of that gets passed as the receiver when calling it will end up in an infinite recursive loop!\n\n\n\nThe solution is to create a new struct type based on and identical to the existing type of , except for its identity. Creating a new type based on is as easy as:\n‚Ä¢ None Since we have we can now cast our instance of to be of type to break the association with our custom . This works because our method was specific to the type with the identity of and not with the type . Passing an instance of to allows us to use the default JSON marshalling we get from Go. \n\n\n\nTo illustrate, here you can see an example that uses and sets its property to giving us output of (you can also see it run in the Go playground): The output for this will be:\n‚Ä¢ None Next we process and manipulate the JSON inside . This can be done by using to an variable which we can then use a type assertion to treat the variable as a map.\n\n\n\nHere is a standalone example unrelated to the prior examples that illustrates this by printing (Again you can see it work in the Go Playground): The output for this will be:\n‚Ä¢ None Our next challenge is to access the tags. Tags are accessible using Reflection. Go provides reflection functionality in the standard reflect package. \n\n\n\nUsing our struct from above, here is a simple example that illustrates how to use Reflection. It uses the function to retrieve the type as a value and then introspects that type to retrieve the tags for each field. The code for retrieving each tag is , which is hopefully somewhat self-explanatory (and again, check it out in the Go Playground): The output for this will be:\n‚Ä¢ None Now that we have covered all the building blocks we can bring it all together into a working solution. The only addition worth mentioning are the creation of a new map variable of the same length as to allow us to store the values using the tags: func (f Foo) MarshalJSON() ([]byte, error) { es := esFoo(f) _json,err := json.Marshal(es) { if err != nil { goto end } var intf interface{} err = json.Unmarshal(_json, &intf) if err != nil { goto end } m := intf.(map[string]interface{}) _m := make(map[string]interface{},len(m)) t := reflect.TypeOf(f) i := 0 for _,v := range m { tag, found := t.Field(i).Tag.Lookup(\"es\") if !found { continue } _m[tag] = v i++ } _json,err = json.Marshal(_m) } end: return _json,err }\n‚Ä¢ None However, there is still one detail left undone. With all the above code will generate JSON for the tags, but so will and we want the latter to return its use of the tags. \n\n\n\nSo address that we just need to: a. Add a local package variable with an initial value of , b. Modify to set to before calling , and then c. To set back to before returning, and d. Lastly modify to only perform the logic required for the tags if is set to : \n\n\n\nWhich brings us to the final code ‚Äî with a second property in to provide a better example (and finally, you can of course see here in the Go Playground): package main import ( \"encoding/json\" \"log\" \"reflect\" ) type Foo struct { Foo string `json:\"test\" es:\"bar\"` Bar string `json:\"live\" es:\"baz\"` } type esFoo Foo var useESTags = false func (f Foo) MarshalWithESTag() ([]byte, error) { useESTags = true data, err := json.Marshal(f) useESTags = false return data,err } func (f Foo) MarshalJSON() ([]byte, error) { es := esFoo(f) _json,err := json.Marshal(es) if useESTags { if err != nil { goto end } var intf interface{} err = json.Unmarshal(_json, &intf) if err != nil { goto end } m := intf.(map[string]interface{}) _m := make(map[string]interface{},len(m)) t := reflect.TypeOf(f) i := 0 for _,v := range m { tag, found := t.Field(i).Tag.Lookup(\"es\") if !found { continue } _m[tag] = v i++ } _json,err = json.Marshal(_m) } end: return _json,err } func main() { f := &Foo{\"Hello\",\"World\"} data, _ := json.Marshal(f) log.Println(string(data)) // -> {\"test\":\"Hello\",\"live\":\"World\"} data, _ = f.MarshalWithESTag() log.Println(string(data)) // -> {\"bar\":\"Hello\",\"baz\":\"World\"} }\n‚Ä¢ None If my assumption was wrong I think I can at least assume this code I provided gives you enough to achieve your objective. You should be able to swap the keys and values in your output if that is actually what you want given the techniques shown. If not, please comment asking for help.\n‚Ä¢ None Finally, I would be remiss not to mention that reflection can be slow and that this example uses reflection multiple times per object to achieve your desired output. For many use-cases the time required to process JSON this way won't be significant. However, for many other use-cases the execution time can be a deal-killer. Several commented that you should approach this a different way; if performance matters and/or using a more idiomatic Go approach is important, you might want to seriously consider their recommendations."
    }
]