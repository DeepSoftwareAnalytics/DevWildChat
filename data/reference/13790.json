[
    {
        "link": "https://en.cppreference.com/w/cpp/numeric/complex",
        "document": "Specializations of for cv-unqualified standard(until C++23) floating-point types are TriviallyCopyable(since C++23) LiteralTypes for representing and manipulating complex number.\n\nFor any object z of type , reinterpret_cast<T(&)[2]>(z)[0] is the real part of z and reinterpret_cast<T(&)[2]>(z)[1] is the imaginary part of z.\n\nFor any pointer to an element of an array of named p and any valid array index i, reinterpret_cast<T*>(p)[2 * i] is the real part of the complex number p[i], and reinterpret_cast<T*>(p)[2 * i + 1] is the imaginary part of the complex number p[i].\n\nThe intent of this requirement is to preserve binary compatibility between the C++ library complex number types and the C language complex number types (and arrays thereof), which have an identical object representation requirement.\n\nIn order to satisfy the requirements of array-oriented access, an implementation is constrained to store the real and imaginary parts of a specialization in separate and adjacent memory locations. Possible declarations for its non-static data members include:\n• an array of type , with the first element holding the real part and the second element holding the imaginary part (e.g. Microsoft Visual Studio);\n• a single member of type (encapsulating the corresponding C language complex number type) (e.g. GNU libstdc++);\n• two members of type , with the same member access, holding the real and the imaginary parts respectively (e.g. LLVM libc++).\n\nAn implementation cannot declare additional non-static data members that would occupy storage disjoint from the real and imaginary parts, and must ensure that the class template specialization does not contain any padding bit. The implementation must also ensure that optimizations to array access account for the possibility that a pointer to may be aliasing a specialization or array thereof.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://cplusplus.com/reference/complex/complex",
        "document": "The type of both Cartesian components"
    },
    {
        "link": "https://support.sas.com/documentation/onlinedoc/sasc/doc/cplus/z0274855.htm",
        "document": "The functions and operators pertaining to complex numbers are implemented by means of and are contained in the C++ complex number mathematics library. The definition of overloads the standard input, output, arithmetic, comparison, and assignment operators of C++, as well as the standard names of the exponential, logarithm, power, square root, and trigonometric functions (sine, cosine, hyperbolic sine, and hyperbolic cosine). Functions for converting between Cartesian and polar coordinates are also provided. This section describes the functions, classes, and operators found in . Declarations for these functions and operators are contained in the header file . In the function descriptions, the form is used to represent a complex number. This is equivalent to the mathematical expression . \n\n\n\nThe function descriptions for the complex library are organized as follows:\n• a brief description of the purpose of the functions\n• details about diagnostics, if appropriate\n\nThe following functions are overloaded by the C++ complex library, where is of type and and are of the types indicated by the function prototypes in the SYNOPSIS. returns the square root of that is contained in the first or fourth quadrant of the complex plane. The and functions have special diagnostic considerations. If overflow is caused by the real part of being small or the imaginary part of being large, then returns and is set to If the real part of is large enough to cause overflow, returns different values under the following conditions pertaining to the sine and cosine of the imaginary part of . In Return Values for exp(a) , the real portion of a complex number depends on the and the imaginary part depends on the . HUGE corresponds to the largest representable . \n\n As you can see from this table, the translation is simple. If the cosine is positive, returns HUGE for the real portion of ; if the cosine is negative, returns -HUGE for the real part. If the cosine is not positive, returns -HUGE for the real part. The same rules hold true for the sine and the imaginary part of . In all overflow cases, is set to . When is returns and is set to .\n\n#include <complex.h> class complex { public: ostream& operator <<(ostream& os, complex c); istream& operator >>(istream& is, complex& c); }; The following functions provide insertion and extraction capabilities for complex numbers. writes a complex number to . The output is formatted in the following manner: where real-part and imag-part are the real and imaginary parts of the complex number, respectively. Both real-part and imag-part are formatted as doubles. For more information, refer to the descrip tion of the in class ostream . The formatting of real-part and imag-part is controlled by flags associated with the stream. See enum format_state . reads a formatted complex number from into . The should contain the complex number to be read in one of these formats: where real-part and imag-part are the real and imaginary parts of the complex number, respectively. Both real-part and imag-part should be formatted as s. For more information, refer to the description of the in class istream . The formatting of real-part and imag-part is controlled by flags associated with the stream. See enum format_state . Remember the following when performing complex I/O:\n• you must use the parentheses and comma for input\n• you can use white space in your input but it is not significant. If your input variable represents a real number such as 5e-2 or (502), the >> operator interprets it as a complex number with an imaginary part of 0. If the does not contain a properly formatted complex number, sets the bit in the stream's I/O state. Here is an example of using : complex c(3.4,2.1); cout << \"This is a complex: \" << c << endl; This code writes the following string to : Here is an example of using . Suppose contains . Then the following code reads the value and the value of becomes .\n\nCopyright © Tue Feb 10 12:11:23 EST 1998 by SAS Institute Inc., Cary, NC, USA. All rights reserved."
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/standard-library/complex?view=msvc-170",
        "document": "Defines the container class template and its supporting templates.\n\nA complex number is an ordered pair of real numbers. In purely geometrical terms, the complex plane is the real, two-dimensional plane. The special qualities of the complex plane that distinguish it from the real plane are due to its having an additional algebraic structure. This algebraic structure has two fundamental operations:\n• None Addition, defined as (a, b) + (c, d) = (a + c, b + d)\n\nThe set of complex numbers with the operations of complex addition and complex multiplication are a field in the standard algebraic sense:\n• None The operations of addition and multiplication are commutative and associative and multiplication distributes over addition exactly as it does with real addition and multiplication on the field of real numbers.\n• None The complex number (0, 0) is the additive identity and (1, 0) is the multiplicative identity.\n• None The additive inverse for a complex number (a, b) is (-a, -b), and the multiplicative inverse for all such complex numbers except (0, 0) is\n\nBy representing a complex number z = (a, b) in the form z = a + bi, where i2 = -1, the rules for the algebra of the set of real numbers can be applied to the set of complex numbers and to their components. For example:\n\nThe system of complex numbers is a field, but it's not an ordered field. There's no ordering of the complex numbers as there is for the field of real numbers and its subsets, so inequalities can't be applied to complex numbers as they are to real numbers.\n\nThere are three common forms of representing a complex number z:\n\nThe terms used in these standard representations of a complex number are referred to as follows:\n• None The modulus or absolute value of a complex number r.\n• None The argument or phase angle p in radians.\n\nUnless otherwise specified, functions that can return multiple values are required to return a principal value for their arguments greater than -π and less than or equal to +π to keep them single valued. All angles must be expressed in radians, where there are 2π radians (360 degrees) in a circle.\n\nThe <complex> header defines the following user-defined literals. The literals create a complex number with a real part of zero and an imaginary part that has the value of the input parameter.\n\nHeader files reference\n\n Thread safety in the C++ standard library"
    },
    {
        "link": "https://stdcxx.apache.org/doc/stdlibug/20-2.html",
        "document": "In the following sections we describe the operations used to create and manipulate complex numbers.\n\nThe template argument is used to define the types associated with the real and imaginary fields. This argument must be one of the floating point number datatypes available in the C++ language, either , , or .\n\nThere are several constructors associated with the class. A constructor with no arguments initializes both the real and imaginary fields to zero. A constructor with a single argument initializes the real field to the given value, and the imaginary value to zero. A constructor with two arguments initializes both real and imaginary fields. Finally, a copy constructor can be used to initialize a complex number with values derived from another complex number.\n\nA complex number can be assigned the value of another complex number. Since the one-argument constructor is also used for a conversion operator, a complex number can also be assigned the value of a real number. The real field is changed to the right-hand side, while the imaginary field is set to zero:\n\nThe function can be used to construct a complex number with the given magnitude and phase angle:\n\nThe conjugate of a complex number is formed using the function . If a complex number represents , then the conjugate is the value .\n\nThe member functions and return the real and imaginary fields of a complex number, respectively. These functions can also be invoked as ordinary functions with complex number arguments.\n\nThe arithmetic operators , , , and can be used to perform addition, subtraction, multiplication, and division of complex numbers. All four work either with two complex numbers, or with a complex number and a real value. Assignment operators are also defined for all four.\n\nThe unary operators and can also be applied to complex numbers.\n\nTwo complex numbers can be compared for equality or inequality, using and Two values are equal if their corresponding fields are equal. Complex numbers do not have a natural ordering, and thus cannot be compared using any other relational operator.\n\nComplex numbers can be written to an output stream, or read from an input stream, using the normal stream I/O conventions. A value is written in parentheses, either as or , depending upon whether or not the imaginary value is zero. A value is read as a set of parentheses surrounding two numeric values.\n\nThe function returns the norm of the complex number. This is the sum of the squares of the real and imaginary parts. The function returns the absolute value, which is the square root of the norm. Note that both are ordinary functions that take the complex value as an argument, not member functions.\n\nThe directed phase angle of a complex number is yielded by the function :\n\nThe trigonometric functions defined for floating point values have all been extended to complex number arguments. These functions are , , , , , and . Each takes a single complex number as argument and returns a complex number as result.\n\nThe transcendental functions , , , and have been extended to complex arguments. Each takes a single complex number as argument, and returns a complex number as result.\n\nThe C++ Standard Library defines several variations of the exponential function . Versions exist to raise a complex number to an integer power, to raise a complex number to a complex power or to a real power, or to raise a real value to a complex power."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/numeric/random",
        "document": "The random number library provides classes that generate random and pseudo-random numbers. These classes include:\n• Uniform random bit generators (URBGs), which include both random number engines, which are pseudo-random number generators that generate integer sequences with a uniform distribution, and true random number generators (if available).\n• Random number distributions (e.g. uniform, normal, or poisson distributions) which convert the output of URBGs into various statistical distributions.\n\nURBGs and distributions are designed to be used together to produce random values. All of the random number engines may be specifically seeded, serialized, and de-serialized for use with repeatable simulators.\n\nA uniform random bit generator is a function object returning unsigned integer values such that each value in the range of possible results has (ideally) equal probability of being returned.\n\nAll uniform random bit generators meet the UniformRandomBitGenerator requirements. C++20 also defines a concept.\n\nA random number engine (commonly shortened to engine ﻿) is a uniform random bit generator which generates pseudo-random numbers using seed data as entropy source.\n\nAt any given time, an engine e of type has a state e for some non-negative integer i. Upon construction, e has an initial state e , which is determined by engine parameters and an initial seed (or seed sequence).\n\nThe following properties are always defined for any engine type :\n• The size of ’s state in multiples of the size of (i.e. ).\n• The transition algorithm by which ’s state is advanced to its successor state (i.e. ).\n• The generation algorithm by which ’s state is mapped to a value of type , the result is a pseudo-random number.\n\nA pseudo-random number sequence can be generated by calling TA and GA alternatively.\n\nThe standard library provides the implementations of three different classes of pseudo-random number generation algorithms as class templates, so that the algorithms can be customized. The choice of which engine to use involves a number of trade-offs:\n• The linear congruential engine is moderately fast and has a very small storage requirement for state.\n• The Mersenne twister engine is slower and has greater state storage requirements but with the right parameters has the longest non-repeating sequence with the most desirable spectral characteristics (for a given definition of desirable).\n• The subtract with carry engine is very fast even on processors without advanced arithmetic instruction sets, at the expense of greater state storage and sometimes less desirable spectral characteristics.\n\nNone of these random number engines are cryptographically secure. As with any secure operation, a crypto library should be used for the purpose (e.g. OpenSSL ).\n\nAll types instantiated from these templates meet the RandomNumberEngine requirements.\n\nRandom number engine adaptors generate pseudo-random numbers using another random number engine as entropy source. They are generally used to alter the spectral characteristics of the underlying engine.\n\nstd::random_device is a non-deterministic uniform random bit generator, although implementations are allowed to implement std::random_device using a pseudo-random number engine if there is no support for non-deterministic random number generation.\n\nA random number distribution post-processes the output of a URBG in such a way that resulting output is distributed according to a defined statistical probability density function.\n\nIn addition to the engines and distributions described above, the functions and constants from the C random library are also available though not recommended:"
    },
    {
        "link": "https://stackoverflow.com/questions/38367976/do-stdrandom-device-and-stdmt19937-follow-an-uniform-distribution",
        "document": "I'm trying to convert this line of matlab in C++:\n\nSo follows an uniform distribution. My C++ code is based on:\n\nMy question is: the code above follows an uniform distribution? If not, how to do so?"
    },
    {
        "link": "https://en.cppreference.com/w/cpp/numeric/random/normal_distribution",
        "document": "Generates random numbers according to the Normal (or Gaussian) random number distribution. It is defined as:\n\nHere \\(\\small\\mu\\)μ is the Mean and \\(\\small\\sigma\\)σ is the Standard deviation (stddev).\n\nmain rd gen rd // Values near the mean are the most likely. Standard deviation // affects the dispersion of generated values from the mean. std d , // Draw a sample from the normal distribution and round it to an integer. random_int d, gen d gen , histogram n n n histogram random_int k, v histogram k v ,"
    },
    {
        "link": "https://stackoverflow.com/questions/33804736/c-fast-normal-random-number-generator",
        "document": "I'm using the generator to generate normal random numbers as shown below:\n\nThe above code works, however since I'm generating more than 100 million normal random numbers in my code, the above is very slow.\n\nIs there a faster way to generate normal random numbers?\n\nThe following is some background on how the code would be used:\n• Quality of the random numbers is not that important\n• Precision of the numbers is not that important, either or is OK\n• The normal distribution always has mean = 0 and sigma = 1\n\nAfter profiling the following function is taking up more than 50% of the time:"
    },
    {
        "link": "https://cplusplus.com/reference/random/mt19937",
        "document": ""
    }
]