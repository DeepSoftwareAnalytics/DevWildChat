[
    {
        "link": "https://en.cppreference.com/w/cpp/filesystem",
        "document": "The Filesystem library provides facilities for performing operations on file systems and their components, such as paths, regular files, and directories.\n\nThe filesystem library was originally developed as boost.filesystem, was published as the technical specification ISO/IEC TS 18822:2015, and finally merged to ISO C++ as of C++17. The boost implementation is currently available on more compilers and platforms than the C++17 library.\n\nThe filesystem library facilities may be unavailable if a hierarchical file system is not accessible to the implementation, or if it does not provide the necessary capabilities. Some features may not be available if they are not supported by the underlying file system (e.g. the FAT filesystem lacks symbolic links and forbids multiple hardlinks). In those cases, errors must be reported.\n\nThe behavior is undefined if the calls to functions in this library introduce a file system race, that is, when multiple threads, processes, or computers interleave access and modification to the same object in a file system.\n• file: a file system object that holds data, can be written to, read from, or both. Files have names, attributes, one of which is file type:\n• file name: a string of characters that names a file. Permissible characters, case sensitivity, maximum length, and the disallowed names are implementation-defined. Names (dot) and (dot-dot) have special meaning at library level.\n• path: sequence of elements that identifies a file. It begins with an optional (e.g. or on Windows), followed by an optional (e.g. on Unix), followed by a sequence of zero or more file names (all but last of which have to be directories or links to directories). The native format (e.g. which characters are used as separators) and character encoding of the string representation of a path (the pathname) is implementation-defined, this library provides portable representation of paths.\n\nUsing this library may require additional compiler/linker options. GNU implementation prior to 9.1 requires linking with and LLVM implementation prior to LLVM 9.0 requires linking with ."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/filesystem/create_directory",
        "document": "Creates the directory as if by POSIX (the parent directory must already exist). If the function fails because resolves to an existing directory, no error is reported. Otherwise on failure an error is reported. Creates the directoryas if by POSIX with a second argument of(the parent directory must already exist). If the function fails becauseresolves to an existing directory, no error is reported. Otherwise on failure an error is reported.\n\nSame as , except that the attributes of the new directory are copied from (which must be a directory that exists). It is OS-dependent which attributes are copied: on POSIX systems, the attributes are copied as if by On Windows OS, no attributes of are copied. Same as, except that the attributes of the new directory are copied from(which must be a directory that exists). It is OS-dependent which attributes are copied: on POSIX systems, the attributes are copied as if byOn Windows OS, no attributes ofare copied.\n\nExecutes for every element of that does not already exist. If already exists, the function does nothing (this condition is not treated as an error).\n\ntrue if a directory was newly created for the directory p resolves to, false otherwise.\n\nAny overload not marked may throw std::bad_alloc if memory allocation fails.\n\n\n\nThe attribute-preserving overload (3,4) is implicitly invoked by when recursively copying directories. Its equivalent in boost.filesystem is (with argument order reversed).\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://stackoverflow.com/questions/71658440/c17-create-directories-automatically-given-a-file-path",
        "document": "I need to output some log data to some files with variable names. However, does not create directories along the way, if the path to the file doesn't exist, writes to nowhere!\n\nWhat can I do to automatically create folders along a file path? The system is Ubuntu only."
    },
    {
        "link": "https://geeksforgeeks.org/file-system-library-in-cpp-17",
        "document": "In this article, we will learn about the File System library in C++17 and with examples. <filesystem> header was added in C++17 and introduces a set of classes, functions, and types that simplify file system operations. In simple words, we can say that the filesystem library provides tools that help us to simplify working with files and directories.\n\nIn earlier versions, performing file and directory operations was often a bulky and mistake-susceptible task as it required the use of platform-specific functions and libraries. The file system library was added to cope with these troubles, offering a portable and standardized way to paint with the file system.\n\nTo use the features of the file system library, we have to import <filesystem> header using #include preprocessor.\n\nAll the identifiers of <filesystem> headers are defined inside the std::filesystem namespace.\n\nThe following are some commonly used classes of file system libraries.\n\nIn this example, we will create a new file in a newly created directory. The parent directory looks like this before execution:\n\nIn this example, a directory is created named “mydirectory”. It checks if the directory exists and creates it if no longer. Sooner or later, a file named “my_file.Txt” is defined within this directory. The code then opens this file for writing using std::ofstream. If a success, it writes the text “Hello, FileSystem!” to the file and closes it. If any errors occur in the directory of the listing or file advent procedure, suitable error messages are displayed.\n\nIn this example, first, we define the directorypath to indicate the target directory. Then we wrote the condition to check if the directory exists or not using fs::exists() and fs::is_directory(). If it exists, it iterates through its contents using a range-based for loop with fs::directory_iterator(), and prints each item’s path to the standard output.\n\nIn this example, first, we define the path for the old file and the new file. Then, wrote a condition to check if the old file exists in the directory or not with fs::exists(), and if it is discovered, then rename it using fs::rename(). A success message will be displayed with the new file path. and if the old file isn’t found, it prints an error message.\n\nLet’s explore some of the key features provided by the <filesystem> library:\n• Path Manipulation: The file system library introduces the std::filesystem::path class to represent file system paths. This class encapsulates the platform-specific path representation and provides an easy way to manipulate and inspect paths.\n• File and Directory Operations: The file system library includes functions to perform common file and directory operations such as creating, removing, renaming, and checking for the existence of files and directories.\n• Error Handling: The <filesystem> library provides exceptions to handle errors during file system operations. You can catch exceptions like std::filesystem::filesystem_error to gracefully handle failures.\n• Portable Code: One of the main advantages of using <filesystem> is the portability it brings to your code. Since it abstracts platform-specific details, you can write code that works consistently across different operating systems."
    },
    {
        "link": "https://stackoverflow.com/questions/71893583/c-how-to-create-folder",
        "document": "Reach devs & technologists worldwide about your product, service or employer brand"
    },
    {
        "link": "https://stackoverflow.com/questions/7868936/read-file-line-by-line-using-ifstream-in-c",
        "document": "Reading a file line by line in C++ can be done in some different ways.\n\nThe simplest approach is to open an std::ifstream and loop using std::getline() calls. The code is clean and easy to understand.\n\nAnother possibility is to use the Boost library, but the code gets a bit more verbose. The performance is quite similar to the code above (Loop with std::getline()).\n\nIf performance is critical for your software, you may consider using the C language. This code can be 4-5 times faster than the C++ versions above, see benchmark below\n\nBenchmark -- Which one is faster?\n\nI have done some performance benchmarks with the code above and the results are interesting. I have tested the code with ASCII files that contain 100,000 lines, 1,000,000 lines and 10,000,000 lines of text. Each line of text contains 10 words in average. The program is compiled with optimization and its output is forwarded to in order to remove the logging time variable from the measurement. Last, but not least, each piece of code logs each line with the function for consistency.\n\nThe results show the time (in ms) that each piece of code took to read the files.\n\nThe performance difference between the two C++ approaches is minimal and shouldn't make any difference in practice. The performance of the C code is what makes the benchmark impressive and can be a game changer in terms of speed."
    },
    {
        "link": "https://stackoverflow.com/questions/13035674/how-to-read-a-file-line-by-line-or-a-whole-text-file-at-once",
        "document": "I'm in a tutorial which introduces files (how to read from file and write to file)\n\nFirst of all, this is not a homework, this is just general help I'm seeking.\n\nI know how to read one word at a time, but I don't know how to read one line at a time, or how to read the whole text file.\n\nWhat if my file contains 1000 words? It is not practical to read entire file word after word.\n\nMy text file named \"Read\" contains the following:\n\nThis is what I have accomplished so far:\n\nIs there any possible way to read the whole file at once, instead of reading each line or each word separately?"
    },
    {
        "link": "https://geeksforgeeks.org/read-file-using-ifstream-in-cpp",
        "document": "How to Read a File Using ifstream in C++?\n\nIn C++, we can read the contents of the file by using the ifstream object to that file. ifstream stands for input file stream which is a class that provides the facility to create an input from to some particular file. In this article, we will learn how to read a file line by line through the ifstream class in C++.\n\nRead File Using ifstream in C++\n\nTo read a file line by line using the ifstream class, we can use the std::getline() function. The getline() function can take input from any available stream so we can use the ifstream to the file with the getline() function.\n• None We will first create an ifstream object associated with the given file.\n• None We then use the getline() function and pass the previously created ifstream object to it along with the buffer.\n\nIn the following example, we will read a text file abc.txt line by line using the getline function of the input stream.\n\nC++ Program to Read File using ifstream in C++"
    },
    {
        "link": "https://gehrcke.de/2011/06/reading-files-in-c-using-ifstream-dealing-correctly-with-badbit-failbit-eofbit-and-perror",
        "document": "Motivated by this POV-Ray issue I tried to find a reliable way to read a file line by line in C++ using in combination with . While doing so, the goal was to handle all underlying stream errors as well as file opening errors, and to emit as precise error messages as possible. In a high-level programming language such as Python this level of reliability and usability is not difficult to obtain. However, in C++ this turned out to be a rather complex topic.\n\nProper handling of the stream error bits , , and requires a tremendous amount of care, as discussed for example here, here, and here, and finally at cplusplus.com. It is worth mentioning that although cplusplus.com is a convenient reference, it does not provide us with a rock-solid solution for the above-stated problem and also does not mention all the important details.\n\nWhen it comes to the idea of providing meaningful error messages, things become quite complicated. Proper evaluation of , respectively , in response to the stream error bits is not a trivial task as can be inferred from discussions like this and this. From these discussions we learn that most of the related uncertainty comes from a lack of centralized documentation or even missing documentation. The exact behavior of C++ code with respect to file handling and stream manipulation is defined by an intertwining of language specification (C++ in this case), operating system interface (e.g. POSIX) and low-level APIs (provided by e.g. libc) — they all are documented in different places and to a different extent. We for example expect that when returns , is set to something meaningful. But where is this actually documented?\n\nIn order to understand the relation between the language and operating system constructs involved, I performed quite some research and testing. Of course there are many obvious and non-obvious ways to write unreliable code. As expected, for writing reliable code, there also best practices or “recipes” to follow. To name, explain, and share those with the community is the goal of this article. We all know that re-using established recipes saves time and improves software quality in the long-term.\n\nUpdate (January 18th, 2015): In the mean time, this article has made it into the top Google search results for “c++ read file ifstream”. It is one of the most-visited articles on my website. Thanks for commenting and sharing!\n\nUpdate (July 7th, 2011): I revised the article after an important insight provided by Alexandre Duret-Lutz (confer comments).\n\nIf you just want to have a look at the results of this small investigation, I recommend scrolling down to the ideal solutions section. Otherwise, before continuing, you should make yourself briefly familiar with , , of the class.\n\nNote: all code shown in this post is contained in this HG repository, and can also be downloaded in a tarball.\n\nObey the two rules of ifstream iteration\n\nThis is the task: iteratively process the lines read from a file by means of an (why ?). Therefore, we first try to open a file by invoking . For attempting to get a line from the file, we use , where is a to store the data to. The goal is to process the data read from the file, line by line, via the fictitious call to . Of course, we want to call only if the preceding was able to extract meaningful data and store it in . When reaching the end of the file, it usually is the goal to treat the trailing data as a healthy line even if it is not terminated by a newline character (there is no standard saying whether a line is defined by special character separation or termination).\n\nAfter the investigation described below, I am pretty sure that the simplest rock-solid language construct for above-specified task is:\n\nThis is so simple and yet reliable, because it is the shortest approach following the two basic rules we must follow when applying an I/O operation on a stream, as is one:\n• Before processing data obtained from the stream, check for errors reported by (this holds true for any other IO operation on streams).\n• If (or any other IO operation on a stream) has set the stream’s or , do not process the data. is not required to be checked in the loop and does not necessarily have to prevent data processing.\n\nThe origin of these rules will become clearer while reading the rest of the article.\n\nOnly two rules, to follow — isn’t that easy? Anyway, this often is not done, as you can infer from the links in the introduction. In fact, not following these rules lead to the bug in POV-Ray linked to in the very first sentence of this article.\n\nHow does the simple code snippet above follow these rules? The loop, in fact, at first tries to obtain data from the stream via IO operation . It is totally okay to try this even on a bad/empty/non-existing file, because it just tries and afterwards sets the stream’s error bits correctly, as defined here. After , and are checked via the ifstream’s bool operator: actually returns the stream object which is evaluated in a bool expression in the loop header. Only if both bits are not set one can be sure that there is meaningful data in . In this case the loop body is evaluated. It processes the data obtained from the stream. Then, in the next loop iteration, the code attempts to read the next line, followed by error check, … and so on.\n\nThe point is: in each iteration, the chronological order of\n\nDo you wonder why we do not need to check the within the loop? This is answered further below.\n\nNow, how does the code snippet above behave if\n• the file path is invalid, e.g.\n• if the file does not exist or\n• if it is a directory or\n• if the executing process is not allowed to access the file?\n• or if the file is empty?\n\nThe answer for all of these scenarios: the code just does not enter the loop body. It does not attempt to process data. The code snippet above cannot be surprised. It deals with all types of errors transparently.\n\nTransparent error handling is good. Sometimes, however, meaningful error messages must be emitted. How to do that? According to my findings, the following snippet is the best that can be done:\n\nWhy? Discussed in the next part.\n\nLet me start with\n\nTwo important things to know:\n• Consider a call to detecting the end of file. It then sets . But: “Notice that some eofbit cases will also set failbit.” (reference). This will be very important and we will figure out in which cases exactly we have either only or both, and set.\n• evaluates the current setting of and prints a meaningful error message. is a global error variable which is set by low-level functions of your current operating system. An setting is sticky: it stays until the next error is happening, overwriting the state of the last error. Therefore, must only be called in a context that for sure has updated right before. Otherwise, the printed error message may not make any sense at all in the current context.\n\nAs you already can imagine, for providing meaningful error messages, it is required to understand when exactly the , and are set. Also, one has to know when exactly it is safe to call in the context of stream methods. Unfortunately, at this point we enter system-dependency and proper documentation is difficult to find or even missing. In order to understand the behavior of my system (a 2.6.27 Linux at the time of writing this article), I went down the empirical path and implemented test cases. All source files are provided in a tarball and it will be very easy for you to run these tests on your system.\n\nThe test suite can be summarized as follows:\n\n It starts off with and then checks the state of the stream via\n• an existing file with the last line not terminated by a newline character (could be considered being an invalid file format, since lines mostly are considered to be newline-terminated, not newline-separated).\n• a file with content that is opened by another process for reading\n• a file with content that is opened by another process for writing\n• a file that the test program has no access to\n\nBasically, the test evaluates the named quantities at all interesting points and especially after calls to .\n• The C++ source of a test program with debug output. It expects an input filename as first command line argument.\n• A bash script that is compiling the C++ source code of the test program and setting up the test files for the test. It runs the compiled test program against various input filenames.\n\nThis is the shell script ( ) (note that this has been written in a quick & dirty fashion):\n\nThis is the source of the C++ program :\n\nThe test results (important things to know: part 2):\n\nThere are many things to learn from this output. The following conclusions are only a subset. All this makes makes a lot of sense:\n• The constructor sets in case of a non-existing file.\n• does not catch the case when trying to open a directory.\n\nConclusion: right after right after construction is safe. According to the test, one single problem may be identified via this method: a non-existing file. Hence, the error message can be made precise.\n• In almost all test cases, the has been set at the same time as the (verifying “Notice that some eofbit cases will also set failbit.” as stated above). A closer look reveals that the is only set by if it did not manage to extract any data at all. Note that this is a regular scenario, when the last character in a file is a line delimiter. The on the other hand means that reached EOF while searching for the next line delimiter: If there is data between the last delimiter and EOF, extracts this data and sets .\n• The is only set in case of trying to get a line from a directory.\n• does only change in case of trying to get a line from a directory. In all other error cases it does not change .\n\nConclusion 1: When on stream has evaluated to , i.e. and are , do not blindly use to print an error message, because it is likely to be wrong in the current context. This is because the bool evaluation of the stream is sensitive to both, or ). Since may occur in common cases, it is not qualified for detecting an exceptional state (although its name suggests so). Only a set identifies an exception. Therefore, right after an I/O operation on a stream must be preceded by a positive evaluation.\n\nConclusion 2: In order to process residual data between the last line delimiter and EOF, a positive must not prevent data processing.\n\nWith the knowledge from above, ideal code solutions in form of ready-to-compile-examples can be proposed for two cases:\n• one, in which error messages are not important\n• one, in which we do the best we can to extract error messages\n\nIt was shown that with C++’s standard means it is difficult to catch specific errors. The following tries to provide as precise error messages as possible:\n\nOf course this can be run against the test shellscript from above:\n\nCongratulations, “no such file or directory”, “is a directory”, and “permission denied” are catched. Also, the data in the “invalid” line was read.\n\nThe following source of deals with all errors transparently and extracts residual data from an “invalid” last line:\n\nThe intention of this last piece of code shown is to transparently handle file opening and stream I/O errors. This succeeds: whenever there is data to extract, it is extracted. All error test cases result in no data being processed.\n\nRemember, all code shown here can be downloaded or cloned from Bitbucket.\n\nPlease let me know if I have to correct certain points or if we can do better than with the presented solutions (thanks again to Alexandre at this point)."
    },
    {
        "link": "https://reddit.com/r/cpp/comments/1g1qsqu/c_file_reading_guidance_on_the_options",
        "document": "I've been exploring file IO a bit more, particularly reading files into an application, and as with many things in C++ I'm finding that there are many ways to do the same thing. With this post I am not asking \"what is the best way to load a file in C++\". I'm willing to bet the answer to this question is \"it depends\" (although if I'm wrong I'd love to know). Instead I'm hoping to get some clarity on different methods and options so that I can make a well-informed decision on the best way to handling reading a file for a given circumstance. Specifically, I am interested in both what the recommendations are, and (if different) what the actual common way of doing things are, and why they might be different.\n\nMy first area of questions concerns the three common methods I see in examples for how to read a file. In this example I am simply trying to read the contents of a file into a string. I am making the assumption that the entire file can reasonably fit in a single buffer. I have broadly seen three ideas thrown around, which I will show in examples below. For the sake of readability, assume the following snippet proceeds each of the example snippets (I have omitted error checks for brevity).\n\nThis idea of fetching each line and appending it to some buffer is the most common one I see, but I'm not entirely sure why. I would have thought that I would be more efficient to load the entire file (or chunk of a file) in a single call (as in option 2). I can see this option being useful if you need to process each line before appending it to the string, but beyond that I don't see why this is so common. Also I'm not sure why but I almost never see anyone 'reserve' the memory before filling it with this method. I could be wrong but my understanding is that without reserving you would get multiple memory reallocations as the underlying array is resized to fit the new data. Is this correct?\n\nThis is what I thought would be the most recommended way of doing things, but I haven't seen it as much. If I understand things correctly I this should just copy the entire file contents into the string in one go, which I would imagine would be more efficient than multiple calls.\n\nEven simpler than the previous two, I see this one a bit more, i'm guessing because of the simplicity of it. Would this be as performant as the other two options though? I haven't really wrapped my head around how works under the hood, so I'm not sure what the efficiency of this would look like.\n\nOf these three methods, where would be the best scenarios to use each? Is there any meaningful performance difference between each? Are there philosophical reasons why an option would be preferred or avoided?\n\nThrough my readings I have seen conflicting claims about C++ IO-streams vs C File IO functions. The most common one is performance. One side claims that streams are significantly slower, and the other says that streams are just as fast if not faster than C File IO. (I have some a little evidence that supports the first position but not enough to be confident).\n\nMy questions about Streams vs C-Style File IO are:\n• Are C++ streams actually that much slower than C File IO?\n• If they are, are the features they have like RAII and exception support worth the speed decrease?\n• What is more common to see in real codebases?\n\nFor the first question, if anyone can provide benchmarks that would be amazing. I've found some but not many so it be great to see some more testing results.\n\nShould we be disabling sync_with_stdio?\n\nThis final question is pretty self explanatory. The reason I ask is because I've seen claims that setting sync_with_stdio significantly improves the performance, but I haven't found much evidence that proves this either way. I also don't see the suggestion very often so I'm wondering if there is a reason for that. Is disabling sync_with_stdio something that is generally recommended in practice? If not, why?"
    }
]