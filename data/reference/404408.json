[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch",
        "document": "The Fetch API provides a JavaScript interface for making HTTP requests and processing the responses. Fetch is the modern replacement for : unlike , which uses callbacks, Fetch is promise-based and is integrated with features of the modern web such as service workers and Cross-Origin Resource Sharing (CORS). With the Fetch API, you make a request by calling , which is available as a global function in both and contexts. You pass it a object or a string containing the URL to fetch, along with an optional argument to configure the request. The function returns a which is fulfilled with a object representing the server's response. You can then check the request status and extract the body of the response in various formats, including text and JSON, by calling the appropriate method on the response. Here's a minimal function that uses to retrieve some JSON data from a server: async function getData() { const url = \"https://example.org/products.json\"; try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const json = await response.json(); console.log(json); } catch (error) { console.error(error.message); } } We declare a string containing the URL and then call , passing the URL with no extra options. The function will reject the promise on some errors, but not if the server responds with an error status like : so we also check the response status and throw if it is not OK. Otherwise, we fetch the response body content as JSON by calling the method of , and log one of its values. Note that like itself, is asynchronous, as are all the other methods to access the response body content. In the rest of this page we'll look in more detail at the different stages of this process.\n\nThe request body is the payload of the request: it's the thing the client is sending to the server. You cannot include a body with requests, but it's useful for requests that send content to the server, such as or requests. For example, if you want to upload a file to the server, you might make a request and include the file as the request body. To set a request body, pass it as the option: You can supply the body as an instance of any of the following types: Other objects are converted to strings using their method. For example, you can use a object to encode form data (see setting headers for more information): const response = await fetch(\"https://example.org/post\", { method: \"POST\", headers: { \"Content-Type\": \"application/x-www-form-urlencoded\", }, // Automatically converted to \"username=example&password=password\" body: new URLSearchParams({ username: \"example\", password: \"password\" }), // ... }); Note that just like response bodies, request bodies are streams, and making the request reads the stream, so if a request contains a body, you can't make it twice: const request = new Request(\"https://example.org/post\", { method: \"POST\", body: JSON.stringify({ username: \"example\" }), }); const response1 = await fetch(request); console.log(response1.status); // Will throw: \"Body has already been consumed.\" const response2 = await fetch(request); console.log(response2.status); Instead, you would need to create a clone of the request before sending it: See Locked and disturbed streams for more information.\n\nCredentials are cookies, TLS client certificates, or authentication headers containing a username and password. To control whether or not the browser sends credentials, as well as whether the browser respects any response headers, set the option, which can take one of the following three values:\n• : never send credentials in the request or include credentials in the response.\n• (the default): only send and include credentials for same-origin requests. Note that if a cookie's attribute is set to or , then the cookie will not be sent cross-site, even if is set to . Including credentials in cross-origin requests can make a site vulnerable to CSRF attacks, so even if is set to , the server must also agree to their inclusion by including the header in its response. Additionally, in this situation the server must explicitly specify the client's origin in the response header (that is, is not allowed). This means that if is set to and the request is cross-origin, then:\n• If the request is a simple request, then the request will be sent with credentials, but the server must set the and response headers, or the browser will return a network error to the caller. If the server does set the correct headers, then the response, including credentials, will be delivered to the caller.\n• If the request is not a simple request, then the browser will send a preflighted request without credentials, and the server must set the and response headers, or the browser will return a network error to the caller. If the server does set the correct headers, then the browser will follow up with the real request, including credentials, and will deliver the real response, including credentials, to the caller.\n\nRequest and response bodies are actually objects, and whenever you read them, you're streaming the content. This is good for memory efficiency, because the browser doesn't have to buffer the entire response in memory before the caller retrieves it using a method like . This also means that the caller can process the content incrementally as it is received. For example, consider a request that fetches a large text file and processes it in some way, or displays it to the user: const url = \"https://www.example.org/a-large-file.txt\"; async function fetchText(url) { try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const text = await response.text(); console.log(text); } catch (e) { console.error(e); } } If we use , as above, we must wait until the whole file has been received before we can process any of it. If we stream the response instead, we can process chunks of the body as they are received from the network: const url = \"https://www.example.org/a-large-file.txt\"; async function fetchTextAsStream(url) { try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const stream = response.body.pipeThrough(new TextDecoderStream()); for await (const value of stream) { console.log(value); } } catch (e) { console.error(e); } } In this example, we iterate asynchronously over the stream, processing each chunk as it arrives. Note that when you access the body directly like this, you get the raw bytes of the response and must transform it yourself. In this case we call to pipe the response through a , which decodes the UTF-8-encoded body data as text."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/how-to-use-the-javascript-fetch-api-to-get-data",
        "document": "There was a time when was used to make API requests. It didn’t include Promises, and it didn’t make for clean JavaScript code. Using jQuery, you could use the cleaner syntax of .\n\nNow, JavaScript has its own built-in way to make API requests. This is the Fetch API, a new standard to make server requests with Promises, but which also includes additional features.\n\nIn this tutorial, you will create both GET and POST requests using the Fetch API.\n\nTo complete this tutorial, you will need the following:\n• A local development environment for Node.js. Follow How to Install Node.js and Create a Local Development Environment.\n• A basic understanding of coding in JavaScript, which you can learn more about from the How to Code in JavaScript series.\n• An understanding of Promises in JavaScript. Read the Promises section of this article on the event loop, callbacks, Promises, and async/await in JavaScript.\n\nOne approach to using the Fetch API is by passing the URL of the API as a parameter:\n\nThe method returns a Promise. After the method, include the Promise method :\n\nIf the Promise returned is , the function within the method is executed. That function contains the code for handling the data received from the API.\n\nAfter the method, include the method:\n\nThe API you call using may be down or other errors may occur. If this happens, the promise will be returned. The method is used to handle . The code within will be executed if an error occurs when calling the API of your choice.\n\nWith an understanding of the syntax for using the Fetch API, you can now move on to using on a real API.\n\nStep 2 — Using Fetch to get Data from an API\n\nThe following code samples will be based on the JSONPlaceholder API. Using the API, you will get ten users and display them on the page using JavaScript. This tutorial will retrieve data from the JSONPlaceholder API and display it in list items inside the author’s list.\n\nBegin by creating an HTML file and adding a heading and unordered list with the of :\n\nNow add tags to the bottom of your HTML file and use a DOM selector to grab the . Use with as the argument:\n\nRemember, is the for the previously created .\n\nNext, create a that is a :\n\nAll the appended list items will be added to . A is not part of the active document tree structure. This has the benefit of not causing performance-affecting redraws when the Document Object Model is changed.\n\nCreate a constant variable called which will hold the API URL that will return ten random users:\n\nNow using the Fetch API, call the JSONPlaceholder API using with as the argument:\n\nYou are calling the Fetch API and passing in the URL to the JSONPlaceholder API. Then a response is received. However, the response you get is not JSON, but an object with a series of methods that can be used depending on what you want to do with the information. To convert the object returned into JSON, use the method.\n\nAdd the method which will contain a function with a parameter called :\n\nThe parameter takes the value of the object returned from . Use the method to convert into JSON data:\n\nThe JSON data still needs to be processed. Add another statement with a function that has an argument called :\n\nWithin this function, create a variable called that is set equal to :\n\nFor each author in , you will want to create a list item that displays their name. The method is suited for this pattern:\n\nWithin your function, create a variable called that will be set equal to with (the HTML element) as the argument. Also, create an for and a for :\n\nThe element will contain the of the . The element will contain the email of the . The property and string interpolation will allow you to do this:\n\nNext, connect these DOM elements with :\n\nNote that each list item is being appended to the . Once the is complete, the is appended to the unordered list element.\n\nWith both functions completed, you can now add the function. This function will log the potential error to the console:\n\nThis is the full code of the request you created:\n\nYou just successfully performed a GET request using the JSONPlaceholder API and the Fetch API. In the next step, you will perform POST requests.\n\nFetch defaults to GET requests, but you can use all other types of requests, change the headers, and send data. Let’s create a POST request.\n\nFirst, include a constant variable that holds the link to the JSONPlaceholder API:\n\nNext, you need to set your object and pass it as the second argument of the fetch function. This will be an object called with the key and value (or your name):\n\nSince this is a POST request, you will need to state that explicitly. Create an object called :\n\nThis object needs to include three keys: , , and :\n\nThe key will have the value . will be set equal to the format of the object that was just created. will have the value of .\n\nThe interface is a property of the Fetch API, which allows you to perform actions on HTTP request and response headers. This article called How To Define Routes and HTTP Request Methods in Express can provide you with more information.\n\nWith this code in place, the POST request can be made using the Fetch API. You will include and as arguments for your POST request:\n\nThe function will include code that handles the response received from the JSONPlaceholder API:\n\nThis is the full code of the request you created:\n\nWith this approach, can be used as the sole argument for , replacing and .\n\nNow you know two methods for creating and executing POST requests with the Fetch API.\n\nThe Fetch API is a modern and flexible interface for making network requests in JavaScript. It is promise-based, making it easier to handle asynchronous operations efficiently. However, it is not the only option for making network requests in JavaScript.\n\nAxios is a popular library for making HTTP requests in JavaScript. It is promise-based and has a simple and clean API. It also provides the ability to intercept requests and responses, transform data, and cancel requests.\n\nMany JavaScript frameworks, such as React, Vue.js, and Angular, have their own built-in methods for making network requests. These methods are often based on the Fetch API or Axios, but they may have additional features or be more tightly integrated with the framework’s ecosystem.\n\nIf you’re working on a simple project and prefer a lightweight, native solution, use Fetch API. However, for projects requiring automatic JSON parsing, interceptors, and better error handling, Axios is the better choice.\n\nYou can check out How to Use Vue.js and Axios to Display Data from an API for an Axios-based approach.\n\nReact applications often use Fetch API inside useEffect() to fetch data when a component mounts:\n\nFor better performance in React, consider using JavaScript Performance API.\n\nIn Vue.js, Fetch API is commonly used inside the lifecycle hook:\n\nAlternatively, many Vue.js projects prefer using Axios for its simplicity, as shown in How to Use Vue.js and Axios to Display Data from an API.\n\nIn Angular, Fetch API can be used within services using , but if using native Fetch API, you can implement it inside a component:\n\nFor large applications, Angular’s built-in is recommended for better scalability.\n\n1. What does Fetch API do in JavaScript?\n\nThe Fetch API provides a modern and flexible interface for making network requests in JavaScript. It allows you to fetch resources like JSON data, HTML, images, and more from a server. Unlike older methods like XMLHttpRequest, Fetch API is promise-based, making it easier to handle asynchronous operations efficiently.\n\n2. What is an example of Fetch API?\n\nA simple example of using Fetch API to request JSON data from an API:\n\nThis fetches a sample post from a placeholder API and logs it to the console. You can also check out How to Use Vue.js and Axios to Display Data from an API for another way to retrieve and display API data.\n\n3. How to fetch JSON data from an API in JavaScript?\n\nThis converts the response to JSON using and then processes the data. If you’re working with performance optimizations, you may also find JavaScript Performance API useful.\n\n4. How to fetch data from an API with JavaScript?\n\no fetch data asynchronously, use inside an function with :\n\nThis ensures cleaner code and better error handling. For advanced API integrations, consider learning about GraphQL API as an alternative to REST APIs.\n\n5. What is the difference between REST API and Fetch API?\n\nIn simpler terms, Fetch API is a tool used to interact with a REST API or any other data source available over the web.\n\nWhile the Fetch API is not yet supported by all the browsers, it is a great alternative to .\n\nThis tutorial provides a step-by-step guide on using Fetch API in JavaScript. However, if you’re working on a larger project, you may want to explore Axios for better error handling or GraphQL for more efficient data fetching.\n• Learn how to optimize API performance with JavaScript Performance API.\n• Explore GraphQL for an alternative to REST APIs.\n• Read How to Use Vue.js and Axios to Display Data from an API for a comparison with Axios.\n\nBy integrating these concepts, you can efficiently fetch and manage data in any JavaScript project.\n\nIf you would like to learn how to call Web APIs using React, check out this article on this very topic."
    },
    {
        "link": "https://freecodecamp.org/news/how-to-fetch-data-from-an-api-using-the-fetch-api-in-javascript",
        "document": "Interacting with external APIs, or Application Programming Interfaces, has become an essential skill in web development.\n\nAPIs allow different software applications to communicate with each other, enabling developers to access and retrieve data from various sources.\n\nOne popular way to perform API requests in JavaScript is by using the Fetch API. In this article, we will explore what the Fetch API is, how it works, and I'll provide practical examples to guide you through fetching data from an API using this powerful tool.\n\nThe Fetch API is a modern JavaScript interface for making network requests, primarily designed to replace the older XMLHttpRequest. It provides a more straightforward and flexible way to handle HTTP requests, making it easier for developers to work with APIs and fetch data from servers.\n\nBefore delving into practical examples, let's take a look at the basic syntax of the Fetch API.\n\nThe function is at the core of this API, and it takes one mandatory argument – the URL of the resource you want to fetch. Optionally, you can include an object as the second argument, where you can specify various settings such as the HTTP method, headers, and more.\n\nIn this example, we're fetching data from . The method is used to handle the response, converting it to JSON using the method. The second block logs the retrieved data to the console, and the block handles errors if the request fails.\n\nHow to Make a GET Request\n\nThe most common type of request when working with APIs is the GET request. It's used to retrieve data from a server. Let's walk through an example of making a simple GET request using the Fetch API.\n\nSuppose we want to retrieve information about a user from a hypothetical API. Here's how you can do it:\n\nIn this example, we define the API endpoint for user data ( ). The fetch function is used to make the GET request, and we handle the response by checking if it's okay using the property. If the response is okay, we convert it to JSON and process the user data.\n\nWhile GET requests are used for retrieving data, POST requests are used to send data to a server. This is commonly used when submitting forms or sending data to create a new resource. Let's explore how to make a POST request using the Fetch API.\n\nSuppose we have a simple form with user details, and we want to send this data to a server to create a new user. Here's how you can make a POST request:\n\nIn this example, we specify the API endpoint for creating a new user ( ). We use the property in the fetch options to set it as a POST request. Additionally, we include the property to indicate that we are sending JSON data in the request body.\n\nOften, when working with APIs, you need to include query parameters in your requests to filter or modify the data you receive. Let's explore how to handle query parameters when making a GET request.\n\nSuppose we want to retrieve a list of users based on a specific criteria, such as users who have registered in the last 30 days. We can achieve this by including query parameters in the URL:\n\nIn this example, we define the API endpoint for fetching recent users ( ). We set up query parameters using an object ( ) and convert them to a string using . The resulting string is then appended to the API endpoint to form the full URL.\n\nMany APIs require authentication to access protected resources. The Fetch API provides a way to include authentication information in your requests using headers. Let's explore how to handle authentication when making a request.\n\nSuppose we have an API that requires an API key for authentication. Here's how you can include the API key in the request headers:\n\nIn this example, we fetch data from the first API endpoint ( ) and process it. Then, we use the returned promise to make another fetch request to the second API endpoint ( ) and process its data. This chaining pattern allows us to handle multiple asynchronous requests in a sequential manner.\n\nHandling errors is a crucial part of making robust applications. The Fetch API provides a convenient way to catch and handle errors that may occur during a network request.\n\nLet's modify our earlier examples to include more comprehensive error handling:\n\nIn this modified example, we include additional information about the HTTP status in the error message when the response is not okay. This can be helpful for debugging and providing more context about the nature of the error.\n\nIn this article, we've covered the basics of fetching data from an API using the Fetch API in JavaScript. We started by exploring the fundamental concepts of the Fetch API, such as its syntax and how to make GET and POST requests. We then delved into handling query parameters, authentication, and asynchronous code.\n\nWorking with APIs is a crucial skill for web developers, and the Fetch API provides a straightforward and powerful way to interact with external data sources. As you continue to explore web development, practicing and implementing these concepts in real-world projects will solidify your understanding of fetching data from APIs using JavaScript. Happy coding!"
    },
    {
        "link": "https://stackoverflow.com/questions/78350380/how-to-make-a-get-request-for-fetching-specific-data-inside-of-fetch-api",
        "document": "Looks like you are using wrong the template string. In your line\n\nshould be with the back ticks `` and the $ outside the curly brackets {}\n\nBack ticks tells Javascript that should be a variable to replace, also, the order of ${} is relevant.\n\nOn the other hand, the url is right? the \":?\" is needed?"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API",
        "document": "The Fetch API uses and objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.\n\nFor making a request and fetching a resource, use the method. It is a global method in both and contexts. This makes it available in pretty much any context you might want to fetch resources in.\n\nThe method takes one mandatory argument, the path to the resource you want to fetch. It returns a that resolves to the to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an options object as the second argument (see ).\n\nOnce a is retrieved, there are a number of methods available to define what the body content is and how it should be handled.\n\nYou can create a request and response directly using the and constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, from service workers).\n\nFind out more about using the Fetch API features in Using Fetch."
    },
    {
        "link": "https://komal-agrawal108.medium.com/accessible-dom-manipulation-with-javascript-ecb06415a1af",
        "document": "Want to create dynamic and interactive web experiences that everyone can enjoy? Understanding Accessible DOM Manipulation with JavaScript is crucial. By ensuring your code adheres to accessibility guidelines, you can reach a wider audience, improve user experience, and potentially avoid legal issues.\n\nHere are some key points to consider for ensuring accessibility when altering the DOM with JavaScript:\n• Maintain Semantic Structure: Don’t fundamentally change the HTML structure in a way that loses meaning for screen readers. For example, avoid replacing headings ( ) with paragraphs ( ) using JavaScript.\n• Use ARIA Attributes: ARIA (Accessible Rich Internet Applications) attributes provide additional information for assistive technologies like screen readers. When adding content dynamically, use ARIA attributes like , , and to convey changes in content or visibility.\n• Manage Focus: When showing new content (like modals or menus), use JavaScript to set focus on the appropriate element, ensuring users of screen readers can interact with it immediately.\n• Graceful Degradation: If JavaScript is disabled, users should still be able to access and understand the content. Ensure core functionality works without JavaScript and use progressive enhancement for features that rely on it.\n• Avoid Content Flickering: When manipulating the DOM, avoid sudden changes that might disorient users, especially those relying on screen readers. Use transitions or animations smoothly for content updates.\n\nRemember, you can also improve accessibility through JavaScript by:\n• Adding ARIA roles to generic elements to provide context for screen readers.\n• Offering alternative ways to interact with dynamically generated content, like keyboard navigation alongside mouse interactions.\n\nBy following these practices, you can ensure that your JavaScript code enhances the user experience for everyone, including those who rely on assistive technologies.\n\nFor further exploration, you can refer to resources like “Accessible JavaScript” on WebAIM for detailed information and techniques.\n\nHere are some examples that showcase how to use JavaScript for DOM manipulation while maintaining accessibility:\n\nImagine an accordion menu where clicking a heading reveals its content. Here’s how to manage accessibility:\n\nThis code toggles the attribute on the button and on the content div, informing screen readers about the visibility change.\n\nConsider a chat application where new messages appear dynamically. Here’s how to announce them:\n\nThis code creates a temporary announcement element with to inform screen reader users about the new message. The announcement is then removed after a short delay to avoid interrupting the reading flow.\n\nLet’s say you have a modal dialog opened with JavaScript. Here’s how to ensure keyboard accessibility:\n\nThis code sets focus on the modal element itself when it’s opened, allowing users to navigate the modal content using keyboard arrows and tab key.\n\nThese are just a few examples."
    },
    {
        "link": "https://nobledesktop.com/learn/javascript/mastering-javascript-dom-manipulation-getting-and-setting-properties",
        "document": "Today we're going to look at a classic coding algorithm called the Fisher-Yates Shuffle, which is used for randomizing the items of an array."
    },
    {
        "link": "https://stackoverflow.com/questions/24279827/dynamic-dom-manipulation-function-how-to-improve-it-should-i-be-using-it-wh",
        "document": "Okay, so I have a fairly thorough understanding of programming (Bachelors in CS), but Web Development is an absolute nightmare, and no one I've asked can give me any real information on what I should be doing here. Most of them go, \"oh, look at that. nifty.\" and that's the end of it.\n\nI've been doing a lot of pet projects with dynamic content, and to speed the process up, I wrote a function to create and insert elements into the DOM. It's fairly straightforward, and not exactly elegant, but gets the job done.\n\nAs the title says, I'm looking for ways to improve this, perhaps a better established practice, and then I have a question about implementing it.\n\nand then when I want to use it, I do either:\n\ndepending on if I need to reference it later or not.\n\nMy last question is: What happens to the returned element with thing2, since I'm not assigning it to a variable? I should obviously know this, but is it cluttering up global? Does it know I'm not using it, and just drop it? There's no prototyping or anything, and it's just returning an element that's already in the DOM. Where does it go and why does this work without an error? :/\n\nI'm sure I should read a book on advanced JavaScript mechanics, but I don't actually know what I'm asking, and five minutes Googling keywords like \"expression\" and \"declaration\" and \"returning to not a variable\" were about as helpful as you can imagine.\n\nAnd most posts I did find on the issue all recommended templating libraries, but I'd like to avoid them if I can.\n\nAny thoughts would be much appreciated!\n\nThanks for the help! -Tyler"
    },
    {
        "link": "https://nobledesktop.com/learn/javascript/building-dynamic-user-interfaces-with-javascript-and-html",
        "document": "Today we're going to look at a classic coding algorithm called the Fisher-Yates Shuffle, which is used for randomizing the items of an array."
    },
    {
        "link": "https://softwareengineering.stackexchange.com/questions/269935/what-is-the-best-way-to-create-dynamically-a-dom",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://stackoverflow.com/questions/34612162/localstorage-strategy-for-user-and-message-data",
        "document": "I am looking for a simple strategy to store user data, as well as messages. I was thinking of using different key values like some random token (Ynjk_nkjSNKJN) for users and some real ids (1,2,3) for messages.\n\nHas anyone ever had that problem?\n\nThe reason is that I would like to keep always up to date with new messages from the server, but users should not be deleted during an update."
    },
    {
        "link": "https://stackoverflow.com/questions/25259163/recommended-way-to-store-chat-history-for-a-webapp",
        "document": "Things are setup and running smoothly, however, I'm a little confused as to where to store chat history.\n\nFrom what I've observed, Desktop based clients typically store chat history on the client side filesystem using formats such as xml, txt etc.\n\nOn the server side, I have the following options:\n\nBut I would like to know which is the best of the above options (or any other ones if you can suggest) in terms of speed and performance."
    },
    {
        "link": "https://reddit.com/r/webdev/comments/1ao3357/storing_conversation_in_local_storage_vs_in",
        "document": "What are the downsides or upsides for storing messages in local storage? I'm building an app where users can chat with an AI, but the problem is I want to keep conversation history (similar to chatgpt) for an improved user experience. However security-wise and such it seems a major hassle to store messages in a database because I can see the messages and things like that (if this feels like a deja vu, it's because I posted that other thread). Local storage seems way easier to do and less risky. But I'm not familiar with it so maybe there are unforeseen downsides to local storage? Obv. I know they won't see the messages on different devices and such, but it's not immediately necessary, only a minor inconvenience I think. But I'm wondering about other aspects I might've missed regarding local storage."
    },
    {
        "link": "https://deadsimplechat.com/blog/javascript-localstorage-complete-guide",
        "document": "Dead Simple Chat offers prebuilt Chat that can be added in minutes to any app or website. Can be completely customized and offers powerful API and SDK.\n\nJavaScript is basically storage that is in the browsers Object. You can store anything in the and it will be persistent through page loads and even if the browser closes and reopens\n\nand its related are part of the Web Storage API. We will be learning more about these below\n\nWeb Storage API provides methods through which browsers can store key/value pairs of data (like Objects).\n\nThe key/value pairs stored in the web storage API are always in the form of strings. (integer keys are automatically converted to strings)\n\nThere are a set of methods provided by the Web Storage API that you can use to access, delete modify the key/Value pairs\n\nThere are two types of storage available in the Web Storage API\n\nis part of the Web Storage API. It allows you to store persistent data (data remains on browser reloads and when the browser is closed and reopened) in the browser Object as key/value pairs of strings.\n\nThere are five methods of localStorage and these are:\n\nBoth and are part of the web storage api.\n• The is only available till the browser is open, when the browser is closed the is deleted. (`sessionStorage` is available when the browser reloads but when the browser is closed sessionStorage is deleted)\n• The is the persistant data even when the browser is closed the data remains in the browser\n• can be deleted manually by the user and it is automatically deleted when the user is in incognito window or private window and the user closes the browser\n\nBoth and provides similar methods to access and store data in the browser\n\nWe will be learning more about the methods below\n\nThere are five methods in the . These methods let you store items, get Items, remove Items and clear the .\n\nUsing localStorage.setItem API you can store key/value pairs in the local storage. here is an example on how you can store the data.\n\nthe is the key and the is the value. As we have mentioned localStorage only stores strings.\n\nYou can try this in the browser itself. Here is an example to storing the data in the chrome browser\n\nThere are multiple ways of storing the data in the using . You can access data in the Object like way:\n\nIt is allowed but not recommended to store or access data in the object like way because the user generated key can by anything like or or any other built in method name of the localStorage\n\nIn which case the and would work fine but the Object like method would fail\n\nUsing the getItem API we can retrive the key/value pairs stored in the localStorage\n\ngetItem() accepts a key and returns the value as a string\n\nThis would return the value as\n\nUsing Object notation you can also access the data (although it is not recommended)\n\n3. removeItem() remove an item from the localStorage\n\nyou can remove any item from the using the method\n\nPass the key of the item that you need to remove to the method and it is deleted from the\n\nlet's use the console to see how the removeItem works. First we will use the length property to check how many items are in teh local storage\n\nAs you can see when we use the length property it shows there are 2 items in the . After we remove an item now there is only one item remaining in the local storage\n\nWith Clear() method of the localStorage api you can clear the entire localStorage and delete all the data in the localStorage\n\nlet us use the console to see how the clear method of the works\n\nWe will use the length to check for the number of items in the\n\nAs you can see there are 2 items stored in the and we used the clear method now there are 0 items stored in the\n\n5. key() returns the n th key in the storage\n\nthe key method can be passed any integer and it will return the key stored at the nth key in the storage Object\n\nlet us use the console to see how the key works.\n\nWe have put 2 key/value pairs in the localStorage like\n\nlet us use the to check for the contents of the localStorage\n\nas you know the index starts from 0. let us see what is at index 0\n\nand let us see what is at index 1\n\nlength : number of key/value pairs stored in the local\n\nThe length is a read-only property of the interface. It returns the number of key/value pairs stored in the\n\nWe can use length property to test whether the is populated or not.\n\nUptill now we have used the length property multiple times and you might have become familier with.\n\nLet us use the length property in different use cases to futher explore its uses. Let us open the console and see how we can use the length property\n\nnow the length property can also be used to check if the localStorage is empty. Let us clear the and see what happens if we use the length property\n\nIt returns 0. hence we know if the length property returns 0 then the localStorage is empty\n\nThe Storage event is fired whenever a change is made to the storage object.\n\nStorageEvent is sent to the window when a storage area the window has access to is changed within the context of another document\n\nStorage event are events that are fired whenever a change takes place and you can listen to the storage event and make appropriate decision in your website or application.\n\nlet us use the console to create a new instance of the storageEvent()\n\ncreating a new instance of the StorageEvent\n\nReturns a String that represents the key that has been changed. The key attribute is null when the change is caused by the clear() method\n\nReturns a String with the new value of the key that has been changed. It is null when clear() method has been used or the key has been removed\n\nReturns a String with the original value of the key. It is null when a new key has been added where there was no key before\n\nReturns a storage Object that represents the storage area that was affected.\n\nReturns a string with the url of the document who key is changed\n\nHere are some of the interesting facts about the localStorage\n• is always stored in UTF-16 string format. Integer keys are converted into string and stored in the localStorage\n• data is specific to the protocol of the browser and website. For example it is different in http and https\n• for documents loaded from the requirements for localstorage is undefined and is different for different browsers\n• for incognito or private browsers is deleted when the browser is closed\n\nHere are some of the limitations for\n• do not store sensitive data in as it can be easily accessed by cross site scripting\n• is syncronous meaning it is accessed one after the other and\n• do not use as a database\n\nLocalStorage is compatiable with all the latest browsers. Only the very very old browsers like Internet Explorer 6 or 7 do not support\n\nIn some situations like the user is in private window or the user is in incognito window the data would be immediately deleted when the user closes the window\n\nThe user can also disable\n\nA security error is thrown in the following cases:\n• Origin is not a valid scheme/host/port tuple error. This happens when the origin uses or schemes. Many modern browsers treat origin as opaque origin. What this means is that the file or files that come from the same folder are assumed to come from different sources and could trigger CORS error\n• The request violates a policy decision. For example the user has disabled the use of localStorage on the browser\n\nHere are some of the relevant articles\n• How to safely use dangerouslySetInnerHTML in React\n\nIn this article I have explained the and its methods and how you can use to save data and access it, deleted it and modify it"
    },
    {
        "link": "https://rxdb.info/articles/localstorage.html",
        "document": "When it comes to client-side storage in web applications, the localStorage API stands out as a simple and widely supported solution. It allows developers to store key-value pairs directly in a user's browser. In this article, we will explore the various aspects of the localStorage API, its advantages, limitations, and alternative storage options available for modern applications.\n\nThe localStorage API is a built-in feature of web browsers that enables web developers to store small amounts of data persistently on a user's device. It operates on a simple key-value basis, allowing developers to save strings, numbers, and other simple data types. This data remains available even after the user closes the browser or navigates away from the page. The API provides a convenient way to maintain state and store user preferences without relying on server-side storage.\n\nLet's dive into some hands-on code examples to better understand how to leverage the power of localStorage. The API offers several methods for interaction, including setItem, getItem, removeItem, and clear. Consider the following code snippet:\n\nWhile js localStorage excels at handling simple key-value pairs, it also supports more intricate data storage through JSON serialization. By utilizing JSON.stringify and JSON.parse, you can store and retrieve structured data like objects and arrays. Here's an example of storing a document:\n\nDespite its convenience, localStorage does come with a set of limitations that developers should be aware of:\n• Non-Async Blocking API: One significant drawback is that js localStorage operates as a non-async blocking API. This means that any operations performed on localStorage can potentially block the main thread, leading to slower application performance and a less responsive user experience.\n• Limited Data Structure: Unlike more advanced databases, localStorage is limited to a simple key-value store. This restriction makes it unsuitable for storing complex data structures or managing relationships between data elements.\n• Stringification Overhead: Storing JSON data in localStorage requires stringifying the data before storage and parsing it when retrieved. This process introduces performance overhead, potentially slowing down operations by up to 10 times.\n• Lack of Indexing: localStorage lacks indexing capabilities, making it challenging to perform efficient searches or iterate over data based on specific criteria. This limitation can hinder applications that rely on complex data retrieval.\n• Tab Blocking: In a multi-tab environment, one tab's localStorage operations can impact the performance of other tabs by monopolizing CPU resources. You can reproduce this behavior by opening this test file in two browser windows and trigger localstorage inserts in one of them. You will observe that the indication spinner will stuck in both windows.\n• Storage Limit: Browsers typically impose a storage limit of around 5 MiB for each origin's localStorage.\n\nContrary to concerns about performance, the localStorage API in JavaScript is surprisingly fast when compared to alternative storage solutions like IndexedDB or OPFS. It excels in handling small key-value assignments efficiently. Due to its simplicity and direct integration with browsers, accessing and modifying localStorage data incur minimal overhead. For scenarios where quick and straightforward data storage is required, localStorage remains a viable option. For example RxDB uses localStorage in the localStorage meta optimizer to manage simple key values pairs while storing the \"normal\" documents inside of another storage like IndexedDB.\n\nWhile localStorage offers convenience, it may not be suitable for every use case. Consider the following situations where alternatives might be more appropriate:\n• Data Must Be Queryable: If your application relies heavily on querying data based on specific criteria, localStorage might not provide the necessary querying capabilities. Complex data retrieval might lead to inefficient code and slow performance.\n• Big JSON Documents: Storing large JSON documents in localStorage can consume a significant amount of memory and degrade performance. It's essential to assess the size of the data you intend to store and consider more robust solutions for handling substantial datasets.\n• Many Read/Write Operations: Excessive read and write operations on localStorage can lead to performance bottlenecks. Other storage solutions might offer better performance and scalability for applications that require frequent data manipulation.\n• Lack of Persistence: If your application can function without persistent data across sessions, consider using in-memory data structures like or . These options offer speed and efficiency for transient data.\n\nWhile localStorage serves as a reliable storage solution for simpler data needs, it's essential to explore alternatives like IndexedDB when dealing with more complex requirements. IndexedDB is designed to store not only key-value pairs but also JSON documents. Unlike localStorage, which usually has a storage limit of around 5-10MB per domain, IndexedDB can handle significantly larger datasets. IndexDB with its support for indexing facilitates efficient querying, making range queries possible. However, it's worth noting that IndexedDB lacks observability, which is a feature unique to localStorage through the event. Also, complex queries can pose a challenge with IndexedDB, and while its performance is acceptable, IndexedDB can be too slow for some use cases.\n\nFor those looking to harness the full power of IndexedDB with added capabilities, using wrapper libraries like RxDB is recommended. These libraries augment IndexedDB with features such as complex queries and observability, enhancing its usability for modern applications by providing a real database instead of only a key-value store.\n\nIn summary when you compare IndexedDB vs localStorage, IndexedDB will win at any case where much data is handled while localStorage has better performance on small key-value datasets.\n\nAnother intriguing option is the OPFS (File System API). This API provides direct access to an origin-based, sandboxed filesystem which is highly optimized for performance and offers in-place write access to its content. OPFS offers impressive performance benefits. However, working with the OPFS API can be complex, and it's only accessible within a WebWorker. To simplify its usage and extend its capabilities, consider using a wrapper library like RxDB's OPFS RxStorage, which builds a comprehensive database on top of the OPFS API. This abstraction allows you to harness the power of the OPFS API without the intricacies of direct usage.\n\nCookies, once a primary method of client-side data storage, have fallen out of favor in modern web development due to their limitations. While they can store data, they are about 100 times slower when compared to the localStorage API. Additionally, cookies are included in the HTTP header, which can impact network performance. As a result, cookies are not recommended for data storage purposes in contemporary web applications.\n\nWebSQL, despite offering a SQL-based interface for client-side data storage, is a deprecated technology and should be avoided. Its API has been phased out of modern browsers, and it lacks the robustness of alternatives like IndexedDB. Moreover, WebSQL tends to be around 10 times slower than IndexedDB, making it a suboptimal choice for applications that demand efficient data manipulation and retrieval.\n\nIn scenarios where data persistence beyond a session is unnecessary, developers often turn to sessionStorage. This storage mechanism retains data only for the duration of a tab or browser session. It survives page reloads and restores, providing a handy solution for temporary data needs. However, it's important to note that sessionStorage is limited in scope and may not suit all use cases.\n\nFor React Native developers, the AsyncStorage API is the go-to solution, mirroring the behavior of localStorage but with asynchronous support. Since not all JavaScript runtimes support localStorage, AsyncStorage offers a seamless alternative for data persistence in React Native applications.\n\nBecause native localStorage is absent in the Node.js JavaScript runtime, you will get the error in Node.js or node based runtimes like Next.js. The node-localstorage npm package bridges the gap. This package replicates the browser's localStorage API within the Node.js environment, ensuring consistent and compatible data storage capabilities.\n\nWhile browser extensions for chrome and firefox support the localStorage API, it is not recommended to use it in that context to store extension-related data. The browser will clear the data in many scenarios like when the users clear their browsing history.\n\nInstead the Extension Storage API should be used for browser extensions. In contrast to localStorage, the storage API works and all operations return a Promise. Also it provides automatic sync to replicate data between all instances of that browser that the user is logged into. The storage API is even able to storage JSON-ifiable objects instead of plain strings.\n\nThe Deno JavaScript runtime has a working localStorage API so running and the other methods, will just work and the locally stored data is persisted across multiple runs.\n\nBun does not support the localStorage JavaScript API. Trying to use will error with . To store data locally in Bun, you could use the module instead or directly use a in-JavaScript database with Bun support like RxDB.\n\nIn the world of modern web development, localStorage serves as a valuable tool for lightweight data storage. Its simplicity and speed make it an excellent choice for small key-value assignments. However, as application complexity grows, developers must assess their storage needs carefully. For scenarios that demand advanced querying, complex data structures, or high-volume operations, alternatives like IndexedDB, wrapper libraries with additional features like RxDB, or platform-specific APIs offer more robust solutions. By understanding the strengths and limitations of various storage options, developers can make informed decisions that pave the way for efficient and scalable applications.\n• Learn how to store and query data with RxDB in the RxDB Quickstart\n• Why IndexedDB is slow and how to fix it"
    }
]