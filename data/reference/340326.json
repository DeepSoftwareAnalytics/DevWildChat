[
    {
        "link": "https://geeksforgeeks.org/thread-functions-in-c-c",
        "document": "In a Unix/Linux operating system, the C/C++ languages provide the POSIX thread(pthread) standard API(Application program Interface) for all thread related functions. It allows us to create multiple threads for concurrent process flow. It is most effective on multiprocessor or multi-core systems where threads can be implemented on a kernel-level for achieving the speed of execution. Gains can also be found in uni-processor systems by exploiting the latency in IO or other system functions that may halt a process.\n\nWe must include the pthread.h header file at the beginning of the script to use all the functions of the pthreads library. To execute the c file, we have to use the -pthread or -lpthread in the command line while compiling the file.\n\nThe functions defined in the pthreads library include:\n• pthread_create: used to create a new thread\n• thread: pointer to an unsigned integer value that returns the thread id of the thread created.\n• attr: pointer to a structure that is used to define thread attributes like detached state, scheduling policy, stack address, etc. Set to NULL for default thread attributes.\n• start_routine: pointer to a subroutine that is executed by the thread. The return type and parameter type of the subroutine must be of type void *. The function has a single attribute but if multiple values need to be passed to the function, a struct must be used.\n• arg: pointer to void that contains the arguments to the function defined in the earlier argument\n• pthread_exit: used to terminate a thread Parameters: This method accepts a mandatory parameter retval which is the pointer to an integer that stores the return status of the thread terminated. The scope of this variable must be global so that any thread waiting to join this thread may read the return status.\n• pthread_join: used to wait for the termination of a thread.\n• th: thread id of the thread for which the current thread waits.\n• thread_return: pointer to the location where the exit status of the thread mentioned in th is stored.\n• pthread_self: used to get the thread id of the current thread.\n• pthread_equal: compares whether two threads are the same or not. If the two threads are equal, the function returns a non-zero value otherwise zero.\n• t1: the thread id of the first thread\n• t2: the thread id of the second thread\n• pthread_cancel: used to send a cancellation request to a thread Parameter: This method accepts a mandatory parameter thread which is the thread id of the thread to which cancel request is sent.\n• pthread_detach: used to detach a thread. A detached thread does not require a thread to join on terminating. The resources of the thread are automatically released after terminating if the thread is detached. Parameter: This method accepts a mandatory parameter thread which is the thread id of the thread that must be detached.\n\nExample: A simple implementation of threads may be as follows:\n\nExplanation: Here two threads of execution are created in the code. The order of the lines of output of the two threads may be interchanged depending upon the thread processed earlier. The main thread waits on the newly created thread for exiting. Therefore, the final line of the output is printed only after the new thread exits. The threads can terminate independently of each other by not using the pthread_join function. If we want to terminate the new thread manually, we may use pthread_cancel to do it.\n\nNote: If we use exit() instead of pthread_exit() to end a thread, the whole process with all associated threads will be terminated even if some of the threads may still be running."
    },
    {
        "link": "https://stackoverflow.com/questions/6990888/c-how-to-create-thread-using-pthread-create-function",
        "document": "parameter is a function pointer. The function should take one argument which is indicated as type and return value .\n\nis expected to be a pointer to the data that will receive.\n\nAs an example, lets say you want to pass two int to the worker. Then, you can create something like this:\n\nThen your work function can convert the pointer type and grab the param data:\n\nYou can do more complex stuff, like creating a struct with all of the data you need to pass."
    },
    {
        "link": "https://stackoverflow.com/questions/64521749/several-ways-to-use-pthread-create-with-a-member-function-of-a-c-class-error",
        "document": "I am testing different ways of executing as a thread a function defined in a C ++ class using pthread_create.\n\nThe program that I attach as an example compile and works correctly in these cases:\n• If the function is static: ThRoutine1\n• If the function is friend: ThRoutine2\n• If the function is neither static nor friend and has no parameters, an intermediate function can be used: runThRoutine3 and ThRoutine3\n\nI compile the program with the command:\n\nHowever, I can not create a thread with the ThRoutine4 function that is neither static nor friend and has an input parameter.\n\nAfter reading several posts on various forums, I have tried to define the s_param structure and the unThRoutine4 function, but when compiling the program I get these errors (it is necessary to uncomment the lines that appear commented):\n\nI appreciate any help in this regard.\n\nThe source code of example_program.cpp is:"
    },
    {
        "link": "https://docs.oracle.com/cd/E26502_01/html/E35303/tlib-1.html",
        "document": "The Pthreads API library consists of more than 100 functions. See the (5) man page for a full list of the functions, grouped by their usage categories.\n\nThis section contains brief descriptions of the functions used for basic threads programming, organized according to the task they perform, and includes links to the man pages of the associated API functions. The following list directs you to the discussion of a particular task.\n• Getting the Thread Policy and Scheduling Parameters\n• Accessing the Signal Mask of the Calling Thread\n\nWhen an attribute object is not specified, the object is , and the default thread is created with the following attributes:\n\nYou can also create a default attribute object with , and then use this attribute object to create a default thread. See the section Initializing Attributes for details.\n\nUse (3C) to add a new thread of control to the current process.\n\nThe function is called with that has the necessary state behavior. is the function with which the new thread begins execution. When returns, the thread exits with the exit status set to the value returned by . See Syntax.\n\nWhen is successful, the ID of the created thread is stored in the location referred to as .\n\nWhen you call with either a attribute argument or a default attribute, creates a default thread. When is initialized, the thread acquires the default behavior.\n\nreturns zero when the call completes successfully. Any other return value indicates that an error occurred. When any of the following conditions are detected, fails and returns the corresponding value.\n\nDescription: A system limit is exceeded, such as when too many threads have been created.\n\nDescription: The value of is invalid.\n\nDescription: The caller does not have appropriate permission to set the required scheduling parameters or scheduling policy.\n\nThe function blocks the calling thread until the specified thread terminates.\n\nUse (3C) to wait for a thread to terminate.\n\nThe specified thread must be in the current process and must not be detached. For information on thread detachment, see Setting Detach State.\n\nWhen status is not , status points to a location that is set to the exit status of the terminated thread when returns successfully.\n\nIf multiple threads wait for the same thread to terminate, all the threads wait until the target thread terminates. Then one waiting thread returns successfully. The other waiting threads fail with an error of .\n\nAfter returns, any data storage associated with the terminated thread can be reclaimed by the application.\n\nreturns zero when the call completes successfully. Any other return value indicates that an error occurred. When any of the following conditions are detected, fails and returns the corresponding value.\n\nDescription: No thread could be found corresponding to the given thread ID.\n\nDescription: A deadlock would exist, such as a thread waits for itself or thread A waits for thread B and thread B waits for thread A.\n\nDescription: The thread corresponding to the given thread ID is a detached thread.\n\nworks only for target threads that are nondetached. When no reason exists to synchronize with the termination of a particular thread, then that thread should be detached.\n\nIn Example 2-1, one thread executes the procedure at the top, creating a helper thread that executes the procedure . The procedure executes a complicated database lookup and might take some time.\n\nThe main thread awaits the results of the lookup but has other work to do in the meantime. So, the main thread perform those other activities and then waits for its helper to complete its job by executing .\n\nAn argument, , to the new thread is passed as a stack parameter. The thread argument can be passed as a stack parameter because the main thread waits for the spun-off thread to terminate. However, the preferred method is to use to allocate storage from the heap instead of passing an address to thread stack storage. If the argument is passed as an address to thread stack storage, this address might be invalid or be reassigned if the thread terminates.\n\n(3C) is an alternative to (3C) to reclaim storage for a thread that is created with a attribute set to .\n\nThe function is used to indicate to your application that storage for the thread tid can be reclaimed when the thread terminates. Threads should be detached when they are no longer needed. If tid has not terminated, does not cause the thread to terminate.\n\nreturns zero when the call completes successfully. Any other return value indicates that an error occurred. When any of the following conditions is detected, fails and returns the corresponding value.\n\nDescription: is not a valid, undetached thread in the current process.\n\nSingle-threaded C programs have two basic classes of data: local data and global data. For multithreaded C programs a third class, thread-specific data, is added. Thread-specific data is very much like global data, except that the data is private to a thread.\n\nThread-specific data (TSD) is maintained on a per-thread basis. TSD is the only way to define and refer to data that is private to a thread. Each thread-specific data item is associated with a that is global to all threads in the process. By using the , a thread can access a pointer ( *) maintained per-thread.\n\nUse (3C) to allocate a that is used to identify thread-specific data in a process. The key is global to all threads in the process. When the thread-specific data is created, all threads initially have the value associated with the key.\n\nCall once for each key before using the key. No implicit synchronization exists for the keys shared by all threads in a process.\n\nOnce a key has been created, each thread can bind a value to the key. The values are specific to the threads and are maintained for each thread independently. The per-thread binding is deallocated when a thread terminates if the key was created with a function.\n\nWhen returns successfully, the allocated key is stored in the location pointed to by . The caller must ensure that the storage and access to this key are properly synchronized.\n\nAn optional destructor function, , can be used to free stale storage. If a key has a non- function and the thread has a non- value associated with that key, the function is called with the current associated value when the thread exits. The order in which the functions are called is unspecified.\n\nreturns zero after completing successfully. Any other return value indicates that an error occurred. When any of the following conditions occur, fails and returns the corresponding value.\n\nDescription: The name space is exhausted.\n\nDescription: Insufficient virtual memory is available in this process to create a new key.\n\nUse (3C) to destroy an existing thread-specific data key. Any memory associated with the key can be freed because the key has been invalidated. Reference to an invalid key returns an error.\n\nIf a has been deleted, any reference to the key with the or call yields undefined results.\n\nThe programmer must free any thread-specific resources before calling the function. This function does not invoke any of the destructors. Repeated calls to and can cause a problem.\n\nThe problem occurs because, in the Oracle Solaris implementation, a value is never reused after marks it as invalid. Every allocates a new key value and allocates more internal memory to hold the key information. An infinite loop of ... will eventually exhaust all memory. If possible, call only once for each desired key and never call .\n\nreturns zero after completing successfully. Any other return value indicates that an error occurred. When the following condition occurs, fails and returns the corresponding value.\n\nDescription: The value is invalid.\n\nUse (3C) to set the thread-specific binding to the specified thread-specific data key.\n\nreturns zero after completing successfully. Any other return value indicates that an error occurred. When any of the following conditions occur, fails and returns the corresponding value.\n\nUse (3C) to get the calling thread's binding for key, and store the binding in the location pointed to by value.\n\nExample 2-2 shows an excerpt from a multithreaded program. This code is executed by any number of threads, but the code has references to two global variables, and . These global values really should be references to items private to each thread.\n\nReferences to should get the system error code from the routine called by this thread, not by some other thread. Including the header file causes a reference to to be a reference to a thread-private instance of , so that references to by one thread refer to a different storage location than references to by other threads.\n\nThe variable refers to a stream that is connected to a window that is private to the referring thread. So, as with , references to by one thread should refer to a different storage location than references to by other threads. Ultimately, the reference is to a different window. The only difference here is that the system takes care of , but the programmer must handle references for .\n\nThe next example shows how the references to work. The preprocessor converts references to into invocations of the procedure.\n\nThis routine in turn invokes . receives the global variable and an output parameter that receives the identity of this thread's window.\n\nThe variable identifies a class of variables for which each thread has its own private copy. These variables are thread-specific data. Each thread calls to initialize its window and to arrange for its instance of to refer to the thread-specific data.\n\nOnce this routine is called, the thread can safely refer to and, after , the thread gets the reference to its private window. References to behave as if direct references were made to data private to the thread.\n\nExample 2-4 shows how to set up the reference.\n\nFirst, get a unique value for the key, . This key is used to identify the thread-specific class of data. The first thread to call eventually calls , which assigns to its first argument a unique . The second argument is a function that is used to deallocate a thread's instance of this thread-specific data item once the thread terminates.\n\nThe next step is to allocate the storage for the caller's instance of this thread-specific data item. Having allocated the storage, calling sets up a window for the thread. points to the storage allocated for the window. Finally, a call is made to , which associates with the key.\n\nSubsequently, whenever the thread calls to pass the global , the thread gets the value that is associated with this key by this thread in an earlier call to .\n\nWhen a thread terminates, calls are made to the functions that were set up in . Each function is called only if the terminating thread established a value for the by calling .\n\nUse (3C) to get the thread identifier of the calling thread.\n\nreturns the thread identifier of the calling thread.\n\nUse (3C) to compare the thread identification numbers of two threads.\n\nreturns a nonzero value when and are equal, otherwise, is returned. When either or is an invalid thread identification number, the result is unpredictable.\n\nUse (3C) in a threaded process to call an initialization routine the first time is called. Subsequent calls to from any thread in the process have no effect.\n\nThe parameter determines whether the associated initialization routine has been called.\n\nreturns zero after completing successfully. Any other return value indicates that an error occurred. When the following condition occurs, fails and returns the corresponding value.\n\nUse to cause the current thread to yield its execution in favor of another thread with the same or greater priority. If no such threads are ready to run, the calling thread continues to run. The function is not part of the Pthread API, but is a function in the Realtime Library Functions. You must include to use .\n\nreturns zero after completing successfully. Otherwise, -1 is returned and is set to indicate the error condition.\n\nUse (3C) to modify the scheduling policy and scheduling parameters of an individual thread.\n\nreturns zero after completing successfully. Any other return value indicates that an error occurred. When either of the following conditions occurs, the function fails and returns the corresponding value.\n\nDescription: The value of the attribute being set is not valid.\n\nDescription: The caller does not have the appropriate permission to set either the scheduling parameters or the scheduling policy of the specified thread.\n\nDescription: The value specified by does not refer to an existing thread.\n\nGetting the Thread Policy and Scheduling Parameters\n\n(3C) gets the scheduling policy and scheduling parameters of an individual thread.\n\nreturns zero after completing successfully. Any other return value indicates that an error occurred. When the following condition occurs, the function fails and returns the corresponding value.\n\nDescription: The value specified by does not refer to an existing thread.\n\n(3C) sets the scheduling priority for the specified thread.\n\nreturns zero after completing successfully. Any other return value indicates that an error occurred. When the following condition occurs, the function fails and returns the corresponding value.\n\nDescription: The value of is invalid for the scheduling policy of the specified thread.\n\nDescription: An attempt was made to set the priority to an unsupported value.\n\nDescription: The caller does not have the appropriate permission to set the scheduling priority of the specified thread.\n\nDescription: The value specified by does not refer to an existing thread.\n\nUse (3C) to send a signal to a thread.\n\nsends the signal sig to the thread specified by tid. tid must be a thread within the same process as the calling thread. Thesig argument must be from the list that is given in (3HEAD).\n\nWhen sig is zero, error checking is performed but no signal is actually sent. This error checking can be used to check the validity of tid.\n\nreturns zero after completing successfully. Any other return value indicates that an error occurred. When either of the following conditions occurs, fails and returns the corresponding value.\n\nDescription: cannot be found in the current process.\n\nAccessing the Signal Mask of the Calling Thread\n\nUse (3C) to change or examine the signal mask of the calling thread.\n\ndetermines how the signal set is changed. can have one of the following values:\n• . Add to the current signal mask, where indicates the set of signals to block.\n• . Delete from the current signal mask, where indicates the set of signals to unblock.\n• . Replace the current signal mask with , where indicates the new signal mask.\n\nWhen the value of is , the value of is not significant. The signal mask of the thread is unchanged. To inquire about currently blocked signals, assign a value to the argument.\n\nThe variable points to the space where the previous signal mask is stored, unless is .\n\nreturns zero when the call completes successfully. Any other return value indicates that an error occurred. When the following condition occurs, fails and returns the corresponding value.\n\nDescription: The value of is not defined and is .\n\nSee the discussion about (3C) in Solution: pthread_atfork.\n\nreturns zero when the call completes successfully. Any other return value indicates that an error occurred. When the following condition occurs, fails and returns the corresponding value.\n\nThe function terminates the calling thread. All thread-specific data bindings are released. If the calling thread is not detached, then the thread's ID and the exit status specified by status are retained until your application calls to wait for the thread. Otherwise, status is ignored. The thread's ID can be reclaimed immediately. For information on thread detachment, see Setting Detach State.\n\nThe calling thread terminates with its exit status set to the contents of .\n\nA thread can terminate its execution in the following ways:\n• By returning from its first (outermost) procedure, the threads start routine. See .\n• By termination with POSIX cancel functions. See .\n\nThe default behavior of a thread is to linger until some other thread has acknowledged its demise by “joining” with the lingering thread. This behavior is the same as the default attribute that is nondetached, see . The result of the join is that the joining thread picks up the exit status of the terminated thread and the terminated thread vanishes.\n\nAn important special case arises when the initial thread, calling , returns from calling or calls . This action causes the entire process to be terminated, along with all its threads. So, take care to ensure that the initial thread does not return from prematurely.\n\nNote that when the main thread merely calls , the main thread terminates itself only. The other threads in the process, as well as the process, continue to exist. The process terminates when all threads terminate.\n\nCancellation allows a thread to request the termination of any other thread in the process. Cancellation is an option when all further operations of a related set of threads are undesirable or unnecessary.\n\nOne example of thread cancellation is an asynchronously generated cancel condition, such as, when a user requesting to close or exit a running application. Another example is the completion of a task undertaken by a number of threads. One of the threads might ultimately complete the task while the others continue to operate. Since the running threads serve no purpose at that point, these threads should be cancelled.\n\nBe careful to cancel a thread only when cancellation is safe. The pthreads standard specifies several cancellation points, including:\n• Threads waiting for the occurrence of a particular condition in or .\n• Some standard library calls. In general, these calls include functions in which threads can block. See the (5) man page for a list.\n\nCancellation is enabled by default. At times, you might want an application to disable cancellation. Disabled cancellation has the result of deferring all cancellation requests until cancellation requests are enabled again.\n\nSee Syntax for information about disabling cancellation.\n\nDangers exist in performing cancellations. Most deal with properly restoring invariants and freeing shared resources. A thread that is cancelled without care might leave a mutex in a locked state, leading to a deadlock. Or a cancelled thread might leave a region of allocated memory with no way to identify the memory and therefore unable to free the memory.\n\nThe standard C library specifies a cancellation interface that permits or forbids cancellation programmatically. The library defines cancellation points that are the set of points at which cancellation can occur. The library also allows the scope of cancellation handlers to be defined so that the handlers are sure to operate when and where intended. The cancellation handlers provide clean up services to restore resources and state to a condition that is consistent with the point of origin.\n\nPlacement of cancellation points and the effects of cancellation handlers must be based on an understanding of the application. A mutex is explicitly not a cancellation point and should be held only for the minimal essential time.\n\nLimit regions of asynchronous cancellation to sequences with no external dependencies that could result in dangling resources or unresolved state conditions. Take care to restore cancellation state when returning from some alternate, nested cancellation state. The interface provides features to facilitate restoration: preserves the current cancel state in a referenced variable, preserves the current cancel type in the same way.\n\nCancellations can occur under three different circumstances:\n• At various points in the execution sequence as defined by the standard\n\nBy default, cancellation can occur only at well-defined points as defined by the POSIX standard.\n\nIn all cases, take care that resources and state are restored to a condition consistent with the point of origin.\n\nHow the cancellation request is treated depends on the state of the target thread. Two functions, and , determine that state.\n\nreturns zero after completing successfully. Any other return value indicates that an error occurred. When the following condition occurs, the function fails and returns the corresponding value.\n\nDescription: No thread could be found corresponding to that specified by the given thread ID.\n\nUse (3C) to enable or disable thread cancellation. When a thread is created, thread cancellation is enabled by default.\n\nreturns zero after completing successfully. Any other return value indicates that an error occurred. When the following condition occurs, the function fails and returns the corresponding value.\n\nDescription: The state is not or .\n\nUse (3C) to set the cancellation type to either deferred or asynchronous mode.\n\nWhen a thread is created, the cancellation type is set to deferred mode by default. In deferred mode, the thread can be cancelled only at cancellation points. In asynchronous mode, a thread can be cancelled at any point during its execution. The use of asynchronous mode is discouraged.\n\nreturns zero after completing successfully. Any other return value indicates that an error occurred. When the following condition occurs, the function fails and returns the corresponding value.\n\nDescription: The type is not or .\n\nUse (3C) to establish a cancellation point for a thread.\n\nThe function is effective when thread cancellation is enabled and in deferred mode. has no effect if called while cancellation is disabled.\n\nBe careful to insert only in sequences where thread cancellation is safe. In addition to programmatically establishing cancellation points through the call, the pthreads standard specifies several cancellation points. See Cancellation Points for more details.\n\nhas no return value.\n\nUse cleanup handlers to restore conditions to a state that is consistent with that state at the point of origin. This consistent state includes cleaning up allocated resources and restoring invariants. Use the and functions to manage the handlers.\n\nCleanup handlers are pushed and popped in the same lexical scope of a program. The push and pop should always match. Otherwise, compiler errors are generated.\n\nUse (3C) to push a cleanup handler onto a cleanup stack (LIFO).\n\nhas no return value.\n\nUse (3C) to pull the cleanup handler off the cleanup stack.\n\nA nonzero argument in the pop function removes the handler from the stack and executes the handler. An argument of zero pops the handler without executing the handler.\n\nis effectively called with a nonzero argument when a thread either explicitly or implicitly calls or when the thread accepts a cancel request."
    },
    {
        "link": "https://geeksforgeeks.org/multithreading-in-c",
        "document": "A thread is a single sequence stream within a process. Because threads have some of the properties of processes, they are sometimes called lightweight processes.\n\nWhat are the differences between process and thread?\n\nThreads are not independent from each other unlike processes. As a result, threads shares with other threads their code section, data section and OS resources like open files and signals. But, like processes, a thread has its own program counter (PC), a register set, and a stack space.\n\nWhy Multithreading? Threads are popular way to improve application through parallelism. For example, in a browser, multiple tabs can be different threads. MS word uses multiple threads, one thread to format the text, other thread to process inputs, etc.\n\nThreads operate faster than processes due to following reasons:\n\n2) Context switching between threads is much faster.\n\nSee http://www.personal.kent.edu/~rmuhamma/OpSystems/Myos/threads.htm for more details.\n\nCan we write multithreading programs in C?\n\nUnlike Java, multithreading is not supported by the language standard. POSIX Threads (or Pthreads) is a POSIX standard for threads. Implementation of pthread is available with gcc compiler.\n\nA simple C program to demonstrate use of pthread basic functions\n\nPlease note that the below program may compile only with C compilers with pthread library.\n\nIn main(), we declare a variable called thread_id, which is of type pthread_t, which is an integer used to identify the thread in the system. After declaring thread_id, we call pthread_create() function to create a thread.\n\nThe first argument is a pointer to thread_id which is set by this function.\n\nThe second argument specifies attributes. If the value is NULL, then default attributes shall be used.\n\nThe third argument is name of function to be executed for the thread to be created.\n\nThe fourth argument is used to pass arguments to the function, myThreadFun.\n\nThe pthread_join() function for threads is the equivalent of wait() for processes. A call to pthread_join blocks the calling thread until the thread with identifier equal to the first argument terminates.\n\nHow to compile above program?\n\nTo compile a multithreaded program using gcc, we need to link it with the pthreads library. Following is the command used to compile the program.\n\nA C program to show multiple threads with global and static variables\n\nAs mentioned above, all threads share data segment. Global and static variables are stored in data segment. Therefore, they are shared by all threads. The following example program demonstrates the same.\n\nPlease note that above is simple example to show how threads work. Accessing a global variable in a thread is generally a bad idea. What if thread 2 has priority over thread 1 and thread 1 needs to change the variable. In practice, if it is required to access global variable by multiple threads, then they should be accessed using a mutex."
    },
    {
        "link": "https://stackoverflow.com/questions/9989496/malloc-and-freeing-memory-between-threads-in-c",
        "document": "I am sharing a set of globals between different threads, so I allocate the memory as needed depending on how much is being placed into it. Kinda like a buffer. Whenever I try to free it from the same thread, but different function, glib goes crazy and segfaults.\n\nI'm not a c programmer by far. I am trying to clear up memory leaks in the code that I hacked together.\n\nHere is the output from valgrind.\n\nHow is it an invalid free?"
    },
    {
        "link": "https://stackoverflow.com/questions/54077534/how-memory-is-shared-between-threads-in-c",
        "document": "I know that every thread has his own stack while heap is shared between every threads. Every thread shares common addressing space, so a local variable inside a thread can be seen by another thread using pointers. This is done by using POSIX library pthread, in Linux.\n\nSome of these details may vary with the operating system and threading implementation, but POSIX does specify that\n\nAnything whose address may be determined by a thread, including but not limited to static variables, storage obtained via , directly addressable storage obtained through implementation-defined functions, and automatic variables, are accessible to all threads in the same process.\n\nNo, you have it pretty much backwards. What you can say is that any thread is permitted to read the value of an automatic variable only during that variable's lifetime. The C specifications don't mention stacks at all, but in a stack-based implementation, an automatic variable's lifetime ends when the stack frame to which it belongs is popped, or earlier. After the end of a variable's lifetime, attempting to read its value via a pointer produces undefined behavior. Among the many possible behaviors that could manifest are that any value at all might be read, including the value held by the variable at the end of its lifetime.\n\nYou have not presented a complete example, but when I combined the functions you presented with this :\n\nwhich shows that the second thread is indeed correctly reading the value stored in the allocated object, as should be expected, to the extent that it runs before the program terminates.\n\nThe in is present to make it probable (but not certain) that the overall program does not terminate before the second thread runs to completion. In practice, one ought to join each thread for certainty, but the original functions do not make that possible, and I elected not to modify them."
    },
    {
        "link": "https://w3.cs.jmu.edu/kirkpams/OpenCSF/Books/csf/html/ThreadArgs.html",
        "document": "The imposes a strict format on the prototype of the function that will run in the new thread. It must take a single parameter and return a single value. The last parameter of is passed as the argument to the function, whereas the return value is passed using and . This section looks at the details of these mechanisms and their implications.\n\nPassing a single argument to a thread seems straightforward, but is easy to do incorrectly. As a simple example to illustrate the danger, Code Listing 6.5 is designed to run in a separate thread: A thread that will print a single integer value /* Print the local copy of the argument */ The danger of this code can be illustrated with the loop in Code Listing 6.6. The intent is to pass the value 1 to the first thread, 2 to the second, and so on. However, it is critical to note that there is only a single copy of the variable. That is, this code passes the address of the single variable to all 10 threads; the code almost certainly does not pass the intended values. Passing a pointer to a variable that repeatedly changes is a common error with threads /* What value is actually passed to the thread? */ The key problem is that thread creation and execution is asynchronous. That means that it is impossible to predict when each of the new threads start running. One possible timing is that all 10 threads are created first, leading to storing the value 11. At that point, each of the threads dereference their respective variable and all get the same value of 11. One common solution to this problem is to cast numeric values as pointers, as shown in Code Listing 6.7. That is, the int variable gets cast as a argument in the call to . Then, the argument to casts the argument back to a instance. Each thread should be given a separate value, rather than a shared address /* ints are passed by value, so a COPY gets passed to each call */ What makes this code work is the fact that scalar variables (e.g., variables) are passed using call-by-value semantics. When this code prepares for the call, a separate copy of the current value of the variable is placed into a register or onto the stack. Code Listing 6.8 shows the corrected version of Code Listing 6.5. The function then gets this copy, regardless of any changes to the original variable. When the child thread then casts its parameter to a local , it is working with the correct value that was passed. /* Convention: It is common to name a void* parameter with a name that begins with _, then cast it to a local variable that has the same (or nearly the same) name without the _. So _args will become args. Recall that _ has no special meaning and is treated /* Safe whenever size of int <= size of pointer (which is /* Print the local copy of the argument */ Casting integral values to pointers and back again is a common practice for passing parameters to pthreads. However, while it is generally safe in practice, it is potentially a bug on some platforms. Specifically, this technique relies on the fact that pointers are at least as large as standard integer types. That is, variables are typically (but not required to be) 32 bits in size. Modern CPU architectures tend to use 32- or 64-bit addresses. As such, casting a 32-bit up to a then back to a 32-bit is safe. On the other hand, assume the argument was declared as a variable instance. If the code is running on a 32-bit architecture (which is not uncommon for virtualized systems) but the type is 64 bits in size, then half of the argument is lost by down-casting to the pointer for the call to !\n\nWhen passing multiple arguments to a child thread, the standard approach is to group the arguments within a declaration, as shown in Code Listing 6.9. The address of the instance gets passed as the to . The new thread’s entry point receives a parameter that can then be cast into the type. Passing multiple arguments to a thread requires grouping them into a struct /* Note that the data structure resides on the heap */ Code Listing 6.10 shows the new thread receiving the pointer to the and freeing the allocated memory when it is finished with the data. The child thread receives multiple values through the passed struct /* Using the convention of casting _args to args */ /* Cast args into a meaningful pointer type that we can use */ /* Do not forget to free the struct used for arguments */ A common mistake with passing arguments in this manner is to declare the instance as a local variable instead of using dynamic allocation. The problem, again, is the asynchronous nature of . Consider this sample code: /* Parent thread exits, but the child may not have run yet */ If the child thread runs immediately before returns, then everything would be fine. However, there is no guarantee that this happens. Instead, it is just as likely that returns and the parent thread exits. Once that happens, all data on the parent thread’s stack (including the instance) become invalid. The child thread now has a dangling pointer to potentially corrupted data. This is another example of a race condition that can happen with threads.\n\nThere are three common ways to get return values back from a thread. All three use techniques that are similar to those used for passing arguments. Code Listing 6.11 shows one simple technique, which is to augment the declaration to include space for any return values. Allocating space for a return value as part of the struct passed /* Approach 1: Include space for return values in the struct */ /* Cast the arguments to the usable struct type */ /* Place the result into the struct itself (on the heap) */ The child thread receives a pointer to the instance, using the input parameters as needed. In this case, the values of and are added, and the resulting sum is copied back into the . As shown in Code Listing 6.12, the main thread uses to wait until the child thread exits. Once the child finishes, the main thread can retrieve all three values ( , , and ) from the itself. The main thread can retrieve the return value from the struct after joining the child thread /* Allocate and pass a heap instance of the struct type */ /* Wait for the thread to finish */ /* The struct is still on the heap, so the result is accessible */ There are three key observations about this approach:\n• The main and the child threads have access to both the input and the output. This fact means that the main thread has information about how this particular child thread was invoked. If the main thread is keeping track of many threads, this additional information may be helpful.\n• Responsibility for memory management resides in one location: the main thread. If responsibility is split between the programmer maintaining the main thread and the programmer maintaining the child thread, there is the possibility for miscommunication leading to memory leaks (or worse, premature de-allocation).\n• The major disadvantage of this approach is that the input parameters may be kept on the heap for much longer than needed, particularly if the child thread runs for a significant amount of time. Code Listing 6.13 shows an alternative approach for simple scalar return types, which is to reuse the trick of casting to and from the type. When a thread calls , it can specify a pointer to return as an argument. A second technique to return a value is to pass it as the thread’s exit code /* Cast the argument to the usable struct */ /* Pass the result back by casting it to the void* */ Code Listing 6.14 shows how the main thread calls to retrieve the pointer. Unless the thread has been detached (or it was created with the attribute), the pointer returned with will remain associated with the thread until it is joined. Retrieving a thread’s exit code when it is joined /* Allocate the struct like before and pass it to the thread */ /* Wait for thread to finish and retrieve the void* into sum */ Code Listing 6.15 shows a third approach to returning values from the thread. In this style, the child thread allocates a separate dynamically to hold the return values. This technique allows a thread to return multiple values rather than a single scalar. For instance, consider the following thread. It receives two values as input and returns the results of five simple arithmetic operations. The child can dynamically allocate space for the return values /* struct for passing arguments to the child thread */ /* struct for returning results from the child thread */ /* Cast the args to the usable struct type */ /* De-allocate the input instance and return the pointer to It is critical to note that the struct instance here must be allocated dynamically. Once the thread calls , everything on its stack becomes invalid. A thread should never pass a pointer to a local variable with . Retrieving the returned data can be accomplished with . In the following example, the main thread creates five separate instances of the thread. Each of these child threads gets a pointer to a unique instance with the corresponding parameters. Each child then allocates its own instance on the heap. This allows the data to persist after the thread has finished. In Code Listing 6.14, the main thread gets each thread’s pointer one at a time, with a separate call to . Since the child thread has already finished at this point, the main thread must bear the responsibility for calling to de-allocate the results instance. The main thread passes arguments to the child threads and frees the results /* args[i] is a pointer to the arguments for thread i */ /* Allocate an array of pointers to result structs */ /* Print each of the results and free the struct */ All of the functions for creating threads, passing arguments, and getting return values involve a lot of pointers. Furthermore, the pointers are dereferenced and manipulated asynchronously because of the nature of multithreading. It is vital to remember the types and lifetimes of each pointer and the corresponding data structure.\n• The first parameter for is a . The argument should typically be an existing passed by reference with the operator.\n• The final parameter to must either be a scalar (cast as a pointer) or a pointer to data that persists until the child thread runs. That is, the target of the pointer must not be modified by the main thread until the child thread has been joined (to guarantee the child has run).\n• The parameter to must be a scalar value (cast as a pointer) or a pointer to non-stack data. The data must be guaranteed to be valid even after the thread has been completely destroyed.\n• The final parameter to must be a pointer that is passed by reference. That is, will change this pointer to point to the returned data structure."
    },
    {
        "link": "https://cboard.cprogramming.com/c-programming/129254-pthread-shared-variables.html",
        "document": ">> 5) Finally I wait for the thread in the main code and get the value as below:\n\n That code is incorrect. When two or more threads access the same memory location, and at least one of those threads is writing - then you must use pthread synchronization primitives to access that data.\n\n \n\n In this case you'll want to use to a condition variable to signal \"data ready\", and a mutex to protect access to \"DATA\".\n\n \n\n gg"
    },
    {
        "link": "https://cs.kent.edu/~ruttan/sysprog/lectures/multi-thread/multi-thread.html",
        "document": ""
    }
]