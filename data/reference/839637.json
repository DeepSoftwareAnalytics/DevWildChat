[
    {
        "link": "https://fastapi.tiangolo.com/tutorial/request-files",
        "document": "You can define files to be uploaded by the client using .\n\nMake sure you create a virtual environment, activate it, and then install it, for example: This is because uploaded files are sent as \"form data\".\n\nCreate file parameters the same way you would for or :\n\nThe files will be uploaded as \"form data\".\n\nIf you declare the type of your path operation function parameter as , FastAPI will read the file for you and you will receive the contents as .\n\nKeep in mind that this means that the whole contents will be stored in memory. This will work well for small files.\n\nBut there are several cases in which you might benefit from using .\n\nUsing has several advantages over :\n• You don't have to use in the default value of the parameter.\n• It uses a \"spooled\" file:\n• A file stored in memory up to a maximum size limit, and after passing this limit it will be stored in disk.\n• This means that it will work well for large files like images, videos, large binaries, etc. without consuming all the memory.\n• You can get metadata from the uploaded file.\n• It exposes an actual Python object that you can pass directly to other libraries that expect a file-like object.\n\nhas the following attributes:\n• : A with the original file name that was uploaded (e.g. ).\n• : A (a file-like object). This is the actual Python file object that you can pass directly to other functions or libraries that expect a \"file-like\" object.\n\nhas the following methods. They all call the corresponding file methods underneath (using the internal ).\n• : Writes ( or ) to the file.\n• : Goes to the byte position ( ) in the file.\n• E.g., would go to the start of the file.\n• This is especially useful if you run once and then need to read the contents again.\n\nAs all these methods are methods, you need to \"await\" them.\n\nFor example, inside of an path operation function you can get the contents with:\n\nIf you are inside of a normal path operation function, you can access the directly, for example:\n\nThe way HTML forms ( ) sends the data to the server normally uses a \"special\" encoding for that data, it's different from JSON.\n\nFastAPI will make sure to read that data from the right place instead of JSON.\n\nData from forms is normally encoded using the \"media type\" when it doesn't include files. But when the form includes files, it is encoded as . If you use , FastAPI will know it has to get the files from the correct part of the body. If you want to read more about these encodings and form fields, head to the web docs for .\n\nYou can make a file optional by using standard type annotations and setting a default value of :\n\nYou can also use with , for example, to set additional metadata:\n\nIt's possible to upload several files at the same time.\n\nThey would be associated to the same \"form field\" sent using \"form data\".\n\nTo use that, declare a list of or :\n\nYou will receive, as declared, a of or s.\n\nAnd the same way as before, you can use to set additional parameters, even for :\n\nUse , , and to declare files to be uploaded in the request, sent as form data."
    },
    {
        "link": "https://stackoverflow.com/questions/63048825/how-to-upload-file-using-fastapi",
        "document": "First, as per FastAPI documentation, you need to install —if you haven't already—as uploaded files are sent as \"form data\". For instance:\n\nThe examples below use the attribute of the object to get the actual Python file (i.e., ), which allows you to call the 's methods, such as and , without having to them. It is important, however, to define your endpoint with in this case—otherwise, if the endpoint was defined with , such operations would block the server until they are completed. In FastAPI, a normal endpoint is run in an external threadpool that is then ed, instead of being called directly (as it would block the server). I would highly suggest having a look at this answer, which explains the difference between and endpoints, as well as provides a number of solutions when one needs to run blocking operations inside endpoints.\n\nThe used by FastAPI/Starlette has the attribute set to 1 MB, meaning that the data are spooled in memory until the file size exceeds 1 MB, at which point the data are written to a temporary file on disk, under the OS's temp directory. Hence, if you uploaded a file larger than 1 MB, it wouldn't be stored in memory, and calling would actually read the data from disk into memory. Thus, if the file is too large to fit into your server's RAM, you should rather read the file in chunks and process one chunk at a time, as described in \"Read the File in chunks\" section below.\n\nAs explained above and in this answer as well, FastAPI/Starlette uses AnyIO threads to run blocking functions, such as endpoints defined with normal , in an external threadpool and then them (so that FastAPI would still work asynchronously), in order to prevent them from blocking the event loop (of the main thread), and hence, the entire server. Therefore, every time an HTTP request arrives at an endpoint defined with normal , a new thread will be spawned (or an idle thread will be used, if available), and thus, depending on the requirements of your project, the expected traffic (i.e., number of users simultaneously accessing your API), as well as any other blocking functions in your API that will eventually run in that threadpool (see the linked answers above for more details), you might need to adjust the maximum number of threads in that threadpool (see the linked answer above on how to do that).\n\nHowever, you should always aim at using asynchronous code (i.e., using / ), wherever is possible, as code runs directly in the event loop which runs in a single thread (in this case, the main thread). One option would be to define the endpoint with and use the asynchronous / / /etc. file methods provided by FastAPI, as demonstrated in this answer. You should, however, note that, as explained in this answer, FastAPI, behind the scenes, actually calls the corresponding synchronous Python File methods in a separate thread from the external threadpool described earlier. Thus, it might or might not make a big difference (always perform and compare tests before choosing one approach over the other).\n\nNote that in the bottom part of this answer, as well as in this answer, another approach is explained and demonstrated on how to upload large files in chunks, using Starlette's , which results in considerably minimizing the time required to upload files, as well as avoiding the use of threads from the external threadpool. Thus, I would highly recommend taking a look.\n\nAs described earlier and in this answer, if the file is too big to fit into memory—for instance, if you have 8GB of RAM, you can't load a 50GB file (not to mention that the available RAM will always be less than the total amount installed on your machine, as other applications will be using some of the RAM)—you should rather load the file into memory in chunks and process the data one chunk at a time. This method, however, may take longer to complete, depending on the chunk size you choose—in the example below, the chunk size is bytes (i.e., 1MB). You can adjust the chunk size as desired.\n\nAnother option would be to use , which is used to copy the contents of a object to another object (have a look at this answer too). By default, the data is read in chunks with the default buffer (chunk) size being 1MB (i.e., bytes) for Windows and 64KB for other platforms, as shown in the source code here. You can specify the buffer size by passing the optional parameter. Note: If negative value is passed, the entire contents of the file will be read instead—see as well, which uses under the hood (as can be seen in the source code here).\n\nFor an HTML example, see here.\n\nAs described earlier in this answer, if you expect some rather large file(s) and don't have enough RAM to accommodate all the data from the beginning to the end, you should rather load the file into memory in chunks, thus processing the data one chunk at a time (Note: adjust the chunk size as desired, below that is bytes).\n\nFor an HTML example, see here."
    },
    {
        "link": "https://blog.ionxsolutions.com/p/file-uploads-with-python-fastapi",
        "document": "FastAPI is a modern web framework for Python that enables you to build APIs quickly. It’s built on standard Python type hints, making it easier to work with and maintain. With built-in support for asynchronous request handling, it’s also ideal for high-performance applications.\n\nCombined with Verisys Antivirus API, FastAPI helps you build secure file upload endpoints, crucial for any web or mobile app handling potentially unsafe files.\n\nThe first step is to create a Python environment, ready with the libraries we will use for the FastAPI project.\n• Open a terminal or command prompt, and navigate to the directory where you want to store the project\n• For this tutorial, we’ll also use the library to send uploaded files to Verisys Antivirus API for malware scanning:\n\nLet’s start by setting up a simple FastAPI app that will accept file uploads. Create a file with this content:\n\nTo run the API using the Uvicorn web server, execute the following from the same folder as :\n\nThe flag allows the server to automatically reload as we make changes to the code, which is helpful during development.\n\nOnce Uvicorn starts, you’ll see output indicating that the app is running, along with the URL where it’s accessible. By default, it will run at:\n\nTo test the basic file upload functionality, you can simply use , or you could a tool like Postman or Insomnia.\n\nHere’s an example using curl, with a file (substitute for any file you want to upload):\n\nYou should see a result similar to:\n\nUploading files is a start, but ensuring that uploaded files are free of malware is critical, especially when accepting files from end users. Verisys Antivirus API allows us to scan files before processing them further.\n\nHere’s how to integrate Verisys Antivirus API to scan uploaded files:\n• Get your Verisys API Key: Before we start, ensure you have your Verisys Antivirus API key. If you don’t have one, visit Verisys Antivirus API to get started or request a trial.\n• Send the file to Verisys Antivirus API: Once the file has been received, send it to the Verisys API for scanning.\n\n# Print the full scan result to the console # Print information about the file to the console # In real-life, you'd now use the scan result to determine what to do # next - but here, we'll just return the scan results to the caller\n\nIn this modified version, after the file is uploaded, it’s passed to the scan_file function, which sends the file to Verisys Antivirus API for scanning. The response from Verisys is returned as part of the result, indicating whether the file is safe or malicious.\n\nTo test the file upload and scanning functionality, as before you can use or another tool of your preference.\n\nHere’s an example using curl, with an EICAR Anti-Virus Test File (substitute for any file you want to upload):\n\nDepending on the file you upload, you should see the malware scan result:\n\nYour upload endpoint could use the scan result to determine what to do next - for example, to prevent uploading files that contain malware.\n\nNote that while in this example the file masqueraded as a PNG image file, Verisys Antivirus API detected that it was actually a plain text file!\n\nHere are a couple of additional tips to ensure your file upload system is secure:\n• Limit File Size: Ensure you’re not accepting excessively large files, which could cause performance issues or even DoS attacks. FastAPI allows you to define custom file size limits.\n• Restrict File Types: Only accept specific file types (e.g., PDFs, images) to prevent the upload of executable or malicious files.\n\nVerisys Antivirus API is specifically designed to ensure secure file uploads in your applications. Here’s why it’s a great fit for your project:\n• Powerful Malware Detection: Verisys detects a wide range of threats, ensuring that no malicious files slip through.\n• Easy Integration: The API is simple to integrate with any web framework, including FastAPI.\n• Content Type Detection: Alongside malware scanning, the API also scans the file content to determine the real file type.\n\nHandling file uploads is essential for many applications, but steps must be taken to ensure security. By using FastAPI and Verisys Antivirus API, you can create a secure file upload endpoint that scans files for malware before processing them further. Whether you’re building a web app or an API for file storage, this approach ensures that your infrastructure - and your users - remain safe from harmful files.\n\nIf you haven’t yet, sign up for Verisys Antivirus API today and start protecting your application against malware!"
    },
    {
        "link": "https://medium.com/@chodvadiyasaurabh/building-a-file-upload-and-download-api-with-python-and-fastapi-3de94e4d1a35",
        "document": "In this blog, we will explore how to create a file upload and download API using Python and FastAPI. FastAPI is a modern, fast, and highly efficient web framework for building APIs with Python. We will walk through the code provided and explain each step in detail, demonstrating how to handle file uploads, store them in Oracle Object Storage, and enable users to download the uploaded files.\n\nPrerequisites: To follow along with this tutorial, you should have basic knowledge of Python, RESTful APIs, and web development concepts. Additionally, you’ll need Python and FastAPI installed on your system.\n\nSetting Up the FastAPI Project: Before we dive into the code, make sure you have created a FastAPI project. If you haven’t, follow these steps:\n\n2. Create a new Python file, e.g., , and import the required modules:\n\nNow let’s go through the provided code and understand each part:\n\nHere, we import the necessary modules and create an instance of the FastAPI app.\n\nThis endpoint handles file uploads. It expects multiple files, a fund ID, and a snapshot date as form data. Additionally, it requires HTTP authorization credentials for security and a database session.\n\nHere, we validate the fund ID and snapshot date provided in the form data. If the validation fails, we return appropriate error responses.\n\nIn this section, we set up the Oracle Object Storage client with appropriate configurations and credentials. We loop through the uploaded files, create unique filenames, and upload them to the specified bucket.\n\nHere, we concatenate the file paths and update the corresponding rows in the database with the file path information.\n\nThis endpoint handles file downloads. It expects the file name to be downloaded and requires HTTP authorization credentials and a database session.\n\nCongratulations! You have successfully built a File Upload and Download API using FastAPI and Oracle Object Storage. This API allows users to upload files, stores them in the cloud, and then download them when needed. You can extend this API by adding more functionalities like file deletion, user authentication, and access control to fit your specific requirements. FastAPI’s easy-to-use and efficient framework, along with Oracle Object Storage’s scalable and secure cloud storage solution, makes this combination a powerful tool for building file management APIs in modern web applications."
    },
    {
        "link": "https://restack.io/p/ai-python-answer-fastapi-file-upload-best-practices-cat-ai",
        "document": "Explore best practices for file uploads in FastAPI, focusing on efficiency and security in AI Python applications."
    },
    {
        "link": "https://stackoverflow.com/questions/38179706/uploading-a-file-in-multipart-form-data-in-qt5",
        "document": "I am trying desperately to upload a file to a server in Multipart. I have almost the same code as in the Qt docs, but the file isn't uploading to the server.\n\nHere's what I have in my Debug:\n\nThe problem is not coming from the server because when I try uploading a file on it in multipart with a Chrome or Firefox extention it actually works!\n\nHere is my code:"
    },
    {
        "link": "https://forum.qt.io/topic/56708/solved-qnetworkaccessmanager-adding-a-multipart-form-data-to-a-post-request",
        "document": "I am trying to communicate with a web service to upload a file.\n\n Here is the web service : http://strava.github.io/api/v3/uploads/#post-file\n\nIt seems I am unable to attach the file in the POST request. I have been looking for a way to do that with QNetworkAccessManager so I can do the POST request directly in Qt.\n\nHere is my current code, The server is answering with this error :\n\n\n\nThanks for your help!"
    },
    {
        "link": "https://forum.qt.io/topic/77763/uploading-a-file-in-multipart-form-data-in-qt5",
        "document": "Your browser does not seem to support JavaScript. As a result, your viewing experience will be diminished, and you have been placed in read-only mode.\n\nPlease download a browser that supports JavaScript, or enable it if it's disabled (i.e. NoScript)."
    },
    {
        "link": "https://stackoverflow.com/questions/15109656/qnetworkaccessmanager-post-http-multipart-from-serial-qiodevice",
        "document": "I'm trying to use QNetworkAccessManager to upload http multiparts to a dedicated server.\n\nThe multipart consists of a JSON part describing the data being uploaded.\n\nThe data is read from a serial QIODevice, which encrypts the data.\n\nThis is the code that creates the multipart request:\n\nIf the p_encDevice is an instance of QFile, that file gets uploaded just fine.\n\nIf the specialised encrypting QIODevice is used (serial device) then all of the data is read from my custom device. however QNetworkAccessManager::post() doesn't complete (hangs).\n\nI read in the documentation of QHttpPart that:\n\nUnfortunately I don't know how do that.\n\nQIODevice doesn't have finished() slot at all. What's more, reading from my custom IODevice doesn't happen at all if QNetworkAccessManager::post() is not called and therefore the device wouldn't be able to emit such an event. (Catch 22?)\n\nIt seems that QNAM does not work with sequential devices at all. See discussion on qt-project.\n\nI managed to \"fool\" QNAM to make it think that it is reading from non-sequential devices, but seek and reset functions prevent seeking. This will work until QNAM will actually try to seek."
    },
    {
        "link": "https://qtcentre.org/threads/17564-file-upload-using-QNetworkRequest-amp-QNetworkAccessManager",
        "document": "To copy to clipboard, switch view to plain text mode\n\nTo copy to clipboard, switch view to plain text mode"
    }
]