[
    {
        "link": "https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript",
        "document": "What is the most efficient way to clone a JavaScript object? I've seen obj = eval(uneval(o)); being used, but that's non-standard and only supported by Firefox . I've done things like obj = JSON.parse(JSON.stringify(o)); but question the efficiency. I've also seen recursive copying functions with various flaws. I'm surprised no canonical solution exists.\n\n. Edit existing answers to improve this post. It is not currently accepting new answers or interactions.\n\nIn my previous tests where speed was a main concern I found to be the slowest way to deep clone an object (it is slower than jQuery.extend with flag set true by 10-20%). jQuery.extend is pretty fast when the flag is set to (shallow clone). It is a good option, because it includes some extra logic for type validation and doesn't copy over undefined properties, etc., but this will also slow you down a little. If you know the structure of the objects you are trying to clone or can avoid deep nested arrays you can write a simple loop to clone your object while checking hasOwnProperty and it will be much much faster than jQuery. Lastly if you are attempting to clone a known object structure in a hot loop you can get MUCH MUCH MORE PERFORMANCE by simply in-lining the clone procedure and manually constructing the object. JavaScript trace engines suck at optimizing loops and checking hasOwnProperty will slow you down as well. Manual clone when speed is an absolute must. Beware using the method on objects - returns a string representation of the date in ISO format, which doesn't convert back to a object. See this answer for more details. Additionally, please note that, in Chrome 65 at least, native cloning is not the way to go. According to JSPerf, performing native cloning by creating a new function is nearly 800x slower than using JSON.stringify which is incredibly fast all the way across the board. If you are using Javascript ES6 try this native method for cloning or shallow copy.\n\nModern browsers and runtimes provide a global function, exposing the HTML standard's previously-internal structured cloning/serialization algorithm for creating deep clones of objects. It's still limited to certain built-in types, but in addition to the few types supported by JSON it supports Dates, RegExps, Maps, Sets, Blobs, FileLists, ImageDatas, sparse Arrays, Typed Arrays, and probably more in the future. It also preserves references within the cloned data, allowing it to support cyclical and recursive structures that would cause errors for JSON. In case you need to support older environments, the rest of this answer describes workarounds to use this capability before it was directly exposed. Node.js provides a rich interface for the structured serialization API in its module. Cloning an object is as simple as: The lowest-overhead way to create a structured clone with previous APIs is to post the data through one port of a MessageChannels. The other port will emit a event with a structured clone of the attached . Unfortunately, listening for these events is necessarily asynchronous, and the synchronous alternatives are less practical. class StructuredCloner { constructor() { this.pendingClones_ = new Map(); this.nextKey_ = 0; const channel = new MessageChannel(); this.inPort_ = channel.port1; this.outPort_ = channel.port2; this.outPort_.onmessage = ({data: {key, value}}) => { const resolve = this.pendingClones_.get(key); resolve(value); this.pendingClones_.delete(key); }; this.outPort_.start(); } cloneAsync(value) { return new Promise(resolve => { const key = this.nextKey_++; this.pendingClones_.set(key, resolve); this.inPort_.postMessage({key, value}); }); } } const structuredCloneAsync = window.structuredCloneAsync = StructuredCloner.prototype.cloneAsync.bind(new StructuredCloner); const main = async () => { const original = { date: new Date(), number: Math.random() }; original.self = original; const clone = await structuredCloneAsync(original); // They're different objects: console.assert(original !== clone); console.assert(original.date !== clone.date); // They're cyclical: console.assert(original.self === original); console.assert(clone.self === clone); // They contain equivalent values: console.assert(original.number === clone.number); console.assert(Number(original.date) === Number(clone.date)); console.log(\"Assertions complete.\"); }; main(); There are no good options for creating structured clones synchronously. Here are a couple of impractical hacks instead. and both create a structured clone of their first argument, and assign that value to . You can use this to create a structured clone of any object like this: 'use strict'; const main = () => { const original = { date: new Date(), number: Math.random() }; original.self = original; const clone = structuredClone(original); // They're different objects: console.assert(original !== clone); console.assert(original.date !== clone.date); // They're cyclical: console.assert(original.self === original); console.assert(clone.self === clone); // They contain equivalent values: console.assert(original.number === clone.number); console.assert(Number(original.date) === Number(clone.date)); console.log(\"Assertions complete.\"); }; const structuredClone = obj => { const oldState = history.state; history.replaceState(obj, null); const clonedObj = history.state; history.replaceState(oldState, null); return clonedObj; }; main(); Though synchronous, this can be extremely slow. It incurs all of the overhead associated with manipulating the browser history. Calling this method repeatedly can cause Chrome to become temporarily unresponsive. The constructor creates a structured clone of its associated data. It also attempts to display a browser notification to the user, but this will silently fail unless you have requested notification permission. In case you have the permission for other purposes, we'll immediately close the notification we've created. 'use strict'; const main = () => { const original = { date: new Date(), number: Math.random() }; original.self = original; const clone = structuredClone(original); // They're different objects: console.assert(original !== clone); console.assert(original.date !== clone.date); // They're cyclical: console.assert(original.self === original); console.assert(clone.self === clone); // They contain equivalent values: console.assert(original.number === clone.number); console.assert(Number(original.date) === Number(clone.date)); console.log(\"Assertions complete.\"); }; const structuredClone = obj => { const n = new Notification('', {data: obj, silent: true}); n.close(); return n.data; }; main();\n\nHere's a version of ConroyP's answer above that works even if the constructor has required parameters: //If Object.create isn't already defined, we just do the simple shim, //without the second argument, since that's all we need here var object_create = Object.create; if (typeof object_create !== 'function') { object_create = function(o) { function F() {} F.prototype = o; return new F(); }; } function deepCopy(obj) { if(obj == null || typeof(obj) !== 'object'){ return obj; } //make sure the returned object has the same prototype as the original var ret = object_create(obj.constructor.prototype); for(var key in obj){ ret[key] = deepCopy(obj[key]); } return ret; } This function is also available in my simpleoo library. Here's a more robust version (thanks to Justin McCandless this now supports cyclic references as well): /** * Deep copy an object (make copies of all its object properties, sub-properties, etc.) * An improved version of http://keithdevens.com/weblog/archive/2007/Jun/07/javascript.clone * that doesn't break if the constructor has required parameters * * It also borrows some code from http://stackoverflow.com/a/11621004/560114 */ function deepCopy(src, /* INTERNAL */ _visited, _copiesVisited) { if(src === null || typeof(src) !== 'object'){ return src; } //Honor native/custom clone methods if(typeof src.clone == 'function'){ return src.clone(true); } //Special cases: //Date if(src instanceof Date){ return new Date(src.getTime()); } //RegExp if(src instanceof RegExp){ return new RegExp(src); } //DOM Element if(src.nodeType && typeof src.cloneNode == 'function'){ return src.cloneNode(true); } // Initialize the visited objects arrays if needed. // This is used to detect cyclic references. if (_visited === undefined){ _visited = []; _copiesVisited = []; } // Check if this object has already been visited var i, len = _visited.length; for (i = 0; i < len; i++) { // If so, get the copy we already made if (src === _visited[i]) { return _copiesVisited[i]; } } //Array if (Object.prototype.toString.call(src) == '[object Array]') { //[].slice() by itself would soft clone var ret = src.slice(); //add it to the visited array _visited.push(src); _copiesVisited.push(ret); var i = ret.length; while (i--) { ret[i] = deepCopy(ret[i], _visited, _copiesVisited); } return ret; } //If we've reached here, we have a regular object //make sure the returned object has the same prototype as the original var proto = (Object.getPrototypeOf ? Object.getPrototypeOf(src): src.__proto__); if (!proto) { proto = src.constructor.prototype; //this line would probably only be reached by very old browsers } var dest = object_create(proto); //add this object to the visited array _visited.push(src); _copiesVisited.push(dest); for (var key in src) { //Note: this does NOT preserve ES5 property attributes like 'writable', 'enumerable', etc. //For an example of how this could be modified to do so, see the singleMixin() function dest[key] = deepCopy(src[key], _visited, _copiesVisited); } return dest; } //If Object.create isn't already defined, we just do the simple shim, //without the second argument, since that's all we need here var object_create = Object.create; if (typeof object_create !== 'function') { object_create = function(o) { function F() {} F.prototype = o; return new F(); }; }\n\nI have two good answers depending on whether your objective is to clone a \"plain old JavaScript object\" or not. Let's also assume that your intention is to create a complete clone with no prototype references back to the source object. If you're not interested in a complete clone, then you can use many of the Object.clone() routines provided in some of the other answers (Crockford's pattern). For plain old JavaScript objects, a tried and true good way to clone an object in modern runtimes is quite simply: Note that the source object must be a pure JSON object. This is to say, all of its nested properties must be scalars (like boolean, string, array, object, etc). Any functions or special objects like RegExp or Date will not be cloned. Is it efficient? Heck yes. We've tried all kinds of cloning methods and this works best. I'm sure some ninja could conjure up a faster method. But I suspect we're talking about marginal gains. This approach is just simple and easy to implement. Wrap it into a convenience function and if you really need to squeeze out some gain, go for at a later time. Now, for non-plain JavaScript objects, there isn't a really simple answer. In fact, there can't be because of the dynamic nature of JavaScript functions and inner object state. Deep cloning a JSON structure with functions inside requires you recreate those functions and their inner context. And JavaScript simply doesn't have a standardized way of doing that. The correct way to do this, once again, is via a convenience method that you declare and reuse within your code. The convenience method can be endowed with some understanding of your own objects so you can make sure to properly recreate the graph within the new object. We're written our own, but the best general approach I've seen is covered here: This is the right idea. The author (David Walsh) has commented out the cloning of generalized functions. This is something you might choose to do, depending on your use case. The main idea is that you need to special handle the instantiation of your functions (or prototypal classes, so to speak) on a per-type basis. Here, he's provided a few examples for RegExp and Date. Not only is this code brief, but it's also very readable. It's pretty easy to extend. Is this efficient? Heck yes. Given that the goal is to produce a true deep-copy clone, then you're going to have to walk the members of the source object graph. With this approach, you can tweak exactly which child members to treat and how to manually handle custom types. So there you go. Two approaches. Both are efficient in my view."
    },
    {
        "link": "https://dev.to/hkp22/javascript-shallow-copy-vs-deep-copy-examples-and-best-practices-3k0a",
        "document": "Writing Clean and Efficient JavaScript: 10 Best Practices Every Developer Should Know\n\nMastering Arrow Functions in JavaScript: Simplify Your Code with Concise Syntax and Lexical `this` Binding\n\nWhen working with objects and arrays in JavaScript, creating copies of data structures is a common task. However, developers often face challenges when deciding between a shallow copy and a deep copy. Misunderstanding the differences can lead to unintended side effects in your code. Let’s dive into these concepts, their differences, and when to use each.\n\nA shallow copy creates a new object with copies of the top-level properties of the original object. For properties that are primitives (e.g., numbers, strings, booleans), the value itself is copied. However, for properties that are objects (like arrays or nested objects), only the reference is copied—not the actual data.\n\nThis means that while the new object has its own copy of top-level properties, the nested objects or arrays remain shared between the original and the copy.\n\nWhile these methods are fast and easy, they are not suitable for deeply nested objects.\n\nA deep copy duplicates every property and sub-property of the original object. This ensures that the copy is completely independent of the original, and changes to the copy do not affect the original object.\n\nDeep copying is essential when dealing with complex data structures like nested objects or arrays, particularly in scenarios where data integrity is critical.\n• Using and :\n• Converts the object into a JSON string and then parses it back into a new object.\n• Custom Recursive Function:\n• For full control, you can write a recursive function to clone nested objects.\n\nWhen to Use Shallow Copy\n• Flat Objects: When dealing with simple objects without nested properties.\n• Performance: When speed is crucial, and you don’t need to handle deeply nested data.\n• Temporary Changes: When you intend to modify top-level properties but share nested data.\n\nWhen to Use Deep Copy\n• Complex Structures: For objects with multiple levels of nesting.\n• Avoiding Side Effects: When you need to ensure that changes in the copy don’t affect the original.\n• State Management: In frameworks like React or Redux, where immutability is critical.\n\nDuplicating the state of a game or application:\n• \n• Developers often mistakenly use shallow copy methods for nested objects, leading to unintended changes in the original data.\n• \n• While / is simple, it doesn’t work for all objects (e.g., those containing methods or circular references).\n• \n• Deep copy methods can be slower, especially for large objects, so use them judiciously.\n\nUnderstanding the difference between shallow copy and deep copy is essential for writing bug-free JavaScript code. Shallow copies are efficient for flat structures, while deep copies are indispensable for complex, nested objects. Choose the appropriate method based on your data structure and application needs, and avoid potential pitfalls by knowing the limitations of each approach."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Glossary/Deep_copy",
        "document": "A deep copy of an object is a copy whose properties do not share the same references (point to the same underlying values) as those of the source object from which the copy was made. As a result, when you change either the source or the copy, you can be assured you're not causing the other object to change too. That behavior contrasts with the behavior of a shallow copy, in which changes to nested properties in the source or the copy may cause the other object to change too.\n\nTwo objects and are structurally equivalent if their observed behaviors are the same. These behaviors include:\n• The properties of and have the same names in the same order.\n• The values of their properties are structurally equivalent.\n• Their prototype chains are structurally equivalent (although when we deal with structural equivalence, these objects are usually plain objects, meaning they both inherit from ).\n\nStructurally equivalent objects can either be the same object ( ) or copies ( ). Because equivalent primitive values always compare equal, you cannot make copies of them.\n\nWe can now define deep copies more formally as:\n• They are not the same object ( ).\n• The properties of and have the same names in the same order.\n• The values of their properties are deep copies of each other.\n\nDeep copies may or may not have their prototype chains copied (and often they do not). But two objects with structurally non-equivalent prototype chains (for example, one is an array and the other is a plain object) are never copies of each other.\n\nThe copy of an object whose properties all have primitive values fits the definition of both a deep copy and a shallow copy. It is somewhat useless to talk about the depth of such a copy, though, because it has no nested properties and we usually talk about deep copying in the context of mutating nested properties.\n\nIn JavaScript, standard built-in object-copy operations (spread syntax, , , , and ) do not create deep copies (instead, they create shallow copies).\n\nOne way to make a deep copy of a JavaScript object, if it can be serialized, is to use to convert the object to a JSON string, and then to convert the string back into a (completely new) JavaScript object:\n\nBecause a deep copy shares no references with its source object, any changes made to the deep copy do not affect the source object.\n\nHowever, while the object in the code above is simple enough to be serializable, many JavaScript objects are not serializable at all — for example, functions (with closures), Symbols, objects that represent HTML elements in the HTML DOM API, recursive data, and many other cases. Calling to serialize the objects in those cases will fail. So there's no way to make deep copies of such objects.\n\nThe web API also creates deep copies and has the advantage of allowing transferable objects in the source to be transferred to the new copy, rather than just cloned. It also handles more data types, such as . But note that isn't a feature of the JavaScript language itself — instead it's a feature of browsers and other JavaScript hosts that implement web APIs. And calling to clone a non-serializable object will fail in the same way that calling to serialize it will fail."
    },
    {
        "link": "https://medium.com/@saikiran-dev/absolute-modern-way-to-deep-clone-object-in-javascript-61f0282db8de",
        "document": "But, now, there is a native way in the javascript to create a deep copy of objects.\n\nis new function that is built into the javascript runtime to create deep copy of the objects.\n\nNow, is already in use but why is there need to introduce a totally new funtion for the same operation?\n\nAnswer is both does not behave in the same way. Let’s look at one example then we will understand why is suits better than\n\nthen using and perform the deep copy. Following is the result:\n\nlet’s do same with . Here is the log.\n\nIf you closely observe, date should be a Date object not a string but incase of structuredDeepCopy, date is Date object NOT a string. can not handle every type that we use in javascript.\n\nThere are lot other things that can not handle in the javascript. So, it is better to go with the ."
    },
    {
        "link": "https://stackoverflow.com/questions/38416020/deep-copy-in-es6-using-the-spread-syntax",
        "document": "You can use like the following:\n\nYou can use that is a built-in function for deep-copying. Structured cloning addresses many (although not all) shortcomings of the technique. Structured cloning can handle cyclical data structures, support many built-in data types, and is generally more robust and often faster.\n\nHowever, it still has some limitations that may catch you off-guard:\n\n1-Prototypes : If you use with a class instance, you’ll get a plain object as the return value, as structured cloning discards the object’s prototype chain.\n\n2-Functions: If your object contains functions, they will be quietly discarded.\n\n3- Non-cloneables: Some values are not structured cloneable, most notably Error and DOM nodes. It will cause structuredClone() to throw.\n\nIf you simply want to deep copy the object to another object, all you will need to do is the object and parse it using afterward. This will essentially perform deep copying of the object.\n\nOne way to create a shallow copy in JavaScript using the object spread operator ... or like the following:\n\nWhen it comes to performance the creator Surma has pointed out that can be a bit faster for small objects. But when you have a large object, complex object starts to get significantly faster.\n\nBrowser support is pretty fantastic And even is supported by Node.js."
    },
    {
        "link": "https://geeksforgeeks.org/lodash-_-clonedeep-method",
        "document": "The Lodash _.cloneDeep() method is handy for making a complete copy of a value. It goes deep into the value, copying everything inside it too. So, the new object you get has the exact same data as the original, but they’re not linked in memory.\n\nThis method is similar to the _.clone() method.\n• value parameter holds the value that needs to be cloned recursively.\n• None This method returns the deep-cloned value\n\nExample 1: In this example, It is returning false because they both have the same value but different memory allocations, and the “===” operator checks for the same reference in objects\n\nExample 2: In this example, It is returning false because they both have the same value but different memory allocations, and “===” operator checks for the same reference in objects and we can change the original object it will not change the cloned object’s value as both of them have different memory allocation\n\nWhat does _.cloneDeep() do?\n\nHow do you use _.cloneDeep()?"
    },
    {
        "link": "https://lodash.com/docs",
        "document": "The opposite of ; this method creates a function that invokes once it's called or more times.\n• (number): The number of calls before is invoked. Creates a function that invokes , with up to arguments, ignoring any additional arguments.\n• (Function): The function to cap arguments for. Creates a function that invokes , with the binding and arguments of the created function, while it's called less than times. Subsequent calls to the created function return the result of the last invocation.\n• (number): The number of calls at which is no longer invoked. Creates a function that invokes with the binding of and prepended to the arguments it receives.\n\n\n\nThe value, which defaults to in monolithic builds, may be used as a placeholder for partially applied arguments.\n\n\n\nNote: Unlike native , this method doesn't set the \"length\" property of bound functions.\n• (...*): The arguments to be partially applied. Creates a function that invokes the method at with prepended to the arguments it receives.\n\n\n\nThis method differs from by allowing bound functions to reference methods that may be redefined or don't yet exist. See Peter Michaux's article for more details.\n\n\n\nThe value, which defaults to in monolithic builds, may be used as a placeholder for partially applied arguments.\n• (Object): The object to invoke the method on.\n• (string): The key of the method.\n• (...*): The arguments to be partially applied. Creates a function that accepts arguments of and either invokes returning its result, if at least number of arguments have been provided, or returns a function that accepts the remaining arguments, and so on. The arity of may be specified if is not sufficient.\n\n\n\nThe value, which defaults to in monolithic builds, may be used as a placeholder for provided arguments.\n\n\n\nNote: This method doesn't set the \"length\" property of curried functions. This method is like except that arguments are applied to in the manner of instead of .\n\n\n\nThe value, which defaults to in monolithic builds, may be used as a placeholder for provided arguments.\n\n\n\nNote: This method doesn't set the \"length\" property of curried functions. Creates a debounced function that delays invoking until after milliseconds have elapsed since the last time the debounced function was invoked. The debounced function comes with a method to cancel delayed invocations and a method to immediately invoke them. Provide to indicate whether should be invoked on the leading and/or trailing edge of the timeout. The is invoked with the last arguments provided to the debounced function. Subsequent calls to the debounced function return the result of the last invocation.\n\n\n\nNote: If and options are , is invoked on the trailing edge of the timeout only if the debounced function is invoked more than once during the timeout.\n\n\n\nIf is and is , invocation is deferred until to the next tick, similar to with a timeout of .\n\n\n\nSee David Corbacho's article for details over the differences between and .\n• (number): The number of milliseconds to delay.\n• (boolean): Specify invoking on the leading edge of the timeout.\n• (number): The maximum time is allowed to be delayed before it's invoked.\n• (boolean): Specify invoking on the trailing edge of the timeout. Defers invoking the until the current call stack has cleared. Any additional arguments are provided to when it's invoked.\n• (...*): The arguments to invoke with. Invokes after milliseconds. Any additional arguments are provided to when it's invoked.\n• (number): The number of milliseconds to delay invocation.\n• (...*): The arguments to invoke with.\n• (Function): The function to flip arguments for. Creates a function that memoizes the result of . If is provided, it determines the cache key for storing the result based on the arguments provided to the memoized function. By default, the first argument provided to the memoized function is used as the map cache key. The is invoked with the binding of the memoized function.\n\n\n\nNote: The cache is exposed as the property on the memoized function. Its creation may be customized by replacing the constructor with one whose instances implement the method interface of , , , , and .\n• (Function): The function to have its output memoized.\n• (Function): The function to resolve the cache key. Creates a function that negates the result of the predicate . The predicate is invoked with the binding and arguments of the created function. Creates a function that is restricted to invoking once. Repeat calls to the function return the value of the first invocation. The is invoked with the binding and arguments of the created function. Creates a function that invokes with its arguments transformed. Creates a function that invokes with prepended to the arguments it receives. This method is like except it does not alter the binding.\n\n\n\nThe value, which defaults to in monolithic builds, may be used as a placeholder for partially applied arguments.\n\n\n\nNote: This method doesn't set the \"length\" property of partially applied functions.\n• (Function): The function to partially apply arguments to.\n• (...*): The arguments to be partially applied. This method is like except that partially applied arguments are appended to the arguments it receives.\n\n\n\nThe value, which defaults to in monolithic builds, may be used as a placeholder for partially applied arguments.\n\n\n\nNote: This method doesn't set the \"length\" property of partially applied functions.\n• (Function): The function to partially apply arguments to.\n• (...*): The arguments to be partially applied. Creates a function that invokes with arguments arranged according to the specified where the argument value at the first index is provided as the first argument, the argument value at the second index is provided as the second argument, and so on.\n• (Function): The function to rearrange arguments for. Creates a function that invokes with the binding of the created function and arguments from and beyond provided as an array.\n\n\n\nNote: This method is based on the rest parameter.\n• (Function): The function to apply a rest parameter to.\n• (number): The start position of the rest parameter. Creates a function that invokes with the binding of the create function and an array of arguments much like .\n\n\n\nNote: This method is based on the spread operator.\n• (Function): The function to spread arguments over.\n• (number): The start position of the spread. say = _ ( (who what) { Creates a throttled function that only invokes at most once per every milliseconds. The throttled function comes with a method to cancel delayed invocations and a method to immediately invoke them. Provide to indicate whether should be invoked on the leading and/or trailing edge of the timeout. The is invoked with the last arguments provided to the throttled function. Subsequent calls to the throttled function return the result of the last invocation.\n\n\n\nNote: If and options are , is invoked on the trailing edge of the timeout only if the throttled function is invoked more than once during the timeout.\n\n\n\nIf is and is , invocation is deferred until to the next tick, similar to with a timeout of .\n\n\n\nSee David Corbacho's article for details over the differences between and .\n• (number): The number of milliseconds to throttle invocations to.\n• (boolean): Specify invoking on the leading edge of the timeout.\n• (boolean): Specify invoking on the trailing edge of the timeout. Creates a function that accepts up to one argument, ignoring any additional arguments.\n• (Function): The function to cap arguments for. Creates a function that provides to as its first argument. Any additional arguments provided to the function are appended to those provided to the . The wrapper is invoked with the binding of the created function.\n• (*): The value to wrap."
    },
    {
        "link": "https://naukri.com/code360/library/lodash-clonedeep-method",
        "document": ""
    },
    {
        "link": "https://tutorialspoint.com/lodash/lodash_clonedeep.htm",
        "document": "This method is like _.clone except that it recursively clones value.\n• None value (*) − The value to recursively clone.\n\nSave the above program in tester.js. Run the following command to execute this program."
    },
    {
        "link": "https://stackoverflow.com/questions/48710797/how-do-i-deep-clone-an-object-in-react",
        "document": "First let's clarify the difference between shallow and deep clone:\n\nA shallow clone is a clone that has its primitive properties cloned but his REFERENCE properties still reference the original.\n\nAllow me to clarify:\n\nNotice how changing the shallow copy's not primitive property's inner properties REFLECTED on the original object.\n\nSo why would we use shallow copy?\n• It is definitely FASTER.\n• It can be done in pure JS via 1 liner.\n\nWhen would you use shallow copy?\n• All of your object's properties are primitives\n• You are making a partial copy where all your copied properties are primitives\n• You don't care about the fate of the original (is there a reason to copy and not use that one instead?)\n\nOke, let's get into making a propper (deep) copy. A deep copy should obviously have the original object coped into the clone by value, not references. And this should persist as we drill deeper into the object. So if we got X levels deep nested object inside of the original's property it should still be a copy not a reference to the same thing in memory.\n\nWhat most people suggest is to abuse the JSON API. They think that turning an object into a string then back into an object via it will make a deep copy. Well, yes and NO. Let's attempt to do just that.\n\nExtend our original example with:\n\nSeems ok, right? WRONG! Take a look at what happened to the mrMethodLookAtMe and howBigIsUniverse properties that I sneaked in from the start :)\n\nOne gives back null which is definitely not Infinity and the other one is GONE. Well, that is no bueno.\n\nIn short: There are problems with \"smarter\" values like NaN or Infinity that get turned to null by JSON API. There are FURTHER problems if you use: methods, RegExps, Maps, Sets, Blobs, FileLists, ImageDatas, sparse Arrays, Typed Arrays as your original object's properties.\n\nWhy? Well this produces some of the nastiest to track bugs out there.. I have nightmares tracking the disappearing methods or type being turned to another (which passed someone's bad input parameter check but then couldn't produce a valid result) before Typescript became a thing.\n\nTime to wrap this up! So what is the correct answer?\n• You write your own implementation of a deep copy. I like you but please don't do this when we have a deadline to meet.\n• Use a deep cloning function provided to you by the library or framework you already use in the project.\n\nMany people still use jQuery. So in our example (please put import where it belongs, on top of the file):\n\nThis works, it makes a nice deep copy and is a one-liner. But we had to import the entire jQuery. Which is fine if it is already being used in project, but I tend to avoid it since it is over-bloated and has terribly inconsistent naming.\n\nBut what if my framework/library does not have a similar function?\n\nYou can use my personal SUPERSTAR among JS libraries (I am not involved in the project, just a big fan) - Lodash (or _ for friends).\n\nSo extend our example with (again, mind the position of import):\n\nIt is a simple oneliner, it works, it is fast.\n\nThis is pretty much it :)\n\nNow you know the difference between shallow and deep copy in JS. You realize JSON API abuse is just that, abuse and not a true solution. If you are using jQuery or AngularJS already you now know there is a solution already there for you. If not you can write your own or consider using lodash.\n\nThe entire example can be found here: codesandbox - entire example"
    }
]