[
    {
        "link": "https://wiki.visual-prolog.com/index.php?title=Visual_Prolog_7.5_New_Features",
        "document": "A major new feature of Visual Prolog 7.5 is the support for creating Web Services/Applications. See the Web Services tutorial for details.\n• if-then-else expression (in addition to the existing if-then-else statement)\n• The condition in an if-then-else now contains an implicit cut, and thus allows non-deterministic condition\n• Improved garbage collection: Typed allocation of objects reduces the possibility of false pointers\n• New attribute inline size for inlining byte sequences in structs\n• New hasDomain function, in addition to the existing hasDomain predicate\n• Warning for superfluous static initialization of an object fact if this fact is also initialized in all constructors (the corresponding warning is switched off by the default)\n• New packages scannerSupport and cursorScannerSupport for writing scanners in Visual Prolog\n• New package service for creating services in Visual Prolog\n• stream property for robust writing of illformed data that contains null-pointers\n• New package json for JSON representation, parsing and writing\n• New packages for JSON-RPC service support: standalone HTTP/HTTPS and/or ISAPI integration into Microsoft Internet Informantion Services, IIS (jsonRpc, jsonRpcService, ...)\n• New package watchDirectory (pfc\\communications) for monitoring directory changes\n• New packages for XML parsing/writing according to XSD definition (xmlSupport, fromXmlDomSupport and toXmlDomSupport)\n• GDI+ support for multi image icons in the icon class (utilized by the ribbonControl).\n\nVip is a directory (Commercial Edition only) that provides access to certain internal tools and structures, here among:\n• SDI template: uses ribbon and new status bar\n• The possibility for adding a resorce entity (dlg, or class, etc.) without creating a package\n\nBuild 7501 mainly contains bug fixes as listed below. But the commercial edition also contains an LALR Parser Generator.\n• Error on retractAll because of invalid code generation (registers management)\n• Must-unify leads to access violation when raising proper runtime error (type library passed to runtime function does not correspond to a term)\n• Incorrect list element allocation if it has type like\n• Recycling bug for open-statements which can be resolved both to a class declaration and interface definition\n• Access violation in example (incorrect type library for allocation)\n• COM: Add comDispInterface (COM exception: Member not found)\n• Exception 'Single fact 'oleInPlaceObject_fact' from internal database 'activeXcontrol::activeXcontrol@objectDB' has no value'\n• Project Settings\\Version: Change description does not trigger new resource compilation\n• Changing an IDE variable without opened project gives an exception\n• Too long effect of \"Apply this action to subsequent files\" flag\n• Tooltip should use proper brackets for generic argument: {@T} instead of (@T)\n• IDE doesn't create .bro file with new console without manifest\n• ChainDB 64bit: Memory overriding (not-aligned arrays of internal structures that contain pointers)\n• Solution manager: clicking vipsln files opens the solution manager, but the solution is not loaded\n\nBuild 7502 contains bug fixes as listed below.\n• Wrong result of sizeOf/1-> predicate for some integral types like core::integer8\n• Wrong handling of NULL fields in 64 bit ODBC (gives \"string right truncation\" error)."
    },
    {
        "link": "https://wiki.visual-prolog.com/index.php?title=Language_Reference/Predicates",
        "document": "A predicates section declares a set of object or class predicates in the current scope.\n\nThe keyword class can be used only inside class implementations, since:\n• predicates declared in an interface are always object predicates and\n• predicates declared in a class declaration are always class predicates.\n\nThe predicate declaration is used to declare the predicate in scopes in which the predicate declaration can be seen. When predicates are declared in an interface definition, this means that objects of the corresponding type must support these predicates. When predicates are declared in a class declaration, this means that the class publicly provides the declared predicates. And if predicates are declared in a class implementation, this means that the predicates are available locally. In all cases a corresponding definitions of the predicates must exist.\n\nHere PredicateDomainName is the name of a predicate domain declared in a domains section.\n\nOnly class predicates can have link names. If the link name is not stated then a link name is derived from the predicate name, the way this name is derived depends on the calling convention.\n\nA predicate that returns a value is called a function, whereas a predicate that does not return a value is sometimes called an ordinary predicate, to stress that it is not a function.\n\nPredicate domains can have Ellipsis argument as the last FormalArgument in the FormalArgument-comma-sep-list.\n\nPredicate domains can have an AnonymousIdentifier as a formal argument type to specify that the argument can be of any type.\n\nThe specified predicate mode applies for each member of a flow pattern list following it.\n\nPredicate modes can be described by the following sets:\n\nIf Fail is in the set it means that the predicate can fail. If succeed is in the set it means that the predicate can succeed. If BacktrackPoint is in the set it means that the predicate can return with an active backtrack point in it.\n\nIf such a set, say failure, is a subset of another set, say nondeterm, then we say that the mode is stronger than the other, i.e. failure is stronger than nondeterm.\n\n\n\n A predicate domain actually contain all predicates (with correct type and flow), which have the mode specified or a stronger mode.\n\nIt is illegal to state a predicate mode for constructors, they always have the procedure mode.\n\nThe flow pattern defines the input/output direction of the arguments, which in combination with functor domains can be structures with parts of a single argument being input and other parts of the same argument being output.\n\nA flow pattern consists of a sequence of flows, each flow corresponds to an argument (fist flow to first argument, etc).\n\nEllipsis flow must match an ellipsis argument and can therefore be only the last flow in the flow pattern.\n\nA functor flow FunctorFlow states a functor and flows of each of the components of that flow. The functor must of course be in the domain of the corresponding argument.\n\nList flows are just like functor flows, but with the same syntactic sugaring as the list domain.\n\nWhen declaring a predicate the flow can be omitted. Inside an implementation (i.e. for a local predicate) the needed flows are derived from the usages of the predicate. Inside an interface or a class declaration (i.e. for a public predicate) omitting flows means that all arguments are input.\n\nThe special flow pattern anyflow can be stated only in declarations of local predicates (i.e. in predicate declarations inside the implementation of a class). It means that the exact flow pattern(s) will be evaluated during the compilation.\n\nThe calling convention determines how arguments, etc. are passed to the predicate, it also determines how the link name is derived from a predicate name.\n\nIf a calling convention is not stated, then the prolog convention is assumed. The prolog calling convention is the standard convention used for Prolog predicates.\n\nThe calling convention c follows the C/C++ standard calling convention. The link name of a predicate is created from the predicate name by adding a leading underscore (_).\n\nThe calling convention thiscall follows the C++ standard calling convention for virtual functions. This calling convention uses the c link name strategy but sometimes it may use the different argument and stack handling rules. Calling convention thiscall can be applied to the object predicates only.\n\nThe calling convention stdcall uses the c link name strategy but it uses the different argument and stack handling rules. The following table shows the implementation of stdcall calling convention.\n\n\n\n The calling convention apicall uses the same argument and stack handling rules as stdcall, but for convenience to call MS Windows API functions apicall uses the naming conventions that are used by most MS Windows API functions. According to apicall naming conventions the link name of a predicate is constructed as follows:\n• a leading underscore ( ) is prefixed to the predicate name;\n• the predicate name in which the first letter is changed in to a capital letter;\n• the ' ', the ' ' or nothing is suffixed, if the arguments and the return type indicate an ANSI, Unicode or neutral predicate, respectively;\n• on the 32bit platform (x86) the sign @ together with the number of bytes in the argument list is suffixed. But this is not used on the 64bit platform.\n\nIf apicall is used together with the \"as\" construction the name stated in the \"as\" construction is decorated in the same manner.\n\napicall can only be used directly in a predicate declaration, not in a predicate domain definition. In predicate domain definitions stdcall, must be used instead. A predicate declared with apicall calling convention cannot have clauses and it also cannot be resolved externally without explicit DLL name.\n\nThe following table compares implementations of c, apicall, and stdcall calling conventions (the prolog calling convention has the special implementation, which is not discussed here):\n\nVisual Prolog notion of predicate domains covers both class and object members. Class members are handled straight forward, but the handling of object members requires attention. The invocation of an object predicate will get \"back\" in the context of the object to which the member belongs.\n\nSometimes a name must have the _...@N decoration, but the default from apicall is wrong. In such cases decorated, decoratedA and decoratedW can be used to control the decoration:\n\nIn this case the link name will be \"_MyPredicate@4\", where apicall would make it \"_MyPredicateW@4\".\n\nIn this case the link name will be \"_MyPredicateA@4\", where apicall would make it \"_MyPredicate@4\".\n\nIn this case the link name will be \"_MyPredicateW@4\", where apicall would make it \"_MyPredicate@4\".\n\nAll of them change the start of the name from xxxx to _Xxxx and all of them put @N behind. The first never uses a suffix; the second always uses A and the third always uses W. This means that the programmer is responsible for deciding which suffix is needed. But he needs not to worry about calculating argument size and initial \"_X\".\n\nA constructors section declares a set of constructors. The constructors belong to the scope in which the constructors section occurs (see class declaration and class implementation).\n\nConstructor sections can only occur in declarations and implementations of classes that construct objects.\n\nA constructor actually has two associated predicates:\n• An object predicate, which is used when initializing inherited objects.\n\nAn associated constructor object predicate is used to perform an object initialization. This predicate can only be called from the constructor in the class itself and from a constructor in a class that inherits from the class (i.e. base class initialization).\n\nIt is illegal to state a predicate mode for constructors, constructors always have procedure mode.\n\nAn interface can support a subset of another interface by stating the predicates in a predicates from section. The predicates from section names the interface and all supported predicates. The predicates are stated by name or by name and arity.\n\nIf an interface supports a subset of another interface it is neither subtype or super-type related to the other interface.\n\nThe important thing about the predicates from section is that the mentioned predicates retain their origin interface. Therefore:\n• there will be no support conflict with any predicates from the origin interface;\n• they can be inherited as the predicates from the origin interface.\n\nPredicatesFromInterface can only be used in interface definitions.\n\nExtension predicates is a syntactic sugaring, which makes it possible use class predicates as if they were object predicates.\n\nExtension predicates can also be used to give give a more natural code flow for binary operations:\n\nAn extension predicate is a class predicate whose first argument is marked with the attribute [this].\n\nExtension predicates can also be declared for non-object types.\n\nIt is illegal to declare an extension predicate on an interface type if that extension predicate is conflicting with a predicate that exist in the interface itself.\n\nExtension predicates follows the visibility rules of class predicates.\n\nExtension predicates can be qualified with namespace and class:\n\nSeveral suitable extension predicates may be visible in a certain context, and thus cause ambiguity. Qualification can resolve such ambiguity.\n\nA predicate that takes N arguments are said to be N-ary, or to have arity N. Predicates with different arity are always different predicates, even if they have the same name.\n\nIn most situations the arity of a predicate is obvious from the context in which the predicate is mentioned. But in, for example, predicatesFromInterface sections and resolve qualifications the arity is not obvious.\n\nIn order to distinguish between different arities of predicates in predicates from sections and in resolve qualifications, predicate names can (optionally) be stated with arity.\n\nThe following arities are possible:\n• Name/N meaning an ordinary predicate (i.e. not a function) Name of arity N.\n• Name/N... meaning an ordinary predicate Name with N arguments followed by an argument (i.e. a varying number of arguments). ( \"...\" can be used in predicate and predicate domain declarations as the last formal argument. In this case it means that the declared predicate (predicate domain) can have a variable number of arguments. Ellipsis flow must match an ellipsis argument and can therefore be only the last flow in the flow pattern.)\n• Name/N...-> meaning a function Name with N arguments followed by an ellipsis argument.\n\nIn Name/0... and Name/0...->. the zero is optional and can thus be written as Name/... and Name/...->, respectively.\n\nThese attributes are specifically related to predicates\n• in, out and byVal attributes"
    },
    {
        "link": "https://academia.edu/8999914/A_Beginners_Guide_to_Visual_Prolog",
        "document": "Demonstrating Prolog Usage: Building a Simple Game Program To demonstrate the use of Prolog and how programming in Prolog is easy and efficient, this paper describe an implementation of the game booby-trap, a game similar to Minesweeper found on most personal computers with windows.\n\nA An Introduction to Prolog Prolog was designed in the 1970s by Alain Colmerauer and a team of researchers with the idea -new at that time -that it was possible to use logic to represent knowledge and to write programs. More precisely, Prolog uses a subset of predicate logic and draws its structure from theoretical works of earlier logicians such as Herbrand (1930) and Robinson (1965) on the automation of theorem proving.\n\nLearn Prolog Now! 1. To give some simple examples of Prolog programs. This will introduce us to the three basic constructs in Prolog: facts, rules, and queries. It will also introduce us to a number of other themes, like the role of logic in Prolog, and the idea of performing matching with the aid of variables."
    },
    {
        "link": "https://scribd.com/document/73010884/Visual-Prolog-7",
        "document": "This book started as a personal project, and it was a huge success. The author received many suggestions on how to improve the text, or the code. Without the help of many people, this book would not have been written."
    },
    {
        "link": "https://eu.swi-prolog.org/packages/xpce/UserGuide/sec-7.5.html",
        "document": "The basic type-syntax is described in section 3.2.1 of this manual. Types are first-class reusable objects that are created from the type-declaration in arguments and variables. The conversion from the textual representation to the object is performed by itself (together with the resource syntax, one of the few places where defines syntax). All types can be specified as Prolog quoted atoms. For example:\n\nFor most cases however, this is not necessary. If the type is not an atom, the class-compiler will convert the Prolog term into an atom suitable for 's type system. Hence, will translate to the atom '[point]', which is interpreted by as ``an instance of class point or the constant @default''. The atoms and are defined as postfix operators, while is an infix operator. This makes ` ' a valid notation for ``any number of anything'' (see section 7.5.2 below) and ` ' a valid expression for ``an integer in the range 0 to 5 (including the boundaries).\n\nAlso, is a valid description for ``an instance of box or circle or the constant @default. Note however that is not valid Prolog syntax and should be written as . Whenever you are in doubt, use quotes to prevent surprises.\n\nMethods such as `chain initialise' and `string format' handle an arbitrary number of arguments. The argument declaration for such a method first defines a number (possibly zero) of `normal' arguments. The last argument is postfixed with ` '. The arguments assigned to the `vararg' type are passed in a Prolog list.\n\nBelow is a refinement of `label report' that will colour the label depending on the nature of the message. The report method takes two obligatory arguments, the kind of the report and a format string, as well as an undefined number of arguments required by the format specification.\n\nprovides two alternatives to multiple inheritance. Delegation is discussed in section C.4. See also the directive delegate_to/1 for user-defined class definitions. The template mechanism is much closer to real multiple inheritance. A template is a named partial class-definition that may be included in other classes. It behaves as if the source-code of the template definition was literally included at the place of the use_class_template/1 directive.\n\nIn fact, the class-attributes (variables, method objects) are copied, while the implementation (the Prolog clauses) are shared between multiple references to the same template.\n\nTemplates itself form a hierarchy below class template, which is an immediate subclass of object. Including a template will make all variables and methods defined between the template class and class template available to the receiving class.\n\nWe illustrate the example below, making both editable boxes as editable ellipses. First we define the template class.\n\nThe main program can now be defined as:\n\nNote that use_class_template/1 imports the definitions from the template in the current class. Thus, the following will not extend further on the `editable_graphical event' definition, but instead replace this definition. Of course it is allowed to subclass the definition of editable_box above and further refine the event method in the subclass.\n\nThe rolog class-compilation is defined using the Prolog preprocessing capabilities of term_expansion/2. While the class is compiled, Prolog gathers the expressions belonging to the class. The expansion of emits the actual code for the class.\n\nThe method implementation is realised by the predicates pce_principal:send_implementation/3 and pce_principal:get_implementation/4. that take the form:\n\nThe remainder of the class specification is translated into a number of Prolog clauses describing the class. No class is created. If generates an exception, it will scan for the class-description in the Prolog database and create the class instance. No methods are associated with the new class. Instead, all method binding is again based on exception handling.\n\nModifications to the class beyond what is provided by the preprocessing facilities (for example changing the `variable clone_style') cannot be made by sending messages to the class inside the class definition body as this would address the not-yet-existing class. Instead, they should be embedded in the pce_class_directive/1 directive. . The Goal argument of pce_class_directive/1 should refer to the class using the var object @class. When the class is realised the exception system will bind @class to the current class while running Goal. Goal is called from the Prolog module in which the class is defined.\n\nThe main reason for the above approach is to exploit the runtime-generation facilities of the hosting Prolog system to create fast-starting portable and (depending on the hosting Prolog's capabilities) stand-alone executables.\n\nOne of the consequences of the chosen approach is that the class-building directives are not accessible as predicates. There is no preprocessing support for the dynamic creation of classes and the programmer should thus fall back to raw manipulation of the class objects."
    },
    {
        "link": "https://stackoverflow.com/questions/75502875/what-are-some-best-practices-for-writing-prolog-predicates-so-that-it-works-in-d",
        "document": "Before answering your question, let's clarify what 'not working' may mean. It may mean that you may get an answer, but that answer is incorrect, like when would be the correct answer. Or it may mean that you get no answer, like a loop, instead. In traditional programming languages both are seen as undesirable and there is no clear distinction between those. In both cases such a program would be considered incorrect. But Prolog is a bit different here. The reason is that we have real variables at runtime. So we may have a list with two identical elements, say which describes all possible lists with two identical elements. That is, we are describing here infinitely many such lists. Sometimes, these infinities can be described compactly, and sometimes this is not possible.\n\nSo infinity and its less popular companion non-termination are lurking around in Prolog right from the very first little programs on. We have to deal with it up front. Think of\n\nLooping behavior may be observed by getting a resource error, or just by a never ending query. In this particular case, all current Prolog systems will produce a resource error which causes some of them to abort completely.\n\nWhat could be worse? Plenty! Think of\n\nMastery of non-termination is absolutely essential in Prolog. In your case, the failure-slice\n\npinpoints you to the very problem. The second argument has no influence on termination whatsoever! That is, all queries with a known length will terminate as good or bad as the same queries with a variable for the length. And thus only the first argument influences termination. Thus only lists of known length (and terms like ) will terminate. We need to modify something in the visible part of the program. Otherwise the problem will persist.\n\nNow to fix the problem, we have several options\n\nIn many situations, the best is to stick to the pure, monotonic subset of Prolog and thus simply add a corresponding goal in front.\n\nSo in this new version, the second argument now influences termination just as the first one. (There are more efficient ways to write this even in the pure, monotonic subset.)\n\nAnother way to improve termination may be coroutining, like or . In this particular case this would be insufficient. But sometimes it can do wonders. The downside is that you may now get answers that are not solutions.\n\nAgain another way is to rule out certain problematic cases by means of instantiation errors. Prefer and over manual tests.\n\nThe other way is extremely difficult, as it requires to handle all different kinds of instantiations separately. Avoid this, unless you want to delve into systems' programming. Many programmers think they can handle this, only to leave out a case or two. You have seen the efficient code for Scryer. Let's leave it at looking at it.\n\nSo why are these things so complex in Prolog? Well, these problems exist equally in traditional programming languages but due to their less expressive formalism, you need to write much more code (like implementing a Prolog interpreter) to encounter the same problems. Often (in particular in the context of Hoare logic) one distinguishes between partial and total correctness. And the problem behind is even more profound, since there are problems that are only semi-decidable. That is, where non-termination (or any other form of non-answer) is the only possible answer.\n\n2 For SWI say instead"
    },
    {
        "link": "https://wiki.visual-prolog.com/index.php?title=Language_Reference/Predicates",
        "document": "A predicates section declares a set of object or class predicates in the current scope.\n\nThe keyword class can be used only inside class implementations, since:\n• predicates declared in an interface are always object predicates and\n• predicates declared in a class declaration are always class predicates.\n\nThe predicate declaration is used to declare the predicate in scopes in which the predicate declaration can be seen. When predicates are declared in an interface definition, this means that objects of the corresponding type must support these predicates. When predicates are declared in a class declaration, this means that the class publicly provides the declared predicates. And if predicates are declared in a class implementation, this means that the predicates are available locally. In all cases a corresponding definitions of the predicates must exist.\n\nHere PredicateDomainName is the name of a predicate domain declared in a domains section.\n\nOnly class predicates can have link names. If the link name is not stated then a link name is derived from the predicate name, the way this name is derived depends on the calling convention.\n\nA predicate that returns a value is called a function, whereas a predicate that does not return a value is sometimes called an ordinary predicate, to stress that it is not a function.\n\nPredicate domains can have Ellipsis argument as the last FormalArgument in the FormalArgument-comma-sep-list.\n\nPredicate domains can have an AnonymousIdentifier as a formal argument type to specify that the argument can be of any type.\n\nThe specified predicate mode applies for each member of a flow pattern list following it.\n\nPredicate modes can be described by the following sets:\n\nIf Fail is in the set it means that the predicate can fail. If succeed is in the set it means that the predicate can succeed. If BacktrackPoint is in the set it means that the predicate can return with an active backtrack point in it.\n\nIf such a set, say failure, is a subset of another set, say nondeterm, then we say that the mode is stronger than the other, i.e. failure is stronger than nondeterm.\n\n\n\n A predicate domain actually contain all predicates (with correct type and flow), which have the mode specified or a stronger mode.\n\nIt is illegal to state a predicate mode for constructors, they always have the procedure mode.\n\nThe flow pattern defines the input/output direction of the arguments, which in combination with functor domains can be structures with parts of a single argument being input and other parts of the same argument being output.\n\nA flow pattern consists of a sequence of flows, each flow corresponds to an argument (fist flow to first argument, etc).\n\nEllipsis flow must match an ellipsis argument and can therefore be only the last flow in the flow pattern.\n\nA functor flow FunctorFlow states a functor and flows of each of the components of that flow. The functor must of course be in the domain of the corresponding argument.\n\nList flows are just like functor flows, but with the same syntactic sugaring as the list domain.\n\nWhen declaring a predicate the flow can be omitted. Inside an implementation (i.e. for a local predicate) the needed flows are derived from the usages of the predicate. Inside an interface or a class declaration (i.e. for a public predicate) omitting flows means that all arguments are input.\n\nThe special flow pattern anyflow can be stated only in declarations of local predicates (i.e. in predicate declarations inside the implementation of a class). It means that the exact flow pattern(s) will be evaluated during the compilation.\n\nThe calling convention determines how arguments, etc. are passed to the predicate, it also determines how the link name is derived from a predicate name.\n\nIf a calling convention is not stated, then the prolog convention is assumed. The prolog calling convention is the standard convention used for Prolog predicates.\n\nThe calling convention c follows the C/C++ standard calling convention. The link name of a predicate is created from the predicate name by adding a leading underscore (_).\n\nThe calling convention thiscall follows the C++ standard calling convention for virtual functions. This calling convention uses the c link name strategy but sometimes it may use the different argument and stack handling rules. Calling convention thiscall can be applied to the object predicates only.\n\nThe calling convention stdcall uses the c link name strategy but it uses the different argument and stack handling rules. The following table shows the implementation of stdcall calling convention.\n\n\n\n The calling convention apicall uses the same argument and stack handling rules as stdcall, but for convenience to call MS Windows API functions apicall uses the naming conventions that are used by most MS Windows API functions. According to apicall naming conventions the link name of a predicate is constructed as follows:\n• a leading underscore ( ) is prefixed to the predicate name;\n• the predicate name in which the first letter is changed in to a capital letter;\n• the ' ', the ' ' or nothing is suffixed, if the arguments and the return type indicate an ANSI, Unicode or neutral predicate, respectively;\n• on the 32bit platform (x86) the sign @ together with the number of bytes in the argument list is suffixed. But this is not used on the 64bit platform.\n\nIf apicall is used together with the \"as\" construction the name stated in the \"as\" construction is decorated in the same manner.\n\napicall can only be used directly in a predicate declaration, not in a predicate domain definition. In predicate domain definitions stdcall, must be used instead. A predicate declared with apicall calling convention cannot have clauses and it also cannot be resolved externally without explicit DLL name.\n\nThe following table compares implementations of c, apicall, and stdcall calling conventions (the prolog calling convention has the special implementation, which is not discussed here):\n\nVisual Prolog notion of predicate domains covers both class and object members. Class members are handled straight forward, but the handling of object members requires attention. The invocation of an object predicate will get \"back\" in the context of the object to which the member belongs.\n\nSometimes a name must have the _...@N decoration, but the default from apicall is wrong. In such cases decorated, decoratedA and decoratedW can be used to control the decoration:\n\nIn this case the link name will be \"_MyPredicate@4\", where apicall would make it \"_MyPredicateW@4\".\n\nIn this case the link name will be \"_MyPredicateA@4\", where apicall would make it \"_MyPredicate@4\".\n\nIn this case the link name will be \"_MyPredicateW@4\", where apicall would make it \"_MyPredicate@4\".\n\nAll of them change the start of the name from xxxx to _Xxxx and all of them put @N behind. The first never uses a suffix; the second always uses A and the third always uses W. This means that the programmer is responsible for deciding which suffix is needed. But he needs not to worry about calculating argument size and initial \"_X\".\n\nA constructors section declares a set of constructors. The constructors belong to the scope in which the constructors section occurs (see class declaration and class implementation).\n\nConstructor sections can only occur in declarations and implementations of classes that construct objects.\n\nA constructor actually has two associated predicates:\n• An object predicate, which is used when initializing inherited objects.\n\nAn associated constructor object predicate is used to perform an object initialization. This predicate can only be called from the constructor in the class itself and from a constructor in a class that inherits from the class (i.e. base class initialization).\n\nIt is illegal to state a predicate mode for constructors, constructors always have procedure mode.\n\nAn interface can support a subset of another interface by stating the predicates in a predicates from section. The predicates from section names the interface and all supported predicates. The predicates are stated by name or by name and arity.\n\nIf an interface supports a subset of another interface it is neither subtype or super-type related to the other interface.\n\nThe important thing about the predicates from section is that the mentioned predicates retain their origin interface. Therefore:\n• there will be no support conflict with any predicates from the origin interface;\n• they can be inherited as the predicates from the origin interface.\n\nPredicatesFromInterface can only be used in interface definitions.\n\nExtension predicates is a syntactic sugaring, which makes it possible use class predicates as if they were object predicates.\n\nExtension predicates can also be used to give give a more natural code flow for binary operations:\n\nAn extension predicate is a class predicate whose first argument is marked with the attribute [this].\n\nExtension predicates can also be declared for non-object types.\n\nIt is illegal to declare an extension predicate on an interface type if that extension predicate is conflicting with a predicate that exist in the interface itself.\n\nExtension predicates follows the visibility rules of class predicates.\n\nExtension predicates can be qualified with namespace and class:\n\nSeveral suitable extension predicates may be visible in a certain context, and thus cause ambiguity. Qualification can resolve such ambiguity.\n\nA predicate that takes N arguments are said to be N-ary, or to have arity N. Predicates with different arity are always different predicates, even if they have the same name.\n\nIn most situations the arity of a predicate is obvious from the context in which the predicate is mentioned. But in, for example, predicatesFromInterface sections and resolve qualifications the arity is not obvious.\n\nIn order to distinguish between different arities of predicates in predicates from sections and in resolve qualifications, predicate names can (optionally) be stated with arity.\n\nThe following arities are possible:\n• Name/N meaning an ordinary predicate (i.e. not a function) Name of arity N.\n• Name/N... meaning an ordinary predicate Name with N arguments followed by an argument (i.e. a varying number of arguments). ( \"...\" can be used in predicate and predicate domain declarations as the last formal argument. In this case it means that the declared predicate (predicate domain) can have a variable number of arguments. Ellipsis flow must match an ellipsis argument and can therefore be only the last flow in the flow pattern.)\n• Name/N...-> meaning a function Name with N arguments followed by an ellipsis argument.\n\nIn Name/0... and Name/0...->. the zero is optional and can thus be written as Name/... and Name/...->, respectively.\n\nThese attributes are specifically related to predicates\n• in, out and byVal attributes"
    },
    {
        "link": "https://wiki.visual-prolog.com/index.php?title=Language_Reference_Book",
        "document": "Visual Prolog types are divided into object types and value types. Objects have mutable state, whereas values are immutable.\n\nThe value types include numerical types, strings and character types and compound domains (also known as algebraic data types). Simpler forms of compound domains are structure and enumeration types, whereas more complex forms represents tree structures.\n\nTypes are organized in a subtype hierarchy. Subtypes are used to introduce subsumption-polymorphism: Any context that expects a value of some type will equally well accept a value of any subtype. Or if we turn it around, we can say, that values of a certain type are automatically converted to any super-type where needed and can thus be used as having the super-type without explicit type conversion.\n\nSubtypes can be derived from any value type, except from algebraic data types. Types derived from algebraic data types are synonym types rather than subtypes, i.e. they are the same type rather than a subtype.\n\nThe notion of subtypes relates closely to the notion of subsets. But it is important to notice that even though a type is \"mathematically\" a subset of another type it need not be a subtype. A type is only subtype of another type if it is declared to be so.\n\nt1 is an integral type whose values are the integers from 1 to 17 (both inclusive). Likewise, t2 contains the values from 5 to 13. So t2 is a subset of t1, but t2 is not a subtype of t1. On the other hand, t3 (which contains the same values as t2) is a subtype of t1, because it is declared to be so.\n\nThe language contains a few implicit subtype relations, but otherwise subtype relations are explicitly stated in type definitions.\n\nObject types are organized in a subtype hierarchy rooted in the predefined object type object, i.e. any object type is a subtype of object. Object subtypes are defined by means of stating that one interface supports another. If an object has an interface/object type that supports a certain other interface, then the object also has that type and can without further interference be used as such an object.\n\nSee also: Universal and Root Types\n\nThe description in this section is not supposed to be an introduction to classes; it is intended as a clarification of the class notions in Visual Prolog. The reader is expected to be familiar with common class notions. The description is purely conceptual in the sense that it does not refer to any syntax, implementation, etc. Moreover, this description does not consider any operational or programmatic aspects. While the reasons for introducing classes, objects, etc are mostly of programmatic nature, we find it valuable to describe the underlying concepts without reference to these programmatic reasons.\n\nThe class concept of Visual Prolog is based on the following three semantic entities:\n\nAn object is set of named object member predicates and a set of supported interfaces. Objects actually also have a state, but this state can only be changed and observed through the member predicates. We say that the state is encapsulated in the object.\n\nHere encapsulation means the ability of an object to hide its internal data and methods, making only the intended parts of the object programmatically accessible. The importance of encapsulation and modularity is well known. Encapsulation helps building more structured and readable programs, because objects are treated like black boxes. Look at a complex problem, find a part, which you can declare and describe. Encapsulate it into an object, construct an interface and continue so, until you have declared all the sub-problems. When you have encapsulated the objects of the problem, and ensured, that they work correctly, you can abstract from them.\n\nAn interface is an object type. It has a name and defines a set of named object predicates.\n\nInterfaces are structured in a supports hierarchy (the structure is a semi-lattice rooted in the interface object). If an object has a type denoted by an interface, then it also has the type of any supported interfaces. Therefore, the supports hierarchy is also a type hierarchy. An interface is a subtype of all its supported interfaces. We also say that the object supports the interface. If the interface is named X, then we say that the object is an X, or an X object.\n\nA class is a named object factory; it can create objects corresponding to a certain interface. Any object is created by a class, if an object was created by the class, which uses the interface C to construct objects then we call it a \"C object\".\n\nAll objects that are constructed by a certain class share the same definition of the object member predicates, but each object has its own state. Thus, the object member predicates is actually part of the class, whereas the state of the object is part of the object itself.\n\nA class also contains another set of named predicates and an encapsulated state, known as the class members and class state, respectively. The class members and the class state exist on a per class basis, whereas the object members and object state exist on a per object basis. The class state can be accessed both by class members and by object members.\n\nNotice! The set of object member predicates that a class defines is the union of the predicates declared (transitively) in the interfaces of that class. More specifically this means that, if the same predicate is declared in two different interfaces then the class will only provide one definition of that predicate. So the class only sounds if that makes sense, i.e. if the intended semantics of these two inherited predicates are the same.\n\nNotice that interface support must be specified explicitly. The fact that some class provides the predicates corresponding to some interface does not imply that the class supports the interface.\n\nIn fact a class need not be able to manufacture objects at all. Such class may have only class members and the class state. And therefore, such class can be considered to be a module rather than a class.\n\nEvery object is unique: objects have a changeable state and since the state of the objects can be observed by means of their member predicates an object is only identical to itself. I.e. even if the states of two objects are identical, the objects are not identical, because we can change the state of one object without changing the state of the other object.\n\nWe never have direct access to an object state, we always access an object state by means of a reference to the object and while an object is only identical to itself, we can have many references to the same object. Thus, the same object can be accessed through many different references.\n\nClasses and interfaces are also unique; they are identified by their names. Two interfaces or classes cannot have the same name in the same program. A class and an interface can only have the same name if the class constructs objects of that interface.\n\nThe essence is that structural equality does not imply identity for objects, classes nor interfaces.\n\nWhere the previous section described objects, classes, and interfaces in terms of their external behavior, this section will extend this description with internal issues. These internal issues have more programmatically nature; they are concerned with splitting of classes onto the declaration part and the implementation part.\n\nFrom a programmatic point of view, classes are the central item: the code is contained in the classes.\n\nInterfaces mainly have static importance. In fact, interfaces only exist in the textual representation of a program; there is no (direct) runtime representation of an interface.\n\nObjects, on the other hand, have mainly dynamic importance. Objects are not directly visible in the program; they do not exist until the program actually runs.\n\nA class consists of a declaration and an implementation. The declaration declares the public accessible parts of the class and the objects it generates. The implementation on the other hand defines the entities declared in the class declaration. The basic implementation of predicates is of course clauses, but predicates can also be defined by means of inheritance, or resolved to external libraries.\n\nA class declaration in Visual Prolog is purely declarative. It only states which entities you can access: not how or where they are implemented.\n\nA class implementation can declare and define further entities (i.e. domains, predicates, etc), which are only visible inside the class itself. I.e. they are private.\n\nThe state of an object is stored in the object as its facts. These facts are declared as normal facts (database) sections in the implementation of the class. Facts are local to each object (like other object entities), whereas class facts are shared among all objects of the class.\n\nFacts can only be declared in the implementation of a class and, therefore, cannot be accessed (directly) from outside the class.\n\nThe implementation of a class can also declare that it supports more interfaces than mentioned in the declaration. This information is, however, only visible in the implementation itself and is, therefore, private.\n\nIn Visual Prolog code inheritance only takes place in the implementation of a class. Visual Prolog has multiple inheritance. You inherit from a class by mentioning the class in a special inherits section of the implementation. The classes you inherit from are called parent classes or super-classes. Child-class or sub-class is the dual to parent class, we also say that the child classes inherit from the parent classes. A child class can only access its parent classes through its public interface, i.e. it does not receive any extra privileges than anybody else that use the parent class.\n\nAll names (identifiers) in Visual Prolog are syntactically divided into two major groups:\n• Variable names (starting with an uppercase letter or an underscore)\n\nConstant names (identifiers) are divided into the following categories:\n• Names without parentheses (i.e. constants, fact variables of non-function type and nullary-functors).\n• Value returning names of arity N (i.e. functions, functors and fact-variables of function type).\n• Non-value-returning names of arity N (i.e. predicates, facts and fact variables of predicate type).\n\nVisual Prolog demands that names do not conflict at the point of declaration, because then it would be impossible to solve the conflict at point of usage. Declarations can only conflict if they are in the same scope, because qualification with scope can be used to solve the conflict. A name in one category can never be in conflict with a name in another category, but as we shall see a single declaration might place a name in several categories.\n\nThe basic units of code organization accepted in Visual Prolog are packages. We use packages in Visual Prolog to organize and structuring things. The use of packages ensures homogeneity in structuring principles among different projects. Packages define the standard for tool structuring and ease sharing source code among projects.\n\nThe package is a collection of several grouped together interfaces and classes. The package provides some common name to all these interfaces and classes. Each declaration or implementation of each interface or class from a package is placed in a separate file. Each filename (of these files) coincides with the name of a class or an interface that is declared or implemented in this file. All package files are stored in the same separate package directory. (If a package contains sub-packages, then they are placed in subdirectories of the package directory.)\n\nThe concept of packages is used for grouping together several linked interfaces and classes. Packages can play a role of some class library. Packages can be used in your program instead of direct placing all used interfaces and classes into your program.\n\nThe accepted in Visual Prolog structure of packages and how packages should be included into projects are described in the VDE part of this help. (See Creating a Package in Creating New Project Items.)\n\nMost of the scoping rules are already mentioned above. This section will complete the picture.\n\nAn interface definition, a class declaration and a class implementation are scopes (scopes cannot be nested). An implementation (privately) extends the scope of the corresponding class declaration. The visibility is the same everywhere in a scope. This does especially mean that no matter where in a scope something is declared, it is visible in the whole scope.\n\nPublic names from supported interfaces and super-classes are directly (i.e. without qualification) available inside a scope, if it is unambiguous where they come from. It is illegal to use a name whose origin is ambiguous. All ambiguities in predicate calls can be removed by qualifying the predicate name with the class name (e.g. cc::p).\n\nThis qualification is also used to qualify calls of object member predicates of super-classes on the current object.\n\nVisual Prolog has the following shadowing hierarchy:\n\nOpened scopes have the same status as super-classes, so in the sequel we will just say super-classes.\n\nThe hierarchy means that a local declaration will shadow a super-class declaration. But there is no shadowing between super-classes; all super-classes have equal preference. If two or more super classes contain conflicting declarations then these declarations can only be accessed by means of qualification.\n\nThe Visual Prolog Compiler is applied to a source file. This source file may include other source files, which are (conceptually) inserted into the original source file to constitute one compilation unit. The compilation of a compilation unit is done in two conceptual steps:\n• first the input is transformed into a sequence of tokens;\n• and then these tokens are syntactically analyzed and transformed into executable code.\n\nThe lexical analysis of the program will break the compilation unit CompilationUnit into a list of input elements InputElement\n\nOnly tokens are significant to the subsequent syntax analysis.\n\nA Visual Prolog comment is written in one of the following ways:\n• The (slash, asterisk) characters, followed by any sequence of characters (including new lines), terminated by the (asterisk, slash) characters. These comments can be multi-lined. They can also be nested.\n• The (percent sign) character, followed by any sequence of characters. Comments that begin with character (percent sign) continue until the end of the line. Therefore, they are commonly called single-line comments.\n\nNotice the following comment example:\n\nHere Space is a space character, Tab is a tabulation character and NewLine is a new line character.\n\nA LowercaseIdentifier is a sequence of letters, digits, and underscores that starts with a small letter. An UppercaseIdentifier is a sequence of letters, digits, and underscores that starts either with a capital letter or with an underscore.\n\nKeywords are divided into major and minor keywords, this division is only cosmetic however, there is no formal difference between major and minor keywords. In the sequel we will however use different coloring for them.\n\nAll keywords except as and language are reserved words.\n\nend is always combined with another key word:\n\nPunctuation marks in Visual Prolog have syntactic and semantic meaning to the compiler, but do not specify by themselves an operation that yields a value. Some punctuation marks, either alone or in combinations, can also be Visual Prolog operators.\n\nOperators specify an evaluation to be performed on involved operands.\n• and are both binary and unary operators.\n• all other operators are binary.\n\nLiterals fall into following categories: integer, character, floating-point, string, binary and list.\n\nAn integral literal can belong to integer or unsigned domains and it should not exceed maximum and minimum integer or unsigned values.\n\nA real literal should not exceed maximum and minimum real values. Notice that any integral literal can also be used as a real value.\n\nCharacterValue can be any printable character or an escape sequence:\n• \\u , here should be exactly four 's representing the Unicode character corresponding to the digits.\n\nA string literal consists of one or more StringLiteralPart's, which are concatenated.\n\nThe first two forms (the ' and \" forms) uses escape sequences to express certain characters\n• \\u , here should be exactly four 's representing the Unicode character corresponding to the digits.\n\nIn single quoted strings it is optional to escape double quotes, and likewise it is optional to escape single quotes in double quoted strings.\n\nSingle quoted strings must contain at least two characters otherwise they will be assumed to be a character literal.\n\nThe @-literals can be used to avoid obscuring the string literals with escape characters. The literals starts with @ followed by some non-letter character AtOpenChar. And it terminates when the close character AtCloseChar is met. For most characters the close character is the same as the opening character, but for diverse paranthesis charactes the close character is the corresponding opposite paranthesis.\n\nFor all non-paranthesis opening character the close character is the same as the open character, for example @\" is closed by \".\n\nFor all @-strings it is the case the twice the closing character does not close the string, but means one occurence of the closing character in the string.\n\nElementValue should be any integral arithmetic expression (for example, constant), which should be calculated while compilation-time and be in the range from 0 till 255.\n\nA program consists of a number of compilation units. The compiler compiles each of these compilation units separately. The result of a compilation is an object file. These object files (and perhaps other files) are linked together to produce the project target. A program must contain exactly one goalSection, which is the entry point to the program.\n\nA compilation unit has to be self-contained in the sense that all referenced names have to be either declared or defined in the unit. Interface definitions and class declarations can be included in several compilation units (the definitions/declarations must be identical in all units where they are included), whereas class implementations (definitions) may only be defined in a single unit. Every declared item must also be defined in the project, but some items can be defined in libraries, meaning that they do not need a textual definition.\n\nA compilation unit (which is perhaps composed by using #include directives) is a sequence of compilation items.\n\nA compilation item is an interface, a class declaration, a class implementation, the goal section or it can be a conditional compilation item, which are described in Conditional Compilation.\n\nAn interface definition defines a named object type. Interfaces can support other interfaces. See Supports Qualification for further details.\n\nAll predicates declared in an interface are object members in objects of the interface type.\n\nAn interface is also a global scope, in which constants and domains can be defined. Thus constants and domains defined in an interface are not part of the type that the interface denotes (or of objects having this type).\n\nSuch domains and constants can be referenced from other scopes by qualification with the interface name: interfaceName::constant, or by using an open qualification. (See Open Qualification.)\n\nSee also Generic Interfaces and Classes and Monitors.\n\nThe InterfaceName in the end of the construction must (if present) be identical to the one in the beginning of the construction.\n\nThe ScopeQualifications must be of the kinds:\n\nThe Sections must be of the kinds:\n\nAll sections contained (transitively) in conditional sections must also be of those kinds.\n\nIf an interface does not explicitly support any interfaces, then it implicitly supports the build-in interface object.\n\nThe object is an empty interface, i.e. it contains no predicates etc.\n\nThe purpose of object is to be a universal base-type of all objects.\n\nOpen qualifications are used to make references to class level entities more convenient. The open section brings the names of one scope into another scope, so that these can be referenced without qualification.\n\nOpen has no effect on the names of object members as these can only be accessed by means of an object anyway. But names of class members, domains, functors and constants can be accessed without qualification.\n\nWhen names are brought into a scope in this way it may happen that some names becomes ambiguous (see Scoping).\n\nOpen sections have only effect in the scope in which they occur. Especially this means that an open section in a class declaration has no effect on the class implementation.\n\nSupports qualifications can only be used in InterfaceDefinition and ClassImplementation.\n\nSupports qualifications are used for two things:\n• specifying that one interface extends another interface and, thereby, that the object type is a subtype of the object type\n• declaring that the objects of a certain class \"privately\" have more object types, than the one specified as construction type.\n\nsupports is a transitive relation: if an interface A supports an interface B and B in turn supports C, then A also supports C.\n\nIf an interface does not explicitly support any interfaces, then it implicitly supports the predefined interface object.\n\nFunctionally, it makes no difference whether an interface supports a certain interface more that once (directly and/or indirectly), but it might make a representational difference for the objects.\n\nWhen supports is used in the implementation of a class, the result is that \"This\" not only can be used with the construction type, but also with any privately supported object type.\n\nSupportsQualification can only be used in InterfaceDefinition and ClassImplementation.\n\nNotice interfaces cannot be used together in a supports qualification, if they have conflicting predicates.\n\nPredicates are conflicting if they have the same name and the arity but different origin interfaces.\n\nThe origin interface of a predicate is the interface in which the predicate is literally declared, as opposed to interfaces where it is indirectly declared by a supports qualification.\n\nSo it does not give conflicts, if the same interface is met twice or more in the supports chains.\n\nA class declaration defines the appearance of the class to the surroundings: the surroundings can see and use exactly those entities mentioned in the class declaration. We say that the declaration of a class specifies the public part of the class.\n\nA class declaration can contain constant and domain definitions and predicate declarations.\n\nIf the class states a construction type ConstructionType, then it constructs objects of that type. Object constructing classes have at least one constructor, but more can be declared. Classes that do not explicitly declare any constructors are automatically equipped with the default constructors (i.e. new/0).\n\nObjects are constructed by invoking one of constructors of the class.\n\nConstructors are also used when initializing inherited classes.\n\nEverything mentioned in a class declaration belongs to the class, rather than to objects it constructs. Everything that relates to the objects must be declared in the construction type of the objects constructed by the class.\n\nAny class declaration ClassDeclaration must have an accompanying class implementation ClassImplementation. The definition/implementation of predicates declared in the class declaration is provided by the class implementation. Likewise the definition of the predicates supported by the objects constructed by the class is provided by the class implementation. Both kinds of predicates can be implemented by clauses, but object predicates can also be inherited from other classes.\n\nIt is important to notice that a class declaration does not state anything about code inheritance. Code inheritance is a completely private matter that can only be stated in the class implementation. (This is unlike many other object oriented programming languages, and serves to hide all implementation details in the implementation).\n\nIf the class does not state a construction type ConstructionType, then the class cannot manufacture any objects; it therefore plays the role of a module rather than a \"real\" class.\n\nSee also Generic Interfaces and Classes and Monitors.\n\nThe ClassName in the end of the class declaration must (if present) be identical to the one in the beginning of the class declaration.\n\nNotice that you can use the same class name ClassName as the interface name ConstructionType specified as the construction type to this class. That is you can write:\n\nNotice that both the class and the interface can declare domains and constants and these must not conflict with each other since they end up in the same name space (because they can be qualified only with the same name of the interface or the class).\n\nThe ScopeQualifications must be of the kind OpenQualification.\n\nThe Sections must be of the kinds:\n\nconstructorsSections are only legal if the class states a ConstructionType.\n\nAll sections contained (transitively) in conditional sections must also be of those kinds.\n\nA class implementation is used to provide the definitions of the predicates and constructors declared in the class declaration, as well as the definitions of any predicates supported by its constructed objects.\n\nA class can privately (i.e. inside the implementation) declare and define more entities than those mentioned in the declaration. Especially, an implementation can declare fact databases that can be used to carry class and object state.\n\nAn implementation is a mixed scope, in the sense that it both contains the implementation of the class and of the objects produced by the class. The class part of a class is shared among all objects of the class, as opposed to the object part, which is individual for each object. Both the class part and the object part can contain facts and predicates, whereas domains, functors and constants always belong to the class part, i.e. they do not belong to individual objects.\n\nBy default all predicate and fact members declared in the implementation of a class are object members. To declare class members the section keyword (i.e. predicates and facts) must be prefixed with the keyword class. All members declared in such sections are class members.\n\nClass members can reference the class part of a class, but not the object part.\n\nObject members, on the other hand, can access both the class part and the object part of the class.\n\nIn the code in the implementation, the owner object is subsumed by all object predicates. The subsumed owner object can also be accessed directly through the special variable \"This\".\n\nSee also Generic Interfaces and Classes.\n\nThe ClassName in the end of the class implementation must (if present) be identical to the one in the beginning of the class implementation.\n\nThe ScopeQualifications must be of the kinds:\n\nA Supports qualification states the list of interfaces, which are supported privately by the class implementation.\n\nA Delegate qualification delegates functionality of (object) predicates from interfaces to predicates from objects, which can be stored as fact variables.\n\nThe Sections must be of the kinds:\n\nconstructorsSections are only legal if the class ClassName states a ConstructionType. Classes that states a ConstructionType are also object constructors, which construct objects of the stated construction type.\n\nThis example illustrates how class facts are shared among the objects of the class and how object facts are not shared.\n\nConsider the interface aa and class aa_class:\n\nThe point of the predicates is that they store and fetches values from respectively class and object facts:\n\nGiven this class consider the goal:\n\nThe class fact is shared among all objects, so setting the class fact via A1 also affects the value obtained via A2. Hence, the value of ClassFact will be one, the value set via A1.\n\nOn the other hand, object facts belong to each object. Therefore setting the object fact in A1 will not affect the value stored in A2. Hence value of ObjectFact is zero, the value that the fact was initialized to in A2.\n\nThis section describes object construction and, as such, it only deals with classes that produce objects.\n\nConstructors are explicitly declared in constructors sections in class declarations and implementations (see also Default Constructor).\n\nA constructor actually has two associated predicates:\n• An object predicate, which is used when initializing inherited objects.\n\nThe associated object predicate is used to perform initialization the object. This predicate can only be called from a constructor in the class itself and from a constructor in a class, which inherits from the class (i.e. base class initialization).\n\nThe associated class function is defined implicitly, i.e. there are no clauses for it anywhere.\n\nThe class function allocates memory to hold the object, perform internal initialization of the object and then invokes the object constructor on the created object. Finally, the constructed object is returned as the result of the constructor execution.\n\nSo before the clauses of the constructor are invoked:\n• All object facts variables that have an initialization expression are initialized.\n• All object facts that have clauses are initialized from these clauses.\n\nThis initialization is also performed on all (transitively) inherited sub-objects, before the clauses of the constructor are invoked.\n• Initialize all those single object facts and object fact variables that are not initialized before entrance.\n\nThe constructor clauses can do other things as well, but it must perform the initialization mentioned here to ensure that the object is valid after construction.\n\nNote. During construction objects might not be valid and care must be taken not to access un-initialized parts of the object (see Rules for Constructing Objects).\n\nA default constructor is a null-ary constructor with the name new/0. If a class that constructs objects does not declare any constructors in the class declaration, then the default constructor (i.e. new/0) is implicitly declared (in the class declaration). This means that each class has at least one constructor. So writing:\n\nis exactly the same as writing\n\nIt is legal to re-declare the default constructor explicitly.\n\nIt is not necessary to define (i.e. implement) the default constructor; if it is not defined then an effect-less definition is implicitly assumed. So writing\n\nis exactly the same as writing:\n\n(Given that aaa has a default constructor).\n\nNotice that a class has a default constructor if and only if:\n• it does not (publicly) declare any constructors at all;\n• or it declares new as a constructor.\n\nWhich is the same (negated) as: A class does not have a default constructor if:\n• and it does not publicly declare new as a constructor.\n\nGiven an interface aa, consider the following code:\n\nThe class aa_class declares no constructors; therefore, it implicitly declares the default constructor. Thus you can create an aa_class object like:\n\nIt is legal to implement the implicitly declared default constructor of aa_class:\n\nThe bb_class class explicitly declares a constructor, which is not the default constructor; subsequently the class does not have the default constructor\n\nThe cc_class class declares the newFromFile/1 constructor, but it also declares the default new/0 constructor; so obviously, it has the default new/0 constructor\n\nYou also can declare \"private\" constructors in class implementations. This can be reasonable, for example, in the following situations:\n• When some predicate returns an object of construction type, then in a class implementation can be declared, implemented and called a \"private\" constructor to create such objects.\n• When some class declares several \"public\" constructors having a \"same big part\", then it can be reasonable to define in the class implementation a \"private\" constructor, which implements this \"same big part\". Then clauses of all these \"public\" constructors can simply call this \"private\" constructor to implement this \"same big part\".\n\nNotice that if a class, which can construct objects, does not declare any constructors in the class declaration, then the default constructor (i.e. new/0) will be declared implicitly independently of whether the class implementation declares or not \"private\" constructors. That is, it is possible to write:\n\nAll constructors are responsible for initializing constructed objects to valid states. In order to obtain such a valid state all sub-objects (i.e. inherited classes) must be initialized as well.\n\nThe sub-objects can be initialized in one of two ways, either the programmer calls a constructor of the inherited class or the default constructor is automatically invoked. The latter requires that the inherited class actually has the default constructor, but this is no difference whether this default constructor is declared explicitly or implicitly - it will be called in both cases!\n\nIf the inherited class does not have a default constructor, then another constructor must be invoked explicitly. The default invocation of constructors of inherited classes takes place immediately after initialization of fact variables and facts with clauses and before entrance to the clauses of the constructor.\n\nConstructors of inherited classes are invoked by the versions that does not return a value. If you call the version that returns a value then you are actually creating a new object, rather than invoking the constructor on \"This\" (see the example below).\n\nThis implementation of the class bb_class inherits from the class aa_class and the default constructor of bb_class call a constructor of aa_class with a newly created cc_class object\n\nIf a base class is not explicitly constructed, then it is implicitly constructed using the default constructor. So writing:\n\nis exactly the same as writing:\n\nIf aaa does not have a default constructor then this will, of course, give an error.\n\nNotice that this rule (of course) can be combined with the rule discussed in the first paragraph of Default Constructor. So writing:\n\nIs exactly the same as writing (according to the rule discussed in the first paragraph of Default Constructor):\n\nWhich is exactly the same as writing (the rule discussed above):\n\nJust like all constructors have to initialize/construct sub-objects, they also have to initialize all single facts of an object, before they are referenced the first time.\n\nNotice that single class facts can only be initialized with clauses, since they are not related to an object. A class fact can be accessed before the first object is created.\n\nThis example shows (1) how to initialize a fact variable by means of an expression; (2) how to initialize a single fact (point) by means of a clause; (3) how to initialize a single fact in the constructor and (4) where the default constructor of an inherited class is invoked:\n\nAs an alternative to construct the object directly in a constructor the job can be delegated to another constructor of the same class. This is done simply by invoking the other constructor (i.e. the version that does not return a value). When delegating construction we have to be sure that the object is actually constructed and that it is not \"over-constructed\". Single facts can be assigned a value as many times as one likes so they cannot be \"over-constructed\". Inherited classes, on the other hand, may only be initialized once during object construction.\n\nThis example shows a typical use of construction by means of delegation. A constructor (new/0) invokes another constructor (newFromC/1) with a default value.\n\nThe programmer must ensure that:\n• All sub-objects are initialized/constructed exactly once each.\n• All single facts are initialized (at least once).\n• That no sub-object is referenced before it is initialized/constructed.\n• That no single fact is used before it is initialized.\n\nThere is no guarantee about how clever the compiler is in detecting such problems at compile time.\n\nThe compiler may offer to generate runtime validation, it may also offer to non-safely omit such runtime validations.\n\nAn object predicate is always invoked on an object. This object carries the object facts and is subsumed by the implementation of object predicates. The object predicate has access to this implicit object. We shall call the object \"This\". There are two kinds of access to \"This\" implicit and explicit.\n\nIn every clause of every object predicate the variable This is implicitly defined and bound to \"This\", i.e. the object whose member predicate is executing.\n\nIn the clause of an object member predicate other object member predicates can be called directly, because \"This\" is implicitly assumed for the operation. Members of super-classes can also be invoked directly, as long as it is unambiguous which method is called (see Scoping & Visibility). Likewise the object facts (which are stored in \"This\") can be accessed.\n\nWe have to classes aaa and bbb that both implement the iName interface. bbb inherits aaa, so this code:\n\nI.e. bbb has inherited the implementation of thew className property from aaa.\n\nIf we reimplement the className property in bbb:\n\nthen the output will change to\n\nBecause now bbb has its own implementation of the className property.\n\nLey us extend the iName interface with a name property:\n\nAnd implement it in aaa like this:\n\nWe will not implement the name property in bbb so it will inherit the implementation from aaa.\n\nChanging the test clause like this:\n\nWe will get this output:\n\nNotice that the inherited name property in bbb returns \"aaa\".\n\nThis is because the inherited name property references the aaa::className.\n\nLet us perform a similar extension with a property nameThis:\n\nAgain we will let bbb inherit the code from aaa, but this time the implementation in aaa will make an indirect reference to className through This:\n\nSuch an indirect reference through This behaves like calls made to objects from the \"outside\", so if updating the test in the \"obvious\" way:\n• A direct reference in an implementation in a3 to a predicate/property will refer to the entity as seen inside a3, which will therefore\n• be implemented in a3 or\n• inherited from a2 which may have inherited it from a1\n• An indirect reference through in an implementation in a3 to a predicate/property will refer to the entity as see from the outside, and will therefore\n• be implemented in a5 or\n• inherited from a4 which may have inherited it from a3, ...\n\nInherits qualifications are used to state that an implementation inherits from one or more classes. Inheritance has only influence on the object part of a class.\n\nThe purpose of inheriting from other classes is to inherit behavior from these classes.\n\nWhen a class cc inherits from a class aa, this means that the implementation of the cc class automatically implicitly (privately) supports the construction type (interface) of the aa class. (If the class aa implementation already support the cc construction type explicitly then there is of course no difference.)\n\nTherefore, notice that the same predicate, for example p, cannot be declared in the construction type interface of a cc class and in the construction type interface of an inherited aa class. (The compiler will detect this and generates an error that a predicate is declared in 2 places.) Let us discuss this in some details. Let us suppose that a cc class has a construction type interface cci and some other aa class has a construction type interface aai. Let both aai and cci interfaces declare the same predicate p. Till the aa and cc classes are independent, the compiler does not detect any problems. But as soon as we declare that the cc class inherits from the aa class, then cc class starts to support also the aai interfaces. Therefore, the cc class starts to see both declarations of the predicate p, which will be reported as a compiling time error. The only possibility to avoid such ambiguity in the predicate p declaration is using of the Predicates from Interface section in the cci interface declaration. For example like:\n\nObject predicates can be inherited: If the class does not implement a certain of its object predicates, but one of the classes it inherits from does implement this predicate, then that predicate will be used for the current class.\n\nThe class that inherits from another class does not have any special privileges towards the inherited class: It can only access the embedded object through its construction type interface.\n\nInheritance must be unambiguous. If the class defines the predicate itself then there is no ambiguity, because then it is this predicate definition that is exposed. If only one inherited class supports the predicate then it is also unambiguous. But if two or more classes supports the predicate then it is ambiguous which class provides the definition. In that case the ambiguity must be resolved by means of a resolve qualification (see Resolve Qualification).\n\nObject predicates from inherited classes can be called directly from object predicates in the current class, since the embedded sub-object is implicitly used as predicate owner. Class qualification can be used to resolve calling ambiguities for object predicates from inherited classes.\n\nAs mentioned elsewhere all ambiguities related to calling predicates can be avoided by using qualified names.\n\nBut when it comes to inheritance this is not the case. Consider the following example:\n\nIn this case it is ambiguous which of the classes bb_class and cc_class that would provide the implementation of aa for dd_class. (Notice that when we say that a class implements an interface, it means that it provide definitions for the predicates declared in the interface.)\n\nIt would of course be possible to add clauses to the implementation of dd_class, which would effectively solve the job. Consider, for example, the following clause, which would \"export\" the predicate p from bb_class:\n\nBut, with this code we have not really inherited the behavior from bb, we have actually delegated the job to the bb_class part of our class.\n\nSo to resolve this kind of ambiguities (and use real inheritance rather than delegation) we use a resolve section. A resolve section contains a number of resolutions:\n\nA resolve qualification is used to resolve an implementation from the specified source.\n\nA predicate from class resolution states that the predicate is implemented by the specified class.\n• the class must implement the predicate to be resolved, this implies that the predicate must origin in the same interface as the one that should be inherited\n• the class must be mentioned in the section\n\nA predicate rename resolution states that the predicate is implemented as predicate with another name. The predicate must come from an inherited class and its type, mode and flow must match exactly.\n\nAn interface resolution is used to resolve a complete interface from one of the inherited classes. Thus an interface resolution is a short way of stating that all the predicates in the interface should be resolved from the same class.\n\nThe class must publicly support the resolved interface.\n\nIf both a predicate resolution and an interface resolution cover some predicate name, then the predicate resolution is used. I.e. the specific resolution overrides the less specific ones.\n\nIt is valid for a predicate to be covered by several interface resolutions, as long as these all resolve the predicate to the same class. If on the other hand a predicate is resolved to different classes by interface resolutions, then the resulting ambiguity must be resolved by a predicate resolution.\n\nNote: The syntax of resolutions is not capable of resolving different overloading of a predicate to different classes.\n\nWe can solve the ambiguity from the example above by providing an interface resolution. In this case we have chosen to inherit the implementation of aa_class from cc_class, except that we will inherit p from bb_class\n\nA predicate externally resolution states that the predicate is not at all implemented in the class itself, but in an external library. External resolutions can only be used for class predicates. I.e. object predicates cannot be resolved externally.\n\nIt is important that the calling convention, link name and argument types correspond to the implementation in the library.\n\nBoth private and public predicates can be resolved externally.\n\nA predicate externally resolution also provide syntax for dynamic loading of private and public class predicates from DLLs.\n\nIf the predicate predicateNameWithArity is not available in the DLL DllNameWithPath, then the dynamic loading provides the possibility to run a program until it actually invokes the predicate. A runtime error will occur on such invocation. The DllNameWithPath is the path to the DLL on the machine where the program should run, it can be absolute or relative. For example if the required dll is situated in the one level up from directory which the application loaded, then the DllNameWithPath should be like \"../DllName\". See also Dynamic-Link Library Search Order.\n\nOnce an object cannot be reached by the program it can be finalized, the semantics of the language does not say exactly when the object will be finalized. The only thing that is guaranteed is that it is not finalized as long as it can be reached from the program. In practice the object is finalized, when it is wasted by the garbage collector. Finalization is the opposite of construction and will remove the object from memory.\n\nClasses can also implement a finalizer, which is a predicate that is invoked when the object is finalized (before it is removed from memory).\n\nA finalizer is a procedure with no arguments and no return value, which has the name finalize. The predicate is implicitly declared and cannot be invoked directly from the program.\n\nThe main purpose of finalizers is to be able to release external resources, but there are no restrictions on what it can do. Finalizers should however be used with caution, recall that the time of their invocation is not completely known and, therefore, it might also be difficult to predict the overall program state at the time where they are invoked.\n\nNotice that there is no reason to retract object facts from an object in the finalizer, because this is automatically done in the finalization process.\n\nAll objects are finalized before the program can terminate (unless an abnormal situation like power failure prevents this).\n\nThis example uses a finalizer to ensure that a database connection is closed properly.\n\nThe delegate qualifications are used to delegate implementations of object predicates to the specified source.\n\nThere are two kinds of the delegate qualifications. The Predicate Delegation and the Interface Delegation. The Interface Delegation is used to delegate implementations of a complete set of object predicates declared in an interface to an implementation of another object, stored as fact variable. Thus an interface delegation is a short way of stating that implementations of all predicates in the interface should be delegated to an implementation of the object, stored in fact variable.\n\nThe delegate sections look like a correspondent (predicate/interface) resolve sections, except that you delegate to fact variables keeping constructed objects of classes, rather than to inherited classes.\n\nA object predicate delegation states that the predicate functionality is delegated to the predicate in the object specified with the fact variable FactVariable_of_InterfaceType.\n\nTo delegate a predicate to an object passed with the fact variable:\n• The fact variable must have a type of an interface (or of its sub-type), which declares the predicate predicateNameWithArity.\n• The object supporting the interface must be constructed and be assigned to the fact variable .\n\nConsider the following example:\n\nLater it will be possible to construct objects of the type a and assign them to fact variables fv1 and fv2 to define to objects of which class we really delegate definitions of p1 and p2 functionality. Consider, for example,\n\nActually in Visual Prolog delegation has the same effect as if you add clauses to the implementation of dd_class that explicitly specify, from object of which class the predicate functionality is \"exported\". That is for example, as if the following clause is determined in the implementation of dd_class:\n\nWhen you need to specify that functionality of all predicates declared in an interface InterfaceName are delegated to predicates from objects of the same inherited class, you can use the Interface Delegation specification:\n\nThus an interface delegation is a short way of stating that functionality of all predicates declared in the interface InterfaceName should be delegated to objects stored as the fact variable FactVariable_of_InterfaceType. Objects should be assigned to the fact variable FactVariable_of_InterfaceType, which should be of the InterfaceName type (or its sub-type).\n\nTo delegate an interface to an object passed with the fact variable:\n• The fact variable must have a type of an interface or of its sub-type.\n• The object supporting the interface must be constructed and be assigned to the fact variable .\n\nThe predicate delegation has higher priority than the interface delegation. If to a predicate both delegations are specified. That is, the predicate delegation is specified to the predicate and it is declared in an interface, which has the interface delegation. Then the higher priority predicate delegation will be implemented.\n\nThe programming language Visual Prolog has gone through a huge development in the latest years, and this will also continue in future. Most noticeable is the shift to object-orientation, and the introduction of parametric polymorphism. In this paper we will explain the reason for introducing these features. Examples will be used to illustrate how these facilities can help to tackle the increasing complexity and size of software.\n\nWhile Prolog has many great virtues, one must remember that it is from the IT-bronze-age, and it would be silly to think that it would stay contemporary after three decades or more, especially considering the speed with, which the IT-world has evolved since then. Back then you could write an amazing Prolog program that described how to get a cabbage, a goat, a wolf and a farmer across a river in a little boat without anybody eating anybody. You can still write such programs just as easily (see Farmer, Wolf, Goat and Cabbage), but they are just not that amazing anymore. Show it to your children and they will immediately ask why the solution is not an animation, and explain that there are millions of much more advanced programs one click away on the Internet already.\n\nPrograms today must be more advanced than yesterday. They also have to live and interact with a much larger world than yesterday. And this is an ongoing story.\n\nMany attempts has been made to help tackle these challenges; we have chosen to add the elements that we believe are the winners to Visual Prolog. These are especially object-orientation and parametric polymorphism, but there are also other new elements especially taken from the functional programming world.\n\nThe goals of the language update is to provide better means for creating and maintaining more complex programs for more complex surroundings.\n\nHumans are better to dealing with simple things than complex things, so one important way to deal with complexity is to reduce it to something simpler, especially by using \"structure\" to organize the complexity.\n\nThe main \"trick\" is the divide and conquer principle: Divide the original problem into separate sub-problems that can be solved individually. I.e., the solution to the overall problem consists of a number of sub-solutions and something that combines these into the overall solution.\n\nFor software it is often not enough to solve a problem, we must also be able to maintain and extend the solution in an evolving world. So it is important that the used methods not only solve the problem, but also result in a program that can be maintained. Here it is important that the program is understandable and especially that the divides are visible and clear in the program.\n\nWhen you divide problems into sub-problems, perhaps repeatedly, you will sometimes see similar sub-problems. Then it would of course be nice to short cut by reusing a similar solution. Such a solution can be adopted into the new context, but there are two ways this can happen. We can make a copy and update it to its new purpose, or we can try to share the code between the two problems.\n\nThe latter is clearly the hardest and only makes sense if both pieces of software are still maintained. But in that case you will have the advantage that maintenance made in one context is also shared with the other context.\n\nIt is also desirable that your software is flexible. You may for example need to deliver several variants of your software to different customers. Or you may need to reconfigure the software to a changed context. Also some of your shared sub-solutions may need to go into contexts that are not completely the same.\n\nFinally, it is of course desirable if language extensions add additional programming power. For example, by simplifying the code necessary to tackle certain standard \"issues\".\n\nVisual Prolog has been extended with many language features that support the goals above, but it is still up to the programmer to apply these features such that the goals are achieved. Here we will focus on understanding and using polymorphism.\n\nThe object-system in Visual Prolog gives so called subsumption polymorphism and also have parametric polymorphism. Polymorphism is especially well-suited for divide and conquer that supports sharing of code.\n\nAn object is a closed entity that carries state and code. The object provides an interface through which the surroundings can interact with the object. The object can also interact with other objects through their interfaces.\n\nEach interface has an explicit definition in the source code. The definition effectively consists of a name and a number of predicate declarations.\n\nLet us assume that we want an object through which some administrative system can report salary. In an oversimplified world, such an object might have this interface:\n\nAn object with this interface will allow you to report an Amount for a person (identified by Name).\n\nThe salarySystem interface defines a data type that can be used in the program. The main salary reporting predicate in the application might be declared like this:\n\nFor the sake of the example, we simply hard code a little salary reporting like this:\n\nWe will of course also need to implement our salary system objects, and that is where the subsumption polymorphism comes in play. The thing is that our customers of course use a lot of different salary systems, which must receive input in many different formats and using many different media. Objects are implemented by classes, and the fortunate thing is that many different classes can implement the same interface. Objects produced by any such class can be used by the reportSalary predicate. Thus, the reportSalary predicate is polymorphic because the salarySystem type subsumes all the different implementations of the interface. To deal with the ACME salary system we declare this class:\n\nThe declaration simply says that acme is a class that produces objects of type salarySystem. The class also needs an implementation:\n\nTo illustrate the polymorphism, we will also implement the integration to the O'Salery system. Again we declare and implement a class:\n\nNow let us try our two salary system integrations:\n\nIn the test predicate above, we create one of each salary systems and report salary to them. The result looks like this:\n\nIn this example, the difference was not that big, but we might also have placed the result in a database, used a foreign API, called a WEB service or whatever.\n\nThe solution above uses the divide and conquer principle to separate the reporting in a vendor independent part and a vendor specific part. In this case the vendor independent part also deals with the company level in the reporting, were as the vendor dependent part only deals with the person level.\n\nWe have used subsumption polymorphism to provide the flexibility to deal with many different salary systems in a seamless way. In real world, this may not be as simple as here though. The key to success is that the salarySystem interface is a sufficiently powerful abstraction/generalization of all the relevant salary systems. It may for example be necessary to provide several different ways to identify persons in the salary predicate. Different salary systems can then use the identification method, which is appropriate for them and ignore the rest.\n\nThe reportSalary predicate is shared across different salary systems. The sharing is a high-level domain specific sharing, within the same application or variants of it.\n\nVisual Prolog also has another kind of subsumption polymorphism: Predicate values. A predicate value is a predicate that is bound to variables, transferred as parameter and/or stored in facts. Again, the polymorphism comes from a type that subsumes many different implementations.\n\nAs an example, PFC uses predicate values in its heavily used event notification scheme. A scheme that can of course also be used outside PFC.\n\nThe event notification scheme has two kinds of actors: the event source and the event listener. There is one event source, but there can be any number of listeners. The event source offers predicates for registering and deregistering event listeners. When the event occurs all registered listeners are notified.\n\nThe interesting thing is that the event listener is a predicate, meaning that the notification will immediately execute code. In addition, due to the subsumption polymorphism each listener can have its own implementation and thus perform quite different actions.\n\nA very important property of predicate values is that they can be object predicates, and that these have access to the object state to which they belong.\n\nWe shall not describe the event notification scheme in details here, though it is good to understand. The reader is encouraged to study the concept in PFC (look for addXxxxListener). However, the use of predicate values will be exercised in the job-scheduling example in the end of this paper.\n\nLike for subsumption polymorphism the purpose of parametric polymorphism is to use the same code for many things. However, where subsumption polymorphism is mainly about supplying different implementations to the same context, parametric polymorphism is mainly about using the same implementation in different contexts.\n\nLet us start with a very simple example, to introduce the concepts. We will implement a function, which takes the list as argument and returns the elements one by one (non-deterministically).\n\nIn Visual Prolog the list domain is a polymorphic domain: If Elem is a type/domain then Elem* the list domain of Elem. The new thing is that parameters like Elem and type expressions like Elem* can be used in declarations, and that the resulting declaration will cover any instantiation of such parameters.\n\nTherefore we can declare our getMember_nd function like this:\n\nThis declaration says that getMember_nd is a function, which takes a list of Elem argument and returns an Elem, where Elem is any domain/type.\n\nWithout further notice getMember_nd can be used on any list kind:\n\nHere Elem is integer* (i.e. list of integers). The output looks like this:\n\nThe list domain is a predefined polymorphic domain. But you can also define polymorphic domains yourself. As an example we can create a priority queue; sometimes called a heap. Let me warn you, the implementation I will use here is not particularly efficient; it is just simple.\n\nThe idea of the priority queue is that we can insert some data with a priority, later we can then retrieve the data with lowest priority. It sounds a bit strange, that it is the one with the lowest Priority that is retrieved; but that is how it normally works. I assume that it comes from the idea of first priority, second priority, etc. where smaller number means higher priority.\n\nAnyway, in this case we want to implement the queue as a list of tuple's, each tuple has two elements the first is the priority and the second is the Data. Furthermore, we will keep the list sorted after priority (i.e. an invariant), such that the smallest element is always first in the list.\n\ntuple is already defined in Visual Prolog its definition looks like this:\n\nThere are also tuple's with other arities, but we only need the pair. This is an example of a programmer defined polymorphic domain. What the definition says is that tuple is a domain with two type parameters T1 and T2. You may think of it as an infinite family of domains corresponding to all instantiations of the type parameters, e.g.:\n\nThe single domain definition above corresponds to all these domains, but actually the domain names/expressions look like this:\n\nThe values looks as expected; let us take a relatively complex one right away:\n\nT2 is a tuple, its first element is itself a tuple (containing a char and a string), its second element is a list of real's. Subsequently, X has this type:\n\nAs you can see type expressions can become rather complex. You will probably soon get use to this, but below I will show a little scheme that can be used to keep type expressions simpler and more understandable, and which will at the same time make your program more type safe.\n\nWe are now ready to define our queue domain:\n\nThe _rep in the domain name has to do with the scheme mentioned above, right now you can simply ignore it. The domain definition says that queue_rep is a domain with two type parameters Priority and Data furthermore it is a list of tuple's of these types.\n\nYou may wonder why Priority is a type parameter, you may think that it should have been a number type like integer. However, in Visual Prolog all data types are ordered, and therefore any data type can be used as a priority. Using a type parameter here makes the resulting queue more flexible. And at least I do not have to choose whether the priority should be integer, unsigned or real.\n\nTo know whether you can use a type parameter or have to use a regular type you will have to consider what you need from the type. Like here where we need ordering (comparison). The following is possible on type parameters:\n• binding and unifying (with values of same type)\n• comparing (with values of same type)\n\nThe last thing is partially wrong, the compiler allows this, but in practice you cannot read all kind of data, it is for example not possible to read predicate values and objects from streams.\n\nLet us return to our priority queue. Now that we have defined the domain that represents the queues, we will also have to declare and implement the suitable operations.\n\nLet us start with the simple ones. First we need an operation to obtain the least element in the queue (i.e. the one with least priority). This can be declared like this:\n\nThe predicate is determ because the queue might be empty. The predicate is a function whose argument is a priority queue and which returns a tuple containing both the Priority and the Data. It does not remove the element from the queue, because I want to be able to peek at the element without removing it.\n\nThe list is sorted with the least element first, so the implementation is trivial:\n\nSimilarly we need a predicate for removing the least element:\n\nFinally, we need an insert predicate:\n\nI have chosen shorter variable names to make the code fit the narrow column, but at the same time it gives me the opportunity to explain that type variables like Pri above only have scope in the declaration/definition where they occur. Therefore, there is nothing wrong with using Priority in one declaration and Pri in another. Nevertheless, you should of course choose variable names with care, because good names make the code clearer. The compiler would not mind if you exchange Priority and Data, but I am sure that it could confuse many programmers.\n\nThe priority queue above can be used for various purposes, but it has two disadvantages, which both relate to the way we have defined the queue domain itself:\n\nA definition like this one is just an abbreviation or synonym, so queue_rep{integer, sting} is exactly the same as tuple{integer, string}*.\n• The debugger will always show the unfolded type (i.e. tuple integer string ) and this can be rather confusing.\n• Any piece of data that have this type can accidentally be given as argument to the priority queue predicates. However, the priority queue operations not only require that the data has this type, it also expect that it is sorted in a specific way (i.e. that the data satisfies the invariant).\n\nThe latter problem could just as easy exist without polymorphism. It comes from using a general data structure for something specific. If you do this, you can mix anything that is of the general kind even though it is of different specific kinds.\n\nSo instead we just consider the queue_rep domain as being the internal representation of the queues, hence the extension _rep. To the external world we will wrap each queue_rep queue inside a functor.\n\nTherefore, to the real queue domain will look like this:\n\nSuch a domain is neither an abbreviation nor a synonym.\n\nThe exported/public predicates will of course work on queue 's, so the complete class declaration looks like this:\n\nI have also added an empty queue constant to the class. As a user of the class you then do not need to be concerned with the representation of the queues at all, there are predicates and constants for everything.\n\nThe predicates in this class are very simple to implement given the predicates we implemented before, the only thing they should do is to remove and add the queue functor in the relevant places:\n\nUsing this _rep scheme is a bit less efficient, because of the extra functor, and it is entirely up to your temperament whether to use it or not. In any case it makes your type unique, rather than being a synonym type.\n\nPriority queues can be used like this:\n\nThe output looks like this (except for additional white space):\n\nIt may seem that polymorphism disables type check, but in fact it gives a very strong but flexible type check. If, for example, I write:\n\nThen I will get the error message:\n\nerror c504: The expression has type '::integer', which is incompatible with the type '::string'\n\nThe first insert forces the Data type of Pq2 to be string, therefore you cannot use an integer in the next line.\n\nWhat may be more surprising is that it also forces the Data type of Pq1 to be string. Therefore this code gives exactly the same error:\n\nOn the other hand this is legal:\n\nThe \"moral\" is that the constant empty is polymorphic, but variables can only have a monomorphic type, so when empty is bound to a variable a concrete type is chosen and \"frozen\".\n\nThe priority queue above can be use for numerous purposes. And the code can be shared between all such uses, both within a single program and across programs. If I choose to make a more efficient solution to the priority queue, then I will benefit from this in all places where it is used.\n\nParametric polymorphism is used to solve different problems in the same way (e.g. a using priority queue), and as such it is often used to make basic library software.\n\nSubsumption polymorphism is in many respects the complement to parametric polymorphism: it is used solve the same problem in different ways (e.g. reporting salaries to different salary systems), and as such it is often used at high levels in applications to deal with variance.\n\nHowever, the world is not black and white in this respect, there are many graduations and clear exceptions to this.\n\nNow let us try to combine some of the things from above to produce a simple, but yet powerful job scheduler.\n\nA job is just some computation that should be performed. You register a job in the scheduler; the scheduler will then start the job at the requested time. Given such an \"alarm clock\" scheduler it is relatively easy to deal with reoccurring jobs and jobs that start in X minutes rather than at a certain time, and so forth. Here we will only consider the \"alarm clock\" functionality.\n\nThe scheduler will rely on a timer event: every time the timer even triggers it will see if any jobs are due, and execute these.\n\nIn this example I will just assume that time is an integer. I might want to use several schedulers in my program, so I choose to represent each scheduler by an object. Therefore the scheduler is mainly described as an interface, i.e. the type of the scheduler objects. The declaration of the scheduler looks like this:\n\nA job is a predicate value acting as a callback. I have chosen that the job receive the invocation Time as a parameter. This is mainly for illustrative purposes and simplicity. In real life, I would probably rather give it the scheduler, which I would enrich with predicates for obtaining the current time and probably other things as well. That way the job can itself decide which information it wants to obtain.\n\ntimerTick should be invoked regularly, since this is the heart of the scheduler.\n\nThe implementation looks like this:\n\nMost of the implementation is completely trivial. The main thing is that I use a priority internally for storing the jobs, with the time as priority. This have the advantage that the \"most due\" job is always easily accessible.\n\nThere is a jobQueue fact that is initialized in the constructor, and registerJob simply insert the job in the priority queue.\n\nThe important things take place in timerTick. It peek at the \"least\" job in the queue. If this hob should be started now or earlier then it is stated and removed from the queue, and then the rest of the queue is considered.\n\nIf the \"least\" job is not due then we do nothing, i.e. then we wait for another timer tick.\n\nBefore we use the scheduler I want to point out that several good reasons why the scheduler does not contain the actual timer:\n• It may be important to be in synchronization with some external clock\n• In some contexts the increment in the Time parameter need not be the same al the time\n• In some contexts the Time does not relate to real time. (E.g. game steps, workflow steps., etc).\n• In a GUI application it may be important that the timerTick's are invoked from a window event. I.e. to keep the application single threaded.\n\nUsing external timer ticks makes all this possible.\n\nLet us use the timer in a console program, where the clock is provided by a simple for loop:\n\nThe traceJob simply writes the clock. We create a scheduler and register the traceJob for running at Time = 500, and then we start the clock.\n\nWe can also make a job that reschedules itself and thus runs repeatedly. To do this the job must have access to the scheduler and therefore we save it in a fact:\n\nIn the scheduler we have clearly used the (parametric) polymorphic priority queue. We have also used the (subsumption) polymorphism that comes from predicate values, such that we can register jobs with different implementation in the scheduler. The parametric polymorphism has exploited the homogeneous treatment of prioritizing things, no matter which kind of things we are dealing with. The subsumption polymorphism has been used to deal with the heterogeneous nature of jobs themselves.\n\nInterfaces and classes can be parametrized with type parameters so that they can be used in different instantiations in different contexts.\n\nThis section must be considered as an extension to the individual sections about:\n\nThe pragmatic reason to use generic classes and interfaces is to declare parametrized object facts and implement operations on these facts. As illustrated in the Queue example below.\n\nAn object of this type is a queue of integers, if you replace \"integer\" with \"string\" you would have a type describing queues of strings.\n\nA generic interface can be used to describe all such interfaces in a single interface definition:\n\n@Elem is a scope type variable (distinguished from local type variables by the @).\n\nqueue{integer} represents integer-queues; queue{string} represents string-queues; and so forth.\n\nWe can declare a generic queue class like this:\n\nqueueClass{@Elem} constructs objects type queue{@Elem} for any instantiation of @Elem.\n\nThe implementation can look like this:\n\nThis piece of code illustrates how to create an integer queue and insert an element in it:\n\nIt is not necessary to apply the type explicitly, instead the compiler can infer it from the context:\n\nThe compiler sees that Q must be an integer queue, because we insert 17 into it.\n\nThe scope type parameters can be used in any declaration/definition in the interface.\n\nA generic interface defines all the interfaces that can be obtained by instantiating the type parameters with actual types. The scope type parameters from the opening are bound in the entire interface.\n\nThen closing name should not have parameters:\n\nIt is illegal to use same interface name for interfaces with different arity (in the same namespace):\n\nParameters can be used in supported interfaces:\n\nSupported interfaces can be instantiated with any type expressions (as long as parameters are bound):\n\nGeneric classes have a list of type parameters, and constructs objects of an interface type uses the these parameters.\n\nThe construction type must be generic (i.e. a generic interface).\n\nA generic class declares a class with a generic constructor. The type of the constructed object will be inferred from the usage of the constructor.\n\nThen closing name should not have parameters:\n\nIt is illegal to use same class name for class with different arity (in the same namespace):\n\nIf a class and interface can have the same name, the class must construct objects of that interface.\n\nParameters in the construction type, etc must be bound:\n\nAll the parameters from the class must be used in the construction type:\n\nIn class declarations scope parameter can only be used in constructors, domains and constants.\n\nA generic class declares a class with a generic constructor. The type of the constructed object will be inferred from the usage of the constructor.\n\nThen closing name should not have parameters:\n\nThe parameters must be the same as in the corresponding class declaration and have same order.\n\nIn class implementations scope parameter can be used in constructors, domains, constants and in object entities (i.e. object facts, object predicates and object properties).\n\nA monitor is a language construction to synchronize two or more threads that use a shared resource, usually a hardware device or a set of variables. The compiler transparently inserts locking and unlocking code to appropriately designated procedures, instead of the programmer having to access concurrency primitives explicitly.\n\nVisual Prolog monitor entrances can be controlled by guard predicates (conditions).\n\nA monitor interface is defined by writing the keyword monitor in front of a regular interface definition:\n\nA monitor class is declared by writing the keyword monitor in front of a regular class declaration:\n\nMonitor classes and interfaces cannot declare multi and nondeterm predicate members.\n• It is not legal to inherit from a monitor (i.e. from a class that implements a monitor interface).\n\nThe predicates and properties declared in a monitor are the entrances to the monitor. A thread enters the monitor through an entrance and is in the monitor until it leaves that entrance again. Only one thread is allowed to be in the monitor at the time. So each entry is protected as a critical region.\n\nThe semantics is simplest to understand as a program transformation (which is how it is implemented). Consider this academic example:\n\nWhere <B1>, <B2>, ..., <Bn> are clause bodies. This code corresponds to the following \"normal\" code:\n\nSo each monitor class is extended with a mutex, which is used to create a critical region around each entry body.\n\nThe code for monitor objects is similar, except that the mutex object is owned by the object.\n\nConsider a monitor protected queue: some threads (producers) inserts elements in the queue and others (consumers) pick-out elements. However, you cannot pick-out elements if the queue is empty.\n\nIf we implement the queue using a monitor, the \"pick-out\" entry could be determ, failing if the queue is empty. But then the consumers would have to \"poll\" the queue until an element can be obtained. Such polling uses system resources, and normally it is desirable to avoid polling. This problem can be solved by guard predicates.\n\nEach entry can have a guard associated in the implementation. The guard is added as a special guard-clause before the other clauses of the entry.\n\n\n\n The guard predicates are evaluated when the monitor is created. For monitor classes this means at program start, for object predicates this is immediately after the construction of the object. The guard predicates are also evaluated whenever a tread leaves the monitor. But they are not evaluated at any other time.\n\nIf a certain guard succeeds the corresponding entry is open, if it fails the entry is closed.\n\nIt is only possible to enter open entries.\n\nGuard predicates are handled in the transformation mentioned above.\n\nAn event is created for each guard predicate; this event is set to signaled if the guard predicate succeeds. As mentioned it is set during the creation of the monitor and each time a predicate leaves the monitor (before it leaves the critical region).\n\nWhen entering an entry the threads waits both for the monitorRegion and for the guard event to be in signalled state.\n\nIn the code above the initialization of the class itself and the guard events are done in an undetermined order. But actually it is ensured that the guard events are initialized after all other class/object initialization is performed.\n\nThis section shows a few cases where monitors are handy.\n\nSeveral threads needs to log information to a single log file.\n\nThe monitor ensures that writing of a log lines are not mixed with each other, and that stream changes only takes place between writing of log lines.\n\nThis monitor can be used to thread protect the operations of an output stream:\n\nYou should realize however that with code like this:\n\nconsists of three separate operations, so it can still be the case (fx) that two threads first write the time and then one writes the \"...\", etc.\n\nThe queue above is fine, but actually it may be better to create queue objects. Using generic interfaces we can create a very general queue:\n\nNotice that PFC contains a similar class monitorQueue already.\n\nNamespaces can be used to avoid name clashes, without having to use long strange names. The names in two different namespaces will never clash, but it may be necessary to qualify references with the namespace (or part of it) to resolve ambiguities.\n\nA namespaces are declared and defined implicitly using NamespaceEntrance'es:\n\nIn short a NamespaceIdentifier is a sequence of lowercase identifiers separated by backslashes.\n\nA namespace entrance marks the beginning of a namespace region, which ends at the next namespace entrance or the end of the file.\n\nEvery file starts in the root namespace.\n\nNamespace regions are not influenced by #include directives, meaning:\n• Namespace entrances in an -file does not change the namespace region in the including file\n• Any file starts in the root namespace (also if it is included inside a namespace region in another file).\n\nAny interface, class and implementation that is meet inside a namespace region belongs to that namespace.\n\nIf ccc is a class in the namespace xxx\\yyy, then the full name of ccc is \\xxx\\yyy\\ccc.\n\nThe leading backslash indicates that we start from the root namespace.\n\nA class/interface can always be uniquely referenced using its full name.\n\nThe full names are not always convenient and therefore it is possible to use shorter names by opening namespaces.\n\nOpening a namespace is distinguished from opening a class/interface by a trailing backslash.\n\nWhen a namespace is open that part of a full name can be left out.\n\nA domains with the full name \\xxx\\yyy\\zzz\\ccc can be as referenced zzz\\ccc inside aaa because xxx\\yyy is open.\n\nNotice that the short name does not start with a backslash; A name starting with a backslash is always a full name.\n\nThe namespace that a certain scope (i.e. interface/class/implementation) belongs to is (implicitly) open inside that scope.\n\nSections are used to declare and define entities in scopes.\n\nNot all sections can occur in all kinds of scopes, please refer to the description of Interfaces, Class Declarations, and Class Implementations for further details.\n\nConditional sections are described in Conditional Compilation.\n\nA domain section defines a set of domains in the current scope (see Interface, Class Declaration, and Class Implementation).\n\nIf the domain on the right hand side denotes an interface or a compound domain, then the defined domain is synonym (i.e. identical) to the type expression. Otherwise the defined domain becomes a subdomain of the domain denoted by the domain expression. Here a domain name DomainName should be a lower case identifier.\n\nThere are certain places where you must use a domain name rather than a type expression:\n• as a type of a constant or a fact variable;\n\nThe full range of DomainExpressions can only be used in a domain definition. TypeExpression is a subset of these expressions that are used in other many other contexts.\n\nA type name is either an interface name or the name of a value domain. We use the term value domain to specify domains whose elements are immutable (unchangeable). Here we can say that objects, belonging to domains correspondent to interface names, have mutable state and terms of any other domains are immutable. So actually value types are everything except object types. A type name (obviously) denotes the type corresponding to the name of an existing domain.\n\nHere InterfaceName is an interface name, DomainName is a value domain name, and ClassName is a class name.\n\nCompound domains (also known as algebraic data types) are used to represent lists, trees, and other tree structured values. In its simple forms compound domains are used to represent structures and enumeration values. Compound domains can have a recursive definition. They can also be mutually/indirectly recursive.\n\nHere IntegralConstantExpression is an expression, which must be compile time evaluated to an integral value.\n\nA compound domain declaration declares a list of functor alternatives with optional alignment. Alignment must be 1, 2 or 4.\n\nIf a compound domain consists of one functor alternative, then it is considered as structure and has representation, which is binary compatible with the appropriate structure in language C.\n\nHere FunctorName is the name of a functor alternative it should be a lower case identifier.\n\nHere ArgumentName can be any upper case identifier. The compiler ignores it.\n\nCompound domains have no subtype relations to any other domains.\n\nIf a domain is defined as being equal to a compound domain, then these two domains are synonym types rather than subtypes. Meaning that they are just two different names for the same type.\n\nIn the example above we used parenthesis after the null-ary function empty. Such parenthesis are optional in all situations, except in a domain definition consisting only of a single null-ary functor. In that case parenthesis are required to distinguish it from a synonym/subtype definition.\n\nList domains represent sequences of values of a certain domain. Thus, all elements in a T list must be of type T.\n\nT* is the type of lists of T elements.\n\nThe following syntax is used for lists:\n\nHere Tail is a term which should have a value of the ListDomain type. Each Term should be of typeName type.\n\nActually, lists are just compound domains with two functors: [] denoting the empty list and the mix-fix functor [HD|TL] denoting the list with head HD and tail TL. The head must be of the underlying element type, whereas the tail must be a list of relevant type.\n\n[E1, E2, ..., En] is shorthand for [E1, E2, ..., En | [] ], which in turn is shorthand for [E1 | [ E2 | [ ...[ En | [] ]...] ] ].\n\nValues of a predicate domain are predicates with the same \"signature\", i.e. the same argument and return types, the same flow pattern and the same (or stronger) predicate mode.\n\nThe details concerning predicate domains are described in Predicate Domains.\n\nBut notice that predicate domains that are used in domain definitions (in a domains section) can at most state one flow.\n\nIntegral domains are used for representing integral numbers. They are divided in two main categories for signed and unsigned numbers. Integral domains can also have different representation size. The predefined domains integer and unsigned represent signed and unsigned numbers with natural representation length for the processor architecture (i.e. 32bit on a 32bit machine, etc).\n\nIf a DomainName is stated in front of the IntegralDomainProperties, then this domain must itself be an integral domain and the resulting domain will be child-type (i.e. subtype) of this domain. In that case IntegralDomainProperties may not violate the possibility of being a subtype, i.e. the range cannot be extended and the size cannot be changed.\n\nAn integral size description declares the size DomainSize of the integral domain, measured in bits. The compiler implement such representation to the integral domain, which has no less than the specified number of bits. The value of DomainSize should be positive and no greater than the maximal value supported by the compiler.\n\nIf integral size description is omitted, then it will become the same as the parent domain. If there is no parent domain, it will become the natural size for the processor.\n\nAn integral range description declares the minimal MinimalBoundary and the maximal MaximalBoundary limits for the integral domain. If a limit is omitted, then the range of the parent domain is used. If there is no parent domain, then the DomainSize is used to determine respectively maximum or minimum value.\n\nNotice that the specified minimum value should not exceed the specified maximum value. That is:\n\nAlso the minimal MinimalBoundary and the maximal MaximalBoundary limits should satisfy the limits implied by the specified bit size bitsize.\n\nThe domain bit size DomainSize value and values of the minimal MinimalBoundary and the maximal MaximalBoundary limits must be calculated while compiling time.\n\nReal domains are used to represent numbers with fractional parts (i.e. floating point numbers). Real domains can be used to represent very large and very small numbers. The built-in domain real have the natural precision for the processor architecture (or the precision given by the compiler).\n\nIf a DomainName is stated in front of the RealDomainProperties, then this domain must itself be a real domain and the resulting domain will be a subtype of this domain. In that case RealDomainProperties may not violate the possibility of being a subtype, i.e. the range cannot be extended and the precision cannot be increased.\n\nThe real precision description declares precision of the real domain, measured in number of decimal digits. If precision is omitted then it will become the same as for the parent domain. If there is no parent domain, then it will be the natural precision for the processor or given by the compiler (in Visual Prolog v.6 the compiler limit is 15 digits). Precision have an upper and a lower limits given by the compiler, if the precisions larger than that limit is used the numbers will only obtain the processor (compiler) specified precision anyway.\n\nHere RealConstantExpression is an expression, which must be compile time evaluated to a floating point value. That is the real domain precision and limits must be calculated while compiling time.\n\nThe real range description declares minimal and maximal limits for the real domain. If a limit is omitted then it will be the same as for the parent domain. If there is no parent domain then the largest possible range for the precision will be used.\n\nNotice that the specified minimum value should not exceed the specified maximum value. That is:\n\nThis section contains the formal syntax for generic domains, for a more complete introduction to generics please see the tutorial Objects and Polymorphism and the section Generic Interfaces and Classes.\n\nA TypeVariable is an upper case identifier. In a domain declaration the type variable must be bound in the FormalTypeParameterList on the left hand side of the domain definition. In a predicate declaration all free type variables are implicitly bound and scoped to that predicate declaration.\n\nA TypeApplication is the application of a typeName to a list of types. The type name must be generic and the number of formal type parameters must match the number of type expressions.\n\nVisual Prolog uses some internal types, called root types and universal types.\n\nA number literal like 1 does not have any particular type, it can be used as a value of any type that contains 1, including real types.\n\nWe say that 1 have a universal type. Having a universal type means that it have any type, which can represent its value.\n\nArithmetic operations are very liberal with their operand requirements: You can add integers of any integer domain with each other.\n\nWe say that arithmetic operands takes root types as arguments. The integer root type is super-type of any integer type (regardless that it is not mentioned in their declarations). Hence any integer type can be converted to the integer root type, and, since the arithmetic operations exist for the root types, it means one of them will work on any integer domains.\n\nThe actual number of root types and which operands exist is a matter of library facilities, and outside the scope of this document to describe.\n\nA constants section defines a set of constants in the current scope.\n\nA constant definition defines a named constant, its type, and its value.\n\nThe ConstantValue should be an expression, which can be evaluated at compile time and it should have the type of the correspondent domain. The ConstantName should be a lower case identifier.\n\nThe TypeExpression can be omitted only for the following built-in domains:\n• Numerical (i.e. integral or real) constants. In this case, the corresponding anonymous numerical domain is adopted for a constant (see the numerical domains for details).\n\nA predicates section declares a set of object or class predicates in the current scope.\n\nThe keyword class can be used only inside class implementations, since:\n• predicates declared in an interface are always object predicates and\n• predicates declared in a class declaration are always class predicates.\n\nThe predicate declaration is used to declare the predicate in scopes in which the predicate declaration can be seen. When predicates are declared in an interface definition, this means that objects of the corresponding type must support these predicates. When predicates are declared in a class declaration, this means that the class publicly provides the declared predicates. And if predicates are declared in a class implementation, this means that the predicates are available locally. In all cases a corresponding definitions of the predicates must exist.\n\nHere PredicateDomainName is the name of a predicate domain declared in a domains section.\n\nOnly class predicates can have link names. If the link name is not stated then a link name is derived from the predicate name, the way this name is derived depends on the calling convention.\n\nA predicate that returns a value is called a function, whereas a predicate that does not return a value is sometimes called an ordinary predicate, to stress that it is not a function.\n\nPredicate domains can have Ellipsis argument as the last FormalArgument in the FormalArgument-comma-sep-list.\n\nPredicate domains can have an AnonymousIdentifier as a formal argument type to specify that the argument can be of any type.\n\nThe specified predicate mode applies for each member of a flow pattern list following it.\n\nPredicate modes can be described by the following sets:\n\nIf Fail is in the set it means that the predicate can fail. If succeed is in the set it means that the predicate can succeed. If BacktrackPoint is in the set it means that the predicate can return with an active backtrack point in it.\n\nIf such a set, say failure, is a subset of another set, say nondeterm, then we say that the mode is stronger than the other, i.e. failure is stronger than nondeterm.\n\n\n\n A predicate domain actually contain all predicates (with correct type and flow), which have the mode specified or a stronger mode.\n\nIt is illegal to state a predicate mode for constructors, they always have the procedure mode.\n\nThe flow pattern defines the input/output direction of the arguments, which in combination with functor domains can be structures with parts of a single argument being input and other parts of the same argument being output.\n\nA flow pattern consists of a sequence of flows, each flow corresponds to an argument (fist flow to first argument, etc).\n\nEllipsis flow must match an ellipsis argument and can therefore be only the last flow in the flow pattern.\n\nA functor flow FunctorFlow states a functor and flows of each of the components of that flow. The functor must of course be in the domain of the corresponding argument.\n\nList flows are just like functor flows, but with the same syntactic sugaring as the list domain.\n\nWhen declaring a predicate the flow can be omitted. Inside an implementation (i.e. for a local predicate) the needed flows are derived from the usages of the predicate. Inside an interface or a class declaration (i.e. for a public predicate) omitting flows means that all arguments are input.\n\nThe special flow pattern anyflow can be stated only in declarations of local predicates (i.e. in predicate declarations inside the implementation of a class). It means that the exact flow pattern(s) will be evaluated during the compilation.\n\nThe calling convention determines how arguments, etc. are passed to the predicate, it also determines how the link name is derived from a predicate name.\n\nIf a calling convention is not stated, then the prolog convention is assumed. The prolog calling convention is the standard convention used for Prolog predicates.\n\nThe calling convention c follows the C/C++ standard calling convention. The link name of a predicate is created from the predicate name by adding a leading underscore (_).\n\nThe calling convention thiscall follows the C++ standard calling convention for virtual functions. This calling convention uses the c link name strategy but sometimes it may use the different argument and stack handling rules. Calling convention thiscall can be applied to the object predicates only.\n\nThe calling convention stdcall uses the c link name strategy but it uses the different argument and stack handling rules. The following table shows the implementation of stdcall calling convention.\n\n\n\n The calling convention apicall uses the same argument and stack handling rules as stdcall, but for convenience to call MS Windows API functions apicall uses the naming conventions that are used by most MS Windows API functions. According to apicall naming conventions the link name of a predicate is constructed as follows:\n• a leading underscore ( ) is prefixed to the predicate name;\n• the predicate name in which the first letter is changed in to a capital letter;\n• the ' ', the ' ' or nothing is suffixed, if the arguments and the return type indicate an ANSI, Unicode or neutral predicate, respectively;\n• on the 32bit platform (x86) the sign @ together with the number of bytes in the argument list is suffixed. But this is not used on the 64bit platform.\n\nIf apicall is used together with the \"as\" construction the name stated in the \"as\" construction is decorated in the same manner.\n\napicall can only be used directly in a predicate declaration, not in a predicate domain definition. In predicate domain definitions stdcall, must be used instead. A predicate declared with apicall calling convention cannot have clauses and it also cannot be resolved externally without explicit DLL name.\n\nThe following table compares implementations of c, apicall, and stdcall calling conventions (the prolog calling convention has the special implementation, which is not discussed here):\n\nVisual Prolog notion of predicate domains covers both class and object members. Class members are handled straight forward, but the handling of object members requires attention. The invocation of an object predicate will get \"back\" in the context of the object to which the member belongs.\n\nSometimes a name must have the _...@N decoration, but the default from apicall is wrong. In such cases decorated, decoratedA and decoratedW can be used to control the decoration:\n\nIn this case the link name will be \"_MyPredicate@4\", where apicall would make it \"_MyPredicateW@4\".\n\nIn this case the link name will be \"_MyPredicateA@4\", where apicall would make it \"_MyPredicate@4\".\n\nIn this case the link name will be \"_MyPredicateW@4\", where apicall would make it \"_MyPredicate@4\".\n\nAll of them change the start of the name from xxxx to _Xxxx and all of them put @N behind. The first never uses a suffix; the second always uses A and the third always uses W. This means that the programmer is responsible for deciding which suffix is needed. But he needs not to worry about calculating argument size and initial \"_X\".\n\nA constructors section declares a set of constructors. The constructors belong to the scope in which the constructors section occurs (see class declaration and class implementation).\n\nConstructor sections can only occur in declarations and implementations of classes that construct objects.\n\nA constructor actually has two associated predicates:\n• An object predicate, which is used when initializing inherited objects.\n\nAn associated constructor object predicate is used to perform an object initialization. This predicate can only be called from the constructor in the class itself and from a constructor in a class that inherits from the class (i.e. base class initialization).\n\nIt is illegal to state a predicate mode for constructors, constructors always have procedure mode.\n\nAn interface can support a subset of another interface by stating the predicates in a predicates from section. The predicates from section names the interface and all supported predicates. The predicates are stated by name or by name and arity.\n\nIf an interface supports a subset of another interface it is neither subtype or super-type related to the other interface.\n\nThe important thing about the predicates from section is that the mentioned predicates retain their origin interface. Therefore:\n• there will be no support conflict with any predicates from the origin interface;\n• they can be inherited as the predicates from the origin interface.\n\nPredicatesFromInterface can only be used in interface definitions.\n\nExtension predicates is a syntactic sugaring, which makes it possible use class predicates as if they were object predicates.\n\nExtension predicates can also be used to give give a more natural code flow for binary operations:\n\nAn extension predicate is a class predicate whose first argument is marked with the attribute [this].\n\nExtension predicates can also be declared for non-object types.\n\nIt is illegal to declare an extension predicate on an interface type if that extension predicate is conflicting with a predicate that exist in the interface itself.\n\nExtension predicates follows the visibility rules of class predicates.\n\nExtension predicates can be qualified with namespace and class:\n\nSeveral suitable extension predicates may be visible in a certain context, and thus cause ambiguity. Qualification can resolve such ambiguity.\n\nA predicate that takes N arguments are said to be N-ary, or to have arity N. Predicates with different arity are always different predicates, even if they have the same name.\n\nIn most situations the arity of a predicate is obvious from the context in which the predicate is mentioned. But in, for example, predicatesFromInterface sections and resolve qualifications the arity is not obvious.\n\nIn order to distinguish between different arities of predicates in predicates from sections and in resolve qualifications, predicate names can (optionally) be stated with arity.\n\nThe following arities are possible:\n• Name/N meaning an ordinary predicate (i.e. not a function) Name of arity N.\n• Name/N... meaning an ordinary predicate Name with N arguments followed by an argument (i.e. a varying number of arguments). ( \"...\" can be used in predicate and predicate domain declarations as the last formal argument. In this case it means that the declared predicate (predicate domain) can have a variable number of arguments. Ellipsis flow must match an ellipsis argument and can therefore be only the last flow in the flow pattern.)\n• Name/N...-> meaning a function Name with N arguments followed by an ellipsis argument.\n\nIn Name/0... and Name/0...->. the zero is optional and can thus be written as Name/... and Name/...->, respectively.\n\nThese attributes are specifically related to predicates\n• in, out and byVal attributes\n\nProperties are named values associated with classes and objects. Actually they are syntactic sugar for get/set predicates for the property value. And in that sense they are a language incarnation of a frequently used programming pattern.\n\nA properties section declares a set of object or class properties in the current scope.\n\nThe keyword class can be used only inside class implementations, since:\n• properties declared in an interface are always object properties and\n• properties declared in a class declaration are always class properties.\n\nIt is possible to get the value of a property that has the (o) flow, and it is possible to set the value of a property that has the (i) flow. If the flow patterns are not stated, both (i) and (o) are assumed, so it is possible bot to set and get the value of such properties.\n\nThough it is legal to state (i) and (o) simultaneously, it is considered better practice to omit them in the get+set case.\n\nIn the sequel we will use the use the following example:\n\nProperties are used like fact variables. It is possible to qualify properties for with a scope name or an object.\n\nA property is implemented by defining a function for getting the value and a predicate to set it.\n\nAlternatively the property can be implemented as a fact variable with the same name as the property.\n\nIn this case the compiler will implicitly provide clauses that implement the get and set predicates.\n\nIt is illegal to have set and get predicates and a fact with the same name, meaning that a property is either implemented by programmer provided clauses or by a fact; mixed implementation is not possible.\n\nAs mentioned above properties are always implemented by get/set predicates even when the program implement them by a fact variable.\n\nAn interface can support a subset of another interface by stating the properties in a properties from section. The properties from section names the interface and all supported properties.\n\nIf an interface supports a subset of another interface it is neither subtype or super-type related to the other interface.\n\nThe important thing about the properties from section is that the mentioned properties retain their origin interface. Therefore:\n• there will be no support conflict with any properties from the origin interface;\n• they can be inherited as the properties from the origin interface.\n\nPropertiesFromInterface can only be used in interface definitions.\n\nA facts section declares a fact database, consisting of a number of facts. The fact database and the facts belong to the current scope.\n\nFact databases can exist on a class level as well as on an object level.\n\nFacts sections can be declared only in class implementations.\n\nIf the fact database is named, an additional compound domain is implicitly defined. This domain has the same name as the fact section and has functors corresponding to the facts in the fact section.\n\nIf the facts section is named, the name denotes a value of the build-in domain factDB. The save and consult predicates accept values of this domain.\n\nA fact declaration declares a fact of a fact database. A fact declaration is either a fact variable, or a functor fact.\n\nA fact functor can have initialization via clauses section. In such case values in the clauses should be expressions, which can be evaluated at compile time.\n\nIf mode is single, then a fact always has one and only one value and the assert predicate overwrites old value with a new one. Predicate retract cannot be applied to single facts.\n\nIf mode is nondeterm, then the fact can have zero, one, or any other number of values. If mode is determ, then the fact can have zero or one value. If fact has zero values, then any read access to it gives fail.\n\nA fact variable is similar to a one-argument single functor fact. However, syntactically it is used as a mutable variable (i.e. with assignment).\n\nThe initialization expression InitialValue must evaluate to a value of Domain type.\n\nThe initialization expression can be omitted (only) if the fact variable is initialized in a constructor. Class fact variables should always have an initialization expression.\n\nThe keyword erroneous can be used as value to be assigned to fact variables. That is both lines below are valid:\n\nThe idea of assigning erroneous value is to give clear runtime error if some code uses uninitialized fact variable by mistake.\n\nVisual Prolog has late initialization of fact variables, meaning that the initialization code for a fact variable is not execute before and unless it is needed.\n\nIf the initialization expression can be evaluated to a constant at compile time then the fact is initialized immediately, rather than late.\n\nLate initialization of facts is threadsafe in the following way: if two or more threads are reading a late fact simultaneously, they will/may potentially all execute the initialization code. But only one of the results will be used as the initial value, and all the threads will receive that value; all the other calculated initialization values will be discarded.\n\nThe attribute immediate can be used to enforce immediate initialization of a fact variable.\n\nFacts can only be declared in a class implementation and subsequently they can only be referenced from this implementation. So the scope of facts is the implementation in which they are declared. But the lifetime of object facts is the lifetime of the object to which they belong. Likewise the lifetime of class facts are from program start to program termination.\n\nA constant fact variable is a fact variable that never changes value after it has been initialized. It can for example be a global \"table\" that initialized at some point and then used for lookup afterwards. Or an \"id\" in an object identifying what the object represents.\n\nA fact variable is a constant fact variable if it is market with the attribute [constant].\n\nA constant class fact variable can only be assigned:\n\nA constant object fact variable can only be assigned:\n\nA clauses section consists of a set of clauses. The clauses section contains implementations of predicates or initial values of facts.\n\nA single clause section can have clauses for several predicates and facts. On the other hand, all clauses for one predicate/fact (the same name and arity) must be grouped together in one clauses section and without intervening clauses of other predicates/facts.\n\nSee also Guards in Monitors.\n\nClauses are used to define predicates. A single predicate is defined by a set of clauses. Each clause is executed in turn until one of them succeeds, or there is no more clauses left to execute. If no clause succeeds the predicate fails.\n\nIf a clause succeeds and there are more relevant clauses in a predicate left, the program control can later backtrack to the clauses of this predicate to search for other solutions.\n\nThus, a predicate can fail, succeed, and even succeed multiple times.\n\nEach clause has a head and optionally a body.\n\nWhen a predicate is called the clauses are tried in turn (from top to bottom). For each clause the head is unified with the arguments from the call. If this unification succeeds then the body of the clause (if such one exist) is executed. The clause succeeds if the match of the head succeeds and the body succeeds. Otherwise it fails.\n\nA clause consists of a head and an optional body.\n\nSee also Guards in Monitors.\n\nThe goal section is the entry to a program. When the program starts it executes the goal, when the goal is executed, the program exits.\n\nThe goal section consists of a clause body. The goal section defines its own scope, therefore all invocations should contain class qualifications.\n\nThe goal must have procedure mode.\n\nThis section describes terms and how execution/evaluation of terms and clauses proceeds.\n\nSemantically, there are two kinds of terms: formulas and expressions.\n• Formulas represent logical statements, like \"the number 7 is greater than the number 3\".\n\nSyntactically the two kinds have a huge overlap and therefore the syntax unites the two kinds into terms.\n\nThe following definition of Term is simplified, in the sense that it includes syntactic constructions that are not legal. For example, one cannot legally write ! + !. We do however believe that using this simple syntax description in combination with intuitive understanding of language concepts, the type system, and the operator hierarchy described below is better for most purposes.\n\nThe evaluation of a Prolog program is a search for a \"solution\" to the goal. Each step in the search for a solution can either succeed or fail. At certain points in the program execution there are more than one possible choices for finding a solution. When such a choice point is met a so called backtrack point is created. A backtrack point is a recording of the program state plus a pointer to the choice that was not executed. If it turn out that the original choice could not provide the solution (i.e. if it fails), then the program will backtrack to the recorded backtrack point. Thereby restoring the program state and pursuing the other choice. The mechanism will be described and exemplified in details in the following sections.\n\nSee also Literals (in Lexical Elements)\n\nVariables in Visual Prolog are immutable: once they are bound to a value they retain that value, but backtracking can unbind the variable again during the process of restoring a previous program state.\n\nA variable can thus be bound (during unification and matching), if it is already bound then it evaluates to the value that it is bound to.\n\nVariables are names starting with an upper-case letter or with an underscore (_), followed by a sequence of letters (both uppercase and lowercase), digits, and underscore characters (all in all called an UppercaseIdentifier):\n\nThe following are examples of valid variable names:\n\nwhile the next two are invalid:\n\nThe variable consisting of single underscore character (i.e. _) is known as the anonymous variable. The anonymous variable is used in patterns and bindings where the corresponding value is of no interest and should be ignored. Every occurrence of the anonymous variable is an independent anonymous variable, i.e. even though the anonymous variable is used several times in a single clause they have no relation to each other.\n\nIf variables that starts with an underscore are not anonymous, but they are still intended for values of no interest that should be ignored. The compiler will issue a warning if the value of such a warning is actually not ignored.\n\nProlog variables are local to the clause in which it occurs. That is, if two clauses each contain a variable called X, these X-s are two distinct variables.\n\nA variable is said to be free when it is not yet associated with a term and to be bound or instantiated when it is unified with a term.\n\nThe Visual Prolog compiler does not make a distinction between upper and lower case letters in names, except for the first letter. This means that the two variables SourceCode and SOURCECODE are the same.\n\nIdentifiers are used to refer to named entities (i.e. classes, interfaces, constants, domains, predicates, facts, ...).\n\nAn identifier can just be a lower case identifier (i.e. a lowercase letter followed by a sequence of letters, numbers and underscore characters).\n\nMany entities can have the same name. So it may be necessary or desirable to qualify the lowercase identifier the name of the particular scope of interest, or to state that the name is in the global namespace.\n\nThe only global entities, which exist in Visual Prolog, are built-in domains, predicates, and constants. Global names are directly accessible in any scope. There might however exist situations where a global name is shadowed by a local or imported name. In that case the global entity can be qualified with a double colon '::' (without a prefixed class/interface name). The double colon can be used everywhere, but the most important place is where an interface name is used as formal parameter type specifier.\n\nStatic members of classes and interfaces are accessed by means of qualification with the class name (and optionally a namespace prefix):\n\nThe ScopeName is the name of the class or interface that defines/declares the name.\n\nNamespace prefixing is explained in: Referencing names in namespaces.\n\nSome names can be accessed without qualification, see scoping & visibility.\n\nThe first term must be an expression that evaluates to a value with predicate type. Typically, it is either the name of a predicate in a class, or an expression that evaluates to a predicate member of an object.\n\nNotice that some predicates return values, whereas other predicates do not. A predicate that returns a value is an expression, and the predicate call is often referred to as a function call. A predicate that does return a value is a formula.\n\nA predicate is invoked by applying arguments to the predicate. The predicate must have a flow-pattern that matches the free/bound state of the arguments.\n\nMost predicates are defined by a set of clauses, but some predicates are built into the language and some are defined externally in a DLL (perhaps in a foreign programming language).\n\nWhen a predicate is invoked by a predicate call, each clause is executed in turn until one of them succeeds, or there are no more clauses left to execute. If no clause succeeds the predicate fails.\n\nIf a clause succeeds and there are more relevant clauses left, a backtrackpoint is created to the next relevant clause.\n\nThus, a predicate can fail, succeed, and even succeed multiple times.\n\nEach clause has a head and optionally a body.\n\nWhen a predicate is called the clauses are tried in turn (from top to bottom). For each clause the arguments in the head is unified with the arguments from the call. If this unification succeeds then the body of the clause (if present) is executed. The clause succeeds, if the match of the head succeeds and the body succeeds. Otherwise it fails.\n\nWhen a predicate is called the arguments from the call is unified with the terms in the head of each clause.\n\nUnification is the process of binding variables in such a way that two terms become equal, making as few bindings as possible (i.e. leaving as much as possible open for further binding).\n\nVariables can be bound to any kind of terms, including variables or terms containing variables.\n\nUnification is either possible or impossible, i.e. it can succeed or fail.\n\nVariables and terms to which they are unified have types, a variable can only be bound to a term of the same type as the variable, or a subtype. When two variables are bound to each other they must therefore have exactly the same type.\n\nUnification takes place (as mentioned) between a predicate call and the clause head. It also takes place when two terms are compared for equality.\n\nIn the example above T1 could have been a predicate call and T2 a clause head. But they could also have been two terms that were compared with equal \"=\".\n\nMatching is the same as unification except that variables can only be bound to grounded terms. A grounded term is a term that does not contain any unbound variables.\n\nIt is the flow-patterns that are stated for predicates, that make it possible to use matching rather than full-blown unification.\n\nTerms that have to be unified or matched with each other are allowed to contain sub-terms that are actually expressions or function calls that have to be evaluated before the unification/matching can be completed.\n\nThe evaluation of such sub-terms is done on a by-need basis.\n\nIn a predicate call all input arguments are evaluated before the predicate is called, all output arguments are variables, which does not need evaluation.\n\nClause heads can also contain terms that have to be evaluated, before matching/unification can be determined.\n• all matching/unification that does not require any evaluation is performed before any evaluation is performed;\n• then evaluation corresponding to input arguments is performed one by one left-to-right. Comparing each value to the corresponding input after each evaluation;\n• then the clause body is evaluated;\n• then the output arguments are evaluated (left-to-right);\n• then the return value (if the predicate is a function) is evaluated.\n\nIf any of these fail then the rest of the evaluation is not carried out.\n\nAll in all the base principles are:\n• input after other match, before body evaluation\n\nThis section describes named, default, optional parameters and functor originals. Even though these notions are individual they also have a significant impact on each other and therefore they are described together.\n• Named parameters: In a call the actual arguments can be supplied by formal parameter name rather than position.\n• Default parameters: A default parameter value can be stated together with a formal argument in a predicate declaration. This value is used when no actual parameter is supplied.\n• Optional parameters: An actual parameter is optional and can therefore be skipped.\n• Functor originals: Functor term which is used as/bound to the original of another functor term (in a functor term expression).\n\nThe formal parameter names from a declaration can be used to specify the actual arguments in a call by using the syntax :<Formal> = <Actual>.\n\nA default parameter is defined by adding = <value> after a formal input parameter in a declaration (<value> can be a constant expression, a property or predicate call).\n\nNotice that it is illegal to provide default parameters for [out] parameters.\n\nIf a parameter is [out] or if it has a default value, then the actual argument is optional and can be skipped provided that it is the last argument in the call. Skipping an [out] parameter corresponds to supplying an anonymous variable for that parameter. Skipping a parameter that has a default value corresponds to supplying the default value for the parameter.\n\nAn optional out parameter can cause conflict with another predicate:\n\nThe attribute [mandatoryOut] can be used to avoid such conflicts and/or if it doesn't seem appropriate that a predicate a has optional output parameters.\n\nA functor original is a syntactic construction that describes an original for a functor term expression. Syntactically it takes the following form:\n\nThe functor original can either be a a functor value or a free variable. In both cases the construction indicates that the functor may have more arguments than those mentioned explicitly in front of the bar.\n\nIf the functor original is a functor value then it will be used as original for constructing a new functor value.\n\nThe functor original can be any kind of term as long as it evaluates to an appropriate functor term.\n\nIf a functor domain has more than one alternative, then the functor original must be of same kind as the term that is constructed.\n\nIn a functor match the functor original can be an anonymous variable. And in that it simply indicates that the term can have more components which we don't care about.\n\nIn a functor match the functor original can be a named variable. If the variable is bound then it is used as an original for constructing a functor value and then that functor value is used in the match.\n\nIf the functor original is a free variable (in a functor match) then that variable will be bound to the entire functor term:\n\nAssign operator := is used to assign a new value for a fact variable FactVariable. The Term must be evaluated to a value of suitable type (i.e. the same type as the fact variable, or a subtype).\n\nA fact database contains a number of fully instantiated (grounded) predicate heads corresponding to the facts from the facts section declaration. The facts can be accessed by a predicate call, using the fact name as the predicate name. The predicate call is matched against each fact in turn; succeeding with a possible backtrack point to the next fact each time the predicate call match the fact. When there are no more facts in the fact database then the predicate call fails.\n\nNew facts can be asserted using the predicates assert/1, asserta/1, and assertz/1. assert/1 is the same as assertz/1 and it asserts a new fact to the end of the list of facts, whereas asserta/1 asserts a new fact to the start of the list.\n\nExisting facts can be retracted with the predicate retract/1 and retractAll/1. retract/1 retracts the first fact that match the argument binding variables in the argument and leaving a backtrack point so that more facts will potentially be retracted when backtracking.\n\nretractAll/1 retracts all facts that matches the arguments and succeeds without any binding.\n\nOperators are organized in a precedence hierarchy. In the rule below operators in each group have same precedence, which is higher than those below. I.e. the power operator has higher precedence than unary minus and plus, which in turn has higher precedence than the multiplication operators, etc. Parenthesis can be used to circumvent the precedence (and for clarification).\n\nAll operators except the UnaryOperator's are binary. The power operator is right associative, all other operators are left associative.\n\nRelationOperator, MustUnifyOperator and InOperator have same precedence.\n\nNotice that the placement UnaryOperator is not consistent with mathematics, where these operators are at the same level as the AdditionalOperator's. The difference has no influence of the calculated value, but it allows writing 2*-2, where mathematics would require a parenthesis around the second operator 2*(-2). It also means that -2*2 is mmeans (-2)*2 where it would be -(2*2) in mathematics (the resulting value is the same).\n\nThe arithmetic operators are used for arithmetic operations on numbers. They are expressions, which takes expressions as arguments. They have root types as arguments and return universal types as result. (See Universal and Root types.)\n\nThe relational operators are formulas, which takes expressions as arguments. Given this nature they are non-associative.\n\nFirst the left term is evaluated, then the right term is evaluated and then the results are compared.\n\nNotice that <> (different) is not the dual operation of = (equal). <> compares two values, whereas = tries to unify two terms (in the general case at least).\n\nThe dual to expression A = B is not (A = B).\n\nThe must unify operator is a procedure, which takes expressions as arguments. It is non-associative.\n\nA == B unifies A and B; if the unification fails an exception is raised, otherwise the predicate succeeds. Therefore A == B always succeeds.\n\nThe following operators for bitwise operations on unsigned, unsigned64 and unsignedNative.\n\nThe logical operations (**, ++, ^^ and ~~) can also be used on boolean values.\n\nThe shift operations discard bits that is shifted out of the number, and shift-in zero bits in the opposite end.\n\nThe AndOperator(s) and OrOperator(s) are formulas, which takes formulas as arguments. They are all left associative. The , and and are synonyms and so are ; and or.\n\nThe evaluation of an and term A, B proceeds as follows. First the left sub-term A is evaluated. If this evaluation fails, the whole and term fails. If A succeeds then the right sub-term B is evaluated. If this evaluation fails, the whole and term fails, otherwise the and term succeeds.\n\nThus the second sub-term B is only evaluated, if the first sub-term A succeeds.\n\nThe evaluation of an or term A; B proceeds as follows. First a backtrack point to the second term B is created and then the first term A is evaluated. If the evaluation of the first term succeeds, then the whole or term succeeds and is left with a backtrack to the second term B. If the evaluation of the first term fails, the backtrack point to the second term is activated.\n\nIf the backtrack point to the second term B is activated (either because the first term fails, or because something later in the execution invokes the backtrack point), then the second term B is evaluated and the whole or term will succeed if B succeeds.\n\nThus an or term can succeed with a backtrack point and the second sub-term B is only evaluated on backtrack.\n\nUsing parentheses or can be nested deeply in clauses.\n\nWe recommend careful usage of or. It is mainly intended for usage in test-conditions:\n\nor is a nondeterministic construction, but orelse can be used as a deterministic pendant:\n\norelse is a deterministic pendant to the nondeterministic or. A orelse B will succeed if A succeeds or if B succeeds, but it will not leave a backtrack point to B if A succeeds.\n\nThe evaluation of an orelse term A orelse B proceeds as follows: First a backtrack point to the second term B is created and then the first term A is evaluated. If the evaluation of the first term succeeds then the backtrack to the second term (and any backtrack point within it) B are removed again and the whole orelse term succeeds. If the evaluation of the first term A fails, the backtrack point to the second term B is evaluated.\n\nSo an orelse term does not leave a backtrack point.\n\notherwise is an expression operator; though it has control flow that makes it resemble the logical operators.\n\nis an expression (A and B must be expressions). If the evaluation of A succeeds by evaluating to the value VA then A otherwise B evaluates to VA, otherwise (i.e. if the evaluation of A fails) then A otherwise B will be the result of evaluating B.\n\notherwise is right associative:\n\nIt has lower precedence than all other expression operators, but higher than relational operators:\n\ncore have been enriched with a predicate isSome for providing default values for core::optional matching:\n\nThe not/1 takes a term as the argument. The evaluation of not(A) first evaluates A. If A succeeds, then not(A) fails, if A fails, then not(A) succeeds.\n\nNotice that not(A) will never bind any variables, because if not(A) succeeds then A has failed, and a failed term does not bind anything. If not(A) on the other hand fails, it cannot bind any variables either, because then the term itself failed.\n\nAlso notice that not(A) can never succeed with backtrack points, because if not(A) succeeds then A have failed, and a failed term cannot contain any backtrack points. This in turn means that all possibilities of success in A have been exhausted.\n\nCut \"!\" removes all backtrack points created since the entrance to the current predicate, this means all backtrack points to subsequent clauses, plus backtrack points in predicate calls made in the current clause before the \"!\".\n\nA cut scope is a scope to which the effect of a cut is limited. Meaning that if a cut is met within a cut scope then only backtrack points within that scope are discarded, while backtrack points outside (i.e. prior to) the cut scope remains.\n\nThe clauses of a predicate is a cut scope. Meeting a cut will (at most) discard the backtrack points that was created after entrance to the predicate. Backtrack points created before entrance to the predicate will remain.\n\nSeveral terms introduce cut scopes (see the respective terms: list comprehension, if-then-else, foreach). Here we will use if-then-else to illustrate the effect of cut scopes. Consider the schematic if-then-else term:\n\nThe condition Cond is a cut-scope, meaning that a cut inside Cond will only have effect inside Cond. Cuts inside T1 and T2, on the other hand, have effect outside the if-then-else statement.\n\ngetMember_nd is a nondeterministic predicate. The evaluation of this code will go as follows. First X is bound to 3 and getMember_nd leaves a backtrack point (so that X can later become 1 and then even 2).\n\nThen we evaluate the condition in the if-then-else term. The first part of this condition succeeds as 3 is a member of [3,3]. The first part also leaves a backtrack point, so that it can be examined whether X is a member several times.\n\nNow we meet a cut. This cut is inside the condition part of an if-then-else statement, so it only has local effect, meaning that it only discards the backtrack point in the second getMember_nd, but leaves the backtrack point in the first getMember_nd predicate.\n\nThe whole condition succeeds and we enter the then-part and write out \"3\".\n\nAfter the if-then-else we meet fail, which backtracks us to the first getMember_nd.\n\ngetMember_nd then binds X to 1, and leaves a backtrack point (so that X can later become 2).\n\nThen we evaluate the condition in the if-then-else term. The first part of this condition fails as 1 is not a member of [3,3]. So we enter the else-part.\n\nHere we meet a cut. This cut is in the else-part of a conditional term so it has effect outside the if-then-else term and subsequently it discards the backtrack point in the first getMember_nd.\n\nWhen we meet the fail after the if-then-else term there are no more backtrack points in the code and it will fail. So all in all X never becomes 2.\n\nfail/0 and succeed/0 are two built-in nullary predicates. fail/0 always fails and succeed/0 always succeeds, besides this the predicates have no effect.\n\nThe in operator is used to test for member ship of a collection (e.g. a list) and to nondeterministically generate the members of a collection.\n\nThe in operator can be defined for any domain and interface using the in_test and in_iterate attributes.\n\nThe in_test(<predicate name>) attribute defines the predicate that is used as in-test for a certain domain or interface. Likewise the in_iterate attribute defines the predicate that is used as in-iterator for the domain/interface.\n\nFor a domain <collection> the predicate must have the type:\n\nFor a domain <collection> the in_test and in_iterate predicate must fulfill these schematic declarations:\n\nFor an interface <collection> the in_test and in_iterate predicate must fulfill these schematic declarations:\n\nThe in operator is predefined on list domains, and in PFC the collections have suitable attributes.\n\nThe list comprehension term is a list expression. Consider this schematic term:\n\nGen is (typically) a nondeterm term. Exp is evaluated for each solution of Gen, and the resulting Exp's are collected in a list. The Exp corresponding to the first solution of Gen is the first element in the list, etc. This list is the result of the list comprehension term. Exp must be procedure (or erroneous). Both Exp and Gen are cut scopes.\n\nThe list comprehension (normally) reads: The list of Exp's such that Gen.\n\nAn anonymous predicate is an expression that evaluates to a predicate value. The predicate value can be bound to a variable, passed as arguments or returned as result, but the value does not have a name in any class, interface or implementation.\n\nAnonymous predicates have the ability to capture values from the context in which the expression occurs, this is a rather powerful ability that can be used to avoid rather excessive amount of strange/unpleasant code.\n\nAn anonymous predicate is a nameless clause in curly brackets. Certain parts are optional, giving these forms:\n\nLeaving out the argument list means \"the required number of arguments\" and can be used whenever the arguments are not used.\n\nAn anonymous predicate expression evaluates to a predicate value. Consider this code:\n\nInc becomes an increment predicate, so the program will write:\n\nThe code in this example corresponds to this code:\n\nWhere the clause (X) = X+1 can be found in the last line. I.e. this time in a named predicate.\n\nVariables that are bound outside (i.e. before the occurrence of) an anonymous predicate can be used inside the anonymous predicate. The value of variable will be captured by the anonymous predicate.\n\nVariables that are bound in an anonymous predicate are local variables in the anonymous predicate.\n\nAn anonymous predicate can capture context, which means that it can refer to things that are defined in its context, especially facts and variables from the clause.\n\nAnonymous predicate occurs in a clause, and this clause may contain variables. Those variables that are bound before the anonymous predicate is met can be used inside the anonymous predicate. This code illustrates how a variable is captured:\n\nWe call createAdder with 17 as argument. So in the createAdder clause A is 17, and therefore the result is { (X) = X+17 }. We say that the anonymous predicate has captured the variable A.\n\nSince Add17 is a predicate that adds 17 to its argument, the output of the code will be:\n\nAn anonymous predicate can capture the ellipsis variable (i.e. ...):\n\nW captures the ellipsis variable. qqq receives a zero-arity predicate, when this predicate is invoked the captured ellipsis variable will be written to the standard output device.\n\nAn anonymous predicate can access facts. If it is created by a class predicate it can access class facts. If it is created by an object predicate it can access both object and class facts. Consider this code that captures a class fact:\n\nBoth A and B increment the class fact count, so the result is\n\nIn object predicates we can capture object facts. So assuming that seq is an object predicate in myClass, this code illustrates the capture of an object fact:\n\nIn this case A and B comes from two different objects, which each have a count fact, so the output will be:\n\nTechnically, the class version actually doesn't capture anything, it merely have access to the fact. Likewise, the object version doesn't actually capture the fact, instead it captures This and through This it obtains access to the object facts.\n\nAs described above it is possible to capture This and thereby gaining access to objects facts. The same mechanism gives access to calling object predicates.\n\nThis can also be used directly:\n\nTo obtain Q we call P with 3300, so A is 3300 and Q therefore becomes { (B) = 3300+B } }, likewise R becomes { (B) = 2200+B } }. So, the output is:\n\nIf you don't need the arguments they can be skipped. So this code-fragment:\n\nNotice that the arguments are completely skipped. If you write () it means zero arguments, whereas skipping the arguments means \"a suitable amount\" of arguments.\n\nThis section shows some cases where anonymous predicates are very handy. The examples assume that the PFC scopes core, std, stdio, list and string are open.\n\nIn cases where you need a predicate and have one that is almost suitable, you can make the adaptation using an anonymous predicate.\n\nIndexer implements an \"array\" of strings, write3 will write the three strings found at the indexes 0, 1 and 2. So write3 assumes that the \"array\" index is zero-based. However, the \"array\" we have uses a one-based index:\n\nBut using an anonymous predicate we can easily adapt the one-based array to the zero-based usage:\n\nSo we get the expected output:\n\nIn this code listChildren will call a ChildWriter predicate for each \"C is the child of P\"-pair:\n\nWe will however prefer to list the \"P is the parent of C\" using the predicate wParent:\n\nwParent takes the arguments in the opposite order, but we can easily adapt using an anonymous predicate:\n\nAnd then the out becomes the expected:\n\nWe can also throw away arguments, for example when calling this predicate that only needs a Child:\n\nThe adaptation looks like this:\n\nThe output will be:\n\nWe can also supply dummy arguments:\n\nHere addChildren will \"add a count of children to P\". Since each invocation corresponds to one child we will call addChild supplying 1 as a \"dummy\" argument. The More is thus an adaptor that both throws away an argument and supplies a dummy argument.\n\nFilter is used to filter the list [1,2,3,4,5,6,7,8,9]; the filtered list and the Label are written to the standard output.\n\nFirst we use the allow-all filter:\n\nThis filter simply succeeds for any element, so the output is the entire list:\n\nIt is just as easy to create a filter that fails for all elements and thus allow-none:\n\nThe output from this is the empty list:\n\nWe can also create filters for elements greater than 3 and elements dividable by 3:\n\nThe output from this is:\n\nThe list package has a sort predicate. But sometimes the default order is not what you need. Therefore the list package also has a predicate sortBy, which sorts the elements using a programmer defined compare operation. Let us first consider string sorting, using this predicate:\n\nWe can call the predicate with the \"normal\" comparator, and using an anonymous predicate we can easily sort it descending as well:\n\nThe output looks like this:\n\nLet us also sort some more complex elements. Here a person has a first name and a last name, using this domain:\n\nFor the demonstration we will use this test predicate:\n\nAgain we can sort using the normal and a descending comparator:\n\nSince the compare predicate uses left-to-right lexicographic order on the p-functor, the result is the same as before:\n\nBut with the more complex domain we can create a comparator that will sort on last name:\n\nThe result is what we expect:\n\nAs mentioned a very powerful feature of anonymous predicates is the ability to capture context. The examples in this section show some ways you can use this.\n\nThe routine for starting a thread takes a null-ary predicate and runs it in the new thread. But you nearly always need to pass some input data to the job in the new thread. This is possible in several ways, but the absolutely simplest way is to use anonymous predicates. The project bgDemo from the Visual Prolog example collection (that can be installed from the IDE) use this method. The project has a form that can start a background job and display status information from the job in a jobControl that is added to the form. A background job is a predicate that will receive a jobLog, which it can use to report status and completion degree:\n\nA jobLog looks like this:\n\nThe job can report completion degree by setting the completion property (range 0 to 1). Likewise, the status property can be used to reflect the current status of the job.\n\nThe status and completion will be shown in the form together with a job name. A job is started by calling the form's addJob predicate:\n\nIn this context it is the last three lines that are interesting. thread::start takes a null-ary predicate as argument, but a job is a predicate that takes a jobLog as argument. Therefore we create an anonymous predicate Action, which takes no arguments but invokes Job on the JobLog. The anonymous predicate has captured both Job and JobLog from the context, and subsequently both these values are transferred to the new thread even though this thread only receives a null-ary predicate. The jobs in the bgDemo project are merely dummy jobs that only manipulate their jobLog. One of them looks like this:\n\nIt has two loops which run from From to To and calculates the completion and sets it on the Log. It also sets the status text before, between and after the loops. You may notice that the job does not have the proper job type, because a proper job only has one argument (the jobLog), this job has three arguments. Again it is anonymous predicates that help us. The code that adds the jobs to the form looks like this:\n\nIn a more realistic program, it is most likely that From and To would not be constants, but rather parameters passed from some outer place. In that case these anonymous predicates would also capture variables from the context. The jobLog in the bgDemo illustrates one more usage of anonymous predicates. The jobLog pass the completion and the status information to a jobControl. The jobControl is a GUI control on the jobForm capable of doing a suitable rendering of the information. This however gives a synchronization problem, because GUI controls are not thread safe and here we want to update some controls from a background thread. This can lead to conflicts, because it is the main thread that draws the controls. The solution is to make transfer the the update of the control to the GUI thread. We do this by posting actions to the control. The implementation of the status update looks like this:\n\nAction is a null-ary predicate that will set the status in the jobCtrl. We post this action to the jobCtrl. When the jobCtrl receives the action it invokes it and is thus updated. This way, the actual update of the control will be performed by the GUI thread. This anonymous predicate not only captures the Status variable it also captures the jobCtrl fact.\n\nAssume that we send commands to a remote service. The command execution is asynchronous, so when we execute a command we also give a callback action which will be invoked when the execution of the command is finished. To execute a command we must call this predicate:\n\nBased on this predicate we want to create a similar predicate that can execute a list of commands. A certain command should be executed when the previous command completes. We will also make our list executor asynchronous, so we supply an action that will be invoked when the entire script of commands are finished. Our script executer will have the form:\n\nIf the script is empty we simply invoke the OnDone action. If the script has a command H and a rest script T, we must first execute H, and when it is finished we must execute the rest of the script T. So the OnDone action we supply when executing H must execute T. All in all, the implementation can look like this:\n\nWe have used an anonymous predicate to perform the execution of the rest of the script. This anonymous predicate captures T and OnDone.\n\nWhenever we have a reference to an object, we can access the object member predicates of that object.\n\n(Currently, the term must be a variable or a fact variable).\n\nThe identifier must have the type of the term.\n\nInside an implementation object member predicates can be invoked without reference to an object, because \"This\" is subsumed, see Scoping.\n\nAn object expressions is an expressions that evaluates to an object. Like anonymous predicates it can capture values from and access facts in the context it appears in.\n\nThe syntax is like a regular class implementation without a name, but with a construction interface:\n\nthe implement ... end implement part is an object expression. To make object expressions a lightweight construction the keyword clauses is implicit/optional at the beginning of the scope (unless the scope has open, supports or inherits qualifications).\n\nThere will be exactly one constructor new\\0. Like for other objects you don't need to supply an implementation if the constructor is 'trivial'.\n\ninherits, supports, open, delegate and resolve works in the same way as in regular implementations.\n\nThe predicates can refer to the context like anonymous predicates but can also refer to facts and inherited classes inside the object.\n\nObject expressions are nested within other scopes, these scopes are all visible from the object expression. If a name is defined in more than one surrounding scope then the reference is to the closest level. Names from named scopes can be resolved with the scope name, but names from surrounding object expressions must be resolved by means of a variable as described in the \"This\" section.\n\nIn a predicate in an object expression the variable This represent the object of the object expression. There are no predefined names for surrounding This variables. So if you want to refer to an outer This you will have to put it in another variable e.g. Outer = This and then use that variable inside the object expression.\n\nOccasionally there will be situations where we will need a type variable. An example would be a predicate p : () -> observer{A} implemented using an object expression. Unfortunately, this is not possible until we get access to the type variables of polymorphic constructions.\n\nThe examples below will be based on iterator object.\n\nWhich we will write using this predicate:\n\nDomains, functors, and constants are all accessed as if they are class members. Even if they are declared in an interface. This means that when they are qualified, then they are always qualified with class/interface name and a double colon.\n\nGen is (typically) a nondeterm term. Body is evaluated for each solution of Gen. If/when Gen fails the foreach-term succeeds without evaluating Body. Body must be procedure (or erroneous). Gen and Body are both cut scopes.\n\nThe main (and important) difference is that a foreach-term succeeds after the iteration, whereas a fail loop fails. As a result foreach-terms can be followed by other terms and they can be properly nested.\n\nif-then-else can be used both as a statement and as an expression.\n\nThe following two terms are equivalents.\n\nConsider the schematic if then else term:\n\nFirst Cond is evaluated, if it succeeds then T1 is evaluated otherwise T2 is evaluated.\n\nCond is followed by an implicit cut, which turns:\n\nFor readability sake, we always recommend using \"or\" instead of \";\". Likewise we also recommend using \"and\" (instead of \",\") when it (as in the condition above) represents a logical \"condition\" rather than a \"sequentation\".\n\nLeaving out the else-part is just shorthand for writing that else succeed, i.e.\n\nSyntactically it is same as the if-then-else statement, but and the terms in the branches must be expressions and the entire if-then-else expression will itself evaluate to a value.\n\nThe shorthand writings that leave out the else-part does not make sense for the expression.\n\nThe try-catch-finally statement provides means for dealing with exceptions that may occur in a given block of code.\n\nA try-construction thus have a Term and a list of catch and finally handlers.\n\nThe Term and the handlers are not allowed to leave backtrack points (i.e. they cannot have mode multi or nondeterm).\n\nA try-construction with more than one handler is equivalent to nesting several try-constructions with one handler each. I.e. the following term:\n\nIs equivalent to these nested terms:\n\nIf Body fails or succeeds the whole try construction fails or succeeds, respectively. I.e. if Body does not terminate with an exception the try construction corresponds to evaluating Body.\n\nIf Body terminates with an exception, then the exception is caught by the catch handler. Meaning that first Var is bound to the exception (in PFC context the exception will be a traceId) and then Handler is evaluated. In this case the construction behaves as if Handler is evaluated with Var bound to the caught exception.\n\nNotice, that no bindings are made by Body if it terminates with an exception.\n\nThe purpose of the construction is to evaluate the Handler after the Body no matter how the Body terminates, i.e. whether it succeeds, fails or terminates with an exception (it cannot leave backtrack points).\n\nThe evaluation is like this\n• If succeeds: is executed and the try-finally construction succeeds.\n• If fails: is executed and the try-finally construction fails.\n• If terminates with an exception : is executed and the try-finally construction terminates with the exception .\n\nAn interface defines a type of objects, all objects that supports the interface have that type. In the sequel we shall use the term the object type as synonym for the term the type defined by the interface.\n\nSince interfaces define types, these types can be used as formal type specifiers in predicate and fact declarations and in domain definitions.\n\nSince an object have the object type of any interface it supports, it can be used as an object of any of these types. I.e. the type of objects is converted to any supported object type. As described below the conversion is in many cases performed automatically.\n\nSo the same object can be viewed as having different types in different contexts. The type with which an object is viewed is called its view type, whereas the type of the class that constructed the object is called the construction type or definition type. The construction type is also a view type.\n\nAs mentioned above objects can be used as having the type of any supported interface. This section describes how conversions between various supported types is handled.\n\nIf some term is statically typed to some type T1 and T1 is declared to support T2 then it is obvious that any object referenced by the variable will indeed support T2. So upward support information is statically known. Subsequently all conversions upwards in the support hierarchy is performed automatically.\n\nSeveral conversion predicates are available.\n\nThe predicates convert/2-> and tryConvert/2-> are used to perform safe conversion from one type to another type.\n\nNeither predicate can be given a real declaration, but here are pseudo declarations for them\n\nBoth convert/2-> and tryConvert/2-> take a \"type\" as the first argument and a value of any type as the second argument and will then return the converted value as the result.\n\nconvert/2-> will raise an exception if the conversion is impossible, while tryConvert/2-> simply fails in that case.\n\nNotice that the use of convert/2-> and tryConvert/2-> is always superfluous, if the source type is a subtype of the target type, because then the conversion will be performed implicitly.\n\nconvert/2-> and tryConvert/2-> can be used in the following situations:\n• converting from one number domain to another number domain\n• converting an object to another type\n\nThe compiler may complain (but does not have to) if it can determine that a conversion can never succeed, for example if attempting to convert between number domains that does not have overlapping ranges.\n\nWhen an object is converted to a super type (i.e. to a supported interface), then information about the object is \"forgotten\". Notice that the capabilities are not really lost they are just not visible in the context where the object is seen with a less capable interface.\n\nIn many situations it is necessary to restore the actual capabilities of the objects. Therefore, we need to be able to convert them downward as well as upwards.\n\nDownward conversion cannot (in general) be validated statically. Therefore, it is necessary to use explicit conversion when restoring \"lost\" interfaces.\n\nWhen an object is created with a constructor it is returned with the construction type. Such an object can automatically be converted to any supported interface and explicitly back again.\n\nEven if the class that implements the object have stated further supported interfaces privately it is impossible to convert the \"public\" object to any of these private types.\n\nIn the implementation however the object can be accessed with any privately supported type. Furthermore \"This\" can be handed outside the implementation with any of these privately supported types.\n\nSuch a \"private\" version of an object can also be converted implicitly upwards in its hierarchy and explicitly downwards again. In fact such a \"private\" object can be converted explicitly to any publicly or privately supported interface.\n\nSo an object have two views the public view and the private view. The private view includes the public type. The object cannot be converted from one view to another, but since the private view includes the public type, the private view can be converted to any supported type whatsoever.\n\nThe predicate uncheckedConvert/2-> is used to perform unsafe conversions based on memory representation. The predicate does not modify memory in any way, it simply forces the compiler to interpret that piece of storage with another type.\n\nNotice this predicate is highly unsafe and should be used with maximum precautions.\n\nThe predicate is intended to be used when interfacing to foreign languages, in order to interpret the memory images these foreign languages uses.\n\nuncheckedConvert/2-> can only be used on pieces of memory that have exactly the same bit-size. However many kinds of data are represented by a pointer and such data have the same bit-size.\n\nThis section describes the low level constructions for dealing with exceptions in Visual Prolog. PFC does however put a higher level layer on top of this low level mechanisms (see the tutorial Exception Handling).\n\nThe basic part of the exception handling system is based on the built-in predicate errorExit/1 and the try-catch language construction.\n• try-catch sets an exception handler for a certain computation.\n\nWhen errorExit/1 is called the currently active exception handler is invoked. This exception handler is executed in its original context, i.e. in the context where it was set rather than in the context where the exception is raised.\n\nThe argument that errorExit/1 is invoked on is transferred to the exception handler. This argument must somehow provide the needed description of the exception.\n\nTogether with additional runtime routines, it is possible to build high-level exception mechanisms on top of this system.\n\nIt is however out of the scope of this document to describe runtime system access routines.\n\nIt is likewise out of the scope of this document to describe how the runtime system deals with exceptions occurring inside the runtime system.\n\nThe first argument of try-catch is the term to execute with new exception handler. The second argument must be a variable. This variable will be bound to the value errorExit/1 is invoked on, if it is invoked while this exception handler is active. The third argument is the exception handler, which will be invoked if errorExit/1 is called while this exception handler is active.\n\nThe exception handler can access the variable stated in the second argument thereby examining the exception that was raised.\n\nIf an exception is raised while executing dangerous, then Exception will be bound to the exception value, and control will be transferred to the third argument of try-catch. In this case Exception is passed to handleDangerous.\n\nVisual Prolog contains an embedded hidden class, which provides declarations and implementations to all built-in constants, domains, and predicates.\n\nThese built-in constants, domains, and predicates can be used both during compilation (for example, in #if ... constructions) and in implementations (which are supported for runtime).\n\nEach compilation unit implicitly contains the declaration of this embedded hidden class. To disambiguate from other entities with the same name you can use \"::\" before names of built-in items.\n\nNotice that the clause variable This is automatically defined in the clauses for object predicates.\n• The operators are listed from highest to lowest precedence\n• All division and multiplication operators have same precedence.\n• The power operator and are right associative.\n• All other operators are left associative.\n\nAll binary operators takes two arguments of same base type and returns a value of that base type. Operands and result may be converted using ordinary subtype rules.\n\ndiv and quot are different integral division operators.\n• truncates towards minus infinite. is the remainder corresponding to .\n• truncates towards zero. is the remainder corresponding to .\n\nFor positive results div and quot have same functionality.\n\nThe difference can be seen in this table:\n\nCompilation date. Here YYYY means the number of a year, MM means a month number, and DD means a day number.\n\nA compiler version. This value depends upon the compiler version.\n\nDefines the maximal value of \"digits\", which is supported by the compiler.\n\nA constant of type pointer with the value 0.\n\nA constant of type handle with the value 0.\n\nA constant of type handle with the invalid (for a handle) value -1.\n\nThe values of this domain are any terms. Such a value contains the reference to the term type library and a term itself.\n\nThe values of this domain are UNICODE characters. Implemented as 2 unsigned bytes.\n\nOnly assignment and comparison (in the lexicographical sense) operations are applied to the values of this domain. The image of a character has the following syntax:\n\nIn the syntax above HHHH correspond to 4 hexadecimal digits. Also, the backslash symbol and the single quote can be represented by an escape-sequence only.\n\nThe result of a comparison. For instance, the built-in procedure compare/2-> has \"compareResult\" as the domain of its result.\n\nA string represented as a pointer to a zero terminated sequence of characters in utf-16 encoding. Values in the sequence are 16 bits, but certain rare characters (code points) are encoded using two such values. Strings are immutable.\n\nIn source code a string literal can be specified as a set of sequences of characters surrounded by the double quotes.\n\nA string literal consists of one or more StringLiteralPart's, which are concatenated. StringLiteralPart's starting with @ does not use escape sequences, whereas StringLiteralPart's without @ uses the following escape sequences:\n• \\u followed by exactly four 's representing the Unicode character corresponding to the digits.\n\nThe double quotes in the string can be represented by the escape-sequence only (the single quote can be represented both with an escape-sequence and a graphical symbol).\n\nA built-in domain who's elements are sequences of (one-byte) ASCII-characters. It is implemented as a pointer to the zero terminated array of ASCII characters. Only assignment and comparison for equality (in the lexicographical sense) operations are applied to the values of this domain. Currently no literals are allowed for this domain.\n\nUtf-16 strings with same representation as string, but they are also stored in a global symbol table.\n\nA symbol is stored in a global symbol table, and that storage guarenties that the pointer value of symbols will be the same for the same symbol. Once a symbol is put into the symbol table it is never removed again, so symbols are never reclaimed. Their storage will live untill the program terminates. So the symbol data type should not be used for large documents, etc.\n\nThe symbol domain is a subtype of the string domain, so a symbol can be used everywhere instead of a string. The opposite is not the case because a string will have to be found or inserted in the global symbol table to become a symbol. So to create a symbol from a string you will have to convert the string to the symbol domain (or a subtype of the symbol domain).\n\nThe equality operation is very efficient for symbols since their pointer value will be the same if the symbol is the same. I.e. there is no need to compare the actual characters to determine equality.\n\nOther comparison operations (less than, case insensitive comparison, etc) are the same as for string in fact all other operations on symbol is simply carried out by the corresponding string operations.\n\nValues of this domain are used for holding binary data. A binary value is implemented as a pointer to the sequence of bytes that represents the contents of a binary term.\n\nThe length of a binary term is situated in the 4 bytes immediately preceding this sequence of bytes. The 4 bytes contains:\n\nwhere ByteLen - is the length of the binary term and 4 is number of bytes occupied by size field.\n\nOnly assignment and comparison operations are applied to values of binary domain.\n\nTwo binary terms are compared in the following way:\n• If they are of different sizes, the bigger is considered larger.\n• Otherwise, they are compared byte by byte, as unsigned values. Comparison stops when two differing bytes are found and the result of their comparison is the result of the comparison of the binary terms. Two binary terms are equal if they have the same sizes and all bytes are equal.\n\nThe text syntax for binary images is determined by the Binary rules:\n\nEach expression should be calculate on compiling time and its value should be in the range from 0 to 255.\n\nSame as binary, but can contain pointers because it is scanned by the garbage collector.\n\nValues of this domain occupy 4 bytes. Arithmetic operations (+, -, /, *, ^), comparison, assignment, div/2->, mod/2->, quot/2->, and rem/2-> operations are applied to values of this domain.\n\nThe permitted number range is from -2147483648 to 2147483647.\n\nThe syntax for the integer literal is determined by the Integer rule:\n\nThe permitted number range is from -2^63 = -9223372036854775808 to 2^63-1 = 9223372036854775807.\n\nThe syntax for integer64 literal is the same as Integer rule.\n\nThe set of operations for integer64 is similar to the one for Integer.\n\nSigned integer number with platform size (32 bit in a 32 bit program; 64 bit in a 64 bit program).\n\nValues of this domain occupy 4 bytes. Arithmetic operations (+, -, /, *, ^), comparison, assignment, div/2->, mod/2->, rem/2->, and quot/2-> operations are applied to values of this domain.\n\nThe permitted number range is from 0 to 4294967295.\n\nThe syntax for unsigned number images is the same as for integer numbers. The usage of minus sign (UnaryMinus) is not allowed for an image of an unsigned number.\n\nThe permitted number range is from 0 to 2^64-1 = 18,446,744,073,709,551,615.\n\nThe syntax for unsigned64 number images is the same as for integer64 numbers. The usage of minus sign (UnaryMinus) is not allowed for an image of an unsigned64 number.\n\nThe set of operations for unsigned64 is similar to the one for Unsigned.\n\nUnsigned integer number with platform size (32 bit in a 32 bit program; 64 bit in a 64 bit program).\n\nValues of this domain occupy 8 bytes. This numerical real domain is introduced for the user's convenience only. All arithmetic, comparison, and assignment operations are applied to values of real domain.\n\nThe permitted number range is -1.7e+308 to 1.7e+308. Values from integral domains are automatically converted to real numbers when necessary.\n\nThe syntax for the floating-point number literal is determined by the Real rule:\n\nValues of this domain occupy 4 bytes. This numerical real32 domain is introduced for the user's convenience only. All arithmetic, comparison, and assignment operations can be applied to values of real32 domain.\n\nThe permitted number range is -3.4e+38 to 3.4e+38.\n\nThe syntax of real32 literals is the same as real lietrals.\n\nA pointer directly corresponds to memory addresses. Only the equality operation can be applied to the values of this domain. There is a built-in null constant for this type\n\npointerTo{Type} represents a pointer to a value of type Type. It's definition is like this (but it is built-in):\n\nA handle is used for Windows API function call. Values of this domain has the same size as a pointer (i.e. 4 on 32bit platfor and 8 on 64bit platform).\n\nThere are no operations for this domain and cannot be converted (except uncheckedConvert) to/from other domains.\n\nThere is a built-in nullHandle and invalidHandle constant for this type\n\nThis domain is introduced for the user convenience only. It is treated as usual compound domain with the following definition:\n\nThis domain has the following hidden meta-declaration:\n\nAll user-defined names of facts sections are the constants of this domain. The compiler automatically builds the corresponding compound terms from such constants whenever it's in need. At the runtime the 1st field of this structure contains the address of the corresponding domain descriptor and the 2nd field contains either zero (for class facts sections) or pointer to an object (i.e. This, for object facts sections).\n\nThe following predicates are deprecated:\n\nInsert the specified fact at the end of the matched internal facts database\n\nassert(Fact) inserts Fact in the matched internal facts database after any other stored facts for the corresponding database predicate. Fact must be a term belonging to the domain of an internal facts database. assert/1 applied to a single fact changes the existing instance of a fact to the specified one. assert/1 has the same effect as assertz/1. See also asserta/1.\n\nNotice that the combination of retract/1 and assert/1 like the following can lead to endless loop:\n\nThe problem is that the retract in first line will eventually retract the fact asserted in the last line, because that fact is inserted last in the fact chain.\n• Attempt to assert a second instance to a fact declared as determ.\n\nInsert a fact at the beginning of the matched internal facts database.\n\nThe asserta(Fact) predicate inserts a Fact in the matched internal facts database before any other stored facts for the corresponding predicate. The Fact must be a term belonging to the domain of an internal facts database. The asserta/1 applied to a single fact changes the existing instance of a fact to the specified one. See also assert/1 and assertz/1.\n• Attempt to a fact declared as determ, but the fact instance already exists.\n\nassertz does exactly the same as the assert/1 predicate.\n\nTest whether the specified variable is bound to a value.\n\nThe bound(Variable) succeeds if Variable is bound and fails if it is free. The bound predicate is used to control flow patterns and to check the binding of reference variables. The bound predicate treats the specified Variable as bound if any of it's part is instantiated.\n\nThis compile time predicate returns the string ClassName that represents the name of the current interface or class.\n\nComparison of two terms of the same domain, resturns the value of compareResult domain.\n\nThis compile time predicate returns the string ConstantName that represents the name of the current constant. It is typically used in exception definitions.\n\nCall-template for this function is:\n• returnDomain: Specifies a domain to which function convert converts . Here returnDomain must be a name of built-in Visual Prolog domain, an interface domain, a name of such user defined domain that is synonym to one of built-in Visual Prolog domains, a numeric domain, binary and pointer domains. The domain name returnDomain must be specified at compile-time, i.e. it cannot come from a variable.\n• : Specifies the value that must be converted. may be any Prolog term or an expression. If is an expression, then it will be evaluated before the conversion.\n• : Returned parameter will be of returnDomain type.\n\nThe convert predicate performs a clean and genuine conversion of the given InputTerm, returning a new term ReturnTerm of the specified new domain returnDomain. If convert cannot perform the required conversion, it rises errors. The similar functionality is provided by the tryConvert/2-> predicate, but tryConvert-> fails and does not produce any runtime errors if it cannot perform the conversion.\n• Between reference domains and corresponding non-reference domains.\n\nThe contrast to these is uncheckedConvert/2-> predicate, which performs an unchecked conversion between terms from any domains, which have the same bit-size.\n\nThe convert/2-> (or tryConvert/2->) predicate accomplishes a checked explicit conversion, when the source and target domains are statically known during the compilation. The result of an explicit conversion can be one of the following:\n• ok the successful conversion to the target domain;\n• run-time-check the conversion to the target domain with generation of run-time checking for compatibility;\n• Synonyms of domains are converted using the same rules that are applied to the domains themselves.\n• Numerical domains can be converted to the numerical domains only.\n• Integral constants are the representatives of the anonymous integral domain: const .. const .\n• Real constants are the representatives of the anonymous real domain: dig const .. const , where dig is the number of the digits in mantissa without insignificant zeroes.\n• A value of the symbol domain can be converted to the string domain and vice versa.\n• A value of binary domain can be converted to the pointer domain.\n• The domains that are implicitly introduced for interfaces can be converted only to the interface domains according to the rules specified below.\n• All other domains cannot be converted.\n• The range is considered first during such conversion. If the ranges of source and target do not intersect, then an error is produced. If the ranges of source and target only partially intersect, then run-time checking is generated. Also, if one of domains is real and another is an integral one, then the integer range is converted to the real range before the comparison.\n• When input term in real and output is integer, then convert and tryConvert/2-> predicates truncate the input value to the nearest integer value, which is nearer to zero.\n\nPredicate convert/2-> allow to convert any object to any interface type. The actual correctness of such conversion is checked at runtime. When object is created, its type is internally stored, therefore when the object is passed as argument it still remember about its original type. This original type is used for checking allowed conversions. The example:\n\nIf object is created by class, which implements x interface, and then object is passed as parameter of type a to some predicate, then it is allowed to convert the object to b type.\n\nReturns precision of the specified floating-point domain.\n\nCall-template for this function is:\n\nThe input parameter domainName of this compiling-time predicate is a floating-point domain, it should be explicitly specified at compile-time (that is, domainName cannot come from a variable). The predicate returns the number Precision that was determined by the digits attribute in the domain declaration.\n\nThe compiler guarantees that values of the domain domainName will have at least Precision number of significant decimal digits.\n\nPerforms a run-time error with the specified return code ErrorNumber, which can be used in the try-catch-finally.\n\nThe fact_address predicate returns the address (as a pointerTo{FactType}) of a fact variable FactVariable of type FactType.\n\nThe fail predicate forces failure and, hence, always causes backtracking. A clause that fails (with fail or for some other reason) cannot bind output arguments.\n\nCall-template for this predicate is:\n\nThe free predicate succeeds if the specified Variable is free and fails if Variable is bound. The free predicate treats the specified Variable as bound if any of it's part are instantiated.\n\nThis predicate creates the list of terms of the universal type any from the EllipsisBlock ... (i.e. from the special varying parameters block).\n\nCall-template for this function is:\n\nhasDomain is not really a predicate, but more a type declaration/restriction. It has two forms a non-function for declaring/restricting the type of a variable and a function form for declaring/restricting the type of a value.\n\nThe non-function form is called with a type as first parmeter and a variable as second parameter.\n\nThe only effect of the call is that the Variable will be restricted to the type Type.\n\nThe variable can be free, bound or of some mixed flow and the binding of the variable will not change in any way.\n\nThe function form is called with a type as first argument and a value as second argument, and it returns the same value.\n\nThe only effect of the call is to ensure that the Value will be restricted to the type Type.\n\nReturns the lower bound of the specified NumericDomain.\n\nCall-template for this function is:\n\nThe lowerBound is a compiling-time predicate. The lowerBound returns the lower bound value LowerBoundValue of the specified numeric domain domainName. The return value LowerBoundValue belongs to the same domain domainName. The domainName parameter should be the name of any numerical domain; this domain name should be explicitly specified at compile-time (that is, domainName cannot come from a variable). See also upperBound/1->.\n\nIt will give a compile time error if the specified domain domainName is not numeric domain.\n\nThe predicate succeeds if the specified fact variable is erroneous.\n\nCall-template for this predicate is:\n\nThe predicate succeeds if the specified fact variable factVariableName has the erroneous value, otherwise it fails.\n\nRetrieves the value of digits (precision) of the basic domain corresponding to the specified floating-point domain RealDomain.\n\nCall-template for this function is:\n\nThe return maximal number of digits MaxDigitsNumber for the domainName parameter, which should be the name of a real domain.\n\nThe notErroneous/1-> predicate will succeed with the value of a fact if the fact is not erroneous. The main purpose of the predicate is to get an atomic view of the fact in a multi-threaded application.\n\nThis predicate returns the name PredicateFullName of the predicate in which it is invoked. The returned predicate name is qualified with a scope name.\n\npredicate_fullname can only be used inside a clause. Use of predicate_fullname in other places causes a compile time error. See also predicate_name.\n\nThis predicate returns the name PredicateName of the predicate in which it is invoked.\n\npredicate_name can only be used inside a clause. Use of predicate_name in other places causes a compile time error. See also predicate_fullname\n\nThis predicate returns the name programPoint corresponding to the place where it is invoked.\n\nSuccessively removes the first matching fact from the facts database. Fails when no more facts match.\n\nCall-template for this predicate is:\n\nHere FactTemplate should be a fact term. The retract/1 predicate deletes the first fact that matches the FactTemplate in the appropriated facts database. During backtracking, the rest of the matching facts will be deleted.\n\nNotice that FactTemplate can have any level of instantiation. The FactTemplate is matched with the facts in the facts database, which means that any free variables will be bound in the call to retract/1.\n\nThe FactTemplate can contain any anonymous variables. That is, variables with names consisting from the single underscore _ or a variable with a name starting with an underscore _AnyValue if the variable occurs only once in the clause. For example.\n\nwill retract the first matched person fact that has \"Hans\" as the first argument and anything as the second argument.\n\nWhen retracting a fact, which is declared to be determ, the call to retract/1 will be deterministic.\n\nSee also retractall/1 and retractFactDb.\n\nThe retract/1 predicate cannot be applied to single facts or fact variables.\n\nBe careful calling retract/1 with free FactTemplate variable if any single fact is declared in the project current scope. If you retract a single fact, then the run-time error is generated. The retract/1 predicate fails when there are no more matches.\n\nRemove all matching facts from the facts database.\n\nCall-template for this predicate is:\n\nHere FactTemplate should be a fact term.\n\nThe retractall/1 retracts all facts which match the given FactTemplate. It always succeeds, even if no facts were retracted.\n\nAttempting to retract a single fact will cause a compile time error.\n\nIt is not possible to obtain any output values from retractall/1. For this reason, the variables in the call must be bound or be a single underscores (anonymous). Notice that FactTemplate can have any level of instantiation, but free variables must be single underscores (\"unconditionally anonymous\"). In difference to retract/1 \"conditionally\" anonymous variables with names starting from the underscore (like _AnyValue) cannot be used in retractall/1.\n\nSee also retract/1 and retractFactDb/1.\n\nRemove all facts from the named internal facts database FactDB.\n\nCall-template for this predicate is:\n\nThe retractFactDb/1 removes all facts from the named facts database FactDB.\n\nNotice, it is impossible to retract single facts and fact variables, so the predicate leaves such ones as they are.\n\nSee also retractall/1 and retract/1.\n\nRetrieves the number of bits occupied in memory by an entity of the specified domain DomainName.\n\nCall-template for this function is:\n\nThis compiling-time predicate receives the domain DomainName as input parameter and return the size of memory that is occupied by the entity of the given domain. The result is measured in bits. For the integer domains sizeBitsOf/1-> predicate returns the value that was defined for the size-field in a domain's declaration.\n\nThe following is always true for the integral domains:\n\nRetrieves the number of bytes occupied in memory by the specified term Term.\n\nCall-template for this function is:\n\nThe sizeOf/1-> function receives a term as input parameter and returns value ByteSize that specifies the number of bytes occupied in memory by this term Term.\n\nRetrieves the number of bytes occupied in memory by the entity of the specified domain DomainName.\n\nCall-template for this function is:\n\nThis compiling-time predicate receives the domain DomainName as input parameter and return the size of memory that is occupied by the entity of the given domain. The result is measured in bytes. The returned value ByteSize belongs to the integer domain. Compare with sizeBitsOf/1->, which returns size of a domain measured in bits.\n\nReturns the current line number in the source file processed by the compiler.\n\nReturns the name of the source file processed by the compiler.\n\nReturns a string that represents the date and time of the currently compiled source file in format YYYY-MM-DD HH:mm:ss. Where:\n\nThe predicate succeed/0 will always succeed.\n\nConverts the specified Term to the value of universal term type any.\n\nCall-template for this function is:\n\nA term of the any domain can be converted back to its original type using the toTerm predicates (see toTerm).\n\nConverts the specified Term to binary representation.\n\nCall-template for this function is:\n\nWhen a Term (of some domain domainName) is converted into a binary, it can safely be stored in a file or sent over a network to another program. Later the obtained binary value Serialized can be converted back to a Visual Prolog term, using toTerm/1-> function (the domain for the reversed term should be adequate to domainName) for the reverse conversion.\n\nThe purpose of this meta-predicate is to convert an expression to the value of boolean domain.\n\nCall-template for this meta-predicate is:\n\nthis is equivalent to\n\nThe toBoolean/1-> meta-predicate returns boolean value. The result is true if deterministic_call succeeds. The result is false if deterministic_call fails.\n\nThis predicate creates EllipsisBlock ... (i.e. the special varying parameters block) from the list of terms of the universal type any. Such EllipsisBlock can be later passed to a predicate which expects the varying number of arguments (i.e. is declared with the ellipsis (...)), like write/..., at the position of the ellipsis (...).\n\nCall-template for this function is:\n\nConverts the specified Term to string representation.\n\nCall-template for this function is:\n\nWhen a Term (of some domain domainName) is converted into a string, it can safely be stored in a file or sent over a network to another program. Later the obtained string value can be converted back to a Visual Prolog term, using toTerm/1-> function (the domain of the return value should be adequate to domainName) for the reverse conversion.\n\nConverts the string/binary/any representation of the specified term Serialized into representation corresponding to the domain of Term variable of the return value. The domain can be stated explicitly or it can be left to the compiler to determine a suitable domain.\n\nCall-template for this function is:\n\nIf the domain is not specified the compiler must be able to determine the domain for the returned value Term at compile-time. Notice that binary version of toTerm predicate performs almost byte to byte conversion and only checking general compatibility of Serialized data with the domain required to the return value Term. The programmer is wholly responsible for providing binary data of Serialized that can be correctly converted to the term of the desired domain. The toTerm predicates are counterparts to predicates toBinary/1-> and toString/1->. When a Term (of some domain domainName) is converted into a binary or string representation Serialized (by toBinary/1-> or toString/1-> or toAny/1-> correspondingly), it can safely be stored in a file or sent over a network to another program. Later the corresponding toTerm/1-> function can convert the obtained string/binary value Serialized back to a Visual Prolog term Term. For correctness of the reverse conversion the domain of the clause variable Term should be adequate to the initial domain domainName.\n\nIt gives a compile time error if the compiler cannot determine the return domain.\n• Run time errors are generated when the toTerm predicate cannot convert the string or binary into a term of the specified domain.\n\n\n\n Converts the string/binary/any representation Serialized into a term Term like toTerm. The only difference between the predicates is that tryToTerm fails if it cannot convert the string or binary or any into a term of the specified domain whereas toTerm raises an exception.\n\nChecks whether the input term Value can be strictly converted into the specified domain Type and returns the converted term Converted.\n\nCall-template for this function is:\n• returnDomain: Specifies a domain to which tryConvert predicate tries to convert the specified . Here returnDomain can be any domain accessible in the current scope. The domain name returnDomain must be specified at compile-time, i.e. it cannot come from a variable.\n• : Specifies the term that must be converted. may be any Prolog term or an expression. If is an expression, then it will be evaluated before conversion.\n• : Returned term will be of returnDomain domain.\n\nThe conversion rules are the same as of the embedded predicate convert/2->, but tryConvert/2-> fails when convert/2-> generates conversion errors.\n\nThis predicate succeeds if the corresponding conversion succeeds. Otherwise it fails. The tryConvert/2-> predicate tries to perform a clean and genuine conversion of the given InputTerm into a value of the specified domain returnDomain. The tryConvert/2-> predicate will fail if the required conversion cannot be performed. When tryConvert/2-> predicate succeeds, it returns the term ReturnTerm converted to the specified domain returnDomain.\n\nFor allowed conversions and rules of checked explicit conversions see convert/2-> predicate.\n\nReflection predicate that returns the typeDescriptor of a type or a value.\n\nA typeDescriptor is the reflection descriptor of an uninstantiated type/domain.\n\nReflection predicate that returns the typeLibrary of a type or a value.\n\nA typeLibrary is the reflection descriptor of an instantiated type/domain.\n\nUnchecked conversion of a value to another type.\n\nCall-template for this function is:\n• returnDomain: Specifies a domain to which uncheckedConvert predicate unsafely converts the specified . Here returnDomain can be any domain accessible in the current scope, the should has the same bit-size as the . The domain name returnDomain must be specified at compile-time, i.e. it cannot come from a variable.\n• : Specifies the value that must be converted. may be any Prolog term or an expression. If InputTerm is an expression, then it will be evaluated before conversion.\n• : Returned parameter will be of returnDomain type.\n\nuncheckedConvert evaluates InputTerm, change the type to returnDomain without any modification of the memory pattern and unifies with ReturnTerm. The uncheckedConvert predicate performs no runtime checks. It makes only compile time checking of bit-size equality of the converted domains. So almost any term may be quite recklessly converted to any other term. So quite disastrous results may occur if you try to use variables incorrectly converted by uncheckedConvert. Be extremely careful implementing uncheckedConvert; we strongly recommend you always, when it is possible, using of convert/2-> and tryConvert/2->. But notice that, when an object is returned by COM system it is necessary to convert it by uncheckedConvert, as Prolog program does not have information about its actual type.\n\nReturns the upper bound value of the specified numeric domain.\n\nCall-template for this function is:\n\nThe upperBound is a compiling-time predicate. The upperBound returns the upper bound value of the specified numeric domain domainName. The return value UpperBound belongs to the same domain domainName. The domainName parameter should be the name of any numerical domain; this domain name should be explicitly specified at compile-time (that is, domainName cannot come from a variable).\n\nWill cause a compile time error if the specified domain domainName is not numeric domain.\n\nEach compiler directive starts from the # character. The following directives are supported:\n\nThe #include compiler directive is used to include the contents of another file into your program source code during compilation. It has the following syntax:\n\nThe String_literal should specify an existing filename.\n\nThis compiler directive uses \"include the first file occurrence only\" semantics. That is, if a compilation unit contains several include directives for the same file, it will be included only one time with the first include directive.\n\nEach included file must contain several accomplished scopes; an included file cannot contain uncompleted scopes. That is, it should contain several accomplished interface declarations, class declarations, class implementations or/and several compiler directives.\n\nThe compiler tries to find the specified include source file in the following way:\n• If the filename contains an absolute path, then this file should be included.\n• Otherwise, the compiler searches for the specified include filename among the paths that had been defined by the command line option. These paths are handled consequently as they are specified in the option. In the IDE you can set these paths in the Include Directories in the Directories tab of the Project Settings dialog.\n\nIf the compiler does not find the specified file a compiling time error is generated.\n\nThe #stringinclude compiler directive is used to include (during compilation) the contents of a file (specified by the string_literal string) as a ::string constant into your program source code. It has the following syntax:\n\nThis directive can be used in any places where string constants are allowed. The string_literal should specify an existing filename. The syntax is the same as in the #include compiler directive described in the previous paragraph Source File Inclusions. The compiler tries to find the specified file in the same way as for #include compiler directive. If the file has a byte-order-mark it will be treated accordingly, if the file does not have byte order mark and does not appear to be in utf-16 it will be read with the current codepage (it is recommended to use files with byte-order-mark utf-8 or utf-16).\n\nThe #bininclude compiler directive is used to include (during compilation) the contents of a file (specified by the string_literal string) as a ::binary constant into your program source code. It has the following syntax:\n\nThis directive can be used in any places where binary constants are allowed. The string_literal should specify an existing filename. The syntax is the same as in the #include compiler directive described in the previous paragraph Source File Inclusions. The compiler tries to find the specified file in the same way as for #include compiler directive.\n\nWhen creating a binary constant the compiler adds the EOS symbol immediately after this constant.\n\nCompiler directives #export and #externally are used to determine lists of exported and imported classes, respectively. They have the following syntax:\n\nThese compiler directives are applied only to classes classNames, which do not construct objects.\n\nThey can be used only outside scopes; that is, they cannot be used inside declarations of interfaces and classes and they cannot be used inside implementations of classes.\n\nBy default, predicates within one executed module are hidden at runtime for all other executed modules. An #export compiler directive makes names of specified classes public outside the module in which they are declared (and implemented). Therefore, all predicates from this module declared in the classes (specified in an #export directive) become accessible while runtime from other executed modules.\n\nUsually, an #export compiler directives can be used in projects, which target modules are DLLs. It enumerates classes declared in a DLL, which should be accessible to other modules that use this DLL.\n\nIf a compilation unit export some class, then this compilation unit should contain this class implementation.\n\nAlso an #export compiler directives can be used to specify condition expressions for #if compiler directives.\n\nFor example, let us suppose that somewhere in the beginning of a compilation unit the compiler has met the #export compiler directive like this:\n\nThen the compiler, if in the subsequent code it meets an #if compiler directive with the same #export compiler directive used as the condition expression, for example like this:\n\nThen the compiler evaluates the #export condition expression as true and, hence, the compiler executes the #then branch of the conditional compilation directive.\n\nFor example, the following #export compiler directive with the subsequent #if conditional compilation compiler directive:\n\nguaranty that the \"some.pack\" package will be included into the compilation unit.\n\nFrom the other hand, if an #export compiler directive is not met by the compiler (somewhere in the compilation unit before the #if compiler directive, which uses the same #export compiler directive as the conditional expression), then the compiler evaluates this #export condition expression as false. Hence, the compiler will not execute the #then branch of the #if conditional compilation directive. That is, the single #if compiler directive without previous #export directive\n\ndoes not requires to include the \"some.pack\" package.\n\nAn #externally compiler directive is counterpart to an #export compiler directive. An #externally compiler directive can be used instead of (and concurrently with) an IMPORTS directive in definition files. An #externally compiler directive enumerates classes, which are declared in a module but implemented in other modules. Therefore, the compiler will not produce errors when it detects such classes. The referenced classes can be implemented (and exported) in DLLs, which can be linked to the module at runtime.\n\nThe #export and #externally compiler directives can be used as Condition boolean expressions in Conditional Compilation.\n\nFor example, like this:\n\nCompiler directives #message, #requires, #orrequires, and #error can be used to issue user-defined messages into a listing file while compilation of project modules and to interrupt compilation.\n\nThese directives can be used either outside scopes (interface declaration, class declaration or class implementation), or inside scopes but outside sections. They have the following syntax:\n\nWhen the compiler meets any of these directives, it generates the correspondent warning message and place the directive text into a listing file.\n\nA listing file name can be specified with the compiler directive:\n\nNotice that no empty spaces can be used between the colon : (after /listinglile) and \"FileName\".\n\nBy default the compiler does NOT generate informative messages for the #message, #requires, and #orrequires directives. You can switch generation of these informative messages ON specifying the compiler options:\n\nThe directive #requires (#orrequires) issues arbitrary user-defined messages about the needed source (object) files into a listing file. The #orrequires directive cannot be used alone: the #requires directive should immediately (separated with white spaces or comments only) precede it.\n\nThe directive #error always terminates the compilation and issues the user-defined error message like the following into a listing file:\n\nYou can parse and analyze these messages and accept the required actions. For example, the VDE analyzes information printed by the #requires and #orrequires directives and automatically adds all needed PFC packages and standard libraries to the compiled project (See also the Handling Project Modules topic).\n\nCompiler directive #options <string_literal> affects the whole compilation unit. This directive should be used outside scopes and conditional compilation statements in the main source file for a compilation unit (i.e. in the source file which is passed to the compiler). Otherwise the compiler generates a warning message and ignores the directive.\n\nThe <string_literal> can only contain the following compiler options:\n\nOtherwise the compiler generates the error message for invalid option. If there are several #options directives they are handled in the textual order.\n\nThe conditional programming constructions are part of the Visual Prolog language. Only other compiler directives, Compilation Units, and Program Sections (including empty) can be conditional. The following syntax is used:\n\nHere Condition can be any expression, which can be evaluated to fail or succeed during compilation time.\n\nEach one conditional compilation statement must be in one file, that is, the compiler directives #if, #then, #elseif and #else (if present), #endif of the same level of nesting must be in one file.\n\nDuring compilation the compiler evaluates the conditions, in order to determine which parts to include in the final program. Parts that are excluded from the final program are called the dead branches.\n\nAll branches of conditional compilation items are syntax checked and must be syntactically correct. That is, also the dead branches must be syntactically correct.\n\nThe compiler only calculates conditions on a need to know basis, i.e. it does not calculate conditions in dead branches.\n\nA condition may not depend on any code, which is located textually inside the conditional statement.\n\nThe example below is illegal because the condition depends on the scope (and constant) which is declared inside the condition branch.\n\nVarious definitions and declarations can be annotated with attributes. This section describes the general syntax of attributes and where they can be placed. It also describes the meaning of the specific attributes.\n\nwhere the literals must either be numbers or string literals.\n\nThe attributes of interfaces, classes and implementations are right after the scope qualifications.\n\nThe attributes of constants, domains, predicates, properties and facts are at the end (i.e. right before the terminating dot).\n\nThe attributes of formal arguments are at the end.\n\nThis attribute is used on a functor domain to indicate that the functors in the domain can be used as attributes elsewhere in the program.\n\nAn argument is transferred directly on the stack rather than using a pointer. Valid for formal predicate arguments provided the language is stdcall, apicall or c.\n\nThe attribute can also be used in combination with the out attribute:\n\nIn that case a point structure will be allocated before the call then a pointer to that structure is transferred handed to the external predicate which can then fill the structure with relevant data.\n\nThis attribute indicates that a predicate should be invoked as a class initializer. It can be applied to a class predicate that does not take any arguments. The predicate will be invoked when the initialization code invokes the runtime_api::runProgramInitialization. A class can have any number of class initializer which will be invoked in an undetermined order. Notice that other classes may not have been initialized.\n\nThe predicate xxx::initialize is registered as a class initializer:\n\nThe constant attribute is used to declare fact variables that cannot be changed once they have been initialized.\n\nThe compiletimeSetting attribute indicates that a constant should be considered a compiletime setting. As a result the compiler will suppress warnings about always failing/succeding code and about unreachable code that may be caused by this constant. The warning suppession is an approximation, because it a may be impossible/difficult to determine the cause of a warning.\n\nIt is problematic to update functor domains, if terms have been persisted in serialized form. Because new programs cannot deal with old serializations.\n\nThe two attributes default/1 and retiredFunctor/1 can help dealing with this problem.\n\nThe last arguments of a functor can have default values:\n\nThe default attribute does not change anything within the program; it only affects the deserialization. If during deserialization we meet the closing parenthesis too soon we supply default values for the remaining arguments.\n\nNotice that this will only work for text deserialization.\n\nThe declared entity is deprecated. The string literal describes how to migrate from it. The entity still exists, but usage will cause a warning. The entity will not exist in future versions of Visual Prolog. Valid for member declarations and scopes.\n\nThis predicate can be used on a functor domain to ensure that the memory representation of all terms have a functor. Without this attribute the compiler optimizes the representation such that some alternatives doesn't have a functor in the term, and such that functors with arguments are represented as a pointer value. The main purpose of this attribute is to ensure compatibility with foreign code.\n\nThe argument is a format string for a subsequent ellipsis argument (i.e. ...). Valid for one string argument of a predicate with an ellipsis argument. The use of formatString will make the compiler check the validity of actual arguments with respect to actual format strings (where possible).\n\nThe format string can contain ordinary characters which are printed without modification, and format fields, that begins with the percent % sign. If the percent sign is followed by some unknown character (not the format specifier) - then this character will be printed without modifications. To output a % character you must write %% in the format string.\n\n[-] Hyphen indicates that the field is to be left justified; right justified is the default. Having no effect when width value is not set, or the number of characters in the actual value is greater than width value.\n\n[0] Zero before width means for values that zeros will be added until the minimum width is reached. If 0(zero) and -(hyphen) appear, the 0 is ignored\n\n[width] Positive decimal number specifying a minimum field size. If the number of characters in the actual value is less than width value - then the required number of space ' ' characters will be added before the value (or after it, if '-' field was set). No changes occurs if number of characters in the actual value is greater than the width value.\n\n[.precision] The point '.' with the following unsigned decimal number can specify either the precision of a floating-point image or the maximum number of characters to be printed from a string.\n\n[type] Specifies other format then the default for the given. For example, in the type field, you can give a specifier that says an integer will be formatted as an unsigned. The possible values are:\n\nThis attribute can be placed on interfaces, classes and implementation to indicate that the code is generated by some tool. As result the compiler will issue less warnings about the code.\n\nThe attribute immediate enforces immediate (i.e. non-late) initialization of a fact variable:\n\nThe argument is an input argument. Valid for a formal predicate argument.\n\nDefines an in-iterator predicate for a domain or interface. See the description of the in operator.\n\nDefines an in-test for a domain or interface. See the description of the in operator.\n\ninline alters the memory layout of a struct (i.e. a single alternative functor domain with an align qualification). The purpose of the attribute is to ease interfacing to foreign languages and should normally not be used for pure Visual Prolog.\n\ninline can be used in three cases:\n• inlining a struct rather than having a pointer to the struct\n• inlining a prolog predicate type (as a struct with two fields)\n\nWhen using inline on struct field in another struct its data will be inlined instead of having a pointer to the struct\n\n\n\n When using inline(<size>) on a string or a string8 field in a struct, the struct will contain a fixed size string with <size> characters (i.e. char or char8, respectively). The strings will be zero terminated if they are shorter than <size>, but not if they have <size> characters.\n\nWhen using inline(<size>) on the pointer type the struct will contain <size> bytes, and the pointer will become a pointer to that field:\n\nA declaration which has special meaning and handling in the compiler (semi-built-in).\n\nUsed to prevent a predicate from having optional output parameters (see Optional parameters).\n\nUsed for a class to indicate that it should not have an implicit default constructor, and can thus be used to a class that does not have any public constructors at all. Valid for an object creating class declaration.\n\nThe argument is an output argument. Valid for a formal predicate argument.\n\nThe [pack(n)] attribute (where n is a number) instructs the compiler to use n as packing size for a functor domains. By default the packing size is 4 in 32 bit programs and 8 in 64 bit programs. This attribute is mainly intended for compatibility with C/C++ api's.\n\nThe attribute can used on a class declaration to cover all domains in that class.\n\nprogramPoint's are used by the exception mechanism to indicate where exceptions are raised and continued, but the usage is not limited to that purpose.\n\nThe programPoint attribute is used predicate or constructor declaration to indicate that it receives an extra input argument which describes the place in a program (program point) where this predicate was called. This additional argument has programPoint type which is declared in the PFC core class like:\n\nThe programPoint attribute can be added to a predicate declaration like this:\n\nAdding this attribute actually means that two predicates are declared, the one you have mentioned and an another one with name raiseAnException_explicit which in addition to the arguments of raiseAnException takes a programPoint as first argument:\n\nWhen you call raiseAnException the compiler will create a program point and call raiseAnException_explicit instead.\n\nIf you have a programPoint you can directly call the explicit predicate with it.\n\nSuch code is treated in the usual way. I.e. when calling raiseAnException or raiseAnException_explicit will in both cases result in calling raiseAnException_explicit, so this is the only predicate that needs an implementation. In fact, it is illegal to state clauses for the non-explicit predicate that will never be called.\n\nThere is also a built-in predicate, programPoint/0->, which returns a programPoint corresponding to the place where it is called.\n• A predicate declaration with programPoint attribute actually declares two predicates. A non-explicit and an explicit predicate.\n• Calling the non-explicit predicate actually results in calling the explicit predicate with the call point as additional argument.\n• Only the explicit predicate should be implemented.\n\nUsed to specify the presenter of a domain.\n\nAlso used without argument to specify that an interface has a presenter.\n\nMakes an entity 'queryable', so that it is available for reflextion using the class predicateExtractor.\n\nThe declared entity is retired. The string literal describes how to migrate from it. The entity does not exist anymore.\n\naaa::fct_ppp must be a predicate with this type (it can be an anonymous predicate):\n\nI.e. it takes the arguments of the old functor and returns a value in the functor domain.\n\nIn the program fct is does not exist at all, it is retired. But in the deserialization fct terms can still be handled: The arguments are parsed according to the types, and then the value is created by invoking aaa::fct_ppp.\n\nThis method will also work for binary serializations, provided:\n• The old domain had more than one alternative (so there are functor numbers in the serialization)\n• New alternatives are added last (to retain functor numbers)\n\nIt is however not recommend using binary serialization for inter-session persistence.\n\nUsed for an interface to indicate that it cannot be supported by any other interface. This allows to create more efficient codes, because the compiler provides some optimization when using the objects of such type. Valid for an object creating class declaration as a construction interface.\n\nUsed for creating functor domains with several alternatives but no real functors. This should only be used to mimic C/C++ union structs in low-level interfacing. Valid for functor domain with several alternatives and alignment.\n\nAn unused local member can be marked used to prevent the compiler to issue a warning and remove the corresponding code. Valid for members."
    },
    {
        "link": "https://eu.swi-prolog.org/packages/xpce/UserGuide/sec-7.5.html",
        "document": "The basic type-syntax is described in section 3.2.1 of this manual. Types are first-class reusable objects that are created from the type-declaration in arguments and variables. The conversion from the textual representation to the object is performed by itself (together with the resource syntax, one of the few places where defines syntax). All types can be specified as Prolog quoted atoms. For example:\n\nFor most cases however, this is not necessary. If the type is not an atom, the class-compiler will convert the Prolog term into an atom suitable for 's type system. Hence, will translate to the atom '[point]', which is interpreted by as ``an instance of class point or the constant @default''. The atoms and are defined as postfix operators, while is an infix operator. This makes ` ' a valid notation for ``any number of anything'' (see section 7.5.2 below) and ` ' a valid expression for ``an integer in the range 0 to 5 (including the boundaries).\n\nAlso, is a valid description for ``an instance of box or circle or the constant @default. Note however that is not valid Prolog syntax and should be written as . Whenever you are in doubt, use quotes to prevent surprises.\n\nMethods such as `chain initialise' and `string format' handle an arbitrary number of arguments. The argument declaration for such a method first defines a number (possibly zero) of `normal' arguments. The last argument is postfixed with ` '. The arguments assigned to the `vararg' type are passed in a Prolog list.\n\nBelow is a refinement of `label report' that will colour the label depending on the nature of the message. The report method takes two obligatory arguments, the kind of the report and a format string, as well as an undefined number of arguments required by the format specification.\n\nprovides two alternatives to multiple inheritance. Delegation is discussed in section C.4. See also the directive delegate_to/1 for user-defined class definitions. The template mechanism is much closer to real multiple inheritance. A template is a named partial class-definition that may be included in other classes. It behaves as if the source-code of the template definition was literally included at the place of the use_class_template/1 directive.\n\nIn fact, the class-attributes (variables, method objects) are copied, while the implementation (the Prolog clauses) are shared between multiple references to the same template.\n\nTemplates itself form a hierarchy below class template, which is an immediate subclass of object. Including a template will make all variables and methods defined between the template class and class template available to the receiving class.\n\nWe illustrate the example below, making both editable boxes as editable ellipses. First we define the template class.\n\nThe main program can now be defined as:\n\nNote that use_class_template/1 imports the definitions from the template in the current class. Thus, the following will not extend further on the `editable_graphical event' definition, but instead replace this definition. Of course it is allowed to subclass the definition of editable_box above and further refine the event method in the subclass.\n\nThe rolog class-compilation is defined using the Prolog preprocessing capabilities of term_expansion/2. While the class is compiled, Prolog gathers the expressions belonging to the class. The expansion of emits the actual code for the class.\n\nThe method implementation is realised by the predicates pce_principal:send_implementation/3 and pce_principal:get_implementation/4. that take the form:\n\nThe remainder of the class specification is translated into a number of Prolog clauses describing the class. No class is created. If generates an exception, it will scan for the class-description in the Prolog database and create the class instance. No methods are associated with the new class. Instead, all method binding is again based on exception handling.\n\nModifications to the class beyond what is provided by the preprocessing facilities (for example changing the `variable clone_style') cannot be made by sending messages to the class inside the class definition body as this would address the not-yet-existing class. Instead, they should be embedded in the pce_class_directive/1 directive. . The Goal argument of pce_class_directive/1 should refer to the class using the var object @class. When the class is realised the exception system will bind @class to the current class while running Goal. Goal is called from the Prolog module in which the class is defined.\n\nThe main reason for the above approach is to exploit the runtime-generation facilities of the hosting Prolog system to create fast-starting portable and (depending on the hosting Prolog's capabilities) stand-alone executables.\n\nOne of the consequences of the chosen approach is that the class-building directives are not accessible as predicates. There is no preprocessing support for the dynamic creation of classes and the programmer should thus fall back to raw manipulation of the class objects."
    },
    {
        "link": "https://academia.edu/8999914/A_Beginners_Guide_to_Visual_Prolog",
        "document": "Demonstrating Prolog Usage: Building a Simple Game Program To demonstrate the use of Prolog and how programming in Prolog is easy and efficient, this paper describe an implementation of the game booby-trap, a game similar to Minesweeper found on most personal computers with windows.\n\nA An Introduction to Prolog Prolog was designed in the 1970s by Alain Colmerauer and a team of researchers with the idea -new at that time -that it was possible to use logic to represent knowledge and to write programs. More precisely, Prolog uses a subset of predicate logic and draws its structure from theoretical works of earlier logicians such as Herbrand (1930) and Robinson (1965) on the automation of theorem proving.\n\nLearn Prolog Now! 1. To give some simple examples of Prolog programs. This will introduce us to the three basic constructs in Prolog: facts, rules, and queries. It will also introduce us to a number of other themes, like the role of logic in Prolog, and the idea of performing matching with the aid of variables."
    }
]