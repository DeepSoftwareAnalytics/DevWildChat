[
    {
        "link": "https://httrack.com/html/step.html",
        "document": ""
    },
    {
        "link": "https://httrack.com/html/fcguide.html",
        "document": "I started using httrack in mid-2000 and found it to be an excellent tool for imaging web sites. Various words are used to describe this process - from imaging to mirroring to snaking and so on. I will be using a variety of these words in my description. I have used many such tools over the years, have performed many manual and semi-automatic operations of similar sorts, and written partial programs to do similar functions, but - at least for now - httrack seems to me to be the best option for this function. The only problem I encountered when using httrack was that it is so rich with features that I could never really figure out precisely the right thing to do at any given point. I was using recepies rather than knowledge to get the job done - and I was pestering the authors for those recepies. After a few days of very helpful assistance from the authors I volenteered to write a users manual for httrack - and here it is. I hope it gets the job done. Httrack is a program that gets information from the Internet, looks for pointers to other information, gets that information, and so forth. If you ask it to, and have enough disk space, it will try to make a copy of the whole Internet on your computer. While this may be the answer to Dilbert's boss when he asks to get a printout of the Internet for some legal document, for most of us, we want to get copies of just the right part of the Internet, and have them nicely organized for our use. This is where httrack does a great job. Here's a simple example: In this example, we ask httrack to start the Universal Resource Locator (URL) http://www.all.net/ and store the results under the directory /tmp/www.all.net (the -O stands for \"output to\") while not going beyond the bounds of all the files in the www.all.net domain and printing out any error messages along the way (-v means verbose). This is the most common way that I use httrack. Please note that this particular command might take you a while - and run you out of disk space. This sort of a mirror image is not an identical copy of the original web site - in some ways it's better such as for local use - while in other ways it may be problematic - such as for legal use. This default mirroring method changes the URLs within the web site so that the references are made relative to the location the copy is stored in. This makes it very useful for navigating through the web site on your local machine with a web browser since most things will work as you would expect them to work. In this example, URLs that point outside of the www.all.net domain space will still point there, and if you encounter one, the web browser will try to get the data from that location. For each of the issues discussed here - and many more - httrack has options to allow you to make different choices and get different results. This is one of the great things about httrack - and one of the the real major problems with using it without the knowledge of all that it can do. If you want to know all the things httrack can do, you might try typing: Unfortunately, while this outputs a though list of options, it is somewhat less helpful it might be for those who don't know what the options all mean and haven't used them before. On the other hand, this is most useful for those who already know how to use the program but don't remember some obscure option that they haven't used for some time. The rest of this manual is dedicated to detailing what you find in the help message and providing examples - lots and lots of examples... Here is what you get (page by page - use to move to the next page in the real program) if you type 'httrack --help': >httrack --help HTTrack version 3.03BETAo4 (compiled Jul 1 2001) usage: ./httrack ] [- ] with options listed below: (* is the default value) General options: O path for mirror/logfiles+cache (-O path_mirror[,path_cache_and_logfiles]) (--path ) %O top path if no path defined (-O path_mirror[,path_cache_and_logfiles]) Action options: w *mirror web sites (--mirror) W mirror web sites, semi-automatic (asks questions) (--mirror-wizard) g just get files (saved in the current directory) (--get-files) i continue an interrupted mirror using the cache Y mirror ALL links located in the first level pages (mirror links) (--mirrorlinks) Proxy options: P proxy use (-P proxy:port or -P user:pass@proxy:port) (--proxy ) %f *use proxy for ftp (f0 don't use) (--httpproxy-ftp[=N]) Limits options: rN set the mirror depth to N (* r9999) (--depth[=N]) %eN set the external links depth to N (* %e0) (--ext-depth[=N]) mN maximum file length for a non-html file (--max-files[=N]) mN,N' for non html (N) and html (N') MN maximum overall size that can be uploaded/scanned (--max-size[=N]) EN maximum mirror time in seconds (60=1 minute, 3600=1 hour) (--max-time[=N]) AN maximum transfer rate in bytes/seconds (1000=1kb/s max) (--max-rate[=N]) %cN maximum number of connections/seconds (*%c10) GN pause transfer if N bytes reached, and wait until lock file is deleted (--max-pause[=N]) Flow control: cN number of multiple connections (*c8) (--sockets[=N]) TN timeout, number of seconds after a non-responding link is shutdown (--timeout) RN number of retries, in case of timeout or non-fatal errors (*R1) (--retries[=N]) JN traffic jam control, minimum transfert rate (bytes/seconds) tolerated for a link (--min-rate[=N]) HN host is abandonned if: 0=never, 1=timeout, 2=slow, 3=timeout or slow (--host-control[=N]) Links options: %P *extended parsing, attempt to parse all links, even in unknown tags or Javascript (%P0 don't use) (--extended-parsing[=N]) n get non-html files 'near' an html file (ex: an image located outside) (--near) t test all URLs (even forbidden ones) (--test) %L ) Build options: NN structure type (0 *original structure, 1+: see below) (--structure[=N]) or user defined structure (-N \"%h%p/%n%q.%t\") LN long names (L1 *long names / L0 8-3 conversion) (--long-names[=N]) KN keep original links (e.g. http://www.adr/link) (K0 *relative link, K absolute links, K3 absolute URI links) (--keep-links[=N]) x replace external html links by error pages (--replace-external) %x do not include any password for external password protected websites (%x0 include) (--no-passwords) %q *include query string for local files (useless, for information purpose only) (%q0 don't include) (--include-query-string) o *generate output html file in case of error (404..) (o0 don't generate) (--generate-errors) X *purge old files after update (X0 keep delete) (--purge-old[=N]) Spider options: bN accept cookies in cookies.txt (0=do not accept,* 1=accept) (--cookies[=N]) u check document type if unknown (cgi,asp..) (u0 don't check, * u1 check but /, u2 check always) (--check-type[=N]) j *parse Java Classes (j0 don't parse) (--parse-java[=N]) sN follow robots.txt and meta robots tags (0=never,1=sometimes,* 2=always) (--robots[=N]) %h force HTTP/1.0 requests (reduce update features, only for old servers or proxies) (--http-10) %B tolerant requests (accept bogus responses on some servers, but not standard!) (--tolerant) %s update hacks: various hacks to limit re-transfers when updating (identical size, bogus response..) (--updatehack) %A assume that a type (cgi,asp..) is always linked with a mime type (-%A php3=text/html) (--assume ) Browser ID: F user-agent field (-F \"user-agent name\") (--user-agent ) %F footer string in Html code (-%F \"Mirrored [from host %s [file %s [at %s]]]\" (--footer ) %l preffered language (-%l \"fr, en, jp, *\" (--language ) Log, index, cache C create/use a cache for updates and retries (C0 no cache,C1 cache is prioritary,* C2 test update before) (--cache[=N]) k store all files in cache (not useful if files on disk) (--store-all-in-cache) %n do not re-download locally erased files (--do-not-recatch) %v display on screen filenames downloaded (in realtime) (--display) Q no log - quiet mode (--do-not-log) q no questions - quiet mode (--quiet) z log - extra infos (--extra-log) Z log - debug (--debug-log) v log on screen (--verbose) f *log in files (--file-log) f2 one single log file (--single-log) I *make an index (I0 don't make) (--index) %I make an searchable index for this mirror (* %I0 don't make) (--search-index) Expert options: pN priority mode: (* p3) (--priority[=N]) 0 just scan, don't save anything (for checking links) 1 save only html files 2 save only non html files *3 save all files 7 get html files before, then treat other files S stay on the same directory D *can only go down into subdirs U can only go to upper directories B can both go up&down into the directory structure a *stay on the same address d stay on the same principal domain l stay on the same TLD (eg: .com) e go everywhere on the web %H debug HTTP headers in logfile (--debug-headers) Guru options: (do NOT use) #0 Filter test (-#0 '*.gif' 'www.bar.com/foo.gif') #f Always flush log files #FN Maximum number of filters #h Version info #K Scan stdin (debug) #L Maximum number of links (-#L1000000) #p Display ugly progress information #P Catch URL #R Old FTP routines (debug) #T Generate transfer ops. log every minutes #u Wait time #Z Generate transfer rate statictics every minutes #! Execute a shell command (-#! \"echo hello\") Command-line specific options: V execute system command after each files ($0 is the filename: -V \"rm \\$0\") (--userdef-cmd ) %U run the engine with another id when called as root (-%U smith) (--user ) Details: Option N N0 Site-structure (default) N1 HTML in web/, images/other files in web/images/ N2 HTML in web/HTML, images/other in web/images N3 HTML in web/, images/other in web/ N4 HTML in web/, images/other in web/xxx, where xxx is the file extension\n\n(all gif will be placed onto web/gif, for example) N5 Images/other in web/xxx and HTML in web/HTML N99 All files in web/, with random names (gadget !) N100 Site-structure, without www.domain.xxx/ N101 Identical to N1 exept that \"web\" is replaced by the site's name N102 Identical to N2 exept that \"web\" is replaced by the site's name N103 Identical to N3 exept that \"web\" is replaced by the site's name N104 Identical to N4 exept that \"web\" is replaced by the site's name N105 Identical to N5 exept that \"web\" is replaced by the site's name N199 Identical to N99 exept that \"web\" is replaced by the site's name N1001 Identical to N1 exept that there is no \"web\" directory N1002 Identical to N2 exept that there is no \"web\" directory N1003 Identical to N3 exept that there is no \"web\" directory (option set for g option) N1004 Identical to N4 exept that there is no \"web\" directory N1005 Identical to N5 exept that there is no \"web\" directory N1099 Identical to N99 exept that there is no \"web\" directory Details: User-defined option N %n Name of file without file type (ex: image) (--do-not-recatch) %N Name of file, including file type (ex: image.gif) %t File type (ex: gif) %p Path [without ending /] (ex: /someimages) %h Host name (ex: www.someweb.com) (--http-10) %M URL MD5 (128 bits, 32 ascii bytes) %Q query string MD5 (128 bits, 32 ascii bytes) %q small query string MD5 (16 bits, 4 ascii bytes) (--include-query-string) %s? Short name version (ex: %sN) %[param] param variable in query string Shortcuts: --mirror For many of you, the manual is now complete, but for the rest of us, I will now go through this listing one item at a time with examples... I will be here a while... The syntax of httrack is quite simple. You specify the URLs you wish to start the process from ( ), any options you might want to add ([-option], any filters specifying places you should ([+ ]) and should not ([- ]) go, and end the command line by pressing . Httrack then goes off and does your bidding. For example: This will use the 'defaults' (those selections from the help page marked with '*' in the listing above) to image the web site. Specifically, the defauls are: w *mirror web sites %f *use proxy for ftp (f0 don't use) cN number of multiple connections (*c8) RN number of retries, in case of timeout or non-fatal errors (*R1) %P *extended parsing, attempt to parse all links, even in unknown tags or Javascript (%P0 don't use) NN name conversion type (0 *original structure, 1+: see below) LN long names (L1 *long names / L0 8-3 conversion) K keep original links (e.g. http://www.adr/link) (K0 *relative link) o *generate output html file in case of error (404..) (o0 don't generate) X *purge old files after update (X0 keep delete) bN accept cookies in cookies.txt (0=do not accept,* 1=accept) u check document type if unknown (cgi,asp..) (u0 don't check, * u1 check but /, u2 check always) j *parse Java Classes (j0 don't parse) sN follow robots.txt and meta robots tags (0=never,1=sometimes,* 2=always) C create/use a cache for updates and retries (C0 no cache,C1 cache is prioritary,* C2 test update before) f *log file mode I *make an index (I0 don't make) pN priority mode: (* p3) *3 save all files D *can only go down into subdirs a *stay on the same address --mirror Here's what all of that means: Automatically go though each URL you download and look for links to other URLs inside it, dowloading them as well. %f *use proxy for ftp (f0 don't use) If there are and links to ftp URLs (URLs using the file transfer protocol (FTP) rather than the hypertext transfer protocol HTTP), go through an ftp proxy server to get them. Use up to 8 simultaneous downloads so that at any gioven time, up to 8 URLs may be underway. RN number of retries, in case of timeout or non-fatal errors (*R1) Retry once if anything goes wrong with a download. %P *extended parsing, attempt to parse all links, even in unknown tags or Javascript (%P0 don't use) Try to parse all URLs - even if they are in Javascript, Java, tags of unknown types, or anywhere else the program can find things. NN name conversion type (0 *original structure, 1+: see below) Use the original directory and file structure of the web site in your mirror image of the site. If filenames do not follow the old DOS conventions, store them with the same names used on the web site. Use relative rather than the original links so that URLs within this web site are adjusted to point to the files in the mirror. IF there are errors in downloading, create a file that indicates that the URL was not found. This makes browsing go a lot smoother. X *purge old files after update (X0 keep delete) Files not found on the web site that were previously there get deleted so that you have an accurate snapshot of the site as it is today - losing historical data. Accept all cokkies sent to you and return them if requested. This is required for many sites to function. These cookies are only kept relative to the specific site, so you don't have to worry about your browser retaining them. u check document type if unknown (cgi,asp..) (u0 don't check, * u1 check but /, u2 check always) This causes different document types to be analyzed differently. This causes Java class files to be parsed looking for URLs. This tells the program to follow the wishes of the site owner with respect to limiting where robots like this one search. C create/use a cache for updates and retries (C0 no cache,C1 cache is prioritary,* C2 test update before) If you are downloading a site you have a previous copy of, supplemental parameters are transmitted to the server, for example the 'If-Modified-Since:' field will be used to see if files are newer than the last copy you have. If they are newer, they will be downloaded, otherwise, they will not. This retains a detailed log of any important events that took place. This makes a top-level index.html file so that if you image a set of sites, you can have one place to start reviewing the set of sites. This will cause all downloaded files to be saved. D *can only go down into subdirs This prevents the program from going to higher level directories than the initial subdirectory, but allows lower-level subdirectories of the starting directory to be investigated. a *stay on the same address This indicates that only the web site(s) where the search started are to be collected. Other sites they point to are not to be imaged. This indicates that the program should try to make a copy of the site as well as it can. Now that's a lot of options for the default - but of course there are a lot more options to go. For the most part, the rest of the options represent variations on these themes. For example, instead of saving all files, we might only want to save html files, or instead of 8 simultaneous sessions, we might want only 4. If we wanted to make one of these changes, we would specify the option on the command line. For example: This would restrict httrack to only use 4 siumultaneous sessions but allow it to go up the directory structure (for example to www.all.net/joe/) as well as down it (for example to www.all.net/bob/deeper/). You can add a lot of options to a command line! A Thorough Going Over Now that you have an introduction, it's time for a more though coverage. This is where I go through each of the options and describe it in detail with examples... Actually, I won't quite do that. But I will get close. Options tend to come in groups. Each group tends to be interrelated, so it's easier and more useful to go through them a group at a time with some baseline project in mind. In my case, the project is to collect all of the information on the Internet about some given subject. We will assume that, through a previous process, I have gotten a list of URLs of interest to me. Typically there will be hundreds of these URLs, and they will be a mixed bag of sites that are full of desired information, pages with lists of pointers to other sites, URLs of portions of a web site that are of interest (like Bob's home pages and subdirectories), and so forth. Let us say that for today we are looking for the definitive colleciton of Internet information on shoe sizes from around the world. For this project, I will want to keep all of the information I gather in one place, so I will specify that output area of the project as /tmp/shoesizes by adding '-O /tmp/shoesizes' to every command line I use.. for example: The action options tell httrack how to operate at the larger level. Action options: w *mirror web sites W mirror web sites, semi-automatic (asks questions) g just get files (saved in the current directory) i continue an interrupted mirror using the cache Y mirror ALL links located in the first level pages (mirror links) If I want httrack to ask me questions - such as what options to use, what sites to mirror, etc. I can tell it to ask these questions as follows: httrack http://www.shoesizes.com -O /tmp/shoesizes -W OR OR The '-W' options asks whether the or not a site has to be mirrored, while the '-w' option does not ask this question but asks the remainder of the questions required to mirror the site. The -g option allows you to get the files exactly as they are and store them in the current directory. This is handy for a relatively small collection of information where organization isn't important. With this option, the html files will not even be parsed to look for other URLs. This option is useful for getting isolated files (e.g., httrack -g www.mydrivers.com/drivers/windrv32.exe). If I start a collection process and it fails for ome reason or another - such as me interrupting it because I am running out of disk space - or a network outage - then I can restart the process by using the -i option: Finally, I can mirror all links in the first level pages of the URLs I specify. A good example of where to use whis would be in a case where I have a page that points to a lot of other sites and I want to get the initial information on those sites before mirroring them: Many users use a proxy for many of their functions. This is a key component in many firewalls, but it is also commonly used for anonymizing access and for exploiting higher speed communications at a remote server. Proxy options: P proxy use (-P proxy:port or -P user:pass@proxy:port) %f *use proxy for ftp (f0 don't use) If you are using a standard proxy that doesn't require a user ID and password, you would do something like this: In this case, we have asusmed that proxy.www.all.net is the host that does the proxy service and that it uses port 8080 for this service. In some cases you will have to ask your network or firewall administrator for these details, however, in most cases they should be the same as the options used in your web browser. In some cases, a user ID and password are required for the proxy server. This is common in corporate environments where only authorized users may access the Internet. In this case, the user ID 'fc' and the password 'password' are used on proxy.www.all.net port 8080. Again, your network or firewall administrator can be most helpful in addressing the specifics for your environment. FTP normally operates through a proxy server, but for systems that have direct connections to the Internet, the following option should help: Limits options: rN set the mirror depth to N mN maximum file length for a non-html file mN,N' for non html (N) and html (N') MN maximum overall size that can be uploaded/scanned EN maximum mirror time in seconds (60=1 minute, 3600=1 hour) AN maximum transfer rate in bytes/seconds (1000=1kb/s max) GN pause transfer if N bytes reached, and wait until lock file is deleted %eN set the external links depth to N (* %e0) (--ext-depth[=N]) %cN maximum number of connections/seconds (*%c10) Setting limits provides the means by which you can avoid running out of disk space, CPU time, and so forth. This may be particularly helpful for those who accidentally try to image the whole Internet. In this example, we limit the directlry depth to 50 levels deep. As a general rule, web sites don't go much deeper than 20 levels or so, and if you think about it, if there are only 2 subdirectories per directory level, a directory structure 50 deep would have about 10 trillion directories. Of course many sites have a small number of files many levels deep in a directory structure for various reasons. In some cases, a symbolic link will cause an infinite recursion of directory levels as well, so placing a limit may be advisable. This example sets the maximum file length for non-HTML files to 50 megabytes. This is not an unusual length for things like tar files, and in some cases - for example when there are images of CD-ROMs to fetch from sites, you might want a limit more like 750 megabytes. In this example, we have set a limit for html files as well - at 100,000 bytes. HTML files are rarely larger than this, however, in some cases larger sizes may be needed. This option sets the maximum total size - in bytes - that can be uploaded from a site - in this case to 1 gigabyte. Depending on how much disk space you have, such an option may be worthwhile. This sets the maximum runtime for the download process. Of course depending on the speed of your connection it may take longer or shorter runtimes to get the same job done, and network traffic is also a factor. 3600 seconds corresponds to one hour. This option specifies the largest number of bytes per second that should be used for transfers. For example, you might want to go slow for some servers that are heavily loaded in the middle of the day, or to download slowly so that the servers at the other end are less likely to identify you as mirroring their site. The setting above limits my bandwidth to 100 million bytes per second - slow I know, but I wouldn't want to stress the rest of the Internet. In this case, the G option is used to 'pause' a download after the first gigabyte is downloaded pending manual removal of the lockfile. This is handy of you want to download some portion of the data, move it to secondary storage, and then continue - or if you want to only download overnight and want to stop before daylight and continue the next evening. You could even combine this option with a cron job to remove the lock file so that the job automatically restarts at 7PM every night and gets another gigabyte. In this case, httrack will only go to depth 5 for external links, thus not imaging the entire web, but only yhose links within 5 links of these web pages. Also note that the interaction of these options may cause unintended consequences. For example, limiting bandwidth and download time conspire to limit the total amount of data that can be downloaded. Flow control: cN number of multiple connections (*c8) %cN maximum number of connections/seconds (*%c10) TN timeout, number of seconds after a non-responding link is shutdown RN number of retries, in case of timeout or non-fatal errors (*R1) JN traffic jam control, minimum transfert rate (bytes/seconds) tolerated for a link HN host is abandonned if: 0=never, 1=timeout, 2=slow, 3=timeout or slow This example allows up to 128 simultaneous downloads. Note that this is likely to crash remote web servers - or at least fail to download many of the files - because of limits on the number of simultaneous sessions at many sites. At busy times of day, you might want to lower this to 1 or 2, especially at sites that limit the number of simultaneous users. Otherwise you will not get all of the downloads. Many operating systems have a limit of 64 file handles, including internet connections and all other files that can be opened. Therefore, in many cases, more that 48 connections might cause a \"socket error\" because the OS can not handle that many sockets. This is also true for many servers. As an example, a test with 48 sockets on a cgi-based web server (Pentium 166,80Meg RAM) overloaded the machine and stopped other services from running correctly. Some servers will ban users that try to brutally download the website. 8 sockets is generally good, but when I'm getting large files (e.g., from a a site with large graphical images) 1 or 2 sockets is a better selection. Here are some other figures from one sample set of runs: Tests: on a 10/100Mbps network, 30MB website, 99 files (70 images (some are little, other are big (few MB)), 23 HTML) With 8 sockets: 1,24MB/s With 48 sockets: 1,30MB/s With 128 sockets: 0,93MB/s The timeout option causes downloads to time out after a non-response from a download attempt. 30 seconds is pretty reasonable for many sites. You might want to increase the number of retries as well so that you try again and again after such timeouts. This limits the number of connections per second. It is similar to the above option but allows the pace to be controlled rather than the simultanaety. It is particulsrly useful for long-term pulls at low rates that allow little impact on remote infrastructure. The default is 10 connections per second. This example increases the number of retries to 5. This means that if a download fails 5 times, httrack will give up on it. For relatively unreliable sites - or for busy times of day, this number should be higher. This is an interesting option. It says that in a traffic jam - where downloads are excessively slow - we might decide to back off the download. In this case, we have limited downloads to stop bothering once we reach 10 bytes per second. These three options will cause the download from a host to be abandoned if (respectively) (0) never, (1) a timeout is reached, (2) slow traffic is detected, (or) (3) a timeout is reached OR slow traffic is detected. Of course these options can be combined to provide a powerful set of criteria for when to continue a download and when to give it up, how hard to push other sites. and how much to stress infrastructures. Links options: %P *extended parsing, attempt to parse all links, even in unknown tags or Javascript (%P0 don't use) n get non-html files 'near' an html file (ex: an image located outside) t test all URLs (even forbidden ones) %L add all URL located in this text file (one URL per line) The links options allow you to control what links are followed and what links are not as well as to provide long lists of links to investigate. Any setting other than the default for this option forces the engine to use less reliable and more complex parsing. 'Dirty' parsing means that links like 'xsgfd syaze=\"foo.gif\"' will cause HTTrack to download foo.gif, even if HTTrack don't know what the \"xsgfd syaze=\" tag actually means! This option is powerful because some links might otherwise be missed, but it can cause errors in HTML or javascript. This will direct the program to NOT search Javascript for unknown tag fields (e.g., it will find things like foo.location=\"bar.html\"; but will not find things like bar=\"foo.gif\";). While I have never had a reason to use this, some users may decide that they want to be more conservative in their searches. As a note, javascript imported files (.js) are not currently searched for URLs. Now here is a classic bit of cleaverness that 'does the right thing' for some cases. In this instance, we are asking httrack to get images - like gif and jpeg files that are used by a web page in its display, even though we would not normally get them. For example, if we were only getting a portion of a web site (e.g., everything under the 'bob directory') we might want to get graphics from the rest of the web sote - or the rest of the web - that are used in those pages as well so that our mirror will look right. Here, we limit the collection to bob's area of the server - except that we get images and other such things that are used by bob in his area of the server. This option 'tests' all links - even those forbidden (by the robot exclusion protocol) - by using the 'HEAD' protocol to test for the presence of a file. In this case, we use a file to list the URLs we wish to mirror. This is particularly useful when we have a lot to do and don't want to tirelessly type in URLs on command line after command line. It's also useful - for example - if you update a set of mirrored sites evey evening. You can set up a command like this to run automatically from your cron file. This will update the mirror of your list of sites whenever it is run. The link file is also useful for things like this example where, after a binary image of a hard disk was analyzed (image) URLs found on that disk were collected by httrack: Build options: NN name conversion type (0 *original structure, 1+: see below) N user defined structure (-N \"%h%p/%n%q.%t\") LN long names (L1 *long names / L0 8-3 conversion) K keep original links (e.g. http://www.adr/link) (K0 *relative link) x replace external html links by error pages o *generate output html file in case of error (404..) (o0 don't generate) X *purge old files after update (X0 keep delete) %x do not include any password for external password protected websites (%x0 include) (--no-passwords) %q *include query string for local files (information only) (%q0 don't include) (--include-query-string) The user can define naming conventions for building the mirror of a site by using these options. For example, to retain the original structure, the default is used. This only modifies the structure to the extent that select characters (e.g., ~, :, <, >, \\, and @) are replaced by _ in all pathnames. In either case, the mirror will build with the same directory hierarchy and name structure as the original site. For cases when you want to define your own structure, you use a string like this: In this case, %h, %p, $n, and %t stand for the href element (e.g., http://www.shoesizes.com or ftp://ftp.shoesizes.com), %p stands for the pathname (e.g., /bob/), %n stands for the name of the file, and %t stands for type (file extension). The full list of these options follows: %n Name of file without file type (ex: image) %N Name of file, including file type (ex: image.gif) %t File type (ex: gif) %p Path [without ending /] (ex: /someimages) %h Host name (ex: www.all.net) %M URL MD5 (128 bits, 32 ascii bytes) %Q query string MD5 (128 bits, 32 ascii bytes) %q small query string MD5 (16 bits, 4 ascii bytes) %s? Short name version (ex: %sN) Details: Option N N0 Site-structure (default) N1 HTML in web/, images/other files in web/images/ N2 HTML in web/HTML, images/other in web/images N3 HTML in web/, images/other in web/ N4 HTML in web/, images/other in web/xxx, where xxx is the file extension\n\n(all gif will be placed onto web/gif, for example) N5 Images/other in web/xxx and HTML in web/HTML N99 All files in web/, with random names (gadget !) N100 Site-structure, without www.domain.xxx/ N101 Identical to N1 exept that \"web\" is replaced by the site's name N102 Identical to N2 exept that \"web\" is replaced by the site's name N103 Identical to N3 exept that \"web\" is replaced by the site's name N104 Identical to N4 exept that \"web\" is replaced by the site's name N105 Identical to N5 exept that \"web\" is replaced by the site's name N199 Identical to N99 exept that \"web\" is replaced by the site's name N1001 Identical to N1 exept that there is no \"web\" directory N1002 Identical to N2 exept that there is no \"web\" directory N1003 Identical to N3 exept that there is no \"web\" directory (option set for g option) N1004 Identical to N4 exept that there is no \"web\" directory N1005 Identical to N5 exept that there is no \"web\" directory N1099 Identical to N99 exept that there is no \"web\" directory Long names are normally used (the -L0 option) but if you are imaging to a DOS file system or want accessibility from older versions of DOS and Windows, you can use the -L1 option to generate these filename sizes. With the 'K' option, you can keep the original links in files. While this is less useful in being able to view a web site froim the mirrored copy, it is vitally important if you want an accurate copy of exactly what was on the web site in the first place. In a forensic image, for example, you might want to use this option to prevent the program from modifying the data as it is collected. In this case, instead of leaving external links (URLs that point to sites not being mirrored) in the pages, these links are replaced by pages that leave messages indicating that they could not be found. This is useful for local mirrors not on the Internet or mirrors that are on the Internet but that are not supposed to lead users to external sites. A really good use for this is that 'bugging' devices placed in web pages to track who is using them and from where will be deactivated byt his process. This option prevents the generation of '404' error files to replace files that were not found even though there were URLs pointing to them. It is useful for saving space as well as eliminating unnecessary files in operations where a working web site is not the desired result. This option prevents the authoatic purging of files from the mirror site that were not found in the original web site after an 'update' is done. If you want to retain old data and old names for files that were renamed, this option should be used. If you want an up-to-date reflection of the current web site, you should not use this option. These options can be combined as desired to produce a wide range of different arrangements, from collections of only graphical files stored in a graphics area, to files identified by their MD5 checksums only, all stored in the same directory. This will not include passwords for web sites. If you mirror http://smith_john:foobar@www.privatefoo.com/smith/, and exclude using filters some links, these links will be by default rewritten with password data. For example, \"bar.html\" will be renamed into http://smith_john:foobar@www.privatefoo.com/smith/bar.html This can be a problem if you don't want to disclose the username/password! The %x option tell the engine not to include username/password data in rewritten URLs. This option is not very useful, because parameters are useless, as pages are not dynamic anymore when mirrored. But some javascript code may use the query string, and it can give useful information. For example: catalog4FB8.html?page=computer-science is clearer than catalog4FB8.html Therefore, this option is activated by default. These options provide for automation with regard to the remote server. For example, some sites require that cookies be accepted and sent back in order to allow access. Spider options: bN accept cookies in cookies.txt (0=do not accept,* 1=accept) u check document type if unknown (cgi,asp..) (u0 don't check, * u1 check but /, u2 check always) j *parse Java Classes (j0 don't parse) sN follow robots.txt and meta robots tags (0=never,1=sometimes,* 2=always) %h force HTTP/1.0 requests (reduce update features, only for old servers or proxies) %B tolerant requests (accept bogus responses on some servers, but not standard!) %s update hacks: various hacks to limit re-transfers when updating %A assume that a type (cgi,asp..) is always linked with a mime type (-%A php3=text/html) (--assume ) By default, cookies are universally accepted and returned. This makes for more effective collection of data, but allows the site to be identified with its collection of data more easily. To disable cookies, use this option: Some documents have known extension types (e.g., html), while others have unknown types (e.g., iuh87Zs) and others may have misleading types (e.g., an html file with a 'gif' file extension. These options provide for (0) not checking file types, (1) checking all file types except directories, and (2) checking all file types including directories. Choose from these options: Meta tags or 'robots.txt' files on a web site are used to indicate what files should and should not be visited by automatic programs when collectiong data. The polite and prudent move for normal data collection (and the default) is to follow this indication: This follows the robots protocol and meta-tags EXCEPT in cases where the filters disagree with the robots protocols or meta-tags. In this next case, we ignore meta-tags and robots.txt files completely and just take whatever we can get from the site. The danger of this includes the fact that automated programs - like games or search engines may generate an unlimited number of nearly identical or identical outputs that will put us in an infinite loop collecting useless data under different names. The benefit is that we will get all the data there is to get. This next option uses strict HTTP/1.0 protocol. This means the program will use HTTP/1.0 headers (as in RFC1945.TXT) and NOT extended 1.1 features described in RFC2616.TXT. For example, reget (complete a partially downloaded file) is a HTTP/1.1 feature. The Etag feature is also a HTTP/1.1 feature (Etag is a special identifier that allow to easily detect file changes). Some servers give responses not strictly within the requirements of the official http protocol. These 'Bogus' responses can be accepted by using this option. For example, when requesting foo.gif (5132 bytes), the server can, optionally, add: This helps the client by allowing it to reserve a block of memory, instead of collecting each byte and re-reserving memory each time data is being received. But some servers are bogus, and send a wrong filesize. When HTtrack detects the end of file (connection broken), there are three cases: 1- The connection has been closed by the server, and we have received all data (we have received the number of bytes incicated by the server). This is fine because we have successfully received the file. 2- The connection has been closed by the server, BUT the filesize received is different from the server's headers: the connection has been suddenly closed, due to network problems, so we reget the file 3- The connetion has been closed by the server, the filesize received is different from the server's headers, BUT the file is complete, because the server gave us a WRONG information! In this case, we use the bogus server option: These options can be combined for the particular needs of the situaiton and are often adapted as a result of site-specific experiences. This is a collection of \"tricks\" which are not really \"RFC compliant\" but which can save bandwidth by trying not to retransfer data in several cases. The most important new feature for some people, maybe. This option tells the engine that if a link is en countered, with a specific type (.cgi, .asp, or .php3 for example), it MUST assume that this link has always the same MIME type, for example the \"text/html\" MIME type. This is VERY important to speed up many mirrors. We have done tests on big HTML files (approx. 150 MB, 150,000,000 bytes!) with 100,000 links inside. Such files are being parsed in approx. 20 seconds on my own PC by the latest optimized releases of HTTra ck. But these tests have been done with links of known types, that is, html, gif, and so on.. If you have, say, 10,000 links of unknown type, such as \".asp\", this will cause the engine to test ALL t hese files, and this will SLOOOOW down the parser. In this example, the parser will take hours, instead of 20 seconds! In this case, it would be great to tell HTTrack: \".asp pages are in fact HTML pages\" This is possible, using: -%A asp=text/html The -%A option can be replaced by the alias --assume asp=text/html which is MUCH more clear. You can use multiple definitions, separed by \",\", or use multiple options. Therefore, these two lines are identical: The MIME type is the standard well known \"MIME\" type. Here are the most important ones: There is also a collection of \"non standard\" MIME types. Example: Therefore, you can give to all files terminated by \".mp3\" the MIME type: application/x-mp3 This allow you to rename files on a mirror. If you KNOW that all \"dat\" files are in fact \"zip\" files ren amed into \"dat\", you can tell httrack: You can also \"name\" a file type, with its original MIME type, if this type is not known by HTTrack. This will avoid a test when the link will be reached: In this case, HTTrack won't check the type, because it has learned that \"foo\" is a known type, or MIME type \"application/foobar\". Therefore, it will let untouched the \"foo\" type. A last remark, you can use complex definitions like: ..and save it on your .httrackrc file: Browsers commonly leave footprints in web servers - as web servers leave footprints in the browser. Browser ID: F user-agent field (-F \"user-agent name\") %F footer string in Html code (-%F \"Mirrored [from host %s [file %s [at %s]]]\" %l preffered language (-%l \"fr, en, jp, *\" (--language ) The user-agent field is used by browsers to determine what kind of browser you are using as well as other information - such as your system type and operating system version. The 'User Agent' field can be set to indicate whatever is desired to the server. In this case, we are claiming to be a netscape browser (version 1.0) running a non-exitent Solaris operating system version on a Sun Sparcstation. On the other side, we may wish to mark each page collected with footer information so that we can see from the page where it was collected from, when, and under what name it was stored. This makes a modified copy of the file that may be useful in future identification. While it is not 'pure' in some senses, it may (or may not) be considered siilar to a camera that adds time and date stamps from a legal perspective. \"I prefer to have pages with french language, then english, then japanese, then any other language\" A lot of options are available for log files, indexing of sites, and cached results: Log, index, cache C create/use a cache for updates and retries (C0 no cache,C1 cache is prioritary,* C2 test update before) k store all files in cache (not useful if files on disk) %n do not re-download locally erased files Q log quiet mode (no log) q quiet mode (no questions) z extra infos log Z debug log v verbose screen mode %v display on screen filenames downloaded (in realtime) (--display) f log file mode f2 one single log file (--single-log) I *make an index (I0 don't make) %I make an searchable index for this mirror (* %I0 don't make) (--search-index) A cache memory area is used for updates and retries to make the process far more efficient than it would otherwise be. You can choose to (0) go without a cache, (1) do not check remotly if the file has been updated or not, just load the cache content, or (2) see what works best and use it (the default). Here is the no cache example. The cache can be used to store all files - if desired - but if files are being stored on disk anyway (the normal process for a mirroring operation), this is not helpful. In some cases, a file from a mirror site is erased locally. For example, if a file contains inappropriate content, it may be erased from the mirror site but remain on the remote site. This option allows you to leave deleted files permanently deleted when you do a site update. If no log is desired, the following option should be added. If no questions should be asked of the user (in a mode that would otherwise ask questions), the following option should be added. httrack http://www.shoesizes.com -O /tmp/shoesizes -q By adding these options, you get (-z) extra log information or (-Z) debugging information, and (-v) verbose screen output. Multiple log files can be created, but by default, this option is used to put all logs into a single log file. Finally, an index is normally made of the sites mirrored (a pointer to the first page found from each specified URL) in an index.html file in the project directory. This can be prevented through the use of this option: Animated information when using consol-based version, example: Do not split error and information log (hts-log.txt and hts-err.txt) - use only one file (hts-log.txt) Still in testing, this option asks the engine to generate an index.txt, useable by third-party programs or scripts, to index all words contained in html files. The above example will produce index.txt: For expert users, the following options provide further options. Expert options: pN priority mode: (* p3) 0 just scan, don't save anything (for checking links) 1 save only html files 2 save only non html files *3 save all files 7 get html files before, then treat other files S stay on the same directory D *can only go down into subdirs U can only go to upper directories B can both go up&down into the directory structure a *stay on the same address d stay on the same principal domain l stay on the same location (.com, etc.) e go everywhere on the web %H debug HTTP headers in logfile One interesting application allows the mirror utility to check for valid and invalid links on a site. This is commonly used in site tests to look for missing pages or other html errors. I often run such programs against my web sites to verify that nothing is missing. To check for valid links outside of a site, the '-t' option can be used: These options can be combined, for example, to provide a service that checks sites for validity of links and reports back a list of missing files and statistics. Other options allow the retention of select files - for example - (1) only html files, (2) only non-html files, (3) all files, and (7) get all html files first, then get other files. This last option provides a fast way to get the web pointers so that, for example, a time limited collection process will tend to get the most important content first. In many cases, we only want the files froma given directory. In this case, we specify this option: This option allows the mirror to go only into subdirectories of the initial directory on the remote host. You might want to combine it with the -n option to get all non-html files linked from the pages you find. If you only want to work your way up the directory structure from the specified URL (don't ask me why you might want to do this), the following command line is for you: If you want to go both up and down the directory structure (i.e., anywhere on on this site that the requested page leads you to), this option will be best: The default is to remain on the same IP address - or host name. This option specifes this explicitly: If you want to restrict yourself only to the same principal domain (e.g., include sites liks ftp.shoesizes.com), you would use this option. To restrict yourself to the same major portion of the Internet (e.g., .com, .net, .edu, etc.) try this option: Finally, if you want to mirror the whole Internet - at least every place on the internet that is ever led to - either directly or indirectly - from the starting point, use this one... Please note that this will almost always run you out of resources unless you use other options - like limiting the depth of search. Last but not least, you can include debugging informaiton on all headers from a collection process by using this option: The options S, D, U, B, a, d, l, and e can be replaces with filter options approximately as follows: S -www.foo.com/* +www.foo.com/bar/*[file] D (default) U +www.foo.com/bar/* -www.foo.com/*[name]/* B +www.foo.com/bar/* a (default) d +*[name].foo.com/* l +*[name].com/* e +* (this is crazy unless a depth limit is used!) Guru Options - DO NOT USE!!! This is a new section, for all \"not very well documented options\". You can use them, in fact, do not believe what is written above! To test the filter system. Example: Useful if you want the hts-log.txt file to be flushed regularly (not buffered) Use if if you want to use more than the maximum default number of filters, that is, 500 filters: -#F2000 for 2,000 filters Use if if you want to use more than the maximum default number of links, that is, 100,000 links: -#L2000000 for 2,000,000 links Self-explanatory :) I will have to improve this one \"Catch URL\" feature, allows to setup a temporary proxy to capture complex URLs, often linked with POST action (when using form based authentication) Command-line specific options: V execute system command after each files ($0 is the filename: -V \"rm \\$0\") (--userdef-cmd ) This option is very nice for a wide array of actions that might be based on file details. For example, a simple log of all files collected could be generated by using: %U run the engine with another id when called as root (-%U smith) (--user ) Change the UID of the owner when running as r00t This new option is important: you can include query-string content when forming the destination filename! Example: you are mirroring a huge website, with many pages named as: www.foo.com/catalog.php3?page=engineering www.foo.com/catalog.php3?page=biology www.foo.com/catalog.php3?page=computing .. Then you can use the -N option: If found, the \"page\" parameter will be included after the filename, and the URLs above will be saved as: These options provide shortcust to combinations of other options that are commonly used. Shortcuts: --mirror *make a mirror of site(s) (default) --get get the files indicated, do not seek other URLs (-qg) --list add all URL located in this text file (-%L) --mirrorlinks mirror all links in 1st level pages (-Y) --testlinks test links in pages (-r1p0C0I0t) --spider spider site(s), to test links: reports Errors & Warnings (-p0C0I0t) --testsite identical to --spider --skeleton make a mirror, but gets only html files (-p1) --update update a mirror, without confirmation (-iC2) --continue continue a mirror, without confirmation (-iC1) --catchurl create a temporary proxy to capture an URL or a form post URL --clean erase cache & log files --http10 force http/1.0 requests (-%h) Mirror is the default behavior. It is detailed earlier. get simply gets the files specified on the command line. The list option is useful for including a list of sites to collect data from. The mirrorlinks option is ideal for using the result of a previous search (like a list of pages found in a web search or somebody's URL collection) to guide the collection of data. With additional options (such as depth 1) it can be used to collect all of the pages linked to a given page without going further. Here is an example: Testing links in pages is useful for automating the verification that a link from a file is not pointing to a non-existent page. The spider option does a site test automatically and returns errors for broken links. The skeleton option makes a mirror of html files only. The continue option continues a previously terminated mirroring activity. This is useful for all sorts of mirror failures. The catchurl option is a small application designed to catch difficult pages, like sites protected via formulas. You can see at http://httrack.free.fr/HelpHtml/addurl.html a Windows description of this application. The purpose is to create a temporary proxy, that will catch the user request to a page, and then store this request to continue the mirror. For example, 1. browse www.foo.com/bar/ until you have a page with a form 2. fill this form to enter the site BUT do not click \"submit\" 3. start the --catchurl application 4. change your browser proxy settings according to the --catchurl application 5. click on \"submit\" on your browser 6. HTTrack has now captured this click and has stored it 7. restore your proxy settings 8. (click back in your browser) The http10 option forces http/1.0 requests (the same as -%h). Filters are normally placed at the end of the command line, but can be intermixed with other command line options if desired, except that if they are placed between (for example) the '-O' and the pathname, your results may be different than you might otherwise predict. There are two sorts of filters, filters that indicate what to include (+) and filters that indicate what to exclude (-). Starting with the initially specified URLs, the default operation mode is to mirror starting from these URLs downward into the directory structure of the host (i.e. if one of your starting pagees was www.all.net/test/a.html, all links starting with www.all.net/test/ will be collected but links in www.all.net/anything-else will not be collected, because they are in a higher directory strcuture level. This prevents HTTrack from mirroring the whole site. If you may want to download files are in other parts of the site or pf particular types - or to not download files in a particular part of the site or of a particular type, you can use filters to specify more precisely what to collect and what not to collect. The syntax for filters is similar to Unix regular expressions. A simple filter can be made by using characters from the URL with '*' as a wildcard for 0 or more characters - with the last filter rule having the highest precendence. An initial '+' indicates URLs to include and an initial '-' indicated URLs to not include. For example: would only get files ending in the 'jpg' extension, while: would not get any files ending in the jpg extension. You can add more filter lines to restrict or expand the scope as desired. The last rule is checked first, and so on - so that the rules are in reverse priority order. Here's an example: Will accept all gif files BUT image1.gif,imageblue.gif,imagery.gif and so on Will accept all gif files, because the second pattern is prioritary (because it is defined AFTER the first one) The full syntax for filters follows: any characters (the most commonly used) any filename or name, e.g. not /,? and ; characters any path (and filename), e.g. not ? and ; characters any characters among 0..9 and a,z,e,r,t,y no characters must be present after size less than NN Kbytes and more than PP Kbytes Here are some examples of filters: (that can be generated automatically using the interface) This will refuse/accept this web site (all links located in it will be rejected) This will accept all links that contains .com in them This will refuse all links that contains cgi-bin in them This will accept all zip files in .com addresses This will refuse all tar (or tar.gz etc.) files in hosts containing someweb This will accept all links containing somepage (but not in the address) This will refuse all html files from anywhere in the world. Accept *.html, but the link must not have any supplemental characters at the end\n\n(e.g., links with parameters, like www.all.net/index.html?page=10 will not match this filter) refuse all gif files smaller than 5KB, exlude all zip files, EXCEPT zip files smaller than 10KB Smoe servers require user ID and password information in order to gain access. In this example, the user ID smith with password foobar is accessing www.all.net/private/index.html For more advanced forms of authentication, such as those involving forms and cookies of various sorts, an emerging capability is being provided through th URL capture features (--catchurl). This feature don't work all of the time. A file called '.httrackrc' can be placed in the current directory, or if not found there, in the home directory, to include command line options. These options are included whenever httrack is run. A sample .httrack follows: But the syntax is not strict, you can use any of these: .httrackrc is sought in the following sequence with the first occurence used:\n• in the dirctory indicated by -O option (.httrackrc)\n• in /etc/httrack.conf (named httrack.conf to be \"standard\") An example .httrackrc looks like: Each line is composed of an option name and a parameter. The \"set\" token can be used, but is not mandatory (it is ignored, in fact). The \"=\" is also optionnal, and is replaced by a space internally. The \"on\" and \"off\" are the same as \"1\" and \"0\" respectively. Therefore, the example .httrackrc above is equivalent to: Because the \"=\" seems to (wrongly) imply a variable assignment (the option can be defined more than once to define more than one filter) the following .httrackrc: looks better for a human than: Here's a example run with the example .httrackrc file: The \"-c8 -C1 -R2 +*.gif -ad.doubleclick.net/*\" was added by the .httrackrc Some things change between releases. Here are some recent changes in httrack that may affect some of these options: Options S,D,U,B, and a,d,l,e are default behaviours of HTTrack. they were the only options in old versions (1.0). With the introduction of filters, their roles are now limited, because filters can override them. Note for the -N option: \"%h%p/%n%q.%t\" will be now be used if possible. In normal cases, when a file does not have any parameters (www.foo.com/bar.gif) the %q option does not add anything, so there are no differences in file names. But when parameters are present (for example, www.foo.com/bar.cgi?FileCollection=133.gif), the additionnal query string (in this case, FileCollection=133.gif) will be \"hashed\" and added to the filename. For example: The additionnal 4 letters/digits are VERY useful in cases where there are a substantial number of identical files: www.all.net/bar.cgi?FileCollection=133.gif www.all.net/bar.cgi?FileCollection=rose.gif www.all.net/bar.cgi?FileCollection=plant4.gif www.all.net/bar.cgi?FileCollection=silver.gif and so on... In these cases, there is a small probability of a hash collision forlarge numbers of files. Here are some examples of special purpose httrack command lines that might be useful for your situation. This is a 'forensic' dump of a web site - intended to collect all URLs reachable from the initial point and at that particular site. It is intended to make no changes whatsoever to the image. It also prints out an MD5 checksum of each file imaged so that the image can be verified later to detect and changes after imaging. It uses 5 retries to be more certain than normal of getting the files, never abandons its efforts, keeps original links, does not generate error files, ignores site restrictions for robots, logs as much as it can, stays in the principal domain, places debugging headers in the log file, Here's an example of a site where I pulled a set of data related to some subject. In this case, I only wanted the relevant subdirectory, all external links were to remain the same, a verbose listing of URLs was to be printed, and I wanted files near (n) and below (D) the original directory. Five retries just makes sure I don't miss anything. This listing is, of course, rather verbose. To reduce the noise, you might want to do something more like this: A still quieter version - without any debugging information but with a list of files loaded looks like this: For the strong silent type, this might be still better: Q: The install is not working on NT without administrator rights! A: That's right. You can, however, install WinHTTrack on your own machine, and then copy your WinHTTrack folder from your Program Files folder to another machine, in a temporary directory (e.g. C:\\temp\\) A: Windows interface is available on several languages, but not yet the documentation! Q: What's the difference between HTTrack and WinHTTrack? A: WinHTTrack is the Windows release of HTTrack (with a graphic shell) A: No, because of a lack of time. But sources are available Q: Can HTTrack be compiled on all Un*x? A: It should. The Makefile may be modified in some cases, however Q: I use HTTrack for professional purpose. What about restrictions/license fee? A: There is no restrictions using HTTrack for professional purpose, except if you want to sell a product including HTTrack components (parts of the source, or any other component). See the license.txt file for more informations A: Not yet. But, again, sources are available (see license.txt for distribution infos) Q: Is there a X11/KDE shell available for Linux and Un*x? A: No. Unfortunately, we do not have enough time for that - if you want to help us, please write one! Q: Only the first page is caught. What's wrong? A: First, check the hts-err.txt error log file - this can give you precious informations. The problem can be a website that redirects you to another site (for example, www.all.net to public.www.all.net) : in this case, use filters to accept this site This can be, also, a problem in the HTTrack options (link depth too low, for example) Q: With WinHTTrack, sometimes the minimize in system tray causes a crash! A: This bug sometimes appears in the shell on some systems. If you encounter this problem, avoid minimizing the window! Q: Files are created with strange names, like '-1.html'! A: Check the build options (you may have selected user-defined structure with wrong parameters!) Q: When capturing real audio links (.ra), I only get a shortcut! A: Yes. The audio/video realtime streaming capture is not yet supported Q: Using user:password@address is not working! A: Again, first check the hts-err.txt error log file - this can give you precious informations The site may have a different authentication scheme (form based authentication, for example) Q: When I use HTTrack, nothing is mirrored (no files) What's happening? A: First, be sure that the URL typed is correct. Then, check if you need to use a proxy server (see proxy options in WinHTTrack or the -P proxy:port option in the command line program). The site you want to mirror may only accept certain browsers. You can change your \"browser identity\" with the Browser ID option in the OPTION box. Finally, you can have a look at the hts-err.txt (and hts-log.txt) file to see what happened. A: You may want to capture files that are in a different folder, or in another web site. In this case, HTTrack does not capture them automatically, you have to ask it to do. For that, use the filters. Example: You are downloading http://www.all.net/foo/ and can not get .jpg images located in http://www.all.net/bar/ (for example, http://www.all.net/bar/blue.jpg) Then, add the filter rule +www.all.net/bar/*.jpg to accept all .jpg files from this location You can, also, accept all files from the /bar folder with +www.all.net/bar/*, or only html files with +www.all.net/bar/*.html and so on.. Q: I'm downloading too many files! What can I do? A: This is often the case when you use too large filters, for example +*.html, which asks the engine to catch all .html pages (even ones on other sites!). In this case, try to use more specific filters, like +www.all.net/specificfolder/*.html If you still have too many files, use filters to avoid somes files. For example, if you have too many files from www.all.net/big/, use -www.all.net/big/* to avoid all files from this folder. Q: File types are sometimes changed! Why? A: By default, HTTrack tries to know the type of remote files. This is useful when links like http://www.all.net/foo.cgi?id=1 can be either HTML pages, images or anything else. Locally, foo.cgi will not be recognized as an html page, or as an image, by your browser. HTTrack has to rename the file as foo.html or foo.gif so that it can be viewed. Sometimes, however, some data files are seen by the remote server as html files, or images : in this case HTTrack is being fooled.. and rename the file. You can avoid this by disabling the type checking in the option panel. Q: I can not access to several pages (access forbidden, or redirect to another location), but I can with my browser, what's going on? A: You may need cookies! Cookies are specific datas (for example, your username or password) that are sent to your browser once you have logged in certain sites so that you only have to log-in once. For example, after having entered your username in a website, you can view pages and articles, and the next time you will go to this site, you will not have to re-enter your username/password. To \"merge\" your personnal cookies to an HTTrack project, just copy the cookies.txt file from your Netscape folder (or the cookies located into the Temporary Internet Files folder for IE) into your project folder (or even the HTTrack folder) Q: Some pages can't be seen, or are displayed with errors! A: Some pages may include javascript or java files that are not recognized. For example, generated filenames. There may be transfer problems, too (broken pipe, etc.). But most mirrors do work. We still are working to improve the mirror quality of HTTrack. Q: Some Java applets do not work properly! A: Java applets may not work in some cases, for example if HTTrack failed to detect all included classes or files called within the class file. Sometimes, Java applets need to be online, because remote files are directly caught. Finally, the site structure can be incompatible with the class (always try to keep the original site structure when you want to get Java classes) If there is no way to make some classes work properly, you can exclude them with the filters. They will be available, but only online. Q: HTTrack is being idle for a long time without transfering. What's happening? A: Maybe you try to reach some very slow sites. Try a lower TimeOut value (see options, or -Txx option in the command line program). Note that you will abandon the entire site (except if the option is unchecked) if a timeout happen You can, with the Shell version, skip some slow files, too. Q: I want to update a site, but it's taking too much time! What's happening? A: First, HTTrack always tries to minimize the download flow by interrogating the server about the file changes. But, because HTTrack has to rescan all files from the begining to rebuild the local site structure, it can takes some time. Besides, some servers are not very smart and always consider that they get newer files, forcing HTTrack to reload them, even if no changes have been made! Q: I am behind a firewall. What can I do? A: You need to use a proxy, too. Ask your administrator to know the proxy server's name/port. Then, use the proxy field in HTTrack or use the -P proxy:port option in the command line program. A: We are trying to avoid bugs and problems so that the program can be as reliable as possible. But we can not be infallible. If you occurs a bug, please check if you have the latest release of HTTrack, and send us an email with a detailed description of your problem (OS type, addresses concerned, crash description, and everything you deem to be necessary). This may help the other users too. Q: I want to update a mirrored project, but HTTrack is retransfering all pages. What's going on? A: First, HTTrack always rescan all local pages to reconstitute the website structure, and it can take some time. Then, it asks the server if the files that are stored locally are up-to-date. On most sites, pages are not updated frequently, and the update process is fast. But some sites have dynamically-generated pages that are considered as \"newer\" than the local ones.. even if there are identical! Unfortunately, there is no possibility to avoid this problem, which is strongly linked with the server abilities. Q: I want to mirror a Web site, but there are some files outside the domain, too. How to retrieve them? A: If you just want to retrieve files that can be reached through links, just activate the 'get file near links' option. But if you want to retrieve html pages too, you can both use wildcards or explicit addresses ; e.g. add www.all.net/* to accept all files and pages from www.all.net. Q: I have forgotten some URLs of files during a long mirror.. Should I redo all? A: No, if you have kept the 'cache' files (in hts-cache), cached files will not be retransfered. Q: I just want to retrieve all ZIP files or other files in a web site/in a page. How do I do it? A: You can use different methods. You can use the 'get files near a link' option if files are in a foreign domain. You can use, too, a filter adress: adding +*.zip in the URL list (or in the filter list) will accept all ZIP files, even if these files are outside the address. Example : httrack www.all.net/someaddress.html +*.zip will allow you to retrieve all zip files that are linked on the site. Q: There are ZIP files in a page, but I don't want to transfer them. How do I do it? A: Just filter them: add -*.zip in the filter list. Q: I don't want to load gif files.. but what may happen if I watch the page? A: If you have filtered gif files (-*.gif), links to gif files will be rebuild so that your browser can find them on the server. Q: I get all types of files on a web site, but I didn't select them on filters! A: By default, HTTrack retrieves all types of files on authorized links. To avoid that, define filters like Q: When I use filters, I get too many files! A: You are using too large a filter, for example *.html will get ALL html files identified. If you want to get all files on an address, use www.<address>/*.html. There are lots of possibilities using filters. Q: When I use filters, I can't access another domain, but I have filtered it! A: You may have done a mistake declaring filters, for example +www.all.net/* -*all* will not work, because -*all* has an upper priority (because it has been declared after +www.all.net) Q: Must I add a '+' or '-' in the filter list when I want to use filters? A: YES. '+' is for accepting links and '-' to avoid them. If you forget it, HTTrack will consider that you want to accept a filter if there is a wild card in the syntax - e.g. +<filter> if identical to <filter> if <filter> contains a wild card (*) (else it will be considered as a normal link to mirror) Q: I want to find file(s) in a web-site. How do I do it? A: You can use the filters: forbid all files (add a -* in the filter list) and accept only html files and the file(s) you want to retrieve (BUT do not forget to add +<website>*.html in the filter list, or pages will not be scanned! Add the name of files you want with a */ before ; i.e. if you want to retrieve file.zip, add */file.zip) Q: I want to download ftp files/ftp site. How to do? A: First, HTTrack is not the best tool to download many ftp files. Its ftp engine is basic (even if reget are possible) and if your purpose is to download a complete site, use a specific client. You can download ftp files just by typing the URL, such as ftp://ftp.www.all.net/pub/files/file010.zip and list ftp directories like ftp://ftp.www.all.net/pub/files/ . Note: For the filters, use something like +ftp://ftp.www.all.net/* Q: How can I retrieve .asp or .cgi sources instead of .html result? A: You can't! For security reasons, web servers do not allow that. Q: How can I remove these annoying <!-- Mirrored from... --> from html files? A: Use the footer option (-&F, or see the WinHTTrack options) Q: Do I have to select between ascii/binary transfer mode? A: No, http files are always transfered as binary files. Ftp files, too (even if ascii mode could be selected) A: Yes. See the URL capture abilities (--catchurl for command-line release, or in the WinHTTrack interface) A: Yes. See the shell system command option (-V option for command-line release) Q: Can I use username/password authentication on a site? A: Yes. Use user:password@your_url (example: http://foo:bar@www.all.net/private/mybox.html) Q: Can I use username/password authentication for a proxy? A: Yes. Use user:password@your_proxy_name as your proxy name (example: smith:foo@proxy.mycorp.com) A: Yes. See the build options (-N, or see the WinHTTrack options) Q: If there any SOCKS support? Q: What's this hts-cache directory? Can I remove it? A: NO if you want to update the site, because this directory is used by HTTrack for this purpose. If you remove it, options and URLs will not be available for updating the site Q: Can I start a mirror from my bookmarks? A: Yes. Drag&Drop your bookmark.html file to the WinHTTrack window (or use file://filename for command-line release) and select bookmark mirroring (mirror all links in pages, -Y) or bookmark testing (--testlinks) Q: I am getting a \"pipe broken\" error and the mirror stops, what should I do? A: Chances are this is a result of downloading too many pages at a time. Remote servers may not allow or be able to handle too many sessions, or your system may be unable to provide the necessary resources. Try redusing this number - for example using the -c2 options for only 2 simultaneous sesions."
    },
    {
        "link": "https://httrack.com",
        "document": ""
    },
    {
        "link": "https://httrack.com/html",
        "document": ""
    },
    {
        "link": "https://wikihow.com/Use-HTTrack",
        "document": "Mirror a website to your computer with this simple tool HTTrack is a free and open source web crawler you can use to download entire websites. By default, HTTrack arranges the downloaded site by the original site's relative link-structure. Once you download a website with HTTrack, you can browse it in your preferred web browser. This wikiHow will teach you how to use HTTrack on Windows or Linux to download a website to your PC.\n• Install HTTrack. You can download it from You can download it from https://www.httrack.com . The software is available on both Windows and Linux.\n• Open HTTrack and choose a project name. This will be the name of the folder containing your project. One project can include copies of multiple websites.\n• Optionally, enter a base path. The default path creates a websites directory in your home directory, but you can choose another location if you'd like.\n• Select an action. Click the menu at the top, and choose the option that fits what you want to do. The most common options are:\n• Chose Download web site(s) to mirror a website with its default options.\n• Choose Download website(s) + questions if you want to be prompted about links to download.[1] Click the menu at the top, and choose the option that fits what you want to do. The most common options are:\n• Enter the URL(s) of the websites you want to mirror. If you're downloading multiple websites, place each URL on a separate line.\n• You can click Set options… to choose other options, including certain file types to download or skip, recursion preferences, and the address of your proxy server. If you're downloading multiple websites, place each URL on a separate line.\n• Choose your final preferences and click . If you want, you can choose options such as delaying the start of the downloading or disconnecting when finished first.\n• Watch the site(s) download in real time. HTTrack will now download the websites you entered with your preferred preferences.\n\nAdd New Question\n• Can I use HTTrack to copy all of the code on a website? Also, can I use this code to develop on my own site? It depends. If you're planning to rip the website from a forum or from big websites, those websites depend on scripts located outside of the website, so the code is only compatible with that website. I suppose if it's a small website and doesn't depend on a database, then that might work. Include your email address to get a message when this question is answered. Submit"
    },
    {
        "link": "https://hostinger.com/tutorials/wget-command-examples",
        "document": "What is the wget command and how to use it (12 examples included)\n\nThis guide teaches you how to use the wget command on Linux. It provides 12 examples of wget commands in action to help you use them. Once you’re done, you’ll know all about wget and how to use it to get files from the web.\n\nWhat is the wget command?\n\nWget is a command-line tool that makes it possible to download files from the internet directly to your active directory. It operates in the background, allowing tasks to continue even if you’re offline. The name is a combination of World Wide Web and the word get. It supports downloads via FTP, SFTP, HTTP, and HTTPS.\n\nWget is created in portable C and is usable on any Unix system. It’s also possible to implement on Mac OS X, Microsoft Windows, AmigaOS, and other popular platforms.\n\nFor this wget command demonstration, we’ll be using Ubuntu 22.04. But the syntax will work on any other Linux distribution too.\n\nTo install wget on Ubuntu 22.04, execute the following command:\n\nTo install wget on CentOS 9 Sream or its previous distros, use:\n\nOnce the setup finishes, you’ll be ready to use it. Also, the knowledge of basic SSH commands can make things easier.\n\nTo get you started, we’ll provide 12 wget command examples that you can use for everyday tasks. Keep in mind that you may also call this function from scripts and cron jobs!\n\nOne of the most basic wget command examples is downloading a single file and storing it in your current working directory. For example, you may get the latest version of WordPress by using the following:\n\nHere is the output that you will see:\n\nIn this example, a file named latest.zip will be downloaded in the current working directory. You’ll also see extra information, such as the download progress, speed, size, time, and date.\n\nWe can take wget usage one step further and download multiple files at once. To do that, we will need to create a text document and place the download URLs there. In this example, we will retrieve the latest versions of WordPress, Joomla, and Drupal by using wget. Enter the following:\n\nThis will create an example.txt file and open a text editor interface. Paste these links there:\n\nOnce done, you may use -i to get all the files stored in your example text file:\n\nWait for the process to finish, and you’ll have the installations of the three most popular content management systems.\n\nUsing wget command to get files under different names\n\nIn this wget example, we will save a file using a different name with the help of the -O option:\n\nIn this case, the downloaded resource will be saved as wordpress-install.zip instead of its original name.\n\nThe -O option makes unzipping archives in Linux more efficient, as you don’t need to retype the full name.\n\nUsing wget command to save files in specified directory\n\nYou can utilize wget to place a file in another directory using the -P function:\n\nThe file you retrieve using this syntax will appear in the documents/archives/ folder.\n\nWith wget, you can also limit the download speed. This is useful when retrieving huge files and will prevent the command from using all of your bandwidth. This wget example will set the limit to 500k:\n\nInternet connection problems can interrupt your download. To tackle this issue, we can increase the retry attempts using the -tries function:\n\nUsing wget command to download in background\n\nFor extremely large files, you may take advantage of the -b function. It will download your content in the background.\n\nA wget-log will appear in your working directory, which can be used to check your download progress and status. You can also use the tail command:\n\nUsing wget command to download via FTP\n\nThe command is also usable with FTP. All you need to do is specify the username and password like in this wget example:\n\nYour download can get interrupted if you lose the internet connection or experience a power outage. This is quite a common occurrence when getting huge files. Instead of starting over, it’s possible to continue the download using the -c function:\n\nIf you proceed without the -c function, the new file will have .1 added at the end as it already exists.\n\nUsing wget command to retrieve whole websites\n\nIt is also possible to use the wget command to download the content of an entire site. This will let you view it locally without an internet connection. Here is an example:\n\nLet’s analyze the ingredients of this wget command:\n\nOnce the process finishes, you’ll be able to open the downloaded website locally and find all the files in the documents/websites/ folder.\n\nLet’s try something more advanced. We can use the wget command to locate all broken URLs that display a 404 error on a specific website. Start by executing the following:\n\nWe may now investigate the wget-log file to find the list of broken links. Here’s the command to do it:\n\nIf you have files or images numbered in a certain list, you may easily download all of them with the following syntax:\n\nCongratulations! By completing this tutorial, you have learned various uses of the wget command. You can now utilize it to get single or multiple files. In addition, you’ve learned some advanced uses, such as downloading a whole website or locating broken URLs. For more information, you may also check the official documentation.\n\nAre there any hidden tips or tricks that you want to share? Feel free to do so in the comments below!"
    },
    {
        "link": "https://phoenixnap.com/kb/wget-command-with-examples",
        "document": "is a free GNU command-line utility tool used to download files. It retrieves files using HTTP, HTTPS, and FTP protocols and is useful for downloads in unstable networks.\n\nIn this article, you will learn how to use the command with examples.\n\nis a tool that sustains file downloads in unstable and slow network connections. If a network problem occurs during a download, this software resumes file retrieval without starting from scratch.\n\nAnother useful feature is performing recursive downloads. transfers not only individual files but also entire directory structures by following links. As a result, the tool creates local copies of entire web pages, maintaining their structure and content.\n\nThe command is highly flexible and works in terminals, scripts, and cron jobs. The user does not have to be active or logged in during the download.\n\nThe following text lists some crucial benefits and risks of using .\n\nThe tool has many features and benefits. Some of them are listed below:\n• Resuming downloads. supports the ability to resume interrupted downloads. This feature is useful for large files or unstable connections.\n• Bandwidth control. allows users to limit bandwidth usage during downloads, enabling better management of network resources.\n• Versatility. The tool handles protocols such as HTTP, HTTPS, and FTP, making it versatile for downloading content from different sources.\n• Scriptability. Using the command in a CLI makes integrating into scripts or automated workflows for repetitive tasks easy.\n\nWhile offers features for uninterrupted and easy downloads, there are some risks you should be aware of:\n• Unintended downloads. The tool sometimes inadvertently downloads large volumes of data or entire websites if not used cautiously.\n• Server overload. Careless utilization of , particularly with recursive downloads, burdens servers excessively, potentially breaching website usage guidelines.\n• Security issues. Employing to retrieve content from dubious sources or via maliciously constructed URLs exposes systems to security threats like malware or phishing schemes.\n• Incomplete mirroring. Recursive downloads sometimes don't capture dynamically generated content or interactive elements, leading to incomplete local replicas of websites.\n• Legal concerns: The use of for specific content types sometimes infringes upon copyright or intellectual property rights.\n\nHow to Check if wget Is Installed\n\nThe package is most likely already on the system, as it often comes pre-installed.\n\nTo check the tool is available on your system, run the command without any options:\n\nIf is already installed, the output shows the command is missing a URL:\n\nOtherwise, the output looks like this if is not installed:\n\nIf the output shows the tool is not installed on your system, you can install it manually. Below are the installation instructions for Ubuntu/Debian, CentOS, Windows, and MacOS.\n\nBefore installing on Ubuntu, update the repository with:\n\nNext, install the tool on Ubuntu or Debian releases with:\n\nTo install on CentOS or Fedora, type the following command:\n\nTo install and configure on Windows:\n\n1. Download wget for Windows and install the package.\n\n2. Copy and paste the wget.exe file to the system32 folder.\n\nTo install on macOS, first install Homebrew, a package manager for macOS. The tool doesn't come with the system by default.\n\nThe syntax has the following pattern:\n\ncan run with no options as long as the URL is provided. The command performs a basic download of the resource located at the URL, using default settings for the download process. However, using options allows users to modify the download process.\n\nThe arguments specify how to download content from the URL. The most common options are in the table below.\n\nDue to an abundance of available options, has plenty of use-case scenarios. The following text presents some common practical examples.\n\nTo download a file from the web, use:\n\nFor example, to download the file to install the Puppet server package on Ubuntu, enter:\n\nDownload File and Specify a Name\n\nTo download a file and save it under a specified name, run:\n\nThe command allows users to rename files before downloading them.\n\nThe command instructed to download the specified file and name it PupperServer.\n\nBy default, downloads a file in the directory the user is in. To save the file in a different location, use:\n\nFor example, download the Puppet server to ./Documents with the following command:\n\nSet the download speed when downloading a big file so it does not use the full available bandwidth. The download speed is defined in kilobytes (k) and megabytes (m). Use the command:\n\nFor example, to get Python3 on Linux and limit the download speed to 1 megabyte, use the command:\n\nInstead of having to start from scratch, is able to resume downloading where it stopped before the interruption. This is a useful feature if there is a loss of connection while downloading a file.\n\nFor instance, the download of the script for Pip installation has stopped:\n\nallows downloading multiple files at the same time using the command:\n\nTo do so, follow the steps outlined below:\n\n1. First, create and open a file under the name MultipleDownloads.txt (or a name of your choice) using a text editor. In this case, we used Vim:\n\n2. Once in the editor, add the URLs of the packages you want to download, one per line.\n\n4. Run the command in the terminal window:\n\nThis prompts to download from each URL specified in the text file.\n\nis able to download an entire website using the option. It prompts to create a specified website mirror. The basic command for doing so is:\n\nallows users to download in the background, a practical feature when dealing with a large file. The syntax is:\n\nFor instance, download Puppet in the background with:\n\nCheck the download status with the tail command:\n\nSet how many times attempts to download a file after being interrupted by a network issue with this command:\n\nBy default, the number of retry attempts is set to 20.\n\nAnother option is to set the number to infinity with the values 0 or inf, as in the following example:\n\nBy default, checks whether the server has a valid SSL/TLS certificate. If it does not identify an authentic certificate, it refuses to download.\n\nThe option avoids certificate authorities checking for a server certificate. However, utilize it only when assured of the website’s credibility. The syntax is:\n\nIf http://enteratonerisk.com has an untrusted certificate but doesn't harm the system, download it with:\n\nWhen downloading a webpage, essentially emulates a browser. In some cases, the output shows a lack of permission to access the server, or the connection is forbidden. This is likely because a website blocks client browsers with a specific \"User-Agent\".\n\n\"User-Agent\" is a header field the browser sends to the server it wants to access. Therefore, to download from a server refusing to connect, try to modify the user agent.\n\nFind a database of all user agents online, find the one needed, and run the command:\n\nFor example, to emulate Chrome (version 100), change the user agent with the command:\n\nAfter reading this article, you now know how to use the tool by following practical examples.\n\nNext, learn how to fix the wget: command not found error."
    },
    {
        "link": "https://utmlibrary.github.io/toolkit/workshops/wget",
        "document": "Wget is a free command line utility for non-interactive downloads of files from the web to retrieve online material. It supports HTTP, HTTPS, and FTP protocols, as well as retrieval through HTTP procies. Wget can also follow links in HTML, XHTML, and CSS pages, to create local versions of remote websites, fully recreating the directory structure of the original site. This means researchers can use wget to gather copies of online digital content for their research projects.\n\nAs you can imagine, wget can be quite useful if you are interested in building an archive of online data from websites, which could include documents, videos, images, and audio files. However, while wget can retrieve almost anything online it is important to read the end-user license agreements (EULAs) of websites you download from and know what falls under fair use when you download copies of files. In the documentation provided in this workshop, we only cover how you can download online digital files from public websites, such as Government Archives. Downloading data from social media accounts, digital game sites, and other login platform-based services is not covered in this workshop. If you are in doubt about whether your research project meets ethics requirements and fair use of copyrighted works you can consult your instituitonal research office and scholarly communications officer. If you do not have access to such resources take a look at our Resources page for more information.\n\nThere are some fantastic resources out there to learn how to use wget for a variety of purposes beyond digital research. The most important resource to consult is the Wget Manual by the Free Software Foundation, the developers of the GNU operating system and wget. The manual includes all the relevant commands for how to use wget.\n\nThere are also some useful tutorials with a focus on digital research. The Programming Historian has two workshops on wget with a focus on creating a web archive for digital research, which most of this site’s documentation is derived from:\n\nDigital research ethics of online material is a constantly moving fence. Most post-secondary institutions have Research Offices with policies on the use of human data, which can include data posted on social media posted behind password protested accounts. Check in with your research office if the data you intend to collect from online sources was created by humans to learn more about ethical decision-making of online data. For faculty, staff, and students at UTM, you can contact our Research Office to learn more about Ethics in Research.\n\nA good first resource to consult if you are wanting a quick-and-fast answer to your ethical decision-making of online data is the Association of Internet Research’s recommendations from its Ethical Working Committee. The Committee is constantly updating its documentation and its current recommendations along with a condensed information chart are a good starting point to determine your research ethics:\n\nCopyright has an impact on digital research activities, including the copying of files from the internet using wget. Most post-secondary institutions have Scholarly Communication and Copyright offices with copyright guidelines on fair dealing. Check in with your scholarly communication and copyright office if you are not sure your data collection falls under fair dealing. For faculty, staff, and students at UTM, you can contact our Scholarly Communication Librarian to learn more about copyright fair dealing. The University has also put together a number of resources you can consult if you need a quick-and-fast answer:\n\nSome other useful resources to consult on copyright fair dealing include:\n\nCanadian Association of Research Libraries’ fair dealing documentation\n\n The Writers Union of Canada’s fair dealing documentation\n\n Council of Ministers of Education’s fair dealing decision tool\n\nNote, these copyright resources only pertain to the Copyright Act for fair dealing in Canada and does not cover copyright in other jurisdictions. For international researchers please consult your own scholarly communication and copyright offices and resources on fair use or fair dealing of copyrighted works in digital research.\n\nBefore we begin with the workshop component of how to use Wget for digital research there is some preliminary setup we have to complete on your computer. Since wget is used through the command line, we have to install packages onto your computer for it work. Depending on which operating system you use, setup can be straightforward or the most time consuming aspect of learning how to use wget. Below are installation instructions for Linux, Windows, and OS X users. Once wget is installed on each system, the instructions will be the same for every user participating in the workshop.\n\nIf you are using Linux operating system, then you should already have wget installed–hooray! To check if wget is already installed on your Linux system, open up your command line. In the command prompt, type and press enter. If wget is already installed the system will respond with:\n\n\n\n \n\n Try 'wget --help' for more options.\n\nIf wget is not installed on your system it will respond with:\n\nIf you receive this error message, follow the OS X instructions below.\n\nThe easiest way is to download a working version. To do so, visit this website and, download (as of writing it is version 1.20, and you should download the 32-bit binary). The file is the second link in the 32-bit binary column, entitled just .\n\nIf you place in your directory, you can then use wget from anywhere on your computer. This will make your life easier as you will not have to worry about always running wget from only one place on your system. If it is in this directory, Windows will know that the command can be used anywhere in your terminal window.\n\nNow that Wget is installed, you can open the Command Prompt terminal window. You can access the Command Prompt by typing in the search bar by Start and opening the application. In the Command Prompt, type and press enter. If wget is already installed the system will respond with:\n\n\n\n \n\n Try 'wget --help' for more options.\n\nIf wget is not installed on your system it will respond with:\n\nIf you receive this error message, check through the instructions above to make sure you didn’t miss a step.\n\nOn OS X, there are two ways to get wget and install it. The easiest is to install a package manager and use it to automatically install wget. There is a second method, discussed below, that involves compiling it.\n\nBoth, however, require that you install Apple’s ‘Command Line Tools’ to use properly. This requires downloading XCode. If you have the ‘App Store’, you should be able to just download XCode via this link. If not, the following instructions will work.\n\nTo download this, go to the Apple Developer website, register as a developer, and then in the downloads for Apple developers section you will need to find the correct version. If you are on the most recent version, Lion as of July 2012, you can use the main link. If not, you will need to click on the link: “Looking for additional developer tools? View Downloads.”\n\nAfter logging in with your free developer credentials, you will see a long list. Type xcode in the search bar and find a version that is compatible with your operating system version. This may take some clicking around to find the right version for you. For example, Xcode 3.2 is the version for OS X 10.6 Snow Leopard, 3.0 is the version for OS X 10.5 Leopard, etc.\n\nIt is a big download, and will take some time. Once you have the file, install it.\n\nYou will need to install the ‘Command Line Tools’ kit in XCode. Open up the ‘Preferences’ tab, click on ‘Downloads,’ and then click ‘Install’ next to Command Line Tools. We are now ready to install a package manager.\n\nThe easiest package manager to install is Homebrew. Go to https://brew.sh and review the instructions. There are many important commands, like wget, that are not included by default in OS X. This program facilitates the downloading and installation of all required files.\n\nTo install Homebrew, open up your terminal window and type the following:\n\nThis uses the ruby programming language, built into OS X, to install Homebrew. To see if the installation worked, type the following into your terminal window:\n\nA list of documentation options should appear if it has been installed. We have one more command to run to make sure everything is working, which is:\n\nWith Homebrew installed, we now have to install wget. This is now an easy step.\n\nIt will proceed to download the most recent version of wget, which is wget 1.14. After the script stops running, and you are back to your main window, enter the following command into the terminal:\n\nIf wget has installed, you will see:\n\n\n\n \n\n Try 'wget --help' for more options.\n\nIf wget is not installed on your system it will respond with:\n\nAt this point, however, wget should be installed successfully. If it is not installed, go through each of the steps above to make sure you did not make a mistake installing Homebrew.\n\nDoes your research require you to build an archive of data from public websites? In this workshop attendees will learn how to automatically download webpages with the wget program in your command line interface without going through the tedious process of manually downloading webpages. Attendees will also be guided through the process of cleaning up data once it’s downloaded.\n\nFor this workshop we are going to walk through a few exercises using wget in your operating system’s command line interface: terminal for Linux and OS X and Ubuntu for Windows. If you have followed the setup instructions to install wget on your Linux, Windows, or OS X machines then you are ready to begin the workshop.\n\nBefore we begin there are a couple of exercises we need to go through before we can start the workshop. The first exercise is to make sure wget is installed. In the command prompt type in the following command and hit enter:\n\nAlternatively, you can type an abbreviated command and hit enter:\n\nNote that the uppercase is important. If you type you will receive an error message. Upper case and lower case characters are important with wget, like most programs in the command line.\n\nAfter you type the command and hit enter you should receive a version message followed by information about your installation of wget, including copyright, license, and developer information:\n\nNow that we know wget is installed and ready to go on your computer for some digital research we can try a few other commands. Another command that is really useful if you need instructions to help you craft your command is the help function. In the command prompt type in the following command and hit enter:\n\nAlernatively, you can type an abbreviated command and hit enter\n\nNote that the lowercase is important. If you type you will invoke the ‘go to foreign hosts when recrusive’ command and retrieve an error code because you have completed your command string.\n\nAfter you type in the command and hit enter you should receive a version message followed by a list of commands you can invoke using wget:\n\nYou will notice this second line starting with shows you how to use wget. You begin with the command followed by your options and ends with the URL where you want to retrieve web data. The options are listed in the command printout after you enter or , which includes commands for:\n\nYou will observe that there are several command options, sometimes dozens, under each category. The list of commands might seem overwhelming, but rest assured we will only be using a handful in this workshop. It is important, however, to take note of the range of options available to you in wget because there is likely an option or string of options that will enable you to complete your digital research.\n\nLet’s take an example file from the web. Say you want to download a news article hosted on The Medium website, UTM’s student newspaper. First though, we need to create a folder for you to deposit your data. In your working directory, make a new directory. Let’s call it wget-medium. To make sure you are in your home directory, type in and enter the following command:\n\nThe command is the ‘change directory’ command. You use this command to navigate through your folders. When you type in you are automatically redirected to your home directory. When you type you navigate backwards one directory.\n\nTo create a new folder in your home directory with the folder name wget-medium, type in and enter the following command:\n\nThe command is the ‘make directory’ command. You have probably noticed that many commands are just abbreviations of actions. If you ever need a list of commands for your terminal simply type and enter:\n\nAnd a list of commands will print out followed by the version of your terminal. At the time of writing this workshop my version was 3.2.57 on a 64 bit Apple desktop:\n\nNow that you have created the directory, let’s navigate to the director. Type in and enter the following command:\n\nThe command also can navigate you to a folder from the folder you currently reside. Next we want to retrieve a news article from UTM news. First you need to get the url and then type in and enter the following command:\n\nAfter some initial messages, you should see the following (however, some figures, dates, and some details will be different):\n\nWhat you have done is downloaded just the raw text file of the UTM News article. If you open the HTML file it will appear in your browser. You now have a copy of the UTM news article that you can add to your research data.\n\nLet’s say you want to download copies of all The Medium’s news articles. To do this we will need to enter in a few options to our wget script.\n\nWget operates on the following general basis:\n\nIn the previous exercise we learned about the component of wget. , however, give the program a bit more information about what exactly we want to do. the program knows that an option is an option by the presence of a dash before the variable. This lets wget know the difference between the URL and the options.\n\nSo let’s now learn a few other commands to write a wget script to download all The Medium’s news articles.\n\nRecursive retrieval is the most important part of wget. What this means is the program begins to follow links from the URL you provide and downloads them too. You will notice the URL we used is part of the folder of the UTM website. So, if we use on the folder it will download all the news articles in that folder. However, it will also follow any other links in the news articles that point to other websites. By default, sends wget to a depth of five sites after the first URL. This means it follows links, to a limit of five clocks after the first URL. At this point, your wget script could capture a lot of data you do not want. So, we need a few more commands.\n\nThe command is the ‘no parent’ command which can also be written as . This is an important command as it tells wget to follow links, but not beyond the last parent directory. In the case of this exercise, that means it won’t go anywhere that is not part of the https://themedium.ca/news/ hierarchy. The no parent command is crtitical for delineating your search.\n\nFinally, it is important to add in a few commands that slow down your wget script. Web servers handle a lot of traffic and the wget program will download everything you command it too immediately unless you tell it to wait. There are two commands you can use to slow downloads:\n\nThe command is the ‘wait’ command and delays the download of each link by seconds. A good wait time is 2 seconds ( ) as it roughly represents how long it would take you to click from link to link. On rare occasions, you may come across a site that blocks automated downloading altogether. The website’s terms of service, which you should consult, may not mention a policy on automated downloading, but steps to prohibit it may be built into their website’s architecture nonetheless. In such rare cases, you can use the command which will vary the wait by 0.5 and 1.5 times the value of seconds you provide.\n\nThe command is the ‘limit rate’ of download speed for wget. You don’t want to use up too much of the servers’ bandwidth. The ‘limit rate’ command will limit the maximum downalod speed in kb/s. A good rate is around 200 kb/s for small files, but it’s up to your discretion when setting a download speed limit. For this workshop, however, we are going to set our limit rate to 20 kb/s in case there are several people completing this exercise at the same time.\n\nSo, we are now ready to download news articles from The Medium. Note, the trailing slash on the URL is critical as it tells wget we are accessing news articles in a directory. If you omit the slash wget will think you are wanting to download a file. The order of the options does not matter, but here is a command you type in and enter:\n\nThe download will be much slower than before, but your terminal will being downloading all the news articles on The Medium website. When it is done you should have a directory labelled that contains the sub-directory. This directory will appear in the location that you ran the command from your command line, so likely is in your directory. Links will be replaced with internal links to the other pages you have downloaded, so you can have a fully working themedium.ca site of news articles on your computer.\n\nIf for whatever reason you want to cancel the search you simply hit and together.\n\nLet’s say you want to copy an entire website, you would use the mirror function by using the command:\n\nThe command mirrors an entire URL, and is especially useful for backing up an entire website. For digital research, this can be quite useful if you’re doing historical research of social groups whose online presence is known to disappear, or who frequently change and update their web content. Mirror introduces the following set of commands: time-stamping, which looks at the date of the site and doesn’t replace it if you already have that version on your system (useful for repeated downloads), as well as infinite recursion (it will go as many layers into the site as necessary).\n\nThe command for mirroring The Medium website is:\n\nAs in the previous exercise, the download will be very slow, but The Medium website will be perfectly mirrored when complete showing all of the sub-directories. It is difficult to gauge how long this will take, but mirroring websites can sometimes take hours, even days depending on how much web content is on the website. This is especially the case for websites with audio-visual material.\n\nAs you become increasingly comfortable with the command line, you will find wget a helpful addition to your digital research toolkit. If there is an entire set of archival documents that you want to download for text mining, if they’re arranged in a directory and are all together (which is not as common as one might think), a quick wget command will be quicker than scraping the links with Python. Similarly, you can then begin downloading things directly from your command line: programs, files, backups, etc. You will soon find that wget may be a first option for you to research all kinds of web content!"
    },
    {
        "link": "https://bluehost.com/blog/wget-command-a-beginners-guide",
        "document": "Looking for a fast and efficient way to download files or copy websites using the command line? The wget command is the perfect solution! It allows you to retrieve files, mirror entire websites and automate downloads with ease. Wget command offers a simple and efficient solution.\n\nThe Wget is useful for website owners and developers. It helps with tasks like backing up website data, testing downloads and getting content from servers far away. Wget works well on different operating systems, making it a popular choice for developers who use Linux, macOS or Windows.\n\nWhen you use the Wget command on a hosting platform, you need a safe and reliable setup. Bluehost provides good hosting with SSH and secure file handling. This allows you to use the Wget command without issues. In this blog, we will guide you on how to install Wget on various systems. We will also discuss how Bluehost can support you. But first, let’s go over the basics of the Wget command.\n\nWget is a powerful command-line tool for downloading files from the internet. It supports HTTP, HTTPS and FTP protocols, making it ideal for retrieving web content directly from servers.\n• Downloading files: You can download single files from a URL with a simple command.\n• Recursive downloads: You can download entire folders or websites while keeping the same layout.\n• Mirroring websites: You can create offline copies of websites, including their linked pages and files.\n• Resuming downloads: You can start your downloads again without losing what you have done.\n• Automated fetching: You can set up and automate downloads using scripts.\n\nWget simplifies website management by enabling website owners and developers to automate backups, monitor site availability and retrieve online content efficiently.\n\nFor example, if a developer wants to back up a website, Wget can download all the web pages, images and files. It will keep the structure of the site for offline use. Also, if a website owner needs to see if the site is working, Wget command can be set up to do this regularly. It can repeatedly retrieve a page to ensure it is accessible. These features make Wget a good tool to manage websites easily.\n\nIt’s interesting, isn’t it? The question is, how can you use it? Here is the Wget file transfer tutorial to install it on various operating systems.\n\nWget is a small but powerful command-line tool. It is fast and simple to install. Below, we will show you how to install Wget on Linux, macOS and Windows. We will also explain how to see if the installation is good.\n\nMost Linux versions already have Wget installed. To check if Wget is on your system, open the command line and run:\n\nIf you have Wget installed, you can see the details. If you do not have it, follow the steps below to install it.\n\nRun the following command to install Wget:\n\nUse this command to install Wget:\n\nMac users can get Wget using Homebrew. If you do not have Homebrew, install it first by using:\n\nHow do I install Wget on Windows?\n\nWget does not come with Windows as it does with Linux and macOS. But you can install it easily.\n\nIf you have Chocolatey installed, you can quickly install Wget with:\n• Go to the official GNU Wget website and download the Wget for Windows program.\n• Unzip the files and place them in a folder, such as C:\\Wget.\n• Add the Wget folder to your system PATH. This lets you use it from any command prompt.\n\nAfter you install it, make sure Wget is working by running:\n\nIf you install it the right way, you will see the details showing the installed form and more.\n\nWith Wget installed, you can now use it to download files. You can also automate tasks and do even more!\n\nWhether you need to fetch a single file, download multiple resources or even mirror an entire website, Wget has you covered. Let’s go through some of the most useful Wget commands with examples.\n\nIf you want to get a specific file from a website, just use:\n\nThis command downloads file.zip from example.com. It saves the file in the current folder.\n\nTip: You can rename the downloaded file using:\n\nWget tutorial to download multiple files at once\n\nIf you want to download multiple files, create a text file named files.txt. Write all the URLs in that file. Be sure to put each URL on a new line.\n\nWget will look at the URLs in files.txt. It will download all the files by itself.\n\nIf your download stopped because of network issues or any other reasons, you don’t have to start over. Wget command allows you to keep downloading with:\n\nThe -c flag makes Wget continue the download from where it stopped. It does not start the download all over again.\n\nIf you want to create a copy of a website that works without the internet, use this command. It will copy the entire site, including all its settings and files:\n\nTo stop a server from becoming overloaded, it’s best to limit download speed and add delays between requests.\n\nWget allows you to control these settings. Use this command to download the file at a speed of 100 kilobytes per second with a 5-second delay between requests. Here is the command:\n\nUse case: This helps when you collect a lot of data. It stops the server from blocking you.\n\nIt makes managing files, backing up websites and automating tasks easier. Knowing these basic commands can help website owners and developers work better.\n\nWhat are the most useful Wget commands for website owners?\n\nWget is not just great for simple downloads. It has powerful features that help website owners work automatically, handle logins and use proxies. Let’s see how these advanced tools can improve the management of a website.\n\nIf you download files or save content from websites often, you can use a simple program to make Wget command easier to handle.\n\nFor example, to download daily backups of your website, create a script (backup.sh):\n\nFor example, if you want to save daily backups of your website, create a file named (backup.sh):\n\nNow, schedule this script using cron (Linux/macOS) to run daily:\n\nAdd the following line to run the script every day at midnight:\n\nThis ensures that the important files on your website are backed up on their own!\n\nSome websites ask for a username and password to download files. Wget can handle this using HTTP authentication.\n\nImportant: Do not save passwords as plain text. Instead, keep your credentials in a .wgetrc file.\n\nTo use cookie-based authentication, first log in using a browser. After that, export the cookies.\n\nThis is helpful when you want to download files from membership sites or restricted areas.\n\nIf you want to download files using a proxy server, you should set up Wget command to send the traffic properly.\n\nFor a permanent proxy configuration, add the following to your .wgetrc file:\n\nUse case: This is useful when you are working behind company firewalls. It helps you access content that is only available in specific areas.\n\nThe reliable and developer-friendly hosting environment of Bluehost makes it easy to use Wget command for website management. You can automate downloads, back up your data or get files from remote locations. Our strong setup makes it easy and safe to use Wget.\n\nWget tutorial to use with Bluehost’s hosting environment\n\nThe Bluehost hosting setup works well with the Wget command. This allows users to:\n• Get files from other sources right to the server.\n\nTo use Wget on Bluehost, first connect using SSH. After that, you can run commands from the command line.\n\nThis helps you control your website’s files. You don’t have to download and upload them manually.\n\nWe provide safe SSH access in our hosting plans. This allows users to run Wget commands directly from the command line.\n\nSteps to use Wget via SSH on Bluehost:\n\nStep 1: Turn on SSH from your Bluehost settings.\n\nStep 2: Connect to your server using an SSH client like PuTTY (Windows) or Terminal (Mac/Linux):\n\nStep 3: Use Wget commands to download files, save backups or arrange automatic file transfers.\n\nThis gives developers and site owners more control over managing their websites using Wget.\n\nSecurity is very important when you use Wget command to manage websites. Bluehost keeps your file transfers safe by:\n\nFor better security, always use https:// URLs with Wget. This will keep your file transfers safe. It helps protect your important information.\n\nIf you ever run into issues while using Wget, our 24/7 expert support is available to help. Whether it’s:\n\nBluehost’s tech team ensures that Wget command runs smoothly. This allows you to manage your website with ease.\n\nWhile Wget command is a good and reliable tool, users may face some issues at times. These problems can happen due to issues with the network, permission settings or limits set by the server. In this section, we will discuss common Wget errors, ways to fix them and how the Bluehost support team can help you solve these problems and quickly download files with Wget.\n\nCause: Wget is not installed on your system.\n\nCheck if Wget is installed by running:\n\nIf it’s missing, install it using:\n\nCause: The requested file is either missing or restricted by the server.\n\nCheck if the file URL is right by opening it in a browser.\n\nIf you cannot get in, check if you need to log in and use:\n\nSome websites block Wget requests. You can get by this by changing the user agent.\n\nCause: Issues with the connection, rules from the firewall or the server not working.\n\nTry to download a different file. This will help you see if the issue is only with one website.\n\nIf you are using a proxy, set up Wget with the correct settings for it.\n\nSometimes, Wget may fail due to server restrictions or permission issues.\n\nIf downloading a file to a specific directory fails, ensure you have write permissions:\n\nIf necessary, grant permissions using:\n\nIf downloads are blocked, see if a firewall or security setting is stopping you from getting files. On Bluehost, make sure that remote file downloads are allowed in your hosting settings.\n\nAlways use https:// instead of http:// for encrypted and secure file transfers.\n\nWget errors can usually be fixed with easy steps. You can look at URLs, check permissions or change your proxy settings. If the problems keep happening, Bluehost’s expert support team is here 24/7 to help you with Wget commands.\n\nWget is an essential tool for efficient website management, with features like recursive downloading, authentication support and proxy integration. When paired with Bluehost’s reliable hosting and secure SSH access, using Wget becomes a breeze. You can handle file management, automate downloads and ensure your data stays secure without breaking a sweat. Plus, whenever you need help, Bluehost’s 24/7 expert support has got your back, ready to troubleshoot any hiccups you might encounter.\n\nReady to take control of your website management? Explore Bluehost’s hosting plans with SSH access and unlock the full potential of Wget today!"
    },
    {
        "link": "https://stackoverflow.com/questions/14578264/how-to-download-multiple-urls-using-wget-using-a-single-command",
        "document": "The existing answers here are really helpful, but what if you end up with duplicates?\n\nYou may encounter an issue with duplicate files being created if, for example, if your URL list contains the same file name at the end of different paths:\n\nIn this case will give you the following in your current directory:\n\nA number will be appended to each subsequent instance of to avoid a namespace collision, but it won't be clear which file came from which path.\n\nIf this happens you can either:\n\nIt's easy if the files all have the same contents and you don't need more than one. Of course you can delete them after downloading, or prevent duplicates from being downloaded to begin with using or . More info here.\n\nThis is usually more useful, as in many cases you will want to preserve the relative paths. The options can be used to strip the hostname and create the same directory structure. See this answer for details.\n\nNote that must directly precede the file name, because the file name is an argument for . This is why we place the other options sequentially first.\n\nFor more info on , the Ubuntu ManPages are very helpful."
    }
]