[
    {
        "link": "https://dev.to/jeetvora331/throttling-in-javascript-easiest-explanation-1081",
        "document": "Throttling is a technique that limits how often a function can be called in a given period of time. It is useful for improving the performance and responsiveness of web pages that have event listeners that trigger heavy or expensive operations, such as animations, scrolling, resizing, fetching data, etc.\n\nFor example, if you have a function that fetches some data from an API every time the user scrolls the page, you might want to throttle it so that it only makes one request every second, instead of making hundreds of requests as the user scrolls. This way, you can avoid overloading the server or the browser with unnecessary requests and reduce the bandwidth consumption.\n\nHow to Implement Throttling in JavaScript?\n\nThere are several ways to implement throttling in JavaScript. One common approach is to use a timer function such as or difference of time method (old method) to wrap the function being throttled. The timer function can be used to enforce a delay between calls to the throttled function, allowing it to be called only once within the specified time period.\n\nPictorial Representation\n\n Here you can see that once the function is executed successfully it starts a blocking delay timer which blocks all the clicks. Once the delay is expired it accepts the clicks and executes the function.\n\nHereâ€™s an example of how to implement a throttle function using :\n\nIn this example, we define a function that takes a and a delay as arguments. The function returns a new function that wraps the with a logic that uses to create a timer. The timer ensures that the callback is only called once within the period. If the returned function is called again before the timer expires, it does nothing.\n\nWe then define a function that simulates an API call with a random delay. We use the function to create a function that has a delay of 5000 ms. We add an event listener to the window scroll event that calls the function.\n\nIf you run this code and scroll the page, you will see that the function is only called once every 5 second, regardless of how fast or slow you scroll.\n\nThrottling can improve the performance and user experience of web pages by reducing the number of unnecessary or redundant operations. It can also prevent some issues such as:\nâ€¢ Overloading the server or the browser with too many requests or calculations\nâ€¢ Exceeding the rate limits or quotas of APIs or services\nâ€¢ Wasting bandwidth or resources on operations that are not visible or relevant to the user\n\nNon Tech Example of throttling:\n\nChanging speed of Fan\n\n When changing speed of fan, it takes few seconds to reach at the desired speed. Thus before changing the speed again, we need to wait for few seconds so the fan reaches at a steady state.\n\nWhen to Use Throttling?\n\nThrottling is suitable for scenarios where you want to limit how often a function can be called, but you donâ€™t want to miss any calls. For example, you might want to use throttling for:\nâ€¢ Fetching data from an API or a database when the user scrolls, resizes, or types\nâ€¢ Updating or animating elements on the page when the user scrolls, resizes, or moves the mouse\nâ€¢ Logging or tracking user actions or events when they occur frequently\n\nThrottling is a technique that limits how often a function can be called in a given period of time. It is useful for improving the performance and responsiveness of web pages that have event listeners that trigger heavy or expensive operations. Throttling can be implemented in JavaScript using timer functions such as setTimeout or setInterval. Throttling is suitable for scenarios where you want to limit how often a function can be called, but you donâ€™t want to miss any calls.\n\nI hope you found this blog helpful and learned something new about throttling in JavaScript. You can check out my article on Debouncing in JavaScirpt Here.\n\nIf you have any questions or feedback, please feel free to leave a comment below. Thanks for reading! ðŸ˜Š"
    },
    {
        "link": "https://reddit.com/r/functionalprogramming/comments/ypg4ib/how_to_implement_throttle_function_in_functional",
        "document": "Just the title says.Im a fairly new in fp pattern so Im having difficulties on wrapping onto my head whether throttle function is a pure function or not. Here is an example:\n\nyou can see clearly in the code that variable is reassigned by the returned function.\n\nhowever im confused if it is still considered a \"pure\" function, since all of the logic are enclosed inside the function.\n\nnow the real kicker is that ppl said pure functional languages dont really use closures since by their logic, they use side effects, so now Im here wondering how the heck do you guys work around this kind of problem in a pure functional way?"
    },
    {
        "link": "https://geeksforgeeks.org/javascript-throttling",
        "document": "Throttling is a technique used to limit the number of times a function can be executed in a given time frame. Itâ€™s extremely useful when dealing with performance-heavy operations, such as resizing the window or scrolling events, where repeated triggers can lead to performance issues.\n\nIn this example\nâ€¢ None The throttle function takes a function (fn) and a delay (delay) as parameters.\nâ€¢ None It keeps track of the last execution time using lastTime.\nâ€¢ None When the function is called, it checks if the time difference from the last execution is greater than or equal to the delay.\nâ€¢ None If so, it executes the function and updates lastTime.\n\nCertain user interactions, like scrolling or window resizing, trigger events multiple times per second. Executing event handlers at such a high frequency can lead to performance issues, including:\n\nBy throttling a function, we can ensure it executes at a controlled rate, reducing resource consumption and improving responsiveness.\n\nThrottling works by restricting the execution of a function so that it runs at most once every predefined period, even if the event is triggered multiple times within that interval.\nâ€¢ None A function is triggered multiple times due to an event (e.g., scroll, resize).\nâ€¢ None Throttling ensures that the function executes only once within the defined interval.\nâ€¢ None Any additional triggers during the interval are ignored until the next cycle starts.\nâ€¢ None Once the interval is over, the function can execute again if triggered.\n\nA simple way to implement throttling is by using setTimeout. The function execution is delayed and only runs after the specified time interval has passed.\n\nAnother approach is to use Date.now() to keep track of the last execution time and determine when the function should be called again.\n\nBoth throttling and debouncing are techniques for controlling function execution, but they serve different purposes:\n\nThrottling is commonly used in cases where frequent execution of a function can cause performance issues."
    },
    {
        "link": "https://medium.com/@thefrontendfeed/throttling-in-javascript-a-complete-frontend-interview-guide-2024-4f9f4514a0f6",
        "document": "Throttling is a crucial performance optimization technique that frequently appears in frontend interviews, especially when discussing event handling and performance optimization. Unlike its cousin debouncing (which waits for a pause), throttling ensures functions execute at a regular rate, making it perfect for handling continuous events like scrolling or real-time updates.\n\nThrottling is a rate-limiting technique that controls how many times a function can be called in a specific time period. Itâ€™s like a valve controlling water flow â€” ensuring steady, controlled execution rather than sporadic bursts.\n\nFor example, if you throttle a function to 1 second:\n\n- t=0s: Function called â†’ Executes\n\n- t=0.3s: Function called â†’ Ignored\n\n- t=0.7s: Function called â†’ Ignored\n\n- t=1.0s: Throttle period ends\n\n- t=1.1s: Function called â†’ Executes"
    },
    {
        "link": "https://stackoverflow.com/questions/74506028/javascript-throttle-implementation-is-not-delaying",
        "document": "this is probably a simple mistake. I'm trying to implement a throttle function (Credit to our man webdevsimplified for quality content: https://blog.webdevsimplified.com/2022-03/debounce-vs-throttle/).\n\nMy throttle implementation is not working and I am not sure why. How can I get the throttle working?\n\nis never printed , even though it should..."
    },
    {
        "link": "https://dev.to/jeetvora331/throttling-in-javascript-easiest-explanation-1081",
        "document": "Throttling is a technique that limits how often a function can be called in a given period of time. It is useful for improving the performance and responsiveness of web pages that have event listeners that trigger heavy or expensive operations, such as animations, scrolling, resizing, fetching data, etc.\n\nFor example, if you have a function that fetches some data from an API every time the user scrolls the page, you might want to throttle it so that it only makes one request every second, instead of making hundreds of requests as the user scrolls. This way, you can avoid overloading the server or the browser with unnecessary requests and reduce the bandwidth consumption.\n\nHow to Implement Throttling in JavaScript?\n\nThere are several ways to implement throttling in JavaScript. One common approach is to use a timer function such as or difference of time method (old method) to wrap the function being throttled. The timer function can be used to enforce a delay between calls to the throttled function, allowing it to be called only once within the specified time period.\n\nPictorial Representation\n\n Here you can see that once the function is executed successfully it starts a blocking delay timer which blocks all the clicks. Once the delay is expired it accepts the clicks and executes the function.\n\nHereâ€™s an example of how to implement a throttle function using :\n\nIn this example, we define a function that takes a and a delay as arguments. The function returns a new function that wraps the with a logic that uses to create a timer. The timer ensures that the callback is only called once within the period. If the returned function is called again before the timer expires, it does nothing.\n\nWe then define a function that simulates an API call with a random delay. We use the function to create a function that has a delay of 5000 ms. We add an event listener to the window scroll event that calls the function.\n\nIf you run this code and scroll the page, you will see that the function is only called once every 5 second, regardless of how fast or slow you scroll.\n\nThrottling can improve the performance and user experience of web pages by reducing the number of unnecessary or redundant operations. It can also prevent some issues such as:\nâ€¢ Overloading the server or the browser with too many requests or calculations\nâ€¢ Exceeding the rate limits or quotas of APIs or services\nâ€¢ Wasting bandwidth or resources on operations that are not visible or relevant to the user\n\nNon Tech Example of throttling:\n\nChanging speed of Fan\n\n When changing speed of fan, it takes few seconds to reach at the desired speed. Thus before changing the speed again, we need to wait for few seconds so the fan reaches at a steady state.\n\nWhen to Use Throttling?\n\nThrottling is suitable for scenarios where you want to limit how often a function can be called, but you donâ€™t want to miss any calls. For example, you might want to use throttling for:\nâ€¢ Fetching data from an API or a database when the user scrolls, resizes, or types\nâ€¢ Updating or animating elements on the page when the user scrolls, resizes, or moves the mouse\nâ€¢ Logging or tracking user actions or events when they occur frequently\n\nThrottling is a technique that limits how often a function can be called in a given period of time. It is useful for improving the performance and responsiveness of web pages that have event listeners that trigger heavy or expensive operations. Throttling can be implemented in JavaScript using timer functions such as setTimeout or setInterval. Throttling is suitable for scenarios where you want to limit how often a function can be called, but you donâ€™t want to miss any calls.\n\nI hope you found this blog helpful and learned something new about throttling in JavaScript. You can check out my article on Debouncing in JavaScirpt Here.\n\nIf you have any questions or feedback, please feel free to leave a comment below. Thanks for reading! ðŸ˜Š"
    },
    {
        "link": "https://syncfusion.com/blogs/post/javascript-debounce-vs-throttle",
        "document": "Performance is one of the most crucial aspects of modern web applications. As developers, we follow various techniques to enhance application performance and provide a better user experience. For example, debouncing and throttling are two simple, yet powerful techniques we can use in JavaScript applications to improve performance.\n\nIn this article, I will introduce debouncing and throttling in JavaScript, compare them, and discuss why we need to use them.\n\nWhy do we need to debounce and throttle?\n\nUsually, developers have the freedom to decide when to call a function. But sometimes, they have to hand over control to users. For example, event triggers are widely used in applications to trigger functions based on events like key presses, button clicks, and mouse movements. In such situations, users can trigger those events far more than required and cause significant performance issues in the application.\n\nFor example, consider a search bar where we need to display a suggestion list as the user types. We can implement this using an event listener to bring data from the backend on each key press. However, it will negatively impact application performance, since it will make an API call each time the user presses a key.\n\nThe following code shows an example of this scenario. It will make 10 API calls if we type the word JavaScript.\n\n // index.html\n\nYou can find a working example of this code in StackBlitz.\n\nAs you can see, there is a significant number of unnecessary API calls in the previous example. In such situations, we can use debouncing and throttling to reduce the number of API calls triggered by the user event and improve the application performance without any drag on the user experience.\n\nSo, letâ€™s see these two techniques and how we can implement them.\n\nThe concept of debouncing is pretty straightforward. It delays the function invocation by a defined period of time to avoid unnecessary invocations. So, the function will only be invoked if no event is triggered within that time. If the user triggers a new event during that time, the time will be reset.\n\nLetâ€™s consider the previous example again. The issue with the scenario was unnecessary API calls. So, if we define a debounce function with a delay of one second, it will hold back the API call until one second passes without any user events. If the user presses a key within that second, the debounce function will reset the delay and wait for another second to make the API call.\n\nWe can easily implement a debounce function using the setTimeout() and clearTimeout() functions. It should also take a callback function and the delay as input parameters.\n\nAs you can see, the debounce function acts as a wrapper for the callback function and ensures that it will be invoked after the delay. In this case, the default delay is 1,000 milliseconds.\n\nLetâ€™s now modify the search bar example code with a debounce function.\n\nAlthough the user has typed the word JavaScript, only a single API call has been invoked. So, debouncing has blocked nine unnecessary API calls from the previous example. You can find a working example of this code in StackBlitz.\n\nThrottle is another technique to minimize unnecessary function invocations when using event listeners. However, throttle works a bit differently from debouncing. Instead of delaying, it invokes the callback function at regular intervals as long as the event trigger is active.\n\nFor example, assume we have defined the delay as one second in a throttle function. First, it will invoke the callback function immediately. Then, it will use the delay time as the waiting time and invoke the callback function every second until the event trigger becomes inactive.\n\nWe can implement a throttle function using the setTimeout() function and a flag variable. It should take a callback function and the delay as input parameters.\n\nIn debouncing, we implemented the debounce function as a wrapper of the callback function, since we delay the callback function invocation. But in throttle implementation, we immediately invoke the callback function if the shouldWait flag is false. Then, the setTimeout() function is used to update the flag value based on the delay we define.\n\nThe following code shows the initial search bar example optimized with a throttle function.\n\nAs you can see, only three API calls were made in this example when I typed the word JavaScript. The first call is the initial call, and the other two were made after 5 and 10 key presses, respectively. So, the throttle function has reduced seven unnecessary API calls. You can find a working example of this code in StackBlitz.\n\nDebounce monitors the time delay between user actions and only executes the callback function if the delay exceeds the time delay defined by the developer. So, continuous user actions can significantly delay the callback functionâ€™s execution if we use debounce.\n\nOn the other hand, throttle uses the time delay to execute the callback function at regular intervals until the event trigger is active. So, it does not delay the callback function execution for a significant period like debounce.\n\nWhen to use what\n\nI explained both debounce and throttle using a search bar example with key press events. However, there are some specific scenarios where we should use one or the other of these techniques:\nâ€¢ Debounce is most suitable for control events like typing or button clicks.\nâ€¢ Throttle is most suitable for continuous user events like resizing and scrolling.\n\nThis article discussed how we could use debounce and throttle to handle user events and minimize unnecessary function executions in JavaScript applications. Ultimately, these two techniques can significantly improve your applicationâ€™s performance since they can avoid many unnecessary API calls, DB queries, and so on. So, give them a try when implementing event triggers on your next application.\n\nThank you for reading!\n\nSyncfusionâ€™s Essential JS 2 is the only suite you will ever need to build an app. It contains over 65 high-performance, lightweight, modular, and responsive UI components in a single package. Download a free trial to evaluate the controls today.\n\nIf you have any questions or comments, you can contact us through our support forums, support portal, or feedback portal. We are always happy to assist you!\nâ€¢ JavaScript Debugging with VS Code and Chrome\nâ€¢ JavaScript String Manipulation Techniques Every Developer Should Know"
    },
    {
        "link": "https://stackoverflow.com/questions/54141738/how-can-i-use-throttling-with-getting-an-event-target",
        "document": "By referring to this site, https://codeburst.io/throttling-and-debouncing-in-javascript-646d076d0a44\n\n\n\n I want use throttled function like this.\n\n\n\n I have to use this to get the value of e.target.\n\n However, if you write this code, the throttled function will not work properly.\n\n\n\n How can I get the throttled function to work properly while getting targeted click events?"
    },
    {
        "link": "https://medium.com/@techsuneel99/throttling-in-javascript-3765384c1523",
        "document": "Throttling is a crucial technique in JavaScript for optimizing performance and managing resource utilization. Itâ€™s particularly useful when dealing with events that can fire at a high frequency, such as scrolling, resizing, or user input. In this article, weâ€™ll explore the concept of throttling, its benefits, and how to implement it in JavaScript with various use cases and examples.\n\nThrottling is a technique that limits the rate at which a function can be called. It ensures that a function is executed at most once in a specified time interval, regardless of how many times itâ€™s invoked. This is particularly useful for performance-intensive operations or when you want to control the rate of API calls.\n\nYou can check these resources for Coding interview Preparation\nâ€¢ When a throttled function is called, it checks if enough time has passed since its last execution.\nâ€¢ If the time threshold has not been met, the function call is ignored.\nâ€¢ If the time threshold has been met, the function is executed and the timer is reset.\nâ€¢ Performance Optimization: Reduces the number of executions for resource-intensiveâ€¦"
    },
    {
        "link": "https://freecodecamp.org/news/throttling-in-javascript",
        "document": "Welcome back, fellow developers! Today, we are once again delving into JavaScript and Web Development and learning about throttling.\n\nAs a developer, making your website user-friendly is important. This goes a long way toward the product's success, and a key part of the user experience is the website's performance.\n\nIn a previous tutorial, I discussed how to improve the performance of any feature using a technique called debouncing. And you can use a similar technique, called throttling, but in a slightly different scenario. You'll learn how to implement throttling in this article.\n\nFor this guide, I am assuming you have a basic knowledge of JavaScript. Don't worry if you are a beginner â€“ I have provided simple and detailed explanations to guide you through. So, let's dive right into it!\nâ€¢ None How to Implement Throttling in JavaScript\nâ€¢ None What is a Closure in JavaScript?\n\nThrottling is a technique used to limit the rate at which a function is called. Throttling transforms a function such that it can only be called once in a specific interval of time.\n\nLet's understand this with an example. Let's take a function :\n\nWe want to modify this function so that it can only be called once in 500ms. So, throttling will take as an input, and return a modified (throttled) function that can only be executed 500ms after the previous function was executed.\n\nWhen you call multiple times within 500ms, will only be executed the first time. You will have to wait 500ms before can be executed again. This happens after every subsequent function call. Thus, can only be called once every 500ms.\n\nHow to Implement Throttling in JavaScript\n\nLet's first understand what we want to achieve with throttling:\nâ€¢ None Call the function immediately the first time.\nâ€¢ None After each call, prevent the function from being called again for a certain time period.\nâ€¢ None Once that time period has passed, the function can be called again.\n\nTo do all this, let's first create a helper function that will return a throttled function:\n\nFor any use cases, the throttled function will be used instead of the original .\n\nLet's start by simply calling the function like this:\n\nOnce the function is called, we want to block it from being called again for a certain time period . Once the time has passed, we want to unblock the function. We can achieve this behaviour using .\n\nFor now, let's keep the empty. You'll understand how it works in a minute.\n\nNext, we'll declare a variable that will be initialized only once in the outer function (that is the function). The method returns a unique timeout id that we can use to identify a timeout. We'll assign the current timeout id to .\n\nSince contains the id of the current timeout, we add a condition at the start of the throttled function to check if a timeout exists before calling the original function .\n\nInitially, is null, so the function is executed. The throttled function then starts a new timeout and assigns it to the variable. In the next function call, it checks if a timeout exists before calling . If a timeout already exists, it does not execute .\n\nBut what happens after the time period of has passed? Inside the we need to do something that enables to be called again. Since we are using to control the function calls, we set it to null after milliseconds.\n\nNow, when you call the function, it is executed and the process repeats by starting a new timeout. We have successfully throttled the function.\n\nBut there's something fundamental that we are still overlooking. In the current function call, once we assign to the variable, for the next one we are assuming that is still valid and holds the value that we want â€“ even if the variable is declared inside the function.\n\nHow is the inner function still able to have access to the variable long after the function has finished execution? It uses a concept called a closure. Let's take a quick detour to visit this concept.\n\nIn JavaScript, an inner function always has access to the local variables of the outer function. In our case, the inner function has access to that has function level scope in the method.\n\nBut when the outer function returns this inner function, the inner function still holds a reference to the local variables of the outer function long after the outer function has finished execution. This is the concept of a closure.\n\nLet's understand closures with an example.\n\nHere, if we call , the code runs without any errors and prints 5. But, if we try to access directly, JavaScript throws a reference error.\n\nHere, closes over and only this function can use the variable and no one other one can. We cannot access the variable explicitly.\n\nYou can check out this beginner-friendly tutorial to learn more about closures.\n\nLet's continue from where we left off.\n\nWe have seen that JavaScript uses closures to hold access to every time we call the throttled function.\n\nWith this, we have a basic implementation of function throttling.\n\nLet's test it out by using the above method and throttling it with a delay of 500ms. This function should only be able to execute once every 500ms.\n\nLet's call in different ways and see how it executes.\n\nThe first function call will execute immediately. For the next 500ms (throttling delay in this example), no matter how many times you call , nothing will happen.\n\nSo, the second function call and the third one won't execute, because they occur within 500ms of the first call. Once 500ms have passed, the next function call â€“ that is, the last one â€“ will execute, since the call is being made after 500ms.\n\nThus, it will print the following output:\n\nThe solution is not complete yet. Our approach does not take into account function arguments. So, let's modify to have two arguments:\n\nTo incorporate arguments, use the spread operator and store all arguments in a variable :\n\nNow, call again, with arguments like this:\n\nThis will print This is a function with args 2 and 3 .\n\nLet's see how throttling is used in practical applications. We'll take a button that makes a call to the backend server when a user clicks it. An API call is made every time someone clicks the button.\n\nBut an API request can take some time, and if the user clicks the button again, or repeatedly in a short time, more and more API calls are made which could overload the server. To avoid this behaviour, we use function throttling. Let's implement this with React.\n\nRun in your terminal or use a modern built tool like Vite to create your React app. Remove the existing boilerplate code. There is no need to install any additional dependencies. Run command to start the project. You can find the complete code on GitHub.\n\nI have set up a Node server to fetch data for the app. You can find it in the Git repo. Run the command to start it. I am not going to show the Node.js code as it's out of the scope of this tutorial.\n\nIn the App component, let's create a button with an handler that makes an API call to the Node server.\n\nHere, an API call is made every time the button is clicked. So, if the user clicks on the button repeatedly, a lot of API calls will be made in one second. This may overload the server.\n\nTo tackle this, we need to prevent the API from getting called on every click of the button. Let's see how to achieve this with throttling.\n\nWe'll write the throttling logic inside a custom hook. Since you may need throttling in multiple places in your application, it is recommended to put the logic inside a custom hook.\n\nCreate a new folder called . Inside it, create a file . Inside the file, create and export new function . The method should take a function and delay as parameters and return the throttled function.\n\nNow, inside the App component, call this method and pass the click handler and a delay of 1000ms.\n\nWe'll use this function as the event handler for our button.\n\nAfter clicking the button repeatedly for two seconds, only two API calls are made.\n\nBy limiting the number of times your APIs are called, throttling improves the performance of your application.\n\nIn this tutorial, you learned what throttling is and how to implement it. Throttling allows you to control the rate at which a function can be executed in a specific period.\n\nThrottling uses an important concept called closures. They allow you to work with local variables even after a function has finished execution. Closures can be quite confusing for beginners, so take your time with them.\n\nAfter that, I showed you a common use case of throttling, where you can control how many times an API call can be made on multiple button clicks. I utilized custom hooks to implement throttling in React. This serves to improve the performance of web applications. I hope this helps you in your future projects.\n\nIf you are unable to understand the content or find the explanation unsatisfactory, let me know. New ideas are always appreciated! Feel free to connect with me on Twitter. Till then, goodbye!"
    }
]