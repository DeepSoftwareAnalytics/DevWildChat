[
    {
        "link": "https://geeksforgeeks.org/inheritance-in-c",
        "document": "The capability of a class to derive properties and characteristics from another class is called Inheritance. Inheritance is one of the most important features of Object Oriented Programming in C++. In this article, we will learn about inheritance in C++, its modes and types along with the information about how it affects different properties of the class.\n\nSyntax of Inheritance in C++\n• derived_class_name : name of the new class, which will inherit the base class\n• access-specifier : Specifies the access mode which can be either of private, public or protected. If neither is specified, private is taken as default.\n• base-class-name : name of the base class.\n\nTo better understand inheritance and other OOP principles, enroll in our Complete C++ Course, which breaks down inheritance, polymorphism, and encapsulation in C++.\n\nExamples of Inheritance in C++\n\nThe following programs demonstrate how to implement inheritance in our C++ programs.\n\nExample 1: Program to Demonstrate the Simple Inheritance of a Class\n\nIn the above program, the ‘Child’ class is publicly inherited from the ‘Parent’ class so the public data members of the class ‘Parent’ will also be inherited by the class ‘Child’.\n\nExample 2: Access the Inherited Members of the Base Class in Derived Class\n\nIn the above example, we have accessed the public members of the base class in the derived class but we cannot access all the base class members directly in the derived class. It depends on the mode of inheritance and the access specifier in the base class.\n\nModes of Inheritance in C++\n\nMode of inheritance controls the access level of the inherited members of the base class in the derived class. In C++, there are 3 modes of inheritance:\n\nIf we derive a subclass from a public base class. Then the public member of the base class will become public in the derived class and protected members of the base class will become protected in the derived class.\n\nIf we derive a subclass from a Protected base class. Then both public members and protected members of the base class will become protected in the derived class.\n\nIf we derive a subclass from a Private base class. Then both public members and protected members of the base class will become private in the derived class. They can only be accessed by the member functions of the derived class.\n\nPrivate mode is the default mode that is applied when we don’t specify any mode.\n\nThe below table summarizes the above three modes and shows the access specifier of the members of the base class in the subclass when derived in public, protected and private modes:\n\nExample 1: Program to show different kinds of Inheritance Modes and their Member Access Levels\n\nExample 2: Program to Access the Private Members of the Base Class in Derived Class\n\nThe above program shows the method in which the private members of the base class remain encapsulated and are only accessible through controlled public or protected member functions.\n\nWe can also access the private members of the base class by declaring the derived class as friend class in the base class.\n\nTo know more about access modes in a C++ class, refer to the article – Access Modifiers in C++\n\nTypes Of Inheritance in C++\n\nThe inheritance can be classified on the basis of the relationship between the derived class and the base class. In C++, we have 5 types of inheritances:\n\nIn single inheritance, a class is allowed to inherit from only one class. i.e. one base class is inherited by one derived class only.\n\nMultiple Inheritance is a feature of C++ where a class can inherit from more than one class. i.e one subclass is inherited from more than one base class.\n\nHere, the number of base classes will be separated by a comma (‘, ‘) and the access mode for every base class must be specified and can be different.\n\nMUST READ – Multiple Inheritance in C++\n\nIn this type of inheritance, a derived class is created from another derived class and that derived class can be derived from a base class or any other derived class. There can be any number of levels.\n\nMUST READ – Multilevel Inheritance in C++\n\nIn this type of inheritance, more than one subclass is inherited from a single base class. i.e. more than one derived class is created from a single base class.\n\nHybrid Inheritance is implemented by combining more than one type of inheritance. For example: Combining Hierarchical inheritance and Multiple Inheritance will create hybrid inheritance in C++\n\nThere is no particular syntax of hybrid inheritance. We can just combine two of the above inheritance types.\n\nBelow image shows one of the combinations of hierarchical and multiple inheritances:\n\nIn multipath inheritance, a class is derived from two base classes and these two base classes in turn are derived from one common base class. An ambiguity can arise in this type of inheritance in the most derived class. This problem is also called diamond problem due to the diamond shape formed in the UML inheritance diagram.\n\nMUST READ – Hybrid Inheritance in C++\n\nConstructors and Destructors are generally defined by the programmer and if not, the compiler automatically creates them so they are present in every class in C++. Now, the question arises what happens to the constructor and destructor when a class is inherited by another class.\n\nIn C++ inheritance, the constructors and destructors are not inherited by the derived class, but we can call the constructor of the base class in derived class.\n• None The constructors will be called by the complier in the order in which they are inherited. It means that base class constructors will be called first, then derived class constructors will be called.\n• None The destructors will be called in reverse order in which the compiler is declared.\n• None We can also call the constructors and destructors manually in the derived class.\n\nMUST READ – Order of Constructor/ Destructor Call in C++\n\nIn Inheritance, we can redefine the base class member function in the derived class. This type of inheritance is called Function Overriding. Generally, in other programming languages, function overriding is runtime polymorphism but in C++, we can do it at both runtime and complile time. For runtime polymorphism, we have to use the virtual functions.\n\nMUST READ – Function Overriding in C++\n\nWhat are a base class and a derived class?\n\nWhat are the rules for calling a base class constructor in a derived class?"
    },
    {
        "link": "https://stackoverflow.com/questions/13504276/inheriting-and-good-practices",
        "document": "Classes B,C,D inherits from A. In my problem i have multiple classes B,C,D and each of them have a static field for example\n\nClass A is abstract class and it have method getGold();\n\nOf course every class B,C,D has its own static field\n\nand in every class (B,C,D) i implement in the same way\n\nIt's copy & paste but i don't have idea how make it better.\n\nEvery object of the same class costs the same so this is why i want to have only one int Of course this is only example instead int i can have there for example class Gold instance :)"
    },
    {
        "link": "https://stackoverflow.com/questions/656224/when-should-i-use-c-private-inheritance",
        "document": "When do you guys use it?\n\nUnlike protected inheritance, C++ private inheritance found its way into mainstream C++ development. However, I still haven't found a good use for it.\n\nNote after answer acceptance: This is NOT a complete answer. Read other answers like here (conceptually) and here (both theoretic and practic) if you are interested in the question. This is just a fancy trick that can be achieved with private inheritance. While it is fancy it is not the answer to the question. Besides the basic usage of just private inheritance shown in the C++ FAQ (linked in other's comments) you can use a combination of private and virtual inheritance to seal a class (in .NET terminology) or to make a class final (in Java terminology). This is not a common use, but anyway I found it interesting: Sealed can be instantiated. It derives from ClassSealer and can call the private constructor directly as it is a friend. FailsToDerive won't compile as it must call the ClassSealer constructor directly (virtual inheritance requirement), but it cannot as it is private in the Sealed class and in this case FailsToDerive is not a friend of ClassSealer. It was mentioned in the comments that this could not be made generic at the time using CRTP. The C++11 standard removes that limitation by providing a different syntax to befriend template arguments: Of course this is all moot, since C++11 provides a contextual keyword for exactly this purpose:\n\nI find it useful for interfaces (viz. abstract classes) that I'm inheriting where I don't want other code to touch the interface (only the inheriting class). Take the example linked to above. Saying that [...] class Wilma needs to invoke member functions from your new class, Fred. is to say that Wilma is requiring Fred to be able to invoke certain member functions, or, rather it is saying that Wilma is an interface. Hence, as mentioned in the example private inheritance isn't evil; it's just more expensive to maintain, since it increases the probability that someone will change something that will break your code. comments on the desired effect of programmers needing to meet our interface requirements, or breaking the code. And, since fredCallsWilma() is protected only friends and derived classes can touch it i.e. an inherited interface (abstract class) that only the inheriting class can touch (and friends). [edited in another example] This page briefly discusses private interfaces (from yet another angle).\n\nPrivate Inheritance to be used when relation is not \"is a\", But New class can be \"implemented in term of existing class\" or new class \"work like\" existing class. example from \"C++ coding standards by Andrei Alexandrescu, Herb Sutter\" :- Consider that two classes Square and Rectangle each have virtual functions for setting their height and width. Then Square cannot correctly inherit from Rectangle, because code that uses a modifiable Rectangle will assume that SetWidth does not change the height (whether Rectangle explicitly documents that contract or not), whereas Square::SetWidth cannot preserve that contract and its own squareness invariant at the same time. But Rectangle cannot correctly inherit from Square either, if clients of Square assume for example that a Square's area is its width squared, or if they rely on some other property that doesn't hold for Rectangles. A square \"is-a\" rectangle (mathematically) but a Square is not a Rectangle (behaviorally). Consequently, instead of \"is-a,\" we prefer to say \"works-like-a\" (or, if you prefer, \"usable-as-a\") to make the description less prone to misunderstanding.\n\nI found a nice application for private inheritance, although it has a limited usage. Suppose you are given the following C API: #ifdef __cplusplus extern \"C\" { #endif typedef struct { /* raw owning pointer, it's C after all */ char const * name; /* more variables that need resources * ... */ } Widget; Widget const * loadWidget(); void freeWidget(Widget const * widget); #ifdef __cplusplus } // end of extern \"C\" #endif Now your job is to implement this API using C++. Of course we could choose a C-ish implementation style like so: Widget const * loadWidget() { auto result = std::make_unique<Widget>(); result->name = strdup(\"The Widget name\"); // More similar assignments here return result.release(); } void freeWidget(Widget const * const widget) { free(result->name); // More similar manual freeing of resources delete widget; } But there are several disadvantages:\n• It is easy to set up the wrong\n• It is easy to forget freeing the resources when freeing the We are allowed to use C++, so why not use its full powers? The above problems are basically all tied to the manual resource management. The solution that comes to mind is to inherit from and add a resource managing instance to the derived class for each variable: class WidgetImpl : public Widget { public: // Added bonus, Widget's members get default initialized WidgetImpl() : Widget() {} void setName(std::string newName) { m_nameResource = std::move(newName); name = m_nameResource.c_str(); } // More similar setters to follow private: std::string m_nameResource; }; This simplifies the implementation to the following: Widget const * loadWidget() { auto result = std::make_unique<WidgetImpl>(); result->setName(\"The Widget name\"); // More similar setters here return result.release(); } void freeWidget(Widget const * const widget) { // No virtual destructor in the base class, thus static_cast must be used delete static_cast<WidgetImpl const *>(widget); } Like this we remedied all the above problems. But a client can still forget about the setters of and assign to the members directly. To encapsulate the members we use private inheritance. Sadly we now need two extra functions to cast between both classes: class WidgetImpl : private Widget { public: WidgetImpl() : Widget() {} void setName(std::string newName) { m_nameResource = std::move(newName); name = m_nameResource.c_str(); } // More similar setters to follow Widget const * toWidget() const { return static_cast<Widget const *>(this); } static void deleteWidget(Widget const * const widget) { delete static_cast<WidgetImpl const *>(widget); } private: std::string m_nameResource; }; This makes the following adaptions necessary: Widget const * loadWidget() { auto widgetImpl = std::make_unique<WidgetImpl>(); widgetImpl->setName(\"The Widget name\"); // More similar setters here auto const result = widgetImpl->toWidget(); widgetImpl.release(); return result; } void freeWidget(Widget const * const widget) { WidgetImpl::deleteWidget(widget); } This solution solves all the problems. No manual memory management and is nicely encapsulated so that does not have any public data members anymore. It makes the implementation easy to use correctly and hard (impossible?) to use wrong. The code snippets form a compiling example on Coliru.\n\nA class holds an invariant. The invariant is established by the constructor. However, in many situations it's useful to have a view of the representation state of the object (which you can transmit over network or save to a file - DTO if you prefer). REST is best done in terms of an AggregateType. This is especially true if you're const correct. Consider: struct QuadraticEquationState { const double a; const double b; const double c; // named ctors so aggregate construction is available, // which is the default usage pattern // add your favourite ctors - throwing, try, cps static QuadraticEquationState read(std::istream& is); static std::optional<QuadraticEquationState> try_read(std::istream& is); template<typename Then, typename Else> static std::common_type< decltype(std::declval<Then>()(std::declval<QuadraticEquationState>()), decltype(std::declval<Else>()())>::type // this is just then(qes) or els(qes) if_read(std::istream& is, Then then, Else els); }; // this works with QuadraticEquation as well by default std::ostream& operator<<(std::ostream& os, const QuadraticEquationState& qes); // no operator>> as we're const correct. // we _might_ (not necessarily want) operator>> for optional<qes> std::istream& operator>>(std::istream& is, std::optional<QuadraticEquationState>); struct QuadraticEquationCache { mutable std::optional<double> determinant_cache; mutable std::optional<double> x1_cache; mutable std::optional<double> x2_cache; mutable std::optional<double> sum_of_x12_cache; }; class QuadraticEquation : public QuadraticEquationState, // private if base is non-const private QuadraticEquationCache { public: QuadraticEquation(QuadraticEquationState); // in general, might throw QuadraticEquation(const double a, const double b, const double c); QuadraticEquation(const std::string& str); QuadraticEquation(const ExpressionTree& str); // might throw } At this point, you might just store collections of cache in containers and look it up on construction. Handy if there's some real processing. Note that cache is part of the QE: operations defined on the QE might mean the cache is partially reusable (e.g., c does not affect the sum); yet, when there's no cache, it's worth to look it up. Private inheritance can almost always modelled by a member (storing reference to the base if needed). It's just not always worth it to model that way; sometimes inheritance is the most efficient representation."
    },
    {
        "link": "https://reddit.com/r/cpp_questions/comments/18arzdr/do_you_still_use_inheritance",
        "document": "With modern c++ features do you still use inheritance?\n\nWhen I'm designing my programs I have hard time deciding should I prefer generic programming or OOP.\n\nDo you prefer the other or combine both paradigms?"
    },
    {
        "link": "https://reddit.com/r/cpp_questions/comments/1h4phi8/inheritance_ever_useful",
        "document": ""
    },
    {
        "link": "https://w3schools.com/cpp/cpp_access_specifiers.asp",
        "document": "By now, you are quite familiar with the keyword that appears in all of our class examples:\n\nThe keyword is an access specifier. Access specifiers define how the members (attributes and methods) of a class can be accessed. In the example above, the members are - which means that they can be accessed and modified from outside the code.\n\nHowever, what if we want members to be private and hidden from the outside world?\n\nIn C++, there are three access specifiers:\n• - members are accessible from outside the class\n• - members cannot be accessed (or viewed) from outside the class\n• - members cannot be accessed from outside the class, however, they can be accessed in inherited classes. You will learn more about Inheritance later.\n\nIn the following example, we demonstrate the differences between and members:\n\nNote: By default, all members of a class are if you don't specify an access specifier:"
    },
    {
        "link": "https://learncpp.com/cpp-tutorial/inheritance-and-access-specifiers",
        "document": "In the previous lessons in this chapter, you’ve learned a bit about how base inheritance works. In all of our examples so far, we’ve used public inheritance. That is, our derived class publicly inherits the base class.\n\nIn this lesson, we’ll take a closer look at public inheritance, as well as the two other kinds of inheritance (private and protected). We’ll also explore how the different kinds of inheritance interact with access specifiers to allow or restrict access to members.\n\nTo this point, you’ve seen the private and public access specifiers, which determine who can access the members of a class. As a quick refresher, public members can be accessed by anybody. Private members can only be accessed by member functions of the same class or friends. This means derived classes can not access private members of the base class directly!\n\nThis is pretty straightforward, and you should be quite used to it by now.\n\nWhen dealing with inherited classes, things get a bit more complex.\n\nC++ has a third access specifier that we have yet to talk about because it’s only useful in an inheritance context. The protected access specifier allows the class the member belongs to, friends, and derived classes to access the member. However, protected members are not accessible from outside the class.\n\nIn the above example, you can see that the protected base member m_protected is directly accessible by the derived class, but not by the public.\n\nSo when should I use the protected access specifier?\n\nWith a protected attribute in a base class, derived classes can access that member directly. This means that if you later change anything about that protected attribute (the type, what the value means, etc…), you’ll probably need to change both the base class AND all of the derived classes.\n\nTherefore, using the protected access specifier is most useful when you (or your team) are going to be the ones deriving from your own classes, and the number of derived classes is reasonable. That way, if you make a change to the implementation of the base class, and updates to the derived classes are necessary as a result, you can make the updates yourself (and have it not take forever, since the number of derived classes is limited).\n\nMaking your members private means the public and derived classes can’t directly make changes to the base class. This is good for insulating the public or derived classes from implementation changes, and for ensuring invariants are maintained properly. However, it also means your class may need a larger public (or protected) interface to support all of the functions that the public or derived classes need for operation, which has its own cost to build, test, and maintain.\n\nIn general, it’s better to make your members private if you can, and only use protected when derived classes are planned and the cost to build and maintain an interface to those private members is too high.\n\nDifferent kinds of inheritance, and their impact on access\n\nFirst, there are three different ways for classes to inherit from other classes: public, protected, and private.\n\nTo do so, simply specify which type of access you want when choosing the class to inherit from:\n\nIf you do not choose an inheritance type, C++ defaults to private inheritance (just like members default to private access if you do not specify otherwise).\n\nThat gives us 9 combinations: 3 member access specifiers (public, private, and protected), and 3 inheritance types (public, private, and protected).\n\nSo what’s the difference between these? In a nutshell, when members are inherited, the access specifier for an inherited member may be changed (in the derived class only) depending on the type of inheritance used. Put another way, members that were public or protected in the base class may change access specifiers in the derived class.\n\nThis might seem a little confusing, but it’s not that bad. We’ll spend the rest of this lesson exploring this in detail.\n\nKeep in mind the following rules as we step through the examples:\n• A class can always access its own (non-inherited) members.\n• The public accesses the members of a class based on the access specifiers of the class it is accessing.\n• A derived class accesses inherited members based on the access specifier inherited from the parent class. This varies depending on the access specifier and type of inheritance used.\n\nPublic inheritance is by far the most commonly used type of inheritance. In fact, very rarely will you see or use the other types of inheritance, so your primary focus should be on understanding this section. Fortunately, public inheritance is also the easiest to understand. When you inherit a base class publicly, inherited public members stay public, and inherited protected members stay protected. Inherited private members, which were inaccessible because they were private in the base class, stay inaccessible.\n\nHere’s an example showing how things work:\n\nThis is the same as the example above where we introduced the protected access specifier, except that we’ve instantiated the derived class as well, just to show that with public inheritance, things work identically in the base and derived class.\n\nPublic inheritance is what you should be using unless you have a specific reason not to.\n\nProtected inheritance is the least common method of inheritance. It is almost never used, except in very particular cases. With protected inheritance, the public and protected members become protected, and private members stay inaccessible.\n\nBecause this form of inheritance is so rare, we’ll skip the example and just summarize with a table:\n\nWith private inheritance, all members from the base class are inherited as private. This means private members are inaccessible, and protected and public members become private.\n\nNote that this does not affect the way that the derived class accesses members inherited from its parent! It only affects the code trying to access those members through the derived class.\n\nPrivate inheritance can be useful when the derived class has no obvious relationship to the base class, but uses the base class for implementation internally. In such a case, we probably don’t want the public interface of the base class to be exposed through objects of the derived class (as it would be if we inherited publicly).\n\nIn practice, private inheritance is rarely used.\n\nBase can access its own members without restriction. The public can only access m_public. Derived classes can access m_public and m_protected.\n\nD2 can access its own members without restriction. D2 can access Base’s m_public and m_protected members, but not m_private. Because D2 inherited Base privately, m_public and m_protected are now considered private when accessed through D2. This means the public can not access these variables when using a D2 object, nor can any classes derived from D2.\n\nD3 can access its own members without restriction. D3 can access D2’s m_public2 and m_protected2 members, but not m_private2. Because D3 inherited D2 publicly, m_public2 and m_protected2 keep their access specifiers when accessed through D3. D3 has no access to Base’s m_private, which was already private in Base. Nor does it have access to Base’s m_protected or m_public, both of which became private when D2 inherited them.\n\nThe way that the access specifiers, inheritance types, and derived classes interact causes a lot of confusion. To try and clarify things as much as possible:\n\nFirst, a class (and friends) can always access its own non-inherited members. The access specifiers only affect whether outsiders and derived classes can access those members.\n\nSecond, when derived classes inherit members, those members may change access specifiers in the derived class. This does not affect the derived classes’ own (non-inherited) members (which have their own access specifiers). It only affects whether outsiders and classes derived from the derived class can access those inherited members.\n\nHere’s a table of all of the access specifier and inheritance types combinations:\n\nAs a final note, although in the examples above, we’ve only shown examples using member variables, these access rules hold true for all members (e.g. member functions and types declared inside the class)."
    },
    {
        "link": "https://geeksforgeeks.org/cpp-inheritance-access",
        "document": "Before learning about Inheritance Access we need to know about access specifiers. There are three Access specifiers in C++. These are:\n\nPublic, Protected, and Private inheritance in C++\n\npublic, protected, and private inheritance have the following features:\n\nIn this example, public inheritance is demonstrated. Since private and protected members will not be directly accessed from main( ) so we have had to create functions name getPVT( ) to access the private variable and getProt( ) to access the protected variable from the inherited class.\n\nWe know that protected members can only be accessed from the Derived class. These members cannot be directly accessed from outside the class. So we cannot use getPVT() from ProtectedDerived. This is also why we need to create getPub() function in the Derived class in order to access the pub variable.\n\nWe know that private members cannot be accessed from the Derived class. These members cannot be directly accessed from outside the class. So we cannot use getPVT() from PrivateDerived. So we need to create the getPub() function in PrivateDerived in order to access the pub variable."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/language/derived_class",
        "document": "Any class type (whether declared with class-key class or struct) may be declared as derived from one or more base classes which, in turn, may be derived from their own base classes, forming an inheritance hierarchy.\n\nThe list of base classes is provided in the base-clause of the class declaration syntax. The base-clause consists of the character followed by a comma-separated list of one or more base-specifiers.\n\nSame as 4), and can appear in any order.\n\nAn elaborated type specifier cannot directly appear as class-or-computed due to syntax limitations.\n\nIf access-specifier is omitted, it defaults to public for derived classes declared with class-key struct and to private for derived classes declared with class-key class.\n\nClasses denoted by class-or-computed's listed in the base-clause are direct base classes. Their bases are indirect base classes. The same class cannot be specified as a direct base class more than once, but the same class can be both direct and indirect base class.\n\nEach direct and indirect base class is present, as base class subobject, within the object representation of the derived class at an ABI-dependent offset. Empty base classes usually do not increase the size of the derived object due to empty base optimization. The constructors of base class subobjects are called by the constructor of the derived class: arguments may be provided to those constructors in the member initializer list.\n\nFor each distinct base class that is specified virtual, the most derived object contains only one base class subobject of that type, even if the class appears many times in the inheritance hierarchy (as long as it is inherited virtual every time).\n\nAn example of an inheritance hierarchy with virtual base classes is the iostreams hierarchy of the standard library: std::istream and std::ostream are derived from std::ios using virtual inheritance. std::iostream is derived from both std::istream and std::ostream, so every instance of std::iostream contains a std::ostream subobject, a std::istream subobject, and just one std::ios subobject (and, consequently, one std::ios_base).\n\nAll virtual base subobjects are initialized before any non-virtual base subobject, so only the most derived class calls the constructors of the virtual bases in its member initializer list:\n\nThere are special rules for unqualified name lookup for class members when virtual inheritance is involved (sometimes referred to as the rules of dominance).\n\nWhen a class uses public member access specifier to derive from a base, all public members of the base class are accessible as public members of the derived class and all protected members of the base class are accessible as protected members of the derived class (private members of the base are never accessible unless friended).\n\nPublic inheritance models the subtyping relationship of object-oriented programming: the derived class object IS-A base class object. References and pointers to a derived object are expected to be usable by any code that expects references or pointers to any of its public bases (see LSP) or, in DbC terms, a derived class should maintain class invariants of its public bases, should not strengthen any precondition or weaken any postcondition of a member function it overrides.\n\nMenuOption title // Menu is a vector of MenuOption: options can be inserted, removed, reordered... Menu MenuOption title print title i , s size i s i i at i . // Note: Menu::title is not problematic because its role is independent of the base class. Color WHITE, RED, BLUE, GREEN apply_terminal_color Color // ColorMenu is a Menu where every option has a custom color. ColorMenu Menu Color colors print title i , s size i s i i apply_terminal_color colors i at i . apply_terminal_color Color // ColorMenu needs the following invariants that cannot be satisfied // by publicly inheriting from Menu, for example: // - ColorMenu::colors and Menu must have the same number of elements // - To make sense, calling erase() should remove also elements from colors, // in order to let options keep their colors // Basically every non-const call to a std::vector method will break the invariant // of the ColorMenu and will need fixing from the user by correctly managing colors. main ColorMenu color_menu // The big problem of this class is that we must keep ColorMenu::Color color_menu. MenuOption // color_menu.print(); // ERROR! colors[i] in print() is out of range color_menu. . Color color_menu. // OK: colors and Menu has the same number of elements\n\nWhen a class uses protected member access specifier to derive from a base, all public and protected members of the base class are accessible as protected members of the derived class (private members of the base are never accessible unless friended).\n\nProtected inheritance may be used for \"controlled polymorphism\": within the members of Derived, as well as within the members of all further-derived classes, the derived class IS-A base: references and pointers to Derived may be used where references and pointers to Base are expected.\n\nWhen a class uses private member access specifier to derive from a base, all public and protected members of the base class are accessible as private members of the derived class (private members of the base are never accessible unless friended).\n\nPrivate inheritance is commonly used in policy-based design, since policies are usually empty classes, and using them as bases both enables static polymorphism and leverages empty-base optimization.\n\nPrivate inheritance can also be used to implement the composition relationship (the base class subobject is an implementation detail of the derived class object). Using a member offers better encapsulation and is generally preferred unless the derived class requires access to protected members (including constructors) of the base, needs to override a virtual member of the base, needs the base to be constructed before and destructed after some other base subobject, needs to share a virtual base or needs to control the construction of a virtual base. Use of members to implement composition is also not applicable in the case of multiple inheritance from a parameter pack or when the identities of the base classes are determined at compile time through template metaprogramming.\n\nSimilar to protected inheritance, private inheritance may also be used for controlled polymorphism: within the members of the derived (but not within further-derived classes), derived IS-A base.\n\nUnqualified and qualified name lookup rules for class members are detailed in name lookup.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://ibm.com/docs/en/i/7.3?topic=only-access-control-base-class-members-c",
        "document": "When you declare a derived class, an access specifier can precede each base class in the base list of the derived class. This does not alter the access attributes of the individual members of a base class as seen by the base class, but allows the derived class to restrict the access control of the members of a base class.\n\nIn all cases, private members of the base class remain private. Private members of the base class cannot be used by the derived class unless friend declarations within the base class explicitly grant access to them.\n\n: In the following example, private derivation is used by default because no access specifier is used in the base list and the derived class is declared with the keyword\n\nMembers and friends of a class can implicitly convert a pointer to an object of that class to a pointer to either:"
    }
]