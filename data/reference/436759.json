[
    {
        "link": "https://kotlinlang.org/docs/lambdas.html",
        "document": "Kotlin functions are first-class, which means they can be stored in variables and data structures, and can be passed as arguments to and returned from other higher-order functions. You can perform any operations on functions that are possible for other non-function values.\n\nTo facilitate this, Kotlin, as a statically typed programming language, uses a family of function types to represent functions, and provides a set of specialized language constructs, such as lambda expressions.\n\nA higher-order function is a function that takes functions as parameters, or returns a function. A good example of a higher-order function is the functional programming idiom for collections. It takes an initial accumulator value and a combining function and builds its return value by consecutively combining the current accumulator value with each collection element, replacing the accumulator value each time: fun <T, R> Collection<T>.fold( initial: R, combine: (acc: R, nextElement: T) -> R ): R { var accumulator: R = initial for (element: T in this) { accumulator = combine(accumulator, element) } return accumulator } In the code above, the parameter has the function type , so it accepts a function that takes two arguments of types and and returns a value of type . It is invoked inside the loop, and the return value is then assigned to . To call , you need to pass an instance of the function type to it as an argument, and lambda expressions (described in more detail below) are widely used for this purpose at higher-order function call sites: fun main() { //sampleStart val items = listOf(1, 2, 3, 4, 5) // Lambdas are code blocks enclosed in curly braces. items.fold(0, { // When a lambda has parameters, they go first, followed by '->' acc: Int, i: Int -> print(\"acc = $acc, i = $i, \") val result = acc + i println(\"result = $result\") // The last expression in a lambda is considered the return value: result }) // Parameter types in a lambda are optional if they can be inferred: val joinedToString = items.fold(\"Elements:\", { acc, i -> acc + \" \" + i }) // Function references can also be used for higher-order function calls: val product = items.fold(1, Int::times) //sampleEnd println(\"joinedToString = $joinedToString\") println(\"product = $product\") }\n\nKotlin uses function types, such as , for declarations that deal with functions: . These types have a special notation that corresponds to the signatures of the functions - their parameters and return values:\n• None All function types have a parenthesized list of parameter types and a return type: denotes a type that represents functions that take two arguments of types and and return a value of type . The list of parameter types may be empty, as in . The return type cannot be omitted.\n• None Function types can optionally have an additional receiver type, which is specified before the dot in the notation: the type represents functions that can be called on a receiver object with a parameter and return a value . Function literals with receiver are often used along with these types.\n• None Suspending functions belong to a special kind of function type that have a suspend modifier in their notation, such as or . The function type notation can optionally include names for the function parameters: . These names can be used for documenting the meaning of the parameters. To specify that a function type is nullable, use parentheses as follows: . Function types can also be combined using parentheses: . The arrow notation is right-associative, is equivalent to the previous example, but not to . You can also give a function type an alternative name by using a type alias: There are several ways to obtain an instance of a function type:\n• None Use a code block within a function literal, in one of the following forms: Function literals with receiver can be used as values of function types with receiver.\n• None Use a callable reference to an existing declaration: These include bound callable references that point to a member of a particular instance: .\n• None Use instances of a custom class that implements a function type as an interface: The compiler can infer the function types for variables if there is enough information: Non-literal values of function types with and without a receiver are interchangeable, so the receiver can stand in for the first parameter, and vice versa. For instance, a value of type can be passed or assigned where a value of type is expected, and the other way around: A function type with no receiver is inferred by default, even if a variable is initialized with a reference to an extension function. To alter that, specify the variable type explicitly. A value of a function type can be invoked by using its operator: or just . If the value has a receiver type, the receiver object should be passed as the first argument. Another way to invoke a value of a function type with receiver is to prepend it with the receiver object, as if the value were an extension function: . Sometimes it is beneficial to use inline functions, which provide flexible control flow, for higher-order functions.\n\nLambda expressions and anonymous functions are function literals. Function literals are functions that are not declared but are passed immediately as an expression. Consider the following example: The function is a higher-order function, as it takes a function value as its second argument. This second argument is an expression that is itself a function, called a function literal, which is equivalent to the following named function: The full syntactic form of lambda expressions is as follows:\n• None A lambda expression is always surrounded by curly braces.\n• None Parameter declarations in the full syntactic form go inside curly braces and have optional type annotations.\n• None The body goes after the .\n• None If the inferred return type of the lambda is not , the last (or possibly single) expression inside the lambda body is treated as the return value. If you leave all the optional annotations out, what's left looks like this: According to Kotlin convention, if the last parameter of a function is a function, then a lambda expression passed as the corresponding argument can be placed outside the parentheses: Such syntax is also known as trailing lambda. If the lambda is the only argument in that call, the parentheses can be omitted entirely: it: implicit name of a single parameter It's very common for a lambda expression to have only one parameter. If the compiler can parse the signature without any parameters, the parameter does not need to be declared and can be omitted. The parameter will be implicitly declared under the name : ints.filter { it > 0 } // this literal is of type '(it: Int) -> Boolean' You can explicitly return a value from the lambda using the qualified return syntax. Otherwise, the value of the last expression is implicitly returned. Therefore, the two following snippets are equivalent: This convention, along with passing a lambda expression outside of parentheses, allows for LINQ-style code: If the lambda parameter is unused, you can place an underscore instead of its name: Destructuring in lambdas is described as a part of destructuring declarations. The lambda expression syntax above is missing one thing – the ability to specify the function's return type. In most cases, this is unnecessary because the return type can be inferred automatically. However, if you do need to specify it explicitly, you can use an alternative syntax: an anonymous function. An anonymous function looks very much like a regular function declaration, except its name is omitted. Its body can be either an expression (as shown above) or a block: The parameters and the return type are specified in the same way as for regular functions, except the parameter types can be omitted if they can be inferred from the context: The return type inference for anonymous functions works just like for normal functions: the return type is inferred automatically for anonymous functions with an expression body, but it has to be specified explicitly (or is assumed to be ) for anonymous functions with a block body. When passing anonymous functions as parameters, place them inside the parentheses. The shorthand syntax that allows you to leave the function outside the parentheses works only for lambda expressions. Another difference between lambda expressions and anonymous functions is the behavior of non-local returns. A statement without a label always returns from the function declared with the keyword. This means that a inside a lambda expression will return from the enclosing function, whereas a inside an anonymous function will return from the anonymous function itself. A lambda expression or anonymous function (as well as a local function and an object expression) can access its closure, which includes the variables declared in the outer scope. The variables captured in the closure can be modified in the lambda: Function types with receiver, such as , can be instantiated with a special form of function literals – function literals with receiver. As mentioned above, Kotlin provides the ability to call an instance of a function type with receiver while providing the receiver object. Inside the body of the function literal, the receiver object passed to a call becomes an implicit , so that you can access the members of that receiver object without any additional qualifiers, or access the receiver object using a expression. This behavior is similar to that of extension functions, which also allow you to access the members of the receiver object inside the function body. Here is an example of a function literal with receiver along with its type, where is called on the receiver object: The anonymous function syntax allows you to specify the receiver type of a function literal directly. This can be useful if you need to declare a variable of a function type with receiver, and then to use it later. Lambda expressions can be used as function literals with receiver when the receiver type can be inferred from the context. One of the most important examples of their usage is type-safe builders: class HTML { fun body() { ... } } fun html(init: HTML.() -> Unit): HTML { val html = HTML() // create the receiver object html.init() // pass the receiver object to the lambda return html } html { // lambda with receiver begins here body() // calling a method on the receiver object }"
    },
    {
        "link": "https://stackoverflow.com/questions/43469241/passing-lambda-instead-of-interface",
        "document": "but can use it only as an anonymous class, not lambda\n\nI think it should be a possibility to replace it by lambda:\n\nBut I am getting error:\n\nWhat am I doing wrong?"
    },
    {
        "link": "https://medium.com/@manishkumar_75473/kotlin-lambda-expressions-clearing-up-the-confusion-d74dc25b49bc",
        "document": "Kotlin is a modern programming language that makes coding easier and more enjoyable. One of its coolest features is lambda expressions. In beginning it looks tricky to understand as it is without function name, no modifier and no return type. But once you understand the syntax it will be easy. In this blog post, we’ll explore what lambdas are, how to use them, and how they can simplify your code.\n\nA lambda expression is a concise way to define a function without giving it a name. It lets you write functions as expressions that can be passed around and used as parameters.\n\nLet’s start by looking at a normal function that adds two numbers:\n\nThis function takes two integers and returns their sum. Now, let’s see how we can write the same logic using a lambda expression.\n\nWriting the Same Function as a Lambda\n\nHere’s how you can write the function as a lambda expression:\n\nIn this example, is a variable of type , which means it takes two integers and returns an integer. The lambda defines the logic for adding the two numbers.\n\nThe syntax for a lambda expression is straightforward:\n• List the parameters (if any) followed by\n• Then write the body of the lambda\n\nFor example, a simple lambda that multiplies two numbers looks like this:\n\nIn Java, you often create a class that implements an interface. For example:\n\nWith Kotlin’s lambdas, you can replace this whole class with a simple lambda:\n\nNote—Lambda expressions can only be used with SAM interfaces (interfaces with exactly one abstract method i.e. functional Interface). If an interface has more than one abstract method, you need to provide a full implementation using or a regular class. A lambda expression provides an inline, shorthand implementation for a single method. If there are multiple methods, it’s not clear which method should be represented by the lambda, which is why Kotlin restricts lambdas to SAM interfaces.\n\nYou can make your lambda expressions even more concise by omitting braces and types in certain situations:\n• Omitting Braces: If the lambda is the only argument to a function or last params of a function , you can drop the braces. For example:\n• Omitting Type: If the type can be inferred, you can also skip declaring it:\n\nYou can pass lambda expressions as parameters to functions. Here’s an example of a function that takes a lambda to perform an operation:\n\nWhile both Java and Kotlin support lambda expressions, there are some key differences:\n\nJava: Requires parentheses and to define a lambda. For example:\n• Kotlin: Uses a more concise syntax. You can directly define a lambda without parentheses if it’s the only argument:\n• Java: Requires explicit type declaration when defining a lambda if the context does not provide it.\n• Kotlin: Can often infer types, allowing you to skip them entirely:\n\n3. No Need for Functional Interfaces:\n• Java: Lambda expressions CAN BE used in the context of a functional interface (an interface with a single abstract method).\n• Kotlin: Lambdas can be used independently, making it more flexible and easier to work with.\n• Java: Uses the Stream API to work with collections, which can be more verbose.\n• Kotlin: Provides built-in functions like , , etc. that directly accept lambdas, making operations on collections more concise and readable.\n\nLambda expressions in Kotlin provide a simple and elegant way to write functions. They can replace traditional interface implementations, reduce boilerplate code, and make your code cleaner and easier to read.\n\nBy understanding how to use lambdas, you can take full advantage of Kotlin’s powerful features and write more expressive code."
    },
    {
        "link": "https://droidcon.com/2024/05/31/everything-you-want-to-know-about-functional-interfaces-in-kotlin",
        "document": "Kobweb is a Kotlin web framework that aims to make web development enjoyable by building on top of Compose HTML and drawing inspiration from Jetpack Compose."
    },
    {
        "link": "https://kotlinlang.org/docs/fun-interfaces.html",
        "document": "An interface with only one abstract member function is called a functional interface, or a Single Abstract Method (SAM) interface. The functional interface can have several non-abstract member functions but only one abstract member function.\n\nTo declare a functional interface in Kotlin, use the modifier.\n\nFor functional interfaces, you can use SAM conversions that help make your code more concise and readable by using lambda expressions. Instead of creating a class that implements a functional interface manually, you can use a lambda expression. With a SAM conversion, Kotlin can convert any lambda expression whose signature matches the signature of the interface's single method into the code, which dynamically instantiates the interface implementation. For example, consider the following Kotlin functional interface: If you don't use a SAM conversion, you will need to write code like this: By leveraging Kotlin's SAM conversion, you can write the following equivalent code instead: // Creating an instance using lambda val isEven = IntPredicate { it % 2 == 0 } You can also use SAM conversions for Java interfaces.\n\nMigration from an interface with constructor function to a functional interface Starting from 1.6.20, Kotlin supports callable references to functional interface constructors, which adds a source-compatible way to migrate from an interface with a constructor function to a functional interface. Consider the following code: With callable references to functional interface constructors enabled, this code can be replaced with just a functional interface declaration: Its constructor will be created implicitly, and any code using the function reference will compile. For example: Preserve the binary compatibility by marking the legacy function with the annotation with : @Deprecated(message = \"Your message about the deprecation\", level = DeprecationLevel.HIDDEN) fun Printer(...) {...}\n\nYou can also simply rewrite the above using a type alias for a functional type: However, functional interfaces and type aliases serve different purposes. Type aliases are just names for existing types – they don't create a new type, while functional interfaces do. You can provide extensions that are specific to a particular functional interface to be inapplicable for plain functions or their type aliases. Type aliases can have only one member, while functional interfaces can have multiple non-abstract member functions and one abstract member function. Functional interfaces can also implement and extend other interfaces. Functional interfaces are more flexible and provide more capabilities than type aliases, but they can be more costly both syntactically and at runtime because they can require conversions to a specific interface. When you choose which one to use in your code, consider your needs:\n• None If your API needs to accept a function (any function) with some specific parameter and return types – use a simple functional type or define a type alias to give a shorter name to the corresponding functional type.\n• None If your API accepts a more complex entity than a function – for example, it has non-trivial contracts and/or operations on it that can't be expressed in a functional type's signature – declare a separate functional interface for it."
    },
    {
        "link": "https://kotlinlang.org/docs/lambdas.html",
        "document": "Kotlin functions are first-class, which means they can be stored in variables and data structures, and can be passed as arguments to and returned from other higher-order functions. You can perform any operations on functions that are possible for other non-function values.\n\nTo facilitate this, Kotlin, as a statically typed programming language, uses a family of function types to represent functions, and provides a set of specialized language constructs, such as lambda expressions.\n\nA higher-order function is a function that takes functions as parameters, or returns a function. A good example of a higher-order function is the functional programming idiom for collections. It takes an initial accumulator value and a combining function and builds its return value by consecutively combining the current accumulator value with each collection element, replacing the accumulator value each time: fun <T, R> Collection<T>.fold( initial: R, combine: (acc: R, nextElement: T) -> R ): R { var accumulator: R = initial for (element: T in this) { accumulator = combine(accumulator, element) } return accumulator } In the code above, the parameter has the function type , so it accepts a function that takes two arguments of types and and returns a value of type . It is invoked inside the loop, and the return value is then assigned to . To call , you need to pass an instance of the function type to it as an argument, and lambda expressions (described in more detail below) are widely used for this purpose at higher-order function call sites: fun main() { //sampleStart val items = listOf(1, 2, 3, 4, 5) // Lambdas are code blocks enclosed in curly braces. items.fold(0, { // When a lambda has parameters, they go first, followed by '->' acc: Int, i: Int -> print(\"acc = $acc, i = $i, \") val result = acc + i println(\"result = $result\") // The last expression in a lambda is considered the return value: result }) // Parameter types in a lambda are optional if they can be inferred: val joinedToString = items.fold(\"Elements:\", { acc, i -> acc + \" \" + i }) // Function references can also be used for higher-order function calls: val product = items.fold(1, Int::times) //sampleEnd println(\"joinedToString = $joinedToString\") println(\"product = $product\") }\n\nKotlin uses function types, such as , for declarations that deal with functions: . These types have a special notation that corresponds to the signatures of the functions - their parameters and return values:\n• None All function types have a parenthesized list of parameter types and a return type: denotes a type that represents functions that take two arguments of types and and return a value of type . The list of parameter types may be empty, as in . The return type cannot be omitted.\n• None Function types can optionally have an additional receiver type, which is specified before the dot in the notation: the type represents functions that can be called on a receiver object with a parameter and return a value . Function literals with receiver are often used along with these types.\n• None Suspending functions belong to a special kind of function type that have a suspend modifier in their notation, such as or . The function type notation can optionally include names for the function parameters: . These names can be used for documenting the meaning of the parameters. To specify that a function type is nullable, use parentheses as follows: . Function types can also be combined using parentheses: . The arrow notation is right-associative, is equivalent to the previous example, but not to . You can also give a function type an alternative name by using a type alias: There are several ways to obtain an instance of a function type:\n• None Use a code block within a function literal, in one of the following forms: Function literals with receiver can be used as values of function types with receiver.\n• None Use a callable reference to an existing declaration: These include bound callable references that point to a member of a particular instance: .\n• None Use instances of a custom class that implements a function type as an interface: The compiler can infer the function types for variables if there is enough information: Non-literal values of function types with and without a receiver are interchangeable, so the receiver can stand in for the first parameter, and vice versa. For instance, a value of type can be passed or assigned where a value of type is expected, and the other way around: A function type with no receiver is inferred by default, even if a variable is initialized with a reference to an extension function. To alter that, specify the variable type explicitly. A value of a function type can be invoked by using its operator: or just . If the value has a receiver type, the receiver object should be passed as the first argument. Another way to invoke a value of a function type with receiver is to prepend it with the receiver object, as if the value were an extension function: . Sometimes it is beneficial to use inline functions, which provide flexible control flow, for higher-order functions.\n\nLambda expressions and anonymous functions are function literals. Function literals are functions that are not declared but are passed immediately as an expression. Consider the following example: The function is a higher-order function, as it takes a function value as its second argument. This second argument is an expression that is itself a function, called a function literal, which is equivalent to the following named function: The full syntactic form of lambda expressions is as follows:\n• None A lambda expression is always surrounded by curly braces.\n• None Parameter declarations in the full syntactic form go inside curly braces and have optional type annotations.\n• None The body goes after the .\n• None If the inferred return type of the lambda is not , the last (or possibly single) expression inside the lambda body is treated as the return value. If you leave all the optional annotations out, what's left looks like this: According to Kotlin convention, if the last parameter of a function is a function, then a lambda expression passed as the corresponding argument can be placed outside the parentheses: Such syntax is also known as trailing lambda. If the lambda is the only argument in that call, the parentheses can be omitted entirely: it: implicit name of a single parameter It's very common for a lambda expression to have only one parameter. If the compiler can parse the signature without any parameters, the parameter does not need to be declared and can be omitted. The parameter will be implicitly declared under the name : ints.filter { it > 0 } // this literal is of type '(it: Int) -> Boolean' You can explicitly return a value from the lambda using the qualified return syntax. Otherwise, the value of the last expression is implicitly returned. Therefore, the two following snippets are equivalent: This convention, along with passing a lambda expression outside of parentheses, allows for LINQ-style code: If the lambda parameter is unused, you can place an underscore instead of its name: Destructuring in lambdas is described as a part of destructuring declarations. The lambda expression syntax above is missing one thing – the ability to specify the function's return type. In most cases, this is unnecessary because the return type can be inferred automatically. However, if you do need to specify it explicitly, you can use an alternative syntax: an anonymous function. An anonymous function looks very much like a regular function declaration, except its name is omitted. Its body can be either an expression (as shown above) or a block: The parameters and the return type are specified in the same way as for regular functions, except the parameter types can be omitted if they can be inferred from the context: The return type inference for anonymous functions works just like for normal functions: the return type is inferred automatically for anonymous functions with an expression body, but it has to be specified explicitly (or is assumed to be ) for anonymous functions with a block body. When passing anonymous functions as parameters, place them inside the parentheses. The shorthand syntax that allows you to leave the function outside the parentheses works only for lambda expressions. Another difference between lambda expressions and anonymous functions is the behavior of non-local returns. A statement without a label always returns from the function declared with the keyword. This means that a inside a lambda expression will return from the enclosing function, whereas a inside an anonymous function will return from the anonymous function itself. A lambda expression or anonymous function (as well as a local function and an object expression) can access its closure, which includes the variables declared in the outer scope. The variables captured in the closure can be modified in the lambda: Function types with receiver, such as , can be instantiated with a special form of function literals – function literals with receiver. As mentioned above, Kotlin provides the ability to call an instance of a function type with receiver while providing the receiver object. Inside the body of the function literal, the receiver object passed to a call becomes an implicit , so that you can access the members of that receiver object without any additional qualifiers, or access the receiver object using a expression. This behavior is similar to that of extension functions, which also allow you to access the members of the receiver object inside the function body. Here is an example of a function literal with receiver along with its type, where is called on the receiver object: The anonymous function syntax allows you to specify the receiver type of a function literal directly. This can be useful if you need to declare a variable of a function type with receiver, and then to use it later. Lambda expressions can be used as function literals with receiver when the receiver type can be inferred from the context. One of the most important examples of their usage is type-safe builders: class HTML { fun body() { ... } } fun html(init: HTML.() -> Unit): HTML { val html = HTML() // create the receiver object html.init() // pass the receiver object to the lambda return html } html { // lambda with receiver begins here body() // calling a method on the receiver object }"
    },
    {
        "link": "https://stackoverflow.com/questions/52126810/lambdas-and-runnable",
        "document": "My Understanding was Lambda's expression is used to replace boiler-plater code around an abstract implementation. So if i have to create a new Thread which takes a Runnable interface (Functional), i do not have to create a new Anonymous class, then provide void run() and then write my logic inside it rather can simply use a lambda and point it to a method provided the method signature is same as run i.e. takes nothing, returns nothing.\n\nHowever i could not understand the implementation below\n\nIn above case printStudent takes an argument (not like run() method of runnable) though somehow it works.\n\nHow does this work ?"
    },
    {
        "link": "https://kotlinlang.org/docs/fun-interfaces.html",
        "document": "An interface with only one abstract member function is called a functional interface, or a Single Abstract Method (SAM) interface. The functional interface can have several non-abstract member functions but only one abstract member function.\n\nTo declare a functional interface in Kotlin, use the modifier.\n\nFor functional interfaces, you can use SAM conversions that help make your code more concise and readable by using lambda expressions. Instead of creating a class that implements a functional interface manually, you can use a lambda expression. With a SAM conversion, Kotlin can convert any lambda expression whose signature matches the signature of the interface's single method into the code, which dynamically instantiates the interface implementation. For example, consider the following Kotlin functional interface: If you don't use a SAM conversion, you will need to write code like this: By leveraging Kotlin's SAM conversion, you can write the following equivalent code instead: // Creating an instance using lambda val isEven = IntPredicate { it % 2 == 0 } You can also use SAM conversions for Java interfaces.\n\nMigration from an interface with constructor function to a functional interface Starting from 1.6.20, Kotlin supports callable references to functional interface constructors, which adds a source-compatible way to migrate from an interface with a constructor function to a functional interface. Consider the following code: With callable references to functional interface constructors enabled, this code can be replaced with just a functional interface declaration: Its constructor will be created implicitly, and any code using the function reference will compile. For example: Preserve the binary compatibility by marking the legacy function with the annotation with : @Deprecated(message = \"Your message about the deprecation\", level = DeprecationLevel.HIDDEN) fun Printer(...) {...}\n\nYou can also simply rewrite the above using a type alias for a functional type: However, functional interfaces and type aliases serve different purposes. Type aliases are just names for existing types – they don't create a new type, while functional interfaces do. You can provide extensions that are specific to a particular functional interface to be inapplicable for plain functions or their type aliases. Type aliases can have only one member, while functional interfaces can have multiple non-abstract member functions and one abstract member function. Functional interfaces can also implement and extend other interfaces. Functional interfaces are more flexible and provide more capabilities than type aliases, but they can be more costly both syntactically and at runtime because they can require conversions to a specific interface. When you choose which one to use in your code, consider your needs:\n• None If your API needs to accept a function (any function) with some specific parameter and return types – use a simple functional type or define a type alias to give a shorter name to the corresponding functional type.\n• None If your API accepts a more complex entity than a function – for example, it has non-trivial contracts and/or operations on it that can't be expressed in a functional type's signature – declare a separate functional interface for it."
    },
    {
        "link": "https://stackoverflow.com/questions/48284994/lambda-implementation-of-interface-in-kotlin",
        "document": "To anyone who is reading this in 2022, Kotlin now has Functional (SAM) Interfaces. Please see https://kotlinlang.org/docs/fun-interfaces.html\n\nMaybe it will save others some time depending on your use case."
    },
    {
        "link": "https://antonioleiva.com/lambdas-kotlin",
        "document": "Lambdas are one of the most powerful tools in Kotlin, and in any other modern language, since it allows modelling functions in a much simpler way.\n\nThe only way we can do this in Java 6 is by declaring interfaces with a single method, and creating anonymous objects that implement those interfaces.\n\nLambdas, and specially the way lambdas can be defined in Kotlin, open up an infinite world of possibilities. We will see some of these usages in the following articles.\n\nA lambda is a way of representing a function, and we already saw an example of this when explaining the :\n\nAs you can see, the left side defines the input values of the function (in this case a view), and the right side declares the operation that function will perform.\n\nHow to define a function that accepts lambdas\n\nIf we wanted to define that function in Kotlin by ourselves, we would do the following:\n\nThis is known as a Higher-Order Function, because it is a function that receives a function by parameter, or that returns a function.\n\nThe natural way of calling this function would be as follows:\n\nBut we’ve already seen that there is a simpler way to do this, and that will also help us do very cool things that we will see right after.\n\nThis is because if the last parameter of a function is a function, we can extract it from the parentheses:\n\nBut in addition, if there is only one function as a parameter, we can just get rid of the parentheses:\n\nThis allows us to create our own DSLs, which can define mini-languages. In Kotlin reference website there is an example with HTML, but here we are going to define an easier one.\n\nImagine that you want to create blocks of code that run on another thread. You could have a function that receives the function we want to run in the background:\n\nThis function creates a thread that executes a which runs the function received as an argument. As is a class with a single method in Java, it can be substituted by a lambda in Kotlin.\n\nNow we can create asynchronous blocks in our code:\n\nEverything inside the braces will be executed in a secondary thread.\n\nThe ugly part of receiving functions as an argument is that the compiler needs to create classes for them, which can impact the performance. But this can be easily solved by using the reserved word .\n\nAn inline function will have less impact in performance because it will substitute the call to the function by its code in compilation time. So it won’t require the use of an extra object for this.\n\nWe can convert into an inline function:\n\nThe in this case, is required because we are calling from another execution context (another lambda). Don’t worry about this too much, as the compiler will warn you when you need to use it.\n\nIf you want to learn more about , and also how it applies to the reified types concept, you can learn more about it in this video I recorded:\n\nAs you can see, with lambdas we can simplify our code a lot, and even achieve things that were impossible in Java.\n\nIn addition, Kotlin’s specific nomenclature makes it possible for us to create our own “language”, and create meaningful blocks of code that do what we need.\n\nAnd if you want to learn how to use Kotlin to develop your own Android Apps, I recommend you take a look at my free training."
    }
]