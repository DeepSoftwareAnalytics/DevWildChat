[
    {
        "link": "https://help.figma.com/hc/en-us/articles/360040314193-Guide-to-prototyping-in-Figma",
        "document": "Figma‚Äôs prototyping features allow you to create interactive flows that explore how a user may interact with your designs.\n\nPrototypes are a fantastic way to:\n\nWatch our video on prototyping below. Or, check out our Prototype & Collaboration Playlist on Youtube.\n\nWith prototyping in Figma, you can create multiple flows for your prototype in one page to preview a user's full journey and experience through your designs.\n\nA flow is the network of frames and connections in a single page. A prototype can map out a user's entire journey through your app or website, or it can focus on a specific segment of it via its own flow. For example: your prototype covers all possible interactions on an eCommerce site. Within the prototype, you have flows for creating an account, adding items to a cart, and checking out.\n\nFigma creates a flow starting point when you add your first connection between two frames. There are a few other ways to add a flow starting point to your prototype:\n‚Ä¢ With the starting frame selected, click in the Flow starting point section of the right sidebar.\n‚Ä¢ Right-click on the frame, then click Add starting point.\n\nWhen it's time to test your designs, you can share the entire prototype or copy the link to a flow starting point.\n\nLearn more about starting points and flows ‚Üí\n‚Ä¢ Select the hotspot for the connection.\n‚Ä¢ Drag it to the destination.\n‚Ä¢ If there are no existing connections, Figma will make the first frame a starting point.\n‚Ä¢ Open the Prototype tab in the right sidebar\n‚Ä¢ A hotspot is where the Interaction takes place. A hotspot can be any object within the original frame, such as a link, button, image or icon, etc.\n‚Ä¢ Connections are the blue arrows or \"noodles\" that connect the hotspot to the destination. We apply the interaction and animation settings via the connection.\n‚Ä¢ A flow is the network of connected frames that form a path through a prototype. Each flow has its own starting point. You can have multiple flows within a prototype.\n‚Ä¢ The starting point is the first frame of a flow. Set multiple starting points to show different flows of the prototype in Presentation view.\n‚Ä¢ The trigger determines what type of interaction with the hotspot will cause the prototype to advance. This could be a mouse or touch interaction, such as a tap, drag, click, hover, etc.\n‚Ä¢ The destination is where the transition ends. This must be a top-level frame - a frame that is added directly to the canvas - and not an object within a frame. If we think of moving from A to B, A is the hotspot and B is the destination.\n‚Ä¢ The action defines the type of progression is occurring in the prototype. For example, the action could be to navigate to another frame, or open an external URL.\n‚Ä¢ The animation settings determine how the prototype moves from one frame to the other. You can control the type of animation, as well as the speed and direction.\n‚Ä¢ A transition is the type of animation. This defines how the action moves to the destination.\n‚Ä¢ The direction controls the direction that the transition comes from. Choose between left, right, top or bottom.\n‚Ä¢ The duration controls the time it takes to complete the animation. The shorter the duration, the faster the transition. Select a duration between 1ms and 10000ms (10 seconds).\n‚Ä¢ Easing affects the acceleration of the animation whether it starts slow or fast. This allows you to build animations that feel more natural.\n‚Ä¢ Overlays are frames that appear above the current screen or frame. You can use overlays to create tool-tips, interactive menus, alerts, or confirmations.\n‚Ä¢ Overflow behavior allows you to define how your prototype responds to scrolling. This allows you to create more advanced user interactions, such as carousels, galleries, or interactive maps.\n‚Ä¢ Choose which device will be shown when presenting your prototype. Define both the device and the model.\n‚Ä¢ The background color lets you define the color in the background of your prototype.\n‚Ä¢ If you have a prototype with portrait and landscape frames, you can select an orientation. The orientation is set for the entire prototype. It's not possible to switch between portrait and landscape view within a prototype.\n‚Ä¢ A preview will show you how something will look or work in the prototype. We show previews for both animations and prototype device settings."
    },
    {
        "link": "https://support.animaapp.com/en/articles/6226128-how-to-create-hover-effects-in-figma",
        "document": "A Hover Effect happens when a visitor hovers their mouse over a specific element and the element responds with transition effects. In this guide, we will show you how to create beautiful and eye-catching hover effects using the Anima plugin within Figma!\n\nFigma's Interactive Components feature allows the addition of interactions between component variants. Here's how to use this feature:\n‚Ä¢ None Design Your Variants: Within Figma, create variants of your component, one for its default state and others for its hover state(s).\n‚Ä¢ None Configure Interactivity: Navigate to the 'Prototype' tab in Figma. Link the default variant to its hover state variant, selecting 'While hovering' as the trigger for this interaction.\n‚Ä¢ None Fine-tune the Transition: Customize the transition settings to ensure a smooth effect that aligns with your design's aesthetic.\n‚Ä¢ None Download the code: Anima converts Figma interactions into code. Open the Anima plugin, Select the screen, and click 'Get code' to get \n\nHTML/CSS/JSX code.\n\nAdding Hover Effect in Figma Without Using Components:\n\nIn addition to using Figma's Interactive Components, Anima offers another pathway for integrating hover effects. Here's how to leverage this feature:\n‚Ä¢ None Choose the layer/group you wish to apply the hover effect to.\n‚Ä¢ None Open the Anima plugin and click on Hover Effects.\n‚Ä¢ None Fine-tune the Transition: Select the desired effect or enter your own custom CSS.\n\n‚Äã\n‚Ä¢ None Anima offers a variety of preset effects, such as , , , , and more.\n‚Ä¢ None Customize the CSS value, duration, and curve.\n\n‚Äã\n‚Ä¢ None Preview to see how it looks üëåüèº\n‚Ä¢ None Sync the file to Anima or return to add additional effects.\n‚Ä¢ None Share or Download code: You can now share a live preview of your design or download the screen's HTML/CSS/JSX code.\n\nTry it on your own for free!"
    },
    {
        "link": "https://help.figma.com/hc/en-us/articles/360039818254-Create-overlays-in-your-prototypes",
        "document": "Prototypes often require transitions between screens in a design. For some interactions, you may want to keep the user on the same screen, but show additional information.\n\nOverlays allow you to show new content or information above the current screen in a prototype. Use overlays to prototype:\n\nIn a prototype connection, an action usually takes the user from A to B. When the action is an overlay, Figma shows the overlay above the current screen.\n\nFigma usually applies interaction settings to just that the connection. When you create an overlay, Figma applies those settings to the overlay itself, not the connection.\n\nThis allows you to apply those settings once and reuse that overlay across your prototype.\n\nYou create an overlay when you define the interaction of a connection. Overlays can be triggered from any object, layer, group or frame. The overlay must be inside a frame.\n‚Ä¢ Click the Prototype tab in the right sidebar.\n‚Ä¢ Hover over the object you want to start the overlay from. Click on the prototype node and drag a connection to the frame you want to become the overlay.\n‚Ä¢ Now you can customize the interaction. There are three aspects of the interaction, the trigger, action and destination.\n‚Ä¢ Select what kind of interaction will trigger the animation.\n‚Ä¢ Figma determines the Destination based on where the connection ends. For this interaction, you want this to be the overlay frame.\n\n\n\nThere are a few aspects of an overlay that you can customize:\n‚Ä¢ Position: The location of the overlay relative to the original frame. Choose from seven default options or set a position manually.\n‚Ä¢ Close when clicking outside: Check this setting to dismiss the overlay when a user clicks outside the overlay's dimensions.\n‚Ä¢ Add background behind overlay: Check this setting to add a background color behind the overlay and in front of the current frame. Set both the color and the opacity.\n‚Ä¢ In the Animation section, customize how the overlay will appear. Select the (1) transition and any additional settings, including (2) direction, (3) easing, and (4) duration. Learn how to build prototypes with interactions and animations.\n\n\n\nWhen working with overlays, you can choose the Swap overlay action. This allows you to keep the existing settings while you swap one overlay for another.\n\nIn the following example, we used Swap overlay to show a user interacting with our in-app help menu.\n‚Ä¢ The user clicks on the help icon, which opens the first overlay ( ).\n‚Ä¢ They select the option from the menu.\n‚Ä¢ We replace the overlay with a overlay.\n‚Ä¢ Select the first overlay in the canvas.\n‚Ä¢ Open the Prototype tab in the right sidebar.\n‚Ä¢ In the Trigger field, choose the type of interaction you want to use as the trigger.\n‚Ä¢ In the Destination field, select the overlay you'd want to swap to.\n‚Ä¢ Customize the Animation with transition, direction, easing, and duration settings.\n\nUnlike other actions, overlay settings are applied to the overlay and not the connection. This means you can update the overlay's settings in one place.\n\nYou can only edit or remove an overlay in Prototype mode.\n‚Ä¢ Identify an overlay using the blue icon. This will appear next to the frame in the canvas.\n‚Ä¢ Click the icon to view overlay's settings in the right sidebar.\n‚Ä¢ Make any changes to the overlay, as required.\n\nThere are a few ways to delete an overlay:\n‚Ä¢ Click on the connection arrow and drag it to an empty part of the canvas.\n‚Ä¢ Click the icon to select the overlay, then press the key.\n‚Ä¢ Remove all connections on the current page. Right-click on a connection and select Remove all interactions."
    },
    {
        "link": "https://help.figma.com/hc/en-us/articles/360039818874-Smart-animate-layers-between-frames",
        "document": "Smart animate looks for matching layers, recognizes differences, and animates layers between frames in a prototype.\n\nYou can select Smart animate from the list of transitions, when building a prototype. You can also apply Smart animate with other transitions to create seamless animations.\n\nSmart animate allows you to quickly create advanced animations. Use Smart animate to replicate:\n\nLearn more about how we built smart animate in our Blog post: Announcing smart animate.\n\nSmart animate looks for matching layers that exist across multiple frames. Figma takes into account both the layer's name and where it sits within the hierarchy.\n\nFor layers that match between frames, Figma recognizes what's changed and applies transition to animate between them.\n\nYou can apply smart animate to entire objects or Components, as well as individual layers within a Component or group.\n\nIt's likely that more than one of an object's properties will change between Frames. We've isolated each of the properties we support below, so you know what to expect.\n\nIf an object changes in size between frames, Figma will animate it shrinking or growing.\n\nFigma recognizes if an object's location, the x and y co-ordinates, have changed. It will then animate the object moving from its current position, to its position in the destination frame.\n\nSmart animate can also recognize a layer or object's opacity. You can adjust opacity to make an object to appear or disappear between frames.\n\nSet the opacity of the layer to 0%, instead of toggling the layer visibility. Figma will apply a dissolve transition to animate the layer's opacity.\n\nYou can adjust opacity through a layer's Fill properties, as well as through the Layer property. Smart animate will apply to both.\n\nWe recommend adjusting the entire layer's opacity. Adjust the opacity Layer setting in the Design tab of the right sidebar.\n\nSmart animate also takes the layer's rotation and orientation into account.\n\nYou can rotate an object using the rotation field in the right sidebar or in the canvas itself. Hover over the corner bounds of an object until the rotation cursor appears.\n\nRotate a single layer at once, or rotate a group of them around a single anchor point.\n\nFigma will smart animate any changes to an object's fill. This allows you to animate changes between solid colors, gradients and even image fills.\n\nThere are two ways you can use smart animate in your prototypes. As a stand alone transition, or by using Smart animate matching layers with another animation.\n\nSelect Smart animate in the transition field to animate between two frames.\n‚Ä¢ Open the Prototype tab in the right sidebar.\n‚Ä¢ Select layer, group, or frame in the canvas. A connection node will appear on the right-edge.\n‚Ä¢ Click on the node and drag it to the next frame to create a connection.\n‚Ä¢ Define the Interaction in the right sidebar by choosing a trigger and action. Figma will set the second frame as the destination.\n‚Ä¢ In the Animation section, select Smart animate from the transition field.\n‚Ä¢ Apply Easing to the transition, or change the Duration (optional).\n‚Ä¢ Repeat for any other frames you want to smart animate.\n‚Ä¢ Click the in the toolbar to open the prototype in Presentation View.\n\nIn our example below, we have three frames with some matching layers. We want smart animate to animate removing the Abel Tasman Coast Track from our list of favorites.\n\nSmart animate now moves us smoothly between each frame in our prototype!\n\nIf you want to smart animate some layers in your prototype while using another main transition, you can check a box to Smart animate matching layers.\n\nFigma treats fixed layers differently when using smart animate with other transitions.\n‚Ä¢ Layers that don't match: Figma will use the main transition you select.\n‚Ä¢ Layers that do match: Figma will Smart animate any differences for supported properties.\n‚Ä¢ Fixed layers that do match: Figma won't apply any transition.\n‚Ä¢ Fixed layers that don't match: Figma will apply a dissolve transition instead of the transition you select.\n\nTo use Smart animate matching layers, check the box in the right sidebar when adjust the animation:\n\nIn our example below, we have a status bar and navigation that exist across all three frames. We want these to stay in place when we switch between tabs.\n\n\n\nWe've selected a Push Transition to move between Frames. We choose not to check the box next to Smart animate matching layers.\n\nWhen we view our Prototype, we can see that everything in our destination frame uses the Push transition. This makes it pretty obvious that we're moving between separate screens in a prototype.\n\nIf we check the box next to Smart animate matching layers, our status bar and navigation stay in place, while the other content uses Push.\n\nBefore smart animate, Figma didn't place much importance on layer names. As Smart Animate is reliant on Layer name and hierarchy, this may require you to use a different approach.\n\nLearn more about creating matching objects with layer name and hierarchy ‚Üí\n\nWe've outlined a few ways to troubleshoot unexpected smart animate results below.\n\nOne quick way to create frames for smart animate is to duplicate them. This keeps the naming consistent between each frame. You can then add and remove layers to each frame, as needed.\n\nFigma names frames and layers based on the way you duplicate or copy and paste them.\n‚Ä¢ Within a frame: Figma numbers layers them sequentially. For example: Frame 1, Frame 2 etc.\n‚Ä¢ Between frames: Figma uses the same name. For example: If you copy from one frame, Figma will paste it as in the next frame.\n\nYou may have objects or layer that exist across frames, but have different names in each. Or, you may have the opposite problem - layers that all have the same name, which you don't want to match.\n\nYou can view and update your layer names using the Layers panel in the left sidebar. Learn how to rename layers in bulk.\n\nFigma has also made it easier to identify layers or objects that exist - or match - between frames. This applies to all layers, groups, frames, and Components.\n‚Ä¢ Open the Prototype tab in the right sidebar.\n‚Ä¢ Hover over an object or layer in the canvas.\n‚Ä¢ Figma will highlight that layer in any other frames it exists in.\n\nSmart animate and Smart animate matching layers take into account the layer order, or hierarchy of your layers.\n\nNormally, Move in or Slide in will transition the entire destination frame above the original frame. With smart animate matching layers, Figma will move or slide in layers based on their hierarchy, which can cause some confusing or unexpected results.\n\nIn our screenshot below, we have two matching objects between our frames ( and ). These are the Status Bar and the Navigation.\n\nIf we have layers above any matching layers, Figma will animate them above the destination frame. In our screenshot below, we can see layers from appear above the destination frame.\n\nBy moving our matching layers to the top of the hierarchy instead, we can make sure the entire destination frames slide above the original frame.\n\nTo be more precise in deciding what to smart animate, Figma matches layers based on their name and hierarchy. This also lets you quickly un-match layers between frames.\n\nLet's say that we have five rectangles in each of our frames. These rectangles contain different content between each frame. We labeled them as to across all three frames.\n\nWhen we try apply a Push transition, smart animate recognizes them as matching layers. Instead of treating these rectangles as new content, Figma smart animates the change to their position.\n\nTo change this behavior, we can group the rectangle trips in each frame and give them a unique name.\n\nWhen we preview our transition, smart animate no longer recognizes these as matching layers. Our content will Push in together, making our Prototype look much more realistic.\n\nSmart animate with Slide in and Move in\n\nThere are a few things to consider when using Smart animate matching layers with Slide or Move transitions.\n\nWhen selected, Figma will animate any matching layers between frames. This means Figma can't animate the entire destination Frame (B) over the initial Frame (A), like it normally would.\n\nFigma also doesn't include a frame's fill as part of the animation. This can cause layers to overlap, making the transition look messy.\n\nTo prevent this, we can add a rectangle with a solid fill behind our other layers. Now, when we view our prototype, the content in each frame slides in together."
    },
    {
        "link": "https://thalion.pro/post/figma-tutorial-button-hover-interaction",
        "document": ""
    },
    {
        "link": "https://nngroup.com/articles/interactive-ux-maps",
        "document": "Interactions can be applied to high-fidelity UX maps to showcase user research and further engage with stakeholders.\n\nOur visual-design guide for UX Maps shows how to approach creating high-fidelity maps, regardless of the design tool. This article explores the use of user-interface (UI) design software, like Figma or Sketch, for building high-fidelity, interactive UX maps. Maps based on research that focus on a product or service's current (as-is) state, like customer-journey maps or experience maps, work best as interactive rather than static maps because interactivity allows you to showcase specific user quotes and actions.\n\nInteractive maps are not appropriate for every single project. Here, we discuss some of their advantages and disadvantages.\n‚Ä¢ Utilizing photos and videos. Showcase photos and videos from user research directly into your map. Overlays can be used to progressively reveal media evidence related to a specific finding.\n‚Ä¢ Improving comprehension. Interactions can make a large, complex map easier to understand if done effectively, especially if you are comparing different user journeys on one map. For example, filters can help stakeholders sort by a specific user persona or theme, and overlays can reveal evidence that might help contextualize a finding.\n‚Ä¢ Time-consuming. Consider your map's scope, project budget, and timeline before adding interactions. For instance, your time might be better spent elsewhere if you already have a polished, noninteractive map and only a few more days left before presenting it to stakeholders. Similarly, you will probably waste time and money if the map‚Äôs stakes are low and you build it from scratch.\n‚Ä¢ Hard to create. It takes time to learn any design software. If you currently don‚Äôt use a UI-design software or aren‚Äôt comfortable with its advanced features, your deliverable may be hard to use and cause frustration. This goes for any software, from Figma to Sketch. Stakeholders have power over your project, and incoherent interactions might influence them negatively.\n\nUntil you feel comfortable with your chosen UI-design software, save yourself time, money, and a headache by creating a noninteractive UX map in software you are more familiar with. A good UX map with no interactions can be just as effective. Learning new software takes time, so take advantage of free resources like Figma‚Äôs YouTube channel, ProtoPie School, and Sketch Guides & Courses to build up your skills.\n\nOnce you‚Äôve determined that you want to build an interactive UX map, here are some steps to get started. In this example, I will be using Figma, so some features might look different or not be available in other software.\n‚Ä¢ Consolidate findings and data into a low-fidelity map. Before you start building a high-fidelity interactive map, gather all your data and synthesize it in the form of a low-fidelity map. This step is essential. Starting with a low-fidelity map helps you document which findings relate to which pieces of evidence. For example, if you have the finding ‚ÄúUsers are worried about being able to afford new software‚Äù and want to show video evidence from a specific research participant, include a link to the video in your low-fidelity map or provide the name of the video file to reference.\n‚Ä¢ Establish a visual design system. This step should be straightforward if you have an existing design system, like a branding style guide or component set. Using or modifying an established system can save time and give you a starting point for adding interactions. However, suppose you don't have one or prefer to create a system just for maps. In that case, you should identify essential elements such as typography, color, iconography, as well as components (e.g., buttons, filters, accordions) and their corresponding states. If you use Figma, take advantage of its text and color styles, variables, and component library to create and publish your assets for easy integration. While it may be tempting to skip this step, creating libraries can save you time for future projects and expedite the design process.\n‚Ä¢ Group key elements of your map by theme or type (e.g., videos, photos). If you use Figma, its section tool can help you categorize the different elements in your map. Make sure that all necessary elements are labeled and easily accessible. If you don‚Äôt use Figma, spend time organizing your file within the capabilities of your chosen software to save you time and energy searching for items.\n‚Ä¢ Create a structure using auto layout. To start creating your map, establish a structure by setting up auto layout frames. These frames will serve as the skeleton of your map and should include headers, swim lanes, quadrants, and other necessary map components. (The components will depend on the type of map you're building.) In this step, try not to focus on adding exact content but on making a flexible structure for that content to live in. Using auto layout ensures that elements snap into place easily and adjust appropriately when content is added. Auto layout is particularly helpful for expandable elements like accordions since it allows elements below the accordion to be pushed below accordion text and not remain in a fixed position. Figma‚Äôs auto layout allows for a page to expand or contract when opening and closing accordions.\n‚Ä¢ Add your actual content. After creating a foundation, add all your content. Include exact text and swap out random placeholder icons for relevant ones. For example, if you used placeholder text that says, ‚ÄúWrite a theme here,‚Äù replace that text with an actual finding, like ‚ÄúDefining parameters for a new plan.‚Äù Similarly, if you were using a random icon to build components, update those placeholders to make them relevant to your map using the Swap Instance feature in Figma. Adding all content before establishing interactions makes it easier to make changes to the map, especially if you need to duplicate pages to get specific interactions to work.\n‚Ä¢ Prototype your desired interactions. With all content ready, switch to Figma‚Äôs prototype mode and connect your interactions. If using a premade design system, some connections might already be made and speed up your process!\n‚Ä¢ Test and troubleshoot. Once satisfied with the visual design and interactions, make sure everything is working properly by testing the map with at least one other person. I recommend testing out interactions as you make them so that you can identify simple mistakes quickly. Doing a final test with someone else before distribution can help catch any last-minute bugs. Naming conventions are important in Figma, so if there are issues with components not working, go back to the base component and check the naming on each state and layer.\n\nAs previously mentioned, building an interactive map from scratch can be time-consuming. But a first map is a great foundation for a template. You‚Äôll have a frame structure already created and you‚Äôll only need to remove the content from your first map. One more thing to add is prototype specifications, so that others understand the parts or limitations of the template. Components and styles for a design system can be published to your team‚Äôs library for easy access later.\n\nEvaluate the pros and cons of creating an interactive UX map to avoid wasted time and to get the most out of your efforts. When incorporating interactions into a map, consider your audience. Make sure that navigation throughout the map will not overwhelm your stakeholders. High-quality interactions can increase stakeholder engagement and make research more accessible.\n\nOur free journey-mapping template is available on the Figma Community."
    },
    {
        "link": "https://help.figma.com/hc/en-us/articles/360040314193-Guide-to-prototyping-in-Figma",
        "document": "Figma‚Äôs prototyping features allow you to create interactive flows that explore how a user may interact with your designs.\n\nPrototypes are a fantastic way to:\n\nWatch our video on prototyping below. Or, check out our Prototype & Collaboration Playlist on Youtube.\n\nWith prototyping in Figma, you can create multiple flows for your prototype in one page to preview a user's full journey and experience through your designs.\n\nA flow is the network of frames and connections in a single page. A prototype can map out a user's entire journey through your app or website, or it can focus on a specific segment of it via its own flow. For example: your prototype covers all possible interactions on an eCommerce site. Within the prototype, you have flows for creating an account, adding items to a cart, and checking out.\n\nFigma creates a flow starting point when you add your first connection between two frames. There are a few other ways to add a flow starting point to your prototype:\n‚Ä¢ With the starting frame selected, click in the Flow starting point section of the right sidebar.\n‚Ä¢ Right-click on the frame, then click Add starting point.\n\nWhen it's time to test your designs, you can share the entire prototype or copy the link to a flow starting point.\n\nLearn more about starting points and flows ‚Üí\n‚Ä¢ Select the hotspot for the connection.\n‚Ä¢ Drag it to the destination.\n‚Ä¢ If there are no existing connections, Figma will make the first frame a starting point.\n‚Ä¢ Open the Prototype tab in the right sidebar\n‚Ä¢ A hotspot is where the Interaction takes place. A hotspot can be any object within the original frame, such as a link, button, image or icon, etc.\n‚Ä¢ Connections are the blue arrows or \"noodles\" that connect the hotspot to the destination. We apply the interaction and animation settings via the connection.\n‚Ä¢ A flow is the network of connected frames that form a path through a prototype. Each flow has its own starting point. You can have multiple flows within a prototype.\n‚Ä¢ The starting point is the first frame of a flow. Set multiple starting points to show different flows of the prototype in Presentation view.\n‚Ä¢ The trigger determines what type of interaction with the hotspot will cause the prototype to advance. This could be a mouse or touch interaction, such as a tap, drag, click, hover, etc.\n‚Ä¢ The destination is where the transition ends. This must be a top-level frame - a frame that is added directly to the canvas - and not an object within a frame. If we think of moving from A to B, A is the hotspot and B is the destination.\n‚Ä¢ The action defines the type of progression is occurring in the prototype. For example, the action could be to navigate to another frame, or open an external URL.\n‚Ä¢ The animation settings determine how the prototype moves from one frame to the other. You can control the type of animation, as well as the speed and direction.\n‚Ä¢ A transition is the type of animation. This defines how the action moves to the destination.\n‚Ä¢ The direction controls the direction that the transition comes from. Choose between left, right, top or bottom.\n‚Ä¢ The duration controls the time it takes to complete the animation. The shorter the duration, the faster the transition. Select a duration between 1ms and 10000ms (10 seconds).\n‚Ä¢ Easing affects the acceleration of the animation whether it starts slow or fast. This allows you to build animations that feel more natural.\n‚Ä¢ Overlays are frames that appear above the current screen or frame. You can use overlays to create tool-tips, interactive menus, alerts, or confirmations.\n‚Ä¢ Overflow behavior allows you to define how your prototype responds to scrolling. This allows you to create more advanced user interactions, such as carousels, galleries, or interactive maps.\n‚Ä¢ Choose which device will be shown when presenting your prototype. Define both the device and the model.\n‚Ä¢ The background color lets you define the color in the background of your prototype.\n‚Ä¢ If you have a prototype with portrait and landscape frames, you can select an orientation. The orientation is set for the entire prototype. It's not possible to switch between portrait and landscape view within a prototype.\n‚Ä¢ A preview will show you how something will look or work in the prototype. We show previews for both animations and prototype device settings."
    },
    {
        "link": "https://medium.com/@darrenvictoria/mastering-figma-prototyping-best-practices-methodologies-and-workarounds-3a4b559ff0d1",
        "document": "Figma has become a go-to tool for UI/UX designers and product teams, thanks to its powerful collaborative design features and ease of use. When it comes to prototyping in Figma, the possibilities are endless ‚Äî from creating simple wireframes to fully interactive, high-fidelity prototypes. Here‚Äôs a comprehensive guide to mastering Figma prototyping, with tips on methodologies, best practices, and workarounds to elevate your design workflow.\n\nBefore diving into Figma, it‚Äôs essential to have a clear understanding of your design goals. What are you trying to achieve with this prototype? Are you validating a user flow, testing interactions, or showcasing a high-fidelity mockup to stakeholders?\n\nLean prototyping focuses on rapid iteration and early user testing to minimize wasted effort. Start with a low-fidelity prototype, focusing on core functionalities. Once you gather feedback, progressively add more details, visuals, and interactions.\n‚Ä¢ Define User Journeys: Identify key user flows to focus on. This makes prototyping more targeted and ensures you address critical areas.\n‚Ä¢ Use Pen and Paper First: Map out complex flows on paper or a whiteboard before recreating them in Figma."
    },
    {
        "link": "https://figma.com/best-practices/components-styles-and-shared-libraries",
        "document": "Two of Figma's most powerful features are components and styles. They let you reuse UI objects and attributes so you can maintain designs systematically at scale. When you need to change something, like your brand‚Äôs link color or home icon, you can make the change once ‚Äî in the original main component or style ‚Äî and watch it update across all your designs.\n\nYou can use components and styles:\n‚Ä¢ Within one individual file in Figma's free tier\n‚Ä¢ Across different files and projects in the Figma Professional tier\n‚Ä¢ Across teams in the Figma Organization tier\n\nThere‚Äôs an endless number of things to consider when creating, naming and managing your components and styles, so we put together a best practice guide to help you out. Grab a cup of coffee and get settled for the 101 masterclass.\n\nA quick note: Before making components in Figma, we recommend figuring out which Figma plan makes the most sense for you. If you're signed up for Figma Organization, read this best practice article on setting up your teams in Figma, because that structure will form the foundation of your component organization.\n\nWhat are components and styles?\n\nIf you already know all the basics of components, styles and libraries, jump to to the next section.\n\nComponents: These are reusable objects in your design. They can be as simple as an individual button, or as complex as an entire navigation header (comprised of instances of other components like logos, avatars, buttons and menu items). You'll discover that components work similarly to \"symbols\" in Sketch or other design tools, but with a few unique differences. More on that in a bit.\n\nHere is a list of common things people turn into components:\n\nComponent Instances: Once you make something a component, you can create instances of it, which are essentially connected copies of that component‚Äîso if you update the design of the original component, the instances will reflect that change. For example, if you change the color of a button component to red, and then publish those changes, any file that used instances of that button will get a notification. They can then choose whether to update their instances to red.\n\nStyles: These are reusable collections of properties which you can easily apply to elements in your design. In Figma, you can create styles for text, colors, grids and effects like shadows and blurs. If components are reusable objects, think of styles as the attributes you might apply to those objects.\n\nLibraries: In Figma, you can share components and styles by publishing them. This turns your file into a library, so you can use instances of those components in other files. Updates to the design of your components can be published and pushed out to other documents where instances of your components live. Users have the choice to accept those updates or continue working with an old version (if required).\n\nWhen to start creating components for design systems\n\nThis question comes up often and the answer varies greatly based on individual designers' workflow preferences. That said, we generally recommend turning things into components fairly early in the design process. Once you have elements repeated across multiple screens, it's a good time to start thinking about components (even if you at fairly low-fidelity stages of your project). The design may change and go through many refinements, but creating components at this stage means you can save time later by making those changes once (with the original component), and having them update across all of your screens (with the instances).\n\nMain components live wherever you create them, usually in context within your design, which makes them easy to tweak as your design progresses (except for bigger companies which house their main components in a separate design system file). If you feel like you're getting hung up on components too early at an exploratory stage of your project, worry about them later‚Äîdon't let it hinder the fluidity of your design process.\n\nAs your team decides to adopt these patterns to reuse them in other products as part of your design system, then you can consider consolidating them from individual project files into a more formal document dedicated to serving as shared library. During that process you may choose to refine their structure/naming/properties so that they are easier to use and consistent with other components. How might you design better components? Let's unpack some considerations and best practices!\n\nWhen you begin creating high-quality components, especially with the intention of sharing them, consider starting with smaller atomic components that can be used as building blocks. You'll notice patterns in your design that you want to be consistent. For example, the shape of a card, or the shape of a button.\n\nA good strategy is to turn these repeated elements into a component that you can reuse by nesting instances of them inside other components. Imagine turning a simple button shape into a component (to be used as an atom), and nesting it within every button component that you create. The result: all buttons use the exact same starting point; if that shape were to change, it can be updated by changing that single atomic component.\n\nContinuing with the button example, let's assume you also have primary and secondary variants, desktop and mobile versions, each with 4 states (normal, disabled, pressed, and focused). You would potentially have 16 different button components that you would otherwise have to edit if you didn't build this in an atomic fashion. Structuring components in this way will make your system much more maintainable.\n\nQuick tip: By prefixing component names with a '_' or a '.', they will be excluded from publishing. Consider which components designers will need to use; they may not need to access all of the smaller atomic components. By excluding these from the publishing process, you can improve the experience for the users of the libraries since you will eliminate these from showing up in the components panel.\n\nAs you're thinking of UI components, you're most likely also considering how to handle related components‚Äîthese could be additional states, themes like light or dark, or other variations. What's the best way to handle them? How will designers interact with them?\n\nWhen you place an instance of a component into your design, Figma gives you access to its layers in the layers panel. This enables you to view and expand each instance in the layers panel. You may consider nesting elements in your component which users can turn on (by toggling the layer visibility) when needed; you could even nest every state within a single component. This method does have some benefits, but also a few drawbacks.\n\nBenefits: There is a single Figma component to share with users. This means one component to maintain, one component for designers to use, and only one to find in the components panel and instance menus.\n\nDrawbacks: This method can make it more difficult for designers for discover the different states within the layer stack of each component. Switching between them can be more cumbersome since designers must know to toggle the appropriate layers within the component. These states are not always immediately apparent unless designers expand the component in the layers panel. This method can also result in a lot of repeated layers within your component. For example, a button comprised of a text box and a rectangle may need to repeat those layers for every state‚Äîwhen users override the text, and later want to show a different variation/state, the designer will need to re-input the override. This use case is handled much smoother with the following approach.\n\nAnother approach, and one that we typically recommend, is to create separate components for each variation or state.\n\nBenefits: With this method, all variations are easily accessible from the components panel and the instance menus; making it easier to find and switch between them. Instead of toggling the right combination of nested layers, designers can simply choose a different related component from the instance menu to switch to. This method can preserve your text overrides when switching instances if the text layers are named the same in both components. This method also tends to be more performant; we've seen some examples of very complex components with hundreds of hidden layers (using the nested approach), that could be greatly simplified using this approach.\n\nDrawbacks: With this method you will ultimately end up with more components to share and maintain. However, if you couple this method with the atomic structure described above, you can build your components in a way that makes them easier to maintain. Lastly, since many visual variations may be very subtle and difficult to discern in a thumbnail preview, consider adding useful descriptions to your components (they will surface as tool tips on hover in the components panel).\n\nThere may also be times when you wish you create variants of components with different visual properties‚Äîfor example: for themes, for light and dark modes, or for different brands. One technique you can use to achieve this is to select an existing component instance, override the visual properties you want to change, and then create a component from it. This will nest an instance of the original component inside a new component. This will preserve the newly applied overrides, but will still maintain a connection with the original component‚Äîthis makes the design easier to maintain since you only have to adjust the design in one place. The image below highlights a couple potential use cases.\n\nNow that you're familiar with a couple of baseline approaches, let's discuss a few best practices for making these components easier to use and maintain.\n\nWhen creating your component variations/states as separate components, you'll want to preserve your text overrides if you plan on swapping between them‚Äîthis way you don't have to re-input the text. To ensure that your text is maintained during this swap, make sure the text layers within each component are renamed to be the same as each other (since by default, the layer name will inherit whatever you initially type into the text box).\n\nYou can add a description to each main component in the properties sidebar. These descriptions show up as tool tips on hover in the components panel. This is also a good place to include info about their intended usage to help users pick the right components.\n\nTake the time to setup proper constraints to ensure predictable and intended behavior when components are resized. Since components function the same way as frames, you can add layout grids within your components and even apply constraints to elements that are relative to the grid. They can also be used to help visualize margins or padding within your component.\n\nYou can toggle the clip content checkbox in the properties panel to define whether or not elements which extend outside the bounds of the frame are cropped/hidden. This feature can be really useful if you have components with repeated elements that you may want to reveal when resized. For example, the number of rows in a table might vary from use case to use case‚Äîwith this method you can simply resize the component to reveal the number of rows you need. Make sure you setup constraints for all of the elements within your component first!\n\nYou can also include styles like colors and text styles in your shared libraries‚Äîthey are much simpler to create, but there are still some best practices that will make using them easier.\n\nText styles: Figma has decoupled properties like alignment and color from being included in the style, so you won't need to create a separate unconnected text style for every color or justification. This results in fewer styles, making them easier to manage. Many users will have two sets of type styles which include a type ramp for mobile and another for desktop.\n\nColor styles: Make sure you have styles created for all of your documented colors in your design system, and name them appropriately so they are easy to identity, use and implement.\n\nEffect styles: Effect styles allow you to consistently reuse effects like layer blurs, background blurs, drop shadows, and inner shadows. For example: the Material design system includes an entire set of drop shadows to coincide with different layers that are stacked in the UI‚Äîshadows are repeatedly used used to create the effect of different \"elevations\" tied to certain elements like modals and buttons.\n\nGrid styles: Often overlooked, grid styles can help standardize layout grids across multiple projects and viewports. If you have specific grids you use from desktop down to mobile phones, consider defining grid styles so they can be easily shared.\n\nStyle names: Style names are critical for alignment with predefined properties in your design system. You can also use prefixes separated by a forward slash in the names to group styles in the style picker (note: you can only add one level of hierarchy). For example, if you add \"Alerts/\" before several styles, they will all appear together under the subheading \"Alerts\". You might use these prefixes to:\n\nStyle descriptions: Add descriptions to your styles‚Äîthese will appear in tooltips in much the same way they do for components. The descriptions can help clarify their intended usage by surfacing additional information to help designers select the right style.\n\nNote: when developers are inspecting your designs, in the code panel, style names will show up as comments in CSS mode and as a line item in table view. The names of color, type, and effect styles will be displayed in addition to their attributes.\n\nImage fills for Placeholder images: You can create styles for image fills. Lets say you have some user avatars, or placeholder photos you commonly use. You may not know what shape, aspect ratio, or size they will need to be applied to. By creating image fills, you can easily apply them to any shape.\n\nLayout grids for visualizing spacing: You can create grid styles which are comprised of multiple layout grids. For example, a column and a row grid can be applied to a frame or component to help visualize margins or padding. These can be very useful for teams that have defined standardized spacing as part of their system.\n\nTo create your first library, publish any Figma document from the Team Library modal. All of the main components and styles in this document will then become available to use in other documents. As you scale design across products or teams, especially in larger organizations, you'll want to figure out the best way to organize and distribute them for everyone to use. How many libraries should you create? How do I organize my components? Remember, the designers consuming these libraries are your end users.\n\nWe often get asked if teams should share everything from a single library or use multiple libraries. Of course the answer is, it depends! Let's look at some of the factors to consider.\n\nEverything in one big library\n\nSome teams, particularly smaller ones, will often create a single library to house all of their components and styles for the sake of simplicity. This approach has some benefits but a few big drawbacks as you scale.\n\nBenefits: There is only one library for users to enable that has everything they need. There is never any confusion as to where particular components live. This also means there is only one library to maintain.\n\nDrawbacks: For larger organizations with a lot of components and styles required to support many different platforms and products, this library can grow very quickly. If users only need a small selection of those components, they'll still have to sift through a lot of similar components they never need to use.\n\nMany teams, especially medium-large teams, often decide the best approach is to break up their components into multiple libraries. This tends to scale much better.\n\nBenefits: By separating components/styles into different documents/libraries, only the required libraries can be enabled for the right subset of users or teams. For example, let's say you have dedicated teams working on only mobile products. Those working on mobile may never have to consume assets designed for desktop. By splitting these into separate documents, you can publish them to separate libraries. Then, designers will only need to enable the applicable library for them, which saves them from having to sift through components they don't need to use.\n\nDrawbacks: For those responsible for maintaining and publishing the libraries, there will be more of them to manage.\n\nOptimizing for success: Libraries can be enabled by default for Pro teams, or across all teams in the entire company in Figma Organization. To learn more about how you might approach this, be sure to read our post on structuring teams.\n\nThe next level of library organization takes place inside each library itself. Within a document you have the ability to organize the master components in a number of ways, from naming schemes to pages and frames. You can even combine these methods in conjunction with one another.\n\nThe first and most common way to group components is with forward slash component names to organize them into a hierarchy. If you're coming from Sketch, you may already be familiar with this method. Let's say you had primary and secondary buttons with variations of each. You may choose to name them as such:\n\nBenefits: This method is the fastest way to organize your components. Simply rename the components, and they will get organized into a hierarchy in your instance menus.\n\nDrawbacks: While this method is a quick way to organize your components, it can result in long component names for larger systems. It is not uncommon for component names to exceed the width of your layers panel, making it more cumbersome to scan and parse the layers panel. If you are migrating from Sketch, there is nothing wrong with this method, and it will help you get up and running faster; however, if you intend to spend a bit more time laying out master components and want to include some additional information alongside them, the next method may be a better approach.\n\nOur recommended method to organize components, is to use pages and frames as organizing containers.\n\nBenefits: This method allows you to decouple organization from the your component naming scheme. This results in shorter component names that are easier to scan in the layers panel, and i will allow you to use a naming scheme which is closer to your system's code base.\n\nFor example, you might have a page called \"Buttons\", and on it a dedicated frame for each type of button (\"Primary\" and \"Secondary\") where those master components reside. This will improve the experience when navigating the thumbnails in the components panel. Page names will appear as top level headings, and frame names will appear as collapsible subheads with all the components that reside within that frame below.\n\nThis feature compliments the way many users were already starting to visually organize their library by laying out accompanying notes, annotations, proper and improper usage examples and other usage documentation alongside the master components. This way users have the ability to right click on any component instance in their document and choose \"Go to Master Component\", which will open the library document. Here they can view this additional information which may help them use the components in the way they were intended.\n\nIn addition, components which reside in the same containing frame are treated as related components. When you click on an instance of one of these components, the list of related ones will surface to the top level of the instance menu to make swapping between them easier. This means you don't have to hunt through the full instance menu to choose the right component.\n\nIf you require additional levels to your component hierarchy, you can still use this method and combine it with the forward slashes. If you add forward slashes, Figma will revert back to your naming scheme to determine the list of related components for subsequent levels.\n\nQuick tip: If you are moving from an existing or imported Sketch library that is using the forward slash method of organization, and want to switch to the pages and frames approach, you can use Figma's batch renaming feature to speed up this transition. To do this, simply select the components you wish to rename, and choose Rename from the context menu, or press cmd + R (Mac), ctrl + R (Win). Within this renaming dialog, you can even use Javascript regular expressions to remove any prefixing and forward slashes.\n\nWhile there are many ways to build and organize your shared libraries, we hope this guide gave you some ideas on how to accomplish this in the way that's most appropriate for your team or organization. If we've learned one thing from our users who build design systems, it's this: Never lose sight of the end user who ultimately consumes the system you create. Make sure the right libraries are enabled for them, and that components are easy to use, find, and understand. Accomplish that, and you'll make huge strides towards achieving greater consistency across your organization's design work."
    },
    {
        "link": "https://media.nngroup.com/media/articles/attachments/steps_to_building_interactive_ux_maps.pdf",
        "document": ""
    }
]