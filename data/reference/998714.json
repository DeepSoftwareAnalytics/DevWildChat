[
    {
        "link": "https://w3schools.com/sql/sql_union.asp",
        "document": "The operator is used to combine the result-set of two or more statements.\n• Every statement within must have the same number of columns\n• The columns must also have similar data types\n• The columns in every statement must also be in the same order\n\nThe operator selects only distinct values by default. To allow duplicate values, use :\n\nNote: The column names in the result-set are usually equal to the column names in the first statement.\n\nIn this tutorial we will use the well-known Northwind sample database.\n\nBelow is a selection from the \"Customers\" table:\n\nAnd a selection from the \"Suppliers\" table:\n\nThe following SQL statement returns the cities (only distinct values) from both the \"Customers\" and the \"Suppliers\" table:\n\nNote: If some customers or suppliers have the same city, each city will only be listed once, because selects only distinct values. Use to also select duplicate values!\n\nThe following SQL statement returns the cities (duplicate values also) from both the \"Customers\" and the \"Suppliers\" table:\n\nThe following SQL statement returns the German cities (only distinct values) from both the \"Customers\" and the \"Suppliers\" table:\n\nSQL UNION ALL With WHERE\n\nThe following SQL statement returns the German cities (duplicate values also) from both the \"Customers\" and the \"Suppliers\" table:\n\nThe following SQL statement lists all customers and suppliers:\n\nNotice the \"AS Type\" above - it is an alias. SQL Aliases are used to give a table or a column a temporary name. An alias only exists for the duration of the query. So, here we have created a temporary column named \"Type\", that list whether the contact person is a \"Customer\" or a \"Supplier\"."
    },
    {
        "link": "https://stackoverflow.com/questions/4288240/union-all-with-if-else-t-sql",
        "document": "Well one way to do it is use dynamic sql\n\nfirst build the query string and then execute it. That way you have full control"
    },
    {
        "link": "https://asktom.oracle.com/ords/f?p=100:11:::::P11_QUESTION_ID:9537853100346419679",
        "document": "I have a bind variable that, if set to one value, the union query should execute the first part of the union. If the bind variable is set to a second value, then the second part of the union query should be executed.\n\n\n\n \n\n\n\nHowever, when I look at trace and/or explain plans for my query, there is a cost coming from BOTH parts of the union query.\n\n\n\n \n\n\n\nHere is a simplified version of what I am trying to do :\n\n\n\n \n\n create table t1 as select 'T1' as ttype, 'Gadget 1' as descr from dual union all select 'T2' as ttype, 'Gadget 2' as descr from dual union all select 'T3' as ttype, 'Gadget 3' as descr from dual; create table t2 as select 'T21' as ttype, 'Widget 1' as descr from dual union all select 'T22' as ttype, 'Widget 2' as descr from dual union all select 'T23' as ttype, 'Widget 3' as descr from dual; 3' as ttype, 'Widget 3' as descr from dual; \n\n \n\n\n\nAnd then my query is :\n\n\n\n \n\n select ttype, descr from t1 where :P_Type='1' union all select ttype, descr from t2 where :P_Type='2'; \n\n \n\n\n\nI would expect that if I provide bind value of '1' for P_Type, then the CBO / query would only actually access table t1 (with zero cardinality / cost for table t2).\n\n\n\n \n\n\n\nHowever, what I see is a cost & cardinality coming from BOTH tables, regardless of the value I assign to the bind variable\n\n\n\n \n\n\n\nHow can I force the CBO / database to \"prune\" those parts of the query where the condition / bind value indicates that part of the union query is irrelevant ?\n\n\n\n \n\n\n\nI do not want to split it into two different queries, as there is a lot of formatting on the report, which I would need to replicate for the two queries.\n\n\n\n \n\n\n\nMany thanks in advance for your feedback ...\n\n\n\n \n\n\n\nOracle Database Enterprise Edition 12.1.0.2 with SQL Tuning option \n\n I have have two complex, expensive queries that I have performed a union all to bring together for use in a report toolI have a bind variable that, if set to one value, the union query should execute the first part of the union. If the bind variable is set to a second value, then the second part of the union query should be executed.However, when I look at trace and/or explain plans for my query, there is a cost coming from BOTH parts of the union query.Here is a simplified version of what I am trying to do :And then my query is :I would expect that if I provide bind value of '1' for P_Type, then the CBO / query would only actually access table t1 (with zero cardinality / cost for table t2).However, what I see is a cost & cardinality coming from BOTH tables, regardless of the value I assign to the bind variableHow can I force the CBO / database to \"prune\" those parts of the query where the condition / bind value indicates that part of the union query is irrelevant ?I do not want to split it into two different queries, as there is a lot of formatting on the report, which I would need to replicate for the two queries.Many thanks in advance for your feedback ...Oracle Database Enterprise Edition 12.1.0.2 with SQL Tuning option\n\nestimated rows in the explain plan, or the actual rows in an execution plan?\n\n\n\nRemember that explain plan costs and cardinalities are estimates. These are generated with no knowledge of what the bind values are. \n\n\n\nBind variable peeking allows the optimizer to adapt the plan based on the inputs. But in this case it doesn't matter. The plan is the same whatever value you assign to :P_Type. \n\n\n\nFor example, in the execution plan below, notice how starts and A-rows are both zero for T2.\n\n\n\nThe filter operations at steps 2 & 4 short-circuit processing. The database only does the full scans below them if the condition is true:\n\n\n\n create table t1 as select 'T1' as ttype, 'Gadget 1' as descr from dual union all select 'T2' as ttype, 'Gadget 2' as descr from dual union all select 'T3' as ttype, 'Gadget 3' as descr from dual; create table t2 as select 'T21' as ttype, 'Widget 1' as descr from dual union all select 'T22' as ttype, 'Widget 2' as descr from dual union all select 'T23' as ttype, 'Widget 3' as descr from dual; set serveroutput off var p_type varchar2(1); exec :p_type := '1'; select /*+ gather_plan_statistics */ttype, descr from t1 where :P_Type='1' union all select ttype, descr from t2 where :P_Type='2'; select * from table(dbms_xplan.display_cursor(null, null, 'ROWSTATS LAST +COST')); ---------------------------------------------------------------------------- | Id | Operation | Name | Starts | E-Rows | Cost (%CPU)| A-Rows | ---------------------------------------------------------------------------- | 0 | SELECT STATEMENT | | 1 | | 4 (100)| 3 | | 1 | UNION-ALL | | 1 | | | 3 | |* 2 | FILTER | | 1 | | | 3 | | 3 | TABLE ACCESS FULL| T1 | 1 | 3 | 2 (0)| 3 | |* 4 | FILTER | | 1 | | | 0 | | 5 | TABLE ACCESS FULL| T2 | 0 | 3 | 2 (0)| 0 | ---------------------------------------------------------------------------- Predicate Information (identified by operation id): --------------------------------------------------- 2 - filter(:P_TYPE='1') 4 - filter(:P_TYPE='2') \n\n\n\nSo it has pruned the execution of the query!\n\n\n\nRemember: to evaluate a plan, you must look at the actual work it does. \n\n Are you looking at therows in theplan, or therows in anplan?Remember that explain plan costs and cardinalities are estimates. These are generated with no knowledge of what the bind values are.Bind variable peeking allows the optimizer to adapt the plan based on the inputs. But in this case it doesn't matter. The plan is the same whatever value you assign to :P_Type.For example, in the execution plan below, notice how starts and A-rows are both zero for T2.The filter operations at steps 2 & 4 short-circuit processing. The database only does the full scans below them if the condition is true:So it has pruned the execution of the query!Remember: to evaluate a plan, you must look at the actual work it does.\n\nIs this answer out of date? If it is, please let us know via a Comment"
    },
    {
        "link": "https://stackoverflow.com/questions/71744306/union-and-select-based-on-conditions",
        "document": "I want to do a union of these two tables by selecting some common columns in the them.\n\nBelow are the things I want to satisfy while doing the union."
    },
    {
        "link": "https://sqlshack.com/sql-union-overview-usage-and-examples",
        "document": "This article will provide a deep dive into the SQL Union operator, describing its many uses along with examples and explore some common questions like the differences between Union vs Union All.\n\nTo address real-world data requirements, we may need to combine result sets from multiple data sources so that we could do data analysis or create new datasets. The datasets may be identical but there are chances that they reference different tables. Is there a way to combine the data in a single query? Are Set Operators a viable option? Let’s get started and see how some of the existing operators can be used to help us address these common challenges.\n• Union vs Union All and how they work\n• Discuss the rules for using Union vs Union All\n• How to use simple SQL Union clause in the select statement\n• How to use SQL Union with the queries that have the WHERE clause\n• How to use the SELECT INTO clause with Union\n• How to use SQL Union with the queries that have a WHERE clause and order by clause\n• How to use SQL Union and SQL Pivot\n• How to use SQL Union with GROUP and HAVING clauses\n\nAn operator is a symbol or a keyword defines an action that is performed on one or more expressions in the Select statement.\n\nLet’s get into the details of Set Operators in SQL Server, and how to use them\n\nThere are four basic Set Operators in SQL Server:\n\nThe Union operator combines the results of two or more queries into a distinct single result set that includes all the rows that belong to all queries in the Union. In this operation, it combines two more queries and removes the duplicates.\n\nFor example, the table ‘A’ has 1,2, and 3 and the table ‘B’ has 3,4,5.\n\nThe SQL equivalent of the above data is given below\n\nIn the output, you can see a distinct list of the records from the two result sets\n\nWhen looking at Union vs Union All we find they are quite similar, but they have some important differences from a performance results perspective.\n\nThe Union operator combines the results of two or more queries into a single result set that includes all the rows that belong to all queries in the Union. In simple terms, it combines the two or more row sets and keeps duplicates.\n\nFor example, the table ‘A’ has 1,2, and 3 and the table ‘B’ has 3,4,5.\n\nThe SQL equivalent of the above data is given below\n\nIn the output, you can see all the rows that include repeating records as well.\n\nThe interest operator keeps the rows that are common to all the queries\n\nFor the same dataset from the aforementioned example, the intersect operator output is given below\n\nThe SQL Representation of the above tables\n\nThe row ‘3’ is common between the two result sets.\n\nThe EXCEPT operator lists the rows in the first that are not in the second.\n\nFor the same dataset from the aforementioned example, the Except operator output is given below\n\nThe SQL representation of the above tables with EXCEPT operator is given below\n\nList the non-common rows from the first set.\n\nNote: It is very easy to visualize a set operator using a Venn diagram, where each of the tables is represented by intersecting shapes. The intersections of the shapes, where the tables overlap, are the rows where a condition is met.\n\nThe syntax for the Union vs Union All operators in SQL is as follows:\n\nSELECT Column1, Column2, … ColumnN\n\n FROM <table>\n\n [WHERE conditions]\n\n [GROUP BY Column(s]]\n\n [HAVING condition(s)]\n\n UNION\n\n SELECT Column1, Column2, … ColumnN\n\n FROM table\n\n [WHERE condition(s)];\n\n ORDER BY Column1,Column2…\n\nThere are a few rules that apply to all set operators:\n• Expressions in each row or the number of columns that are defined in each query must have the same order\n• Subsequent SQL statement row sets must match the data type of the first query\n• Parentheses are allowed to construct other set operators in the same statement\n• It possible to have an ORDER BY clause, but that should be the last statement of the SQL\n• GROUP BY and HAVING clauses can be applied to the individual query\n• All of these Set operators remove duplicates, except for the Union All operator\n• The output column names are referred from the first query i.e. when we run the SELECT statements with any of the Set operators and result set of each of the queries may have different column names, so the result of the SELECT statement refers the column names from the first query in the operation.\n• SQL JOIN is more often used combine columns from multiple related tables whereas SET Operators combines rows from multiple tables.\n• When the expression types are the same but differ in precision, scale, or length, the result is determined based on the same rules for combining expressions\n\nThe following T-SQL queries are prepared and run against the Adventureworks2014 database. You can download the sample AdventireWorks2014 database here\n• None How to use simple SQL Union clause in select statement In this example, the result set includes a distinct set of rows from the first set and second set.The following example is based on the rule 1, 3 & 5. The output is a combination of Union and Union All operators using parenthesis.\n• None How to use SQL Union with the queries that have the WHERE clause The following example shows the use of Union in two SELECT statements with a WHERE clause and ORDER BY clause. The following example is based on the rule 1,2 and 3\n• None How to use SELECT INTO clause with SQL Union The following example creates a new dbo.dummy table using the INTO clause in the first SELECT statement which holds the final result set of the Union of the columns ProductModel and name from two different result sets. In this case, it is derived from the same table but in a real-world situation, this can also be two different tables. The following example is based on the rule 1 , 2 and 4.\n• None How to use SQL Union with the queries that have a WHERE clause and ORDER BY clause This is only possible when we use TOP or aggregate functions in every select statement of the Union operator. In this case, top 10 rows are listed from each result set and combined the rows using Union clause to get a final result. You also see that the order by clause is placed in all the select statement.\n• None How to use of SQL Union and SQL Pivot In the following example, we’re trying to combine more than one set of results. In a real-world situation, you may have financial numbers from various regions or departments and the tables might have the same columns and data types, but you want to put them in one set of rows and in a single report. In such a scenario, you would use the Union clause and it is very easy to combine results and transform the data into a more meaningful report. In this example, the ProductModel is categorized into Top10, Top100, Top 100 and transforming the rows as an aggregated set of the values into the respective columns. The following example is based on the rule 2. NULL values are very important with the Set Operators and are treated as second-class database citizens. Because NULLs are considered unique and if two rows have a NULL in the same column, then they would be considered identical, so in that case, you are actually comparing a NULL to a NULL and getting equality. In the following example, you see the use of NULL values. In this case, it is operated with the aggregate function, max. \n\n\n\nHow to use SQL Union with Group and Having clauses\n\nThe following examples use the Union operator to combine the result of the table that all have the conditional clause defined using Group by and Having clause.\n\nThe lastname is parsed by specifying the conditions in the having clause.\n\nThe following example is based on rule 5.\n\nWe can see that the last names are derived into two different columns using the Union operator\n\nThus far, we addressed various available options and rules to use Set operators and understand when to use them. When determining whether to use Union vs Union All there are a few points to consider. Use Union All if you know that the result sets from multiple queries don’t overlap or generate duplicates and remember, if you need to use parentheses, you can do that. You can also pivot and transform the output.\n\nJust make sure your data types match up and if you need to do an ORDER BY, do it at the end after you’ve run all those set queries. By nature, when it comes to Union vs Union All, Union All is faster than Union; as Union operators incur additional overhead to eliminate duplicates.\n\nI hope you enjoyed this article on the SQL Union operator. Feel free to ask any questions in the comments below."
    },
    {
        "link": "https://stackoverflow.com/questions/554509/sql-improve-not-exists-query-performance",
        "document": "Is there a way I can improve this kind of SQL query performance:\n\nThe problem is when I have many data in my table (like million of rows), the execution of the clause if very slow. I have to do this verification because I can't insert duplicated data."
    },
    {
        "link": "https://sqland.wordpress.com/2022/09/22/in-vs-not-in-vs-exists-vs-not-exists-performance-considerations",
        "document": "I’ve often been asked about these operators in terms of performance, like “which is best?” I guess I could say “well, it depends…” as in so many cases. In this post I’ve decided to demonstrate some factors upon which it actually depends that may not be of common knowledge, so if you are one of those who is curious about this question, read on and enjoy the ride 🙂\n\nI’m using SQL Server 2019 in all the demos below and the queries will be made over two simple tables, one is called tb_countries and the other is called tb_regions:\n\nThere are no indexes, no PKs and no FKs in these tables.\n\nI will now run a simple query using the IN operator:\n\nLet’s see what we got:\n\nThis was fast! Let’s take a quick look at the execution plan:\n\nTable scans are exactly what we would expect, since there are no indexes, however the tb_regions table has more than 4 Million rows, so how come we have only 15 rows Read (out of 4.350.530) in the table scan? Well, taking a look at the query, it is searching for “Portugal” and there is only one country with that name, so there is just one value of cty_id to look for in table tb_regions, in this case it’s the value 7. If there is at least one occurrence of cty_id = 7 in the tb_regions table then it can return immediately after finding the first one (not needing to scan the entire table) and that’s what happened here. There was an occurrence of “cty_id = 7” on the first data page in row number 15, so the scan stopped here, contributing to a much faster execution, isn’t this great? I Know what you’re thinking, “Is there a way to confirm this?” Yes! let’s do it just for fun 🙂\n\nI’ll use the DBCC IND command to get the data pages that belong to the tb_regions table. After that I’ll use DBCC PAGE to look inside the first data page, particularly in slot 14 (it starts on slot 0, so row 15 will be in slot 14)\n\nOk, the first data page for the table is the page number 267064. Let’s look inside it:\n\nKnowing it starts on 0, let’s scroll a bit until we get to slot 14:\n\nThere it is, cty_id = 7 on row 15 of the table, hence no need to continue the search and that is why we come up with only 15 rows Read from the table in this particular query 🙂\n\nGreat, now the next question is “what about the EXISTS operator?”. Let’s find out:\n\nYep, we get the same behavior here.\n\nIt was fast and the good news are that the “Number of Rows Read” remained 15 (for the reason explained above).\n\nYeah, it was fast… but wait a minute, this one took 426 milliseconds while the previous ones ran in around 28 ms, now that’s 15 times slower! Wow, what happened here?! Let’s see the execution plan:\n\nOh boy, there are two Table Scans for table tb_regions here and one of them is huge, all the 4.350.530 rows were actually read! This is bad and it’s why the performance of “NOT IN” was much worse than using “NOT EXISTS”!\n\nDoes this mean that “NOT IN” is worse than “NOT EXISTS” in terms of performance? In this example it sure was but actually it depends… on what?! Ok, did you notice the predicate in the image above (inside the red rectangle) “…cty_id IS NULL”. Now where does that come from? I didn’t write any NULL in the query right? Ok, now get ready for the big revelation, let’s have a look at the table structure:\n\nWe can see that column cty_id accepts NULLs although there are no NULL values in it for the moment. Now I know that “NOT IN” has a “special” way of dealing with NULL values, I even wrote a post about it some time ago, you can find it here. Could this be the cause for this behavior? It’s easy to find out, I’ll change the nullable setting for column cty_id in tb_regions table and then I’ll run the query again, let’s see how that works for us:\n\nAt this moment the column does not accept NULLs anymore, so I’ll re-execute the same query:\n\nThe same we had with “NOT EXISTS”! Pretty awesome right?\n\nSo bear this in mind, there are “external” factors that can greatly influence the “NOT IN” behavior. Having this said, many times we cannot change the table structure, because it is just as it should be or there are no permissions, etc. so in those cases you should avoid the use of “NOT IN” and go with other options such as “NOT EXISTS” (or “OUTER JOINs”, not covered here).\n\nSorry, what are you saying? Oh yes, writing T-SQL queries is much more intuitive and easy when using “NOT IN”. Well, I’m not sure I agree with this myself but I’ve heard it many times over the years and I understand it. If that is your case, you can try some alternatives while keeping the “NOT INs” and see how it works for you, for example creating an index on the column might help, turning table scans into index seeks:\n\nIf NULL values are nonexistent or can be ignored you could even enhance the query with just a little change, by adding a WHERE clause like this:\n\nOn the other hand, if NULL values exist and cannot be discarded and the index created in your table for that particular column is not preventing the huge table scans then I would strongly advise you to stop using “NOT IN” and use the other options as mentioned above.\n\nNow if this is the point when you’re gonna start to cry because you really don’t want to stop using “NOT IN” (for whatever reason) maybe you can try something like this:\n\nBy adding the ISNULL function around the columns (carefully choosing a value that would not be possible to exist in the table for those columns, in this case I chose 0) , the huge table scan for the Predicate “…cty_id IS NULL” simply goes away, yeah!\n\nBut bear in mind that using the ISNULL function around the columns will prevent index seeks from happening (in case a suitable index would exist).\n\nI would truly prefer to rewrite the entire code in this situation and replace the “NOT IN” operator by another option but I know that sometimes it’s not easy or feasible to do it, sometimes you’re not even allowed to do code refactoring if it is considered to involve “major” changes/”risks”. So if you ever face this situation, perhaps this can help you mitigate the problem a little bit 🙂\n\nI Hope you can find this useful, Cheers!"
    },
    {
        "link": "https://stackoverflow.com/questions/10432883/best-way-to-tune-not-exists-in-sql-queries",
        "document": "I am trying to tune SQLs which have NOT EXISTS clause in the queries.My database is Netezza.I tried replacing NOT EXISTS with NOT IN and looked at the query plans.Both are looking similar in execution times.Can someone help me regarding this?I am trying to tune some SQL queries.Thanks in advance."
    },
    {
        "link": "https://medium.com/womenintechnology/optimizing-sql-query-performance-a-comprehensive-guide-6cb72b9f52ef",
        "document": "One key technique for speeding up queries is indexing. Essentially, indexing helps speed up the process of finding and accessing data in a database. It’s like a quick reference guide that allows for faster searches. But it’s important to use indexing wisely because while it can make data retrieval faster, it also comes with extra work, especially when data changes often. Using indexing smartly can significantly boost the speed of queries, as it helps the database system to find and fetch data much quicker. This creates an index on the column of the table, speeding up queries searching by customer name.\n\nUse EXISTS Instead of IN When checking if a value is part of a smaller group, using EXISTS is usually faster than IN. This is because EXISTS lets the database stop looking the moment it finds a matching record, while IN may require going through the whole dataset to gather the smaller group for comparison. In simpler terms, EXISTS speeds things up by ending the search as soon as it finds what it’s looking for. SELECT * FROM orders o WHERE EXISTS (SELECT 1 FROM customers c WHERE c.id = o.customer_id AND c.active = TRUE); This query retrieves orders only for active customers, using for efficient existence checking.\n\nHow can I speed up a slow-running SQL query? Start by analyzing the query execution plan to identify bottlenecks. Use indexes effectively, avoid using SELECT *, limit the use of JOINs by only fetching necessary data, and consider using WHERE clauses to filter rows early. Why is my query with JOIN operations slow, and how can I improve it? Queries with JOINs can be slow if they’re not using indexes efficiently or if they’re joining large datasets. To improve performance, ensure that the columns used for joining are indexed. Also, consider whether you can limit the datasets being joined with WHERE clauses before the JOIN. What is the impact of using SELECT * in my queries? Using SELECT * can negatively impact performance because it retrieves all columns from the table, including those not needed for your specific operation. This increases the amount of data processed and transferred. Specify only the necessary columns in your SELECT clause. Indexes improve query performance by allowing the database engine to find data without scanning the entire table. They are especially beneficial for queries with WHERE clauses, JOIN operations, and ORDER BY statements. However, keep in mind that excessive indexing can slow down write operations. Yes, in some cases, using temporary tables to store intermediate results can simplify complex queries and improve performance. This is particularly useful for breaking down complex calculations or when working with multiple subqueries. What is the difference between using IN and EXISTS, and which is faster? EXISTS can be faster than IN in many cases because EXISTS stops processing as soon as it finds a match, whereas IN might scan the entire dataset. Use EXISTS for subquery conditions where you’re checking for the existence of a record. How can I optimize a query that uses a lot of subqueries? Consider replacing some subqueries with JOINs or using temporary tables to hold intermediate results. This can reduce the complexity of the query and potentially improve performance. What are some best practices for writing efficient SQL queries? Some best practices include using indexes wisely, avoiding unnecessary columns in the SELECT clause, filtering data early with WHERE clauses, and preferring set-based operations over loops. Regularly review and refactor your queries for performance improvements. How does pagination affect SQL query performance, and how can I optimize it? Pagination can affect performance by requiring the database to process large amounts of data for each page request. To optimize, use LIMIT and OFFSET clauses wisely, and consider caching page results for frequently accessed pages. Why is my query with a lot of OR conditions slow, and how can I optimize it? Queries with many OR conditions can be slow because they require the database to evaluate multiple conditions, which can be inefficient. Consider restructuring your query to minimize the use of OR or using UNION to combine the results of simpler queries."
    },
    {
        "link": "https://dba.stackexchange.com/questions/337555/how-does-different-forms-of-exists-affect-performance-in-ms-sql-server",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    }
]