[
    {
        "link": "https://reddit.com/r/Python/comments/w4hxly/i_learned_how_to_code_grid_based_movement",
        "document": "Title is self explanatory. This is a program where you can move in a grid with tile based movement by using the arrow keys. I also learned how to draw a basic grid with code, that'll definitely be useful in the future. I guess it's way easier than making a grid image myself. Also, the console prints your current grid position.\n\nYou're free to use this as a reference or as foundation for your own projects."
    },
    {
        "link": "https://medium.com/@ziad.francis/grid-trading-with-python-a-simple-and-profitable-algorithmic-strategy-820410698516",
        "document": "Welcome to today’s article, where we’ll explore the grid trading strategy — a straightforward yet effective approach that doesn’t rely on technical indicators to determine trends. This strategy is a great candidate for algorithmic trading, and our backtest using Python demonstrates a steady equity increase over two months of data on a 5-minute timeframe. The results are curiously good, with a Sharpe Ratio of almost 5.7. If you prefer visual support and detailed explanation check my YouTube link where I also provided a download link for the Jupyter notebook file I used for the backtest:\n\nIf you like learning algorithmic trading from video lessons check these 2 discount vouchers:\n\nGrid trading involves creating a grid of values on a price chart. Every time the price crosses a grid line, we open both a long and a short position simultaneously. The take profit for each opened position is set at the next grid line. This strategy thrives in markets with frequent price oscillations, making it particularly suitable for lower timeframes.\n\nNow we will implement a grid strategy in python and backtest it on historical data.\n\nTo begin, we need to set up our Python environment by importing the necessary libraries and downloading the dataset. We’ll use to fetch the EUR/USD exchange rate data, for data manipulation, for numerical operations, and for technical analysis indicators.\n\nWe use to download EUR/USD exchange rate data from November 19, 2022, to January 16, 2023, with a 5-minute interval. This provides us with a detailed and high-frequency dataset suitable for our grid trading strategy.\n\nIn this step, we create a grid of values that will determine our entry and exit points. The grid is a series of horizontal lines spaced at regular intervals on the price chart. Each time the price crosses a grid line, we will open a new position.\n• : This defines the distance between each grid line. It represents the price increment at which we will open new positions.\n• : This is the central price around which the grid is created. It can be set to the current market price or any other reference price.\n• The function creates a range of values from to , spaced by .\n• : This determines the total range of the grid above and below the midprice.\n\nThe array contains all the price levels at which we will consider opening positions. This forms the backbone of our grid trading strategy, allowing us to systematically enter and exit trades as the price moves.\n\nIn this step, we generate trading signals based on the grid we created. A trading signal is generated whenever the price crosses a grid line. This is done by iterating over each row in our dataset and checking if the high or low price for that interval crosses any of the grid lines.\n\n: We create a list of zeros with the same length as our dataset. This list will store our trading signals.\n\nWe iterate over each row in the dataset using .\n\nFor each row, we check if the price crosses any of the grid lines. This is done by comparing the minimum and maximum of the row’s high and low prices to each grid line.\n\nIf a grid line is crossed (i.e., the minimum price is below the grid line and the maximum price is above it), we set the corresponding entry in the list to 1.\n\nThis indicates that a trading signal is generated at that time interval.\n• : We add the signal list as a new column to our DataFrame.\n• : This filters the DataFrame to show only the rows where a trading signal is generated.\n\nBy generating these trading signals, we identify the exact points in time when the price crosses a grid line, indicating potential trade entries. This systematic approach ensures that we capture all relevant price movements within our defined grid.\n\nIn this step, we prepare our dataset for backtesting by calculating the Average True Range (ATR) and defining the signal function. The ATR is a volatility indicator that helps us set dynamic stop-loss and take-profit levels.\n\n: We create a copy of our original dataset to avoid modifying it directly during the backtesting process. This ensures that our original data remains intact.\n\n: This function returns the signal column from our DataFrame. It will be used during backtesting to access the generated trading signals.\n\n: We calculate the ATR using a period of 16 intervals. The ATR is a measure of market volatility and helps in setting appropriate stop-loss and take-profit levels.\n\n: These parameters specify the high, low, and close prices used to calculate the ATR.\n\n: We remove any rows with missing values to ensure the integrity of our backtesting process. This step is crucial for accurate and reliable backtesting results.\n\nThe ATR provides a dynamic measure of volatility. By calculating the ATR and defining the signal function, we equip our backtesting framework with the necessary tools to evaluate the grid trading strategy’s performance.\n\nIn this step, we implement our trading strategy using the library and run a backtest to evaluate its performance. We define a custom strategy class and configure the backtest parameters.\n\n: Import the necessary classes from the library to define and run our strategy.\n\n: We create a custom strategy class by inheriting from the class.\n\n: Define the position size for each trade.\n\n: Access the trading signals using the function defined earlier.\n\n: Calculate the stop loss distance based on the grid distance.\n\n: Set the take profit to stop loss ratio.\n\nIf a signal is generated ( ) and the number of trades is less than or equal to 10,000:\n• : Set the stop loss above the current close price.\n• : Set the take profit below the current close price.\n• : Set the stop loss below the current close price.\n• : Set the take profit above the current close price.\n• : Run the backtest and store the statistics.\n\nSo with this backtest run we can evaluate the performance of our grid trading strategy. The object contains detailed metrics and insights that help us understand the strategy's effectiveness.\n• Duration: The strategy was tested over 57 days and 21 hours, providing a comprehensive evaluation period.\n• Exposure Time: 99.14%, indicating the strategy was almost always in the market.\n• Number of Trades: 1698, high frequency due to the grid trading strategy.\n• Avg Trade: 0.10%, reflecting the cumulative effect of many small trades."
    },
    {
        "link": "https://stackoverflow.com/questions/48464979/navigating-a-grid",
        "document": "There is also a mathematical solution (which is probably what you used):\n\nThis works because the number of paths is the same as the number of ways to choose to go right or down over steps, where you go right w times, which is equal to , or .\n\nWith missing grid squares, I think there is a combinatoric solution, but it's very slow if there are many missing squares, so dynamic programming would probably be better there.\n\nFor example, the following should work:"
    },
    {
        "link": "https://medium.com/@davidlfliang/intro-python-algorithms-path-counting-using-combinatorics-8cdaca7e5e1a",
        "document": "The path counting problem is a fundamental concept in combinatorics that involves determining the number of distinct ways to traverse a defined grid from one point to another. This grid, often visualized as a two-dimensional array of points, allows movement in specific directions — commonly right and down.\n\nWhile most pathfinding problems typically rely on algorithmic methods such as Depth-First Search (DFS) or Breadth-First Search (BFS), in simpler scenarios with straightforward movement rules, a combinatorial approach can be utilized. In these cases, using mathematical formulas is often sufficient to obtain the desired result, making the problem more accessible and efficient to solve.\n\nYou are given a 6 x 6 grid defined by its points, as illustrated in Figure 1, where you can traverse from the starting point (1, 1) to the destination point (4, 3) using specific movement rules. Your task is to count the total number of distinct paths from (1, 1) to (4, 3).\n• You can only move right (R) or down (D).\n• Each movement from point (x, y) to point (x+1, y) represents a right move, while a movement to point (x, y+1) represents a down move.\n• An integer representing the total number of unique paths from (1, 1) to (4, 3).\n• A list of move sequences (using R and D) representing each unique path. For example, “RRRDD” would represent one possible path.\n\nLet’s start by analyzing this problem using a direct thinking approach. Visually, we can see that we need to make 5 moves from (1,1) to reach (4,3). These 5 moves will be a mix of R (for moving right) and D (for moving down) to reach the target point.\n\nWe can also see that we need 3 Rs and 2 Ds in these 5 moves. Therefore, the problem becomes finding the number of combinations to form a 5-letter path consisting of 3 Rs and 2 Ds. Furthermore, we only need to determine how many ways we can place 3 Rs in the 5-letter path, as the Ds will fill the remaining 2 positions.\n\nWe can illustrate this simplified scenario as shown in Figure 2 below:\n\nWe simply need to find out how many ways we can tick 3 boxes out of 5. As shown in Figure 2, one possible selection is (1, 3, 5). For the first tick, we have 5 options; for the second, 4 options remain; and for the third, 3 options are left. So, the permutation is 5 × 4 × 3 = 60.\n\nHowever, among these 60 permutations, there are duplicates. For instance, the selection of (1, 3, 5) remains the same regardless of whether the ticks are made in the order (1, 3, 5) or (3, 1, 5). Since there are 3 options, this yields 3! = 6 permutations. Therefore, the final answer is 60 / 6 = 10.\n\nWe can manually list all 10 selections as follows:\n\nFor each selection, we can represent the moves as follows, where each combination corresponds to a different arrangement of 3 “R” and 2 “D”:\n\nHere are the final 5-letter sequences representing the combinations of R and D:\n\nWe can write a Python program to verify our calculations.\n\nWe can verify that this matches the list we created manually earlier.\n\nWe can combine these paths into a single chart for better visualization.\n\nWe can explore the generalization of this solution method by employing mathematical modeling to determine how it can be applied to any starting and target points on a grid.\n\nIn the previous section, we explored combinations through the concept of ticking boxes. Now, we can extend this idea to a more general model: selecting k items from a set of n elements. This transition highlights that the fundamental principles of combination remain consistent, whether we are choosing boxes or selecting items.\n\nThe C(n, k) formula provides a way to calculate the number of ways to choose k elements from n elements without regard to order. It is defined as:\n• n! (n factorial) is the product of all positive integers up to n.\n• k! is the factorial of k.\n• (n — k)! is the factorial of the difference between n and k.\n\nFor example, if we apply this model to our previous example, we would use C(5, 3).\n\nNow, substituting these values into the formula:\n\nCalculating the distance between two points is essential for determining the value of n, which represents the total distance required to reach the target from the starting point.\n\nFor a given pair of points (x1, y1) and (x2, y2), assuming x2 is greater than or equal to x1 and y2 is greater than or equal to y1, we can calculate the distance as follows:\n\nThen, for the value of k, we can pick either Delta x or Delta y. This is because C(n, k) is equal to C(n, n-k).\n\nLet’s use our previous example again, starting from (1, 1) and ending at (4, 3).\n\nLet’s say we pick 2 for the vertical movements this time, then C(5, 2) = 10.\n\nWe can create a function to calculate all of these between points on a grid.\n\nHaving explored the path counting problem on a 6x6 grid, we can extend this mathematical model to a more interesting scenario involving the movement of a rook on an 8x8 chessboard.\n\nThe rook can move any number of squares horizontally or vertically on the chessboard.\n\nFor example, as shown in Figure 4, if the rook needs to move from the top left corner (0, 0) to the bottom right corner (7, 7), we can restrict its movement to only right or down. This ensures that the rook always progresses toward the target square and does not move back or away from the target area.\n\nIf we apply the same mathematical model to this Rook problem, it will effectively give us the number of unique shortest paths available for the rook to accomplish this goal.\n\nWe can use the same program, simply by providing a different pair of data.\n\nFrom the output, we can see that there are 3,432 unique paths available, each with a length of 14 for this rook path problem.\n\nNext, we can handpick a straightforward path with 7 Ds followed by 7 Rs:\n\nWe can plot these two example paths on the same chart, using a 14-letter sequence to represent their unique names.\n\nThese paths are just two of the 3,432 unique routes available for the rook to travel from (0, 0) to (7, 7).\n\nWe have one more challenge to tackle: calculating the number of unique paths not just for a single square, but for all 64 squares when the starting square is (0, 0).\n\nWe can display these numbers on the chessboard:\n\nThis 8x8 number grid has an interesting relationship with the famous mathematical arrangement known as Pascal’s Triangle.\n\nPascal’s triangle is a triangular array of numbers where each number is the sum of the two directly above it. Pascal’s Triangle with 15 rows is shown in Figure 7 below.\n\nThe Reason for This Relationship\n\nAs shown in Figure 7, the numbers highlighted in pink match those in the 8x8 number grid from the Rook Path Counting Problem, and the only difference is the shape of the formation, where 15 diagonals from the 8x8 grid become 15 horizontal rows in the triangular arrangement. Mathematically, this is because they represent the same concept, derived from the same formula (or mathematical model) we discussed earlier.\n\nIn Pascal’s triangle, n is the row index number (0-based) in the triangle tower, and k is the position within that row (also 0-based). The edge cases C(0,0) and C(n,0) are both defined to be 1.\n\nWe can confirm this with our original example by locating the cells for C(5,2) and C(5,3) in Pascal’s triangle, both of which equal 10.\n\nThe rook path counting follows a simple and intuitive pattern: to reach any given target square, there are only two possible directions — either from above or from the left. As a result, the number on each square is the sum of the numbers on the square directly above it and the square directly to the left. This logic mirrors the construction of Pascal’s Triangle, where each number is the sum of the two numbers directly above it.\n\nIn this article, we explored the path counting problem within a 6x6 grid and extended it to the context of an 8x8 chessboard rook’s movements. By employing combinatorial methods, we demonstrated how to calculate the total number of distinct paths from a starting point to a destination using the combination formula C(n, k). Through examples, we illustrated the process of determining unique move sequences and confirmed our calculations with Python implementations.\n\nWe also examined the relationship between our path counting results and Pascal’s Triangle, highlighting how both concepts arise from the same combinatorial principles. The numbers within our 8x8 grid corresponded with those in Pascal’s Triangle, revealing a deeper mathematical connection.\n\nFuture discussions will delve deeper into the properties of Pascal’s Triangle and its applications in combinatorial theory and beyond."
    },
    {
        "link": "https://github.com/riscy/a_star_on_grids",
        "document": "\n• Heuristics\n• Use octile distance on an 8-connected grid\n• Algorithmic details\n• Know whether to use a heap\n\nThis document describes ways to improve an A* implementation, focusing on pathfinding in four- and eight-connected grids. It’s pitched at hobbyists and anyone looking for ways to make existing code a bit faster.\n\nSome accompanying example code is available in C++.\n\nForgoing a complete description, recall that A* is essentially a loop that expands a list of open states that reach toward a goal state. Each iteration of the A* loop expands the open list with the neighbors of a state already on the open list. The open state that gets chosen is one with the lowest value:\n\nwhich is an estimate of the cost of a path going through and continuing to the goal. Here is the cost of the cheapest path to state that A* has generated so far, and is an efficiently computed heuristic estimate for the cost to get from to the goal.\n\nOn an 8-connected grid, the cost of a single diagonal move ( ) relative to the cost of a cardinal move ( ) not only affects the appearance of the paths A* generates, but can also affect its efficiency.\n\nPrefer integral data types wherever possible. This is not only faster but helps to avoid the numerical imprecision that can confuse debugging attempts.\n\nWhen the entity can move cardinally or diagonally once per time-step, the instinct is to tell A* that cardinal and diagonal moves cost the same (e.g., ). While technically true, this increases the number of unique optimal paths across the grid; A* is more efficient when it has fewer options.\n\n. If a diagonal move costs less than a cardinal move, A* prefers zigzagging paths. If a diagonal move costs more than two cardinal moves, A* prefers rectilinear paths like you’d see on a 4-connected grid. Paths tend to look best when the costs lie between these two extremes.\n\nThe following cost structures work well in practice. Results can vary depending on the obstacles in the grid, so test before using.\n\nHere are some tips on selecting a good heuristic. I frequently see these details missed on many first implementations of A*.\n\nHeuristics that don’t overestimate are called admissible. A* recovers an optimal (cheapest) path when its heuristic is admissible. A good, admissible grid heuristic is the “distance” between two states assuming no obstacles.\n\nThe distance between two states on a 4-connected grid, assuming no obstacles, is the Manhattan (or L1-norm or rectilinear) distance:\n\nwhere and are absolute distances between and the goal along the and axes and is the cost to take a cardinal move, which may as well be .\n\nWhen pathfinding on an 8-connected grid, use the octile heuristic:\n\nwhere with being the cost to take a cardinal move and being the cost to take a diagonal move.\n\nNote the octile heuristic can be written without a conditional (albeit with an absolute value), which may help improve instruction level parallelism:\n\nwhere . You can see how this simplifies further, without floating point arithmetic, if (and therefore ) is even.\n• See an example implementation of the octile heuristic\n• See an example implementation of the non-branching octile heuristic\n\nOnce you’ve selected a good heuristic, try multiplying all of the values it gives you by a constant (e.g. ). This simple change yields an algorithm called Weighted A*, which significantly improves run-time at the cost of small suboptimalities in your paths.\n\nSee an example implementation of a weighted octile heuristic.\n\nSome details that tend not to come up in textbook descriptions of A*.\n\nIt is common for more than one state on the open list to have the lowest cost. When this is the case it’s better to make A* focus on deep solutions rather than a breadth of shallow solutions by tie-breaking on larger values. My Ph.D. co-supervisor Nathan Sturtevant created a video demonstration.\n\nTo help keep the open list sorted, an implementation of A* might store the and values for every open state . And since , the value of can always be recovered as for any open state . Using these stored values (a form of memoization) can be less expensive than recomputing .\n\nFor instance, suppose is on the open list with and values of and . Then A* iterates to a cheaper path to with a cost of . The corresponding value can be determined without making another call to the heuristic function:\n\nSee an example of using memoized heuristics.\n\nOn larger grids with complex obstacles, implementing your open list as a binary heap (preferably on top of an array) can lead to dramatic performance gains. This is why it’s generally considered a best practice to do so.\n\nBut heaps can hurt. On smaller grids with few obstacles, a linear scan of the entire open list can be much faster, especially if your implementation is written in a low-level language like C++.\n• See an A* implementation that uses an array\n• See an A* implementation that uses a heap\n• See an example heap implementation\n\nFringe Search is a close cousin of A* that takes a different approach to growing and maintaining the open list. Just about all of the points in this document apply to Fringe Search, such as choosing a good heuristic, the choice of diagonal vs. cardinal move costs, and using memoized heuristic values.\n\nWith compiler optimizations on, I found Fringe Search to be slower than A*, albeit only if the methods in this document are applied. But with compiler optimizations off, Fringe Search can be faster than A*. It’s reasonable to predict Fringe Search may be the faster choice in interpreted scripting languages.\n\nSee an example Fringe Search implementation.\n\nThe following are some tips on the actual implementation of your pathfinder.\n\nDuring development you’ll be constantly changing and refactoring your code. This can be dangerous – it is surprisingly easy to write a pathfinder that seems to work but has an invisible bug that isn’t obvious until much later.\n\nTo prevent this you should write tested code: write a simple but correct pathinder and use it to test your production pathfinder. For example, if you’re finding optimal paths, both your simple pathfinder and your optimized pathfinder should return solutions of the same length, even if they visit different states.\n\nYou’ll get huge speed gains by writing your pathfinder in a compiled system-level language like C, or C++, or Rust.\n\nIf you’re using a high-level scripting language, you’re not necessarily out of luck. If you’re using Python, for example, you could look into compiling your pathfinding module with Cython – it’s surprisingly easy to do.\n\nIf you’re coding in a low-level language like C, C++, or Rust, be aware of the effects of structure packing – especially if you’re using an explicit graph to represent a large search space.\n\nIf you’re using , for example, try giving your compiler the argument and see how much it whines about having to pad your data structures with extra bytes. Eric Raymond has a great writeup on this topic.\n\nIf you have any corrections or contributions – both much appreciated – feel free to get in touch or simply make a pull request.\n\nIf for any reason you want to cite this document, use the following:"
    },
    {
        "link": "https://dev.to/who_tf_cares/how-to-work-with-multidimensional-arrays-in-javascript-9jl",
        "document": "JavaScript doesn't natively provide multidimensional arrays. However, you can create one using a one-dimensional array. Essentially, a multidimensional array in JavaScript is an array within another array. To make an array behave like a multidimensional array, you can place arrays inside a parent array, effectively mimicking a multidimensional structure. Defining a multidimensional array is almost identical to defining a one-dimensional array.\n\nHere, , , ..., are 1D arrays inside the array.\n\nThis is known as array literals notation.\n\nYou can add elements in two ways—either to the inner array or the outer array.\n\n1. Adding to the Inner Array\n\nYou can remove elements from both the inner and outer arrays.\n\n1. Removing from the Inner Array\n\nExample 3: Adding Elements to an Array\n\nExample 5: Adding a New Inner Array\n\nExample 6: Removing a Single Element and an Entire Sub-array\n• \n• Use nested loops to iterate through multidimensional arrays.\n• \n• Add elements to inner arrays using direct indexing or .\n• Add new inner arrays using .\n• \n• Remove elements from inner arrays using .\n\nThese operations allow you to manipulate multidimensional arrays effectively in JavaScript.\n\nWhen working with multidimensional arrays in JavaScript, visualizing their structure can be highly beneficial for debugging and understanding the data. Here are some tools and techniques that can help you visualize JavaScript multidimensional arrays:\n• Usage: Directly log arrays to the browser console using .\n• Benefits: Allows you to view array structures in a collapsible format.\n• Usage: Displays array data in a tabular format in the console.\n• Benefits: Provides a clear, structured view of arrays with easy-to-read rows and columns.\n• Usage: Visualize multidimensional arrays in a structured format by pasting them into online JSON viewers.\n• Usage: Use DataTables library to turn arrays into interactive tables with sorting, filtering, and searching capabilities.\n• Benefits: Provides an interactive and user-friendly way to view and manipulate array data.\n• Usage: Create custom visualizations of multidimensional data with charts, graphs, and interactive elements.\n• Usage: Visualize data with charts and graphs to represent multidimensional arrays graphically.\n• Benefits: Provides various chart types to represent multidimensional data visually.\n• Usage: Use extensions like or to visualize and navigate multidimensional arrays.\n• Benefits: Integrates directly into your development environment for quick visualization and debugging.\n• Browser Developer Tools: Use and for quick inspection.\n• Online Visualization Tools: Use JSON viewers and interactive tables for structured views.\n• Visualization Libraries: Use libraries like D3.js and Chart.js for custom and graphical representations.\n• IDEs: Leverage extensions in IDEs like Visual Studio Code for enhanced visualization and navigation.\n\nThese tools can significantly aid in understanding and debugging multidimensional arrays in JavaScript by providing clear and interactive visualizations.\n\nBest Practices for Working with Nested Arrays in JavaScript\n\nWhen working with nested arrays in JavaScript, it's crucial to follow best practices to ensure your code is clean, efficient, and maintainable. Here are some best practices for handling nested arrays:\n• Define Array Structure Clearly: Be explicit about the structure of nested arrays to avoid confusion. Document what each level of nesting represents. // Array of employee records, each containing personal info and job details\n• Choose Meaningful Names: Name variables and arrays descriptively to make the code more readable.\n• Check for Undefined Values: Before accessing nested array elements, ensure that each level exists to prevent runtime errors.\n• Leverage Built-in Methods: Use JavaScript array methods like , , and to work with nested arrays more effectively. // Extract all roles from the nested array\n• Flatten Arrays When Possible: Deeply nested arrays can be hard to manage. Consider flattening the array or using objects to represent hierarchical data.\n• Encapsulate Logic in Functions: Create functions to handle operations on nested arrays to make the code reusable and easier to maintain.\n• Ensure Data Integrity: Validate the input data before processing it to ensure it matches the expected structure.\n• Add Comments: Document the purpose and structure of nested arrays in your code to make it easier for others (and yourself) to understand.\n• Consider Complexity: Be mindful of the performance implications when working with large or deeply nested arrays. Optimize your algorithms to handle data efficiently.\n• Manage Special Cases: Account for edge cases, such as empty arrays or missing elements, to ensure robust code.\n• Understand the Structure: Define and document the nested array structure clearly.\n• Use Descriptive Names: Name arrays and variables meaningfully.\n• Utilize Array Methods: Use methods like , , and for efficient processing.\n• Avoid Deep Nesting: Flatten arrays or use objects when possible.\n• Encapsulate Logic: Use functions to handle operations on nested arrays.\n• Document Your Code: Add comments and documentation for clarity.\n• Optimize Performance: Be aware of performance implications and optimize algorithms.\n\nFollowing these best practices will help you manage nested arrays effectively and write more maintainable and readable code in JavaScript.\n\nWhen dealing with multidimensional arrays in JavaScript, several libraries can help you manage, manipulate, and visualize data effectively. Here are some of the best JavaScript libraries for handling multidimensional arrays:\n• Overview: Lodash is a powerful utility library that provides a wide range of functions for manipulating arrays and objects, including multidimensional arrays.\n• Overview: Underscore.js is a utility-belt library for JavaScript that provides functional programming helpers, including support for multidimensional arrays.\n• Overview: Danfo.js is a library for manipulating and analyzing data in JavaScript, similar to Pandas in Python. It is designed for handling multidimensional data structures like DataFrames and Series.\n• Features:\n• Supports operations on DataFrames, which are essentially multidimensional arrays.\n• Overview: Math.js is a comprehensive math library for JavaScript and Node.js, providing extensive support for mathematical operations, including those on multidimensional arrays.\n• Overview: These are native JavaScript methods for flattening arrays, introduced in ECMAScript 2019. They can be particularly useful for working with nested arrays.\n• Features:\n• : Flattens nested arrays up to a specified depth.\n• : Maps each element using a mapping function and then flattens the result.\n• Overview: Three.js is a 3D library that can be used for visualizing multidimensional arrays as 3D objects and scenes.\n• Features:\n• Useful for visualizing multidimensional data in a 3D context.\n• Overview: Recharts is a composable charting library built on React components, which can be used to visualize multidimensional data in charts.\n• Features:\n• Supports various chart types like line charts, bar charts, and scatter plots.\n\nThese libraries and tools can help you manage, analyze, and visualize multidimensional arrays more effectively in JavaScript.\n\nDebugging multidimensional arrays in JavaScript can be challenging due to their complex structure. Here are some of the best debugging techniques to help you effectively troubleshoot issues with multidimensional arrays:\n• Overview: Utilize to print out the structure and content of your multidimensional arrays at various stages of your code.\n• Tips:\n• Log the entire array or specific elements to inspect their values.\n• Use for a more readable, formatted output.\n• Overview: Use browser developer tools to inspect and debug multidimensional arrays interactively.\n• Tips:\n• Set breakpoints in your code to pause execution and inspect variables.\n• Use the Console panel to evaluate expressions and view array contents.\n• Utilize the Sources panel to step through code and observe changes to arrays.\n• Overview: Insert statements in your code to trigger the debugger and pause execution at specific points.\n• Tips:\n• Place before the line where you want to start debugging.\n• This allows you to inspect the state of multidimensional arrays when execution pauses.\n• Overview: Use built-in array methods to simplify the inspection and manipulation of multidimensional arrays.\n• Tips:\n• Use or to iterate over arrays and log elements.\n• Overview: Check the integrity of your multidimensional array to ensure it matches the expected structure.\n• Tips:\n• Verify that each level of nesting exists and contains the correct data types.\n• Use conditionals or validation functions to check array length and structure.\n• Overview: Develop unit tests to verify the behavior and integrity of functions that work with multidimensional arrays.\n• Tips:\n• Use testing frameworks like Jest or Mocha to write tests.\n• Overview: Simplify complex operations on multidimensional arrays by breaking them into smaller, manageable steps.\n• Tips:\n• Refactor code to handle smaller pieces of the array.\n• Overview: Use visualization tools to better understand the structure and content of multidimensional arrays.\n• Tips:\n• Convert arrays to tables or charts for a clearer view of data.\n• Libraries like DataTables or charting libraries can help visualize array data.\n• Overview: Create custom functions to assist with debugging by logging and validating array data.\n• Tips:\n• Use these functions to gain insights into your data.\n• Overview: Refer to documentation and seek help from the developer community for issues related to multidimensional arrays.\n• Tips:\n• Participate in forums or Stack Overflow to ask questions and find solutions.\n• Use : Print array structure and elements for inspection.\n• Inspect with Browser DevTools: Utilize interactive debugging tools in your browser.\n• Employ Array Methods: Use methods like and for easier manipulation.\n• Visualize Data: Use tools to convert arrays into readable formats.\n• Debug with Custom Functions: Create functions to log and validate array data.\n• Consult Documentation and Community: Use available resources and seek help when needed.\n\nBy employing these techniques, you can more effectively debug issues related to multidimensional arrays in JavaScript and ensure your code behaves as expected.\n\nAccessing data in nested JavaScript arrays can be intricate due to their hierarchical structure. Here are some of the best methods and techniques for accessing and manipulating data in nested arrays:\n• Overview: Use index notation to access specific elements in nested arrays.\n• How-To:\n• Example: where , , and are indices at different levels.\n• Overview: Use array destructuring to extract values from nested arrays into variables.\n• How-To:\n• Use to reduce the nesting level of arrays.\n• How-To:\n• Create a function that calls itself to traverse arrays of arbitrary depth.\n• Overview: Utilize array methods like and to iterate through and access nested array elements.\n• How-To:\n• Use to transform and access nested data.\n• Use to perform actions on each element.\n• How-To:\n• Use to recursively flatten arrays or perform operations on nested data.\n• Overview: Use to locate and access elements in nested arrays based on a condition.\n• How-To:\n• Apply to locate the first matching element in nested arrays.\n• Overview: Use to locate the index of a sub-array or element.\n• How-To:\n• Find the index of a sub-array or element in a nested structure.\n• Overview: Use to extract portions of nested arrays.\n• Overview: Use ES6 to create custom access behavior for nested arrays.\n• How-To:\n• Define a to intercept and manage access to nested array data.\n• Using and : Iterate and manipulate nested data.\n• Using for Flattening: Flatten or aggregate data with .\n• Using for Positioning: Find indices of sub-arrays or elements.\n• Using for Sub-array Extraction: Extract portions of arrays.\n\nBy using these methods, you can efficiently access and manipulate data in nested JavaScript arrays, making it easier to handle complex data structures in your applications.\n\nBest IDEs for JavaScript Development with Multidimensional Arrays\n\nWhen working with JavaScript, especially involving complex data structures like multidimensional arrays, choosing the right Integrated Development Environment (IDE) can significantly enhance productivity and code management. Here’s a list of some of the best IDEs for JavaScript development, specifically focusing on handling multidimensional arrays:\n• Features:\n• IntelliSense: Provides smart code completions and inline documentation, which is helpful for navigating multidimensional arrays.\n• Extensions: Supports a wide range of extensions for JavaScript development, including those for array visualization and manipulation.\n• Integrated Terminal: Allows running scripts and testing code without leaving the editor.\n• Bracket Pair Colorizer: Helps in visualizing matching brackets, useful for nested arrays.\n• Overview: A powerful IDE for JavaScript and web development created by JetBrains.\n• Features:\n• Live Edit: Allows real-time preview of changes in the browser.\n• Features:\n• Syntax Highlighting: Clear syntax highlighting for JavaScript code, aiding in readability of nested structures.\n• Command Palette: Access to various commands and tools directly.\n• Emmet: For faster HTML and CSS writing, useful in conjunction with JavaScript.\n• Overview: An open-source text editor developed by GitHub with a strong community of contributors.\n• Features:\n• Package Manager: Easy access to a wide range of packages for JavaScript development.\n• Features:\n• Live Preview: See changes in real-time as you edit your code.\n• Inline Editors: Edit CSS and JavaScript inline with the HTML code.\n• Extensions: Support for various extensions to enhance functionality.\n• Overview: A versatile IDE that can be extended for JavaScript development with plugins.\n• Eclipse Wild Web Developer: Provides JavaScript, TypeScript, and other web development support.\n• Overview: An open-source IDE with support for multiple programming languages, including JavaScript.\n• JavaScript Tools: Includes various tools for managing and analyzing JavaScript code.\n• Visual Studio Code (VS Code): Best for extensive extensions and integrated development features.\n\nThese IDEs offer various features to streamline the development process, manage multidimensional arrays, and enhance productivity in JavaScript programming.\n\nWhen working with complex array structures in JavaScript, using the right framework can simplify data management and enhance your application's performance. Here are some of the best JavaScript frameworks and libraries for handling complex array structures:\n• Features:\n• Component-Based Architecture: Helps in managing complex data structures by breaking down the UI into reusable components.\n• State Management: Libraries like Redux or React's built-in and hooks are excellent for managing complex state, including arrays.\n• Virtual DOM: Efficiently updates the UI by only re-rendering parts of the DOM that have changed.\n\nExample: Managing a nested array of items and their state using React's state management.\n• \n• Two-Way Data Binding: Synchronizes data between the model and the view, making it easy to manage and display complex array structures.\n• Dependency Injection: Facilitates easier management of services and components that handle complex data.\n• RxJS: Powerful library for handling asynchronous data and streams, useful for managing and manipulating arrays.\n\nExample: Using Angular’s services to manage nested arrays.\n• Features:\n• Reactivity System: Automatically updates the UI when the data changes, making it ideal for managing complex array structures.\n• Vuex: State management pattern and library that works well with Vue to handle complex state, including nested arrays.\n\nExample: Using Vue to handle and display nested arrays.\n• Features:\n• Data Layer: Provides a robust data management system with Ember Data, which simplifies the handling of complex data structures.\n• Computed Properties: Allows you to create properties based on the state of the data, useful for working with nested arrays.\n\nExample: Managing and displaying nested arrays with Ember.js.\n• Overview: A modern framework for building user interfaces that compiles to efficient vanilla JavaScript.\n• Features:\n• Reactivity: Built-in reactivity system makes it easy to handle changes in complex data structures.\n• Svelte Stores: Manage and react to changes in state, including arrays, with a simple and intuitive API.\n• Overview: A lightweight framework that provides the minimal structure needed for JavaScript applications.\n• Features:\n• Models and Collections: Useful for managing complex data, including nested arrays, with built-in methods for querying and updating.\n\nExample: Using Backbone’s collections to manage nested arrays.\n• Overview: A modern framework for building robust applications with a focus on simplicity and ease of use.\n• Features:\n• Two-Way Data Binding: Makes it straightforward to bind complex data structures to the UI.\n• Vue.js: Known for its reactivity and simple state management with Vuex.\n• Backbone.js: Lightweight with models and collections for data management.\n• Aurelia: Focuses on simplicity with data binding and custom elements.\n\nThese frameworks and libraries offer different features and approaches to handling complex array structures in JavaScript, helping you choose the best tool based on your project's requirements.\n\nBest Sorting Algorithms for Multidimensional Arrays in JavaScript\n\nSorting multidimensional arrays in JavaScript can be complex, as it involves sorting based on one or more dimensions. Here’s a guide to some of the best sorting algorithms you can use for multidimensional arrays, along with their suitability for different scenarios:\n• Overview: Quick sort is a highly efficient, divide-and-conquer algorithm that sorts arrays by selecting a 'pivot' and partitioning the array into sub-arrays.\n• Suitability: Good for large arrays and multidimensional arrays where you need to sort based on a specific dimension.\n\nExample: Sorting a 2D array by the second element in each sub-array.\n• Overview: Merge sort is a stable, divide-and-conquer algorithm that divides the array into smaller arrays, sorts them, and merges them back together.\n• Suitability: Ideal for large arrays and cases where stability (preserving the order of equal elements) is important.\n\nExample: Sorting a 2D array by the first element in each sub-array.\n• Overview: Bubble sort repeatedly compares and swaps adjacent elements if they are in the wrong order.\n• Suitability: Best for small arrays or as a teaching tool; not efficient for large multidimensional arrays.\n\nExample: Sorting a 2D array by the first element using bubble sort.\n• Overview: Insertion sort builds the sorted array one item at a time by repeatedly picking the next item and inserting it into the correct position.\n• Suitability: Good for small to medium-sized arrays or nearly sorted arrays.\n\nExample: Sorting a 2D array by the second element using insertion sort.\n• Overview: Heap sort involves building a heap from the array and then repeatedly extracting the maximum element from the heap to build the sorted array.\n• Suitability: Good for large arrays where performance is a concern.\n\nExample: Sorting a 2D array by the first element using heap sort.\n• Overview: Radix sort is a non-comparative sorting algorithm that sorts numbers by processing individual digits.\n• Suitability: Efficient for sorting numbers and can be adapted for multidimensional arrays if elements are numeric.\n\nExample: Sorting a 2D array by a specific column if elements are numeric.\n• Quick Sort: Efficient for large arrays and multidimensional arrays with specific sorting criteria.\n• Merge Sort: Stable and good for large arrays where stability is important.\n• Bubble Sort: Simple but inefficient for large arrays; best for small or educational purposes.\n• Insertion Sort: Suitable for small or nearly sorted arrays.\n• Radix Sort: Efficient for numeric arrays; can be adapted for multidimensional sorting if elements are numbers.\n\nThese sorting algorithms offer different trade-offs in terms of complexity, performance, and stability, allowing you to choose the best one based on your specific needs when working with multidimensional arrays in JavaScript.\n• Some sections of this article were generated using artificial intelligence, specifically Claude Sonnet. While I have manually reviewed most of the content, please verify the information under the \"Generated by AI\" sections to ensure accuracy.\n• This article is geared towards Beginners and their queries. More sophisticated methods for working with multidimensional arrays, such as dynamic memory allocation, recursion, and custom data structures haven't been discussed here.\n• Multidimensional Arrays are used in game development, data visualization, or machine learning.\n• Compare the performance of different methods for handling multidimensional arrays and highlight their strengths and weaknesses.\n• The article doesn't provide many examples of how multidimensional arrays are used in real-world JavaScript applications. What are some real-world applications apart from those mentioned in note."
    },
    {
        "link": "https://freecodecamp.org/news/javascript-2d-arrays",
        "document": "In JavaScript programming, we are all used to creating and working with one-dimensional arrays. These are arrays that contain elements (elements of similar data types or multiple data types).\n\nBut it’s also good to know that two-dimensional arrays (2D arrays) exist in JS.\n\nIn this article, you will learn what two-dimensional arrays are and how they work in JavaScript. It is quite different from other programming languages because, technically, there is no two-dimensional array in JavaScript.\n\nA two-dimensional array, also known as a 2D array, is a collection of data elements arranged in a grid-like structure with rows and columns. Each element in the array is referred to as a cell and can be accessed by its row and column indices/indexes.\n\nIn JavaScript, there is no direct syntax for creating 2D arrays as with other commonly used programming languages like C, C++, and Java.\n\nYou can create two-dimensional arrays in JavaScript through jagged arrays — an array of arrays. For example, below is what a jagged array looks like:\n\nBut there is a limitation. It is important to note that two-dimensional arrays have a fixed size. This means that once they are created, the number of rows and columns should be fixed. Also, each row should have a similar number of elements (columns).\n\nFor example, the array below has three rows and four elements:\n\nThe limitation is that with jagged arrays, you don't get to specify a fixed row and column. This means that a jagged array could have m rows, each having different numbers of elements.\n\nWhy Use a 2D Array in JavaScript?\n\nAt this point, you may ask yourself about the importance of a 2D array, especially if this is your first time reading about 2D arrays.\n\nIn JavaScript, we use two-dimensional arrays, also known as matrices, to store and manipulate data in a structured and organized manner.\n• None They allow for the efficient storage and manipulation of large amounts of data, such as in image or video processing, scientific simulations, and spreadsheet applications.\n• None Two-dimensional arrays also enable the use of matrix operations, such as matrix multiplication and transposition, which can simplify complex calculations and make code more readable.\n• None Two-dimensional arrays can represent mathematical matrices in linear algebra and a wide range of data, such as graphs, maps, and tables.\n• None Two-dimensional arrays are commonly used in applications that involve data tables, image processing, and game development.\n\nHow to Access Elements in a JavaScript 2D Array\n\nBefore you learn how to create 2D arrays in JavaScript, let’s first learn how to access elements in 2D arrays.\n\nYou can access the elements of a two-dimensional array using two indices, one for the row and one for the column. Suppose you have the following two-dimensional array:\n\nThe above is a jagged array in which each element holds the student's name, test score, exam score, and grade. You can access specific elements using the row and column index as seen in the syntax below:\n\nTo better understand this, let’s convert the two-dimensional array above to a table using .\n\nYou will get an output like this, showing the row and column index. Remember that arrays are zero-indexed, meaning items are referenced from 0, not 1.\n\nPlease note that the column and row are for the illustration that indicates the indices/indexes of the inner array.\n\nYou use two square brackets to access an element of the two-dimensional or multi-dimensional array. The first accesses the rows, while the second accesses the element in the specified row.\n\nHow to access the first and last elements of a 2D array\n\nSometimes you might need to find the first and last elements of a two-dimensional array. You can do this using the first and last index of both the rows and columns.\n\nThe first element will always have the row and column index of 0, meaning you will use .\n\nThe index of the last element can be tricky, however. For example, in the example above, the first element is ‘John Doe’ while the last is ‘B’:\n\nHow to add all elements of a 2D array\n\nIn some situations, all the elements of your 2D array can be numbers, so you may need to add them together and arrive at just one digit. You can do this using a nested loop. You will first loop through the rows, then, for each row, you loop through its elements.\n\nHow to Manipulate 2D Arrays in JavaScript\n\nYou can manipulate 2D arrays just like one-dimensional arrays using general array methods like pop, push, splice and lots more.\n\nLet’s start by learning how to add/insert a new row and element to the 2D array.\n\nHow to insert an element into a 2D array\n\nYou can add an element or many elements to a 2D array with the push() and unshift() methods.\n\nThe push() method adds elements(s) to the end of the 2D array, while the unshift() method adds element(s) to the beginning of the 2D array.\n\nWhen you or the array, you will see that the new rows have been added:\n\nYou can also add elements to the inner array, but it’s wrong to push to just one inner array without affecting all the array elements. This is because two-dimensional arrays are meant to have the same number of elements in each element array.\n\nInstead of affecting one array element, you can add elements to all element arrays at once:\n\nYou can also use the method to insert the element at the beginning and the method to insert at the middle of the array:\n\nIn the above, is the position where you want the new array to be inserted (remember it is zero-indexed), is used so it removes no element, and then the third parameter is the array to be added.\n\nThis is the output:\n\nHow to remove an element from a 2D array\n\nYou can also remove element(s) from the beginning and end of a 2D array with the and methods. This is similar to how the and methods work, but you do not add any parameters to the methods this time.\n\nWhen you or the array, you will see that the first and last array elements have been removed:\n\nYou can also remove elements from each array element:\n\nYou can also use the method to remove the element at the beginning and the method to remove array elements from specific positions:\n\nIn the code above, you remove one item from position index of the 2D array. This will output:\n\nNote: All JavaScript array methods will operate on a 2D array because it is an array of arrays. You only have to be mindful when adjusting individual elements in the elements array. You make a similar change on all elements by looping through, even though 2D arrays in JavaScript are not strict.\n\nHow to Create 2D Arrays in JavaScript\n\nThere are two options for creating a multi-dimensional array. You can create the array manually with the array literal notation, which uses square brackets to wrap a list of elements separated by commas. You can also use a nested loop.\n\nHow to create a 2D array using an array literal\n\nThis is just like the examples we have been considering using the following syntax:\n\nFor example, below is a 2D array that holds information about each student’s math score and grade:\n\nHow to create a 2D array using a nested for loop\n\nThere are many approaches to doing this. But generally, you create a nested loop where the first loop will loop through the rows while the second loop will loop through the elements in the inner array (columns):\n\nIn the code above, you will first loop through the rows. For each row, it will create an empty array within the original array declared and stored in variable . You will then create a nested loop to loop through the columns and add individual elements.\n\nIn this example, the index for is used and will output:\n\nYou can decide to create a number, initialize with 0, and then increase as you loop through so you don’t have the same number for all elements:\n\nYou can also decide to create a function that accepts these values as arguments:\n\nThis is very similar to how you do it with one-dimensional arrays, where you can update an array’s value by using the index to assign another value.\n\nYou can use the same approach to change an entire row or even individual elements:\n\nThis will replace the value of index with this new array:\n\nYou can update individual elements by tracking the row and column indices and updating their values:\n\nThis will change the name on the row with index to “Jack Jim”, as seen below:\n\nIn this article, you have learned what two-dimensional arrays are and how they work in JavaScript.\n\nIt’s important to know that 2D arrays in JavaScript still work very much like one-dimensional arrays, so feel free to tweak and manipulate them with JavaScript methods.\n\nYou can access over 150 of my articles by visiting my website. You can also use the search field to see if I've written a specific article."
    },
    {
        "link": "https://bomberbot.com/javascript/javascript-2d-array-two-dimensional-arrays-in-js-a-comprehensive-guide",
        "document": "As a full-stack developer, you‘ll inevitably encounter situations where you need to work with grid-like or tabular data structures. This is where two-dimensional arrays, or 2D arrays, come into play. While JavaScript doesn‘t have a built-in 2D array type, they can be effectively implemented using nested arrays.\n\nIn this in-depth guide, we‘ll explore the ins and outs of creating, accessing, and manipulating 2D arrays in JavaScript. Whether you‘re a front-end developer working with complex UI grids, or a back-end developer optimizing data storage and retrieval, mastering 2D arrays is a critical skill in your toolkit.\n\nA 2D array is essentially an \"array of arrays\" – elements arranged in a grid-like structure with rows and columns. Each element is accessed via two indexes – one for the row, and one for the column within that row.\n\nConceptually, you can visualize a 2D array as a table or matrix:\n\nIn JavaScript, this would be represented as:\n\nUnder the hood, 2D arrays in JavaScript are implemented as arrays of arrays. The outer array represents the rows, while each inner array represents the columns within a row.\n\nWhile this nested structure provides flexibility, it‘s important to understand the implications. Unlike true 2D arrays in languages like C or Java, JavaScript‘s nested arrays are not guaranteed to be rectangular. Each row could potentially have a different number of columns.\n\nAs a developer, it‘s your responsibility to enforce the rectangular structure if your application requires it. This means being careful when adding, removing, or updating elements to maintain consistent row lengths.\n\nThere are several ways to create a 2D array in JavaScript, each with its own use cases and trade-offs.\n\nThe simplest way to create a 2D array is using array literal notation and nesting arrays inside another array:\n\nThis is convenient for small, fixed-size arrays that you can define upfront. However, it becomes cumbersome for larger or dynamically-sized arrays.\n\nFor larger or dynamic 2D arrays, you can use nested loops to populate the rows and columns programmatically:\n\nThis creates a 3×4 array filled with zeros. The outer loop creates each row, while the inner loop populates each column within those rows.\n\nThis approach provides more control over the size and initial values of the array. You can easily swap out the zero with any value or expression.\n\nAs of ES2015, provides a concise way to create a 2D array using a mapping function:\n\nHere, creates an array with number of undefined elements. then maps each of these undefined elements to a new array of size filled with zeros.\n\nThis is a more declarative and functional approach compared to the imperative nested loops.\n\nTo access an individual element in a 2D array, you need to provide both the row and column indexes:\n\nRemember that array indexes start at 0, so accesses the second row, and accesses the first element within that row.\n\nTo iterate through all elements, you can use nested loops:\n\nThe outer loop handles the rows, while the inner loop handles the columns within each row. Note that we use for the inner loop condition, as each row could potentially have a different length in a \"jagged\" array.\n\nAccessing an element in a 2D array has a time complexity of O(1), as it‘s a constant-time operation regardless of the size of the array. You‘re directly indexing into the outer and inner arrays.\n\nHowever, iterating through all elements using nested loops has a time complexity of O(n * m), where n is the number of rows and m is the number of columns. In the worst case of a square matrix (n = m), this simplifies to O(n^2) quadratic time.\n\nThe space complexity of a 2D array is also O(n * m), as you need to store each individual element. This can become significant for large matrices.\n\nAs a developer, it‘s crucial to be mindful of these complexities when working with large datasets in 2D arrays. You might need to consider alternative data structures or algorithms for better performance.\n\nAdding, removing, and updating elements in a 2D array involves working with both the outer and inner arrays.\n\nTo add a new row to a 2D array, you can use the method on the outer array:\n\nTo add an element to an existing row, you can use on the specific inner array:\n\nBe cautious when adding elements individually to rows, as it can lead to inconsistent row lengths and a \"jagged\" array.\n\nTo remove a row from a 2D array, you can use the method on the outer array:\n\nHere, removes 1 element starting from index 1 (the second row).\n\nTo remove an element from a specific row, you can again use on the inner array:\n\nThis removes 1 element starting from index 1 in the first row.\n\nUpdating an element is straightforward using direct assignment:\n\nHere, we update the element at row 0, column 1 to the value 5.\n\nWhen working with 2D arrays in JavaScript, there are several best practices to keep in mind:\n• Consistent Dimensions: Unless you have a specific reason for jagged arrays, always ensure that your 2D arrays have consistent row lengths. This makes your code more predictable and easier to reason about.\n• Naming Conventions: Use clear and descriptive names for your arrays and index variables. Common conventions are , , for indexes, and for individual elements, and , , or for the 2D array itself.\n• Bounds Checking: Always validate that your indexes are within the valid range before accessing elements. Accessing an out-of-bounds index will return and can lead to subtle bugs.\n• Modularize: If you find yourself repeating similar operations on 2D arrays, consider extracting them into reusable functions. This improves readability and maintainability.\n• Consider Alternatives: If you‘re working with very large datasets or need more complex operations, consider using libraries like NumPy (for data processing) or TensorFlow (for machine learning). These provide optimized and vectorized operations on multi-dimensional arrays.\n\n2D arrays have numerous applications across various domains of web development:\n\nFor example, let‘s say you‘re building a chess game. You can represent the board as an 8×8 array, with each element storing the chess piece (or null for empty squares):\n\nYou can then write functions to display the board, validate moves, and update the array as the game progresses.\n\n2D arrays are often used in dynamic programming, a technique for solving complex problems by breaking them down into simpler subproblems. Each subproblem‘s solution is stored in the array to avoid redundant calculations.\n\nFor example, let‘s say you want to find the longest common subsequence between two strings. You can use a 2D array to store the lengths of subproblems:\n\nHere, represents the length of the longest common subsequence between and . By filling the array in a specific order, we ensure that each subproblem has the necessary previous solutions.\n\nIf you‘re coming from a language like Python, you might be used to more concise 2D array creation and manipulation. For example, in Python you can create a 2D array of zeros like this:\n\nIn JavaScript, you‘d need to use nested loops or as shown earlier.\n\nHowever, JavaScript‘s flexibility with jagged arrays and the ability to mix data types within an array can be advantageous in certain scenarios, like building a JSON object from diverse data sources.\n\nIt‘s important to adapt your mental model to the specifics of each language while being aware of the underlying concepts.\n\nWhen working with 2D arrays, it‘s crucial to have a robust testing and debugging strategy. Some tips:\n• Edge Cases: Always test the boundaries of your arrays – empty arrays, single-element arrays, and arrays with inconsistent row lengths. Make sure your code handles these gracefully.\n• Visual Debugging: When dealing with complex grid-like structures, it can be helpful to print your arrays in a visually appealing format. Consider writing a helper function that formats your array as a grid string for easier visualization.\n• Unit Tests: Write unit tests for your 2D array operations, covering a wide range of inputs and expected outputs. This helps catch regressions and ensures the reliability of your code.\n• Performance Testing: If you‘re working with large arrays, profile your code to identify performance bottlenecks. Tools like Chrome DevTools or Node.js‘s built-in profiler can help pinpoint slow operations.\n\nWhile vanilla JavaScript provides all the necessary tools for working with 2D arrays, there are several libraries and frameworks that can make your life easier:\n• NumPy: If you‘re doing heavy numerical computations, consider using NumPy, a library for working with large, multi-dimensional arrays. While not native to JavaScript, it can be used via transpilation with tools like Transcrypt or by running Python code on the server.\n• TensorFlow.js: For machine learning applications, TensorFlow.js provides a high-level API for manipulating tensors, which are essentially multi-dimensional arrays.\n• Two.js: If you‘re working with 2D graphics, Two.js is a lightweight library that provides an abstraction layer over SVG, Canvas, and WebGL.\n• D3.js: For data visualization, D3.js provides a rich ecosystem of tools for manipulating and visualizing arrays of data.\n\nWhile it‘s always beneficial to understand the underlying concepts, don‘t hesitate to leverage existing tools to boost your productivity.\n\n2D arrays are a fundamental data structure in JavaScript, powering a wide range of applications from gaming to data visualization. By understanding how to create, access, and manipulate 2D arrays, you‘ll be well-equipped to tackle complex data structures and algorithms.\n\nRemember to keep your code clean, modular, and well-tested. Leverage libraries and frameworks when appropriate, but always strive to understand the underlying concepts.\n\nAs a full-stack developer, mastering 2D arrays is just one piece of the puzzle. But it‘s a crucial skill that will serve you well across the stack, from optimizing database queries on the back-end to rendering complex grids on the front-end.\n\nSo go forth and conquer those arrays! And always keep learning and exploring new ways to work with data in JavaScript."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
        "document": "objects cannot use arbitrary strings as element indexes (as in an associative array) but must use nonnegative integers (or their respective string form). Setting or accessing via non-integers will not set or retrieve an element from the array list itself, but will set or access a variable associated with that array's object property collection. The array's object properties and list of array elements are separate, and the array's traversal and mutation operations cannot be applied to these named properties. Array elements are object properties in the same way that is a property (to be specific, however, is a method). Nevertheless, trying to access an element of an array as follows throws a syntax error because the property name is not valid: JavaScript syntax requires properties beginning with a digit to be accessed using bracket notation instead of dot notation. It's also possible to quote the array indices (e.g., instead of ), although usually not necessary. The in is coerced into a string by the JavaScript engine through an implicit conversion. As a result, and would refer to two different slots on the object, and the following example could be : Only is an actual array index. is an arbitrary string property that will not be visited in array iteration.\n\nMany array methods take a callback function as an argument. The callback function is called sequentially and at most once for each element in the array, and the return value of the callback function is used to determine the return value of the method. They all share the same signature: The current element being processed in the array. The index of the current element being processed in the array. The array that the method was called upon. What is expected to return depends on the array method that was called. The argument (defaults to ) will be used as the value when calling . The value ultimately observable by is determined according to the usual rules: if is non-strict, primitive values are wrapped into objects, and / is substituted with . The argument is irrelevant for any defined with an arrow function, as arrow functions don't have their own binding. The argument passed to is most useful if you want to read another index during iteration, because you may not always have an existing variable that refers to the current array. You should generally not mutate the array during iteration (see mutating initial array in iterative methods), but you can also use this argument to do so. The argument is not the array that is being built, in the case of methods like , , and — there is no way to access the array being built from the callback function. All iterative methods are copying and generic, although they behave differently with empty slots. The following methods are iterative: , , , , , , , , , and . In particular, , , , , , and do not always invoke on every element — they stop iteration as soon as the return value is determined. The and methods also take a callback function and run it at most once for each element in the array, but they have slightly different signatures from typical iterative methods (for example, they don't accept ). The method also takes a callback function, but it is not an iterative method. It mutates the array in-place, doesn't accept , and may invoke the callback multiple times on an index. Iterative methods iterate the array like the following (with a lot of technical details omitted): function method(callbackFn, thisArg) { const length = this.length; for (let i = 0; i < length; i++) { if (i in this) { const result = callbackFn.call(thisArg, this[i], i, this); // Do something with result; maybe return early } } }\n• Not all methods do the test. The , , , and methods do not, but other methods do.\n• The is memorized before the loop starts. This affects how insertions and deletions during iteration are handled (see mutating initial array in iterative methods).\n• The method doesn't memorize the array contents, so if any index is modified during iteration, the new value might be observed.\n• The code above iterates the array in ascending order of index. Some methods iterate in descending order of index ( ): , , and .\n• and have slightly different signatures and do not always start at the first/last element.\n\nArray methods are always generic — they don't access any internal data of the array object. They only access the array elements through the property and the indexed elements. This means that they can be called on array-like objects as well. The property is converted to an integer and then clamped to the range between 0 and 253 - 1. becomes , so even when is not present or is , it behaves as if it has value . The language avoids setting to an unsafe integer. All built-in methods will throw a if will be set to a number greater than 253 - 1. However, because the property of arrays throws an error if it's set to greater than 232 - 1, the safe integer threshold is usually not reached unless the method is called on a non-array object. Some array methods set the property of the array object. They always set the value after normalization, so always ends as an integer. The term array-like object refers to any object that doesn't throw during the conversion process described above. In practice, such object is expected to actually have a property and to have indexed elements in the range to . (If it doesn't have all indices, it will be functionally equivalent to a sparse array.) Any integer index less than zero or greater than is ignored when an array method operates on an array-like object. Many DOM objects are array-like — for example, and . The object is also array-like. You can call array methods on them even if they don't have these methods themselves.\n\nReturns the array item at the given index. Accepts negative integers, which count back from the last item. Returns a new array that is the calling array joined with other array(s) and/or value(s). Copies a sequence of array elements within an array. Returns a new array iterator object that contains the key/value pairs for each index in an array. Returns if every element in the calling array satisfies the testing function. Fills all the elements of an array from a start index to an end index with a static value. Returns a new array containing all elements of the calling array for which the provided filtering function returns . Returns the value of the first element in the array that satisfies the provided testing function, or if no appropriate element is found. Returns the index of the first element in the array that satisfies the provided testing function, or if no appropriate element was found. Returns the value of the last element in the array that satisfies the provided testing function, or if no appropriate element is found. Returns the index of the last element in the array that satisfies the provided testing function, or if no appropriate element was found. Returns a new array with all sub-array elements concatenated into it recursively up to the specified depth. Returns a new array formed by applying a given callback function to each element of the calling array, and then flattening the result by one level. Calls a function for each element in the calling array. Determines whether the calling array contains a value, returning or as appropriate. Returns the first (least) index at which a given element can be found in the calling array. Joins all elements of an array into a string. Returns a new array iterator that contains the keys for each index in the calling array. Returns the last (greatest) index at which a given element can be found in the calling array, or if none is found. Returns a new array containing the results of invoking a function on every element in the calling array. Removes the last element from an array and returns that element. Adds one or more elements to the end of an array, and returns the new of the array. Executes a user-supplied \"reducer\" callback function on each element of the array (from left to right), to reduce it to a single value. Executes a user-supplied \"reducer\" callback function on each element of the array (from right to left), to reduce it to a single value. Reverses the order of the elements of an array in place. (First becomes the last, last becomes first.) Removes the first element from an array and returns that element. Extracts a section of the calling array and returns a new array. Returns if at least one element in the calling array satisfies the provided testing function. Sorts the elements of an array in place and returns the array. Returns a localized string representing the calling array and its elements. Overrides the method. Returns a new array with the elements in reversed order, without modifying the original array. Returns a new array with the elements sorted in ascending order, without modifying the original array. Returns a new array with some elements removed and/or replaced at a given index, without modifying the original array. Returns a string representing the calling array and its elements. Overrides the method. Adds one or more elements to the front of an array, and returns the new of the array. Returns a new array iterator object that contains the values for each index in the array. Returns a new array with the element at the given index replaced with the given value, without modifying the original array. An alias for the method by default.\n\nIterative methods do not mutate the array on which it is called, but the function provided as can. The key principle to remember is that only indexes between 0 and are visited, where is the length of the array at the time the array method was first called, but the element passed to the callback is the value at the time the index is visited. Therefore:\n• will not visit any elements added beyond the array's initial length when the call to the iterative method began.\n• Changes to already-visited indexes do not cause to be invoked on them again.\n• If an existing, yet-unvisited element of the array is changed by , its value passed to the will be the value at the time that element gets visited. Removed elements are not visited. Warning: Concurrent modifications of the kind described above frequently lead to hard-to-understand code and are generally to be avoided (except in special cases). The following examples use the method as an example, but other methods that visit indexes in ascending order work in the same way. We will first define a helper function: Modification to indexes not visited yet will be visible once the index is reached: Modification to already visited indexes does not change iteration behavior, although the array will be different afterwards: Inserting n elements at unvisited indexes that are less than the initial array length will make them be visited. The last n elements in the original array that now have index greater than the initial array length will not be visited: testSideEffect((arr, index) => { if (index === 1) arr.splice(2, 0, \"new\"); }); // array: [e1, e2, e3, e4], index: 0, elem: e1 // array: [e1, e2, e3, e4], index: 1, elem: e2 // array: [e1, e2, new, e3, e4], index: 2, elem: new // array: [e1, e2, new, e3, e4], index: 3, elem: e3 // Final array: [e1, e2, new, e3, e4] // e4 is not visited because it now has index 4 Inserting n elements with index greater than the initial array length will not make them be visited: testSideEffect((arr) => arr.push(\"new\")); // array: [e1, e2, e3, e4], index: 0, elem: e1 // array: [e1, e2, e3, e4, new], index: 1, elem: e2 // array: [e1, e2, e3, e4, new, new], index: 2, elem: e3 // array: [e1, e2, e3, e4, new, new, new], index: 3, elem: e4 // Final array: [e1, e2, e3, e4, new, new, new, new] Inserting n elements at already visited indexes will not make them be visited, but it shifts remaining elements back by n, so the current index and the n - 1 elements before it are visited again: testSideEffect((arr, index) => arr.splice(index, 0, \"new\")); // array: [e1, e2, e3, e4], index: 0, elem: e1 // array: [new, e1, e2, e3, e4], index: 1, elem: e1 // array: [new, new, e1, e2, e3, e4], index: 2, elem: e1 // array: [new, new, new, e1, e2, e3, e4], index: 3, elem: e1 // Final array: [new, new, new, new, e1, e2, e3, e4] // e1 keeps getting visited because it keeps getting shifted back Deleting n elements at unvisited indexes will make them not be visited anymore. Because the array has shrunk, the last n iterations will visit out-of-bounds indexes. If the method ignores non-existent indexes (see array methods and empty slots), the last n iterations will be skipped; otherwise, they will receive : testSideEffect((arr, index) => { if (index === 1) arr.splice(2, 1); }); // array: [e1, e2, e3, e4], index: 0, elem: e1 // array: [e1, e2, e3, e4], index: 1, elem: e2 // array: [e1, e2, e4], index: 2, elem: e4 // Final array: [e1, e2, e4] // Does not visit index 3 because it's out-of-bounds // Compare this with find(), which treats nonexistent indexes as undefined: const arr2 = [\"e1\", \"e2\", \"e3\", \"e4\"]; arr2.find((elem, index, arr) => { console.log(`array: [${arr.join(\", \")}], index: ${index}, elem: ${elem}`); if (index === 1) arr.splice(2, 1); return false; }); // array: [e1, e2, e3, e4], index: 0, elem: e1 // array: [e1, e2, e3, e4], index: 1, elem: e2 // array: [e1, e2, e4], index: 2, elem: e4 // array: [e1, e2, e4], index: 3, elem: undefined Deleting n elements at already visited indexes does not change the fact that they were visited before they get deleted. Because the array has shrunk, the next n elements after the current index are skipped. If the method ignores non-existent indexes, the last n iterations will be skipped; otherwise, they will receive : testSideEffect((arr, index) => arr.splice(index, 1)); // array: [e1, e2, e3, e4], index: 0, elem: e1 // Does not visit e2 because e2 now has index 0, which has already been visited // array: [e2, e3, e4], index: 1, elem: e3 // Does not visit e4 because e4 now has index 1, which has already been visited // Final array: [e2, e4] // Index 2 is out-of-bounds, so it's not visited // Compare this with find(), which treats nonexistent indexes as undefined: const arr2 = [\"e1\", \"e2\", \"e3\", \"e4\"]; arr2.find((elem, index, arr) => { console.log(`array: [${arr.join(\", \")}], index: ${index}, elem: ${elem}`); arr.splice(index, 1); return false; }); // array: [e1, e2, e3, e4], index: 0, elem: e1 // array: [e2, e3, e4], index: 1, elem: e3 // array: [e2, e4], index: 2, elem: undefined // array: [e2, e4], index: 3, elem: undefined For methods that iterate in descending order of index, insertion causes elements to be skipped, and deletion causes elements to be visited multiple times. Adjust the code above yourself to see the effects."
    },
    {
        "link": "https://medium.com/jeremy-gottfrieds-tech-blog/algorithms-common-edge-cases-in-js-ce35a2d47674",
        "document": "Algorithms are the bedrock of computer programming. Algorithms are built to handle specific data structures with a range of accepted parameters. An edge case is a problem or situation that occurs only at an extreme (maximum or minimum) operating parameter. As programmers, how can we predict these cases in order to protect our app from breaking?\n\nI will demonstrate some common edge cases in a basic bubble sort algorithm:\n\nThe first major edge case is the unaccepted data structure. My bubble sort algorithm only works predictably for arrays. Javascript will not prevent you from inputting other data structures in the function, such as normal objects. For example, what happens if I input this object:\n\nThis will do some very strange things inside the for loop, but ultimately, our algorithm will return the original object.\n\nThat may not be what we want! If the algorithm is going to be truly fool proof, we should test that our data structure is an array, and handle it somehow. Here I will return so that we can handle unwanted data structures as an error in our program:\n\nThis will also return false for falsey values like null or undefined.\n\nAn empty array would not break this specific sorting algorithm, but empty values are something important to look out for:\n\nIn the context of many programs, we want to handle an empty array differently so that it doesn’t break something in our program further down the line:\n\nFor algorithms that accept different data structures and types, we should also look out for emptiness. Here are some common ones:\n\nIf our algorithm iterates through nested data structures, we may also want to check for nested emptiness like this:\n\nThe next big case to test for is accepted types inside our array. Our bubbleSort algorithm sorts strings based on their Unicode values. That means that capital letters will go before lowercase:\n\nIf we want the algorithm to sort strings independent of capitalization, we may want to handle that:\n\nAnother case you may want to handle are string numbers vs normal numerical values. Here is one strange example of this:\n\nIn the case of two equal numbers, where one is a string, the only operator that evaluates to true is . It gets even more tricky if there is a letter in the numerical string.\n\nThis could lead to some strange results in our sorting algorithm. Therefore, we may want to only accept numbers and not strings, or handle the different types separately.\n\nAnother type to be aware of is the boolean value. is loosely equal to while is loosely equal to .\n\nWe may not want to allow boolean values in our algorithm, especially if we are sorting an array of strings. This includes falsey values like and , which will all act strange when passed into a comparison operator.\n\nThe falsey data types all act differently in the comparison operators:\n\nYou may want to exclude these from your sorting algorithm. is probably the strangest, where it approaches zero but does not equal 0 and is not greater than 0, but it can be coerced by to be equal to undefined.\n\nLuckily, Javascript has a way of forcefully making falsey data types become equal to each other and false. Simply append double exclamation points onto any of them.\n\nThis has to do with the coercion algorithms in Javascript and how different falsey values are stored in memory. More on this here: http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3. and here: http://www.ecma-international.org/ecma-262/5.1/#sec-11.8.5\n\nIn our case, we should be looking out for extremely large arrays. What happens if our function is given an array with length greater than 1 x 10¹⁰⁰?\n\nHere is where Big O notation comes in.\n\nBig O complexity is a measure of algorithm efficiency. It makes a big difference when we are dealing with large data sets. Big O has two variables — time and memory space. Memory is important because it can be break our algorithm if large amounts of data are passed as parameters. Every computer program stores data in stack and heap memory. Stack memory is much faster to access but there’s less of it. How does this relate to algorithms?\n\nLet’s answer this with two versions of bubble sort, recursive and iterative —\n\nThese two examples use the same exact algorithm, but the memory is handled differently. The recursive version of the algorithm uses stack memory, and will therefore break with a stack overflow error if the length of the array is very large. This is because the stack keeps track of every call of until the original call resolves. The iterative version of the function doesn’t face stack overflow issues.\n\nIn theory, the recursive version shouldn’t face memory issues either. Many lower level languages allow something called tail-call optimization, which makes it possible to to write recursive functions with 0(1) memory complexity. Until recently, JS did not allow tail call optimization, but in ECMAScript 6 you can enable it in strict mode. Simply type at the top of the file, and you will be able to write recursively without running into stack overflow errors.\n\nJust make sure that your recursive function calls are written in the last line, or tail, of your function like in the function below.\n\n5. Some other edge cases to keep in mind"
    }
]