[
    {
        "link": "https://javadoc.io/doc/com.fasterxml.jackson.core/jackson-annotations/latest/com/fasterxml/jackson/annotation/JsonInclude.Include.html",
        "document": ""
    },
    {
        "link": "https://javadoc.io/doc/com.fasterxml.jackson.core/jackson-annotations/2.10.0.pr2/com/fasterxml/jackson/annotation/JsonInclude.html",
        "document": ""
    },
    {
        "link": "https://github.com/FasterXML/jackson-docs/wiki/Presentation-Jackson-2.0",
        "document": "Jackson 2.0 is the first Major release after official 1.x versions. As the major version bump indicates, 2.0 is the first official release that is NOT fully backwards compatible.\n\nThis presentation gives an overview of changes that occured between versions 1.9 and 2.0.\n\nAlthough progression from 1.9 to 2.0 seems natural from \"increasing numbers\" perspective, we did actually seriously consider going to 1.10 and possibly more versions, with the usual rules of backwards compatibility.\n\nBut after so many minor releases, Jackson had accumulated some technical debt, in form of deprecated methods, as well as many non-intuitive naming choices and non-optimal packaging decisions. Further, external developments like awesomeness of GitHub and steady improvement of Maven build system were suggesting that we might want to improve building and release management aspects as well; changes that would cause some backwards-compatibility issues of their own.\n\nNone of the issues alone would have been sufficient to justify break from expected compatibility (in our opinion); but taken as whole, it seemed like time would be ripe to make a clean break, to pay down most of the technical debt.\n\nThe rough summary of clean-up changes that started Jackson 2.0 development is:\n• 3 Core Jackson projects: Streaming API, (http://wiki.fasterxml.com/JacksonDataBinding) and (core annotations; used to be bundled with \"core\", in 1.x)\n• Simplifies releases significantly; can deploy to Sonatype OSS Maven repository (which syncs to central Maven repo)\n• Remove ALL methods, types, annotations that were deprecated in 1.9!\n• Rename Java packages, mostly to allow 1.x and 2.0 to co-exist; in some cases to make more intuitive\n• Rename a small number of misnamed classes (for example as )\n• Move couple of classes to clean up package structure (split \"too big\" packages)\n\nThroughout development of Jackson 1.x, one feature proved too hard to solve: that of automatically serializing and deserializing object graphs that may contain cyclic references. Although partial solutions have been added -- Jackson 1.6 added support for so-called back references, which allows handling of parent/child type of references -- they have limited applicability.\n\nOne big part of the problem is figuring out what inclusion mechanism to use: since JSON does not have 'natural' mechanism for embedding metadata (XML, for example, makes it somewhat natural to use attributes for metadata, and elements for data), one has to consider carefully details of adding metadata (like Object Id) along with actual data (object properties).\n\nWith 2.0, we decided to go back to the drawing board and think of existing features that might help model Object Identity; and realized that the closest applicable is the way that Type Information is handled. As a result, one new annotation -- -- was added to indicate types of Objects for which Object Identity handling is enabled, as well as details of how Id values are produced.\n\nThe way @JsonIdentityInfo works is as follows:\n• Object Id is always included as a property (with configurable name). This means that output shape must be JSON Object; and means that currently identity of Java Collections, Arrays and Maps can not be handled\n• First instance of an Object is serialized completely (including Object Id); further references are serialized using Object Id itself\n• Object ids can be either (Jackson creates ids on the fly), as either s or sequence numbers ( s); or , in which case Object itself provides the value through property (field value or getter).\n\nAn example annotation looks like:\n\nand could produce JSON output like:\n\nfor case where two objects were referencing each other.\n\nThis case uses 'generated' id, using basic sequence: the main difference from 'provided' case is that the \"id property\" that annotation presents does NOT have actual property in class. An alternative POJO definition could be:\n\nin which case class itself needs to provide the id value, and Jackson will use it as-is.\n\nLimitations to handling are currently:\n• Types handled must be POJOs; Collections, arrays and Maps can not use Object Identity currently\n• It may be possible to add support for these types in future (tricky, but possible)\n• No \"default Object Id\" (unlike with Type Ids): each type must be annotated, directly or using mix-ins; or use custom to indicate types for which Object Ids are to be used\n\nBuilder-style of construction has been gaining popularity in Java world; Jackson itself uses similar approach for creating and configuring and instances.\n\nAn example of how to support Builder-style construction:\n\nso the important thing is to add annotation in POJO being created; and it needs to point to Builder class. The default naming convention assumes \"withXxx()\" method, but this is configurable.\n\nJackson 1.x only supported use of JSON Views for serialization: 2.0 adds symmetric support for deserialization; active view defined via (similar to for serialization)\n\nUsage can look like:\n\nwhich also demonstrates New and Improved way to construct and configure s (and works similarly).\n\nOne simple but \"ergonomic\" improvement is ability to use meta-annotation, which causes target annotation to be consider a \"bundle\", meaning that annotations it has will be applied as if they were directly used on the target class. End result is that you can basically create your own annotations to be used in place of a set of Jackson annotations, to simplify configuration as well as to hide direct Jackson annotation dependencies.\n\nand then you can do:\n\nAnnotation was added in 1.9, but a significant new addition is inclusion of \"prefix\" and \"suffix\" properties. They can be used like:\n\nWith 2.0 version of JAX-RS JSON Provider, it is finally possible to use some annotations on JAX-RS Resource methods:\n• (core Jackson annotation) can be used to define JSON View to use for serialization, deserialization\n• annotation, provided by module, can be used to indicate whether JSONP is used for serialization, and configuring how (method name to use)\n• can be used to explicitly enable and/or disable and setting.\n• Use it like this:\n\nIn addition to allowing ignoring of specific properties when serializing/deserializing particular class, it is now possibly to add additional properties to be excluded when serializing POJO-valued properties:\n\nannotation will be added to list of properties to ignore for the value type (if any).\n\nStarting with 2.0, it is finally possible to configure and settings on per-call basis, cleanly and safely. But additionally everything that is dynamically changeable (meaning changing effects actual operation -- some things are not dynamically changeable as they change actual cached serializers; one example being mix-in annotations) can now be changed with methods that and add.\n\nFor example; to write \"JAXB compatible\" structure, where root-name wrapping is used (but only on some cases), you could do:\n\nand get expected results. Check out Javadocs for all the options.\n\nAnother nice if minor improvement is the ability to let (custom) implementations to determine whether a given value is considered \"empty\", for purpose of optional filtering of empty values. By default null references are considered empty, as well as a small number of general cases (empty s, arrays, s). But this extension mechanism can be used to support any other type that has some concept of \"empty\".\n\nAlthough Jackson 1.x had introduced some non-JSON backends (notably Smile and XML), one significant area for improvement for 2.0 API was to support even wider range of alternate data formats.\n\nHere is a high-level overview of all data formats that Jackson 2.0 supports, either directly or via extension modules\n• Smile (since 1.6) -- 100% feature parity, compatibility with JSON at Streaming API level\n• Very mature, stable; extensive production deployments (used by Elastic Search, for example)\n• BSON (since ~1.7): support for BSON, JSON-like data format used by MongoDB\n• external project (not under FasterXML), implemented by Michel Kramer (with help from Jackson team)\n• Builds on standard STAX API: i.e. parsing/generation using Woodstox or Aalto\n• High-performance, slightly faster than JAXB (using same underlying parser/generator), although not up to JSON speed (+50% time spent?)\n• Is being adopted more and more: XML is the most challenging \"non-JSON\" format to support, but we are getting there as a good alternative to JAXB\n• Due to XML/JSON impedance, requires use of , in addition to -- also means that use of Streaming API with XML is not necessarily useful (just use standard XML STAX API)\n• Reasonably efficient: limited testing suggests speed similar to XML or better (much due to more compact output)\n• Requires use of new object, which simply defines Name/Column mapping; can construct from POJO, or programmatically\n• YAML (since 2.0): uses SnakeYAML library for parsing.\n• Newest addition: relatively easy addition, should be more mature than age implies\n• Performance significant lower than that of JSON, XML or CSV: limited by SnakeYAML which works well, correctly, but not very efficiently.\n• Avro? (we have some ideas, project)\n• Thrift? (possible -- interesting to see if IDL could be reused)"
    },
    {
        "link": "https://github.com/FasterXML/jackson-annotations",
        "document": "This project contains general purpose annotations for Jackson Data Processor, used on value and handler types. The only annotations not included are ones that require dependency to the Databind package. Note that only annotations themselves (and related value classes) are included, but no functionality that uses annotations.\n\nProject contains versions 2.0 and above: source code for earlier (1.x) versions is available from Jackson-1 repository.\n\nFull Listing of Jackson Annotations details all available annotations; Project Wiki gives more details.\n\nIn addition to regular usage (see below), there are couple of noteworthy improvements Jackson does:\n• Mix-in annotations allow associating annotations on third-party classes ''without modifying classes''.\n• Jackson annotations support full inheritance: meaning that you can ''override annotation definitions'', and not just class annotations but also method/field annotations!\n• Jackson annotations will also be inherited from interfaces:\n• precedence between base class and implemented interfaces is such that base-class has lower precedence than interfaces;\n• if multiple interfaces are implemented, then the precedence depends on the order as returned by the JVM.\n\nAll annotations are in Java package . To use annotations, you need to use Maven dependency:\n\nor download jars from Maven repository (or via quick links on Wiki)\n\nLet's start with simple use cases: renaming or ignoring properties, and modifying types that are used.\n\nNote: while examples only show field properties, same annotations would work with method (getter/setter) properties.\n\nOne of most common tasks is to change JSON name used for a property: for example:\n\nwould result in JSON like:\n\nSometimes POJOs contain properties that you do not want to write out, so you can do:\n\nand get JSON like:\n\nor, you may get properties in JSON that you just want to skip: if so, you can use:\n\nwhich would be able to handle JSON like:\n\nFinally, you may even want to just ignore any \"extra\" properties from JSON (ones for which there is no counterpart in POJO). This can be done by adding:\n\nSometimes the type Jackson uses when reading or writing a property is not quite what you want:\n• When reading (deserializing), declared type may be a general type, but you know which exact implementation type to use\n• When writing (serializing), Jackson will by default use the specific runtime type; but you may not want to include all information from that type but rather just contents of its supertype.\n\nThese cases can be handled by following annotations:\n\nBy default, Jackson tries to use the \"default\" constructor (one that takes no arguments), when creating value instances. But you can also choose to use another constructor, or a static factory method to create instance. To do this, you will need to use annotation , and possibly annotations to bind names to arguments:\n\ncan be used similarly for static factory methods. But there is also an alternative usage, which is so-called \"delegating\" creator:\n\nthe difference being that the creator method can only take one argument, and that argument must NOT have annotation.\n\nIf you need to read and write values of Objects where there are multiple possible subtypes (i.e. ones that exhibit polymorphism), you may need to enable inclusion of type information. This is needed so that Jackson can read back correct Object type when deserializing (reading JSON into Objects). This can be done by adding annotation on ''base class'':\n\nwhich gives serialized JSON like:\n\nAlternatively, can be used to avoid requiring the 'type' field. For deserialization, types are deduced based on the fields available. Exceptions will be raised if subtypes do not have a distinct signature of fieldnames or JSON does not resolve to single known signature.\n\nNote that has lots of configuration possibilities: for more information check out Intro to polymorphic type handling\n• All setters ('setXxx(value)' methods), ''regardless of visibility'')\n\nBut if this does not work, you can change visibility levels by using annotation . If you wanted, for example, to auto-detect ALL fields (similar to how packages like GSON work), you could do:\n\nor, to disable auto-detection of fields altogether:\n\nJackson components are supported by the Jackson community through mailing lists, Gitter forum, Github issues. See Participation, Contributing for full details.\n\nAvailable as part of the Tidelift Subscription.\n\nThe maintainers of and thousands of other packages are working with Tidelift to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use. Learn more.\n• Full Listing of Jackson Annotations details all available annotations.\n• You can make Jackson 2 use Jackson 1 annotations with jackson-legacy-introspector\n• Databinding module has more documentation, since it is the main user of annotations."
    },
    {
        "link": "https://fasterxml.github.io/jackson-annotations/javadoc/2.11/com/fasterxml/jackson/annotation/JsonInclude.html",
        "document": "Annotation used to indicate when value of the annotated property (when used for a field, method or constructor parameter), or all properties of the annotated class, is to be serialized. Without annotation property values are always included, but by using this annotation one can specify simple exclusion rules to reduce amount of properties to write out.\n\nNote that the main inclusion criteria (one annotated with ) is checked on Java object level, for the annotated type, and NOT on JSON output -- so even with it is possible that JSON null values are output, if object reference in question is not `null`. An example is instance constructed to reference value: such a value would be serialized as JSON null, and not filtered out.\n\nTo base inclusion on value of contained value(s), you will typically also need to specify annotation; for example, specifying only as for a {link java.util.Map} would exclude s with no values, but would include s with `null` values. To exclude Map with only `null` value, you would use both annotations like so:\n\nSimilarly you could Maps that only contain \"empty\" elements, or \"non-default\" values (see and for more details).\n\nIn addition to `Map`s, `content` concept is also supported for referential types (like ). Note that `content` is NOT currently (as of Jackson 2.9) supported for arrays or s, but supported may be added in future versions."
    },
    {
        "link": "https://stackoverflow.com/questions/9112900/jackson-how-to-prevent-field-serialization",
        "document": "I have an entity class with a password field:\n\nI want this field to be skipped during serialization. But it should still be able to deserialize. This is needed, so that the client can send me a new password, but is not able to read the current one.\n\nHow do I accomplish this with Jackson?"
    },
    {
        "link": "https://baeldung.com/jackson-ignore-properties-on-serialization",
        "document": "This tutorial will show how to ignore certain fields when serializing an object to JSON using Jackson 2.x.\n\nThis is very useful when the Jackson defaults aren’t enough and we need to control exactly what gets serialized to JSON — and there are several ways to ignore properties.\n\nTo dig deeper and learn other cool things we can do with Jackson, head on over to the main Jackson tutorial.\n\nWe can ignore specific fields at the class level, using the @JsonIgnoreProperties annotation and specifying the fields by name:\n\nWe can now test that, after the object is written to JSON, the field is indeed not part of the output:\n\nWe can also ignore a field directly via the @JsonIgnore annotation directly on the field:\n\nWe can now test that the intValue field is indeed not part of the serialized JSON output:\n\nFinally, we can ignore all fields of a specified type, using the @JsonIgnoreType annotation. If we control the type, then we can annotate the class directly:\n\nMore often than not, however, we don’t have control of the class itself. In this case, we can make good use of Jackson mixins.\n\nFirst, we define a MixIn for the type we’d like to ignore and annotate that with @JsonIgnoreType instead:\n\nThen we register that mixin to replace (and ignore) all String[] types during marshalling:\n\nAt this point, all String arrays will be ignored instead of marshalled to JSON:\n\nAnd here is our DTO:\n\nNote: Since version 2.5, it seems that we can’t use this method to ignore primitive data types, but we can use it for custom data types and arrays.\n\nFinally, we can also use filters to ignore specific fields in Jackson.\n\nFirst, we need to define the filter on the Java object:\n\nThen we define a simple filter that will ignore the intValue field:\n\nNow we can serialize the object and make sure that the intValue field is not present in the JSON output:\n\nThis article illustrated how to ignore fields on serialization. We did this first by name and then directly, and finally, we ignored the entire java type with MixIns and used filters for more control of the output."
    },
    {
        "link": "https://stackoverflow.com/questions/12505141/only-using-jsonignore-during-serialization-but-not-deserialization",
        "document": "Exactly how to do this depends on the version of Jackson that you're using. This changed around version 1.9, before that, you could do this by adding to the getter.\n\nDo this, and also add a specific annotation for your JSON \"password\" field name to the setter method for the password on your object.\n\nMore recent versions of Jackson have added and annotation arguments for . So you could also do something like:\n\nDocs can be found here."
    },
    {
        "link": "https://iamvickyav.medium.com/spring-boot-dynamically-ignore-fields-while-converting-java-object-to-json-e8d642088f55",
        "document": "Lets consider we have a RestController class which has two endpoints to expose User & List<User>\n\nSince id & dob fields in User object are sensitive, we don’t want to expose them in our endpoints.\n\nJackson library provides @JsonIgnore & @JsonIgnoreProperties annotations to ignore fields while serializing\n\nOne catch with @JsonIgnore & @JsonIgnoreProperties annotations are — They expect field names in compile time itself. But what if our consumer want to ignore few fields dynamically based on their input ?\n\nWe can use MappingJacksonValue class to achieve the above requirement\n\nHere is the sample code\n• Properties which are to be ignored is supplied to SimpleBeanPropertyFilter.serializeAllExcept(“id”, “dob”). This can be easily made dynamic based on user input\n• Filter name mentioned in SimpleFilterProvider() .addFilter(“userFilter”, simpleBeanPropertyFilter) has to match filer name provided in @JsonFilter(“userFilter”) annotation on User class\n• We need to return MappingJacksonValue instance instead of User or List<User> (Refer line 19 & line 34)"
    },
    {
        "link": "https://mkyong.com/java/how-to-ignore-a-field-with-jackson",
        "document": "In Jackson, we can use to ignore a single field, to ignore multiple fields and to ignore a specified type during JSON serialization and deserialization.\n\nThe annotation is used directly on the field or getter/setter to ignore it during JSON serialization and deserialization.\n\nThe annotation is used at the class level to ignore multiple fields by name.\n\nThe annotation is used on a class definition to automatically ignore all fields of this class.\n• How to parse JSON string with Jackson\n• How to ignore null fields with Jackson"
    }
]