[
    {
        "link": "https://geeksforgeeks.org/trapping-rain-water",
        "document": "Trapping Rainwater Problem states that given an array of n non-negative integers arr[] representing an elevation map where the width of each bar is 1, compute how much water it can trap after rain.\n\nInput: arr[] = [3, 0, 1, 0, 4, 0, 2]\n\nOutput: 10\n\nExplanation: The expected rainwater to be trapped is shown in the above image. Input: arr[] = [1, 2, 3, 4]\n\nOutput: 0\n\nExplanation: We cannot trap water as there is no height bound on both sides\n\nThe basic intuition of the problem is as follows:\n• None An element of the array can store water if there are higher bars on the left and the right.\n• None The amount of water to be stored in every position can be found by finding the heights of the higher bars on the left and right sides.\n• None The total amount of water stored is the summation of the water stored in each index.\n• None No water can be filled if there is no boundary on both sides.\n\n[Naive Approach] Find left and right max for each index – O(n^2) Time and O(1) Space\n\nTraverse every array element and find the highest bars on the left and right sides. Take the smaller of two heights. The difference between the smaller height and the height of the current element is the amount of water that can be stored in this array element.\n\n// Function to return the maximum water that can be stored // For every element of the array // Find the maximum element on its left // Find the maximum element on its right // Function to return the maximum water that can be stored // For every element of the array // Find the maximum element on its left // Find the maximum element on its right // Function to return the maximum water that can be stored // For every element of the array // Find the maximum element on its left // Find the maximum element on its right # Function to return the maximum water that can be stored # For every element of the array # Find the maximum element on its left # Find the maximum element on its right // Function to return the maximum water that can be stored // For every element of the array // Find the maximum element on its left // Find the maximum element on its right // Function to return the maximum water that can be stored // For every element of the array // Find the maximum element on its left // Find the maximum element on its right\n\n[Better Approach] Prefix and suffix max for each index – O(n) Time and O(n) Space\n\n// Left[i] contains height of tallest bar to the // Right[i] contains height of tallest bar to // the right of i'th bar including itself // Left[i] contains height of tallest bar to the // Right[i] contains height of tallest bar to // the right of i'th bar including itself // Left[i] contains height of tallest bar to the // Right[i] contains height of tallest bar to // the right of i'th bar including itself # Left[i] contains height of tallest bar to the # Right[i] contains height of tallest bar to # the right of i'th bar including itself // Left[i] contains height of tallest bar to the // Right[i] contains height of tallest bar to // the right of i'th bar including itself // Left[i] contains height of tallest bar to the // Right[i] contains height of tallest bar to // the right of i'th bar including itself\n\n[Expected Approach] Using Two Pointers – O(n) Time and O(1) Space\n\nThe approach is mainly based on the following facts:\n• None If we consider a subarray arr[left…right], we can decide the amount of water either for arr[left] or arr[right] if we know the left max (max element in arr[0…left-1]) and right max (max element in arr[right+1…n-1].\n• None If left max is less than the right max, then we can decide for arr[left]. Else we can decide for arr[right]\n• None If we decide for arr[left], then the amount of water would be left max – arr[left] and if we decide for arr[right], then the amount of water would be right max – arr[right].\n\nHow does this work? Let us consider the case when left max is less than the right max. For arr[left], we know left max for it and we also know that the right max for it would not be less than left max because we already have a greater value in arr[right…n-1]. So for the current bar, we can find the amount of water by finding the difference between the current bar and the left max bar.\n\n// If rMax is smaller, then we can decide the amount of water for arr[right] // Update right pointer as we have decided the amount of water for this // Update left pointer as we have decided water for this // If rMax is smaller, then we can decide the amount of water for arr[right] // Update right pointer as we have decided the amount of water for this // Update left pointer as we have decided water for this // If rMax is smaller, then we can decide the amount of water for arr[right] // Update right pointer as we have decided the amount of water for this // Update left pointer as we have decided water for this # If rMax is smaller, then we can decide the # Update right pointer as we have decided # the amount of water for this # Update left pointer as we have decided # the amount of water for this // If rMax is smaller, then we can decide the // Update right pointer as we have decided // the amount of water for this // Update left pointer as we have decided // If rMax is smaller, then we can decide the // Update right pointer as we have decided // the amount of water for this // Update left pointer as we have decided water for this\n\n[Alternate Approach] Using Stack – O(n) Time and O(n) Space\n\nWe have already discussed a better approach than this, but this is really an interesting approach to learn. It is strongly recommended to refer next greater element, previous greater element and largest area in a histogram problems before moving forward. When we compute next greater element, we pop an item from the stack and mark current item as next greater of it. One important observation here is the item below every item in stack is the previous greater element. So for every element, we can compute both previous greater and next greater in one traversal and a stack. Now you must be wondering that for the trapping rain water problem, we need greatest on right and left (not closest greater). Please pause reading for a moment and think how we can use next greater and previous greater for finding the amount of water.\n• None As discussed above, the idea is to find next greater and previous greater for every element using a stack and single traversal.\n• None When we have valid next greater and previous greater, we know for sure that we need to fill water between next greater and previous greater. We know a minimum amount also, so we fill the known amount. And when we consider previous greater and next greater we find their next and previous greater, and fill some more amount. We do this until we find next greatest and previous greatest.\n• None We do not fill the exact amount in a go and we also do not necessarily fill one by one, we fill all between next greater and previous greater.\n\n// Function to return the maximum water that can be stored // arr[i] is the next greater for the removed item // and new stack top is the previous greater // Take the minimum of two heights (next and prev greater) // and find the amount of water that we can fill in all // Stack is full when top is equal to the last index // Stack is empty when top is -1 // Function to add an item to stack // Function to remove an item from stack // Function to return the top from the stack without popping // Function to return the maximum water that can be stored // arr[i] is the next greater for the removed item // and new stack top is the previous greater // Take the minimum of two heights (next and prev greater) // Function to return the maximum water that can be stored // arr[i] is the next greater for the removed item // and new stack top is the previous greater // Take the minimum of two heights (next and prev greater) # Function to return the maximum water that can be stored # arr[i] is the next greater for the removed item # and new stack top is the previous greater # Take the minimum of two heights (next and prev greater) // arr[i] is the next greater for the removed item // and new stack top is the previous greater // Take the minimum of two heights (next and prev greater) // Function to return the maximum water that can be stored // arr[i] is the next greater for the removed item // and new stack top is the previous greater // Take the minimum of two heights (next and prev greater)"
    },
    {
        "link": "https://medium.com/@RobuRishabh/two-pointers-in-c-a-path-to-optimized-algorithms-403f628053d9",
        "document": "Example: Container With Most Water\n\nYou are given an integer array of length . There are vertical lines drawn such that the two endpoints of the line are and . Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store.\n\nA phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string , return if it is a palindrome, or otherwise.\n\nExample: Two Sum II — Input Array Is Sorted\n\nGiven a 1-indexed array of integers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific number. Let these two numbers be and where .\n\nReturn the indices of the two numbers, and , added by one as an integer array of length 2.\n\nThe tests are generated such that there is exactly one solution. You may not use the same element twice.\n\nYour solution must use only constant extra space.\n\nGiven an integer array nums, return all the triplets such that , , and , and .\n\nNotice that the solution set must not contain duplicate triplets.\n\nGiven non-negative integers representing an elevation map where the width of each bar is , compute how much water it can trap after raining."
    },
    {
        "link": "https://leetcode.com/problems/trapping-rain-water",
        "document": ""
    },
    {
        "link": "https://enjoyalgorithms.com/blog/trapping-rain-water",
        "document": "Key takeaway: An excellent problem to learn time and space complexity optimization using various approaches. Two-pointers and stack-based approaches are worth exploring.\n\nGiven n non-negative integers representing an elevation map where the width of each tower is 1. Write a program to compute how much water it can trap after raining.\n\nExplanation: Trapped water = 1 x 1 + 1 x 1 + 2 x 1 + 1 x 1 + 1 x 1 = 6 (Area of the blue region in the following diagram).\n\nOne basic idea would be to traverse the array, calculate the rainwater trapped at each tower, and sum it to get the overall water trapped. The critical question is: How do we find the amount of water trapped at each tower?\n\nIf we observe closely, water trapped by tower height[i] will be bounded by the minimum of the maximum height on the left and right sides of height[i]. So here is the formula: Rainwater trapped at height[i] = min (max height on the left side, max height on the right side) - height[i].\n\nSo for each element height[i], we traverse elements on the left of height[i] to find the highest tower on the left side and traverse elements on the right of height[i] to find the highest tower on the right side. After this, we apply the above formula to calculate the water trapped at tower height[i].\n• We initialize the variable trappedWater to store the total trapped water.\n• Now, we traverse the array from i = 0 to n - 1. Inside the loop, we initialize variables leftMax and rightMax to track the maximum height of towers on both sides. For each height[i]:\n• We run a loop from j = i to 0 to find the maximum height on the left side and store this value in the variable leftMax. Similarly, we run a loop from j = i to n - 1 to find the maximum height on the right side and store this value in the variable rightMax.\n• Using the formula, we calculate the amount of water trapped at height[i] and add it to the variable trappedWater: trappedWater = trappedWater + min(leftMax, rightMax) - height[i].\n• By the end of nested loops, we return value stored in variable trappedWater.\n\nWe use two nested loops where the outer loop scans the height[] array, and the two inner loops find rightMax and leftMax. So, at each iteration of the outer loop, we traverse each array element using the inner loops. Therefore, the time complexity is n * O(n) = O(n^2). We use a constant number of variables, so the space complexity is O(1).\n\nNow critical questions are: Can we improve efficiency and solve the problem in O(n) time? Is it possible to get rid of the two inner loops? Let's think! If we know the values of leftMax and rightMax for each tower height[i], we can solve this problem in a single scan of the array. How can we do this? Let's think!\n\nSuppose we take two extra arrays, leftMax[n] and rightMax[n], i.e., leftMax[i] to store the maximum height on the left side and rightMax[i] to store the maximum height on the right side. Can we calculate both arrays in O(n) time? Here is an idea:\n• If we know leftMax[i - 1], we can easily calculate leftMax[i] in O(1) using the formula leftMax[i] = max(leftMax[i - 1], height[i]).\n• Similarly, if we know rightMax[i + 1], we can easily calculate rightMax[i] in O(1) using the formula rightMax[i] = max(rightMax[i + 1], height[i]).\n\nSo, based on the above idea, we can store values in the leftMax[] and rightMax[] arrays in a single scan of the height[] array. This is similar to the dynamic programming approach where we use the already calculated solution of the smaller problem to get the solution to the larger problem. Think!\n• We create two arrays leftMax[n] and rightMax[n].\n• Now we initialize leftMax[0] with height[0] and run a loop from i = 1 to n - 1 to store values in leftMax[]. At each ith iteration, we store the maximum element that occurred up to that point in leftMax[i].\n• Similarly, we initialize rightMax[n - 1] with height[n - 1] and run a loop from i = n - 2 to 0 to store values in rightMax[]. At each ith iteration, we store the maximum element that occurred up to that point in rightMax[i].\n• Now stored water at the height[i] = min(leftMax[i], rightMax[i]) - height[i]. So we traverse the height[] array and track the total amount of trapped water using the variable trappedWater.\n• Finally, we return the value stored in the variable trappedWater.\n\nWe are running three single loops. So, the time complexity = Time complexity of storing values in leftMax[] + Time complexity of storing values in rightMax[] + Time complexity of calculating total trapped water = O(n) + O(n) + O(n) = O(n). We are using two extra arrays of size n. So the space complexity = Space complexity of leftMax[] + Space complexity of rightMax[] = O(n) + O(n) = O(n).\n\nThe critical question is: Can we solve this problem in a single scan of height[] array? Let's explore.\n\nDid we observe any patterns? Here's an idea: As we traverse the array, we need to find the area confined between the current tower and all previous smaller towers in a sequence. The critical question is: How can we find this? One idea would be to use a stack to track the indices of the previous smaller towers.\n\nWe will keep pushing towers onto the stack until we find a tower larger than the one at the top of the stack. Now We'll stop at this stage because there can be some trapped water on the left side of the current tower. So we get the indices of the previous smaller towers by popping values from the stack and calculate the amount of water stored at each popped tower and the current tower.\n\nStep 1: We create a stack, S, to store indices of previous smaller towers. Now, we traverse the height[] array using a loop while(i < n).\n\nStep 2: If the current tower is smaller than or equal to the tower at the top of the stack, we push the index of the current tower onto the stack and move to the next tower.\n\nStep 3: If the current tower height[i] is larger than the tower at the top of the stack, we can conclude that there may be trapped water between the current tower and some previous towers in the stack. So, we pop the value from the stack, calculate the trapped water, and add it to the total trapped water. The water trapped is equal to the area of the rectangular region formed by the current tower, the popped tower, and the tower at the top of the stack.\n• Region height = min(Height of the current tower, Height of the tower at the top of the stack) - Height of the popped tower.\n\nWe continue this step in a loop until we find the current tower smaller than the tower at the top of the stack or the stack becomes empty.\n\nStep 4: Finally, we return the value stored in the variable trappedWater.\n\nWe are performing a single traversal of the array. In the worst case, we will perform two stack operations for each tower, i.e., one push and one pop operation. So the time complexity = O(n). In the worst case, the stack can contain up to n elements, so the space complexity is O(n).\n\nHere is an observation: For a given tower, if there is any tower on the right side that is taller than the maximum height on the left side, the amount of water trapped at the current tower will depend on the maximum height on the left side. Vice versa is also true: If there is any tower on the left side taller than the maximum height on the right side, the amount of water trapped at the current tower will depend on the maximum height on the right side.\n\nSo one idea is to traverse the array from the opposite end using two pointers (l and r) and maintain two extra variables (maxLeft and maxRight) to track the maximum heights encountered from both ends. Initial values: l = 0, r = n - 1, leftMax = 0, rightMax = 0. This will continue in a loop until the left pointer does not cross the right pointer i.e. while (l <= r).\n\nIf height[l] < height[r]: If there are some towers on the left side shorter than height[r], there can be some trapped water at these left towers. So we calculate the water trapped at towers on the left side, update maxLeft, keep moving the left pointer forward and stop the left pointer when height[l] is greater than height[r]. During this process:\n• If height[l] < maxLeft, there will be some water at height[l]. The water trapped at height[l] is equal to maxLeft - height[l].\n• If height[l] > maxLeft, then we find a new maximum height from the left, and there will be no water at height[l]. So we update maxLeft with the value of height[l].\n\nIf height[l] > height[r]: There will be some towers on the right side shorter than height[l], and there can be trapped water at these right towers. We continue a similar process: calculate the trapped water at towers on the right side, update maxRight, move the right pointer inward and stop the right pointer when height[r] is greater than height[l]. During this process:\n• If height[r] < maxRight, there will be some water at height[r]. The water trapped at height[r] is equal to maxRight - height[r].\n• If height[r] > maxRight, then we find a new maximum height from the right, and there will be no water at height[r]. So we update maxRight with the value of height[r].\n\nIn simple terms: If the shorter tower is on the left end, the amount of trapped water will depend on the tower's height in the direction from left to right. Similarly, if the shorter tower is on the right end, the amount of trapped water will depend on the tower's height in the direction from right to left.\n\nSo we first calculate the water trapped on the shorter tower among height[l] and height[r] and move the pointer associated with the shorter tower. In terms of an analogy, we can think of height[l] and height[r] as forming a partial container wall, where we fix the higher end and allow water to flow from the lower end.\n\nWe are doing a single scan to traverse the array from both ends. After each comparison, we move either the left or right pointer. So in the worst case, we need to do O(n) operations. So, time complexity = O(n).\n\nOnly constant space is required for variables and pointers, so space complexity = O(1).\n\nCan we find another solution to this problem in O(n) time and O(1) space? Here is a hint: we first search for the maximal tower in height [] and split the array into two halves around it. Now we do two traversals: One from the leftmost tower to the highest tower and another from the rightmost to the highest tower.\n\nIn the 2nd approach, can we save one extra array? Here is a hint: We pre-calculate the max height on the left side of each tower in an array maxLeft[i]. Now we process the trapped water on the fly as we traverse the towers from right to left. During this process, we maintain a variable maxRight to keep track of the maximum height on the right side. For each tower, we calculate the min(maxLeft[i], maxRight). If this minimum is greater than the height[i], it means there's trapped water at height[i]. After that, we update maxRight.\n• In the stack-based approach, what would be the best and worst-case scenarios?\n• In the 4th approach, can we compare leftMax and rightMax to decide which pointer to move?\n• Let's consider a different version of the problem: given an m x n integer matrix height[][] representing the height of each unit cell in a 2D elevation map, return the volume of water it can trap after rain.\n• Using dynamic programming: Time = O(n), Space = O(n).\n• Using stack: Time = O(n), Space = O(n).\n• Using two pointers: Time = O(n), Space = O(1).\n• Check for pair in an array with a given sum\n• Sort an array of 0s, 1s, and 2s\n\nPlease write comments if you find an error or you want to share more insights about the topic. Enjoy learning, Enjoy coding, Enjoy algorithms!"
    },
    {
        "link": "https://medium.com/@roya90/trapping-rain-water-6d1a728a0cc9",
        "document": "This blog series attempts to solve the 500 Top Leet Code Interview Questions with the help of AI Code Assistance, such as Gemini and GPT.\n\nThe task is to compute the amount of water that can be trapped between the bars of a given elevation map. The elevation map is represented as an array , where the width of each bar is 1.\n\nThe key observation is that water trapped at any index i depends on the minimum height of the tallest bars to its left and right:\n\nInstead of precomputing arrays for the left and right maximum heights, we can use two pointers ( and ) to dynamically calculate these values while iterating through the array.\n• starts at the beginning of the array.\n• starts at the end of the array.\n• : Tracks the maximum height encountered so far from the left.\n• : Tracks the maximum height encountered so far from the right."
    },
    {
        "link": "https://geeksforgeeks.org/trapping-rain-water",
        "document": "Trapping Rainwater Problem states that given an array of n non-negative integers arr[] representing an elevation map where the width of each bar is 1, compute how much water it can trap after rain.\n\nInput: arr[] = [3, 0, 1, 0, 4, 0, 2]\n\nOutput: 10\n\nExplanation: The expected rainwater to be trapped is shown in the above image. Input: arr[] = [1, 2, 3, 4]\n\nOutput: 0\n\nExplanation: We cannot trap water as there is no height bound on both sides\n\nThe basic intuition of the problem is as follows:\n• None An element of the array can store water if there are higher bars on the left and the right.\n• None The amount of water to be stored in every position can be found by finding the heights of the higher bars on the left and right sides.\n• None The total amount of water stored is the summation of the water stored in each index.\n• None No water can be filled if there is no boundary on both sides.\n\n[Naive Approach] Find left and right max for each index – O(n^2) Time and O(1) Space\n\nTraverse every array element and find the highest bars on the left and right sides. Take the smaller of two heights. The difference between the smaller height and the height of the current element is the amount of water that can be stored in this array element.\n\n// Function to return the maximum water that can be stored // For every element of the array // Find the maximum element on its left // Find the maximum element on its right // Function to return the maximum water that can be stored // For every element of the array // Find the maximum element on its left // Find the maximum element on its right // Function to return the maximum water that can be stored // For every element of the array // Find the maximum element on its left // Find the maximum element on its right # Function to return the maximum water that can be stored # For every element of the array # Find the maximum element on its left # Find the maximum element on its right // Function to return the maximum water that can be stored // For every element of the array // Find the maximum element on its left // Find the maximum element on its right // Function to return the maximum water that can be stored // For every element of the array // Find the maximum element on its left // Find the maximum element on its right\n\n[Better Approach] Prefix and suffix max for each index – O(n) Time and O(n) Space\n\n// Left[i] contains height of tallest bar to the // Right[i] contains height of tallest bar to // the right of i'th bar including itself // Left[i] contains height of tallest bar to the // Right[i] contains height of tallest bar to // the right of i'th bar including itself // Left[i] contains height of tallest bar to the // Right[i] contains height of tallest bar to // the right of i'th bar including itself # Left[i] contains height of tallest bar to the # Right[i] contains height of tallest bar to # the right of i'th bar including itself // Left[i] contains height of tallest bar to the // Right[i] contains height of tallest bar to // the right of i'th bar including itself // Left[i] contains height of tallest bar to the // Right[i] contains height of tallest bar to // the right of i'th bar including itself\n\n[Expected Approach] Using Two Pointers – O(n) Time and O(1) Space\n\nThe approach is mainly based on the following facts:\n• None If we consider a subarray arr[left…right], we can decide the amount of water either for arr[left] or arr[right] if we know the left max (max element in arr[0…left-1]) and right max (max element in arr[right+1…n-1].\n• None If left max is less than the right max, then we can decide for arr[left]. Else we can decide for arr[right]\n• None If we decide for arr[left], then the amount of water would be left max – arr[left] and if we decide for arr[right], then the amount of water would be right max – arr[right].\n\nHow does this work? Let us consider the case when left max is less than the right max. For arr[left], we know left max for it and we also know that the right max for it would not be less than left max because we already have a greater value in arr[right…n-1]. So for the current bar, we can find the amount of water by finding the difference between the current bar and the left max bar.\n\n// If rMax is smaller, then we can decide the amount of water for arr[right] // Update right pointer as we have decided the amount of water for this // Update left pointer as we have decided water for this // If rMax is smaller, then we can decide the amount of water for arr[right] // Update right pointer as we have decided the amount of water for this // Update left pointer as we have decided water for this // If rMax is smaller, then we can decide the amount of water for arr[right] // Update right pointer as we have decided the amount of water for this // Update left pointer as we have decided water for this # If rMax is smaller, then we can decide the # Update right pointer as we have decided # the amount of water for this # Update left pointer as we have decided # the amount of water for this // If rMax is smaller, then we can decide the // Update right pointer as we have decided // the amount of water for this // Update left pointer as we have decided // If rMax is smaller, then we can decide the // Update right pointer as we have decided // the amount of water for this // Update left pointer as we have decided water for this\n\n[Alternate Approach] Using Stack – O(n) Time and O(n) Space\n\nWe have already discussed a better approach than this, but this is really an interesting approach to learn. It is strongly recommended to refer next greater element, previous greater element and largest area in a histogram problems before moving forward. When we compute next greater element, we pop an item from the stack and mark current item as next greater of it. One important observation here is the item below every item in stack is the previous greater element. So for every element, we can compute both previous greater and next greater in one traversal and a stack. Now you must be wondering that for the trapping rain water problem, we need greatest on right and left (not closest greater). Please pause reading for a moment and think how we can use next greater and previous greater for finding the amount of water.\n• None As discussed above, the idea is to find next greater and previous greater for every element using a stack and single traversal.\n• None When we have valid next greater and previous greater, we know for sure that we need to fill water between next greater and previous greater. We know a minimum amount also, so we fill the known amount. And when we consider previous greater and next greater we find their next and previous greater, and fill some more amount. We do this until we find next greatest and previous greatest.\n• None We do not fill the exact amount in a go and we also do not necessarily fill one by one, we fill all between next greater and previous greater.\n\n// Function to return the maximum water that can be stored // arr[i] is the next greater for the removed item // and new stack top is the previous greater // Take the minimum of two heights (next and prev greater) // and find the amount of water that we can fill in all // Stack is full when top is equal to the last index // Stack is empty when top is -1 // Function to add an item to stack // Function to remove an item from stack // Function to return the top from the stack without popping // Function to return the maximum water that can be stored // arr[i] is the next greater for the removed item // and new stack top is the previous greater // Take the minimum of two heights (next and prev greater) // Function to return the maximum water that can be stored // arr[i] is the next greater for the removed item // and new stack top is the previous greater // Take the minimum of two heights (next and prev greater) # Function to return the maximum water that can be stored # arr[i] is the next greater for the removed item # and new stack top is the previous greater # Take the minimum of two heights (next and prev greater) // arr[i] is the next greater for the removed item // and new stack top is the previous greater // Take the minimum of two heights (next and prev greater) // Function to return the maximum water that can be stored // arr[i] is the next greater for the removed item // and new stack top is the previous greater // Take the minimum of two heights (next and prev greater)"
    },
    {
        "link": "https://github.com/keineahnung2345/leetcode-cpp-practices/blob/master/42.%20Trapping%20Rain%20Water.cpp",
        "document": "Runtime: 4 ms, faster than 95.59% of C++ online submissions for Trapping Rain Water.\n\nMemory Usage: 8.2 MB, less than 100.00% of C++ online submissions for Trapping Rain Water.\n\nright wall should be larger than valley\n\nnow we want to discover higher right wall\n\nwe only need to find a higher right wall when right wall is lower than left wall\n\nwe should take max(0, x) here!\n\nRuntime: 312 ms, faster than 5.10% of C++ online submissions for Trapping Rain Water.\n\nMemory Usage: 8.5 MB, less than 100.00% of C++ online submissions for Trapping Rain Water.\n\nRuntime: 4 ms, faster than 95.59% of C++ online submissions for Trapping Rain Water.\n\nMemory Usage: 8.2 MB, less than 100.00% of C++ online submissions for Trapping Rain Water.\n\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Trapping Rain Water.\n\nMemory Usage: 8.5 MB, less than 100.00% of C++ online submissions for Trapping Rain Water.\n\ntop is bounded by previous bar in the stack and current bar\n\nMemory Usage: 8.3 MB, less than 100.00% of C++ online submissions for Trapping Rain Water.\n\nuse leftMax to substract because leftMax is min(leftMax, rightMax)"
    },
    {
        "link": "https://algocademy.com/link?problem=trapping-rain-water&lang=cpp&solution=1",
        "document": "Best Time To Buy Stock in C++\n\nBest Time To Buy Stock in C++\n\nBest Time To Buy Stock in C++\n\nBest Time To Buy Stock in C++\n\nBest Time To Buy Stock in C++\n\nBest Time To Buy Stock in C++\n\nBinary Strings With At Most K Consecutive Ones in C++\n\nBinary Strings With At Most K Consecutive Ones in C++\n\nBinary Strings With K Ones On Even Positions in C++\n\nBinary Strings With K Ones On Even Positions in C++\n\nBinary Strings With K Ones in C++\n\nBinary Strings With K Ones in C++\n\nBinary Strings Without Consecutive Ones in C++\n\nBinary Strings Without Consecutive Ones in C++\n\nPermutations Of Given Length in C++\n\nPermutations Of Given Length in C++\n\nBinary Strings Of Given Length in C++\n\nBinary Strings Of Given Length in C++\n\nSubarray Of Given Sum Ii in C++\n\nSubarray Of Given Sum Ii in C++\n\nLongest Subarray With At Most K Distinct Integers in C++\n\nLongest Subarray With At Most K Distinct Integers in C++\n\nLongest Subarray With Sum At Most S in C++\n\nLongest Subarray With Sum At Most S in C++\n\nIntersection Of Two Linked Lists in C++\n\nIntersection Of Two Linked Lists in C++\n\nRemove Nth Node From End Of List in C++\n\nRemove Nth Node From End Of List in C++\n\nGenerate Binary Strings With K Ones in C++\n\nGenerate Binary Strings With K Ones in C++\n\nLongest Subarray With At Most K Distinct Integers in C++\n\nLongest Subarray With At Most K Distinct Integers in C++\n\nContainer With Most Water in C++\n\nContainer With Most Water in C++\n\nMax Sum Of Three Subarrays in C++\n\nMax Sum Of Three Subarrays in C++\n\nMax Sum Of Three Subarrays in C++\n\nMax Sum Of Three Subarrays in C++\n\nMax Sum Of Three Subarrays in C++\n\nMax Sum Of Three Subarrays in C++\n\nSubarray Of Given Sum in C++\n\nSubarray Of Given Sum in C++\n\nLongest Subarray With Sum At Most S in C++\n\nLongest Subarray With Sum At Most S in C++\n\nMax Sum Of Three Subarrays in C++\n\nMax Sum Of Three Subarrays in C++\n\nMax Val And Number Of Occurrences in C++\n\nMax Val And Number Of Occurrences in C++\n\nLongest Common Prefix Of Two Strings in C++\n\nLongest Common Prefix Of Two Strings in C++\n\nContinue In For Loops in C++\n\nContinue In For Loops in C++\n\nBreak In For Loops in C++\n\nBreak In For Loops in C++\n\nLooping Through Arrays With Indices in C++\n\nLooping Through Arrays With Indices in C++\n\nThe For Loop in C++\n\nThe For Loop in C++\n\nThe While Loop in C++\n\nThe While Loop in C++\n\nWhy For Loops in C++\n\nWhy For Loops in C++\n\nSecond Largest Value in C++\n\nSecond Largest Value in C++\n\nMinimum Value Of Three in C++\n\nMinimum Value Of Three in C++\n\nAllow To Contest in C++\n\nAllow To Contest in C++\n\nReducing If Else To Boolean Expression in C++\n\nReducing If Else To Boolean Expression in C++\n\nIf Else in C++\n\nIf Else in C++\n\nLast Two Digit Sum in C++\n\nLast Two Digit Sum in C++\n\nYour First Challenge in C++\n\nYour First Challenge in C++\n\nBuggy Code Return Instead Of Print in C++\n\nBuggy Code Return Instead Of Print in C++\n\nQuiz Return Instead Of Print in C++\n\nQuiz Return Instead Of Print in C++\n\nBuggy Code Print Instead Of Return in C++\n\nBuggy Code Print Instead Of Return in C++\n\nQuiz Print Instead Of Return in C++\n\nQuiz Print Instead Of Return in C++\n\nWhy Parameters And Arguments in C++\n\nWhy Parameters And Arguments in C++\n\nConvert Hours And Mins Into Seconds in C++\n\nConvert Hours And Mins Into Seconds in C++\n\nThe Power Of Variables in C++\n\nThe Power Of Variables in C++\n\nTrapping Rain Water in C++ (Time Complexity: O(n))\n\nThe core challenge of this problem is to determine how much water can be trapped between the bars of the elevation map after it rains. This problem is significant in various fields such as civil engineering for designing drainage systems and in computer graphics for simulating realistic water effects.\n\nPotential pitfalls include misunderstanding how water is trapped between the bars and not accounting for all possible trapped water sections.\n\nTo solve this problem, we need to consider the height of the bars and how they form valleys where water can be trapped. Here are the steps to approach the solution:\n\nA naive solution would involve iterating through each bar and calculating the trapped water by finding the maximum height to the left and right of each bar. This approach, however, is not optimal as it has a time complexity of O(n^2).\n\nWe can optimize the solution using two main approaches:\n\nWe can precompute the maximum height to the left and right of each bar and then use these precomputed values to calculate the trapped water in a single pass.\n\nWe can use two pointers to traverse the elevation map from both ends towards the center, keeping track of the maximum heights seen so far from both directions. This approach has a time complexity of O(n) and a space complexity of O(1).\n• Initialize two pointers, left and right, at the beginning and end of the elevation map, respectively.\n• Initialize two variables, left_max and right_max, to keep track of the maximum heights seen so far from the left and right, respectively.\n• While the left pointer is less than the right pointer, do the following:\n• If the height at the left pointer is less than or equal to the height at the right pointer:\n• If the height at the left pointer is greater than or equal to left_max, update left_max.\n• Otherwise, add the difference between left_max and the height at the left pointer to the total trapped water.\n• Move the left pointer one step to the right.\n• Otherwise:\n• If the height at the right pointer is greater than or equal to right_max, update right_max.\n• Otherwise, add the difference between right_max and the height at the right pointer to the total trapped water.\n• Move the right pointer one step to the left.\n\nThe time complexity of the two-pointer approach is O(n) because we traverse the elevation map only once. The space complexity is O(1) as we use only a constant amount of extra space.\n• All bars have the same height.\n• The elevation map is strictly increasing or decreasing.\n• The elevation map has only one bar.\n\nEach of these cases should be tested to ensure the algorithm handles them correctly.\n\nTo test the solution comprehensively, consider the following test cases:\n\nUsing a testing framework like Google Test can help automate and manage these tests effectively.\n\nWhen approaching such problems, consider the following tips:\n• Break down the problem into smaller parts and understand each part.\n• Think about different approaches and their trade-offs.\n\nUnderstanding and solving the Trapping Rain Water problem is crucial for developing strong problem-solving skills. By practicing and exploring different approaches, you can improve your ability to tackle similar problems efficiently.\n\nFor further reading and practice, consider the following resources:"
    },
    {
        "link": "https://takeuforward.org/data-structure/trapping-rainwater",
        "document": ""
    },
    {
        "link": "https://w3resource.com/data-structures-and-algorithms/array/dsa-trapping-rain-water.php",
        "document": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n• Problem Statement: Trapping rainwater on an elevation map involves calculating the amount of water trapped between bars representing different elevations. When it rains, water accumulates between these bars, and the task is to determine the total amount of water trapped.\n• The input consists of an array of non-negative integers representing the elevation at each position on the map.\n• The output is the total amount of water trapped between the bars.\n• Real-world Scenario: Understanding this problem is crucial in various real-world scenarios, such as urban drainage systems or architecture design in flood-prone areas. \n\n For example, urban planners need to calculate how much water a drainage system should be able to handle during heavy rainfall to prevent flooding in streets and buildings.\n• Elevation Map: An elevation map is represented by an array of integers where each integer corresponds to the height of a bar on the map. The higher the integer value, the higher the bar's elevation.\n• Water Trapping: When it rains on an elevation map, water accumulates between bars of different heights. Water gets trapped in the lower areas between the taller bars, forming \"pools\" or \"lakes\" of water. The goal is to calculate the total volume of water trapped between the bars after rainfall.\n\nWalkthrough examples: These examples demonstrate how the problem of trapping rainwater can be approached through manual calculations using specific elevation maps.\n• Example 1: Consider an elevation map represented by the array [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1].\n• Identify the areas where water can be trapped between the bars.\n• Calculate the amount of water trapped using manual calculations, following the water trapping process.\n• Example 2: Take another elevation map represented by the array [3, 0, 0, 2, 0, 4].\n• Identify the areas where water can be trapped between the bars.\n• Calculate the amount of water trapped using manual calculations, following the water trapping process.\n• Naive Solution: The naive solution to the \"Trapping Rain Water\" problem involves iterating through each bar in the elevation map and calculating the amount of water that can be trapped above it.\n\n This is done by finding the maximum heights of bars to the left and right of each bar and computing the minimum of these two heights. \n\n The difference between the minimum height and the height of the current bar gives the amount of water trapped above it.\n• Complexity Analysis: \n\n The time complexity of the brute force approach is O(n^2), where n is the number of bars in the elevation map. We iterate through each bar and for each bar, we iterate through all bars to its left and right to find the maximum heights. \n\n The space complexity is O(1) as we are not using any additional data structures. However, the approach may involve redundant calculations, resulting in inefficiency.\n• Two Pointer Technique: The Two Pointer Technique optimizes the solution by using two pointers, one starting from the left and one from the right, to determine the maximum height of bars on both sides. This allows for a more efficient calculation of trapped water without the need for a stack or hash table.\n• Stack-Based Approach: A stack-based approach can further optimize the solution by using a stack to keep track of the indices of bars in non-decreasing order of their heights. \n\n This helps in efficiently calculating trapped water by iterating through the elevation map only once.\n• Complexity Analysis: Compare the time and space complexity of the optimized approaches with the brute force approach. The Two Pointer Technique and Stack-Based Approach offer improved time complexity compared to the brute force approach, with both having a time complexity of O(n) and space complexity of O(1). This is because they iterate through the elevation map only once, leading to more efficient calculations of trapped water. \n\n However, the space complexity may vary depending on the implementation details of the stack-based approach.\n• \"Divide and Conquer\" involves breaking down a complex problem into simpler subproblems.\n• For \"Trapping Rain Water,\" identifying key subproblems such as finding the maximum height of bars on the left and right sides of each bar can simplify the problem-solving process.\n• Combine the solutions of subproblems to obtain the overall solution.\n• Identify subproblems like calculating the maximum height of bars on the left and right sides of each bar and determining the amount of water trapped at each position.\n• Combine the solutions of these subproblems to calculate the total amount of water trapped.\n• \"Divide and Conquer\" is effective when the problem can be easily divided into smaller, more manageable parts.\n• Each subproblem is solved independently, simplifying the overall problem-solving process.\n• Algorithmic strategies involve adopting specific techniques or approaches to tackle problems more efficiently.\n• In the context of \"Trapping Rain Water,\" strategies such as dynamic programming, two-pointer technique, and stack-based approach can be considered algorithmic approaches.\n• Dynamic programming can be applied to efficiently solve the problem by breaking it down into smaller subproblems and storing the results of these subproblems to avoid redundant calculations.\n• For \"Trapping Rain Water,\" dynamic programming can be used to calculate the maximum water trapped at each position on the elevation map, considering the water trapped to the left and right of each bar.\n• The Two-Pointer Technique optimizes the solution by using two pointers, one starting from the left and one from the right, to determine the maximum height of bars on both sides.\n• This allows for a more efficient calculation of trapped water without the need for a stack or hash table.\n• A stack-based approach can further optimize the solution by using a stack to keep track of the indices of bars in non-decreasing order of their heights.\n• This helps in efficiently calculating the trapped water by iterating through the elevation map only once.\n• Algorithmic strategies aim to improve the efficiency of solving problems.\n• Dynamic programming, the two-pointer technique, and stack-based approach provide alternative approaches that reduce time complexity and improve the overall efficiency of calculating trapped water.\n• They can be applied to different problems by leveraging the underlying principles of dynamic programming, pointer techniques, and stack-based approaches.\n• The choice of strategy depends on the problem requirements and constraints.\n• Understanding the nature of the \"Trapping Rain Water\" problem guides the selection of the most appropriate algorithmic strategy for efficient solution.\n• Mistake: Assuming the elevation map always contains bars.\n• Solution: Check for an empty elevation map at the beginning and handle it appropriately to avoid errors.\n• Mistake: Not considering the case where the elevation map has only one bar.\n• Solution: Ensure the algorithm works correctly for elevation maps with one or two bars.\n• Mistake: Ignoring edge cases with extreme elevation values (e.g., very large or very small integers).\n• Solution: Test the algorithm with extreme elevation values to verify its robustness.\n• Solution: Account for duplicate pairs and decide whether to include them in the result or not.\n• Counting the Same Elements Twice:\n• Mistake: Counting the same elevation value twice when considering pairs.\n• Solution: Implement a mechanism to avoid pairing an elevation value with itself.\n• Mistake: Treating (a, b) and (b, a) as different pairs.\n• Mistake: Not testing the algorithm with a target of zero.\n• Solution: Explicitly test the algorithm with a target of zero to verify correctness.\n• Mistake: Not considering the possibility of integer overflow when calculating sums.\n• Solution: Use data types that can handle large sums or implement checks to prevent overflow.\n• Mistake: Assuming the data range is within a certain limit.\n• Solution: Be mindful of the potential range of data and choose appropriate data types.\n• Mistake: Misinterpreting how negative numbers contribute to the target.\n• Solution: Understand the impact of negative numbers on the target and adjust the algorithm accordingly.\n• Break down the solution into modular functions or methods, each addressing a specific subtask.\n• Improved Readability: Each function focuses on a specific task, making the code easier to understand.\n• Reusability: Modular functions can be reused in other parts of the code or in different projects.\n• Easy Debugging: Isolate and troubleshoot issues in specific modules without affecting the entire codebase.\n• Choose descriptive and meaningful variable names that convey the purpose or content of the variable.\n• Readability: Clear and descriptive names enhance code readability for yourself and others.\n• Maintenance: Easier maintenance as the purpose of variables is evident.\n• Reduced Comments: Well-named variables can reduce the need for excessive comments.\n• Follow established conventions, such as PEP 8 for Python, for a uniform appearance.\n• Consistency facilitates version control and collaboration, especially in team environments.\n• Adopting a consistent style ensures that team members can easily understand and contribute to the code.\n• Test the solution with a variety of input scenarios to ensure its correctness.\n• Include both typical cases and edge cases to cover a wide range of possibilities.\n• Positive cases with valid elevation maps that can trap water.\n• Cases with an elevation map where no water can be trapped.\n• Automate the execution of test cases to streamline the testing process.\n• Use testing frameworks or write custom test scripts to cover various scenarios.\n• Helps identify where the code deviates from expected behavior.\n• Utilize integrated development environment (IDE) debuggers to set breakpoints and step through the code.\n• Engage in code reviews with peers or mentors.\n• Explain the code step by step to an inanimate object (or a colleague).\n• The act of verbalizing often helps in identifying logical errors.\n• Temporarily comment out or isolate specific sections of code to identify the source of errors.\n• Narrow down the scope of investigation to smaller segments.\n• Ensure that variables hold expected values at different stages of execution.\n• Pay attention to changes in variable states.\n• This prevents the program from crashing abruptly, providing information about the error.\n• Try reproducing the issue in a controlled environment.\n• Identify the steps leading to the error and examine the relevant code.\n• Incorporate logging statements to record the program's state during execution.\n• Log messages provide insights into the program flow and variable values.\n• Implement and test the solution incrementally, focusing on small sections at a time.\n• Two sets of eyes can catch errors more effectively.\n• Evaluate the efficiency of the algorithm in terms of input size.\n• Identify the dominant operations and quantify their relationship with input size.\n• For the Two Pointer Technique, the time complexity is O(n) since it involves iterating through the elevation map once.\n• Assess the algorithm's memory usage in relation to input size.\n• Consider additional data structures and their impact on space complexity.\n• The Two Pointer Technique typically requires O(1) additional space since it operates in-place without extra data structures.\n• Evaluate the trade-offs between optimizing for time or space.\n• Some algorithms prioritize reduced time complexity, while others prioritize minimal space usage.\n• The Two Pointer Technique offers improved time complexity (O(n)) but minimal space complexity (O(1)) compared to other approaches like the Stack-Based Approach.\n• Consider the balance between memory efficiency and algorithmic speed.\n• Optimize the algorithm based on the specific requirements and constraints of the problem.\n• The Stack-Based Approach may offer better memory efficiency by utilizing a stack data structure but might sacrifice speed due to additional stack operations.\n• Choose algorithmic strategies based on the problem's characteristics and constraints.\n• Select an approach that aligns with the specific goals of the application.\n• The choice between the \"Two Pointer\" Technique and the Stack-Based Approach depends on factors such as available memory and the complexity of the elevation map.\n• Consider how well the algorithm scales as the input size increases.\n• Choose an algorithm that maintains efficiency with growing datasets.\n• The Two Pointer Technique may be more scalable for large elevation maps since its time complexity remains linear with input size, whereas other approaches may exhibit worse performance.\n• Scenario: Designing effective drainage systems or architectural features to manage rainwater in urban areas.\n• Algorithmic Approach: Trapping Rain Water algorithms can assist in calculating the capacity needed for drainage systems or designing structures that can store rainwater effectively.\n• Scenario: Developing strategies to mitigate flooding in flood-prone regions or areas susceptible to heavy rainfall.\n• Algorithmic Approach: Trapping Rain Water algorithms can provide insights into how much water certain areas can hold, helping in flood risk assessment and management planning.\n• Algorithmic Approach: By understanding how much rainwater can be trapped in various landscapes, conservationists can design sustainable water management systems that benefit ecosystems and communities.\n• Algorithmic Approach: Trapping Rain Water algorithms can inform decisions about water distribution and storage on farms, reducing water waste and ensuring crops receive adequate moisture.\n• Scenario: Planning for natural disasters such as hurricanes or typhoons that bring heavy rainfall.\n• Algorithmic Approach: Trapping Rain Water algorithms can help emergency response teams estimate potential flood volumes and identify areas at risk, aiding in evacuation planning and resource allocation.\n• Encourage learners to consider additional factors such as terrain slope, soil permeability, and vegetation cover, which can affect water retention and runoff.\n• Explore variations of the Trapping Rain Water problem, such as considering irregular elevation maps or incorporating real-time rainfall data for dynamic water trapping calculations.\n• Integrate Trapping Rain Water algorithms with GIS software to visualize water accumulation patterns on maps and assess their impact on urban development or natural ecosystems.\n• Investigate machine learning approaches to predict rainfall patterns and optimize water management strategies based on historical data and environmental factors.\n• Input: heights = [3, 1, 2, 4, 5] \n\nExpected output: 0 (no water trapped as each bar's height is greater than or equal to adjacent bars)\n• Input: heights = [0, 1000000000, 0, 1000000000, 0] \n\nExpected output: 0 (no water trapped as each bar's height is greater than or equal to adjacent bars)\n\nExplanation of the said Python code:\n• This function takes an array 'height' as input, representing the heights of bars in an elevation map.\n• It initializes variables 'n' to store the length of the 'height' array.\n• If the 'height' array is empty (n == 0), it returns 0 as there's no water trapped.\n• Two arrays, 'left_max' and 'right_max', are initialized to store the maximum height of bars to the left and right of each bar, respectively.\n• The 'left_max' array is computed by iterating through the 'height' array from left to right, storing the maximum height encountered so far.\n• The 'right_max' array is computed by iterating through the 'height' array from right to left, storing the maximum height encountered so far.\n• The amount of water trapped at each bar is calculated by taking the minimum of the maximum heights to the left and right of the bar and subtracting the height of the bar itself.\n• This calculation is performed for each bar, and the total amount of trapped water is accumulated.\n• The total amount of trapped water is returned as the result of the function.\n\nExplanation of the said Java code:\n• This method takes an array of integers 'height' as input and returns an integer representing the total amount of water trapped after raining.\n• It first checks if the length of the 'height' array is 0. If it is, it returns 0, indicating that there is no water trapped.\n• Two arrays, 'leftMax' and 'rightMax', are initialized to store the maximum height of bars to the left and right of each bar, respectively.\n• The 'leftMax' array is computed by iterating through the 'height' array from left to right, storing the maximum height encountered so far.\n• The 'rightMax' array is computed by iterating through the 'height' array from right to left, storing the maximum height encountered so far.\n• The amount of water trapped at each bar is calculated by taking the minimum of the maximum heights to the left and right of the bar and subtracting the height of the bar itself.\n• This calculation is performed for each bar, and the total amount of trapped water is accumulated.\n• The total amount of trapped water is returned as the result of the trap method.\n• This method serves as the entry point of the program.\n• It creates an instance of the \"Solution\" class and calls the \"trap()\" method with various test cases.\n• The results of the trap method for each test case are printed to the console.\n\nExplanation of the said C++ code:\n• The code begins by including the necessary libraries: iostream for input-output operations, vector for dynamic arrays, and algorithm for functions like min and max.\n• The \"Solution\" class is defined, containing the \"trap()\" method. This method takes a vector of integers ('height') by reference and returns an integer representing the total amount of trapped water.\n• It first calculates the size of the input vector 'height' and checks if it's empty. If empty, it returns 0.\n• Two vectors, 'leftMax' and 'rightMax', are created to store the left and right maximum heights encountered so far, respectively.\n• The 'leftMax' vector is filled by iterating through the input vector from left to right, storing the maximum height encountered at each position.\n• The 'rightMax' vector is filled by iterating through the input vector from right to left, storing the maximum height encountered at each position.\n• Finally, it calculates the trapped water at each position by taking the minimum of 'leftMax' and 'rightMax' for that position and subtracting the height of the current bar. The total trapped water is accumulated in the variable 'waterTrapped'.\n• An instance of the \"Solution\" class is created.\n• Test cases represented by vectors 'heights1' to 'heights5' are defined.\n• The \"trap()\" method is called for each test case, and the result is printed to the console using \"cout\".\n\nExplanation of the said C# code:\n• Using Directives: The code includes necessary using directives for basic functionalities like input-output operations and mathematical functions.\n• The \"Trap()\" method takes an integer array 'height' as input and returns the total trapped water as an integer.\n• It first calculates the length of the input array 'n'.\n• If n is 0 (indicating an empty array), it returns 0.\n• It initializes two arrays 'leftMax' and 'rightMax' to store the left and right maximum heights respectively.\n• It calculates the left maximum heights for each position in the 'height' array and stores them in the 'leftMax' array using a loop.\n• Similarly, it calculates the right maximum heights for each position in the 'height' array and stores them in the 'rightMax' array using a loop.\n• It then iterates through each position in the 'height' array and calculates the trapped water at that position by subtracting the current height from the minimum of the corresponding left and right maximum heights.\n• The calculated trapped water is accumulated in the variable waterTrapped.\n• The \"Main()\" method serves as the entry point of the program.\n• It creates an instance of the \"Solution\" class.\n• It calls the \"Trap()\" method for five different test cases and prints the result of each test case using \"Console.WriteLine\".\n\nExplanation of the said JavaScript code:\n• The \"trap()\" function takes an array 'height' as input.\n• It calculates the amount of water that can be trapped after raining based on the elevation map represented by the input array.\n• It initializes variables 'n' to store the length of the input array.\n• If the length 'n' is zero, indicating an empty array, it returns 0 as there is no water trapped.\n• It initializes arrays 'leftMax' and 'rightMax' to store the left and right maximum heights, respectively, for each position in the input array.\n• The 'leftMax' array is filled with zeros initially.\n• It iterates through the input array from left to right, updating 'leftMax' to store the maximum height encountered so far at each position.\n• Similarly, it iterates through the input array from right to left, updating 'rightMax' to store the maximum height encountered so far at each position.\n• It initializes a variable 'waterTrapped' to store the total trapped water.\n• It iterates through the input array, calculating the trapped water at each position based on the minimum of the left and right maximum heights minus the height of the current position.\n• It adds the calculated trapped water to the 'waterTrapped' variable.\n• The code consists of three main loops:\n• The first loop iterates over the height array to calculate the maximum height of bars to the left of each bar ('left_max'). This loop runs in O(n) time, where n is the length of the height array.\n• The second loop iterates over the height array in reverse to calculate the maximum height of bars to the right of each bar ('right_max'). This loop also runs in O(n) time.\n• The third loop iterates over the height array to calculate the amount of water trapped by each bar and accumulate the total trapped water. This loop runs in O(n) time.\n• Therefore, the overall time complexity of the code is O(n), where n is the length of the height array.\n• The code utilizes additional space to store two arrays ('left_max' and 'right_max') of size n, where n is the length of the height array. Hence, the space complexity of the code is O(n).\n• Apart from these arrays, the code uses a few extra variables ('n', 'water_trapped', and loop counters), which occupy constant space and do not affect space complexity.\n• Therefore, the overall space complexity of the code is O(n)."
    }
]