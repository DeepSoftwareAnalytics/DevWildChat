[
    {
        "link": "https://stackoverflow.com/questions/38249296/using-vuejs-with-a-php-variable",
        "document": "I'm attempting to bind a HTML element which contains a string echoed via PHP so that I can use it with VueJS. Essentially what I am going to be doing is switching between GBP and USD depending on some php/mysql database queries (USD is default value). Here is a simplified example of what I have tried so far.\n\nOf course I could just echo the php variable again, but the main reason I want to bind it to a VueJS element is so I can use the value of this element in my JS to do something like this...\n\nWorth noting that I already have a fair bit of VueJS working within this #app so it's nothing to do with the configuration of Vue being wrong, more a case of just not knowing the correct way to approach the issue."
    },
    {
        "link": "https://reddit.com/r/vuejs/comments/b8ijxz/using_php_variables_in_a_vue_application",
        "document": "I'm curious about using PHP variables within a Vue application and how feasible it is.\n\nThis thought came about because I was thinking up a possible WordPress plugin idea where there would be Settings set in the WordPress admin for this plugin. I would then take those settings and use them in Vue\n\nMy question is what is the best way to grab these values set in the WordPress admin and use them in a Vue application? Would it be to set up a REST API endpoint and grab the values that way or possibly a way to pass PHP variables to use within Vue?\n\nAny ideas on what is the best route to grab values set in the WordPress admin to use within a Vue application?"
    },
    {
        "link": "https://stackoverflow.com/questions/48611986/how-to-use-vue-js-and-php-on-one-server",
        "document": "So currently I have built an application that uses Vue.js and PHP. The PHP is my backend and talks a mysql database.\n\nI am running this on my local machine (Mac). When I run my vue.js side, I use the command npm run dev This starts a webserver and I view it by going to address localhost:8080.\n\nThen for the PHP I start another web server using MAMP. This runs Apache and Mysql. To access these they are stored at localhost:8888.\n\nI make post and get requests from the vue.js side to the PHP side. And the only way I can get this to work is by using a chrome extension called: Allow control Allow origin. Otherwise I get a cross origin error and they won't communicate.\n\nIs there therefore a way that I can run both on the same webserver? I'm not sure how"
    },
    {
        "link": "https://reddit.com/r/vuejs/comments/j7hw6d/best_practices_for_using_databases_with_vuejs",
        "document": "I am fairly new to Vue and JS as I've mainly worked with PHP and Laravel. I am building a Vue app that I would like to connect to a database (to handle user info and logins). What's the best way of accessing a database from the front-end? Is there any secure way? I know that variables can be accessed from the console, so how would I use secure credentials?"
    },
    {
        "link": "https://medium.com/@andrewmasonmedia/how-to-use-environmental-variables-env-in-vue-js-and-vite-ac2ee73480dd",
        "document": "Lately development best practice seems to be putting your API endpoints, login credentials, secrets, etc., into environmental variables which are supposed to make sensitive information more secure. I was going through this process the other day with a new Vite project which required me to look up how to do it again after using the Vue CLI. Here’s what I found.\n\nFirst, on their own, they aren’t secure. Environmental variables are exposed to the client if they’re being used in the frontend of a website or application. They are visible in the build bundle, and while it might be tedious to sift through, they are there to see. You can also see domains used in API calls, as well as other assets, so the idea that environmental variables prevent sensitive data from being seen isn’t accurate (which is what I initially thought). What does do — provided you add it to your file — is keep any app secrets or sensitive endpoints out of a github repo so they aren’t public. One other useful reason is to reduce redundancy in your code with variables/values that you’ll use a lot. Putting them in a global variable makes them easy to reuse.\n\nRead on to see how to use them in a Vue application with Vite.\n\nMost articles on the topic will tell you something like this:\n\nThey’ll go on to say it’s good practice to put any sensitive website or application data into environmental variables so they are secure. But how? And why?\n\nIf environmental variables are used on the frontend, i.e. an API endpoint used in a request to fetch some type of data, that variable will still be seen in the client/browser. It might only be visible in the application bundle (if you’re using a build tool), but it’s still there if someone is interested enough to find it. All that it does is dynamically swap in the variable wherever it’s used at run time — still, on the client.\n\nSo, while there are other uses for EVs, like setting up different types of data or credentials for different development environments (local, dev, production), the main application for using environmental variables — as said above — especially on the frontend, is to keep them out of your repo for a modicum of security, and to create reusable global variables which keep your code DRY.\n\nHow to do this in Vue and Vite\n\nI made a website recently that uses a headless CMS to provide the client with an intuitive GUI so they can change, add, and update text and images themselves. It’s a common developer task and becoming more so with the advent of headless CMSs.\n\nThis particular CMS exposes all the site content as an API in JSON format. So the Vue frontend consumes the endpoint and dynamically renders all the data. To create and consume an environmental variable in Vue and Vite, it’s pretty straightforward:\n\nIn your project’s ROOT, create a new file called\n• This is an important point to note. Do not put the file in the folder or in any other spot.\n• A common mistake is getting errors with files and variables not rendering — which largely can be solved by making sure your file is in the root.\n\nIn Vite, environmental variables need to be prefixed with as in\n\nFor reference with the Vue CLI, variables need to be prefixed with\n\nUse/access the variable throughout your application\n\nTo use environmental variables throughout your site or application in Vite, you use in front of your variable name: i.e.\n\nAnd for fetching API data for example (using ), you can call your environmental variable like this:\n\nTo avoid a few common errors when using EVs:\n• Make sure to restart your dev server after making any changes to your file.\n• Put your file in the project ROOT, not\n• See here for more troubleshooting.\n\nBe sure to add your file to so your variables don’t get stored in your repo.\n\nFor more on environmental variables, here’s an exhaustive article, here’s a good thread, find one more here on why you shouldn’t use them, and go straight to the source at the Vite docs."
    },
    {
        "link": "https://vuejs.org/guide/extras/ways-of-using-vue",
        "document": "We believe there is no \"one size fits all\" story for the web. This is why Vue is designed to be flexible and incrementally adoptable. Depending on your use case, Vue can be used in different ways to strike the optimal balance between stack complexity, developer experience and end performance.\n\nVue can be used as a standalone script file - no build step required! If you have a backend framework already rendering most of the HTML, or your frontend logic isn't complex enough to justify a build step, this is the easiest way to integrate Vue into your stack. You can think of Vue as a more declarative replacement of jQuery in such cases.\n\nVue also provides an alternative distribution called petite-vue that is specifically optimized for progressively enhancing existing HTML. It has a smaller feature set, but is extremely lightweight and uses an implementation that is more efficient in no-build-step scenarios.\n\nYou can use Vue to build standard Web Components that can be embedded in any HTML page, regardless of how they are rendered. This option allows you to leverage Vue in a completely consumer-agnostic fashion: the resulting web components can be embedded in legacy applications, static HTML, or even applications built with other frameworks.\n\nSome applications require rich interactivity, deep session depth, and non-trivial stateful logic on the frontend. The best way to build such applications is to use an architecture where Vue not only controls the entire page, but also handles data updates and navigation without having to reload the page. This type of application is typically referred to as a Single-Page Application (SPA).\n\nVue provides core libraries and comprehensive tooling support with amazing developer experience for building modern SPAs, including:\n\nSPAs typically require the backend to expose API endpoints - but you can also pair Vue with solutions like Inertia.js to get the SPA benefits while retaining a server-centric development model.\n\nPure client-side SPAs are problematic when the app is sensitive to SEO and time-to-content. This is because the browser will receive a largely empty HTML page, and has to wait until the JavaScript is loaded before rendering anything.\n\nVue provides first-class APIs to \"render\" a Vue app into HTML strings on the server. This allows the server to send back already-rendered HTML, allowing end users to see the content immediately while the JavaScript is being downloaded. Vue will then \"hydrate\" the application on the client side to make it interactive. This is called Server-Side Rendering (SSR) and it greatly improves Core Web Vital metrics such as Largest Contentful Paint (LCP).\n\nThere are higher-level Vue-based frameworks built on top of this paradigm, such as Nuxt, which allow you to develop a fullstack application using Vue and JavaScript.\n\nServer-side rendering can be done ahead of time if the required data is static. This means we can pre-render an entire application into HTML and serve them as static files. This improves site performance and makes deployment a lot simpler since we no longer need to dynamically render pages on each request. Vue can still hydrate such applications to provide rich interactivity on the client. This technique is commonly referred to as Static-Site Generation (SSG), also known as JAMStack.\n\nThere are two flavors of SSG: single-page and multi-page. Both flavors pre-render the site into static HTML, the difference is that:\n• None After the initial page load, a single-page SSG \"hydrates\" the page into an SPA. This requires more upfront JS payload and hydration cost, but subsequent navigations will be faster, since it only needs to partially update the page content instead of reloading the entire page.\n• None A multi-page SSG loads a new page on every navigation. The upside is that it can ship minimal JS - or no JS at all if the page requires no interaction! Some multi-page SSG frameworks such as Astro also support \"partial hydration\" - which allows you to use Vue components to create interactive \"islands\" inside static HTML.\n\nSingle-page SSGs are better suited if you expect non-trivial interactivity, deep session lengths, or persisted elements / state across navigations. Otherwise, multi-page SSG would be the better choice.\n\nThe Vue team also maintains a static-site generator called VitePress, which powers this website you are reading right now! VitePress supports both flavors of SSG. Nuxt also supports SSG. You can even mix SSR and SSG for different routes in the same Nuxt app.\n\nAlthough Vue is primarily designed for building web applications, it is by no means limited to just the browser. You can:\n• Build desktop and mobile apps from the same codebase with Quasar or Tauri\n• Use Vue's Custom Renderer API to build custom renderers, like those for the terminal!"
    },
    {
        "link": "https://vuejs.org/guide/scaling-up/ssr.html",
        "document": "Vue.js is a framework for building client-side applications. By default, Vue components produce and manipulate DOM in the browser as output. However, it is also possible to render the same components into HTML strings on the server, send them directly to the browser, and finally \"hydrate\" the static markup into a fully interactive app on the client.\n\nA server-rendered Vue.js app can also be considered \"isomorphic\" or \"universal\", in the sense that the majority of your app's code runs on both the server and the client.\n\nCompared to a client-side Single-Page Application (SPA), the advantage of SSR primarily lies in:\n• None Faster time-to-content: this is more prominent on slow internet or slow devices. Server-rendered markup doesn't need to wait until all JavaScript has been downloaded and executed to be displayed, so your user will see a fully-rendered page sooner. In addition, data fetching is done on the server-side for the initial visit, which likely has a faster connection to your database than the client. This generally results in improved Core Web Vitals metrics, better user experience, and can be critical for applications where time-to-content is directly associated with conversion rate.\n• None Unified mental model: you get to use the same language and the same declarative, component-oriented mental model for developing your entire app, instead of jumping back and forth between a backend templating system and a frontend framework.\n• None Better SEO: the search engine crawlers will directly see the fully rendered page. As of now, Google and Bing can index synchronous JavaScript applications just fine. Synchronous being the key word there. If your app starts with a loading spinner, then fetches content via Ajax, the crawler will not wait for you to finish. This means if you have content fetched asynchronously on pages where SEO is important, SSR might be necessary.\n\nThere are also some trade-offs to consider when using SSR:\n• None Development constraints. Browser-specific code can only be used inside certain lifecycle hooks; some external libraries may need special treatment to be able to run in a server-rendered app.\n• None More involved build setup and deployment requirements. Unlike a fully static SPA that can be deployed on any static file server, a server-rendered app requires an environment where a Node.js server can run.\n• None More server-side load. Rendering a full app in Node.js is going to be more CPU-intensive than just serving static files, so if you expect high traffic, be prepared for corresponding server load and wisely employ caching strategies.\n\nBefore using SSR for your app, the first question you should ask is whether you actually need it. It mostly depends on how important time-to-content is for your app. For example, if you are building an internal dashboard where an extra few hundred milliseconds on initial load doesn't matter that much, SSR would be an overkill. However, in cases where time-to-content is absolutely critical, SSR can help you achieve the best possible initial load performance.\n\nStatic Site Generation (SSG), also referred to as pre-rendering, is another popular technique for building fast websites. If the data needed to server-render a page is the same for every user, then instead of rendering the page every time a request comes in, we can render it only once, ahead of time, during the build process. Pre-rendered pages are generated and served as static HTML files.\n\nSSG retains the same performance characteristics of SSR apps: it provides great time-to-content performance. At the same time, it is cheaper and easier to deploy than SSR apps because the output is static HTML and assets. The keyword here is static: SSG can only be applied to pages providing static data, i.e. data that is known at build time and can not change between requests. Every time the data changes, a new deployment is needed.\n\nIf you're only investigating SSR to improve the SEO of a handful of marketing pages (e.g. , , , etc.), then you probably want SSG instead of SSR. SSG is also great for content-based websites such as documentation sites or blogs. In fact, this website you are reading right now is statically generated using VitePress, a Vue-powered static site generator.\n\nLet's take a look at the most bare-bones example of Vue SSR in action.\n• Create a new directory and into it\n• Add in so that Node.js runs in ES modules mode.\n\nIt should print the following to the command line:\n\ntakes a Vue app instance and returns a Promise that resolves to the rendered HTML of the app. It is also possible to stream rendering using the Node.js Stream API or Web Streams API. Check out the SSR API Reference for full details.\n\nWe can then move the Vue SSR code into a server request handler, which wraps the application markup with the full page HTML. We will be using for the next steps:\n\nFinally, run and visit . You should see the page working with the button.\n\nTry it on StackBlitz\n\nIf you click the button, you'll notice the number doesn't change. The HTML is completely static on the client since we are not loading Vue in the browser.\n\nTo make the client-side app interactive, Vue needs to perform the hydration step. During hydration, it creates the same Vue application that was run on the server, matches each component to the DOM nodes it should control, and attaches DOM event listeners.\n\nTo mount an app in hydration mode, we need to use instead of :\n\nNotice how we need to reuse the same app implementation as on the server. This is where we need to start thinking about code structure in an SSR app - how do we share the same application code between the server and the client?\n\nHere we will demonstrate the most bare-bones setup. First, let's split the app creation logic into a dedicated file, :\n\nThis file and its dependencies are shared between the server and the client - we call them universal code. There are a number of things you need to pay attention to when writing universal code, as we will discuss below.\n\nOur client entry imports the universal code, creates the app, and performs the mount:\n\nAnd the server uses the same app creation logic in the request handler:\n\nIn addition, in order to load the client files in the browser, we also need to:\n• Load the client entry by adding to the HTML shell.\n• Support usage like in the browser by adding an Import Map to the HTML shell.\n\nTry the completed example on StackBlitz. The button is now interactive!\n\nMoving from the example to a production-ready SSR app involves a lot more. We will need to:\n• None Support Vue SFCs and other build step requirements. In fact, we will need to coordinate two builds for the same app: one for the client, and one for the server. Vue components are compiled differently when used for SSR - templates are compiled into string concatenations instead of Virtual DOM render functions for more efficient rendering performance.\n• None In the server request handler, render the HTML with the correct client-side asset links and optimal resource hints. We may also need to switch between SSR and SSG mode, or even mix both in the same app.\n\nA complete implementation would be quite complex and depends on the build toolchain you have chosen to work with. Therefore, we highly recommend going with a higher-level, opinionated solution that abstracts away the complexity for you. Below we will introduce a few recommended SSR solutions in the Vue ecosystem.\n\nNuxt is a higher-level framework built on top of the Vue ecosystem which provides a streamlined development experience for writing universal Vue applications. Better yet, you can also use it as a static site generator! We highly recommend giving it a try.\n\nQuasar is a complete Vue-based solution that allows you to target SPA, SSR, PWA, mobile app, desktop app, and browser extension all using one codebase. It not only handles the build setup, but also provides a full collection of Material Design compliant UI components.\n\nVite provides built-in support for Vue server-side rendering, but it is intentionally low-level. If you wish to go directly with Vite, check out vite-plugin-ssr, a community plugin that abstracts away many challenging details for you.\n\nYou can also find an example Vue + Vite SSR project using manual setup here, which can serve as a base to build upon. Note this is only recommended if you are experienced with SSR / build tools and really want to have complete control over the higher-level architecture.\n\nRegardless of your build setup or higher-level framework choice, there are some principles that apply in all Vue SSR applications.\n\nDuring SSR, each request URL maps to a desired state of our application. There is no user interaction and no DOM updates, so reactivity is unnecessary on the server. By default, reactivity is disabled during SSR for better performance.\n\nSince there are no dynamic updates, lifecycle hooks such as or will NOT be called during SSR and will only be executed on the client. The only hooks that are called during SSR are and\n\nYou should avoid code that produces side effects that need cleanup in and or the root scope of . An example of such side effects is setting up timers with . In client-side only code we may setup a timer and then tear it down in or . However, because the unmount hooks will never be called during SSR, the timers will stay around forever. To avoid this, move your side-effect code into instead.\n\nUniversal code cannot assume access to platform-specific APIs, so if your code directly uses browser-only globals like or , they will throw errors when executed in Node.js, and vice-versa.\n\nFor tasks that are shared between server and client but with different platform APIs, it's recommended to wrap the platform-specific implementations inside a universal API, or use libraries that do this for you. For example, you can use to use the same fetch API on both server and client.\n\nFor browser-only APIs, the common approach is to lazily access them inside client-only lifecycle hooks such as .\n\nNote that if a third-party library is not written with universal usage in mind, it could be tricky to integrate it into a server-rendered app. You might be able to get it working by mocking some of the globals, but it would be hacky and may interfere with the environment detection code of other libraries.\n\nIn the State Management chapter, we introduced a simple state management pattern using Reactivity APIs. In an SSR context, this pattern requires some additional adjustments.\n\nThe pattern declares shared state in a JavaScript module's root scope. This makes them singletons - i.e. there is only one instance of the reactive object throughout the entire lifecycle of our application. This works as expected in a pure client-side Vue application, since the modules in our application are initialized fresh for each browser page visit.\n\nHowever, in an SSR context, the application modules are typically initialized only once on the server, when the server boots up. The same module instances will be reused across multiple server requests, and so will our singleton state objects. If we mutate the shared singleton state with data specific to one user, it can be accidentally leaked to a request from another user. We call this cross-request state pollution.\n\nWe can technically re-initialize all the JavaScript modules on each request, just like we do in browsers. However, initializing JavaScript modules can be costly, so this would significantly affect server performance.\n\nThe recommended solution is to create a new instance of the entire application - including the router and global stores - on each request. Then, instead of directly importing it in our components, we provide the shared state using app-level provide and inject it in components that need it:\n\nState Management libraries like Pinia are designed with this in mind. Consult Pinia's SSR guide for more details.\n\nIf the DOM structure of the pre-rendered HTML does not match the expected output of the client-side app, there will be a hydration mismatch error. Hydration mismatch is most commonly introduced by the following causes:\n• None The template contains invalid HTML nesting structure, and the rendered HTML got \"corrected\" by the browser's native HTML parsing behavior. For example, a common gotcha is that cannot be placed inside : If we produce this in our server-rendered HTML, the browser will terminate the first when is encountered and parse it into the following DOM structure:\n• None The data used during render contains randomly generated values. Since the same application will run twice - once on the server, and once on the client - the random values are not guaranteed to be the same between the two runs. There are two ways to avoid random-value-induced mismatches:\n• None Use + to render the part that depends on random values only on the client. Your framework may also have built-in features to make this easier, for example the component in VitePress.\n• None Use a random number generator library that supports generating with seeds, and guarantee the server run and the client run are using the same seed (e.g. by including the seed in serialized state and retrieving it on the client).\n• None The server and the client are in different time zones. Sometimes, we may want to convert a timestamp into the user's local time. However, the timezone during the server run and the timezone during the client run are not always the same, and we may not reliably know the user's timezone during the server run. In such cases, the local time conversion should also be performed as a client-only operation.\n\nWhen Vue encounters a hydration mismatch, it will attempt to automatically recover and adjust the pre-rendered DOM to match the client-side state. This will lead to some rendering performance loss due to incorrect nodes being discarded and new nodes being mounted, but in most cases, the app should continue to work as expected. That said, it is still best to eliminate hydration mismatches during development.\n\nIn Vue 3.5+, it is possible to selectively suppress inevitable hydration mismatches by using the attribute.\n\nSince most custom directives involve direct DOM manipulation, they are ignored during SSR. However, if you want to specify how a custom directive should be rendered (i.e. what attributes it should add to the rendered element), you can use the directive hook:\n\nTeleports require special handling during SSR. If the rendered app contains Teleports, the teleported content will not be part of the rendered string. An easier solution is to conditionally render the Teleport on mount.\n\nIf you do need to hydrate teleported content, they are exposed under the property of the ssr context object:\n\nYou need to inject the teleport markup into the correct location in your final page HTML similar to how you need to inject the main app markup."
    },
    {
        "link": "https://stackoverflow.com/questions/3613186/what-is-the-safest-way-of-passing-arguments-from-server-side-php-to-client-side",
        "document": "In my application I rely heavily on JavaScript to enhance the user interface, but all of the data comes from a database and is processed by PHP. By default I use 'echo' statements to substitute the required values \"just in time\" like so:\n\nThis, however, does not strike me as very elegant and I am concerned about stability and maintainability of such code.\n\nDo I have any alternatives here?\n\nFor server-side, I am using the Symfony 1.4 PHP framework."
    },
    {
        "link": "https://vueschool.io/articles/vuejs-tutorials/the-ultimate-guide-for-using-vue-js-with-laravel",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/58602121/how-to-integrate-vue-js-to-server-side-rendering-application",
        "document": "We all know that vue js is for client side but I have an app which is server side rendering using keystone js but there is one part of the app that requires SPA and that is where i want to integrate vue js.\n\nWhat i did is in the index.js I render the html\n\nthe html contains the following code but it vue does not work on doing this way.\n\nIs this the right way to integrate vue js to a back-end rendered designe app?\n\nOr i really need to generate whole vue project ? but only one page of my app that needs vue js (SPA) .\n\ntHANK YOU. Help would be appreciated."
    }
]