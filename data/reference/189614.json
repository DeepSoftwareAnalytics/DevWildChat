[
    {
        "link": "https://stackoverflow.com/questions/33119314/best-practice-for-error-codes-in-batch-processing",
        "document": "I have a CLI tool that processes a bunch of objects, and I would like to use the exit code to signal whether everything worked well or not.\n\nNow, if everything is fine I return . This is pretty simply and obvious.\n\nBut what do I do if one of the processed objects fails? Should I simply return a , which then effectively means \"Something went wrong\"? Or should I return the number of failed objects as an error code?\n\nThe problem here is that I am not sure about the semantics of the error code: Basically it would be interesting to know how many objects have failed, but on the other hand this means that I can not distinguish different errors from each other, because the error code is not related any longer to the actual type of the error.\n\nAre the any best practices on how to solve this?"
    },
    {
        "link": "https://stackoverflow.com/questions/62018535/what-is-the-best-practice-to-load-and-update-data-using-redis-and-mysql",
        "document": "I am using Redis as caching layer and I'd like to know what is the best practice or how to use it properly alongside with DB (in this case MySQL).\n\nHere I have an example of user dashboard function:\n\nHowever this else statement is never reached somehow even though from cache might be empty. Is there a better way to do this?\n\nAlso while updating... Is there a better way to automatically update both (cache and DB) when data in one of them is changed.\n\nAt the moment I do it like this but sometimes only one of them might be changed and then cache data (or vice-versa, DB data) are not synchronized/updated.\n\nThis is my first experience with Redis and caching in general, so any help is appreciated."
    },
    {
        "link": "https://redis.io/docs/latest/develop/reference/protocol-spec",
        "document": "Redis serialization protocol (RESP) is the wire protocol that clients implement\n\nTo communicate with the Redis server, Redis clients use a protocol called Redis Serialization Protocol (RESP). While the protocol was designed specifically for Redis, you can use it for other client-server software projects.\n\nRESP is a compromise among the following considerations:\n\nRESP can serialize different data types including integers, strings, and arrays. It also features an error-specific type. A client sends a request to the Redis server as an array of strings. The array's contents are the command and its arguments that the server should execute. The server's reply type is command-specific.\n\nRESP is binary-safe and uses prefixed length to transfer bulk data so it does not require processing bulk data transferred from one process to another.\n\nRESP is the protocol you should implement in your Redis client.\n\nSupport for the first version of the RESP protocol was introduced in Redis 1.2. Using RESP with Redis 1.2 was optional and had mainly served the purpose of working the kinks out of the protocol.\n\nIn Redis 2.0, the protocol's next version, a.k.a RESP2, became the standard communication method for clients with the Redis server.\n\nRESP3 is a superset of RESP2 that mainly aims to make a client author's life a little bit easier. Redis 6.0 introduced experimental opt-in support of RESP3's features (excluding streaming strings and streaming aggregates). In addition, the introduction of the command allows clients to handshake and upgrade the connection's protocol version (see Client handshake).\n\nUp to and including Redis 7, both RESP2 and RESP3 clients can invoke all core commands. However, commands may return differently typed replies for different protocol versions.\n\nFuture versions of Redis may change the default protocol version, but it is unlikely that RESP2 will become entirely deprecated. It is possible, however, that new features in upcoming versions will require the use of RESP3.\n\nA client connects to a Redis server by creating a TCP connection to its port (the default is 6379).\n\nWhile RESP is technically non-TCP specific, the protocol is used exclusively with TCP connections (or equivalent stream-oriented connections like Unix sockets) in the context of Redis.\n\nThe Redis server accepts commands composed of different arguments. Then, the server processes the command and sends the reply back to the client.\n\nThis is the simplest model possible; however, there are some exceptions:\n• Redis requests can be pipelined. Pipelining enables clients to send multiple commands at once and wait for replies later.\n• When a RESP2 connection subscribes to a Pub/Sub channel, the protocol changes semantics and becomes a push protocol. The client no longer requires sending commands because the server will automatically send new messages to the client (for the channels the client is subscribed to) as soon as they are received.\n• The command. Invoking the command switches the connection to an ad-hoc push mode. The protocol of this mode is not specified but is obvious to parse.\n• Protected mode. Connections opened from a non-loopback address to a Redis while in protected mode are denied and terminated by the server. Before terminating the connection, Redis unconditionally sends a reply, regardless of whether the client writes to the socket.\n• The RESP3 Push type. As the name suggests, a push type allows the server to send out-of-band data to the connection. The server may push data at any time, and the data isn't necessarily related to specific commands executed by the client.\n\nExcluding these exceptions, the Redis protocol is a simple request-response protocol.\n\nRESP is essentially a serialization protocol that supports several data types. In RESP, the first byte of data determines its type.\n\nRedis generally uses RESP as a request-response protocol in the following way:\n• Clients send commands to a Redis server as an array of bulk strings. The first (and sometimes also the second) bulk string in the array is the command's name. Subsequent elements of the array are the arguments for the command.\n• The server replies with a RESP type. The reply's type is determined by the command's implementation and possibly by the client's protocol version.\n\nRESP is a binary protocol that uses control sequences encoded in standard ASCII. The character, for example, is encoded with the binary byte of value 65. Similarly, the characters CR ( ), LF ( ) and SP ( ) have binary byte values of 13, 10 and 32, respectively.\n\nThe (CRLF) is the protocol's terminator, which always separates its parts.\n\nThe first byte in an RESP-serialized payload always identifies its type. Subsequent bytes constitute the type's contents.\n\nWe categorize every RESP data type as either simple, bulk or aggregate.\n\nSimple types are similar to scalars in programming languages that represent plain literal values. Booleans and Integers are such examples.\n\nRESP strings are either simple or bulk. Simple strings never contain carriage return ( ) or line feed ( ) characters. Bulk strings can contain any binary data and may also be referred to as binary or blob. Note that bulk strings may be further encoded and decoded, e.g. with a wide multi-byte encoding, by the client.\n\nAggregates, such as Arrays and Maps, can have varying numbers of sub-elements and nesting levels.\n\nThe following table summarizes the RESP data types that Redis supports:\n\nSimple strings are encoded as a plus ( ) character, followed by a string. The string mustn't contain a CR ( ) or LF ( ) character and is terminated by CRLF (i.e., ).\n\nSimple strings transmit short, non-binary strings with minimal overhead. For example, many Redis commands reply with just \"OK\" on success. The encoding of this Simple String is the following 5 bytes:\n\nWhen Redis replies with a simple string, a client library should return to the caller a string value composed of the first character after the up to the end of the string, excluding the final CRLF bytes.\n\nTo send binary strings, use bulk strings instead.\n\nRESP has specific data types for errors. Simple errors, or simply just errors, are similar to simple strings, but their first character is the minus ( ) character. The difference between simple strings and errors in RESP is that clients should treat errors as exceptions, whereas the string encoded in the error type is the error message itself.\n\nRedis replies with an error only when something goes wrong, for example, when you try to operate against the wrong data type, or when the command does not exist. The client should raise an exception when it receives an Error reply.\n\nThe following are examples of error replies:\n\nThe first upper-case word after the , up to the first space or newline, represents the kind of error returned. This word is called an error prefix. Note that the error prefix is a convention used by Redis rather than part of the RESP error type.\n\nFor example, in Redis, is a generic error, whereas is a more specific error that implies that the client attempted an operation against the wrong data type. The error prefix allows the client to understand the type of error returned by the server without checking the exact error message.\n\nA client implementation can return different types of exceptions for various errors, or provide a generic way for trapping errors by directly providing the error name to the caller as a string.\n\nHowever, such a feature should not be considered vital as it is rarely useful. Also, simpler client implementations can return a generic error value, such as .\n\nThis type is a CRLF-terminated string that represents a signed, base-10, 64-bit integer.\n\nRESP encodes integers in the following way:\n• The colon ( ) as the first byte.\n• An optional plus ( ) or minus ( ) as the sign.\n• One or more decimal digits ( .. ) as the integer's unsigned, base-10 value.\n\nFor example, and are integer replies (of zero and one thousand, respectively).\n\nMany Redis commands return RESP integers, including , , and . An integer, by itself, has no special meaning other than in the context of the command that returned it. For example, it is an incremental number for , a UNIX timestamp for , and so forth. However, the returned integer is guaranteed to be in the range of a signed 64-bit integer.\n\nIn some cases, integers can represent true and false Boolean values. For instance, returns 1 for true and 0 for false.\n\nOther commands, including , , and , return 1 when the data changes and 0 otherwise.\n\nA bulk string represents a single binary string. The string can be of any size, but by default, Redis limits it to 512 MB (see the configuration directive).\n\nRESP encodes bulk strings in the following way:\n• The dollar sign ( ) as the first byte.\n• One or more decimal digits ( .. ) as the string's length, in bytes, as an unsigned, base-10 value.\n\nSo the string \"hello\" is encoded as follows:\n\nWhereas RESP3 has a dedicated data type for null values, RESP2 has no such type. Instead, due to historical reasons, the representation of null values in RESP2 is via predetermined forms of the bulk strings and arrays types.\n\nThe null bulk string represents a non-existing value. The command returns the Null Bulk String when the target key doesn't exist.\n\nIt is encoded as a bulk string with the length of negative one (-1), like so:\n\nA Redis client should return a nil object when the server replies with a null bulk string rather than the empty string. For example, a Ruby library should return while a C library should return (or set a special flag in the reply object).\n\nClients send commands to the Redis server as RESP arrays. Similarly, some Redis commands that return collections of elements use arrays as their replies. An example is the command that returns elements of a list.\n\nRESP Arrays' encoding uses the following format:\n• An asterisk ( ) as the first byte.\n• One or more decimal digits ( .. ) as the number of elements in the array as an unsigned, base-10 value.\n• An additional RESP type for every element of the array.\n\nSo an empty Array is just the following:\n\nWhereas the encoding of an array consisting of the two bulk strings \"hello\" and \"world\" is:\n\nAs you can see, after the part prefixing the array, the other data types that compose the array are concatenated one after the other. For example, an Array of three integers is encoded as follows:\n\nArrays can contain mixed data types. For instance, the following encoding is of a list of four integers and a bulk string:\n\n(The raw RESP encoding is split into multiple lines for readability).\n\nThe first line the server sent is . This numeric value tells the client that five reply types are about to follow it. Then, every successive reply constitutes an element in the array.\n\nAll of the aggregate RESP types support nesting. For example, a nested array of two arrays is encoded as follows:\n\n(The raw RESP encoding is split into multiple lines for readability).\n\nThe above encodes a two-element array. The first element is an array that, in turn, contains three integers (1, 2, 3). The second element is another array containing a simple string and an error.\n\nWhereas RESP3 has a dedicated data type for null values, RESP2 has no such type. Instead, due to historical reasons, the representation of null values in RESP2 is via predetermined forms of the Bulk Strings and arrays types.\n\nNull arrays exist as an alternative way of representing a null value. For instance, when the command times out, it returns a null array.\n\nThe encoding of a null array is that of an array with the length of -1, i.e.:\n\nWhen Redis replies with a null array, the client should return a null object rather than an empty array. This is necessary to distinguish between an empty list and a different condition (for instance, the timeout condition of the command).\n\nSingle elements of an array may be null bulk string. This is used in Redis replies to signal that these elements are missing and not empty strings. This can happen, for example, with the command when used with the option if the specified key is missing.\n\nHere's an example of an array reply containing a null element:\n\nAbove, the second element is null. The client library should return to its caller something like this:\n\nNulls' encoding is the underscore ( ) character, followed by the CRLF terminator ( ). Here's Null's raw RESP encoding:\n\nThis type is similar to the bulk string, with the addition of providing a hint about the data's encoding.\n\nA verbatim string's RESP encoding is as follows:\n• An equal sign ( ) as the first byte.\n• One or more decimal digits ( .. ) as the string's total length, in bytes, as an unsigned, base-10 value.\n• Exactly three (3) bytes represent the data's encoding.\n• The colon ( ) character separates the encoding and data.\n\n(The raw RESP encoding is split into multiple lines for readability).\n\nSome client libraries may ignore the difference between this type and the string type and return a native string in both cases. However, interactive clients, such as command line interfaces (e.g., ), can use this type and know that their output should be presented to the human user as is and without quoting the string.\n\nFor example, the Redis command outputs a report that includes newlines. When using RESP3, displays it correctly because it is sent as a Verbatim String reply (with its three bytes being \"txt\"). When using RESP2, however, the is hard-coded to look for the command to ensure its correct display to the user.\n\nThe RESP map encodes a collection of key-value tuples, i.e., a dictionary or a hash.\n\nIt is encoded as follows:\n• A percent character ( ) as the first byte.\n• One or more decimal digits ( .. ) as the number of entries, or key-value tuples, in the map as an unsigned, base-10 value.\n• Two additional RESP types for every key and value in the map.\n\nFor example, the following JSON object:\n\nCan be encoded in RESP like so:\n\n(The raw RESP encoding is split into multiple lines for readability).\n\nBoth map keys and values can be any of RESP's types.\n\nRedis clients should return the idiomatic dictionary type that their language provides. However, low-level programming languages (such as C, for example) will likely return an array along with type information that indicates to the caller that it is a dictionary.\n\nRESP2 doesn't have a map type. A map in RESP2 is represented by a flat array containing the keys and the values. The first element is a key, followed by the corresponding value, then the next key and so on, like this: . RESP2 doesn't have a map type. A map in RESP2 is represented by a flat array containing the keys and the values. The first element is a key, followed by the corresponding value, then the next key and so on, like this:\n\nThe attribute type is exactly like the Map type, but instead of a character as the first byte, the character is used. Attributes describe a dictionary exactly like the Map type. However the client should not consider such a dictionary part of the reply, but as auxiliary data that augments the reply.\n\nNote: in the examples below, indentation is shown only for clarity; the additional whitespace would not be part of a real reply.\n\nFor example, newer versions of Redis may include the ability to report the popularity of keys for every executed command. The reply to the command may be the following:\n\nThe actual reply to is just the two item array . The returned attributes specify the popularity, or frequency of requests, given as floating point numbers ranging from to , of the keys mentioned in the original command. Note: the actual implementation in Redis may differ.\n\nWhen a client reads a reply and encounters an attribute type, it should read the attribute, and continue reading the reply. The attribute reply should be accumulated separately, and the user should have a way to access such attributes. For instance, if we imagine a session in an higher level language, something like this could happen:\n\nAttributes can appear anywhere before a valid part of the protocol identifying a given type, and supply information only about the part of the reply that immediately follows. For example:\n\nIn the above example the third element of the array has associated auxiliary information of . Note that it's not up to the client library to interpret the attributes, but it should pass them to the caller in a sensible way.\n\nSets are somewhat like Arrays but are unordered and should only contain unique elements.\n• A tilde ( ) as the first byte.\n• One or more decimal digits ( .. ) as the number of elements in the set as an unsigned, base-10 value.\n• An additional RESP type for every element of the Set.\n\nClients should return the native set type if it is available in their programming language. Alternatively, in the absence of a native set type, an array coupled with type information can be used (in C, for example).\n\nRESP's pushes contain out-of-band data. They are an exception to the protocol's request-response model and provide a generic push mode for connections.\n\nPush events are encoded similarly to arrays, differing only in their first byte:\n• A greater-than sign ( ) as the first byte.\n• One or more decimal digits ( .. ) as the number of elements in the message as an unsigned, base-10 value.\n• An additional RESP type for every element of the push event.\n\nPushed data may precede or follow any of RESP's data types but never inside them. That means a client won't find push data in the middle of a map reply, for example. It also means that pushed data may appear before or after a command's reply, as well as by itself (without calling any command).\n\nClients should react to pushes by invoking a callback that implements their handling of the pushed data.\n\nNew RESP connections should begin the session by calling the command. This practice accomplishes two things:\n• It allows servers to be backward compatible with RESP2 versions. This is needed in Redis to make the transition to version 3 of the protocol gentler.\n• The command returns information about the server and the protocol that the client can use for different goals.\n\nThe command has the following high-level syntax:\n\nThe first argument of the command is the protocol version we want the connection to be set. By default, the connection starts in RESP2 mode. If we specify a connection version that is too big and unsupported by the server, it should reply with a error. Example:\n\nClient: HELLO 4 Server: -NOPROTO sorry, this protocol version is not supported.\n\nAt that point, the client may retry with a lower protocol version.\n\nSimilarly, the client can easily detect a server that is only able to speak RESP2:\n\nThe client can then proceed and use RESP2 to communicate with the server.\n\nNote that even if the protocol's version is supported, the command may return an error, perform no action and remain in RESP2 mode. For example, when used with invalid authentication credentials in the command's optional clause:\n\nClient: HELLO 3 AUTH default mypassword Server: -ERR invalid password (the connection remains in RESP2 mode)\n\nA successful reply to the command is a map reply. The information in the reply is partly server-dependent, but certain fields are mandatory for all the RESP3 implementations:\n• server: \"redis\" (or other software name).\n• proto: the highest supported version of the RESP protocol.\n\nIn Redis' RESP3 implementation, the following fields are also emitted:\n• modules: list of loaded modules as an Array of Bulk Strings.\n\nNow that you are familiar with the RESP serialization format, you can use it to help write a Redis client library. We can further specify how the interaction between the client and the server works:\n• A client sends the Redis server an array consisting of only bulk strings.\n• A Redis server replies to clients, sending any valid RESP data type as a reply.\n\nSo, for example, a typical interaction could be the following.\n\nThe client sends the command to get the length of the list stored at the key mylist. Then the server replies with an integer reply as in the following example ( is the client, the server).\n\nC: *2\\r\n\n C: $4\\r\n\n C: LLEN\\r\n\n C: $6\\r\n\n C: mylist\\r\n\n S: :48293\\r\n\n\n\nAs usual, we separate different parts of the protocol with newlines for simplicity, but the actual interaction is the client sending as a whole.\n\nA client can use the same connection to issue multiple commands. Pipelining is supported, so multiple commands can be sent with a single write operation by the client. The client can skip reading replies and continue to send the commands one after the other. All the replies can be read at the end.\n\nFor more information, see Pipelining.\n\nSometimes you may need to send a command to the Redis server but only have available. While the Redis protocol is simple to implement, it is not ideal for interactive sessions, and may not always be available. For this reason, Redis also accepts commands in the inline command format.\n\nThe following example demonstrates a server/client exchange using an inline command (the server chat starts with , the client chat with ):\n\nHere's another example of an inline command where the server returns an integer:\n\nBasically, to issue an inline command, you write space-separated arguments in a telnet session. Since no command starts with (the identifying byte of RESP Arrays), Redis detects this condition and parses your command inline.\n\nWhile the Redis protocol is human-readable and easy to implement, its implementation can exhibit performance similar to that of a binary protocol.\n\nRESP uses prefixed lengths to transfer bulk data. That makes scanning the payload for special characters unnecessary (unlike parsing JSON, for example). For the same reason, quoting and escaping the payload isn't needed.\n\nReading the length of aggregate types (for example, bulk strings or arrays) can be processed with code that performs a single operation per character while at the same time scanning for the CR character.\n\n/* Now p points at '\\r', and the length is in len. */\n\nAfter the first CR is identified, it can be skipped along with the following LF without further processing. Then, the bulk data can be read with a single read operation that doesn't inspect the payload in any way. Finally, the remaining CR and LF characters are discarded without additional processing.\n\nWhile comparable in performance to a binary protocol, the Redis protocol is significantly more straightforward to implement in most high-level languages, reducing the number of bugs in client software.\n• For testing purposes, use Lua's type conversions to have Redis reply with any RESP2/RESP3 needed. As an example, a RESP3 double can be generated like so:"
    },
    {
        "link": "https://aws.amazon.com/blogs/database/best-practices-redis-clients-and-amazon-elasticache-for-redis",
        "document": "In this post, we cover best practices for interacting with Amazon ElastiCache for Redis resources with commonly used open-source Redis client libraries. ElastiCache is compatible with open-source Redis. However, you may still have questions about how to optimize your applications and associated Redis client library configurations to interact with ElastiCache. These issues typically arise when operating ElastiCache clusters at a large scale, or gracefully handling cluster resize events. Learn best practices for common scenarios and follow along with code examples of some of the most popular open source Redis client libraries (redis-py, PHPRedis, and Lettuce).\n\nIndividual ElastiCache for Redis nodes support up to 65,000 concurrent client connections. However, to optimize for performance, we advise that client applications do not constantly operate at that level of connection. Redis is a single-threaded process based on an event loop where incoming client requests are handled sequentially. That means the response time of a given client becomes longer as the number of connected clients increases.\n\nYou can take the following set of actions to avoid hitting a connection bottleneck on the Redis server:\n• Perform read operations from read replicas. This can be done by using the ElastiCache reader endpoints in cluster mode disabled or by using replicas for reads in cluster mode enabled.\n• Distribute write traffic across multiple primary nodes. You can do this in two ways. You can use a multi-sharded Redis cluster with a Redis cluster mode capable client. You could also write to multiple primary nodes in cluster mode disabled with client-side sharding.\n• Use a connection pool when available in your client library.\n\nIn general, creating a TCP connection is a computationally expensive operation compared to typical Redis commands. For example, handling a SET/GET request is an order of magnitude faster when reusing an existing connection. Using a client connection pool with a finite size reduces the overhead of connection management. It also bounds the number of concurrent incoming connections from the client application.\n\nThe following code example of PHPRedis shows that a new connection is created for each new user request:\n\nWe benchmarked this code in a loop on an Amazon Elastic Compute Cloud (Amazon EC2) instance connected to a Graviton2 (m6g.2xlarge) ElastiCache for Redis node. We placed both the client and server at the same Availability Zone. The average latency of the entire operation was 2.82 milliseconds.\n\nWhen we updated the code and used persistent connections and a connection pool, the average latency of the entire operation was 0.21 milliseconds:\n\nThe following code is an example of a Redis-py connection pool:\n\nThe following code is an example of a Lettuce connection pool:\n\nWhen connecting to an ElastiCache for Redis cluster in cluster mode enabled, the corresponding Redis client library must be cluster aware. The clients must obtain a map of hash slots to the corresponding nodes in the cluster in order to send requests to the right nodes and avoid the performance overhead of handing cluster redirections. As a result, the client must discover a complete list of slots and the mapped nodes in two different situations:\n• The client is initialized and must populate the initial slots configuration\n• A MOVED redirection is received from the server, such as in the situation of a failover when all slots served by the former primary node are taken over by the replica, or re-sharding when slots are being moved from the source primary to the target primary node\n\nClient discovery is usually done via issuing a CLUSTER SLOT or CLUSTER NODE command to the Redis server. We recommend the CLUSTER SLOT method because it returns the set of slot ranges and the associated primary and replica nodes back to the client. This doesn’t require additional parsing from the client and is more efficient.\n\nDepending on the cluster topology, the size of the response for the CLUSTER SLOT command can vary based on the cluster size. Larger clusters with more nodes produce a larger response. As a result, it’s important to ensure that the number of clients doing the cluster topology discovery doesn’t grow unbounded. For example, when the client application starts up or loses connection from the server and must perform cluster discovery, one common mistake is that the client application fires several reconnection and discovery requests without adding exponential backoff upon retry. This can render the Redis server unresponsive for a prolonged period of time, with the CPU utilization at 100%. The outage is prolonged if each CLUSTER SLOT command must process a large number of nodes in the cluster bus. We have observed multiple client outages in the past due to this behavior across a number of different languages including Python (redis-py-cluster) and Java (Lettuce and Redisson).\n\nTo mitigate the impact caused by a sudden influx of connection and discovery requests, we recommend the following:\n• Implement a client connection pool with a finite size to bound the number of concurrent incoming connections from the client application.\n• When the client disconnects from the server due to timeout, retry with exponential backoff with jitter. This helps to avoid multiple clients overwhelming the server at the same time.\n• Use the ElastiCache Configuration Endpoint to perform cluster discovery. In doing so, you spread the discovery load across all nodes in the cluster (up to 90) instead of hitting a few hardcoded seed nodes in the cluster.\n\nThe following are some code examples for exponential backoff retry logic in redis-py, PHPRedis, and Lettuce.\n\nredis-py has a built-in retry mechanism that retries one time immediately after a failure. This mechanism can be enabled through the argument supplied when creating a Redis object. Here we demonstrate a custom retry mechanism with exponential backoff and jitter. We’ve submitted a pull request to natively implement exponential backoff in redis-py (#1494). In the future it may not be necessary to implement manually.\n\nYou can then use the following code to set a value:\n\nDepending on your workload, you might want to change the base backoff value from 1 second to a few tens or hundreds of milliseconds for latency-sensitive workloads.\n\nPHPRedis has a built-in retry mechanism that retries a (non-configurable) maximum of 10 times. There is a configurable delay between tries (with a jitter from the second retry onwards). For more information, see the following sample code. We’ve submitted a pull request to natively implement exponential backoff in PHPredis (#1986) that has since been merged and documented. For those on the latest release of PHPRedis, it won’t be necessary to implement manually but we’ve included the reference here for those on previous versions. For now, the following is a code example that configures the delay of the retry mechanism:\n\nLettuce has built-in retry mechanisms based on the exponential backoff strategies described in the post Exponential Backoff and Jitter. The following is a code excerpt showing the full jitter approach:\n\nConfigure the client-side timeout appropriately to allow the server sufficient time to process the request and generate the response. This also allows it to fail fast if the connection to the server can’t be established. Certain Redis commands can be more computationally expensive than others. For example, Lua scripts or MULTI/EXEC transactions that contain multiple commands that must be run atomically. In general, a higher client-side timeout is recommended to avoid a time out of the client before the response is received from the server, including the following:\n• Running MULTI/EXEC transactions or Lua scripts that consist of multiple individual Redis commands\n\nIn case of a blocking operation such as BLPOP, the best practice is to set the command timeout to a number lower than the socket timeout.\n\nThe following are code examples for implementing a client-side timeout in redis-py, PHPRedis, and Lettuce.\n\nThe following is a code example with redis-py:\n\nThe following is a code example with PHPRedis:\n\nThe following is a code example with Lettuce:\n\nWe have observed cases when a customer’s application has a high number of idle clients connected, but isn’t actively sending commands. In such scenarios, you can exhaust all 65,000 connections with a high number of idle clients. To avoid such scenarios, configure the timeout setting appropriately on the server via ElastiCache Redis parameter groups. This ensures that the server actively disconnects idle clients to avoid an increase in the number of connections.\n\nRedis supports more than 200 commands, including those to run Lua scripts. However, when it comes to Lua scripts, there are several pitfalls that can affect memory and availability of Redis.\n\nEach Lua script is cached on the Redis server before it runs. Unparameterized Lua scripts are unique, which can lead to the Redis server storing a large number of Lua scripts and consuming more memory. To mitigate this, ensure that all Lua scripts are parameterized and regularly perform SCRIPT FLUSH to clean up cached Lua scripts if needed.\n\nThe following example shows how to use parameterized scripts. First, we have an example of an unparameterized approach that results in three different cached Lua scripts and is not recommended:\n\nInstead, use the following pattern to create a single script that can accept passed parameters:\n\nLua scripts can run multiple commands atomically, so it can take longer to complete than a regular Redis command. If the Lua script only runs read-only operations, you can stop it in the middle. However, as soon as the Lua script performs a write operation, it becomes unkillable and must run to completion. A long-running Lua script that is mutating can cause the Redis server to be unresponsive for a long time. To mitigate this issue, avoid long-running Lua scripts and test the script out in a pre-production environment.\n\nThere are a few ways a Lua script can continue to write new data into Redis even when Redis is over :\n• The script starts when the Redis server is below , and contains multiple write operations inside\n• The script’s first write command isn’t consuming memory (such as DEL), followed by more write operations that consume memory\n\nYou can mitigate this problem by configuring a proper eviction policy in Redis server other than . This allows Redis to evict items and free up memory in between Lua scripts.\n\nWe have observed cases where an application stores large composite items in Redis (such as a multi-GB hash dataset). This is not a recommended practice because it often leads to performance problems in Redis. For example, the client can do a HGETALL command to retrieve the entire multi GB hash collection. This can generate significant memory pressure to the Redis server buffering the large item in the client output buffer. Also, for slot migration in cluster mode, ElastiCache doesn’t migrate slots that contain items with serialized size that is larger than 256 MB.\n\nTo solve the large item problems, we have the following recommendations:\n• Break up the large composite item into multiple smaller items. For example, break up a large hash collection into individual key-value fields with a key name scheme that appropriately reflects the collection, such as using a common prefix in the key name to identify the collection of items. If you must access multiple fields in the same collection atomically, you can use the MGET command to retrieve multiple key-values in the same command.\n• If you evaluated all options and still can’t break up the large collection dataset, try to use commands that operate on a subset of the data in the collection instead of the entire collection. Avoid having a use case that requires you to atomically retrieve the entire multi-GB collection in the same command. One example is using HGET or HMGET commands instead of HGETALL on hash collections.\n\nIn this post, we reviewed Redis client library best practices when using ElastiCache, and ways to avoid common pitfalls. By adhering to best practices, you can increase the performance, reliability, and operational excellence of your ElastiCache environments. If you have any questions or feedback, reach out on the Amazon ElastiCache discussion forum or in the comments.\n\nQu Chen is a senior software development engineer at Amazon ElastiCache – the team responsible for building, operating and maintaining the highly scalable and performant Redis managed service at AWS. In addition, he is an active contributor to the open-source Redis project. In his spare time, he enjoys sports, outdoor activities and playing piano music.\n\nJim Gallagher is an Amazon ElastiCache Specialist Solutions Architect based in Austin, TX. He helps AWS customers across the world best leverage the power, simplicity, and beauty of Redis. Outside of work he enjoys exploring the Texas Hill Country with his wife and son.\n\nNathaniel Braun is a Senior Software Development Engineer at Amazon Web Services, based in Tel Aviv, Israel. He designs and operates large-scale distributed systems and likes to tackle difficult problems with his team. Outside of works he enjoys hiking, sailing, and drinking coffee.\n\nAsaf Porat Stoler​ is a Software Development Manager at Amazon ElastiCache, based in Tel Aviv, Israel. He has vast and diverse experience in storage systems, data reduction, and in-memory databases, and likes performance and resource ​optimizations. Outside of work he enjoys sport, hiking, and spending time with his family."
    },
    {
        "link": "https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f",
        "document": "\n• Set AbortConnect to false, then let the ConnectionMultiplexer reconnect automatically. See here for details\n• Reuse the ConnectionMultiplexer - do not create a new one for each request. The pattern shown here is strongly recommended.\n• Be aware of the performance costs associated with different operations you are running. For instance, the \"KEYS\" command is an O(n) operation and should be avoided. The redis.io site has details around the time complexity for each operation that it supports.\n• Consider turning on \"Server GC\". \"Workstation GC\" is the default and can impact the latencies when garbage collection is in happening.\n• Most customers find that a single ConnectionMultiplexer is sufficient for their needs. However, if you have high throughput requirements, you may consider slowly increasing the number of connections to see if you get an improvement in throughput. Avoid setting it to an arbitrarily large number of connections as it may not give the desired benefit.\n• Configure supported TLS settings. If you are targeting .NET 4.7 or later, you should not have to do anything because StackExchange.Redis will automatically use the OS level settings when deciding which TLS versions to support (which is a good thing in most cases). If you are targeting an older version of .NET, then you should configure the client to use the highest TLS version that your client system supports (typically TLS 1.2). Once you move to a newer version of the .NET framework, then you should probably remove this configuration and let the OS settings take precedence. This can configured through the sslProtocols connection string entry (requires NuGet package version 1.2.3 or later), or through the ConfigurationOptions class as show here:\n\nWe have seen a few rare cases where StackExchange.Redis fails to reconnect after a connection blip (for example, due to patching). Restarting the client or creating a new ConnectionMultiplexer will fix the issue. Here is some sample code that still uses the recommended pattern while allowing apps to force a reconnection periodically. Make sure to update code calling into the ConnectionMultiplexer so that they handle any errors that occur as a result of disposing the old one."
    },
    {
        "link": "https://stackoverflow.com/questions/8636408/codeigniter-batch-insert-performance",
        "document": "From the documentation of code igniter do this kind of things\n\nSo it would produce only one query with all the values, normally this way faster then doing separate inserts."
    },
    {
        "link": "https://stackoverflow.com/questions/39950693/codeigniter-batch-update-performance",
        "document": "As in Codeigniter documentation generate a single query and establish only one connection. So it would be faster than query within loop.\n\nAfter profiling I can see following results (only taken to update 4 rows)\n\non other hand I have updated same no. of rows with loop and it takes much time ( which is almost 1 sec)"
    },
    {
        "link": "https://forum.codeigniter.com/thread-70975.html",
        "document": "ci_posts:\n\n id, title, description.\n\n \n\n ci_terms:\n\n term_id,title,slug\n\n \n\n ci_terms_relationship:\n\n id, post_id, term_id\n\n \n\n I have a function in which I can easily add terms to any post, the problem comes when I'm trying to update one of the post. Lets say I created a post with ONE term and I publish it, now I want to update it and put more(more than ONE) than the main term into it. \n\n \n\n \n\n The var $id comes from the id of the ci_posts table. As I said before, it currently updates the relationship with ONE term(as said above; from the add function which is not listed here).\n\n \n\n And if I create a new post with at least 5 terms(different term_id) when updating it, it changes the term_id(all of them) to the first term_id of the selected terms.\n\n \n\n Thanks in advance. I do Front-End development most of the time So I currently have three tables.ci_posts:id, title, description.ci_terms:term_id,title,slugci_terms_relationship:id, post_id, term_idI have a function in which I can easily add terms to any post, the problem comes when I'm trying to update one of the post. Lets say I created a post with ONE term and I publish it, now I want to update it and put more(more than ONE) than the main term into it.The var $id comes from the id of the ci_posts table. As I said before, it currently updates the relationship with ONE term(as said above; from the add function which is not listed here).And if I create a new post with at least 5 terms(different term_id) when updating it, it changes the term_id(all of them) to the first term_id of the selected terms.Thanks in advance. \n\n \n\n \n\n If this does not work for you you can implement your own batch update function. \n\n Tutorial is here: \n\n \n\n It would be better if you copy update_batch function from system folder and then change it (don't forgot to rename it) for your needs You have ID column in your ci_terms_relationship table. Use that id.If this does not work for you you can implement your own batch update function.Tutorial is here: https://github.com/bcit-ci/CodeIgniter/w...se-Drivers It would be better if you copy update_batch function from system folder and then change it (don't forgot to rename it) for your needs \n\n It's because you are using post_id as row identifier, but that's not unique per record. You need to use ci_terms_relationship.id if you want to use update_batch.\n\n \n\n Didn't even know update_batch was a thing. Had a quick look at CI documentation, and at first glance it seems ok for couple of records, but the size of the SQL query could potentially spiral out of control very quick with number of records or number of fields to update.\n\n \n\n And you might not even need it, if you only need to keep simple groups of term IDs for each post ID, and nothing more.\n\n \n\n In that case, I'd usually compare two arrays, one for existing terms and one for new updated terms, and generate two new arrays:\n\n - if ID is present in existing and updated terms, I ignore it\n\n - if ID is present in existing but not in updated terms, I add it to delete array\n\n - if ID is not present in existing but is in updated terms, I add it to insert array\n\n \n\n Then, if anything is in delete array, I delete it using where_in('id', $delete) method, and if anything is in insert array, I populate necessary additional column data (add post_id, category) and use insert_batch. \n\n It's because you are using post_id as row identifier, but that's not unique per record. You need to use ci_terms_relationship.id if you want to use update_batch.\n\n \n\n Didn't even know update_batch was a thing. Had a quick look at CI documentation, and at first glance it seems ok for couple of records, but the size of the SQL query could potentially spiral out of control very quick with number of records or number of fields to update.\n\n \n\n And you might not even need it, if you only need to keep simple groups of term IDs for each post ID, and nothing more.\n\n \n\n In that case, I'd usually compare two arrays, one for existing terms and one for new updated terms, and generate two new arrays:\n\n - if ID is present in existing and updated terms, I ignore it\n\n - if ID is present in existing but not in updated terms, I add it to delete array\n\n - if ID is not present in existing but is in updated terms, I add it to insert array\n\n \n\n Then, if anything is in delete array, I delete it using where_in('id', $delete) method, and if anything is in insert array, I populate necessary additional column data (add post_id, category) and use insert_batch. \n\n That's what I'm trying to do but I just don't find any way of accomplishing it and I have never done something like this before so that's why I'm having troubles. I just created this but it did not work, you can check it if you think you can make it work or something:\n\n \n\n Updated controller function(notice that I have to create two foreach with different vars \"$data[]\" and \"$data2[]\"):\n\n // I really have not idea how can I create the title knowing that the input comes from the ci_terms table(terms already created)\n\n // If they do not exist, create them\n\n // If relationship does not exist between post_id and term_id, create it\n\n // If relationship already exist between post_id and term_id, update them(in case we take them(terms) out or create more)\n\n \n\n and here is the model function to check if they already exists whether on ci_terms or ci_relationships:\n\n \n\n // If relationship does not exist, create it\n\n \n\n NOTE: \"$this->table\" refers to the ci_terms table I do Front-End development most of the time That's what I'm trying to do but I just don't find any way of accomplishing it and I have never done something like this before so that's why I'm having troubles. I just created this but it did not work, you can check it if you think you can make it work or something:Updated controller function(notice that I have to create two foreach with different vars \"$data[]\" and \"$data2[]\"):and here is the model function to check if they already exists whether on ci_terms or ci_relationships:NOTE: \"$this->table\" refers to the ci_terms table \n\n \n\n // you get this by SELECT term_id FROM ci_terms_relationship WHERE post_id = $postID\n\n // filter out all term IDs that exist in DB but are not selected for update\n\n // filter out all terms not yet stored in DB, but are selected for update\n\n There are multiple ways to do this, here's one way: \n\n \n\n to make every record unique. This is one reason why you always have a plain ID auto increment column in your tablesto make every record unique. \n\n This is one reason why you always have a plain ID auto increment column in your tables to make every record unique. \n\n I'm not entirely sure you to, but that's just my gut feel and not based on any scientific evidence.\n\n \n\n Post ID and Term ID already give that unique-ness per row, so not having to deal with that intermediate ID seems to make set up simpler, however I'm open to suggestions where there's clear benefit to db performance or race conditions \n\n \n\n Did a quick search on Google but couldn't see anything obvious. I'm not entirely sure youto, but that's just my gut feel and not based on any scientific evidence.Post ID and Term ID already give that unique-ness per row, so not having to deal with that intermediate ID seems to make set up simpler, however I'm open to suggestions where there's clear benefit to db performance or race conditionsDid a quick search on Google but couldn't see anything obvious. \n\n Didn't even know update_batch was a thing. Had a quick look at CI documentation, and at first glance it seems ok for couple of records, but the size of the SQL query could potentially spiral out of control very quick with number of records or number of fields to update. \n\n \n\n update_batch has $batch_size parameter,default is 100, if there are more the than 100 records it breaks them for clusters with 100 rows. so I think the number of rows will not affect it.\n\n (My English is not good, so I might misunterstood your point) update_batch has $batch_size parameter,default is 100, if there are more the than 100 records it breaks them for clusters with 100 rows. so I think the number of rows will not affect it.(My English is not good, so I might misunterstood your point) \n\n update_batch has $batch_size parameter,default is 100, if there are more the than 100 records it breaks them for clusters with 100 rows. so I think the number of rows will not affect it.\n\n (My English is not good, so I might misunterstood your point) \n\n Ah excellent, yeah that was exactly my point, so there's absolutely nothing wrong with your English Ah excellent, yeah that was exactly my point, so there's absolutely nothing wrong with your English"
    },
    {
        "link": "https://codeigniter.com/userguide3/database/query_builder.html?highlight=update_batch",
        "document": "CodeIgniter gives you access to a Query Builder class. This pattern allows information to be retrieved, inserted, and updated in your database with minimal scripting. In some cases only one or two lines of code are necessary to perform a database action. CodeIgniter does not require that each database table be its own class file. It instead provides a more simplified interface.\n\nBeyond simplicity, a major benefit to using the Query Builder features is that it allows you to create database independent applications, since the query syntax is generated by each database adapter. It also allows for safer queries, since the values are escaped automatically by the system.\n\nThe following functions allow you to build SQL SELECT statements. Runs the selection query and returns the result. Can be used by itself to retrieve all records from a table: The second and third parameters enable you to set a limit and offset clause: // (in MySQL. Other databases have slightly different syntax) You’ll notice that the above function is assigned to a variable named $query, which can be used to show the results: Please visit the result functions page for a full discussion regarding result generation. Compiles the selection query just like $this->db->get() but does not run the query. This method simply returns the SQL query as a string. The second parameter enables you to set whether or not the query builder query will be reset (by default it will be reset, just like when using ): // (in MySQL. Other databases have slightly different syntax) The key thing to notice in the above example is that the second query did not utilize $this->db->from() and did not pass a table name into the first parameter. The reason for this outcome is because the query has not been executed using $this->db->get() which resets values or reset directly using $this->db->reset_query(). Identical to the above function except that it permits you to add a “where” clause in the second parameter, instead of using the db->where() function: Please read the about the where function below for more information. get_where() was formerly known as getwhere(), which has been removed Permits you to write the SELECT portion of your query: If you are selecting all (*) from a table you do not need to use this function. When omitted, CodeIgniter assumes that you wish to select all fields and automatically adds ‘SELECT *’. accepts an optional second parameter. If you set it to FALSE, CodeIgniter will not try to protect your field or table names. This is useful if you need a compound select statement where automatic escaping of fields may break them. '(SELECT SUM(payments.amount) FROM payments WHERE payments.invoice_id=4) AS amount_paid' Writes a portion for your query. You can optionally include a second parameter to rename the resulting field. Writes a “SELECT MIN(field)” portion for your query. As with select_max(), You can optionally include a second parameter to rename the resulting field. Writes a “SELECT AVG(field)” portion for your query. As with select_max(), You can optionally include a second parameter to rename the resulting field. Writes a “SELECT SUM(field)” portion for your query. As with select_max(), You can optionally include a second parameter to rename the resulting field. Permits you to write the FROM portion of your query: As shown earlier, the FROM portion of your query can be specified in the $this->db->get() function, so use whichever method you prefer. Permits you to write the JOIN portion of your query: Multiple function calls can be made if you need several joins in one query. If you need a specific type of JOIN you can specify it via the third parameter of the function. Options are: left, right, outer, inner, left outer, right outer and full outer.\n\nThis function enables you to set WHERE clauses using one of four methods: All values passed to this function are escaped automatically, producing safer queries.\n• Notice that the equal sign is added for you. If you use multiple function calls they will be chained together with AND between them: // WHERE name = 'Joe' AND title = 'boss' AND status = 'active'\n• You can include an operator in the first parameter in order to control the comparison: // Produces: WHERE name != 'Joe' AND id < 45\n• // Produces: WHERE name = 'Joe' AND title = 'boss' AND status = 'active' You can include your own operators using this method as well:\n• None You can write your own clauses manually: accepts an optional third parameter. If you set it to FALSE, CodeIgniter will not try to protect your field or table names. This function is identical to the one above, except that multiple instances are joined by OR: // Produces: WHERE name != 'Joe' OR id > 50 or_where() was formerly known as orwhere(), which has been removed. Generates a WHERE field IN (‘item’, ‘item’) SQL query joined with AND if appropriate Generates a WHERE field IN (‘item’, ‘item’) SQL query joined with OR if appropriate Generates a WHERE field NOT IN (‘item’, ‘item’) SQL query joined with AND if appropriate // Produces: WHERE username NOT IN ('Frank', 'Todd', 'James') Generates a WHERE field NOT IN (‘item’, ‘item’) SQL query joined with OR if appropriate // Produces: OR username NOT IN ('Frank', 'Todd', 'James')\n\nThis method enables you to generate LIKE clauses, useful for doing searches. All values passed to this method are escaped automatically.\n• If you use multiple method calls they will be chained together with AND between them: // WHERE `title` LIKE '%match%' ESCAPE '!' AND `body` LIKE '%match% ESCAPE '!' If you want to control where the wildcard (%) is placed, you can use an optional third argument. Your options are ‘before’, ‘after’, ‘none’ and ‘both’ (which is the default).\n• // WHERE `title` LIKE '%match%' ESCAPE '!' AND `page1` LIKE '%match%' ESCAPE '!' AND `page2` LIKE '%match%' ESCAPE '!' This method is identical to the one above, except that multiple instances are joined by OR: // WHERE `title` LIKE '%match%' ESCAPE '!' OR `body` LIKE '%match%' ESCAPE '!' was formerly known as , which has been removed. This method is identical to , except that it generates NOT LIKE statements: // WHERE `title` NOT LIKE '%match% ESCAPE '!' This method is identical to , except that multiple instances are joined by OR: // WHERE `title` LIKE '%match% OR `body` NOT LIKE '%match%' ESCAPE '!' Permits you to write the GROUP BY portion of your query: You can also pass an array of multiple values as well: group_by() was formerly known as groupby(), which has been removed. Permits you to write the HAVING portion of your query. There are 2 possible syntaxes, 1 argument or 2: You can also pass an array of multiple values as well: If you are using a database that CodeIgniter escapes queries for, you can prevent escaping content by passing an optional third argument, and setting it to FALSE. // Produces: HAVING `user_id` = 45 in some databases such as MySQL Identical to having(), only separates multiple clauses with “OR”.\n\nGenerates an insert string based on the data you supply, and runs the query. You can either pass an array or an object to the function. Here is an example using an array: // Produces: INSERT INTO mytable (title, name, date) VALUES ('My title', 'My name', 'My date') The first parameter will contain the table name, the second is an associative array of values. Here is an example using an object: // Produces: INSERT INTO mytable (title, content, date) VALUES ('My Title', 'My Content', 'My Date') The first parameter will contain the table name, the second is an object. Compiles the insertion query just like $this->db->insert() but does not run the query. This method simply returns the SQL query as a string. // Produces string: INSERT INTO mytable (`title`, `name`, `date`) VALUES ('My title', 'My name', 'My date') The second parameter enables you to set whether or not the query builder query will be reset (by default it will be–just like $this->db->insert()): // Produces string: INSERT INTO mytable (`title`, `content`) VALUES ('My Title', 'My Content') The key thing to notice in the above example is that the second query did not utilize nor did it pass a table name into the first parameter. The reason this worked is because the query has not been executed using which resets values or reset directly using . Generates an insert string based on the data you supply, and runs the query. You can either pass an array or an object to the function. Here is an example using an array: // Produces: INSERT INTO mytable (title, name, date) VALUES ('My title', 'My name', 'My date'), ('Another title', 'Another name', 'Another date') The first parameter will contain the table name, the second is an associative array of values.\n\nThis method executes a REPLACE statement, which is basically the SQL standard for (optional) DELETE + INSERT, using PRIMARY and UNIQUE keys as the determining factor. In our case, it will save you from the need to implement complex logics with different combinations of , , and calls. // Executes: REPLACE INTO mytable (title, name, date) VALUES ('My title', 'My name', 'My date') In the above example, if we assume that the title field is our primary key, then if a row containing ‘My title’ as the title value, that row will be deleted with our new row data replacing it. Usage of the method is also allowed and all fields are automatically escaped, just like with . This function enables you to set values for inserts or updates. It can be used instead of passing a data array directly to the insert or update functions: // Produces: INSERT INTO mytable (`name`) VALUES ('{$name}') If you use multiple function called they will be assembled properly based on whether you are doing an insert or an update: set() will also accept an optional third parameter ( ), that will prevent data from being escaped if set to FALSE. To illustrate the difference, here is used both with and without the escape parameter. You can also pass an associative array to this function: Generates an update string and runs the query based on the data you supply. You can pass an array or an object to the function. Here is an example using an array: Or you can supply an object: You’ll notice the use of the $this->db->where() function, enabling you to set the WHERE clause. You can optionally pass this information directly into the update function as a string: You may also use the $this->db->set() function described above when performing updates. Generates an update string based on the data you supply, and runs the query. You can either pass an array or an object to the function. Here is an example using an array: // WHEN `title` = 'My title' THEN 'My Name 2' // WHEN `title` = 'Another title' THEN 'Another Name 2' // WHEN `title` = 'My title' THEN 'My date 2' // WHEN `title` = 'Another title' THEN 'Another date 2' // WHERE `title` IN ('My title','Another title') The first parameter will contain the table name, the second is an associative array of values, the third parameter is the where key. won’t give you proper results with this method, due to the very nature of how it works. Instead, returns the number of rows affected. This works exactly the same way as except that it produces an UPDATE SQL string instead of an INSERT SQL string. For more information view documentation for .\n\nResets the current Query Builder state. Useful when you want to build a query that can be cancelled under certain conditions.\n• $prefix (string) – The new prefix to use Sets the database prefix, without having to reconnect.\n• $table (string) – The table name to prefix Prepends a database prefix, if one exists in configuration.\n• $reset (bool) – Whether to reset values for SELECTs Number of rows in the query result Generates a platform-specific query string that counts all records returned by an Query Builder query. Compiles and runs SELECT statement based on the already called Query Builder methods.\n• $table (mixed) – The table(s) to fetch data from; string or array\n• $where (string) – The WHERE clause Same as , but also allows the WHERE to be added directly.\n• $escape (bool) – Whether to escape values and identifiers\n• $select (string) – Field to compute the average of\n• $alias (string) – Alias for the resulting value name\n• $select (string) – Field to compute the maximum of\n• $alias (string) – Alias for the resulting value name\n• $select (string) – Field to compute the minimum of\n• $alias (string) – Alias for the resulting value name\n• $select (string) – Field to compute the sum of\n• $alias (string) – Alias for the resulting value name\n• $val (bool) – Desired value of the “distinct” flag Sets a flag which tells the query builder to add a DISTINCT clause to the SELECT portion of the query. Specifies the FROM clause of a query.\n• $escape (bool) – Whether to escape values and identifiers\n• $key (mixed) – Name of field to compare, or associative array\n• $value (mixed) – If a single key, compared to this value\n• $escape (bool) – Whether to escape values and identifiers Generates the WHERE portion of the query. Separates multiple calls with ‘AND’.\n• $key (mixed) – Name of field to compare, or associative array\n• $value (mixed) – If a single key, compared to this value\n• $escape (bool) – Whether to escape values and identifiers Generates the WHERE portion of the query. Separates multiple calls with ‘OR’.\n• $escape (bool) – Whether to escape values and identifiers Generates a WHERE field IN(‘item’, ‘item’) SQL query, joined with ‘OR’ if appropriate.\n• $escape (bool) – Whether to escape values and identifiers Generates a WHERE field NOT IN(‘item’, ‘item’) SQL query, joined with ‘OR’ if appropriate.\n• $key (string) – Name of field to examine\n• $escape (bool) – Whether to escape values and identifiers Generates a WHERE field IN(‘item’, ‘item’) SQL query, joined with ‘AND’ if appropriate.\n• $key (string) – Name of field to examine\n• $escape (bool) – Whether to escape values and identifiers Generates a WHERE field NOT IN(‘item’, ‘item’) SQL query, joined with ‘AND’ if appropriate. Starts a group expression, using ANDs for the conditions inside it. Starts a group expression, using ORs for the conditions inside it. Starts a group expression, using AND NOTs for the conditions inside it. Starts a group expression, using OR NOTs for the conditions inside it.\n• $side (string) – Which side of the expression to put the ‘%’ wildcard on\n• $escape (bool) – Whether to escape values and identifiers Adds a LIKE clause to a query, separating multiple calls with AND.\n• $side (string) – Which side of the expression to put the ‘%’ wildcard on\n• $escape (bool) – Whether to escape values and identifiers Adds a LIKE clause to a query, separating multiple class with OR.\n• $side (string) – Which side of the expression to put the ‘%’ wildcard on\n• $escape (bool) – Whether to escape values and identifiers Adds a NOT LIKE clause to a query, separating multiple calls with AND.\n• $side (string) – Which side of the expression to put the ‘%’ wildcard on\n• $escape (bool) – Whether to escape values and identifiers Adds a NOT LIKE clause to a query, separating multiple calls with OR.\n• $value (string) – Value sought if $key is an identifier\n• $escape (string) – Whether to escape values and identifiers Adds a HAVING clause to a query, separating multiple calls with AND.\n• $value (string) – Value sought if $key is an identifier\n• $escape (string) – Whether to escape values and identifiers Adds a HAVING clause to a query, separating multiple calls with OR.\n• $by (mixed) – Field(s) to group by; string or array\n• $escape (bool) – Whether to escape values and identifiers Adds an ORDER BY clause to a query.\n• $value (int) – Number of rows to limit the results to\n• $key (mixed) – Field name, or an array of field/value pairs\n• $value (string) – Field value, if $key is a single field\n• $escape (bool) – Whether to escape values and identifiers Adds field/value pairs to be passed later to , or .\n• $escape (bool) – Whether to escape values and identifiers\n• $escape (bool) – Whether to escape values and identifiers\n• $batch_size (int) – Count of rows to insert at once Number of rows inserted or FALSE on failure When more than rows are provided, multiple queries will be executed, each trying to insert up to rows.\n• $key (mixed) – Field name or an array of field/value pairs\n• $value (string) – Field value, if $key is a single field\n• $escape (bool) – Whether to escape values and identifiers Adds field/value pairs to be inserted in a table later via .\n• $where (string) – The WHERE clause\n• $set (array) – Field name, or an associative array of field/value pairs\n• $value (string) – Field value, if $set is a single field\n• $batch_size (int) – Count of conditions to group in a single query Number of rows updated or FALSE on failure When more than field/value pairs are provided, multiple queries will be executed, each handling up to field/value pairs.\n• $key (mixed) – Field name or an array of field/value pairs\n• $value (string) – Field value, if $key is a single field\n• $escape (bool) – Whether to escape values and identifiers Adds field/value pairs to be updated in a table later via .\n• $table (mixed) – The table(s) to delete from; string or array\n• $where (string) – The WHERE clause If the database platform in use doesn’t support TRUNCATE, a DELETE statement will be used instead. Deletes all records from a table via a DELETE statement.\n• $reset (bool) – Whether to reset the current QB values or not Compiles a SELECT statement and returns it as a string.\n• $reset (bool) – Whether to reset the current QB values or not Compiles an INSERT statement and returns it as a string.\n• $reset (bool) – Whether to reset the current QB values or not Compiles an UPDATE statement and returns it as a string.\n• $reset (bool) – Whether to reset the current QB values or not Compiles a DELETE statement and returns it as a string."
    },
    {
        "link": "https://forum.codeigniter.com/thread-41338.html",
        "document": "Hello guys,\n\n \n\n I need to update a batch of data, I preformat an array wich is outputted like that when passed to var_export():\n\n \n\n Then I pass it to $this->db->update_batch() but it always raises a codeigniter database error. My array looks good right? I do a insert_batch with a similar array and it works fine.\n\n \n\n My table, simplified, looks like : 'id', 'exercice_id', 'ordre', 'nb_series'.\n\n \n\n Thanks you! \n\n \n\n JoeDRL [eluser]JoeDRL[/eluser]Hello guys,I need to update a batch of data, I preformat an array wich is outputted like that when passed to var_export():Then I pass it to $this->db->update_batch() but it always raises a codeigniter database error. My array looks good right? I do a insert_batch with a similar array and it works fine.My table, simplified, looks like : 'id', 'exercice_id', 'ordre', 'nb_series'.Thanks you!JoeDRL \n\n [eluser]JoeDRL[/eluser]\n\n Knowing that I only need to update about 15 rows at the time, and that in some cases I will need to insert or delete data instead of updating it, would looping on an update/insert function would bring huge performance problems?\n\n \n\n It would solve the problem, and I don't know how I can do it differently to insert or delete with a \"batch\" function. The only thing is the performance issue that I'm not so sure about.\n\n \n\n Thank you! \n\n [eluser]Nick_MyShuitings[/eluser]\n\n and it didn't occur to you to include the db error for us to troubleshoot off of? \n\n [eluser]JoeDRL[/eluser]\n\n Actually there was no error.\n\n The message only said, in french, \"Il y a eu une erreur avec la base de données.\" which can be translated to \"A database error as occured\". Then it says it's on the update_batch() function, no error message from MySQL in my case like habitually. \n\n [eluser]Nick_MyShuitings[/eluser]\n\n Hmm... well, in reality, the update batch is just going to loop through them and update them.. so you're not getting a performance gain in any way. If that works better for you logically to allow you to insert/delete/update based on XYZ logic, then go for it. \n\n [eluser]JoeDRL[/eluser]\n\n Isn't update_batch() doing a request looking like \"INSERT... VALUES (x1, y1, z1), (x2, y2, z2), (x3, y3, z3)\"\n\n which is faster than looping on single INSERT?\n\n \n\n Anyway as i said I only process like 10 rows at a time so it's not that important.\n\n \n\n Thank you Nick \n\n \n\n Check out this link: \n\n \n\n But now you've piqued my curiosity about how CI rigs up the udpate batch... I'll prolly do some tests later... but unless they've discovered some dark magic, I think you'd have a hard time using update_batch when you have different where clauses. \n\n \n\n insert_batch would work how you sent in your example... but update... not sure. [eluser]Nick_MyShuitings[/eluser]Check out this link: http://www.frihost.com/forums/vt-68316.html But now you've piqued my curiosity about how CI rigs up the udpate batch... I'll prolly do some tests later... but unless they've discovered some dark magic, I think you'd have a hard time using update_batch when you have different where clauses.insert_batch would work how you sent in your example... but update... not sure. \n\n \n\n Yeah thanks for the link but they didn't find a solution \n\n So the update_batch() is meant to update the same fields of a same table with the same values and only the id is different?\n\n Yeah insert_batch worked like a charm.\n\n \n\n Will do more research..\n\n \n\n Thanks again man [eluser]JoeDRL[/eluser]Yeah thanks for the link but they didn't find a solutionSo the update_batch() is meant to update the same fields of a same table with the same values and only the id is different?Yeah insert_batch worked like a charm.Will do more research..Thanks again man \n\n \n\n Instead of wondering, you could \n\n \n\n https://bitbucket.org/ellislab/codeignit...infomation\n\n \n\n \n\n \n\n Generates an update string based on the data you supply, and runs the query. You can either pass an\n\n or an to the function. Here is an example using an array:\n\n \n\n $data = array(\n\n array( \n\n 'title' => 'My title' , \n\n 'name' => 'My Name 2' , \n\n 'date' => 'My date 2' \n\n ), \n\n array( \n\n 'title' => 'Another title' , \n\n 'name' => 'Another Name 2' , \n\n 'date' => 'Another date 2' \n\n )\n\n ); \n\n \n\n $this->db->update_batch('mytable', $data, 'title');\n\n \n\n // Produces: \n\n // UPDATE `mytable` SET `name` = CASE \n\n // WHEN `title` = 'My title' THEN 'My Name 2' \n\n // WHEN `title` = 'Another title' THEN 'Another Name 2' \n\n // ELSE `name` END, \n\n // `date` = CASE \n\n // WHEN `title` = 'My title' THEN 'My date 2' \n\n // WHEN `title` = 'Another title' THEN 'Another date 2' \n\n // ELSE `date` END \n\n // WHERE `title` IN ('My title','Another title') \n\n The first parameter will contain the table name, the second is an associative array of values, the third parameter is the where key. [eluser]danmontgomery[/eluser]Instead of wondering, you could look at the source to see what it's doing, and see that is does, in fact, form a case statement in support of separate where clauses for each update. \n\n \n\n That is the exact kind of dark wizardry that I was looking to find... (I just fired up my dev box to check the source but all hail to noctrum for getting it first)\n\n \n\n I hope they update the online user guide soon as it has the insert_batch documentation duplicated with the name update_batch... \n\n \n\n I hang my head in shame for not taking my own advice and just opening the source on the spot. [eluser]Nick_MyShuitings[/eluser]That is the exact kind of dark wizardry that I was looking to find... (I just fired up my dev box to check the source but all hail to noctrum for getting it first)I hope they update the online user guide soon as it has the insert_batch documentation duplicated with the name update_batch... http://ellislab.com/codeigniter/user-gui...tml#update I hang my head in shame for not taking my own advice and just opening the source on the spot."
    }
]