[
    {
        "link": "https://stackoverflow.com/questions/16295677/how-can-i-simulate-a-button-click-given-the-handle-to-the-buttons-window",
        "document": "I want to simulate a click on a button located in a dialog box.\n\nI have the handle to that window. This is an Abort/Retry/Ignore kind of window.\n\nI don't want to go with simulating a click having X and Y coordinates as it doesn't suit my needs."
    },
    {
        "link": "https://stackoverflow.com/questions/28386029/how-to-simulate-mouse-click-using-c",
        "document": "Closed. This question needs . This question needs details or clarity . It is not currently accepting answers. Want to improve this question? Add details and clarify the problem by editing this post. This post was edited and submitted for review 3 years ago and failed to reopen the post:\n\nI need to simulate a mouse click that clicks on application windows. I'm using Windows.\n\nHow can I send a left button mouse click to screen coordinates where the window is located?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/controls/button-messages",
        "document": "A button can send messages to its parent window, and a parent window can send messages to a button.\n\nThe following topics are discussed in this section.\n\nA parent window can send messages to a button in an overlapped or child window by using the SendMessage function, or it can send messages to a button in a dialog box by using the SendDlgItemMessage, CheckDlgButton, CheckRadioButton, and IsDlgButtonChecked functions.\n\nAn application can use the BM_GETCHECK message to retrieve the check state of a check box or radio button. An application can also use the BM_GETSTATE message to retrieve the button's current states (the check state, push state, and focus state). To get information about a specific state, use a bitmask on the returned state value.\n\nThe BM_SETCHECK message sets the check state of a check box or radio button; the message returns zero. The BM_SETSTATE message sets the push state of a button; this message also returns zero. The BM_SETSTYLE message changes the style of a button. It is designed for changing button styles within a type (for example, changing a check box to an automatic check box). It is not designed for changing between types (for example, changing a check box to a radio button). An application should not change a button from one type to another.\n\nA button of the BS_BITMAP or BS_ICON style displays a bitmap or icon instead of text. The BM_SETIMAGE message associates a handle to a bitmap or icon with a button. The BM_GETIMAGE message retrieves a handle to the bitmap or icon associated with a button.\n\nAn application can also use the DM_GETDEFID message to retrieve the identifier of the default push button control in a dialog box. An application can use the DM_SETDEFID message to set the default push button for a dialog box.\n\nCalling the CheckDlgButton or CheckRadioButton function is equivalent to sending a BM_SETCHECK message. Calling the IsDlgButtonChecked function is equivalent to sending a BM_GETCHECK message.\n\nNotifications from a button are sent as either WM_COMMAND or WM_NOTIFY messages. Information about which message is used can be found on the reference page for each notification.\n\nFor more information on how to handle messages, see Control Messages. See also Button Messages.\n\nWhen the user clicks a button, its state changes, and the button sends notification codes, in the form of WM_COMMAND messages, to its parent window. For example, a push button control sends the BN_CLICKED notification code whenever the user chooses the button. In all cases (except for BCN_HOTITEMCHANGE), the low-order word of the wParam parameter contains the control identifier, the high-order word of wParam contains the notification code, and the lParam parameter contains the control window handle.\n\nBoth the message and the parent window's response depend on the type, style, and current state of the button. Following are the button notification codes an application should monitor and process.\n\nA button sends the BN_DISABLE, BN_PUSHED, BN_KILLFOCUS, BN_PAINT, BN_SETFOCUS, and BN_UNPUSHED notification codes only if it has the BS_NOTIFY style. BN_DBLCLK notification codes are sent automatically for BS_USERBUTTON, BS_RADIOBUTTON, and BS_OWNERDRAW buttons. Other button types send BN_DBLCLK only if they have the BS_NOTIFY style. All buttons send the BN_CLICKED notification code regardless of their button styles.\n\nFor automatic buttons, the system changes the push state and paints the button. In this case, the application typically processes only the BN_CLICKED and BN_DBLCLK notification codes. For buttons that are not automatic, the application typically responds to the notification code by sending a message to change the state of the button. For information about sending messages to buttons, see Sending Messages to Buttons.\n\nWhen the user selects an owner-drawn button, the button sends its parent window a WM_DRAWITEM message containing the identifier of the control to be drawn and information about its dimensions and state.\n\nThe system provides default color values for buttons. An application can retrieve the default values for these colors by calling the GetSysColor function, or set the values by calling the SetSysColors function. The following table shows the default button-color values.\n\nHowever, calling SetSysColors affects all applications, so you should not call this function to customize buttons for your application.\n\nThe system sends a WM_CTLCOLORBTN message to a button's parent window before drawing a button. This message contains a handle to the button's device context and a handle to the child window. The parent window can use these handles to change the button's text and background colors. However, only owner-drawn buttons respond to the parent window processing the message.\n\nThe window procedure for the predefined button control window class carries out default processing for all messages that the button control procedure does not process. When the button control procedure returns FALSE for any message, the predefined window procedure checks the messages and performs the default actions listed in the following table.\n\nThe predefined window procedure passes all other messages to the DefWindowProc function for default processing."
    },
    {
        "link": "https://forums.codeguru.com/showthread.php?223396-Simulate-button-click-in-another-app",
        "document": "\n• I need to write a program that simulates a button click in another application. I have written an application already that sends keystrokes to this application, and therefore already know things like how to start at the desktop and search to find the window I want to send the keystrokes to, and to send to that window WM_KEY messages.\n\n \n\n However, now, in a similar vein, there is an app that is written in Visual Basic and I need to \"press a button\" in that app (programmatically), and that button doesn't have a keyboard shortcut.\n\n \n\n Any insights on how to do this?\n\n \n\n Thanks in advance,\n\n Allen\n• OOPs I put this on the wrong post....\n\n \n\n Sorry.\n• Originally posted by anw \n\n ...\n\n I need to \"press a button\" in that app (programmatically), and that button doesn't have a keyboard shortcut. ...I need to \"press a button\" in that app (programmatically), and that button doesn't have a keyboard shortcut. Pressing button (either toolbar button or dialog button) sends command message with buttonâs ID.\n\n \n\n Therefore sending WM_COMMAND message with proper parameters (see MSDN) should resolve your problem providing you have already pointer or handle to that window. There are only 10 types of people in the world: \n\n Those who understand binary and those who do not.\n• So, it's a WM_COMMAND message, as opposed to a WM_LBUTTONDOWN/ WM_LBUTTONUP combination? And, this works with Visual Basic- built buttons? I think I can get the window ID of the button based on the caption that it displays (which I think is just its window text).\n\n \n\n I'll go check out the MSDN documentation as well.\n\n \n\n Thanks,\n\n Allen\n• Upon checking the MSDN docs, I see how to do most of the stuff: I can get the window handle (lparam) from searching through the windows, WM_COMMAND is the message, and I need to get the parent window as the window to send this message to (again, from searching through the windows).\n\n \n\n The only thing that isn't obvious is how to get the wparam values: the notification code (would this be WM_LBUTTONDOWN/ WM_LBUTTONUP?) and button ID (which presumably is the ID_XXXX identifier for the button).\n\n \n\n Any further thoughts would be appreciated.\n\n \n\n Thanks,\n\n Allen\n• hwndButton = FindWindowEx(hwndParent, NULL, \"Button\", NULL);\n\n SendMessage(hwndParent, WM_COMMAND, 1, (LPARAM)hwndChild);\n\n \n\n is how i've previously done it but i've noticed it wont work in all instances with all other apps.\n\n \n\n \n\n you can do it with your button up and button down idea though too......just find the HWND of the button and.....\n\n \n\n SendMessage(hwndButton, WM_LBUTTONDOWN, MK_LBUTTON, 0);\n\n SendMessage(hwndButton, WM_LBUTTONUP, 0, 0); Last edited by filthy_mcnasty; December 19th, 2002 at .\n• I haven't used FindWindowEx- it may be easier. I just get the desktop window, then traverse through the top- level windows until I hit the one with the correct window text (which presumably is the frame window), then traverse its children until I hit the a window whose window text is the caption of the button I'm looking for. The code looks like this:\n\n \n\n HWND CPopCltDlg::GetPopWin(const char *title) { char tmpbuf[64]; int buflen; int titlen= strlen(title); // ButtonTitle is const char * declared globally int buttitlen= strlen(ButtonTitle); HWND h= ::GetDesktopWindow(); h= ::GetTopWindow(h); while(h) { buflen= ::GetWindowText(h, tmpbuf, 64); if (!strncmp(title, tmpbuf, titlen)) break; h= ::GetNextWindow(h, GW_HWNDNEXT); } //////////////////////////////////////////////////////////// // This is for MFC windows (with a child inside a CFrameWnd) // This gets the window that is on top of the frame window (e. g. a dialog) h= ::GetTopWindow(h); // WINDOWINFO winfo; // ::GetWindowInfo(h, &winfo); // End MFC specific //////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////// // And this is to get a child control h= ::GetWindow(h, GW_CHILD); while(h) { buflen= ::GetWindowText(h, tmpbuf, 64); if(!strncmp(ButtonTitle, tmpbuf, buttitlen) break; h= ::GetWindow(h, GW_HWNDNEXT); } // End button code //////////////////////////////////////////////////////////// return h; } Note that the part commented with \"And this to get the child control\" hasn't been tested yet. The rest has.\n\n \n\n So, according to MSDN, once I have the HWND for the button, I ought to be able to send it BM_CLICK messages:\n\n \n\n According to MSDN, under BM_CLICK, I don't need to worry about WM_COMMAND and notification codes and all that. Has anyone ever used this?\n\n \n\n Does this make sense to everyone? I'll be testing it over the next day or two.\n\n \n\n Thanks for all the help,\n\n Allen\n• if you know the exact titles and whatnot and they aren't changing then yeah use FindWindow or FindWindowEx as they will save your app lots of processing time *well, not noticable amounts but it will make your life coding a lot easier*\n\n and yes, you are right about BM_CLICK, it will work just as you need\n• Thanks to all. If I don't post anymore over the next couple of days, it means everything worked.\n\n \n\n Thanks,\n\n Allen\n• Originally posted by filthy_mcnasty \n\n and yes, you are right about BM_CLICK, it will work just as you need and yes, you are right about BM_CLICK, it will work just as you need Unfortunately he is not. There is no such a thing like BM_CLICKED message.\n\n \n\n BN_CLICKED is used as button notification code used in conjunction with buttonâs ID in WM_COMMAND message wParam parameter.\n\n \n\n Proper way to do it:\n\n \n\n ::SendMessage(hFoundWindow, WM_COMMAND, MAKEWPARAM(ButtonID, BN_CLICKED), (LPARAM)hButton);\n\n \n\n In most cases that will translate to:\n\n \n\n ::SendMessage(hFoundWindow, WM_COMMAND, ButtonID, NULL);\n\n \n\n I would not recommend above \"shortcut\". Last edited by JohnCz; December 20th, 2002 at . There are only 10 types of people in the world: \n\n Those who understand binary and those who do not.\n• I could do it either way, but thproblem is that I don't have the button ID. Why does the MSDN documentation talk about BM_CLICK (not B_N__CLICK, but B_M__CLICK)? What is it used for?\n\n \n\n I'll be playing around with all these techniques today, and repost later.\n\n \n\n Thanks,\n\n Allen\n• john, there IS a BM_CLICK message. it DOES work. i have used it.\n\n not CLICKED, but CLICK\n\n \n\n BN_CLICKED is the message sent when you actually do click it, BM_CLICK simulates this through falsifying WM_LBUTTONDOWN and WM_LBUTTONUP messages. it's there i promise.\n\n \n\n as for the ButtonID part, his message comes from another program so he'd actually have to find that too, it's not just nice and given to him, take the hwnd and use bm_click is the easiest way.\n\n \n\n \n\n BM_CLICK \n\n An application sends a BM_CLICK message to simulate the user clicking a button. This message causes the button to receive a WM_LBUTTONDOWN and a WM_LBUTTONUP message, and the buttonâs parent window to receive a BN_CLICKED notification message. \n\n \n\n BM_CLICK \n\n wParam = 0; // not used; must be zero \n\n lParam = 0; // not used; must be zero \n\n \n\n Parameters\n\n This message has no parameters. \n\n \n\n Return Values\n\n This message does not return a value.\n• Originally posted by filthy_mcnasty \n\n john, there IS a BM_CLICK message. it DOES work. i have used it.\n\n not CLICKED, but CLICK john, there IS a BM_CLICK message. it DOES work. i have used it.not CLICKED, but CLICK You are right that was me overlooking spelling. Sorry it was late night (or early morning for me. \n\n \n\n As a result WM_COMMAND is send to a parent window anyway. There are only 10 types of people in the world: \n\n Those who understand binary and those who do not.\n• OK, finding the windows seems to work. I am using the system accessory \"Calculator\" to test finding the windows because it has so many buttons, and, at least by appearances, seems to be a dialog- based application. The only thing is, a bunch of the child windows, which I assume must be the controls in the dialog, have NULL window text. Not all- it finds \"Deg\", \"Rad\", \"Grad\", a few others, but the bulk of them are NULL. Where are the window captions, like for example the numerals and the button labeled \"Backspace\" (which don't show up and are presumably among the windows with NULL window text), coming from?\n\n \n\n Thanks,\n\n Allen\n• I do not know how you are going about finding windows. Not all windows have text.\n\n \n\n I would find window using EnumWindows and once a culprit is found I would use EnumChildWindows and check windowâs class to see if this is a button. There are only 10 types of people in the world: \n\n Those who understand binary and those who do not.\n• You may not post new threads\n• You may not post replies\n• You may not post attachments\n• You may not edit your posts\n\n\n\n\n\n\n\n \n\n \n\n Click Here to Expand Forum to Full Width \n\n \n\n * The Best Reasons to Target Windows 8\n\n Learn some of the best reasons why you should seriously consider bringing your Android mobile development expertise to bear on the Windows 8 platform.\n• * Porting from Android to Windows 8: The Real Story\n\n Do you have an Android application? How hard would it really be to port to Windows 8?\n• * Guide to Porting Android Applications to Windows 8\n\n If you've already built for Android, learn what do you really need to know to port your application to Windows Phone 8.\n• * HTML5 Development Center\n\n Our portal for articles, videos, and news on HTML5, CSS3, and JavaScript\n• * Windows App Gallery\n\n See the Windows 8.x apps we've spotlighted or submit your own app to the gallery!"
    },
    {
        "link": "https://reddit.com/r/C_Programming/comments/ld5r3d/windows_api_to_simulate_user_input",
        "document": "I was trying to automate some parts in several video games using C by simulating the mouse movement and clicking. First I tried this version that didn't work for games but for anything else was fine:\n\nAfter some research I found another way, but with the same result:\n\nAm I using the API wrong or game engines blocked my input to protect the game from hackers?"
    },
    {
        "link": "https://stackoverflow.com/questions/2271376/find-a-window-using-c-and-modifying-controls",
        "document": "I would like to use c++ without mfc(and not clr) in order to modify textbox's and activate a button on a form outside of my project. I don't know where to start. I've done a lot of searching but can only find information for VB. A starting point would help. Thanks.\n\nI tried this and it doesn't seem to work.\n\nand I also tried this\n\nI ALSO tried using LPTSTR instead of LPCWSTR, incase it was a unicode deal.\n\nMaybe I don't understand this microsoft LPCWSTR and LPTSTR crap.\n\nand that didn't work. I guess the windows api must just be broken.\n\nI tried the function on other programs...I'm using xp and I tried catching the calculator, and an explorer window, and something else. But I got nothing.\n\nHeres some of the exact code I'm using to try and figure this out.\n\nBear in mind, I'm not actually trying to hook explorer, I just want to figure out how to get it to work."
    },
    {
        "link": "https://stackoverflow.com/questions/7070814/api-method-for-getting-windows-controls",
        "document": "I've searched quite a while in MSDN, couldn't find it.\n\nIn fact, I don't even know how controls are called in API. they are not declared as a \"Window\", right? (No hwnd for them, I wasn't sure because I saw a method which seemed like it could return a control but it returns an hwnd.)\n\nSo lets say I have a window's handle. I want to recieve it's controls (a textbox, button, checkbox....)\n\nWhat are the methods to do this? And again, how are the controls called in API? Thanks for helpers."
    },
    {
        "link": "https://forums.codeguru.com/showthread.php?290354-GetDlgItem(hwnd-ID_XX)",
        "document": "\n• sorry, but why the follolwing code causing an assertion?\n\n ListBox is the only listbox drawn on the main dialog box, with title \"MyApp\". I got the handle returned in both mywnd and mychildwnd.\n\n \n\n FROM MSDN:-\n\n HWND GetDlgItem(\n\n HWND hDlg, // handle to dialog box\n\n int nIDDlgItem // control identifier\n\n );\n\n \n\n hDlg \n\n [in] Handle to the dialog box that contains the control. \n\n nIDDlgItem \n\n [in] Specifies the identifier of the control to be retrieved. \n\n \n\n i tried both with hwnd and hchildwnd, i didn't get the pList succesfully in both cases.\n\n \n\n void CMyAppDlg::OnGet() { mywnd=::FindWindow(0,\"MyApp\"); mychildwnd=::FindWindowEx(mywnd,0,\"ListBox\",NULL); //pList is 0x0000000 CListBox *pList=(CListBox*)::GetDlgItem(mychildwnd,IDC_LIST1); //so assertion here pList->AddString(\"test\");//assertion here /* { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_ADDSTRING, 0, (LPARAM)lpszItem); }*/ }\n• Hi,\n\n Since you are using this from within the dialog class, you don't need the FindWindow - it brings you the handle of the list. \n\n Simply use:\n\n CListBox *pList=(CListBox*)GetDlgItem(IDC_LIST1);\n• yes, but i am just doing a test and i don understand why the win32 codes doesn't work as it should be...\n• OK, than i'll be happy to explain.\n\n The win32 API requires the handle of the window in which you want to look for another window. you tried to look for the list inside the list - that's not really possible... \n\n If you want to really do it with the win32 API you need the handle of the dialog, meaning:\n\n GetDlgItem(m_hWnd, IDC_LIST1);\n\n \n\n I believe this explains it.\n• thanks for your reply, but really, it doesn't work as well. i thought the mywnd and m_hWnd is actually the same., as i mentioned, i had tried the mychildwnd and mywnd both..\n\n \n\n what is the difference between m_hWnd and mywnd which i got by mywnd=::FindWindow(0,\"MyApp\") ..\n• if GetDlgItem(m_hWnd, IDCLIST1) does not work, it looks like you have a problem with the resource.\n\n \n\n As for you question regarding 'mywnd' - after you got it, use the following line:\n\n CWnd *myTempWindow = CWnd::FromHandle(mywnd);\n\n \n\n now in debug look to see what is the real class of the window - is it CDialog?\n• !!!!\n\n //pList is 0x0000000\n\n CListBox *pList=(CListBox*)::GetDlgItem(mychildwnd,IDC_LIST1);\n\n \n\n No, you are wrong.\n\n \n\n \n\n Trace the target program automatically and monitor the parameters of all API and COM interfaces.\n\n \n\n Auto Debug for Windows 4.0\n\n Auto Debug for .Net\n\n http://www.autodebug.com/ Best Api Monitor tool.Trace the target program automatically and monitor the parameters of all API and COM interfaces.Auto Debug for Windows 4.0Auto Debug for .Net\n• Just to let you know - CListBox does not overload the FromHandle function! this is exactly the same as calling CWnd::FromHandle\n• hello guys, thanks for all the post, i aslo found out myself that the correct way is using FromHandle(mychildwnd).\n\n \n\n But i need to take this a step further.\n\n \n\n Here, i am getting another instance of pList object in the heap, correct? \n\n \n\n What i am trying to achieve now is, i call FromHandle to get a CListBox* from another application/process., everything fine., i can add and delete item in another application through this pointer.\n\n \n\n But there are some controls which doesn't work., such as MsFlexGrid control. If it works on ListBox, i want to know why it doesn't work on MsFlexGrid, since both are derived from CWnd.\n• the class name of MSFlexGrid is MSFlexGridWndClass.\n\n Try finding(FindWindow(...)) your flexgrid using the above class name and then get a handle of it.\n• hi, as you see, my problem is not really about finding the handle of CMSFlexGrid, i already have the handle. The problem is: -\n\n \n\n \n\n CMsFlexGrid is derived from CWnd.\n\n \n\n I call this function: -\n\n \n\n //i already have the hGridWnd back by using FindWindow CMsFlexGrid * pGrid=(CMSFlexGrid*)FromHandle(hGridWnd); hGridWnd is a HWND from another application/process. //Then i do: //Now, i want to know why this cause an assertion. pGrid->JustAnyMethod(); If the other control is listbox, i have no problem: CListBox * pList=(CListBox*)FromHandle(hListBoxWnd); pList->JustAnyMethod(); //hListBoxWnd is also from another application/process. Further to this, i want to know what really happen when you do FromHandle, is a new instance of CMSFlexGrid object being created in the caller's process?? if so, i should be able to access it. If the new instance is created in the callee's process space, i should also be able to access by passing a pointer which is relative to the callee' process memory. Last edited by mce; April 8th, 2004 at .\n• 'pList' is of basetype 'CWnd *' and not 'HWND' as returned by 'GetDlgItem'...\n\n \n\n Furthermore, use 'GetLastError()' to retrieve the specific error code for 'GetDlgItem()'...\n• how abt questions in my last post? any ideas??\n• Note that a CWnd is just a C++ object and is something specific to MFC. \n\n \n\n But whether you use MFC or not, all window objects are identified by HWND. So, you can use a hWnd ( handle to a window ) across process and it works fine. But that is not the case with CWnd. CWnd is something that MFC invented to wrap the Windows calls to a window ( and other things ) from within a C++ object. So, if you had your own class you could have a CMyFunkyWindow instead of CWnd and still achieve the same purpose. Finaly, what matters is the ultimate call to a Win32 API taking a HWND as parameter such as SetWindowText(hWnd.... ) etc.. \n\n \n\n Ok. MFC application framework maintains a map of handles created to their corresponding CWnd ( C++ ) objects. So, given a handle you can get the CWnd object. There are 2 kinds of map MFC uses, permanent, temporary. Permanent map is used wherever you have gone thru a CWnd::Create or a Subclasswindow or something like that. When you don't do that, for e.g., in a dialog you may subclass some 2 edit boxes( by way of providing a DDX_Control entry ) and you may not subclass 2 other edit boxes. So, for 2 edit boxes you have corresponding CWnd objects in the permanent map, but for the other 2 you do not have. Despite this, all 4 edit boxes have a valid HWND. \n\n \n\n What FromHandle does is, first it goes off and searches the permanent map and checks to see if there is a CWnd object for the given hWnd. If it finds one , it returns that. If it doesn't find, it creates a temporary CWnd object, and attaches the hWnd to this CWnd object by calling CWnd::Attach. It then returns this object pointer. It also adds this CWnd object to a temporary map. \n\n \n\n From time to time, MFC framework will loop through the list of temporary map and deletes the C++ objects. Therefore, you need to exercise caution not to store the CWnd object returned from FromHandle because they may not simply be valid CWnd object anymore at a later time. \n\n \n\n What is happening in your case is, when you call FromHandle in either case, you are getting a handle to a temporary object. Why temporary ? Simple reason being the hWnd is from a different App and so there is no way your app is gonna have a permanent map entry for that window !!!\n\n \n\n But note that this is a CWnd object and is not a CListBox or CFlexGrid or whatever. So , it is unsafe to assume that. \n\n But, you say methods on CListBox object work, right ? \n\n That may be because, if say you call GetItemCount() method of a listbox , it may be implemented in MFC as CListBox::GetItemCount() { ::SendMessage(m_hWnd, message .. .) ; } which you see is a simple Win32 call without involving any data specific to listbox.\n\n \n\n But then can the same be said of CFlexGrid ? Does \n\n CFlexGrid::JustAnyMethod translate just to ::SendMesage(m_hWnd, message... ) ? to wrap code sections. \n\n - Debugging 101 using Visual Studio - Video article for beginners\n\n visit me @http://www.kirants.com\n• This is basically what I was trying to say in the thread:\n\n \n\n http://www.codeguru.com/forum/showth...hreadid=290235\n\n \n\n kirants gave you more information on how things work, under the hood. The reason that it works with some controls and not others, is that those controls are just wrapping Windows API calls that use the handle itself! Things like CWnd::GetWindowText just wraps the ::GetWindowText(hWnd, ...) function.\n\n \n\n Viggy\n• You may not post new threads\n• You may not post replies\n• You may not post attachments\n• You may not edit your posts\n\n\n\n\n\n\n\n \n\n \n\n Click Here to Expand Forum to Full Width \n\n \n\n * The Best Reasons to Target Windows 8\n\n Learn some of the best reasons why you should seriously consider bringing your Android mobile development expertise to bear on the Windows 8 platform.\n• * Porting from Android to Windows 8: The Real Story\n\n Do you have an Android application? How hard would it really be to port to Windows 8?\n• * Guide to Porting Android Applications to Windows 8\n\n If you've already built for Android, learn what do you really need to know to port your application to Windows Phone 8.\n• * HTML5 Development Center\n\n Our portal for articles, videos, and news on HTML5, CSS3, and JavaScript\n• * Windows App Gallery\n\n See the Windows 8.x apps we've spotlighted or submit your own app to the gallery!"
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-findwindowa",
        "document": "Retrieves a handle to the top-level window whose class name and window name match the specified strings. This function does not search child windows. This function does not perform a case-sensitive search.\n\nTo search child windows, beginning with a specified child window, use the FindWindowEx function.\n\nThe class name or a class atom created by a previous call to the RegisterClass or RegisterClassEx function. The atom must be in the low-order word of lpClassName; the high-order word must be zero.\n\nIf lpClassName points to a string, it specifies the window class name. The class name can be any name registered with RegisterClass or RegisterClassEx, or any of the predefined control-class names.\n\nIf lpClassName is NULL, it finds any window whose title matches the lpWindowName parameter.\n\nThe window name (the window's title). If this parameter is NULL, all window names match.\n\nIf the function succeeds, the return value is a handle to the window that has the specified class name and window name.\n\nIf the function fails, the return value is NULL. This function does not modify the last error value.\n\nIf the lpWindowName parameter is not NULL, FindWindow calls the GetWindowText function to retrieve the window name for comparison. For a description of a potential problem that can arise, see the Remarks for GetWindowText.\n\nFor an example, see Retrieving the Number of Mouse Wheel Scroll Lines.\n\nThe winuser.h header defines FindWindow as an alias that automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that is not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for Function Prototypes."
    },
    {
        "link": "https://cplusplus.com/forum/windows/265715",
        "document": "I am working on getting the hwnd by using the mouse cursor pointing on button/statictext. The problem is I cannot reach the button/statictext which is inside a tab dialog.\n\n \n\n I used Spy++ to get the hierarchy, there are 3 layers to reach the desired button. MainWindow (#32770) - Tab1 (#32770) - Btn1 (Button). It shows that Tab1 is not parented to SysTabControl32 and have the same parent window with SysTabControl32.\n\n \n\n Instead of getting the Btn1, I always get SysTabControl32, which has the same hierarchy level with Tab1, means that I only can reach the SysTabControl32 but not the Tab1.\n\n \n\n If I used and point my mouse on Btn1, I will get SysTabControl32; using , I will get 0 as return value; using , I will get SysTabControl32.\n\n \n\n Spy++ only can detect MainWindow, SysTabControl32 and Tab1 but it cannot detect Btn1. I can get all the child windows by using but the function still cannot find Tab1 and those child windows. Also, Spy++ is able to highlight Btn1 after I \"Highlight\" it but if I use 'Find Window' function in Spy++, Btn1 cannot be detected. \n\n \n\n Is it the reason is the overlapping of sibling windows? Does anyone know what is the cause of this situation and how to solve it? Please help..Thanks\n\nThe problem is I cannot reach the button/statictext which is inside a tab dialog. \n\n To get childs of a dialog you are supposed to use function\n\n https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getdlgitem\n\n \n\n I can get all the child windows by using EnumChildWindow \n\n Good, EnumChildWindow, will do the work too, but unlike which gets you single control, the let's you do stuff on all child windows, I recommend you to use to get a handle to button.\n\n \n\n Is it the reason is the overlapping of sibling windows? \n\n surely not.\n\n \n\n \n\n that doesn't sound as good design for your issue, just use \n\n \n\n Note: I'm not MFC expert, my sugesstions here are based on Win32, and should work just fine.\n\n \n\n edit: the MFC dialog in guestion has a mehotd called so you may use that instead of winapi version. To get childs of a dialog you are supposed to usefunctionGood, EnumChildWindow, will do the work too, but unlikewhich gets you single control, thelet's you do stuff on all child windows, I recommend you to useto get a handle to button.surely not.that doesn't sound as good design for your issue, just useNote: I'm not MFC expert, my sugesstions here are based on Win32, and should work just fine.edit: the MFC dialog in guestion has a mehotd calledso you may use that instead of winapi version.\n\n\n\n \n\n Thank you so much for the information. I'm a beginner in MFC and I'm not sure how to implement in my MFC application because it consists of many others function and cpp files. Does it has any simple C++ code that I can try and test run in console before I apply it into MFC?\n\n \n\n Below is the code that I have tried\n\n Hi malibor,Thank you so much for the information. I'm a beginner in MFC and I'm not sure how to implementin my MFC application because it consists of many others function and cpp files. Does it has any simple C++ code that I can try and test run in console before I apply it into MFC?Below is the code that I have tried\n\nclass inherits from which has a virtual base method \n\n \n\n reference:\n\n https://docs.microsoft.com/en-us/cpp/mfc/reference/cwnd-class?view=vs-2019#getdlgitem\n\n \n\n this is all you need, you should take a look at memory template to find out control ID which you pass into the \n\n \n\n then here is pseudo code:\n\n \n\n CDialog dlg( , ); CWnd* btn = dlg.GetDlgItem(IDOK); // get pointer to ie. OK button HWND hButton = btn->GetSafeHwnd(); \n\n \n\n this is how to do it, but I guess the dialog you are talking about isn't created by you?\n\n well in that case you don't know control ID (and you should not know it) and what that mean is you need to obtain this info somehow because template most likely isn't open source, here are few suggestions how to do it:\n\n \n\n \n\n for description of these see:\n\n https://docs.microsoft.com/en-us/cpp/mfc/reference/cdialog-class?view=vs-2019\n\n \n\n OR\n\n if you need a handle you would call below method, and the use C API to \"hack the MFC dialog\":\n\n \n\n see info here:\n\n https://docs.microsoft.com/en-us/cpp/mfc/reference/cwnd-class?view=vs-2019#getsafehwnd\n\n \n\n Below is the code that I have tried \n\n No no, first the code isn't MFC, if you are using MFC then please avoid C style API, and use MFC functionality in a manner similar to my sample, and secondly, doesn't look like maintanable solution for MFC, and it isn't FMC code or style either.\n\n \n\n Instead make use of on the dialog pointer/varaible to get focus to button, that should be better and it's MFC code too.\n\n \n\n In your code, where is the dialog pointer you were talking about? or object variable? use that to get the handle.\n\n for example:\n\n \n\n \n\n Does it has any simple C++ code that I can try and test run in console before I apply it into MFC? \n\n I'm afraid not without googling out, but all information you need is really on msdn, you just need to take a read.\n\n \n\n as I said I don't know MFC I just try to help you with this info here is from msdn, it's not that hard to understand. since MFC is just winapi and C++. known concepts. the rest belongs to reading the reference.\n\n \n\n \n\n Ok, I did a quick search on msdn an figured out,class inherits fromwhich has a virtual base methodthis is all you need, you should take a look at memory template to find out control ID which you pass into thethen here is pseudo code:this is how to do it, but I guess the dialog you are talking about isn't created by you?well in that case you don't know control ID (and you should not know it) and what that mean is you need to obtain this info somehow because template most likely isn't open source, here are few suggestions how to do it:for description of these see:if you need a handle you would call below method, and the use C API to \"hack the MFC dialog\":see info here:No no, first the code isn't MFC, if you are using MFC then please avoid C style API, and use MFC functionality in a manner similar to my sample, and secondly,doesn't look like maintanable solution for MFC, and it isn't FMC code or style either.Instead make use ofon the dialog pointer/varaible to get focus to button, that should be better and it's MFC code too.In your code, where is the dialog pointer you were talking about? or object variable? use that to get the handle.for example:I'm afraid not without googling out, but all information you need is really on msdn, you just need to take a read.as I said I don't know MFC I just try to help you with this info here is from msdn, it's not that hard to understand. since MFC is just winapi and C++. known concepts. the rest belongs to reading the reference."
    }
]