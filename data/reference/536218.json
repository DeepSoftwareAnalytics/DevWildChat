[
    {
        "link": "https://legacy.reactjs.org/docs/hooks-reference.html",
        "document": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.\n\nThis page describes the APIs for the built-in Hooks in React.\n\nIf you’re new to Hooks, you might want to check out the overview first. You may also find useful information in the frequently asked questions section.\n\nReturns a stateful value, and a function to update it.\n\nDuring the initial render, the returned state ( ) is the same as the value passed as the first argument ( ).\n\nThe function is used to update the state. It accepts a new state value and enqueues a re-render of the component.\n\nDuring subsequent re-renders, the first value returned by will always be the most recent state after applying updates.\n\nIf the new state is computed using the previous state, you can pass a function to . The function will receive the previous value, and return an updated value. Here’s an example of a counter component that uses both forms of :\n\nThe ”+” and ”-” buttons use the functional form, because the updated value is based on the previous value. But the “Reset” button uses the normal form, because it always sets the count back to the initial value.\n\nIf your update function returns the exact same value as the current state, the subsequent rerender will be skipped completely.\n\nThe argument is the state used during the initial render. In subsequent renders, it is disregarded. If the initial state is the result of an expensive computation, you may provide a function instead, which will be executed only on the initial render:\n\nIf you update a State Hook to the same value as the current state, React will bail out without rendering the children or firing effects. (React uses the comparison algorithm.)\n\nNote that React may still need to render that specific component again before bailing out. That shouldn’t be a concern because React won’t unnecessarily go “deeper” into the tree. If you’re doing expensive calculations while rendering, you can optimize them with .\n\nReact may group several state updates into a single re-render to improve performance. Normally, this improves performance and shouldn’t affect your application’s behavior.\n\nBefore React 18, only updates inside React event handlers were batched. Starting with React 18, batching is enabled for all updates by default. Note that React makes sure that updates from several different user-initiated events — for example, clicking a button twice — are always processed separately and do not get batched. This prevents logical mistakes.\n\nIn the rare case that you need to force the DOM update to be applied synchronously, you may wrap it in . However, this can hurt performance so do this only where needed.\n\nMutations, subscriptions, timers, logging, and other side effects are not allowed inside the main body of a function component (referred to as React’s render phase). Doing so will lead to confusing bugs and inconsistencies in the UI.\n\nInstead, use . The function passed to will run after the render is committed to the screen. Think of effects as an escape hatch from React’s purely functional world into the imperative world.\n\nBy default, effects run after every completed render, but you can choose to fire them only when certain values have changed.\n\nOften, effects create resources that need to be cleaned up before the component leaves the screen, such as a subscription or timer ID. To do this, the function passed to may return a clean-up function. For example, to create a subscription:\n\nThe clean-up function runs before the component is removed from the UI to prevent memory leaks. Additionally, if a component renders multiple times (as they typically do), the previous effect is cleaned up before executing the next effect. In our example, this means a new subscription is created on every update. To avoid firing an effect on every update, refer to the next section.\n\nUnlike and , the function passed to fires after layout and paint, during a deferred event. This makes it suitable for the many common side effects, like setting up subscriptions and event handlers, because most types of work shouldn’t block the browser from updating the screen.\n\nHowever, not all effects can be deferred. For example, a DOM mutation that is visible to the user must fire synchronously before the next paint so that the user does not perceive a visual inconsistency. (The distinction is conceptually similar to passive versus active event listeners.) For these types of effects, React provides one additional Hook called . It has the same signature as , and only differs in when it is fired.\n\nAdditionally, starting in React 18, the function passed to will fire synchronously before layout and paint when it’s the result of a discrete user input such as a click, or when it’s the result of an update wrapped in . This behavior allows the result of the effect to be observed by the event system, or by the caller of .\n\nEven in cases where is deferred until after the browser has painted, it’s guaranteed to fire before any new renders. React will always flush a previous render’s effects before starting a new update.\n\nThe default behavior for effects is to fire the effect after every completed render. That way an effect is always recreated if one of its dependencies changes.\n\nHowever, this may be overkill in some cases, like the subscription example from the previous section. We don’t need to create a new subscription on every update, only if the prop has changed.\n\nTo implement this, pass a second argument to that is the array of values that the effect depends on. Our updated example now looks like this:\n\nNow the subscription will only be recreated when changes.\n\nThe array of dependencies is not passed as arguments to the effect function. Conceptually, though, that’s what they represent: every value referenced inside the effect function should also appear in the dependencies array. In the future, a sufficiently advanced compiler could create this array automatically.\n\nAccepts a context object (the value returned from ) and returns the current context value for that context. The current context value is determined by the prop of the nearest above the calling component in the tree.\n\nWhen the nearest above the component updates, this Hook will trigger a rerender with the latest context passed to that provider. Even if an ancestor uses or , a rerender will still happen starting at the component itself using .\n\nDon’t forget that the argument to must be the context object itself:\n\nA component calling will always re-render when the context value changes. If re-rendering the component is expensive, you can optimize it by using memoization.\n\nPutting it together with Context.Provider\n\nThis example is modified for hooks from a previous example in the Context Advanced Guide, where you can find more information about when and how to use Context.\n\nThe following Hooks are either variants of the basic ones from the previous section, or only needed for specific edge cases. Don’t stress about learning them up front.\n\nAn alternative to . Accepts a reducer of type , and returns the current state paired with a method. (If you’re familiar with Redux, you already know how this works.)\n\nis usually preferable to when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one. also lets you optimize performance for components that trigger deep updates because you can pass down instead of callbacks.\n\nHere’s the counter example from the section, rewritten to use a reducer:\n\nThere are two different ways to initialize state. You may choose either one depending on the use case. The simplest way is to pass the initial state as a second argument:\n\nYou can also create the initial state lazily. To do this, you can pass an function as the third argument. The initial state will be set to .\n\nIt lets you extract the logic for calculating the initial state outside the reducer. This is also handy for resetting the state later in response to an action:\n\nIf you return the same value from a Reducer Hook as the current state, React will bail out without rendering the children or firing effects. (React uses the comparison algorithm.)\n\nNote that React may still need to render that specific component again before bailing out. That shouldn’t be a concern because React won’t unnecessarily go “deeper” into the tree. If you’re doing expensive calculations while rendering, you can optimize them with .\n\nPass an inline callback and an array of dependencies. will return a memoized version of the callback that only changes if one of the dependencies has changed. This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. ).\n\nPass a “create” function and an array of dependencies. will only recompute the memoized value when one of the dependencies has changed. This optimization helps to avoid expensive calculations on every render.\n\nRemember that the function passed to runs during rendering. Don’t do anything there that you wouldn’t normally do while rendering. For example, side effects belong in , not .\n\nIf no array is provided, a new value will be computed on every render.\n\nYou may rely on as a performance optimization, not as a semantic guarantee. In the future, React may choose to “forget” some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. Write your code so that it still works without — and then add it to optimize performance.\n\nreturns a mutable ref object whose property is initialized to the passed argument ( ). The returned object will persist for the full lifetime of the component.\n\nA common use case is to access a child imperatively:\n\nEssentially, is like a “box” that can hold a mutable value in its property.\n\nYou might be familiar with refs primarily as a way to access the DOM. If you pass a ref object to React with , React will set its property to the corresponding DOM node whenever that node changes.\n\nHowever, is useful for more than the attribute. It’s handy for keeping any mutable value around similar to how you’d use instance fields in classes.\n\nThis works because creates a plain JavaScript object. The only difference between and creating a object yourself is that will give you the same ref object on every render.\n\nKeep in mind that doesn’t notify you when its content changes. Mutating the property doesn’t cause a re-render. If you want to run some code when React attaches or detaches a ref to a DOM node, you may want to use a callback ref instead.\n\ncustomizes the instance value that is exposed to parent components when using . As always, imperative code using refs should be avoided in most cases. should be used with :\n\nIn this example, a parent component that renders would be able to call .\n\nThe signature is identical to , but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside will be flushed synchronously, before the browser has a chance to paint.\n\nPrefer the standard when possible to avoid blocking visual updates.\n\ncan be used to display a label for custom hooks in React DevTools.\n\nFor example, consider the custom Hook described in “Building Your Own Hooks”:\n\nIn some cases formatting a value for display might be an expensive operation. It’s also unnecessary unless a Hook is actually inspected.\n\nFor this reason accepts a formatting function as an optional second parameter. This function is only called if the Hooks are inspected. It receives the debug value as a parameter and should return a formatted display value.\n\nFor example a custom Hook that returned a value could avoid calling the function unnecessarily by passing the following formatter:\n\naccepts a value and returns a new copy of the value that will defer to more urgent updates. If the current render is the result of an urgent update, like user input, React will return the previous value and then render the new value after the urgent render has completed.\n\nThis hook is similar to user-space hooks which use debouncing or throttling to defer updates. The benefits to using is that React will work on the update as soon as other work finishes (instead of waiting for an arbitrary amount of time), and like , deferred values can suspend without triggering an unexpected fallback for existing content.\n\nonly defers the value that you pass to it. If you want to prevent a child component from re-rendering during an urgent update, you must also memoize that component with or :\n\nMemoizing the children tells React that it only needs to re-render them when changes and not when changes. This caveat is not unique to , and it’s the same pattern you would use with similar hooks that use debouncing or throttling.\n\nReturns a stateful value for the pending state of the transition, and a function to start it.\n\nlets you mark updates in the provided callback as transitions:\n\nindicates when a transition is active to show a pending state:\n\nis a hook for generating unique IDs that are stable across the server and client, while avoiding hydration mismatches.\n\nFor a basic example, pass the directly to the elements that need it:\n\nFor multiple IDs in the same component, append a suffix using the same :\n\nThe following Hooks are provided for library authors to integrate libraries deeply into the React model, and are not typically used in application code.\n\nis a hook recommended for reading and subscribing from external data sources in a way that’s compatible with concurrent rendering features like selective hydration and time slicing.\n\nThis method returns the value of the store and accepts three arguments:\n• : function to register a callback that is called whenever the store changes.\n• : function that returns the current value of the store.\n• : function that returns the snapshot used during server rendering.\n\nThe most basic example simply subscribes to the entire store:\n\nHowever, you can also subscribe to a specific field:\n\nWhen server rendering, you must serialize the store value used on the server, and provide it to . React will use this snapshot during hydration to prevent server mismatches:\n\nThe signature is identical to , but it fires synchronously before all DOM mutations. Use this to inject styles into the DOM before reading layout in . Since this hook is limited in scope, this hook does not have access to refs and cannot schedule updates."
    },
    {
        "link": "https://react.dev/reference/react/useEffect",
        "document": "In this example, a cleanup function is not needed because the class manages only the DOM node that was passed to it. After the React component is removed from the tree, both the DOM node and the class instance will be automatically garbage-collected by the browser JavaScript engine. You can use an Effect to fetch data for your component. Note that if you use a framework, using your framework’s data fetching mechanism will be a lot more efficient than writing Effects manually. If you want to fetch data from an Effect manually, your code might look like this: Note the variable which is initialized to , and is set to during cleanup. This ensures your code doesn’t suffer from “race conditions”: network responses may arrive in a different order than you sent them.\n\nWriting data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later. It’s easier to use a custom Hook—either your own or maintained by the community. What are good alternatives to data fetching in Effects? Writing calls inside Effects is a popular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:\n• Effects don’t run on the server. This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.\n• Fetching directly in Effects makes it easy to create “network waterfalls”. You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.\n• Fetching directly in Effects usually means you don’t preload or cache data. For example, if the component unmounts and then mounts again, it would have to fetch the data again.\n• It’s not very ergonomic. There’s quite a bit of boilerplate code involved when writing calls in a way that doesn’t suffer from bugs like race conditions. This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:\n• If you use a framework, use its built-in data fetching mechanism. Modern React frameworks have integrated data fetching mechanisms that are efficient and don’t suffer from the above pitfalls.\n• Otherwise, consider using or building a client-side cache. Popular open source solutions include React Query, useSWR, and React Router 6.4+. You can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes). You can continue fetching data directly in Effects if neither of these approaches suit you. Notice that you can’t “choose” the dependencies of your Effect. Every reactive value used by your Effect’s code must be declared as a dependency. Your Effect’s dependency list is determined by the surrounding code: If either or change, your Effect will reconnect to the chat using the new values. Reactive values include props and all variables and functions declared directly inside of your component. Since and are reactive values, you can’t remove them from the dependencies. If you try to omit them and your linter is correctly configured for React, the linter will flag this as a mistake you need to fix: To remove a dependency, you need to “prove” to the linter that it doesn’t need to be a dependency. For example, you can move out of your component to prove that it’s not reactive and won’t change on re-renders: Now that is not a reactive value (and can’t change on a re-render), it doesn’t need to be a dependency. If your Effect’s code doesn’t use any reactive values, its dependency list should be empty ( ): An Effect with empty dependencies doesn’t re-run when any of your component’s props or state change. If you have an existing codebase, you might have some Effects that suppress the linter like this: When dependencies don’t match the code, there is a high risk of introducing bugs. By suppressing the linter, you “lie” to React about the values your Effect depends on. Instead, prove they’re unnecessary.\n\nNow that you create the object inside the Effect, the Effect itself only depends on the string. With this fix, typing into the input doesn’t reconnect the chat. Unlike an object which gets re-created, a string like doesn’t change unless you set it to another value. Read more about removing dependencies. If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the function is different for every render: By itself, creating a function from scratch on every re-render is not a problem. You don’t need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render. Avoid using a function created during rendering as a dependency. Instead, declare it inside the Effect:"
    },
    {
        "link": "https://telerik.com/blogs/guide-new-hooks-react-18",
        "document": "In this blog post, we won’t just describe what React hooks do, but we’ll also get our hands dirty and cover how to use them in the code.\n\nReact 18 is a major release that comes with new features, such as concurrent rendering, automated batching, transitions, new APIs and hooks. In this tutorial, we will cover the five new hooks that arrived in React 18:\n\nHowever, instead of just describing what they do and how to use them, we will get our hands dirty and cover how to actually use them in the code. For that, we will create contrived state management and CSS-in-JS solutions. Let’s dive in!\n\nYou can find full code examples for this project in this GitHub repository. Below you can also find an interactive StackBlitz.\n\nIf you would like to follow this tutorial, you can quickly scaffold a new React project using Vite by running the command below:\n\nAfter the project is scaffolded, move into it, install all libraries and start the dev server.\n\nWe will use Tailwind for styles, but instead of going through the whole setup process, we will take advantage of the CDN version. Just update the file and add the script below.\n\nThat’s it for the setup. Let’s have a look at the first new hook— .\n\nThe times when React ran only on client-side are long gone. With frameworks like Next.js, Gatsby or Remix and new features like server components, React is used on both client- and server-side.\n\nUntil version 18, React did not offer any good way to generate unique IDs that could be used for server- and client-rendered content. The important thing to remember is that the HTML markup that was rendered on the client should match the one rendered on the server. Otherwise, you will be welcomed with a React server hydration mismatch error.\n\nHere’s a situation in which it could happen: Let’s say we have a form with an input field for which we need to generate a unique id.\n\nThe component above would have ids generated once on the server, and new ones would be generated on the client-side. This would result in a mismatch in the DOM. That’s where the hook comes into play.\n\nThe hook can be used to generate unique IDs that will be the same on the server- and client-side and thus help to avoid the mismatch error.\n\nIf we have more fields than one, we can always use string interpolation and add a prefix or a suffix to the unique id. You can create a new file called with the code below.\n\nNext, update the component to render the .\n\nThe image below shows what you should see. React generates a unique id with a colon as a prefix and suffix.\n\nWith the new concurrent renderer, React can interrupt and pause renders. This means that if a new high-priority render is scheduled, React can stop the current low-priority rendering process and handle the upcoming one first.\n\nA high-priority render could be caused by a user’s click or input. React provides two new React hooks that can be used to indicate low-priority updates— and . This provides a new way of optimizing React apps, as developers can now specify which state updates are low priority.\n\nFirst, let’s have a look at the hook. Below we have a simple feature that allows a user to search for meals.\n\nWhen a user types something into the query input, the state is updated. However, instead of passing it directly to the component, it is passed to the hook instead. The hook returns a value, which then is passed to the component. We let React decide when exactly should the state change to the latest value.\n\nNote that the component is wrapped with to make sure it only re-renders when changes and not . The hook is similar to how bouncing or throttling works, but the difference is that instead of waiting until a specified amount of time has passed, React can start the work immediately when it’s done with higher priority work.\n\nNow we need to add the component in the file.\n\nThe GIF below shows what the search functionality should look like.\n\nNext, let’s have a look at the hook.\n\nThe hook is quite similar to , but we have more control over when to start a low-priority update. The hook returns a tuple with the value that indicates whether a transition is currently happening and the method.\n\nLet’s replace the hook from our previous example and use the hook instead.\n\nInstead of having a deferred state for the value, we wrap the update with the instead.\n\nIf React would be in the middle of processing the update but a higher priority update, like a user click, would be scheduled, the update would be paused.\n\nThe is a hook that was created for state management libraries. Its purpose is to provide an ability to read and subscribe from external data sources in a way that works with concurrent rendering features like selective hydration and time slicing.\n\nAn external store needs to provide at least two arguments—subscribe and get state snapshot methods. The former allows React to subscribe to any store changes, and the latter returns the store state. Here’s a simple example of how to use the hook.\n\nThe method returns the whole external state, but we can also pass a function that returns only a part of it. For instance, if the store has a field called , we could get just the value from the store state.\n\nThe can also accept a third argument, which can be used to provide a state snapshot that was created if the React app was server-side rendered. We won’t be diving into it in this article, as server-side rendering comes with its own rules and setup that is out of the scope for this article.\n\nThat’s a nice explanation so far, but how could we use it in practice? Fortunately, creating a state management library doesn’t necessarily have to be extremely complicated, and Zustand is a good example of that. Here’s a mini Zustand implementation utilizing the hook.\n\nFirst, we need store creation logic.\n\nThe creates a new state and a few methods:\n• – adds a new listener that will be notified when the state changes\n• – updates the state in an immutable way by utilizing immer and notifies all subscribers\n• – a wrapper around that can be used to consume the store state\n\nNow we can use the method to create a new store. Below, we create a count store with methods to increment, decrement, divide and multiply the count.\n\nFinally, add the component in the file.\n\nHere’s how our implementation looks in action.\n\nNote that the store creation code isn’t really optimized, so if you like this approach to an using external state, just use the Zustand library.\n\nThe should only be used by CSS-in-JS libraries to dynamically insert styles into the DOM. This hook has an identical signature to , but it runs synchronously before all DOM mutations. Thus, if you’re not injecting any CSS styles into the DOM, you shouldn’t use it.\n\nI wondered whether I should create a practical example of how to use the since I never really looked under the hood of CSS-in-JS libraries, but here it is. A naive, contrived and totally unoptimized CSS-in-JS implementation—meaning don’t use it at home.\n\nFirst, we have the hook that accepts an object with styles and props.\n\nIn the , a unique hashed class name is generated for each object style property, and the object with styles is converted to a CSS string using the library. Each rule is pushed into the array.\n\nIn the , we create a new element, loop through the style rules and insert each of them into the stylesheet.\n\nLast but not least, the stylesheet is removed from the DOM in the cleanup function.\n\nNow we can use our hook, so create a new file called and copy the code below into it.\n\nWe have the object with styles for the buttons that are then passed to the hook. The hook returns an object with classes that look something like this:\n\nThe class is passed to a element, while the class to and buttons.\n\nThe state changes every time one of the buttons is clicked. When that happens, the old styles are removed, and new ones are created and inserted into the DOM again inside of the .\n\nNext, we need to render the component.\n\nThe GIF below shows what the should look like.\n\nWe have covered the new hooks that were added in React 18. Interestingly enough, you might actually find yourself not using any of them.\n\nand are specifically designed for library authors who work on state management and CSS-in-JS solutions. The hook is useful if your React app runs on both client and server, so if your React app runs only on the client-side, you won’t really need it.\n\nFurthermore, and can be used to mark some state updates as less important and defer, but this isn’t something that all applications will necessarily need.\n\nNevertheless, all of these hooks are a great addition, and I can’t wait to see what else React will bring in the future. If you would like to read more about React 18, make sure to read the official blog page that covers new features."
    },
    {
        "link": "https://react.dev/reference/react/useState",
        "document": "Suppose the is . This handler calls three times: However, after one click, will only be rather than ! This is because calling the function does not update the state variable in the already running code. So each call becomes . To solve this problem, you may pass an updater function to instead of the next state: Here, is your updater function. It takes the pending state and calculates the next state from it. React puts your updater functions in a queue. Then, during the next render, it will call them in the same order:\n• will receive as the pending state and return as the next state.\n• will receive as the pending state and return as the next state.\n• will receive as the pending state and return as the next state. There are no other queued updates, so React will store as the current state in the end. By convention, it’s common to name the pending state argument for the first letter of the state variable name, like for . However, you may also call it like or something else that you find clearer. React may call your updaters twice in development to verify that they are pure. You might hear a recommendation to always write code like if the state you’re setting is calculated from the previous state. There is no harm in it, but it is also not always necessary. In most cases, there is no difference between these two approaches. React always makes sure that for intentional user actions, like clicks, the state variable would be updated before the next click. This means there is no risk of a click handler seeing a “stale” at the beginning of the event handler. However, if you do multiple updates within the same event, updaters can be helpful. They’re also helpful if accessing the state variable itself is inconvenient (you might run into this when optimizing re-renders). If you prefer consistency over slightly more verbose syntax, it’s reasonable to always write an updater if the state you’re setting is calculated from the previous state. If it’s calculated from the previous state of some other state variable, you might want to combine them into one object and use a reducer.\n\nReact saves the initial state once and ignores it on the next renders. Although the result of is only used for the initial render, you’re still calling this function on every render. This can be wasteful if it’s creating large arrays or performing expensive calculations. To solve this, you may pass it as an initializer function to instead: Notice that you’re passing , which is the function itself, and not , which is the result of calling it. If you pass a function to , React will only call it during initialization. React may call your initializers twice in development to verify that they are pure.\n\nUsually, you will update state in event handlers. However, in rare cases you might want to adjust state in response to rendering — for example, you might want to change a state variable when a prop changes. In most cases, you don’t need this:\n• If the value you need can be computed entirely from the current props or other state, remove that redundant state altogether. If you’re worried about recomputing too often, the Hook can help.\n• If you want to reset the entire component tree’s state, pass a different to your component.\n• If you can, update all the relevant state in the event handlers. In the rare case that none of these apply, there is a pattern you can use to update state based on the values that have been rendered so far, by calling a function while your component is rendering. Here’s an example. This component displays the prop passed to it: Say you want to show whether the counter has increased or decreased since the last change. The prop doesn’t tell you this — you need to keep track of its previous value. Add the state variable to track it. Add another state variable called to hold whether the count has increased or decreased. Compare with , and if they’re not equal, update both and . Now you can show both the current count prop and how it has changed since the last render.\n\nNote that if you call a function while rendering, it must be inside a condition like , and there must be a call like inside of the condition. Otherwise, your component would re-render in a loop until it crashes. Also, you can only update the state of the currently rendering component like this. Calling the function of another component during rendering is an error. Finally, your call should still update state without mutation — this doesn’t mean you can break other rules of pure functions. This pattern can be hard to understand and is usually best avoided. However, it’s better than updating state in an effect. When you call the function during render, React will re-render that component immediately after your component exits with a statement, and before rendering the children. This way, children don’t need to render twice. The rest of your component function will still execute (and the result will be thrown away). If your condition is below all the Hook calls, you may add an early to restart rendering earlier. Calling the function does not change state in the running code: This is because states behaves like a snapshot. Updating state requests another render with the new state value, but does not affect the JavaScript variable in your already-running event handler. If you need to use the next state, you can save it in a variable before passing it to the function: React will ignore your update if the next state is equal to the previous state, as determined by an comparison. This usually happens when you change an object or an array in state directly: You mutated an existing object and passed it back to , so React ignored the update. To fix this, you need to ensure that you’re always replacing objects and arrays in state instead of mutating them: I’m getting an error: “Too many re-renders” You might get an error that says: Too many re-renders. React limits the number of renders to prevent an infinite loop. Typically, this means that you’re unconditionally setting state during render, so your component enters a loop: render, set state (which causes a render), render, set state (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler: If you can’t find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific function call responsible for the error. In Strict Mode, React will call some of your functions twice instead of once: This is expected and shouldn’t break your code. This development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and updater functions are pure, this shouldn’t affect your logic. However, if they are accidentally impure, this helps you notice the mistakes. For example, this impure updater function mutates an array in state: Because React calls your updater function twice, you’ll see the todo was added twice, so you’ll know that there is a mistake. In this example, you can fix the mistake by replacing the array instead of mutating it: Now that this updater function is pure, calling it an extra time doesn’t make a difference in behavior. This is why React calling it twice helps you find mistakes. Only component, initializer, and updater functions need to be pure. Event handlers don’t need to be pure, so React will never call your event handlers twice. I’m trying to set state to a function, but it gets called instead You can’t put a function into state like this: Because you’re passing a function, React assumes that is an initializer function, and that is an updater function, so it tries to call them and store the result. To actually store a function, you have to put before them in both cases. Then React will store the functions you pass."
    },
    {
        "link": "https://legacy.reactjs.org/docs/hooks-effect.html",
        "document": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.\n\nThe Effect Hook lets you perform side effects in function components:\n\nThis snippet is based on the counter example from the previous page, but we added a new feature to it: we set the document title to a custom message including the number of clicks.\n\nData fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects. Whether or not you’re used to calling these operations “side effects” (or just “effects”), you’ve likely performed them in your components before.\n\nThere are two common kinds of side effects in React components: those that don’t require cleanup, and those that do. Let’s look at this distinction in more detail.\n\nSometimes, we want to run some additional code after React has updated the DOM. Network requests, manual DOM mutations, and logging are common examples of effects that don’t require a cleanup. We say that because we can run them and immediately forget about them. Let’s compare how classes and Hooks let us express such side effects.\n\nIn React class components, the method itself shouldn’t cause side effects. It would be too early — we typically want to perform our effects after React has updated the DOM.\n\nThis is why in React classes, we put side effects into and . Coming back to our example, here is a React counter class component that updates the document title right after React makes changes to the DOM:\n\nNote how we have to duplicate the code between these two lifecycle methods in class.\n\nThis is because in many cases we want to perform the same side effect regardless of whether the component just mounted, or if it has been updated. Conceptually, we want it to happen after every render — but React class components don’t have a method like this. We could extract a separate method but we would still have to call it in two places.\n\nNow let’s see how we can do the same with the Hook.\n\nWe’ve already seen this example at the top of this page, but let’s take a closer look at it:\n\nWhat does do? By using this Hook, you tell React that your component needs to do something after render. React will remember the function you passed (we’ll refer to it as our “effect”), and call it later after performing the DOM updates. In this effect, we set the document title, but we could also perform data fetching or call some other imperative API.\n\nWhy is called inside a component? Placing inside the component lets us access the state variable (or any props) right from the effect. We don’t need a special API to read it — it’s already in the function scope. Hooks embrace JavaScript closures and avoid introducing React-specific APIs where JavaScript already provides a solution.\n\nDoes run after every render? Yes! By default, it runs both after the first render and after every update. (We will later talk about how to customize this.) Instead of thinking in terms of “mounting” and “updating”, you might find it easier to think that effects happen “after render”. React guarantees the DOM has been updated by the time it runs the effects.\n\nNow that we know more about effects, these lines should make sense:\n\nWe declare the state variable, and then we tell React we need to use an effect. We pass a function to the Hook. This function we pass is our effect. Inside our effect, we set the document title using the browser API. We can read the latest inside the effect because it’s in the scope of our function. When React renders our component, it will remember the effect we used, and then run our effect after updating the DOM. This happens for every render, including the first one.\n\nExperienced JavaScript developers might notice that the function passed to is going to be different on every render. This is intentional. In fact, this is what lets us read the value from inside the effect without worrying about it getting stale. Every time we re-render, we schedule a different effect, replacing the previous one. In a way, this makes the effects behave more like a part of the render result — each effect “belongs” to a particular render. We will see more clearly why this is useful later on this page.\n\nEarlier, we looked at how to express side effects that don’t require any cleanup. However, some effects do. For example, we might want to set up a subscription to some external data source. In that case, it is important to clean up so that we don’t introduce a memory leak! Let’s compare how we can do it with classes and with Hooks.\n\nIn a React class, you would typically set up a subscription in , and clean it up in . For example, let’s say we have a module that lets us subscribe to a friend’s online status. Here’s how we might subscribe and display that status using a class:\n\nNotice how and need to mirror each other. Lifecycle methods force us to split this logic even though conceptually code in both of them is related to the same effect.\n\nLet’s see how we could write this component with Hooks.\n\nYou might be thinking that we’d need a separate effect to perform the cleanup. But code for adding and removing a subscription is so tightly related that is designed to keep it together. If your effect returns a function, React will run it when it is time to clean up:\n\nWhy did we return a function from our effect? This is the optional cleanup mechanism for effects. Every effect may return a function that cleans up after it. This lets us keep the logic for adding and removing subscriptions close to each other. They’re part of the same effect!\n\nWhen exactly does React clean up an effect? React performs the cleanup when the component unmounts. However, as we learned earlier, effects run for every render and not just once. This is why React also cleans up effects from the previous render before running the effects next time. We’ll discuss why this helps avoid bugs and how to opt out of this behavior in case it creates performance issues later below.\n\nWe’ve learned that lets us express different kinds of side effects after a component renders. Some effects might require cleanup so they return a function:\n\nOther effects might not have a cleanup phase, and don’t return anything.\n\nThe Effect Hook unifies both use cases with a single API.\n\nIf you feel like you have a decent grasp on how the Effect Hook works, or if you feel overwhelmed, you can jump to the next page about Rules of Hooks now.\n\nWe’ll continue this page with an in-depth look at some aspects of that experienced React users will likely be curious about. Don’t feel obligated to dig into them now. You can always come back to this page to learn more details about the Effect Hook.\n\nOne of the problems we outlined in the Motivation for Hooks is that class lifecycle methods often contain unrelated logic, but related logic gets broken up into several methods. Here is a component that combines the counter and the friend status indicator logic from the previous examples:\n\nNote how the logic that sets is split between and . The subscription logic is also spread between and . And contains code for both tasks.\n\nSo, how can Hooks solve this problem? Just like you can use the State Hook more than once, you can also use several effects. This lets us separate unrelated logic into different effects:\n\nHooks let us split the code based on what it is doing rather than a lifecycle method name. React will apply every effect used by the component, in the order they were specified.\n\nIf you’re used to classes, you might be wondering why the effect cleanup phase happens after every re-render, and not just once during unmounting. Let’s look at a practical example to see why this design helps us create components with fewer bugs.\n\nEarlier on this page, we introduced an example component that displays whether a friend is online or not. Our class reads from , subscribes to the friend status after the component mounts, and unsubscribes during unmounting:\n\nBut what happens if the prop changes while the component is on the screen? Our component would continue displaying the online status of a different friend. This is a bug. We would also cause a memory leak or crash when unmounting since the unsubscribe call would use the wrong friend ID.\n\nIn a class component, we would need to add to handle this case:\n\nForgetting to handle properly is a common source of bugs in React applications.\n\nNow consider the version of this component that uses Hooks:\n\nIt doesn’t suffer from this bug. (But we also didn’t make any changes to it.)\n\nThere is no special code for handling updates because handles them by default. It cleans up the previous effects before applying the next effects. To illustrate this, here is a sequence of subscribe and unsubscribe calls that this component could produce over time:\n\nThis behavior ensures consistency by default and prevents bugs that are common in class components due to missing update logic.\n\nIn some cases, cleaning up or applying the effect after every render might create a performance problem. In class components, we can solve this by writing an extra comparison with or inside :\n\nThis requirement is common enough that it is built into the Hook API. You can tell React to skip applying an effect if certain values haven’t changed between re-renders. To do so, pass an array as an optional second argument to :\n\nIn the example above, we pass as the second argument. What does this mean? If the is , and then our component re-renders with still equal to , React will compare from the previous render and from the next render. Because all items in the array are the same ( ), React would skip the effect. That’s our optimization.\n\nWhen we render with updated to , React will compare the items in the array from the previous render to items in the array from the next render. This time, React will re-apply the effect because . If there are multiple items in the array, React will re-run the effect even if just one of them is different.\n\nThis also works for effects that have a cleanup phase:\n\nIn the future, the second argument might get added automatically by a build-time transformation.\n\nCongratulations! This was a long page, but hopefully by the end most of your questions about effects were answered. You’ve learned both the State Hook and the Effect Hook, and there is a lot you can do with both of them combined. They cover most of the use cases for classes — and where they don’t, you might find the additional Hooks helpful.\n\nWe’re also starting to see how Hooks solve problems outlined in Motivation. We’ve seen how effect cleanup avoids duplication in and , brings related code closer together, and helps us avoid bugs. We’ve also seen how we can separate effects by their purpose, which is something we couldn’t do in classes at all.\n\nAt this point you might be questioning how Hooks work. How can React know which call corresponds to which state variable between re-renders? How does React “match up” previous and next effects on every update? On the next page we will learn about the Rules of Hooks — they’re essential to making Hooks work."
    },
    {
        "link": "https://ant.design/components/form",
        "document": "Form provides default verification error messages. You can modify the template by configuring property. A common usage is to configure localization:\n\nBesides, ConfigProvider also provides a global configuration scheme that allows for uniform configuration error notification templates:\n\nForm field component for data bidirectional binding, validation, layout, and so on.\n\nAfter wrapped by with property, (or other property defined by ) (or other property defined by ) props will be added to form controls, the flow of form data will be handled by Form which will cause:\n• You shouldn't use on each form control to collect data(use of Form), but you can still listen to .\n• You cannot set value for each form control via or prop, you should set default value with of Form. Note that cannot be updated by dynamically, you should use in that situation.\n• You shouldn't call manually, please use to change value programmatically.\n\nUsed when there are dependencies between fields. If a field has the prop, this field will automatically trigger updates and validations when upstream is updated. A common scenario is a user registration form with \"password\" and \"confirm password\" fields. The \"Confirm Password\" validation depends on the \"Password\" field. After setting , the \"Password\" field update will re-trigger the validation of \"Check Password\". You can refer examples.\n\nshouldn't be used together with , since it may result in conflicting update logic.\n\nForm updates only the modified field-related components for performance optimization purposes by incremental update. In most cases, you only need to write code or do validation with the property. In some specific cases, such as when a new field option appears with a field value changed, or you just want to keep some area updating by form update, you can modify the update logic of Form.Item via the .\n\nWhen is , any Form update will cause the Form.Item to be re-rendered. This is very helpful for custom rendering some areas. It should be noted that the child component should be returned in a function, otherwise won't behave correctly:\n\nYou can ref example to see detail.\n\nWhen is a function, it will be called by form values update. Providing original values and current value to compare. This is very helpful for rendering additional fields based on values:\n\nYou can ref example to see detail.\n\nYou can modify the default verification information of Form.Item through .\n\nSince , when you don't want to convert , you can use to skip:\n\nNote: You should not configure Form.Item under Form.List. It always should be configured by Form.List or Form .\n\nSome operator functions in render form of Form.List.\n\nNew in 4.7.0. Show error messages, should only work with of Form.List. See example.\n\nProvide linkage between forms. If a sub form with prop update, it will auto trigger Provider related events. See example.\n\nAdded in . Get current context form instance to avoid pass as props between components:\n\nWatch the value of a field. You can use this to interact with other hooks like to reduce development costs:\n\nIf your component is wrapped by , you can omit the second argument, will find the nearest automatically.\n\nBy default only watches the registered field. If you want to watch the unregistered field, please use :\n\nAdded in . Could be used to get validate status of Form.Item. If this hook is not used under Form.Item, would be . Added and in , Could be used to get error messages and warning messages of Form.Item:\n\nForm only update the Field which changed to avoid full refresh perf issue. Thus you can not get real time value with in render. And will rerender current component to sync with latest value. You can also use Field renderProps to get better performance if only want to do conditional render. If component no need care field value change, you can use to give to parent component to avoid current one rerender.\n\nWhen is empty, return all registered fields, including values of List (even if List has no Item children).\n\nWhen is , return all values in store, including unregistered fields. For example, if you set the value of an unregistered Item through , you can also get all values through .\n\nWhen is an array, return the value of the specified path. Note that is a nested array. For example, you need the value of a certain path as follows:\n\nNew in . Accept configuration parameters. When is , only the value of Item will be matched. For example, in , if List is only bound to the field, then will only get .\n\nTo filter certain field values, will provide information related to the fields. For example, it can be used to retrieve values that have only been modified by the user, and so on."
    },
    {
        "link": "https://stackoverflow.com/questions/56715594/how-to-correctly-validate-and-submit-if-form-is-valid-with-ant-design-form-with",
        "document": "I build a simple form with react, redux, typescript ant design. Following the ant design documentation, I created a small form using the provided and methods. Everything works fine so far and validation is handled by ant design itself when entering data into the fields. My main issue is with the form submit. I want to submit data only if the form is validated and the form is, therefore \"valid\".\n\nThe official documentation uses to validate the form and returns a variable which contains the errors and returns further execution so that the form doesn't get submitted. Now with typescript I have the following signatures: <- I use this method to trigger validation upon submit of the form and afterwards call\n\nNow if you look at the example code, the ugly part is using a variable \"allValid\" to check if the form is valid or not. I thought there must be a simpler way of validating and submitting data if the form is valid."
    },
    {
        "link": "https://stackoverflow.com/questions/57952554/how-to-show-error-or-validation-messages-only-after-form-is-submitted-and-not-wh",
        "document": "I have created a form using Ant Design with Reactjs. It works great except it shows error messages that I have specified for each field under the input field before the \"Submit\" button is even clicked and user is typing in. It looks very odd and I would like to change that behavior. I want to show these messages only after the submit button is clicked. Is there a way to do it?\n\nI went through the official doc. I couldn't find anything regarding \"async validator\" or \"getFieldDecorator\" that suggested what I wanted to achieve.\n\nThe \"getFieldDecorator\" to specify validation rules and error messages for each field is set in this way:\n\nMy \"OnSubmit()\" method looks like this:\n\nExpected is to show error messages only after the submit button is clicked and not before that even if user types invalid inputs or leaves it blank. Help would be appreciated since I am new to React."
    },
    {
        "link": "https://github.com/ant-design/ant-design/issues/40580",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://github.com/ant-design/ant-design/issues/15674",
        "document": "\n• I have searched the issues of this repository and believe that this is not a duplicate.\n\nWhat problem does this feature solve?\n\nFor e.g. I want to display a form for user and be able to toggle an disabled prop of submit button if form is valid or not.\n\nWhat does the proposed API look like?\n\nIt would be super if it would be possible to do by using accessing this boolean value like a form prop like:"
    }
]