[
    {
        "link": "https://qt.io/product/qt6/qml-book/ch17-qtcpp-qtcpp",
        "document": "Qt is a C++ toolkit with an extension for QML and Javascript. There exist many language bindings for Qt, but as Qt itself is developed in C++. The spirit of C++ can be found throughout the classes. In this section, we will look at Qt from a C++ perspective to build a better understanding of how to extend QML with native plugins developed using C++. Through C++, it is possible to extend and control the execution environment provided to QML.\n\nThis chapter will, just as Qt, require the reader to have some basic knowledge of C++. Qt does not rely on advanced C++ features and I generally consider the Qt style of C++ to be very readable, so do not worry if you feel that your C++ knowledge is shaky.\n\nApproaching Qt from a C++ direction, you will find that Qt enriches C++ with a number of modern language features enabled through making introspection data available. This is made possible through the use of the base class. Introspection data, or metadata, maintains information of the classes at run-time, something that ordinary C++ does not do. This makes it possible to dynamically probe objects for information about such details as their properties and available methods.\n\nQt uses this meta information to enable a very loosely bound callback concept using signals and slots. Each signal can be connected to any number of slots or even other signals. When a signal is emitted from an object instance, the connected slots are invoked. As the signal emitting object does not need to know anything about the object owning the slot and vice versa, this mechanism is used to create very reusable components with very few inter-component dependencies.\n\nThe introspection features are also used to create dynamic language bindings, making it possible to expose a C++ object instance to QML and making C++ functions callable from Javascript. Other bindings for Qt C++ exist and besides the standard Javascript binding, the official one is the Python binding called PySide6 (opens new window).\n\nIn addition to this central concept, Qt makes it possible to develop cross-platform applications using C++. Qt C++ provides a platform abstraction on the different operating systems, which allows the developer to concentrate on the task at hand and not the details of how you open a file on different operating systems. This means you can re-compile the same source code for Windows, OS X, and Linux and Qt takes care of the different OS ways of handling certain things. The end result is natively built applications with the look and feel of the target platform. As the mobile is the new desktop, newer Qt versions can also target a number of mobile platforms using the same source code, e.g. iOS, Android, Jolla, BlackBerry, Ubuntu Phone, Tizen.\n\nWhen it comes to re-using, not only can source code be re-used but developer skills are also reusable. A team knowing Qt can reach out to far more platforms than a team just focusing on a single platform specific technology and as Qt is so flexible the team can create different system components using the same technology.\n\nFor all platform, Qt offers a set of basic types, e.g. strings with full Unicode support, lists, vectors, buffers. It also provides a common abstraction to the target platform’s main loop, and cross-platform threading and networking support. The general philosophy is that for an application developer Qt comes with all required functionality included. For domain-specific tasks such as to interface to your native libraries, Qt comes with several helper classes to make this easier."
    },
    {
        "link": "https://doc.qt.io/qt-6/signalsandslots.html",
        "document": "In GUI programming, when we change one widget, we often want another widget to be notified. More generally, we want objects of any kind to be able to communicate with one another. For example, if a user clicks a Close button, we probably want the window's close() function to be called.\n\nOther toolkits achieve this kind of communication using callbacks. A callback is a pointer to a function, so if you want a processing function to notify you about some event you pass a pointer to another function (the callback) to the processing function. The processing function then calls the callback when appropriate. While successful frameworks using this method do exist, callbacks can be unintuitive and may suffer from problems in ensuring the type-correctness of callback arguments.\n\nIn Qt, we have an alternative to the callback technique: We use signals and slots. A signal is emitted when a particular event occurs. Qt's widgets have many predefined signals, but we can always subclass widgets to add our own signals to them. A slot is a function that is called in response to a particular signal. Qt's widgets have many pre-defined slots, but it is common practice to subclass widgets and add your own slots so that you can handle the signals that you are interested in.\n\nThe signals and slots mechanism is type safe: The signature of a signal must match the signature of the receiving slot. (In fact a slot may have a shorter signature than the signal it receives because it can ignore extra arguments.) Since the signatures are compatible, the compiler can help us detect type mismatches when using the function pointer-based syntax. The string-based SIGNAL and SLOT syntax will detect type mismatches at runtime. Signals and slots are loosely coupled: A class which emits a signal neither knows nor cares which slots receive the signal. Qt's signals and slots mechanism ensures that if you connect a signal to a slot, the slot will be called with the signal's parameters at the right time. Signals and slots can take any number of arguments of any type. They are completely type safe.\n\nAll classes that inherit from QObject or one of its subclasses (e.g., QWidget) can contain signals and slots. Signals are emitted by objects when they change their state in a way that may be interesting to other objects. This is all the object does to communicate. It does not know or care whether anything is receiving the signals it emits. This is true information encapsulation, and ensures that the object can be used as a software component.\n\nSlots can be used for receiving signals, but they are also normal member functions. Just as an object does not know if anything receives its signals, a slot does not know if it has any signals connected to it. This ensures that truly independent components can be created with Qt.\n\nYou can connect as many signals as you want to a single slot, and a signal can be connected to as many slots as you need. It is even possible to connect a signal directly to another signal. (This will emit the second signal immediately whenever the first is emitted.)\n\nTogether, signals and slots make up a powerful component programming mechanism.\n\nSignals are emitted by an object when its internal state has changed in some way that might be interesting to the object's client or owner. Signals are public access functions and can be emitted from anywhere, but we recommend to only emit them from the class that defines the signal and its subclasses.\n\nWhen a signal is emitted, the slots connected to it are usually executed immediately, just like a normal function call. When this happens, the signals and slots mechanism is totally independent of any GUI event loop. Execution of the code following the statement will occur once all slots have returned. The situation is slightly different when using queued connections; in such a case, the code following the keyword will continue immediately, and the slots will be executed later.\n\nIf several slots are connected to one signal, the slots will be executed one after the other, in the order they have been connected, when the signal is emitted.\n\nSignals are automatically generated by the moc and must not be implemented in the file.\n\nA note about arguments: Our experience shows that signals and slots are more reusable if they do not use special types. If QScrollBar::valueChanged() were to use a special type such as the hypothetical QScrollBar::Range, it could only be connected to slots designed specifically for QScrollBar. Connecting different input widgets together would be impossible.\n\nA slot is called when a signal connected to it is emitted. Slots are normal C++ functions and can be called normally; their only special feature is that signals can be connected to them.\n\nSince slots are normal member functions, they follow the normal C++ rules when called directly. However, as slots, they can be invoked by any component, regardless of its access level, via a signal-slot connection. This means that a signal emitted from an instance of an arbitrary class can cause a private slot to be invoked in an instance of an unrelated class.\n\nYou can also define slots to be virtual, which we have found quite useful in practice.\n\nCompared to callbacks, signals and slots are slightly slower because of the increased flexibility they provide, although the difference for real applications is insignificant. In general, emitting a signal that is connected to some slots, is approximately ten times slower than calling the receivers directly, with non-virtual function calls. This is the overhead required to locate the connection object, to safely iterate over all connections (i.e. checking that subsequent receivers have not been destroyed during the emission), and to marshall any parameters in a generic fashion. While ten non-virtual function calls may sound like a lot, it's much less overhead than any or operation, for example. As soon as you perform a string, vector or list operation that behind the scene requires or , the signals and slots overhead is only responsible for a very small proportion of the complete function call costs. The same is true whenever you do a system call in a slot; or indirectly call more than ten functions. The simplicity and flexibility of the signals and slots mechanism is well worth the overhead, which your users won't even notice.\n\nNote that other libraries that define variables called or may cause compiler warnings and errors when compiled alongside a Qt-based application. To solve this problem, the offending preprocessor symbol.\n\nThe QObject-based version has the same internal state, and provides public methods to access the state, but in addition it has support for component programming using signals and slots. This class can tell the outside world that its state has changed by emitting a signal, , and it has a slot which other objects can send signals to.\n\nAll classes that contain signals or slots must mention Q_OBJECT at the top of their declaration. They must also derive (directly or indirectly) from QObject.\n\nSlots are implemented by the application programmer. Here is a possible implementation of the slot:\n\nThe line emits the signal from the object, with the new value as argument.\n\nIn the following code snippet, we create two objects and connect the first object's signal to the second object's slot using QObject::connect():\n\nCalling makes emit a signal, which will receive in its slot, i.e. is called. Then emits the same signal, but since no slot has been connected to 's signal, the signal is ignored.\n\nNote that the function sets the value and emits the signal only if . This prevents infinite looping in the case of cyclic connections (e.g., if were connected to ).\n\nBy default, for every connection you make, a signal is emitted; two signals are emitted for duplicate connections. You can break all of these connections with a single disconnect() call. If you pass the Qt::UniqueConnection type, the connection will only be made if it is not a duplicate. If there is already a duplicate (exact same signal to the exact same slot on the same objects), the connection will fail and connect will return .\n\nThis example illustrates that objects can work together without needing to know any information about each other. To enable this, the objects only need to be connected together, and this can be achieved with some simple QObject::connect() function calls, or with uic's automatic connections feature.\n\nThe following is an example of the header of a simple widget class without member functions. The purpose is to show how you can utilize signals and slots in your own applications.\n\ninherits QObject, which has most of the signal-slot knowledge, via QFrame and QWidget. It is somewhat similar to the built-in QLCDNumber widget.\n\nThe Q_OBJECT macro is expanded by the preprocessor to declare several member functions that are implemented by the ; if you get compiler errors along the lines of \"undefined reference to vtable for \", you have probably forgotten to run the moc or to include the moc output in the link command.\n\nAfter the class constructor and members, we declare the class . The class emits a signal, , when it is asked to show an impossible value.\n\nIf you don't care about overflow, or you know that overflow cannot occur, you can ignore the signal, i.e. don't connect it to any slot.\n\nIf on the other hand you want to call two different error functions when the number overflows, simply connect the signal to two different slots. Qt will call both (in the order they were connected).\n\nA slot is a receiving function used to get information about state changes in other widgets. uses it, as the code above indicates, to set the displayed number. Since is part of the class's interface with the rest of the program, the slot is public.\n\nSeveral of the example programs connect the valueChanged() signal of a QScrollBar to the slot, so the LCD number continuously shows the value of the scroll bar.\n\nNote that is overloaded; Qt will select the appropriate version when you connect a signal to the slot. With callbacks, you'd have to find five different names and keep track of the types yourself.\n\nThe signatures of signals and slots may contain arguments, and the arguments can have default values. Consider QObject::destroyed():\n\nWhen a QObject is deleted, it emits this QObject::destroyed() signal. We want to catch this signal, wherever we might have a dangling reference to the deleted QObject, so we can clean it up. A suitable slot signature might be:\n\nTo connect the signal to the slot, we use QObject::connect(). There are several ways to connect signal and slots. The first is to use function pointers:\n\nThere are several advantages to using QObject::connect() with function pointers. First, it allows the compiler to check that the signal's arguments are compatible with the slot's arguments. Arguments can also be implicitly converted by the compiler, if needed.\n\nYou can also connect to functors or C++11 lambdas:\n\nIn both these cases, we provide this as context in the call to connect(). The context object provides information about in which thread the receiver should be executed. This is important, as providing the context ensures that the receiver is executed in the context thread.\n\nThe lambda will be disconnected when the sender or context is destroyed. You should take care that any objects used inside the functor are still alive when the signal is emitted.\n\nThe other way to connect a signal to a slot is to use QObject::connect() and the and macros. The rule about whether to include arguments or not in the and macros, if the arguments have default values, is that the signature passed to the macro must not have fewer arguments than the signature passed to the macro.\n\nAll of these would work:\n\nBut this one won't work:\n\n...because the slot will be expecting a QObject that the signal will not send. This connection will report a runtime error.\n\nNote that signal and slot arguments are not checked by the compiler when using this QObject::connect() overload.\n\nFor cases where you may require information on the sender of the signal, Qt provides the QObject::sender() function, which returns a pointer to the object that sent the signal.\n\nLambda expressions are a convenient way to pass custom arguments to a slot:\n\nUsing Qt with 3rd Party Signals and Slots\n\nIt is possible to use Qt with a 3rd party signal/slot mechanism. You can even use both mechanisms in the same project. To do that, write the following into your CMake project file:\n\nIn a qmake project (.pro) file, you need to write:\n\nIt tells Qt not to define the moc keywords , , and , because these names will be used by a 3rd party library, e.g. Boost. Then to continue using Qt signals and slots with the flag, simply replace all uses of the Qt moc keywords in your sources with the corresponding Qt macros Q_SIGNALS (or Q_SIGNAL), Q_SLOTS (or Q_SLOT), and Q_EMIT.\n\nThe public API of Qt-based libraries should use the keywords and instead of and . Otherwise it is hard to use such a library in a project that defines .\n\nTo enforce this restriction, the library creator may set the preprocessor define when building the library.\n\nThis define excludes signals and slots without affecting whether other Qt-specific keywords can be used in the library implementation."
    },
    {
        "link": "https://sciendo.com/2/download/0~xmz-x8UDuZxX9EL3UIBaYMJqYxzdqwdYTe~jSG_T.pdf",
        "document": ""
    },
    {
        "link": "https://packtpub.com/en-us/product/cross-platform-development-with-qt-6-and-modern-c-9781800204584?type=print&srsltid=AfmBOophfFzAAZGjWfaTAOjTNsjQF3tdE14MSVns0TjXpPW_W_Ow8eoT",
        "document": "There are different ways to install the Qt framework and tools on your system. You can download an online or offline installer from the Qt website, or you can build the source packages yourself. Qt recommends using the online installer for first-time installations and the Qt Maintenance Tool for modifying the installation later.\n\nThe installers allow you to download and install the following components:\n\nThe online installer allows you to select open source or commercial versions of Qt, tools, and Add-On modules to install based on the chosen license. The online installer doesn't contain the Qt components, but it is a downloader client to download all the relevant files. You can install once the download is complete. You will require a Qt account to download and install Qt. An evaluation version for the commercial Qt gives you free trial-period access, with all commercial packages and access to official Qt support. The installer requires you to sign in with your Qt account. If you don't have a Qt account, you can sign up during the installation process. The installer fetches the license attached to the account from the Qt server and lists down modules according to your license. If you are new to Qt, then we recommend that you start with the open source version.\n\nThe offline installer is a platform-specific package that includes all Qt modules and add-ons relevant for the platform. Due to the official policy changes, open source offline installers are not available any more since Qt 5.15. If you have a commercial license, then you can provide the credentials during the installation process. You can locate your license key in your Qt account web portal.\n\nYou can download them from the following links:\n• Offline: https://www.qt.io/offline-installers The Qt Company provides users with a dual-licensing option. As a beginner, you can get started with an open source license to explore Qt. If you are working for a company, then discuss with your manager or Information Technology (IT) or legal team to procure a commercial license or to understand legal obligations. You can learn more about Qt licensing at https://www.qt.io/licensing/.\n\nLet's start by downloading Qt onto your machine, as follows:\n• Click on the Download. Try. Buy. button in the top-right corner. You will see different download options here.\n• If you want to try the commercial version, then click on Try Qt section. If you already have a Qt account, then you can log in into the account under the Existing customers section.\n• Considering that you are new to Qt, we will begin with the open source version. Click on the Go open source button, as shown in the following screenshot:\n• On the next screen, you will find Download the Qt Online Installer button. Click on it to proceed to the download link.\n• The web page will automatically detect the underlying platform details from the browser and will show you the Download button. You can also select your intended installer by choosing the other options: you can select 32-bit or 64-bit or download for a different platform. You will see a Thank you page after you click on the download option. At this stage, you can find the installer in your folder.\n\nNext, let's begin with the installation process on the Windows platform.\n\nNow, let's start the installation process on Windows! Proceed as follows:\n• You will find a file with the name inside your download folder. Double-click on the executable, and you will see a Welcome screen.\n• Click the Next button, and a credentials screen will appear, asking you to log in with your Qt account. If you don't have one, then you can sign up on the same page, as shown in the following screenshot:\n• In the next screen, you will be presented with the open source usage obligations agreement. You won't get this screen if you are installing using a commercial license. Click on the first checkbox, saying I have read and approve the obligations of using Open Source Qt, and acknowledge that you are not using Qt for commercial purposes. Make sure you read the terms and conditions mentioned in the agreement! Then, click on the Next button.\n• The next screen will provide you with options related to tracking and sharing pseudonymous data in Qt Creator. You may allow or disable these options based on your preferences. Then, click on the Next button to proceed to the next screen.\n• In the next screen, you can specify the installation path. You may continue with the default path, or you can change it to any other path if you don't have enough space on the default drive. You can also choose whether you want to associate common file types with Qt Creator by selecting the checkbox option at the bottom. Click on the Next button.\n• Next, you will be presented with a list where you can select the version(s) of Qt you need to install on your system. You may simply proceed with the default options. If you don't need some of the components, then you can unselect them to reduce the size of the download. You can update the Qt components using the Maintenance Tool anytime later. To complete the installation process, click on the Next button. The component selection screen can be seen here:\n• In the next screen, you will be presented with the license agreement. Click on the first radio button, which says I have read and agree to the terms contained in the license agreements. Again, make sure you read the terms and conditions mentioned in the license agreement, and then click on the Next button.\n• On the next screen, you can create Start menu shortcuts on Windows. This screen will not be available for other platforms. Once you have finished doing this, click on the Next button.\n• Now, Qt is ready to be installed in your system. Make sure you have a working internet connection and data balance. Click on the Install button to begin the installation. The download process will take time, depending on your internet speed. Once the required files are downloaded, the installer will automatically install them in the previously selected path.\n• Once the installation is finished, the installer will make an entry for the Maintenance Tool, which will help you later to make changes to the libraries. Click on the Next button to move to the last screen of the installer.\n• In order to complete the installation process, click on the Finish button. If you have left the Launch Qt Creator checkbox checked, then Qt Creator will be launched. We will discuss this in more detail in the next chapter. Now, Qt is ready to be used on your Windows machine. Click on the Finish button to exit the wizard.\n\nNow, let's install the Qt framework on the latest LTS version of Linux, such as Ubuntu 20.04, CentOS 8.1, or openSUSE 15.1. We will be focusing on the most popular Linux distribution, Ubuntu. You can follow the same steps as mentioned previously to download the online installer from the Qt website.\n\nOn Ubuntu, you will get an installer file such as , where is the latest version— for example: .\n• You may have to give write permissions to the downloaded file before executing it. To do that, open the terminal and run the following command:\n• You can start the install process by double-clicking the downloaded installer file. The installation requires superuser access. You may have to add a password in the authorization dialog during the installation. You can also run the installer from the terminal, as follows:\n• You will see similar screens to those shown for the Windows platform. Apart from the operating system (OS)-specific title bar changes, all the screens remain the same for installation in Ubuntu or similar Linux flavors.\n\nAt the time of writing the book, there was no Ubuntu or Debian package available for Qt 6 as the respective maintainers have stepped down. Hence, you may not get the Qt 6 package from the terminal.\n\nIf you are a macOS user, then you can also install the same way as discussed for the earlier platforms. You can follow the same steps mentioned previously to download the online installer from the Qt website.\n\nYou will get an installer file such as , where is the latest version (such as ).\n\nQt has a dependency on Xcode. To install Qt on your Mac, you will need Xcode installed on your machine, otherwise, it will refuse to install. If you are an Apple developer, then your Mac may have Xcode installed. If you don't have Xcode installed on your machine, then you may proceed to install Xcode's Command Line Tools instead of Xcode. This will save time and storage space on your machine:\n• To begin, type the following command on the terminal:\n• If the terminal shows the following output, then your system is ready for the next steps: xcode-select: error: command line tools are already installed, use \"Software Update\" to install updates\n• The next step is to install the Qt framework. Double-click on the installer file to launch the installation interface.\n• If the installer still complains that Xcode is not installed, then keep clicking OK until the message goes away permanently. Remember the installation path. Once the installation is finished, you are ready to use Qt on your machine.\n\nFurther instructions on Qt for macOS can be found at the following link:\n\nOnce Qt is installed, you can modify the components—including updating, adding, and removing components—using the Maintenance Tool under the installation directory. The directory structure remains the same for all desktop platforms. The installation directory contains folders and files, as shown in the following screenshot (on Windows):\n\nLet's begin with the maintenance process! You can add, remove, and update modules using the Maintenance Tool. Proceed as follows:\n• Click on the executable to launch the maintenance interface. Click on the Next button, and a credentials screen will appear, asking you to log in with your Qt account. The login details will be prefilled from your last login session. You can click Next to add or update components or select the Uninstall only checkbox to remove Qt from your system. The following screenshot shows what the credentials screen looks like: Figure 1.5 – Welcome screen of the Maintenance Tool\n• Once you are logged in, the tool will present you with options to add or remove or update the components, as shown in the following screenshot. Click on the Next button to proceed further:\n• On the next screen, you can select new components from the latest releases or the archived version. You can click on the Filter button to filter versions as per your requirement. You can also add new platform-specific components such as Android from the component list. If the component is existing and you uncheck it, then it will be removed from your desktop during the update. Once you have selected the components, click on the Next button. The following screenshot shows what the component selection screen looks like:\n• You will then come across the update screen. This screen will tell you how much storage space is required for the installation. If you are running out of storage space, then you may go back and remove some existing components. Click on the Update button to begin the process, as illustrated in the following screenshot: Figure 1.8 – The Ready to Update screen of the Maintenance Tool\n• You can abort the update installation process by clicking on the Cancel button. Qt will warn you and ask you for confirmation before aborting the installation process, as illustrated in the following screenshot. Once the process is aborted, click on the Next button to exit the wizard:\n• Launch the Maintenance Tool again to update existing components from the latest releases. You can click on the Quit button to exit the Maintenance Tool. Please wait while the installer fetches the meta-information from the remote repository. Click on the Next button to see the available components. The update option is illustrated in the following screenshot: Figure 1.10 – The Update option in the Maintenance Tool\n• Next, you can select which components to update from the checkboxes. You can choose to update all or you can update selectively. The installer will show how much storage space will be required for the update, as illustrated in the following screenshot. You can click Next to go to the update screen and begin the update. Then, on the next screen, click on the Update button to download the update packages:\n• Once the installation is finished, the installer makes entries for the Maintenance Tool, which will help you make changes to the libraries later. This is illustrated in the following screenshot. Click on the Next button to move to the last screen of the installer: Figure 1.12 – The Update finished screen in the Maintenance Tool\n• In the last screen, you will see Restart and Finish buttons. Click on the Finish button to exit the Qt wizard.\n• Similarly, you can restart or launch the Maintenance Tool and select the Remove all components radio button. Click on the Next button to begin the uninstallation process, as illustrated in the following screenshot:\n\nFigure 1.13 – The Remove option in the Maintenance Tool\n\nPlease note that on clicking the Uninstall button, all the Qt components will be removed from your system; you will have to reinstall Qt if you want to use them again. Click on Cancel if you don't intend to remove the Qt components from your system, as illustrated in the following screenshot. If you intend to remove the existing version and use a newer version of Qt, then select the Add or remove components option, as discussed earlier. This will remove older Qt modules and free up your disk space:\n\nFigure 1.14 – The Uninstall screen in the Maintenance Tool\n\nIn this section, we learned about modifying an existing Qt installation through the Maintenance Tool. Now, let's learn how to build and install Qt from the source code."
    },
    {
        "link": "https://reddit.com/r/cpp/comments/dclp8f/whats_your_opinion_of_the_qt_framework",
        "document": "I've been looking over its capabilities for a while and how to work with it. Honestly, it seems too good to be true. And you know what they say about such things. So I wanted to get some more views on this. Perhaps I missed some major flaws it may have."
    },
    {
        "link": "https://sfml-dev.org/documentation/2.5.1",
        "document": "Welcome to the official SFML documentation. Here you will find a detailed view of all the SFML classes and functions. \n\n If you are looking for tutorials, you can visit the official website at www.sfml-dev.org.\n\nHere is a short example, to show you how simple it is to use SFML:"
    },
    {
        "link": "https://medium.com/@RileyEntertainmentGameDev/getting-started-with-sfml-in-visual-studio-for-windows-eb689e72e912",
        "document": "SFML, the Simple and Fast Multimedia Library, is a cross-platform API written in C++ used to manage windows and provide access to 2D graphics, audio, and networking features. The full source is available on Github, and the library is distributed under the licence. The website provides a number of tutorials, and a full reference section.\n\nThis post will be covering how to set up SFML for development in Visual Studio for Windows. If you’re savvy enough and looking to get straight into it, you can just reference the tutorial found on the website itself. If you get stuck along the way, check back here for some extra tips.\n\nBefore I jump into the guide on getting set up in Visual Studio, I thought I’d address why I’m choosing to focus on SFML in the short-term.\n\nAs of September of 2021, the most recent release of SFML was version 2.5.1, roughly three years ago. Scanning the Github repository, ongoing development appears a little spotty since that time. Activity in the forums suggest there may be a bit of “analysis paralysis” going on when it comes to future releases:\n• Much of the codebase has aged, so there is discussion on updating it to the C++17 or C++20 standard.\n• Support for mobile platforms has been on the agenda for a long time.\n• Vulkan will eventually replace OpenGL, so SFML will ultimately need to be updated to support it.\n\nHopefully the presence of the SFML 2.6.0 project board, with tons of “done” items and only a few “open” items, is an indication that SFML is alive and well.\n\nSFML is really just a utility library that can be used to bypass a lot of low-level coding. It offers convenient ways to do all the low-level tasks necessary for game development, in a cross-platform manner:\n• Receive user interface events from the keyboard, mouse, or other controllers.\n\nSFML makes no assumptions on how your game engine should operate. This is the flexibility and control I was looking for when I was choosing a library. For myself, I enjoy the challenge and find it rewarding to build my own game loop and engine.\n\nFor my current game called The Colon Case, I’m also looking to limit its scope to a simpler 2D game engine, as I take the time and effort to learn more about game loops, sprite sheets, and so forth.\n\nThere are plenty of game design platforms that have large parts of the game engine built for you, allowing you to focus more immediately on the content of your game. If that’s the case, this blog might only be of passing interest to you, at least for the short term. You might look at platforms like Godot, Construct, Unity, or Unreal.\n\nThe SFML and Visual Studio tutorial page on the SFML website already provides everything you’ll need to get started. However, these pages would have been written in 2018, for an older version of Visual Studio. Here are a few additional notes:\n• The site strongly cautions that you need to match the SFML version you download with your version of Visual Studio. The download links for Visual Studio C++ 15 (2017) work fine with Visual Studio C++ 2019 as well.\n• In your project’s properties, under , add SFML’s include folder to the .\n• Under , add SFML’s lib folder to the .\n• I recommend linking to the static libraries, to avoid having to include SFML’s DLL files as part of your release. Under , add to the .\n• Under , add the SFML libraries you need to the .\n• The SFML distribution provides different library files for debug vs. release, and static vs. dynamic. For each configuration, you’ll need to be careful about which file you specify.\n• Pay special attention to the additional dependency matrix shown on the SFML and Visual Studio tutorial page. At a minimum, you’ll probably need to add and .\n\nI’ve provided an example SFML project over on Github. It has all the necessary project settings for debug and release, as well as 32-bit and 64-bit configurations. You’d only need to change the include and library directories to match where you installed SFML.\n\nIf you’re wondering whether there’s a less manual way of getting going with SFML, keep watching this blog! In my next post, I’ll be introducing the CMake build system. Soon after I’ll be discussing how to use CMake’s FetchContent module for SFML as an alternative to all this manual setup."
    },
    {
        "link": "https://sfml-dev.org/tutorials/3.0/window/events",
        "document": "This tutorial is a detailed list of window events. It describes them, and shows how to (and how not to) use them.\n\nSFML uses a type-safe API for events. There are two main ways to use this API. For a comprehensive example of both approaches, check out the EventHandling example program.\n\nThe first option is based around 's member functions and . The template argument must be an event subtype such as or . returns a pointer to the specific event subtype if the template argument matches the active event subtype. Otherwise it returns .\n\nreturns if the template argument matches the active event subtype. Otherwise it returns . This is especially useful for subtypes like which does not contain any data.\n\nNote how the API for getting events has changed slightly from SFML 2. and returns a . These two functions might return an event but they might not.\n\nHere's what that looks like:\n\nC++ lets you deduce the template parameter which is why you can write instead of . is another valid choice if you prefer a shorter expression.\n\nThe second option for processing events is via the function. This functions performs event visitation. What this means is that you can provide lambdas or other callables which take different event subtypes as arguments. Alternatively you may provide an object (or objects) with implementations which handle the event subtypes you want to process. Depending on the current active event subtype, the corresponding callback is called.\n\nHere's what that looks like:\n\nThe event is triggered when the user wants to close the window through any of the possible methods the window manager provides (\"close\" button, keyboard shortcut, etc.). This event only represents a close request, meaning the window is not yet closed when the event is received.\n\nTypically, one will just call in reaction to this event to actually close the window. However, you may also want to do something else first, like saving the current application state or asking the user what to do. If you don't do anything, the window remains open.\n\nThere's no event data associated with this event.\n\nThe event is triggered when the window is resized, either through user action or programmatically by calling . You can use this event to adjust the rendering settings: the viewport if you use OpenGL directly, or the current view if you use sfml-graphics.\n\nThe data associated with this event contains the new size of the window.\n\nThe and events are triggered when the window loses/gains focus, which happens when the user switches the currently active window. When the window is out of focus, it doesn't receive keyboard events. This event can be used e.g. if you want to pause your game when the window is inactive.\n\nThere's no event data associated with this event.\n\nThe event is triggered when a character is typed. This must not be confused with the event. interprets the user input and produces the appropriate printable character. For example, pressing '^' then 'e' on a French keyboard will produce two events, but a single event containing the 'ê' character. It works with all the input methods provided by the operating system, even the most specific or complex ones.\n\nThis event is typically used to catch user input in a text field.\n\nThe data associated with this event contains the Unicode value of the entered character. You can either put this data directly in a , or cast it to a after making sure that it is in the ASCII range (0 - 127).\n\nNote that since they are part of the Unicode standard, some non-printable characters such as backspace are generated by this event. In most cases you'll need to filter them out.\n\nThe and events are triggered when a keyboard key is pressed/released.\n\nIf a key is held, multiple events will be generated, at the default operating system delay (i.e. the same delay that applies when you hold a letter in a text editor). To disable repeated events, you can call . On the flip side, it is obvious that events can never be repeated.\n\nThis event is the one to use if you want to trigger an action exactly once when a key is pressed or released, like making a character jump with space, or exiting something with escape.\n\nSometimes, people try to react to events directly to implement smooth movement. Doing so will not produce the expected effect, because when you hold a key you only get a few events (remember, the repeat delay). To achieve smooth movement with events, you must use a boolean that you set on and clear on ; you can then move (independently of events) as long as the boolean is set.\n\nThe other (easier) solution to produce smooth movement is to use real-time keyboard input with (see the dedicated tutorial).\n\nThe data associated with these events contains the scancode and key code of the pressed/released key, as well as the current state of the modifier keys (alt, control, shift, system).\n\nScancodes are unique values for each physical key on a keyboard, regardless of the language or layout, whereas key codes represent keys based on the user's chosen layout. For instance, the Z key is in the bottom row to the left of the X key on a US layout. Referring to the scancode for Z would identify this physical key location on any keyboard. However, on a German layout, the same physical key is labeled Y. Thus, using the key code for Y can lead to different physical key locations, depending on the chosen layout.\n\nIt is strongly recommended to use scancodes over key codes if the physical location of the keys is more important than the key values that depend on the keyboard layout, such as using WASD keys for movement.\n\nThe event is triggered when a mouse wheel moves up or down, but also laterally if the mouse supports it.\n\nThe data associated with this event contains the number of ticks the wheel has moved, what the orientation of the wheel is and the current position of the mouse cursor.\n\nThe and events are triggered when a mouse button is pressed/released. SFML supports 5 mouse buttons: left, right, middle (wheel), extra #1 and extra #2 (side buttons).\n\nThe data associated with these events contains the code of the pressed/released button, as well as the current position of the mouse cursor.\n\nThe event is triggered when the mouse moves within the window.\n\nThe data associated with this event contains the current position of the mouse cursor relative to the window.\n\nThe event is triggered when the mouse moved within the window even if the mouse is moved a distance too small to perceive.\n\nWhile the position value is dependent on the screen resolution, the raw data of this event is not. If the physical mouse is moved too little to cause the cursor on the screen to move at least a single pixel, no event will be generated. In contrast, any movement information generated by the mouse independent of its sensor resolution will always generate an event.\n\nThe data associated with this event contains the change in position of the mouse cursor relative to the window.\n\nThe and events are triggered when the mouse cursor enters/leaves the window. There's no event data associated with these events.\n\nThe and events are triggered when a joystick button is pressed/released.\n\nSFML supports up to 8 joysticks and 32 buttons.\n\nThe data associated with these events contains the identifier of the joystick and the index of the pressed/released button.\n\nThe event is triggered when a joystick axis moves. Joystick axes are typically very sensitive. That's why SFML uses a detection threshold to avoid spamming your event loop with tons of events. This threshold can be changed with the function, in case you want to receive more or less joystick move events.\n\nSFML supports 8 joystick axes: X, Y, Z, R, U, V, POV X and POV Y. How they map to your joystick depends on its driver.\n\nThe data associated with this event contains the identifier of the joystick, the name of the axis, and its current position (in the range [-100, 100]).\n\nThe and events are triggered when a joystick is connected/disconnected.\n\nThe data associated with this event contains the identifier of the connected/disconnected joystick."
    },
    {
        "link": "https://stackoverflow.com/questions/73682060/compile-error-in-sfml-2-5-1-sample-code-in-linux",
        "document": "As the error message indicate, there is no constructor for which takes two input for width and height. The constructor expect an argument of type .\n\nCreate the Window as follows:"
    },
    {
        "link": "https://en.sfml-dev.org/forums/index.php?topic=26893.0",
        "document": "I am attempting to use SFML for my next project, however I have yet to find reliable information on how to install SFML for MinGW, the page on the main SFML website for SFML is for using code::blocks, and I would prefer to keep using VS Code if I could. Additionally all of the tutorials for Visual Studio are not for VS Code. I was hoping that someone who has installed it could guide me through the steps they used to install it. Thanks.\n\n\n\nI am on Windows."
    }
]