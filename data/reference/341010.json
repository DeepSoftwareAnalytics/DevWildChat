[
    {
        "link": "https://cmake.org/cmake/help/latest/guide/tutorial/index.html",
        "document": "The CMake tutorial provides a step-by-step guide that covers common build system issues that CMake helps address. Seeing how various topics all work together in an example project can be very helpful.\n\nThe tutorial source code examples are available in . Each step has its own subdirectory containing code that may be used as a starting point. The tutorial examples are progressive so that each step provides the complete solution for the previous step."
    },
    {
        "link": "https://cmake.org/cmake/help/latest/release/3.23.html",
        "document": "Changes made since CMake 3.22 include the following.\n• None files now have an optional field, which allows the files to include other files.\n• None files now support a macro, which contains the directory containing the preset file.\n• None gained support for specifying the command line option in a build preset to control restoration behavior of package references from external package managers. Currently this is only supported by the Visual Studio generator to support restoring packages from NuGet. Other generators ignore this option.\n• None The Visual Studio Generators for VS 2019 and above learned to support .NET SDK-style project files ( ) for C# projects. See the target property and corresponding variable. is not yet supported in .NET SDK-style projects.\n• None The Visual Studio Generators for VS 2017 and above learned to use portable instances of Visual Studio not known to the VS installer. See the variable.\n• None The command, when used with Visual Studio Generators on projects that set the target property, now automatically restores package references from NuGet. The cache variable may be set to toggle this behavior in a build tree. Use the command-line option to control the behavior on one invocation.\n• None The command line tool gained a option to enable debug messages under specific calls.\n• None The command line tool gained a option to enable debug messages for calls that use specific result variables.\n• None The command gained a new option to cause a target property to be initialized from a variable when a target is created.\n• None The command gained a new argument, which can be used to install header file sets associated with a target.\n• None The and commands now support the specifier for microseconds.\n• None The command gained a new mode, which can be used to add headers as header-only source files of a target.\n• None The variable and associated target property now support the , and values for CUDA toolkit 7.0+.\n• None The and variables were added to tell the , , , , and commands to ignore specified prefixes.\n• None The variable and corresponding target property were added to optionally require that all link items that can be target names are actually names of existing targets.\n• None The and read-only target properties were added to list header sets associated with a target.\n• None The and target properties were added to list files in the default header set and named header sets, respectively.\n• None The and target properties were added to specify the base directories of the default header set and named header sets, respectively.\n• None The target property was added to specify that an Imported Target should not be treated as a system library (i.e. its include directories are not automatically ).\n• None The target property was added to tell the generator what targets to put in the build phase.\n• None The target property and supporting variable were added to tell the generator to enable specifying the Xcode scheme option property .\n• None The module now supports the , , , and languages. It also now honors and .\n• None The module's command gained support for a option to give the patch step exclusive terminal access.\n• None The module now provides a target for , if found.\n• None The module now provides the result variable to conform with naming conventions documented in the manual. This supersedes the legacy variable.\n• None The module now provides a target for GMock, if found.\n• None The module now provides a result variable reporting the version number."
    },
    {
        "link": "https://cmake.org/cmake/help/latest/guide/tutorial/A%20Basic%20Starting%20Point.html",
        "document": "Where do I start with CMake? This step will provide an introduction to some of CMake's basic syntax, commands, and variables. As these concepts are introduced, we will work through three exercises and create a simple CMake project.\n\nEach exercise in this step will start with some background information. Then, a goal and list of helpful resources are provided. Each file in the section is in the directory and contains one or more comments. Each represents a line or two of code to change or add. The s are intended to be completed in numerical order, first complete then , etc. The section will give some helpful hints and guide you through the exercise. Then the section will walk step-by-step through how to build and test the exercise. Finally, at the end of each exercise the intended solution is discussed.\n\nAlso note that each step in the tutorial builds on the next. So, for example, the starting code for is the complete solution to .\n\nThe most basic CMake project is an executable built from a single source code file. For simple projects like this, a file with three commands is all that is required. Note: Although upper, lower and mixed case commands are supported by CMake, lower case commands are preferred and will be used throughout the tutorial. Any project's top most CMakeLists.txt must start by specifying a minimum CMake version using the command. This establishes policy settings and ensures that the following CMake functions are run with a compatible version of CMake. To start a project, we use the command to set the project name. This call is required with every project and should be called soon after . As we will see later, this command can also be used to specify other project level information such as the language or version number. Finally, the command tells CMake to create an executable using the specified source code files. The source code for is provided in the directory and can be used to compute the square root of a number. This file does not need to be edited in this step. In the same directory is a file which you will complete. Start with and work through . Once through have been completed, we are ready to build and run our project! First, run the executable or the to configure the project and then build it with your chosen build tool. For example, from the command line we could navigate to the directory of the CMake source code tree and create a build directory: Next, navigate to that build directory and run to configure the project and generate a native build system: Then call that build system to actually compile/link the project: For multi-config generators (e.g. Visual Studio), first navigate to the appropriate subdirectory, for example: Finally, try to use the newly built : Note: Depending on the shell, the correct syntax may be , or . For simplicity, the exercises will use throughout. As mentioned above, a three line is all that we need to get up and running. The first line is to use to set the CMake version as follows: The next step to make a basic project is to use the command as follows to set the project name: The last command to call for a basic project is . We call it as follows:\n\nExercise 2 - Specifying the C++ Standard¶ CMake has some special variables that are either created behind the scenes or have meaning to CMake when set by project code. Many of these variables start with . Avoid this naming convention when creating variables for your projects. Two of these special user settable variables are and . These may be used together to specify the C++ standard needed to build the project. Continue editing files in the directory. Start with and complete through . First, edit by adding a feature that requires C++11. Then update to require C++11. Let's build our project again. Since we already created a build directory and ran CMake for Exercise 1, we can skip to the build step: Now we can try to use the newly built with same commands as before: We start by adding some C++11 features to our project by replacing with in . This looks like the following: We will need to explicitly state in the CMake code that it should use the correct flags. One way to enable support for a specific C++ standard in CMake is by using the variable. For this tutorial, set the variable in the file to and to . Make sure to add the declarations above the call to .\n\nSometimes it may be useful to have a variable that is defined in your file also be available in your source code. In this case, we would like to print the project version. One way to accomplish this is by using a configured header file. We create an input file with one or more variables to replace. These variables have special syntax which looks like . Then, we use the command to copy the input file to a given output file and replace these variables with the current value of in the file. While we could edit the version directly in the source code, using this feature is preferred since it creates a single source of truth and avoids duplication. Continue to edit files from . Start on and complete through . In this exercise, we start by adding a project version number in . In that same file, use to copy a given input file to an output file and substitute some variable values in the input file content. Next, create an input header file defining version numbers which will accept variables passed from . Finally, update to print out its version number. Let's build our project again. As before, we already created a build directory and ran CMake so we can skip to the build step: Verify that the version number is now reported when running the executable without any arguments. In this exercise, we improve our executable by printing a version number. While we could do this exclusively in the source code, using lets us maintain a single source of data for the version number. First, we modify the file to use the command to set both the project name and version number. When the command is called, CMake defines and behind the scenes. Then we used to copy the input file with the specified CMake variables replaced: Since the configured file will be written into the project binary directory, we must add that directory to the list of paths to search for include files. Note: Throughout this tutorial, we will refer to the project build and the project binary directory interchangeably. These are the same and are not meant to refer to a directory. We used to specify where the executable target should look for include files. is the input header file to be configured. When is called from our , the values for and will be replaced with the corresponding version numbers from the project in . // the configured options and settings for Tutorial Next, we need to modify to include the configured header file, . Finally, we print out the executable name and version number by updating as follows:"
    },
    {
        "link": "http://cmake.org.cn/manual/cmake.1.html",
        "document": "The cmake executable is the command-line interface of the cross-platform buildsystem generator CMake. The above Synopsis lists various actions the tool can perform as described in sections below. To build a software project with CMake, Generate a Project Buildsystem. Optionally use cmake to Build a Project, Install a Project or just run the corresponding build tool (e.g. ) directly. cmake can also be used to View Help. The other actions are meant for use by software developers writing scripts in the to support their builds. For graphical user interfaces that may be used in place of cmake, see and . For command-line interfaces to the CMake testing and packaging facilities, see and . For more information on CMake at large, see also the links at the end of this manual.\n\nA buildsystem describes how to build a project's executables and libraries from its source code using a build tool to automate the process. For example, a buildsystem may be a for use with a command-line tool or a project file for an Integrated Development Environment (IDE). In order to avoid maintaining multiple such buildsystems, a project may specify its buildsystem abstractly using files written in the . From these files CMake generates a preferred buildsystem locally for each user through a backend called a generator. To generate a buildsystem with CMake, the following must be selected: The top-level directory containing source files provided by the project. The project specifies its buildsystem using files as described in the manual, starting with a top-level file named . These files specify build targets and their dependencies as described in the manual. The top-level directory in which buildsystem files and build output artifacts (e.g. executables and libraries) are to be stored. CMake will write a file to identify the directory as a build tree and store persistent information such as buildsystem configuration options. To maintain a pristine source tree, perform an out-of-source build by using a separate dedicated build tree. An in-source build in which the build tree is placed in the same directory as the source tree is also supported, but discouraged. This chooses the kind of buildsystem to generate. See the manual for documentation of all generators. Run to see a list of generators available locally. Optionally use the option below to specify a generator, or simply accept the default CMake chooses for the current platform. When using one of the Command-Line Build Tool Generators CMake expects that the environment needed by the compiler toolchain is already configured in the shell. When using one of the IDE Build Tool Generators, no particular environment is needed.\n\nRun CMake with one of the following command signatures to specify the source and build trees and generate a buildsystem: Uses the current working directory as the build tree, and as the source tree. The specified path may be absolute or relative to the current working directory. The source tree must contain a file and must not contain a file because the latter identifies an existing build tree. For example: Uses as the build tree, and loads the path to the source tree from its file, which must have already been generated by a previous run of CMake. The specified path may be absolute or relative to the current working directory. For example: Uses as the build tree and as the source tree. The specified paths may be absolute or relative to the current working directory. The source tree must contain a file. The build tree will be created automatically if it does not already exist. For example: In all cases the may be zero or more of the Options below. The above styles for specifying the source and build trees may be mixed. Paths specified with or are always classified as source or build trees, respectively. Paths specified with plain arguments are classified based on their content and the types of paths given earlier. If only one type of path is given, the current working directory (cwd) is used for the other. For example: Changed in version 3.23: CMake warns when multiple source paths are specified. This has never been officially documented or supported, but older versions accidentally accepted multiple source paths and used the last path specified. Avoid passing multiple source path arguments. After generating a buildsystem one may use the corresponding native build tool to build the project. For example, after using the generator one may run directly: Alternatively, one may use cmake to Build a Project by automatically choosing and invoking the appropriate native build tool. Path to root directory of the CMake project to build. Path to directory which CMake will use as the root of build directory. If the directory doesn't already exist CMake will make it. When CMake is first run in an empty build tree, it creates a file and populates it with customizable settings for the project. This option may be used to specify a file from which to load cache entries before the first pass through the project's CMake listfiles. The loaded entries take priority over the project's default values. The given file should be a CMake script containing commands that use the option, not a cache-format file. References to and within the script evaluate to the top-level source and build tree. When CMake is first run in an empty build tree, it creates a file and populates it with customizable settings for the project. This option may be used to specify a setting that takes priority over the project's default value. The option may be repeated for as many entries as desired. If the portion is given it must be one of the types specified by the command documentation for its signature. If the portion is omitted the entry will be created with no type if it does not exist with a type already. If a command in the project sets the type to or then the will be converted to an absolute path. This option may also be given as a single argument: or . This option may be used to remove one or more variables from the file, globbing expressions using and are supported. The option may be repeated for as many entries as desired. Use with care, you can make your non-working. CMake may support multiple native build systems on certain platforms. A generator is responsible for generating a particular build system. Possible generator names are specified in the manual. If not specified, CMake checks the environment variable and otherwise falls back to a builtin default selection. Toolset specification for the generator, if supported. Some CMake generators support a toolset specification to tell the native build system how to choose a compiler. See the variable for details. Specify platform name if supported by generator. Some CMake generators support a platform name to be given to the native build system to choose a compiler or SDK. See the variable for details. Specify the cross compiling toolchain file, equivalent to setting variable. Specify the installation directory, used by the variable. Must be an absolute path. Suppress warnings that are meant for the author of the files. By default this will also turn off deprecation warnings. Enable warnings that are meant for the author of the files. By default this will also turn on deprecation warnings. Make warnings that are meant for the author of the files errors. By default this will also turn on deprecated warnings as errors. Make warnings that are meant for the author of the files not errors. By default this will also turn off deprecated warnings as errors. Enable warnings for usage of deprecated functionality, that are meant for the author of the files. Suppress warnings for usage of deprecated functionality, that are meant for the author of the files. Make warnings for usage of deprecated macros and functions, that are meant for the author of the files, errors. Make warnings for usage of deprecated macros and functions, that are meant for the author of the files, not errors. List variables will run CMake and list all the variables from the CMake that are not marked as or . This will effectively display current CMake settings, which can then be changed with option. Changing some of the variables may result in more variables being created. If is specified, then it will display also advanced variables. If is specified, it will also display help for each variable. Only load the cache. Do not actually run configure and generate steps. Generate graphviz of dependencies, see for more. Generate a graphviz input file that will contain all the library and executable dependencies in the project. See the documentation for for more details. Dump a wide range of information about the current system. If run from the top of a binary tree for a CMake project it will dump additional information such as the cache, log files etc. The command will only output messages of the specified log level or higher. The default log level is . To make a log level persist between CMake runs, set as a cache variable instead. If both the command line option and the variable are given, the command line option takes precedence. For backward compatibility reasons, is also accepted as a synonym for this option. Enable the command outputting context attached to each message. This option turns on showing context for the current CMake run only. To make showing the context persistent for all subsequent CMake runs, set as a cache variable instead. When this command line option is given, is ignored. Do not delete the build tree. Only useful on one at a time. Do not delete the files and directories created for calls. This is useful in debugging failed try_compiles. It may however change the results of the try-compiles as old junk from a previous try-compile may cause a different test to either pass or fail incorrectly. This option is best used for one try-compile at a time, and only when debugging. Print extra information during the cmake run like stack traces with calls. Print extra find call information during the cmake run to standard error. Output is designed for human consumption and not for parsing. See also the variable for debugging a more local part of the project. Put cmake find commands in a debug mode when running under calls to , where is an entry in the given comma-separated list of case-sensitive package names. Like , but limiting scope to the specified packages. Put cmake find commands in a debug mode when called with as the result variable, where is an entry in the given comma-separated list. Like , but limiting scope to the specified variable names. Print a trace of all calls made and from where. Like , but with variables expanded. Put cmake in trace mode and sets the trace output format. can be one of the following values. Prints each trace line in a human-readable format. This is the default format. Prints each line as a separate JSON document. Each document is separated by a newline ( ). It is guaranteed that no newline characters will be present inside a JSON document. The full path to the CMake source file where the function was called. The line in of the function call. Optional member that is present when the function call was deferred by . If present, its value is a string containing the deferred call . The name of the function that was called. Timestamp (seconds since epoch) of the function call. Stack frame depth of the function that was called. Additionally, the first JSON document outputted contains the key for the current major and minor version of the Indicates the version of the JSON format. The version has a major and minor components following semantic version conventions. Put cmake in trace mode, but output only lines of a specified file. Put cmake in trace mode and redirect trace output to a file instead of stderr. Print a warning when an uninitialized variable is used. Does nothing. In CMake versions 3.2 and below this enabled warnings about unused variables. In CMake versions 3.3 through 3.18 the option was broken. In CMake 3.19 and above the option has been removed. Don't find variables that are declared on the command line, but not used. Normally, unused and uninitialized variables are searched for only in and . This flag tells CMake to warn about other files as well. Used in conjunction with to output to a given path. Enable the output of profiling data of CMake script in the given format. This can aid performance analysis of CMake scripts executed. Third party applications should be used to process the output into human readable format. Currently supported values are: Outputs in Google Trace Format, which can be parsed by the about:tracing tab of Google Chrome or using a plugin for a tool like Trace Compass. Reads a from and . The preset may specify the generator and the build directory, and a list of variables and other arguments to pass to CMake. The current working directory must contain CMake preset files. The can also recognize and files. For full details on these files, see . The presets are read before all other command line options. The options specified by the preset (variables, generator, etc.) can all be overridden by manually specifying them on the command line. For example, if the preset sets a variable called to , but the user sets it to with a argument, the value is preferred. Lists the available presets. If no option is specified only configure presets will be listed. The current working directory must contain CMake preset files.\n\nCMake provides a command-line signature to build an already-generated project binary tree: This abstracts a native build tool's command-line interface with the following options: Project binary directory to be built. This is required (unless a preset is specified) and must be first. Use a build preset to specify build options. The project binary directory is inferred from the key. The current working directory must contain CMake preset files. See for more details. Lists the available build presets. The current working directory must contain CMake preset files. The maximum number of concurrent processes to use when building. If is omitted the native build tool's default number is used. The environment variable, if set, specifies a default parallel level when this option is not given. Some native build tools always build in parallel. The use of value of can be used to limit to a single job. Build instead of the default target. Multiple targets may be given, separated by spaces. Build target first, then build. (To clean only, use .) Resolve remote package references from external package managers (e.g. NuGet) before build. When set to (default), packages will be restored before building a target. When set to , the packages will be restored, but no build will be performed. When set to , no packages will be restored. If the target does not define any package references, this option does nothing. This setting can be specified in a build preset (using ). The preset setting will be ignored, if this command line option is specified. If no command line parameter or preset option are provided, an environment- specific cache variable will be evaluated to decide, if package restoration should be performed. When using the Visual Studio generator, package references are defined using the property. Package references are restored using NuGet. It can be disabled by setting the variable to . Ignored. Behavior is default in CMake >= 3.0. Enable verbose output - if supported - including the build commands to be executed. This option can be omitted if environment variable or cached variable is set. Run with no options for quick help.\n\nCMake provides builtin command-line tools through the signature Run or for a summary of commands. Available commands are: Report cmake capabilities in JSON format. The output is a JSON object with the following keys: The full version string as displayed by cmake . A bool that is set if the cmake build is from a dirty tree. A list available generators. Each generator is a JSON object with the following keys: A string containing the name of the generator. if the generator supports toolsets and otherwise. if the generator supports platforms and otherwise. Optional member that may be present when the generator supports platform specification via ( ). The value is a list of platforms known to be supported. A list of strings with all the extra generators compatible with the generator. Optional member that is present when the is available. The value is a JSON object with one member: A JSON array containing zero or more supported file-api requests. Each request is a JSON object with members: Specifies one of the supported Object Kinds. A JSON array whose elements are each a JSON object containing and members specifying non-negative integer version components. if cmake supports server-mode and otherwise. Always false since CMake 3.20. Concatenate files and print on the standard output. Check if is same as . If files are the same, then returns , if not it returns . In case of invalid arguments, it returns 2. New in version 3.14: The option implies line-wise comparison and ignores LF/CRLF differences. Copy files to (either file or directory). If multiple files are specified, the must be directory and it must exist. Wildcards are not supported. does follow symlinks. That means it does not copy symlinks, but the files or directories it point to. New in version 3.5: Support for multiple input files. Copy content of directories to directory. If directory does not exist it will be created. does follow symlinks. New in version 3.5: Support for multiple input directories. New in version 3.15: The command now fails when the source directory does not exist. Previously it succeeded by creating an empty destination directory. Copy files to (either file or directory) if they have changed. If multiple files are specified, the must be directory and it must exist. does follow symlinks. New in version 3.5: Support for multiple input files. New in version 3.13: Support for creating symlinks on Windows. Path to where symbolic link will be created has to exist beforehand. Path to where hard link will be created has to exist beforehand. has to exist beforehand. Displays arguments as text but no new line. Do nothing, with an exit code of 1. Create directories. If necessary, create parent directories too. If a directory already exists it will be silently ignored. New in version 3.5: Support for multiple input directories. Remove the file(s). The planned behavior was that if any of the listed files already do not exist, the command returns a non-zero exit code, but no message is logged. The option changes the behavior to return a zero exit code (i.e. success) in such situations instead. does not follow symlinks. That means it remove only symlinks and not files it point to. The implementation was buggy and always returned 0. It cannot be fixed without breaking backwards compatibility. Use instead. Remove directories and their contents. If a directory does not exist it will be silently ignored. Use instead. New in version 3.15: Support for multiple directories. New in version 3.16: If is a symlink to a directory, just the symlink will be removed. Rename a file or directory (on one volume). If file with the name already exists, then it will be silently replaced. Use or to remove directories and their contents recursively. If any of the listed files/directories do not exist, the command returns a non-zero exit code, but no message is logged. The option changes the behavior to return a zero exit code (i.e. success) in such situations instead. Sleep for given number of seconds. Create or extract a tar or zip archive. Options are: Create a new archive containing the specified files. If used, the argument is mandatory. Extract to disk from the archive. New in version 3.15: The argument could be used to extract only selected files or directories. When extracting selected files or directories, you must provide their exact names including the path, as printed by list ( ). New in version 3.15: The argument could be used to list only selected files or directories. Read file names from the given file, one per line. Blank lines are ignored. Lines may not start in except for to add files whose names start in . Specify the format of the archive to be created. Supported formats are: , , , (restricted pax, default), and . Stop interpreting options and treat all remaining arguments as file names, even if they start with . New in version 3.15: The command now continues adding files to an archive even if some of the files are not readable. This behavior is more consistent with the classic tool. The command now also parses all flags, and if an invalid flag was provided, a warning is issued. New in version 3.5: The command now properly passes arguments with spaces or special characters through to the child process. This may break scripts that worked around the bug with their own extra quoting or escaping. Creates if file do not exist. If exists, it is changing access and modification times. Touch a file if it exists but do not create it. If a file does not exist it will be silently ignored. Do nothing, with an exit code of 0.\n\nTo print selected pages from the CMake documentation, use with one of the following options: Usage describes the basic command line interface and its options. If a file is specified, the version is written into it. The help is printed to a named <f>ile if given. Print all help manuals and exit. All manuals are printed in a human-readable text format. The help is printed to a named <f>ile if given. Print one help manual and exit. The specified manual is printed in a human-readable text format. The help is printed to a named <f>ile if given. List help manuals available and exit. The list contains all manuals for which help may be obtained by using the option followed by a manual name. The help is printed to a named <f>ile if given. Print help for one command and exit. The manual entry for is printed in a human-readable text format. The help is printed to a named <f>ile if given. List commands with help available and exit. The list contains all commands for which help may be obtained by using the option followed by a command name. The help is printed to a named <f>ile if given. The manual is printed in a human-readable text format. The help is printed to a named <f>ile if given. Print help for one module and exit. The manual entry for is printed in a human-readable text format. The help is printed to a named <f>ile if given. List modules with help available and exit. The list contains all modules for which help may be obtained by using the option followed by a module name. The help is printed to a named <f>ile if given. The manual is printed in a human-readable text format. The help is printed to a named <f>ile if given. Print help for one policy and exit. The manual entry for is printed in a human-readable text format. The help is printed to a named <f>ile if given. List policies with help available and exit. The list contains all policies for which help may be obtained by using the option followed by a policy name. The help is printed to a named <f>ile if given. The manual is printed in a human-readable text format. The help is printed to a named <f>ile if given. Print help for one property and exit. The manual entries for are printed in a human-readable text format. The help is printed to a named <f>ile if given. List properties with help available and exit. The list contains all properties for which help may be obtained by using the option followed by a property name. The help is printed to a named <f>ile if given. The manual is printed in a human-readable text format. The help is printed to a named <f>ile if given. Print help for one variable and exit. The manual entry for is printed in a human-readable text format. The help is printed to a named <f>ile if given. List variables with help available and exit. The list contains all variables for which help may be obtained by using the option followed by a variable name. The help is printed to a named <f>ile if given. The manual is printed in a human-readable text format. The help is printed to a named <f>ile if given. To view the presets available for a project, use"
    },
    {
        "link": "https://discourse.cmake.org/t/cmake-project-initialization/6756",
        "document": "I want CMake to have a project initializer to start quickly, similar to xmake or cargo init - The Cargo Book. The advantage for new users is they don’t have to deal with CMake files. One of the goals is to provide a very simple project to get a project going. I don’t want this command to support hundreds of use cases, it would be minimalist, simple and easy to maintain.\n\nThe suggested user interface can look something like this:\n\nThe user didn’t have to create/manipulate any CMake files or learn the syntax. The new command will provide a minimalist CMake project initializer, and it will set up a new project ready to be compiled.\n\nIf we compare this to the current way, without any external help from 3rd party tools it looks something like this:\n\nThere are 3rd party tools that can provide project initializers for CMake. Here is an example: cmake-init · PyPI. One issue that I see with those tools is that you need to install something else to get started with CMake. If a user requires something more complex or an enterprise template, I think that should be a 3rd party tool.\n\nCMake is a meta-build system. If I want a project generator, maybe I should use a different tool?"
    },
    {
        "link": "https://cmake.org/cmake/help/latest/guide/tutorial/index.html",
        "document": "The CMake tutorial provides a step-by-step guide that covers common build system issues that CMake helps address. Seeing how various topics all work together in an example project can be very helpful.\n\nThe tutorial source code examples are available in . Each step has its own subdirectory containing code that may be used as a starting point. The tutorial examples are progressive so that each step provides the complete solution for the previous step."
    },
    {
        "link": "https://reddit.com/r/cpp/comments/12dssrl/best_practice_for_cpp_projects_using_cmake",
        "document": "There are many open source application and some of them have common structure, ./src folder and ./include folder. I don't know how to structure it, how to start, to not regret later.\n\nMy question is: what is the best practice for stucturing you project? any sources to learn from?\n\nThank you in advance"
    },
    {
        "link": "https://cmake.org/cmake/help/latest/guide/tutorial/Installing%20and%20Testing.html",
        "document": "Often, it is not enough to only build an executable, it should also be installable. With CMake, we can specify install rules using the command. Supporting local installations for your builds in CMake is often as simple as specifying an install location and the targets and files to be installed. Install the executable and the library. The starting code is provided in the directory. In this exercise, complete through . First, update to install the and libraries to the directory. In that same file, specify the install rules needed to install to the directory. Then, update the top level to install the executable to the directory. Lastly, any header files should be installed to the directory. Remember that is in the . Make a new directory called . Run the executable or the to configure the project and then build it with your chosen build tool. Then, run the install step by using the option of the command (introduced in 3.15, older versions of CMake must use ) from the command line. This step will install the appropriate header files, libraries, and executables. For example: For multi-configuration tools, don't forget to use the argument to specify the configuration. If using an IDE, simply build the target. You can build the same install target from the command line like the following: The CMake variable is used to determine the root of where the files will be installed. If using the command, the installation prefix can be overridden via the argument. For example: Navigate to the install directory and verify that the installed runs. The install rules for our project are fairly simple:\n• None For , we want to install the libraries and header file to the and directories respectively.\n• None For the executable, we want to install the executable and configured header file to the and directories respectively. So to the end of we add: The install rules for the executable and configured header file are similar. To the end of the top-level we add: That is all that is needed to create a basic local install of the tutorial.\n\nCTest offers a way to easily manage tests for your project. Tests can be added through the command. Although it is not explicitly covered in this tutorial, there is a lot of compatibility between CTest and other testing frameworks such as . Create unit tests for our executable using CTest. The starting source code is provided in the directory. In this exercise, complete through . First, we need to enable testing. Next, begin adding tests to our project using . We will work through adding 3 simple tests and then you can add additional testing as you see fit. Navigate to the build directory and rebuild the application. Then, run the ctest executable: and . For multi-config generators (e.g. Visual Studio), the configuration type must be specified with the flag. For example, to run tests in Debug mode use from the build directory (not the Debug subdirectory!). Release mode would be executed from the same location but with a . Alternatively, build the target from the IDE. Let's test our application. At the end of the top-level file we first need to enable testing with the command. With testing enabled, we will add a number of basic tests to verify that the application is working correctly. First, we create a test using which runs the executable with the parameter 25 passed in. For this test, we are not going to check the executable's computed answer. This test will verify that application runs, does not segfault or otherwise crash, and has a zero return value. This is the basic form of a CTest test. Next, let's use the test property to verify that the output of the test contains certain strings. In this case, verifying that the usage message is printed when an incorrect number of arguments are provided. The next test we will add verifies the computed value is truly the square root. This one test is not enough to give us confidence that it will work for all values passed in. We should add more tests to verify this. To easily add more tests, we make a function called that runs the application and verifies that the computed square root is correct for given input. For each invocation of , another test is added to the project with a name, input, and expected results based on the passed arguments."
    },
    {
        "link": "https://stackoverflow.com/questions/54271925/how-to-configure-cmakelists-txt-to-install-public-headers-of-a-shared-library",
        "document": "CMake cannot deduce the set of header files to be installed from the target. This makes sense, as the target may contain both private and public header files, but CMake does not differentiate between those. As a consequence, you have to list the header files explicitly in an command:\n\nUpdate for CMake 3.23 and later:\n\nCMake version 3.23 introduced File Sets, which allow handling header files in a more elegant way. This way header files only need to be listed once in the to get both integrated in the IDE and also installed correctly:\n\nThe field that you stumbled upon is related to the OSX framework mechanism, which is its very own can of worms. I suggest you stay clear of it, unless you actually want to deploy your library as a on OSX.\n\nTake special note of the option to the command. While this does not actually copy any files itself, it allows the include directory to be added to the imported target provided by the config package script automatically. If you intend to provide a package config script to your users (which you probably should, at least if you expect your users to also use CMake), you probably want to set this option.\n\nSince the install mechanism is quite complicated overall, I have a small github project of mine where you can observe all the elements in action."
    },
    {
        "link": "https://github.com/cpp-best-practices/gui_starter_template/blob/main/CMakeLists.txt",
        "document": "# so that it behaves well with MSVC's debugger, and we can run the target from visual studio\n\n# Add other targets that you want installed here, be default we just package the one executable"
    }
]