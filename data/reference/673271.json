[
    {
        "link": "https://wiki.libsdl.org/SDL2/SDL_Surface",
        "document": "A collection of pixels used in software blitting.\n\n/** Application data associated with the surface */ /** list of BlitMap that hold a reference to this surface */ /** info for fast blit mapping to other surfaces */\n\nThis structure should be treated as read-only, except for , which, if not NULL, contains the raw pixel data for the surface."
    },
    {
        "link": "https://stackoverflow.com/questions/77472045/why-use-sdl-surface-over-sdl-texture",
        "document": "I understand that SDL_Textures are rendered by the GPU, whilst SDL_Surfaces are rendered by the CPU. However, I don't understand why SDL_Surfaces would be used at all, given that SDL_Textures are apparently faster than SDL_Surfaces.\n\nIf possible, can anyone explain reasons why SDL_Surfaces are better than SDL_Textures (if any) or provide situations where SDL_Surfaces are better than SDL_Textures (if any)?"
    },
    {
        "link": "https://discourse.libsdl.org/t/sdl-2-26-not-rendering-on-macos/40842",
        "document": "I have used SDL for projects previously without trouble, but currently I am trying to build a couple projects from the command line using SDL 2.26, on Monterey and now on Ventura. The projects build successfully, but when run, they mostly produce blank black windows. Printing error messages shows that most drawing operations are yielding the message “invalid renderer.” In almost all cases, it says I’m using an OpenGL renderer, regardless of which API I ask for; I have not been able to get it to use Vulkan or Metal, and the failure to draw affects both the renderer and surface APIs. I have confirmed that the same code works normally on Windows. I appreciate any avenues for finding a way to correct this.\n\nSo the reason your drawing operations are returning “invalid renderer” is most likely because the renderer isn’t being successfully created. You need to make sure isn’t returning . What does say when it does return ? Secondly, what specifically are you passing to ? I’m not having any trouble creating a renderer and drawing things with SDL 2.26 on macOS 13 Ventura. It would be helpful if you posted your code that creates the window and renderer.\n\nYou definitely need to actually check return values. The value returned by can only be used if the last SDL function call returned an error. It’s just there to provide more information about why an error was returned; if the last SDL call succeeded then it doesn’t tell you anything meaningful. The SDL docs for specifically say: The message is only applicable when an SDL function has signaled an error. You must check the return values of SDL function calls to determine when to appropriately call SDL_GetError(). You should not use the results of SDL_GetError() to decide if an error has occurred! Sometimes SDL will set an error string even when reporting success. SDL will not clear the error string for successful API calls. You must check return values for failure cases before you can assume the error string applies. So, check to make sure window creation succeeded before creating the renderer, make sure renderer creation succeeded, and check to make sure your draw call succeeded. Only if they fail should you print Also, because of this, you don’t need to call . Just check function return values. edit: And another thing: you don’t need to pass to when creating the window unless you’re planning on creating a Vulkan context yourself and doing your own drawing with it. has no Vulkan backend.\n\nThe VULKAN flag is a holdover from me trying to find some way to get the renderer to obtain a driver other than opengl, which it sounds like you’re saying won’t happen. So, the documentation says that SDL might generate the “invalid renderer” message even when generating a valid renderer, and that as long as it returns a renderer, that message is to be ignored. If I am supposed to accept that the renderer is valid, why doesn’t it draw the rectangle? That said, thank you for your responses so far.\n\nThe VULKAN flag is a holdover from me trying to find some way to get the renderer to obtain a driver other than opengl, which it sounds like you’re saying won’t happen. On macOS, you should be getting the Metal backend. You can find out with this: So, the documentation says that SDL might generate the “invalid renderer” message even when generating a valid renderer, and that as long as it returns a renderer, that message is to be ignored. Yes. Because isn’t there to tell you if an error occurred. It’s only there to tell you what the error was if an SDL call fails. If I am supposed to accept that the renderer is valid, why doesn’t it draw the rectangle? Something I noticed: your sample code calls to clear the screen, but doesn’t call it again before drawing the rectangle, so it’s drawing a rectangle that’s the same color as your clear color. However, if you change the draw color and it isn’t working (or that’s just an oversight from copy/pasting from real code for the sample code) check the return value of and if it really is failing then call to see what the problem is.\n\nSadly, it wasn’t anything that simple. There was a SetDrawColor in the original code that got lost. Still doesn’t show up. I’ve added the renderer name request. This is the code as I ran it minus some of the boilerplate: (The forum seems to be taking umbrage to some of the pastebin links now, but the previous link still works.) As far as I can tell, I’m requesting Metal and getting OpenGL.\n\nAre you setting any hints? What do you get if, right after calling , you insert the line You can post formatted code here, using 3 backticks (not apostrophes) on their own line to start a code block, and three more on their own line to end it. This code works on my system (2018 Mac Mini, Intel, macOS 13 Ventura): #include <stdio.h> #include <stdlib.h> #include <string.h> #include <SDL2/SDL.h> #define SCREEN_WIDTH 800 #define SCREEN_HEIGHT 600 int main(int argc, char **argv) { if(SDL_Init(SDL_INIT_VIDEO) < 0) { fprintf(stderr, \"ERROR: %s\n\n\", SDL_GetError()); return EXIT_FAILURE; } SDL_LogSetAllPriority(SDL_LOG_PRIORITY_VERBOSE); SDL_Window *window = SDL_CreateWindow(\"Test\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, 0); if(window == NULL) { fprintf(stderr, \"ERROR: can't create window: %s\n\n\", SDL_GetError()); return EXIT_FAILURE; } SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC); if(renderer == NULL) { fprintf(stderr, \"ERROR: can't create renderer: %s\n\n\", SDL_GetError()); return EXIT_FAILURE; } // The above call to SDL_LogSetAllPriority() should make SDL print which backend was used when // creating the renderer, but do it ourselves anyway. SDL_RendererInfo info; SDL_GetRendererInfo(renderer, &info); printf(\"Renderer backend: %s\n\n\", info.name); int running = 1; while(running) { SDL_Event event; while(SDL_PollEvent(&event)) { switch(event.type) { case SDL_QUIT: running = 0; break; } } SDL_SetRenderDrawColor(renderer, 128, 196, 255, 255); SDL_RenderClear(renderer); SDL_Rect rect = { 20, 20, SCREEN_WIDTH - 40, SCREEN_HEIGHT - 40 }; SDL_SetRenderDrawColor(renderer, 255, 196, 128, 255); SDL_RenderFillRect(renderer, &rect); SDL_RenderPresent(renderer); } SDL_Quit(); return EXIT_SUCCESS; } Gives the following output"
    },
    {
        "link": "https://reddit.com/r/Python/comments/cgaovr/sdl2_where_are_my_sdl_surface_and_sdl_texture",
        "document": ""
    },
    {
        "link": "https://lazyfoo.net/tutorials/SDL/07_texture_loading_and_rendering/index.php",
        "document": "A major new addition to SDL 2 is the texture rendering API. This gives you fast, flexible hardware based rendering. In this tutorial we'll be using this new rendering technique. A major new addition to SDL 2 is the texture rendering API. This gives you fast, flexible hardware based rendering. In this tutorial we'll be using this new rendering technique.\n\n\n\n \n\n As you can also see we have a new image loading routine with loadTexture and a globally declared texture we're going to load. Textures in SDL have their own data type intuitively called an SDL_Texture . When we deal with SDL textures you need an SDL_Renderer to render it to the screen which is why we declare a global renderer named \"gRenderer\".As you can also see we have a new image loading routine with loadTexture and a globally declared texture we're going to load.\n\n\n\n \n\n After creating the renderer, we want to initialize the rendering color using After we create our window, we have to create a renderer for our window so we can render textures on it. Fortunately this is easily done with a call to SDL_CreateRenderer After creating the renderer, we want to initialize the rendering color using SDL_SetRenderDrawColor . This controls what color is used for various rendering operations.\n\nOur texture loading function looks largely the same as before only now instead of converting the loaded surface to the display format, we create a texture from the loaded surface using SDL_CreateTextureFromSurface . Like before, this function creates a new texture from an existing surface which means like before we have to free the loaded surface and then return the loaded texture.\n\n\n\n \n\n In our clean up function, we have to remember to deallocate our textures using Since texture loading is abstracted with our image loading function, the loadMedia() function works pretty much the same as before.In our clean up function, we have to remember to deallocate our textures using SDL_DestroyTexture\n\n\n\n \n\n With the screen cleared, we render the texture with \n\n \n\n Now, there is a new API call called IMG_LoadTexture. It's not in the official documentation as of this writing but you can find it in the SDL_image header files. It allows you to load a texture without having to create a temporary surface. The reason I haven't gone back and updated the tutorial to use this method is because I don't want to go back an update 40+ tutorials. Even though it is undocumented, it works just fine.\n\n \n\n I recommend giving it a try. Also, get used to having to deal with undocumented code because often times in the professional game development world, documentation is a luxury. In the main loop after the event loop, we call SDL_RenderClear . This function fills the screen with the color that was last set with SDL_SetRenderDrawColor.With the screen cleared, we render the texture with SDL_RenderCopy . With the texture rendered, we still have to update the screen, but since we're not using SDL_Surfaces to render we can't use SDL_UpdateWindowSurface. Instead we have to use SDL_RenderPresent Now, there is a new API call called IMG_LoadTexture. It's not in the official documentation as of this writing but you can find it in the SDL_image header files. It allows you to load a texture without having to create a temporary surface. The reason I haven't gone back and updated the tutorial to use this method is because I don't want to go back an update 40+ tutorials. Even though it is undocumented, it works just fine.I recommend giving it a try. Also, get used to having to deal with undocumented code because often times in the professional game development world, documentation is a luxury."
    },
    {
        "link": "https://reddit.com/r/gamedev/comments/m6d592/c_with_sdl_20_are_there_any_references_on_how_to",
        "document": "I've been wanting to make my first game as an exercise to get better at programming and so I decided to try and make a 2D top down spaceship game in \"pure\" C++ using SDL 2 as my only help to only have abstraction on the things that either require silicon level access or that Windows likes to prevent you from doing directly.\n\nI've come to the conclusion that while I do know how C++ works and SDL2 is pretty well documented I'm having trouble properly dissecting the problem at hand and planning out an approach.\n\nI have no idea how I should organise the headers and sources, for example, or what should be a fully fledged class with long constructors and destructors for the sake of future proofing as opposed to three lines of code in the main loop.\n\nHave you ever had problems actually planning out a larger piece of software like this? How did you solve them?"
    },
    {
        "link": "https://reddit.com/r/gamedev/comments/2eb5d8/copenglsdl_game_engine_tutorials_for_an_absolute",
        "document": "Hey guys! I am the lead developer for Seed Of Andromeda, and over the past two months I have been working on a C++/Game development series for an absolute beginner to programming.\n\nI first started working on Seed Of Andromeda two years ago with little to no knowledge of OpenGL, software engineering, or game development. It started as a hobby but slowly grew into something with potential. Now the team has grown from one to fourteen, and the engine is turning into something truly amazing.\n\nI have always had an extreme aptitude for teaching others. Nothing brings me more pleasure than to see someone else making use of the knowledge they have gained through my effort, and for that reason I decided to create a series of free tutorials to help others follow a path to programming and game development.\n\nThe purpose of these tutorials is to attract non-programmers into the technical field of programming, by leading along the interesting path of game development. The beginner C++/Game tutorials are aimed at those who have little to no programming experience , but the later tutorials become more complicated and always build on concepts that have already been taught explicitly in previous tutorials.\n\nMost of the tutorials tie the programming concepts to game development by showing practical applications for the concepts, rather than just teaching the bare minimum and moving on.\n\nThese videos are intended to explain every step of the programming process. The are very deep in their content, and I take care to explain basic concepts so that even younger programmers can understand. The pace of the videos is quick, so that more experienced programmers don't have to sit through incredibly long explanation videos, but concepts are not glossed over. If you have any questions or confusions, you need only comment on the videos and I or another programmer will help you through your bugs or provide a more in depth explanation :)\n\nEvery 6 or so tutorials, there is a challenge episode. These episodes are designed to give the viewer incentive to actually use what they have learned. They will construct a small game using what they have learned in the previous tutorials, according to a specific challenge that I outline. I provide hints at the beginning of the video, and then go on to finish the challenge myself line by line, explaining as I go so that no-one is left behind.\n\nI encourage you all to upload video responses to the challenge episodes, that walk through the code of your creations. I will link my favorite viewer games in the descriptions of the videos :)\n\nSo far there are two tutorial series. The first series is the C++/Game Tutorial Series. This series is designed to bring programming noobs up to speed with the basics of C++. In this series you will make several small ascii games, and you will learn useful concepts such as variables, functions, classes, polymorphism, static functions, binary code, and more!\n\nThe second tutorial series is the Advanced C++/Graphics Tutorials. In this series we will be making a simple game engine in C++/SDL/OpenGL, which will be capable of rendering in 2D or 3D. Rather than making a bunch of disconnected graphics tutorials, I chose to simply build a game engine. Each video will add a new component to the engine, or will teach you advanced CS concepts that will help you in the creation of your games. At the end of the tutorial series, you should be able to use your new custom made engine to make simple games, and you should have the knowledge to extend it yourself!\n\nAs the game engine is fleshed out, the challenge videos will become more interesting! For instance, one challenge may be to make a barebones turn based strategy using the 2D rendering utilities you have created! And of course, I will walk though the process step by step if you get stuck.\n\nThe end goal of these two series is to prepare the user to make their own voxel engine. In the third tutorial series we will make a voxel engine in C++/OpenGL/SDL. It is likely that I will teach you how to implement many of the features found in Seed Of Andromeda. Once you have reached these tutorials, you should be fully capable of developing and releasing your own games, and you should have the knowledge to learn any programming language that you want with ease.\n\nI hope you all will find these tutorials beneficial, and I encourage you to share it with any people who seem to have an interest in game development. I am always trying to improve the content of my videos, so please post your suggestions and comments!\n\nTLDR: Go here and learn to make games :)\n\nEdit: Thanks for supporting reddit with your delicious gold doubloon! If you need me, I'll be in r/lounge."
    },
    {
        "link": "https://stackoverflow.com/questions/8857376/organization-of-code-for-a-game-using-sdl",
        "document": "I've been using SDL for some days now, and I decided after following some tutorials to start developing my own clone of Galaga. However, I had some difficulty trying to find a proper layout for my code.\n\nFor example, I have a Spaceship class defined as follows:\n\nwhere Sprite is a base class that holds the position on the screen and so on. My constructor would be something like:\n\nFrom what I've seen it's not possible to use Game::screenWidth() [static class] because I'd need to include \"game.h\", which is basically the main game class and includes \"spaceship.h\", creating basically an infinite loop (I've tried using #ifndef etc. with no success).\n\nIs it possible to achieve this kind of result?\n\nEDIT: I found a way to overcome the problem (I just added the \"game.h\" include in the cpp file and not in the header file)."
    },
    {
        "link": "https://discourse.libsdl.org/t/performance-tricks/6685",
        "document": "you could always use SDL_GetKeyState and SDL_GetModState… …which goes through the same mechanism, and having to iterate over each\n\n keystate is going to be slower on top of that. I come from an era that used \"short\" instead of \"int\" when we could get away with it to save stack space, and had to be extremely nervous about \"function call overhead\", and even I don't think the event subsystem is slow. I come from an era that used \"short\" instead of \"int\" when we could get away with it to save stack space, and had to be extremely nervous about \"function call overhead\", and even I don't think the event subsystem is slow. In an age of dual CPUs and gigabytes of RAM, are we really going to bust\n\n our balls over this interface? Most big commercial game engines I’ve seen\n\n probably spend four times as long in unnecessary copy constructors as they\n\n do handling input events, and no one considers them inefficient.\n\n\n\nI come from an era that used \"short\" instead of \"int\" when we could get away with it to save stack space, and had to be extremely nervous about \"function call overhead\", and even I don't think the event subsystem is slow. In an age of dual CPUs and gigabytes of RAM, are we really going to bust\n\n our balls over this interface? Most big commercial game engines I’ve seen\n\n probably spend four times as long in unnecessary copy constructors as they\n\n do handling input events, and no one considers them inefficient. Indeed, we routinely do things which are slower than SDL’s event loop that\n\n we know are inefficient because it’s that or have extremely ugly code. I\n\n came from 1MHz machines, so I’ve learned to avoid floats at all costs and\n\n use bytes for anything that does not absolutely need more… My box has 512 megs, and even the average machine comes with at least 128\n\n megs. My CPU is 800MHz and takes 22 cycles for a 64 bit sqrt instruction.\n\n While the average person has a CPU about half that speed and which takes\n\n far longer to do anything significant with even a 32 bit float (I feel\n\n sorry for you people dumb enough to buy Intel these days!). the fact is\n\n that we no longer live in a world where every byte is precious - even in\n\n the game industry. Actually, I should say especially in the game industry. (ooh, my turn\n\n on the soapbox for the newbies on the list!) The old hacks to squeeze\n\n every last drop of performance out of the machines which made games\n\n essentially unreadable black voodoo are going the way of the dodo fast\n\n because people don’t want to work with that kind of crappy code! Because they tend to release their source code after a few years, a good\n\n example of what I mean can be found in Id Software. Look at the code for\n\n Wolf3D or Doom sometime. I have, and I can tell you it’s disgusting. On\n\n the other hand, Quake 2 is fairly elegant code (for its time) and I happen\n\n to know that Quake 3’s code could almost be called clean in many places,\n\n especially the renderer. Doom 3 is expected to be better still. There’s\n\n not one company today in the gaming industry or any other for that matter\n\n where sloppy code leads to job security, so get that idea out of your head\n\n right now. My experience has led me to the following rules of game programming, which\n\n often apply to many other types of programming as well:\n• Do what works best and makes for the most legible code. Everyone else\n\n who ever has to read it will want to thank you. Failure to do this\n\n will result in them wanting to shoot you instead.\n• Don’t try to out-optimize the optimizer! Back when Quake was written,\n\n Michael Abrash carefully hand-tuned several essential parts of the\n\n Quake renderer in i586 assembly. Parts of this were still used with\n\n OpenGL - but the first thing I did with Project Twilight was remove\n\n it for a speed gain! If your code’s not fast enough after you’ve\n\n written it, then you can try to tweak things to be more optimized.\n• Don’t make spaghetti code. Spaghetti is no fun unless you can eat the\n\n consiquences, after all. Divide your code by functional blocks and\n\n keep those blocks seperate. We probably all understand that in a game\n\n global variables are a near necessity, but not every variable needs to\n\n be global and even if they do, they don’t all need to be exported to\n\n other modules. Anything you don’t know needs to be public should be\n\n static, and you should be reluctant to change that.\n• Don’t extern things in files. Quake did this in several places and\n\n even in Project Twilight still does. This has proven to be nothing\n\n but a headache for us. Find the right header to put a thing into. If\n\n it doesn’t exist, create it! Don’t use extern for special case things\n\n that shouldn’t be public (but aren’t static either) as is done in many\n\n commercial games. It will bite you in the ass later on.\n• Classes aren’t everything! Yes, when you learned C++, you learned all\n\n about classes, inheritance, and maybe even multiple inheritance.\n\n These are all great things (with the possible exception of multiple\n\n inheritance which is abused more than used), but you would be\n\n surprised how little they benefit most parts of game programming. I\n\n am not saying they don’t have their uses in games - our Neither engine\n\n will use C++ specifically because we want classes and inheritance for\n\n all the cool things they are made so perfectly for. Use the right\n\n type of code for the right type of problem. There is absolutely\n\n nothing wrong with procedural code in C++, even alongside classes,\n\n methods, and inheritance. Naturally these are all meta-ideas. While I could give examples of things\n\n done both the right way and the wrong way in games (and in other types of\n\n programs too), the best advice I can really give is to use your head and\n\n not make things any more complicated than they’ve got to be. It’s too\n\n easy with games to code yourself into a corner compared with other types\n\n of programs. If you’re careful to avoid that, suddenly everything starts\n\n to seem easier. And then you discover linear algebra, the joy of vector and matrix math,\n\n and lose what vestiges of your sanity remained. =) If you survive this,\n\n you may make it into an industry job where you work too long for too\n\n little pay. =p If you’re really lucky, you don’t wind up at the next\n\n company which ends as Loki and countless other game companies have. Well,\n\n okay, Loki ended a bit worse than most, but that’s even further off topic\n\n and a touchy subject for many former employees, so … Okay, newbie lesson over, Ryan can have his soapbox back now. =)On Tue, May 21, 2002 at 04:00:45AM -0400, Ryan C. Gordon wrote:\n• knghtbrd can already envision: “Subject: [INTENT TO PREPARE TO PROPOSE\n\n FILING OF BUG REPORT] Typos in the policy document” -------------- next part --------------\n\n A non-text attachment was scrubbed…\n\n Name: not available\n\n Type: application/pgp-signature\n\n Size: 273 bytes\n\n Desc: not available\n\n URL: http://lists.libsdl.org/pipermail/sdl-libsdl.org/attachments/20020521/0033f990/attachment.pgp\n\nwhere can I find some stuffs about how to make my games more ‘speddy’\n\n in SDL?\n\n I’m interested in video and input stuffs.\n\n (like, converting from xx bpp to surface bpp will increase blitsurface\n\n speed) Someone should dedicate a web site to this… heh We’re discussing this sort of stuff on the list every now and then, and\n\n indeed, there are some important SDL related things to keep in mind, but\n\n the most important stuff isn’t really SDL related. To get real speed, regardless of API, you need to figure out how your\n\n particular problem is best solved from a hardware POV, and then figure\n\n out how to do it with whatever API you decide to use. Because of the complexity (and occasionally braindead design) of PC\n\n hardware, there isn’t a single “best way” to do things. Many games will\n\n appear to work best with two or more methods at once, which usually means\n\n that you’ll end up with some sort of compromize. For example, on most targets, opaque and colorkeyed blits are best done\n\n with everything in VRAM, using h/w acceleration - but as soon as you\n\n start doing software rendering, or alpha blending, VRAM is the worst\n\n place to work in! Where the surfaces are best placed depends on the\n\n balance between normal and alpha blits, and which platform you’re on. In\n\n some cases, you might have to support two or three different methods of\n\n rendering to get maximum performance on all targets. Another question: I see that SDL keyboard input is ‘message’ based, but\n\n this I think is too slow in comparation with DirectInput (for example). “message” here does not mean “message, as implemented by Microsoft on top\n\n of a kernel with serious task switching problems”. We are talking about a thread safe message queue, but it has nothing to\n\n do with whatever a “message” might be on whatever platform you’re using.\n\n AFAIK, the SDL message queue is implemented on top of the fastest and\n\n lowest level synchronization objects provided by each platform, and as\n\n such, it should be pretty much as fast as it gets on each platform. BTW, the new audio engine of Kobo Deluxe is using “messages” (events)\n\n internally, all the way into the voice mixers. Sending an event means\n\n that you grab a fixed size struct from a preallocated pool and add it to\n\n a linked list. There are no system calls involved, and sending/receiving\n\n these “messages” costs very little. In fact, switching to an “event based\n\n design” has made it possible to make the engine a lot more flexible and\n\n accurate, without adding significant overhead. Some things are actually a\n\n lot more effecient this way, since a lot of “explicit context switches”\n\n can be avoided. In short, if a “message” based system is slow, it’s either because of a\n\n bad implementation, or because of the synchronization constructs (needed\n\n for thread safe implementations) of the OS are slow. Any improvement in the future? .- M A I A -------------------------------------------------.\n\n | Multimedia Application Integration Architecture |\n\n | A Free/Open Source Plugin API for Professional Multimedia |\n\n -------------------------------------> http://olofson.net -'On Tuesday 21 May 2002 09:31, user at domain.invalid wrote:\n\nWell, provided you have a playable frame rate, an FPS player should be\n\n quite happy if the input response time is in the range of the duration of\n\n one frame. That said, it seems like at least on Linux, SDL’s keyboard input is quite\n\n a bit faster than that. Using it to trigger sound effects (played by an\n\n engine with ~5 ms latency), the average response time seem to be on par\n\n with that of professional MIDI gear. No perceptible latency, that is.\n\n (This is on standard Linux kernels; not anything with real time patches\n\n and stuff.) My qualified guess would be that the average keyboard latency (say 99% of\n\n keyboard events) is way below 10 ms - and I would believe that’s the case\n\n on most platforms. .- M A I A -------------------------------------------------.\n\n | Multimedia Application Integration Architecture |\n\n | A Free/Open Source Plugin API for Professional Multimedia |\n\n -------------------------------------> http://olofson.net -'On Tuesday 21 May 2002 08:33, Ryan C. Gordon wrote: Another question: I see that SDL keyboard input is ‘message’ based,\n\n but this I think is too slow in comparation with DirectInput (for\n\n example). Any improvement in the future? It’s fast enough, unless your on some really REALLY low end embedded\n\n device, in which case you shouldn’t be coding to an abstraction layer. Seriously. It’s good enough for first person shooters, it’s good enough\n\n for anything. The real SDL bottlenecks are almost always video output.\n\nEven so, new and malloc() (which includes copy constructors) in the\n\n game loop still makes me nervous… Wouldn’t that also cause memory fragmentation? Provided you have a decent suballocator (usually part of the runtime lib)\n\n and sane allocation patterns, it shouldn’t be much of a problem - but\n\n unfortunately, it’s impossible to design a memory manager that works\n\n great for all applications. On my machine that is a real performance killer. Well, if you get fragmentation, two things may happen; 1) The memory manager will burn more cycles merging adjacent memory blocks. 2) The brk limit will start running away. Although that (hopefully) means that there are unused pages \"in the middle\" that can be swapped out, this still means that you have to talk to the virtual memory manager - which is where you risk getting into *real* timing problems. 3) And of course, as soon as you touch the memory manager at all (fragmentation or not), you risk hitting brk, and consequently, all of the above. In short, this is hairy stuff, and it behaves in very different ways on\n\n different OSes, so the easiest and safest way to avoid trouble is to\n\n simply stay away from it. Do what most memory hungry games do; allocate a\n\n big pool of memory, and use your own memory manager. Note that you’ll usually benefit from using a deterministic memory\n\n manager, rather than a “fast” memory manager! “Fast” just means “fast\n\n most of the time” - which implies that it may occasionally take several\n\n times longer to run. Still, this is insignificant next to the impact of\n\n messing with the virtual memory subsystem. .- M A I A -------------------------------------------------.\n\n | Multimedia Application Integration Architecture |\n\n | A Free/Open Source Plugin API for Professional Multimedia |\n\n -------------------------------------> http://olofson.net -'On Wednesday 22 May 2002 04:05, David Moffatt wrote:"
    },
    {
        "link": "https://discourse.libsdl.org/t/intermediate-level-game-development/17200",
        "document": "The Annchienta Engine is a free, open source isometric RPG engine written in C++."
    },
    {
        "link": "https://pysdl2.readthedocs.io/en/latest/modules/sdl2_sdlimage.html",
        "document": "py-sdl2 provides bindings for SDL2_image, a library designed for use with SDL2 that adds support for loading a wide range of different common (and uncommon) image formats for easy use with SDL2. In addition, SDL2_image includes functions for saving objects to PNG and/or JPEG images.\n\nFor a list of supported image formats, see the documentation.\n\nCalling this function enables support for the JPEG, PNG, TIF, WebP, JPEG XL, and/or AVIF image formats as requested by the init flags. All other image formats can be loaded or used regardless of whether this has been called. The following init flags are supported: This can be called multiple times to enable support for these formats separately, or can initialize multiple formats at once by passing a set of flags as a bitwise OR. You can also call this function with 0 as a flag to check which image libraries have already been loaded, or to test whether a given image format is available on the current system: # Initialize JPEG and PNG support at the same time AVIF and JPEG XL support are not included in the official SDL_image binaries, and are likewise not enabled on most Linux distributions. flags (int) – A bitwise OR’d set of the flags of the image formats to load support for. A bitmask of all the currently initialized image loaders. Calling this function disables JPEG, PNG, TIF, and WEBP support and frees all associated memory. Once this has been called, you can re-initialize support for those image formats using and the corresponding init flags. You only need to call this function once, no matter how many times was called. Returns the most recently encountered SDL2 error message, if any. This function is a simple wrapper around . Sets the most recent SDL2 error message to a given string. This function is a simple wrapper around . fmt (bytes) – A UTF-8 encoded string containing the error message to set. Gets the version of the dynamically-linked SDL_image library. A pointer to a structure containing the version of the SDL_image library currently in use.\n\nThese functions are used to check whether an SDL file object ( ) is a valid image file of a given format. Note that all of these functions will return 0 if SDL2_image was not built with support for that format, even if it is a valid image of that type, so be cautious when using these for formats like WEBP, AVIF, JXL, and TIFF, which are optional when building SDL2_image. Tests whether a file object contains an AVIF image. 1 if AVIFs are supported and file is a valid AVIF, otherwise 0. Tests whether a file object contains an ICO (Windows icon) image. 1 if BMPs are supported and file is a valid ICO, otherwise 0. 1 if BMPs are supported and file is a valid CUR, otherwise 0. 1 if BMPs are supported and file is a valid BMP, otherwise 0. 1 if GIFs are supported and file is a valid GIF, otherwise 0. 1 if JPEGs are supported and file is a valid JPEG, otherwise 0. 1 if JPEG XL is supported and file is a valid JXL, otherwise 0. Tests whether a file object contains an LBM (Interleaved Bitmap) image. 1 if LBMs are supported and file is a valid LBM, otherwise 0. 1 if PCXs are supported and file is a valid PCX, otherwise 0. 1 if PNGs are supported and file is a valid PNG, otherwise 0. 1 if PNMs are supported and file is a valid PNM, otherwise 0. Tests whether a file object contains an SVG image. 1 if SVGs are supported and file is a valid SVG, otherwise 0. 1 if QOI is supported and file is a valid QOI, otherwise 0. 1 if TIFFs are supported and file is a valid TIFF, otherwise 0. Tests whether a file object contains an XCF (native GIMP format) image. XCF support is currently missing in official macOS binaries 1 if XCFs are supported and file is a valid XCF, otherwise 0. Tests whether a file object contains an XPM (X11 Pixmap) image. 1 if XPMs are supported and file is a valid XPM, otherwise 0. Tests whether a file object contains an XV (XV Visual Schnauzer) image. 1 if XVs are supported and file is a valid XV, otherwise 0. 1 if WebPs are supported and file is a valid WebP, otherwise 0.\n\nLoads an image file to a new surface. This can load all supported image files, including TGA as long as the filename ends with “.tga”. It is best to call this outside of event loops and keep the loaded images around until you are really done with them, as disk speed and image conversion to a surface can be slow. Once you are done with a loaded image, you can call on the returned surface pointer to free up the memory associated with it. If the image format supports a transparent pixel, SDL_image will set the colorkey for the surface. You can enable RLE acceleration on the surface afterwards by calling: If the loader for the image’s format requires initialization (e.g. PNG) and it is not already initialized, this function will attempt to load it automatically. file (bytes) – A UTF8-encoded bytestring containing the path to the image file to load. A pointer to the new surface containing the image, or a null pointer if there was an error. Loads an image file from an SDL file object to a new surface. This can load all supported formats, except TGA. See for more information.\n• src ( ) – The file object from which to load the image.\n• freesrc (int) – If non-zero, the input file object will be closed and freed after it has been read. A pointer to the new surface containing the image, or a null pointer if there was an error. Loads an image file from an SDL file object as a specific format. This function allows you to explicitly specify the format type of the image to load. Here are the different possible image format strings: Note that loading QOI, JXL, and AVIF images requires SDL_image 2.6.0 or newer. See for more information.\n• src ( ) – The file object from which to load the image.\n• freesrc (int) – If non-zero, the input file object will be closed and freed after it has been read.\n• type (bytes) – A bytestring indicating the image format with which the file object should be loaded. A pointer to the new surface containing the image, or a null pointer if there was an error. Loads an image file to a new texture using a given renderer. This function can load all supported image files, including TGA as long as the filename ends with “.tga”. It is best to call this outside of event loops and keep the loaded images around until you are really done with them, as disk speed and image conversion to a texture can be slow. Once you are done with a loaded image, you can call on the returned texture pointer to free up the memory associated with it. If the image loader for the format of the given image requires initialization (e.g. PNG) and it is not already initialized, this function will attempt to load it automatically.\n• renderer ( ) – The SDL rendering context with which to create the texture.\n• file (bytes) – A UTF8-encoded bytestring containing the path to the image file to load. A pointer to the new texture containing the image, or a null pointer if there was an error. Loads an image from a file object to a texture using a given renderer. This function can load all supported formats, except TGA. See for more information.\n• renderer ( ) – The SDL rendering context with which to create the texture.\n• src ( ) – The file object from which to load the image.\n• freesrc (int) – If non-zero, the input file object will be closed and freed after it has been read. A pointer to the new texture containing the image, or a null pointer if there was an error. Loads an image file from a file object to a texture as a specific format. This function allows you to explicitly specify the format type of the image to load. The different possible format strings are listed in the documentation for . See for more information.\n• renderer ( ) – The SDL rendering context with which to create the texture.\n• src ( ) – The file object from which to load the image.\n• freesrc (int) – If non-zero, the input file object will be closed and freed after it has been read.\n• type (bytes) – A bytestring indicating the image format with which the file object should be loaded. A pointer to the new texture containing the image, or a null pointer if there was an error.\n\nLoads an AVIF image from an SDL file object. Use the function to check for any errors. src ( ) – The file object from which to load the AVIF. A pointer to a new surface containing the image, or if there was an error. Loads an ICO (Windows icon) image from an SDL file object. Use the function to check for any errors. src ( ) – The file object from which to load the ICO. A pointer to a new surface containing the image, or if there was an error. Use the function to check for any errors. src ( ) – The file object from which to load the CUR. A pointer to a new surface containing the image, or if there was an error. Use the function to check for any errors. src ( ) – The file object from which to load the BMP. A pointer to a new surface containing the image, or if there was an error. Use the function to check for any errors. src ( ) – The file object from which to load the GIF. A pointer to a new surface containing the image, or if there was an error. Use the function to check for any errors. src ( ) – The file object from which to load the JPEG. A pointer to a new surface containing the image, or if there was an error. Use the function to check for any errors. src ( ) – The file object from which to load the JPEG XL. A pointer to a new surface containing the image, or if there was an error. Loads an LBM (Interleaved Bitmap) image from an SDL file object. Use the function to check for any errors. src ( ) – The file object from which to load the LBM. A pointer to a new surface containing the image, or if there was an error. Use the function to check for any errors. src ( ) – The file object from which to load the PCX. A pointer to a new surface containing the image, or if there was an error. Use the function to check for any errors. src ( ) – The file object from which to load the PNG. A pointer to a new surface containing the image, or if there was an error. Use the function to check for any errors. src ( ) – The file object from which to load the PNM. A pointer to a new surface containing the image, or if there was an error. Loads an SVG image from an SDL file object. Note that this function only loads SVGs at their self-reported resolutions. To load an SVG at an arbitrary resolution, see . Use the function to check for any errors. src ( ) – The file object from which to load the SVG. A pointer to a new surface containing the image, or if there was an error. Loads an SVG image at a given size from an SDL file object. Use the function to check for any errors. src ( ) – The file object from which to load the SVG. A pointer to a new surface containing the image, or if there was an error. Use the function to check for any errors. src ( ) – The file object from which to load the QOI. A pointer to a new surface containing the image, or if there was an error. Use the function to check for any errors. src ( ) – The file object from which to load the TGA. A pointer to a new surface containing the image, or if there was an error. Use the function to check for any errors. src ( ) – The file object from which to load the TIFF. A pointer to a new surface containing the image, or if there was an error. Loads an TIFF (native GIMP format) image from an SDL file object. Use the function to check for any errors. src ( ) – The file object from which to load the XCF. A pointer to a new surface containing the image, or if there was an error. Loads an XPM (X11 Pixmap) image from an SDL file object. Use the function to check for any errors. src ( ) – The file object from which to load the XPM. A pointer to a new surface containing the image, or if there was an error. Loads an XV thumbnail (XV Visual Schnauzer) from an SDL file object. Use the function to check for any errors. src ( ) – The file object from which to load the XV. A pointer to a new surface containing the image, or if there was an error. Use the function to check for any errors. src ( ) – The file object from which to load the WebP. A pointer to a new surface containing the image, or if there was an error. Loads an X11 Pixmap from an array to a new surface. The XPM format consists of a C header with an array of strings defining the dimensions, colors, and pixels of a pixel art image: this is the data format that this function expects to be passed. The input string for this function must be cast to a (pointer to a character array) and passed by reference using . Note that this function will return an 8-bit indexed (palette) surface when possible. To obtain a 32-bit RGB surface from an XPM array, use the function. A pointer to a new surface containing the image, or if there was an error. Loads an X11 Pixmap from an array to a new 32-bit surface. This function is the same as except that it always returns a 32-bit ARGB surface. A pointer to a new surface containing the image, or if there was an error.\n\nThis should work regardless of whether PNG support was successfully initialized with , but the full set of PNG features may not be available.\n• surface ( ) – The surface to be saved to PNG.\n• file (bytes) – A UTF-8 encoded bytestring containing the path at which to save the PNG. 0 on success or a negative error code on failure, can call for more information. Saves an SDL surface to a file object containing a PNG. See for more information.\n• surface ( ) – The surface to be saved to PNG.\n• dst ( ) – The destination file object for the saved PNG.\n• freedst (int) – If non-zero, the destination file object will be closed once the PNG has been written. 0 on success or a negative error code on failure, can call for more information. Saves an SDL surface to a JPEG file at a given quality. JPEG support must be already initialized using before this function can be used. Otherwise, this function will fail without an explicit error that can be retrieved with . JPEG saving was not supported in the official libsdl.org macOS binaries until SDL_image 2.6.0.\n• surface ( ) – The surface to be saved to JPEG.\n• file (bytes) – A UTF-8 encoded bytestring containing the path at which to save the PNG.\n• quality (int) – The compression level of the saved JPEG, from 1 (lowest quality) to 100 (highest quality). 0 on success or a negative error code on failure, can call for more information. Saves an SDL surface to a file object containing a JPEG. As of SDL_image 2.0.5, JPEG saving is not supported by the official libsdl.org macOS binaries.\n• surface ( ) – The surface to be saved to JPEG.\n• file (bytes) – A UTF-8 encoded bytestring containing the path at which to save the PNG.\n• quality (int) – The compression level of the saved JPEG, from 1 (lowest quality) to 100 (highest quality). 0 on success or a negative error code on failure, can call for more information.\n\nA structure containing the frame data for an animation. When working with this data structure in Python, you need to be careful not to access an out-of-range frame or delay number to avoid illegal memory access problems. To convert the animation data to a more Pythonic format, you can do something similar to the example below: # Load frames/delays from the IMG_Animation structure to lists Note that even if you copy the frame surfaces into a Python list, the pixel data will still be stored within the animation object. As such, you cannot call on an object until you are fully done with its data. The width (in pixels) of the animation. The height (in pixels) of the animation. The number of frames in the animation. An array of pointers (of length ) to the SDL surfaces for the frames of the animation. An array (of length ) containing the delays (in milliseconds) between each frame in the animation. For more information on how to work with imported animations, see the documentation. As of SDL_image 2.6.0, this currently only supports GIF animations. file (bytes) – A UTF8-encoded bytestring containing the path to the animation file to load. A pointer to an animation object, or a null pointer if there was an error. Loads an animated image from an SDL file object. For more information on how to work with imported animations, see the documentation. As of SDL_image 2.6.0, this currently only supports GIF animations.\n• src ( ) – The file object from which to load the animation.\n• freesrc (int) – If non-zero, the input file object will be closed and freed after it has been read. A pointer to an animation object, or a null pointer if there was an error. Loads an animated image from an SDL file object as a specific format. For more information on how to work with imported animations, see the documentation. As of SDL_image 2.6.0, the only supported animation type is .\n• src ( ) – The file object from which to load the animation.\n• freesrc (int) – If non-zero, the input file object will be closed and freed after it has been read.\n• type (bytes) – A bytestring indicating the animation format with which the file object should be loaded. A pointer to an animation object, or a null pointer if there was an error. For more information on how to work with imported animations, see the documentation. Use the function to check for any errors. src ( ) – The file object from which to load the GIF. A pointer to an animation object, or a a null pointer if there was an error. Closes and frees the memory associated with a given animation. This function should be called on an animation after you are done with it. An and its frame data cannot be used after it has been closed."
    },
    {
        "link": "https://pysdl2.readthedocs.io/en/stable/modules/sdl2_sdlimage.html",
        "document": "py-sdl2 provides bindings for SDL2_image, a library designed for use with SDL2 that adds support for loading a wide range of different common (and uncommon) image formats for easy use with SDL2. In addition, SDL2_image includes functions for saving objects to PNG and/or JPEG images.\n\nFor a list of supported image formats, see the documentation.\n\nCalling this function enables support for the JPEG, PNG, TIF, WebP, JPEG XL, and/or AVIF image formats as requested by the init flags. All other image formats can be loaded or used regardless of whether this has been called. The following init flags are supported: This can be called multiple times to enable support for these formats separately, or can initialize multiple formats at once by passing a set of flags as a bitwise OR. You can also call this function with 0 as a flag to check which image libraries have already been loaded, or to test whether a given image format is available on the current system: # Initialize JPEG and PNG support at the same time AVIF and JPEG XL support are not included in the official SDL_image binaries, and are likewise not enabled on most Linux distributions. flags (int) – A bitwise OR’d set of the flags of the image formats to load support for. A bitmask of all the currently initialized image loaders. Calling this function disables JPEG, PNG, TIF, and WEBP support and frees all associated memory. Once this has been called, you can re-initialize support for those image formats using and the corresponding init flags. You only need to call this function once, no matter how many times was called. Returns the most recently encountered SDL2 error message, if any. This function is a simple wrapper around . Sets the most recent SDL2 error message to a given string. This function is a simple wrapper around . fmt (bytes) – A UTF-8 encoded string containing the error message to set. Gets the version of the dynamically-linked SDL_image library. A pointer to a structure containing the version of the SDL_image library currently in use.\n\nThese functions are used to check whether an SDL file object ( ) is a valid image file of a given format. Note that all of these functions will return 0 if SDL2_image was not built with support for that format, even if it is a valid image of that type, so be cautious when using these for formats like WEBP, AVIF, JXL, and TIFF, which are optional when building SDL2_image. Tests whether a file object contains an AVIF image. 1 if AVIFs are supported and file is a valid AVIF, otherwise 0. Tests whether a file object contains an ICO (Windows icon) image. 1 if BMPs are supported and file is a valid ICO, otherwise 0. 1 if BMPs are supported and file is a valid CUR, otherwise 0. 1 if BMPs are supported and file is a valid BMP, otherwise 0. 1 if GIFs are supported and file is a valid GIF, otherwise 0. 1 if JPEGs are supported and file is a valid JPEG, otherwise 0. 1 if JPEG XL is supported and file is a valid JXL, otherwise 0. Tests whether a file object contains an LBM (Interleaved Bitmap) image. 1 if LBMs are supported and file is a valid LBM, otherwise 0. 1 if PCXs are supported and file is a valid PCX, otherwise 0. 1 if PNGs are supported and file is a valid PNG, otherwise 0. 1 if PNMs are supported and file is a valid PNM, otherwise 0. Tests whether a file object contains an SVG image. 1 if SVGs are supported and file is a valid SVG, otherwise 0. 1 if QOI is supported and file is a valid QOI, otherwise 0. 1 if TIFFs are supported and file is a valid TIFF, otherwise 0. Tests whether a file object contains an XCF (native GIMP format) image. XCF support is currently missing in official macOS binaries 1 if XCFs are supported and file is a valid XCF, otherwise 0. Tests whether a file object contains an XPM (X11 Pixmap) image. 1 if XPMs are supported and file is a valid XPM, otherwise 0. Tests whether a file object contains an XV (XV Visual Schnauzer) image. 1 if XVs are supported and file is a valid XV, otherwise 0. 1 if WebPs are supported and file is a valid WebP, otherwise 0.\n\nLoads an image file to a new surface. This can load all supported image files, including TGA as long as the filename ends with “.tga”. It is best to call this outside of event loops and keep the loaded images around until you are really done with them, as disk speed and image conversion to a surface can be slow. Once you are done with a loaded image, you can call on the returned surface pointer to free up the memory associated with it. If the image format supports a transparent pixel, SDL_image will set the colorkey for the surface. You can enable RLE acceleration on the surface afterwards by calling: If the loader for the image’s format requires initialization (e.g. PNG) and it is not already initialized, this function will attempt to load it automatically. file (bytes) – A UTF8-encoded bytestring containing the path to the image file to load. A pointer to the new surface containing the image, or a null pointer if there was an error. Loads an image file from an SDL file object to a new surface. This can load all supported formats, except TGA. See for more information.\n• src ( ) – The file object from which to load the image.\n• freesrc (int) – If non-zero, the input file object will be closed and freed after it has been read. A pointer to the new surface containing the image, or a null pointer if there was an error. Loads an image file from an SDL file object as a specific format. This function allows you to explicitly specify the format type of the image to load. Here are the different possible image format strings: Note that loading QOI, JXL, and AVIF images requires SDL_image 2.6.0 or newer. See for more information.\n• src ( ) – The file object from which to load the image.\n• freesrc (int) – If non-zero, the input file object will be closed and freed after it has been read.\n• type (bytes) – A bytestring indicating the image format with which the file object should be loaded. A pointer to the new surface containing the image, or a null pointer if there was an error. Loads an image file to a new texture using a given renderer. This function can load all supported image files, including TGA as long as the filename ends with “.tga”. It is best to call this outside of event loops and keep the loaded images around until you are really done with them, as disk speed and image conversion to a texture can be slow. Once you are done with a loaded image, you can call on the returned texture pointer to free up the memory associated with it. If the image loader for the format of the given image requires initialization (e.g. PNG) and it is not already initialized, this function will attempt to load it automatically.\n• renderer ( ) – The SDL rendering context with which to create the texture.\n• file (bytes) – A UTF8-encoded bytestring containing the path to the image file to load. A pointer to the new texture containing the image, or a null pointer if there was an error. Loads an image from a file object to a texture using a given renderer. This function can load all supported formats, except TGA. See for more information.\n• renderer ( ) – The SDL rendering context with which to create the texture.\n• src ( ) – The file object from which to load the image.\n• freesrc (int) – If non-zero, the input file object will be closed and freed after it has been read. A pointer to the new texture containing the image, or a null pointer if there was an error. Loads an image file from a file object to a texture as a specific format. This function allows you to explicitly specify the format type of the image to load. The different possible format strings are listed in the documentation for . See for more information.\n• renderer ( ) – The SDL rendering context with which to create the texture.\n• src ( ) – The file object from which to load the image.\n• freesrc (int) – If non-zero, the input file object will be closed and freed after it has been read.\n• type (bytes) – A bytestring indicating the image format with which the file object should be loaded. A pointer to the new texture containing the image, or a null pointer if there was an error.\n\nLoads an AVIF image from an SDL file object. Use the function to check for any errors. src ( ) – The file object from which to load the AVIF. A pointer to a new surface containing the image, or if there was an error. Loads an ICO (Windows icon) image from an SDL file object. Use the function to check for any errors. src ( ) – The file object from which to load the ICO. A pointer to a new surface containing the image, or if there was an error. Use the function to check for any errors. src ( ) – The file object from which to load the CUR. A pointer to a new surface containing the image, or if there was an error. Use the function to check for any errors. src ( ) – The file object from which to load the BMP. A pointer to a new surface containing the image, or if there was an error. Use the function to check for any errors. src ( ) – The file object from which to load the GIF. A pointer to a new surface containing the image, or if there was an error. Use the function to check for any errors. src ( ) – The file object from which to load the JPEG. A pointer to a new surface containing the image, or if there was an error. Use the function to check for any errors. src ( ) – The file object from which to load the JPEG XL. A pointer to a new surface containing the image, or if there was an error. Loads an LBM (Interleaved Bitmap) image from an SDL file object. Use the function to check for any errors. src ( ) – The file object from which to load the LBM. A pointer to a new surface containing the image, or if there was an error. Use the function to check for any errors. src ( ) – The file object from which to load the PCX. A pointer to a new surface containing the image, or if there was an error. Use the function to check for any errors. src ( ) – The file object from which to load the PNG. A pointer to a new surface containing the image, or if there was an error. Use the function to check for any errors. src ( ) – The file object from which to load the PNM. A pointer to a new surface containing the image, or if there was an error. Loads an SVG image from an SDL file object. Note that this function only loads SVGs at their self-reported resolutions. To load an SVG at an arbitrary resolution, see . Use the function to check for any errors. src ( ) – The file object from which to load the SVG. A pointer to a new surface containing the image, or if there was an error. Loads an SVG image at a given size from an SDL file object. Use the function to check for any errors. src ( ) – The file object from which to load the SVG. A pointer to a new surface containing the image, or if there was an error. Use the function to check for any errors. src ( ) – The file object from which to load the QOI. A pointer to a new surface containing the image, or if there was an error. Use the function to check for any errors. src ( ) – The file object from which to load the TGA. A pointer to a new surface containing the image, or if there was an error. Use the function to check for any errors. src ( ) – The file object from which to load the TIFF. A pointer to a new surface containing the image, or if there was an error. Loads an TIFF (native GIMP format) image from an SDL file object. Use the function to check for any errors. src ( ) – The file object from which to load the XCF. A pointer to a new surface containing the image, or if there was an error. Loads an XPM (X11 Pixmap) image from an SDL file object. Use the function to check for any errors. src ( ) – The file object from which to load the XPM. A pointer to a new surface containing the image, or if there was an error. Loads an XV thumbnail (XV Visual Schnauzer) from an SDL file object. Use the function to check for any errors. src ( ) – The file object from which to load the XV. A pointer to a new surface containing the image, or if there was an error. Use the function to check for any errors. src ( ) – The file object from which to load the WebP. A pointer to a new surface containing the image, or if there was an error. Loads an X11 Pixmap from an array to a new surface. The XPM format consists of a C header with an array of strings defining the dimensions, colors, and pixels of a pixel art image: this is the data format that this function expects to be passed. The input string for this function must be cast to a (pointer to a character array) and passed by reference using . Note that this function will return an 8-bit indexed (palette) surface when possible. To obtain a 32-bit RGB surface from an XPM array, use the function. A pointer to a new surface containing the image, or if there was an error. Loads an X11 Pixmap from an array to a new 32-bit surface. This function is the same as except that it always returns a 32-bit ARGB surface. A pointer to a new surface containing the image, or if there was an error.\n\nThis should work regardless of whether PNG support was successfully initialized with , but the full set of PNG features may not be available.\n• surface ( ) – The surface to be saved to PNG.\n• file (bytes) – A UTF-8 encoded bytestring containing the path at which to save the PNG. 0 on success or a negative error code on failure, can call for more information. Saves an SDL surface to a file object containing a PNG. See for more information.\n• surface ( ) – The surface to be saved to PNG.\n• dst ( ) – The destination file object for the saved PNG.\n• freedst (int) – If non-zero, the destination file object will be closed once the PNG has been written. 0 on success or a negative error code on failure, can call for more information. Saves an SDL surface to a JPEG file at a given quality. JPEG support must be already initialized using before this function can be used. Otherwise, this function will fail without an explicit error that can be retrieved with . JPEG saving was not supported in the official libsdl.org macOS binaries until SDL_image 2.6.0.\n• surface ( ) – The surface to be saved to JPEG.\n• file (bytes) – A UTF-8 encoded bytestring containing the path at which to save the PNG.\n• quality (int) – The compression level of the saved JPEG, from 1 (lowest quality) to 100 (highest quality). 0 on success or a negative error code on failure, can call for more information. Saves an SDL surface to a file object containing a JPEG. As of SDL_image 2.0.5, JPEG saving is not supported by the official libsdl.org macOS binaries.\n• surface ( ) – The surface to be saved to JPEG.\n• file (bytes) – A UTF-8 encoded bytestring containing the path at which to save the PNG.\n• quality (int) – The compression level of the saved JPEG, from 1 (lowest quality) to 100 (highest quality). 0 on success or a negative error code on failure, can call for more information.\n\nA structure containing the frame data for an animation. When working with this data structure in Python, you need to be careful not to access an out-of-range frame or delay number to avoid illegal memory access problems. To convert the animation data to a more Pythonic format, you can do something similar to the example below: # Load frames/delays from the IMG_Animation structure to lists Note that even if you copy the frame surfaces into a Python list, the pixel data will still be stored within the animation object. As such, you cannot call on an object until you are fully done with its data. The width (in pixels) of the animation. The height (in pixels) of the animation. The number of frames in the animation. An array of pointers (of length ) to the SDL surfaces for the frames of the animation. An array (of length ) containing the delays (in milliseconds) between each frame in the animation. For more information on how to work with imported animations, see the documentation. As of SDL_image 2.6.0, this currently only supports GIF animations. file (bytes) – A UTF8-encoded bytestring containing the path to the animation file to load. A pointer to an animation object, or a null pointer if there was an error. Loads an animated image from an SDL file object. For more information on how to work with imported animations, see the documentation. As of SDL_image 2.6.0, this currently only supports GIF animations.\n• src ( ) – The file object from which to load the animation.\n• freesrc (int) – If non-zero, the input file object will be closed and freed after it has been read. A pointer to an animation object, or a null pointer if there was an error. Loads an animated image from an SDL file object as a specific format. For more information on how to work with imported animations, see the documentation. As of SDL_image 2.6.0, the only supported animation type is .\n• src ( ) – The file object from which to load the animation.\n• freesrc (int) – If non-zero, the input file object will be closed and freed after it has been read.\n• type (bytes) – A bytestring indicating the animation format with which the file object should be loaded. A pointer to an animation object, or a null pointer if there was an error. For more information on how to work with imported animations, see the documentation. Use the function to check for any errors. src ( ) – The file object from which to load the GIF. A pointer to an animation object, or a a null pointer if there was an error. Closes and frees the memory associated with a given animation. This function should be called on an animation after you are done with it. An and its frame data cannot be used after it has been closed."
    },
    {
        "link": "https://wiki.libsdl.org/SDL2_image/IMG_LoadTexture",
        "document": "Load an image from a filesystem path into a GPU texture.\n\n(SDL_Texture *) Returns a new texture, or NULL on error.\n\nAn SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render API. This can be significantly more efficient than using a CPU-bound SDL_Surface if you don't need to manipulate the image directly after loading it.\n\nIf the loaded image has transparency or a colorkey, a texture with an alpha channel will be created. Otherwise, SDL_image will attempt to create an SDL_Texture in the most format that most reasonably represents the image data (but in many cases, this will just end up being 32-bit RGB or 32-bit RGBA).\n\nThere is a separate function to read files from an SDL_RWops, if you need an i/o abstraction to provide data from anywhere instead of a simple filesystem read; that function is IMG_LoadTexture_RW().\n\nIf you would rather decode an image to an SDL_Surface (a buffer of pixels in CPU memory), call IMG_Load() instead.\n\nWhen done with the returned texture, the app should dispose of it with a call to SDL_DestroyTexture().\n\nThis function is available since SDL_image 2.0.0."
    },
    {
        "link": "https://stackoverflow.com/questions/74013539/sdl2-image-wont-load-textures-but-surfaces-work-and-i-dont-get-any-error-mes",
        "document": "i am making a game using SDL2, using IMG_LoadTexture() to load images, and it works fine on my main computer, but i recently acquired a new laptop, and the same code on this new machine won't load textures, but SDL doesn't give me any error message.\n• IMG_GetError() and SDL_GetError() give me nothing (which is weird, since IMG_LoadTexture() returning null means an error occured)\n• I work on msys2/mingw64 and launch the executable from the MSYS2/MINGW64 shell, checked for zlip and libpng, everything is here\n• Checked SDL initialization, returns 0 (no error), returns 3 (no error), same outputs as on the other computer where everything works.\n• Happens with all tested image formats (png, jpg, bmp)\n\ndoes anyone have any idea about what could be the cause of such a situation ? In the mingw install or something ?\n\nHere are the steps that led to the situation :\n• None Install msys from the official website\n• None install the following libraries using pacman :\n• #include \"SDL2/SDL.h\" #include \"SDL2/SDL_image.h\" #include \"SDL2/SDL_syswm.h\" #include <iostream> int main(int argc, char** argv){ int res = SDL_Init(SDL_INIT_VIDEO | SDL_INIT_JOYSTICK); std::cout << res << '\n\n'; if ( res < 0){ printf(\"Couldn't initialize SDL (%d): %s\n\n\", res, SDL_GetError()); exit(1); } res = IMG_Init(IMG_INIT_PNG | IMG_INIT_JPG); std::cout << res << '\n\n'; if (res < 0) { printf(\"Couldn't initialize SDL Image (%d): %s\n\n\", res, IMG_GetError()); exit(1); }; int rendererFlags = SDL_RENDERER_ACCELERATED; int windowFlags = 0; SDL_Window* window = SDL_CreateWindow(\"KuriX\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 800, 600, windowFlags); if (!window){ printf(\"Failed to open %d x %d window: %s\n\n\", 800, 600, SDL_GetError()); exit(1); } SDL_SysWMinfo win_info; SDL_VERSION(&win_info.version); SDL_GetWindowWMInfo(window, &win_info); SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, \"linear\"); SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, rendererFlags); if (!renderer){ printf(\"Failed to create renderer: %s\n\n\", SDL_GetError()); exit(1); } SDL_Texture* t = IMG_LoadTexture(renderer, \"JPGTest.jpg\"); std::cout << t << '\n\n'; if (t == NULL){ std::cerr << \"Error ! Message : \" << IMG_GetError() << '\n\n'; } return 0; }\n\nKeep in mind that the same code, using the same libraries, works fine on my main computer, and all previous computers i used previously. Something must have went wrong with the installation on the new laptop, but i just don't see what."
    },
    {
        "link": "https://github.com/veandco/go-sdl2/blob/master/img/sdl_image.go",
        "document": "// Init loads dynamic libraries and prepares them for use. Flags should be one or more flags from IMG_InitFlags OR'd together. It returns the flags successfully initialized, or 0 on failure.\n\n// LoadTypedRW loads an image from an SDL data source. The 'type' may be one of: \"BMP\", \"GIF\", \"PNG\", etc. If the image format supports a transparent pixel, SDL will set the colorkey for the surface."
    }
]