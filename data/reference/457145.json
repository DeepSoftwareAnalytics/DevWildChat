[
    {
        "link": "https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nHere is an example of a typical method declaration:\n\nThe only required elements of a method declaration are the method's return type, name, a pair of parentheses, , and a body between braces, .\n\nMore generally, method declarations have six components, in order:\n• Modifierssuch as , , and others you will learn about later.\n• The return typethe data type of the value returned by the method, or if the method does not return a value.\n• The method namethe rules for field names apply to method names as well, but the convention is a little different.\n• The parameter list in parenthesisa comma-delimited list of input parameters, preceded by their data types, enclosed by parentheses, . If there are no parameters, you must use empty parentheses.\n• An exception listto be discussed later.\n• The method body, enclosed between bracesthe method's code, including the declaration of local variables, goes here.\n\nModifiers, return types, and parameters will be discussed later in this lesson. Exceptions are discussed in a later lesson.\n\nDefinition: Two of the components of a method declaration comprise the method signaturethe method's name and the parameter types.\n\nThe signature of the method declared above is:\n\nAlthough a method name can be any legal identifier, code conventions restrict method names. By convention, method names should be a verb in lowercase or a multi-word name that begins with a verb in lowercase, followed by adjectives, nouns, etc. In multi-word names, the first letter of each of the second and following words should be capitalized. Here are some examples:\n\nTypically, a method has a unique name within its class. However, a method might have the same name as other methods due to method overloading.\n\nThe Java programming language supports overloading methods, and Java can distinguish between methods with different method signatures. This means that methods within a class can have the same name if they have different parameter lists (there are some qualifications to this that will be discussed in the lesson titled \"Interfaces and Inheritance\").\n\nSuppose that you have a class that can use calligraphy to draw various types of data (strings, integers, and so on) and that contains a method for drawing each data type. It is cumbersome to use a new name for each methodfor example, , , , and so on. In the Java programming language, you can use the same name for all the drawing methods but pass a different argument list to each method. Thus, the data drawing class might declare four methods named , each of which has a different parameter list.\n\nOverloaded methods are differentiated by the number and the type of the arguments passed into the method. In the code sample, and are distinct and unique methods because they require different argument types.\n\nYou cannot declare more than one method with the same name and the same number and type of arguments, because the compiler cannot tell them apart.\n\nThe compiler does not consider return type when differentiating methods, so you cannot declare two methods with the same signature even if they have a different return type.\n\nNote: Overloaded methods should be used sparingly, as they can make code much less readable."
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/java/javaOO/returnvalue.html",
        "document": "Trail: Learning the Java Language \n\nLesson: Classes and Objects \n\nSection: More on Classes\n\nThe Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nA method returns to the code that invoked it when it\n• completes all the statements in the method,\n\nYou declare a method's return type in its method declaration. Within the body of the method, you use the statement to return the value.\n\nAny method declared doesn't return a value. It does not need to contain a statement, but it may do so. In such a case, a statement can be used to branch out of a control flow block and exit the method and is simply used like this:\n\nIf you try to return a value from a method that is declared , you will get a compiler error.\n\nAny method that is not declared must contain a statement with a corresponding return value, like this:\n\nThe data type of the return value must match the method's declared return type; you can't return an integer value from a method declared to return a boolean.\n\nThe method in the class that was discussed in the sections on objects returns an integer:\n\nThis method returns the integer that the expression evaluates to.\n\nThe method returns a primitive type. A method can also return a reference type. For example, in a program to manipulate objects, we might have a method like this:\n\nIf this section confuses you, skip it and return to it after you have finished the lesson on interfaces and inheritance.\n\nWhen a method uses a class name as its return type, such as does, the class of the type of the returned object must be either a subclass of, or the exact class of, the return type. Suppose that you have a class hierarchy in which is a subclass of , which is in turn a subclass of , as illustrated in the following figure.\n\nNow suppose that you have a method declared to return a :\n\nThe method can return an but not an . is a because it's a subclass of . However, an is not necessarily a  it could be a or another type.\n\nYou can override a method and define it to return a subclass of the original method, like this:\n\nThis technique, called covariant return type, means that the return type is allowed to vary in the same direction as the subclass.\n\nNote: You also can use interface names as return types. In this case, the object returned must implement the specified interface."
    },
    {
        "link": "https://stackoverflow.com/questions/22370244/java-documentation-return-and-param",
        "document": "The Javadoc style guide explains the intended uses of these tags. describes a parameter and describes the return value. (There are several other useful tags.)\n\nRemember that Javadoc generates documentation from your code, not just from your comments. The signature of the method will appear in the output -- therefore, don't tell the readers stuff they already know. The purpose of your documentation is to supply the additional semantics not expressed in the signature. Is that numeric parameter constrained to a particular range of values? Are there any special return values (like null)? Document the contract.\n\nYou ask if there is such a thing as too much documentation. Yes, there is. API reference documentation is most useful when it tells the readers all and only what they need to know to properly use the interface. So fully document the contract, but say nothing abut how your code implements this interface. Link to other elements of the API (such as other classes or interfaces) if they directly bear on the part you're documenting (for example if somebody needs to use to obtain an instance of , the class you're documenting).\n\nThis isn't to say that you should never write anything longer than a few sentences; sometimes an interface is complex and requires more explanation. Consider whether that explanation belongs in a package overview, the top-level documentation of a class or interface, or a specific member. If you find yourself cutting and pasting an explanation in several places, that may be a sign that you need to address it at a higher level instead."
    },
    {
        "link": "https://whitman.edu/mathematics/java_tutorial/java/javaOO/methoddecl.html",
        "document": "While this may sound like writing a novel rather than simply declaring a method for a class, most method attributes can be declared implicitly. The only two required elements of a method declaration are the method name and the data type returned by the method. For example, the following declares a method named in the Stack class that returns a boolean value ( or ):\n\nJava requires that a method declare the data type of the value that it returns. If a method does not return a value, it must be declared to return . Methods can return either values of primitive data types or of reference data types. The method in the Stack class returns a primitive data type, a boolean value: However, the method in the Stack class returns a reference data type: an object. Methods use the operator to return a value. Any method that is not declared must contain a statement. The data type of the value returned by the statement must match the data type that the method claims to return; you can't return an Object from a method declared to return an integer. When returning an object, the returned object's data type must be either a subclass of or the exact class indicated. When returning an interface type, the object returned must implement the specified interface.\n\nA method name can be any legal Java identifier. There are three special cases to consider in regards to Java method names:\n• Java supports method name overloading so multiple methods can share the same name. For example, suppose you were writing a class that can render various types of data (strings, integers, and so on) to its drawing area. You would need to write a method that knew how to render each data type. In other languages, you would have to think of a new name for each method: , , , and so on. In Java, you can use the same name for all of the drawing methods but pass in a different type of parameter to each method. So, in your data rendering class, you can declare three methods named each of which takes a different type parameter: Note: The information within the parenthesis in the method declaration are arguments to the method. Arguments are covered on the next page: Passing Information into a Method. The methods are differentiated by the compiler by the number and type of the arguments passed into the method. Thus, and are distinct and unique methods. You cannot declare more than one method with the same signature: and are identical and will result in a compiler error. You should note that overloaded methods must return the same data type; so and declared in the same class will produce a compile-time error.\n• Any method whose name is the same as its class is a constructor and has a special duty to perform. Constructors are used to initialize a new object of the class type. Constructors can only be called with Java's operator. You learned how to create an object in Creating Objects. To learn how to write a constructor, see Writing a Constructor Method.\n• A class may override a method in its superclass. The overriding method must have the same name, return type, and parameter list as the method it overrides. Overriding Methods will show you how to override the methods in your class's superclass."
    },
    {
        "link": "https://stackoverflow.com/questions/27682807/how-to-find-all-methods-returning-type-in-javadoc",
        "document": "In the standard Javadoc layout, you cannot do that specifically.\n\nHowever, you can find all usages of a particular class, provided you are on the javadoc page for that class: at the top of the page, you have a set of links; one of them is called (it's right next to ). It will indeed list all the uses of that class, whether it be as a return value or as an argument.\n\nIn IDEA itself, if you have the cursor on the class you want, you can press Alt+F7, you'll have the option to search for the uses of a particular class in your project, or your project PLUS the libraries you depend upon."
    },
    {
        "link": "https://pysmali.readthedocs.io/en/latest/api/smali/language.html",
        "document": "Smali is an assembly-like language used to write code for Android apps. It is designed to be human-readable as well as easy to understand, while still being low-level enough to allow for fine-grained control over the app’s behavior.\n\nSmali files come with the extension and each of them correspond to a single Java class and has the same name as the class, but with slashes ( ) replacing dots ( ) in the package name. For example, the Java class would be represented by the Smali file . These names are referred to internal names.\n\nThe structure of a Smali source code can be broken down into the following sections:\n\nThe header of a Smali file contains several pieces of information that are used by the Smali assembler to build the final file for an Android app. It starts with the directive, which specifies the name of the class being defined in the file. Here’s an example: Here, we are defining a class called in the package with as its access modifier. The class name is preceded by the letter and is followed by a semicolon, which is the standard syntax for type descriptors in Smali. For more information about type descriptors, see chapter Type descriptors of the Smali API. After the directive, the header can include several optional directives to provide additional information about the class. For example, you can use the directive to specify the parent class of the current: This directive specifies that the our class inherits contents and functionalities from . Other optional directives that can appear in the header include:\n• None This directive is used to specify that the current class implements one or more interfaces. For instance, the following code specifies that our class implements and :\n• None This directive is used to specify the name of the original source that Smali code was generated from. This information can be useful for debugging purposes. Note that for lambda-classes the source definition would point to :\n• None This directive is used to enable debug information for the current class. When it is present, the Smali assembler will include additional metadata in the final file that can be used by debuggers: The visitor API provided by this repository uses different method call for each of these directives to provide more flexibility while parsing. Therefore, if you want to get the header information on a class, you have to implement the following methods: In summary, the header of a Smali source file contains important metadata about the class being defined, as well as optional directives that provide additional information.\n\nIn Smali, class annotations are used to provide metadata information about a class. They are defined using the directive followed by their descriptor and elements. Here is an example of how class annotations are defined in Smali: com/example/ ; java/lang/ ; runtime java/lang/ ; system dalvik/annotation/ ; value com/example/ ; system dalvik/annotation/ ; accessFlags name outer com/example/ ; # class definition and methods go here In this example, we have defined three different class annotations:\n• This runtime annotation indicates that the class is deprecated and should no longer be used. It is defined using the annotation descriptor.\n• This system annotation specifies the enclosing class of the current. It is defined using the descriptor. In this case, it specifies that the enclosing class of is .\n• This system annotation specifies that the class is an inner class. It is defined using the descriptor. In this case, it specifies that the access flags for the class are (which means it is static), the name of the class is , and the outer class is . There is also a special annotation used to mark classes to contain generic types, named . When used on a class, the annotation specifies the generic signature of the class, including its type parameters. Here is an example of how the signature annotation can be used on a class in Smali: # add the Signature annotation to the class In this example, the class is defined with a type parameter using the signature annotation. Converted into Java code, the class would look like the folowing: All type descriptors that are defined after geenric type descriptors define the super classes of the declared class. In this case, there is only one super class ( ).\n\nThe directive in Smali is used to define a field within a class. The general syntax for the field directive is as follows: Here is a breakdown of the different components of the field directive:\n• Access flags specifiy the access modifiers for the field being defined. It can be one of the following values: The field can be accessed from anywhere within the application. The field can be accessed within the same package or by a subclass. The field can only be accessed within the same class or by a non-static subclass. The field belongs to the class, but not to any instance of the class. The field cannot be modified once it has been initialized. The field is generated by the compiler and not present in the original source code. You can use a combination of these flags to specify the desired access level for the field. They can be retrieved by using the class:\n• This section specifies the name of the field. It should start with a letter and can contain letters, digits, underscores, and dollar signs. It must not start with a number.\n• The type descriptor is a string that represents the type of the field. The structure of type descriptors is described in the Type descriptors chapter of the Smali API.\n• The value definition is used when the field should be assigned directly with a value. Let’s take a quick look at a small example of the directive: Here, we are defining a private integer field named myField. The type descriptor indicates that this field has an integer as its value. This field can only be accessed within the same class or any non-static sub-class.\n\nIn Smali, a method definition consists of several components, including access modifiers, return type, parameter types, and implementation code. The code block contains the actual assembly-like code that is executed when the method is called. It can contain registers, instructions, labels, and exception handlers. Here is a breakdown of the different components of the method directive:\n• Access flags specifiy the access modifiers for the method. It can have the same values as defined before in field definitions.\n• Stores the actual method name used in references. There are two special method names that are pre-defined: for constructor methods and for static initializer blocks.\n• These are the type descriptors of the parameters of the method.\n• Defines the return type for this method (type descriptor).\n• This is the actual code that performs the functionality of the method. It may contain the following sections:\n• Registers are used to store temporary data and intermediate results during the execution of the method. They are specified using the letter followed by a number (e.g., , , , etc.).\n• Instructions are used to perform operations on registers or objects. Each instruction is represented by a mnemonic (e.g., , , , etc.) followed by its operands. Operands can be registers, constants, or labels.\n• Labels are used to mark specific locations in the code block. They are specified using a colon ( ) followed by its name (e.g., , , etc.).\n• Exception handlers are used to handle exceptions that may occur during the execution of the method. They are specified using the directive, followed by the type of the exception that is being caught and the label of the handler. The following example method written in Smali can be used to print to the console:\n• In the first line we defined a method with name that returns nothing and takes a string array ( ) as an argument.\n• declares that the method will use 2 registers, so we can use and within the method.\n• The instruction loads the object named out into the first register ( ).\n• The instruction defines a string variable that will be loaded into the register .\n• With we are calling the method println of the Java class to print our string in register to the console.\n\nThe directive in Smali is used to define an annotation. The structure of this directive is as follows: The annotation directive starts with the or keyword followed by the visibility and the type descriptor for the annotation. There are three possible values for the annotation’s visibility:\n• None : The annotation is visible at runtime and can be queried using reflection.\n• None : The annotation is a system annotation and is not visible to the user.\n• None : Another system annotation that indicates special treating of the annotated value. After the visibility and annotation type descriptor, the properties are defined. These are key-value pairs, where the key is the property’s name and the value is the property’s value. The properties are defined using the syntax . It is possible to define multiple properties on separate lines within one annotation directive. Finally, the annotation directive is closed using the keyword. Here is an example of an annotation directive in Smali: The sample defines an annotation named with two properties: name and age. The name property is a simple string and has a value of , and the age property is a sub-annotation with a value of 30. The keyword specifies that the annotation is visible at runtime of the application."
    },
    {
        "link": "https://sallam.gitbook.io/sec-88/android-appsec/smali/smali-cheat-sheet",
        "document": "Smali is the assembly language used to represent Android's DEX bytecode. This guide organizes the most important instructions and concepts into a comprehensive and easy-to-understand format, providing clarity on the various components of Smali code.\n\nIn Dalvik, registers are always 32 bits and can hold any type of value. For 64-bit types like and , two registers are used. There are two key types of registers:\n• None Local registers ( ): Used for local variables and temporary values.\n• None Parameter registers ( ): Used for passing parameters in functions, with typically representing the operator.\n\nLocal registers start from and may go up as needed (e.g., to ). Not all of these correspond directly to variables; some registers are used for internal operations by the decompiler.\n\nThe type of local registers often starts with , indicating a class reference. For example:\n\nThe decompiled code also shows the use of extra registers, e.g., , for handling function outputs (like ).\n\nHere’s a table summarizing the syntax and descriptions for the conditional comparison commands:\n\nHere’s a table summarizing the commands and descriptions for invoking methods in Java/Smali:\n\nDifferent instructions are used depending on whether you are invoking a method statically, virtually, or on an interface.\n\nA method in Smali starts with a directive and is followed by the method signature, return type, and parameters.\n\nSmali allows assigning constant values to registers using the family of instructions.\n\nIn Smali, arrays are handled with the instruction, which creates an array and stores it in a register. Elements are accessed via the and instructions.\n• None : Moves the value from one register to another.\n• None : Returns from a method with no value.\n\nThis is a simple and effective way to print variables such as passwords, secrets, or comparison values to logcat. By injecting a statement into the Smali code, you can monitor the output of specific values in the application logs.\n\nYou can print the value of a variable by loading it into a register (e.g., ), then using and to print it.\n\nAfter inserting this code into the Smali file, you can run the app and check the logcat output to see the printed value, which can be useful for debugging or extracting sensitive data.\n\nOften, cryptographic functions store sensitive data like keys or initialization vectors (IVs) as byte arrays. To print these byte arrays in a readable format, you can encode them as Base64 strings and output them.\n\nInsert the following code into the existing Smali code. Ensure that the register ( in this case) refers to the correct byte array.\n\nThis will print the byte array as a Base64-encoded string, making it easier to inspect and understand cryptographic data. You can insert this snippet into any Smali file where byte arrays are processed."
    },
    {
        "link": "https://payatu.com/blog/an-introduction-to-smali",
        "document": "Smali is a type of assembly language for the Dalvik virtual machine, which is used by Android devices. It is used to modify and reverse engineer Android apps, and allows developers to make changes to the bytecode of an app.\n\nOne of the main advantages of Smali is that it allows for more fine-grained control over the behavior of an app than Java, as it operates at the bytecode level. This makes it useful for tasks such as hooking into specific methods or modifying the behavior of an app without modifying its Java source code.\n\nIn this blog, we will look at three different test cases which include decompiling the APKs and converting them into Smali code which can be edited, modified and then recompiled back into the APKs. So, let’s get started.\n\nThis blog has some pre-requisite that one should be familiar with basics of java and basic knowledge of android application. If you are not familiar with these, you can first read few blogs to gain some insights.\n\nsmali/baksmali is an assembler/disassembler for the dex format used by dalvik, Android’s Java VM implementation. When we create an android application, the structure of the apk folder looks like below:\n\nAs you can see, one of the files is classes.dex which is basically binary dalvik bytecode that the android platform understands. Suppose if we want to read/modify this binary file, we need to convert this file to a more human readable format. This is when smali comes into play. The classes are then converted into Smali code, which can be edited and modified. The modified code can then be recompiled back into an APK file and installed on an Android device.\n\nFor example, say you have Java code that does something like\n\nAssuming this is the first variable, then the dex code for the method will most likely contain the hexadecimal sequence\n\nIf you run baksmali on it, you’d get a text file containing the line\n\nWhich is obviously a lot more readable than the binary code.\n\nSo, let’s start with learning the basics of smali first. Then we will create an android application and modify some variables. After that we will rebuild the mod apk.\n• In Smali, registers are used to hold any type of value and are always 32 bits. To hold 64-bit values (long/double), two registers are used.\n• Each method/function has a declaration of the number of registers used in that method/function.\n• The .registers directive specifies the total number of registers used in the method, while the alternate .locals directive specifies the number of non-parameter registers used in the method.\n• For example, if there is a non-static method with two arguments, there would be three parameter registers. If the total number of registers used in that method is 5, then the .locals directive will be 2, as 3 are parameter registers (this, arg1, arg2).\n\nFor example, look at the following java code:\n\nConverting this java code into Smali Bytecode using locals directive:\n\nDon’t worry if you don’t understand the code, we will be explaining it in a later section. For now, you can find out that the number of locals directive used is 1. So we can conclude that the method addIntger and addInteger2 both have one non-parameter registers.\n\nIn the above Smali code in which we have used registers directive, you can find out that addInteger method has four registers while the addInteger2 method has three registers. This is because addInteger method is non-static while the addInteger2 method is static. As in non-static class, we need to create instance of the class first and then using this keyword, we call the method.\n\nSo, the total number of registers used in addInteger method is 4, then the .locals directive will be 1, as 3 are parameter registers (this, arg1, arg2). Similarly, the total number of registers used in addInteger2 method is 3, which includes 1 locals directive and 2 parameter registers(arg1, arg2).\n\nSo now we have covered how the variables are defined in smali code. Now let us take a look on Smali Data Types. The below table depicts how data types of Java gets mapped into Smali:\n\nNow we will follow the same tradition to learn smali as any developer do to learn any other language. We will look at a famous HelloWorld Example in Smali. I have also attached the java code for HelloWorld method as it will help in understanding the code better. But during the practical demonstration, we didn’t have access to the java code.\n\nThe above piece of Smali code has a method named “HelloWorld” which takes no arguments and returns void.\n\nThe first line “.method public HelloWorld()V” declares the method “HelloWorld” as public and takes no arguments and returns void.\n\nThe next line “.locals 2” declares that this method uses 2 local variables. Local variables are used to temporarily hold values within a method.\n\nThe next line “.line 6” is used to indicate the source code line number, in this case line 6.\n\nThe next line “sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;” is used to retrieve the value of the “out” field of the “java.lang.System” class, which is an instance of the “java.io/PrintStream” class, and store it in register v0.\n\nThe next line “const-string v1, “Hello World!”” loads the string “Hello World!” into register v1.\n\nThe next line “invoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V” invokes the “println” method of the “java.io.PrintStream” class, passing in the value of v1 as the argument. The “println” method writes the passed string to the standard output.\n\nThe next line “.line 7” is used to indicate the source code line number, in this case line 7.\n\nThe last line “return-void” is used to return from the method and indicate that the method returns void.\n\nYou may be wondering from where is sget-object or const-string coming from in the smali. These are basically instructions that are used to manipulate value in the registers. The “sget-object” instruction is used to retrieve the value of a static object field and store it in a register, while the “const-string” instruction is used to load a constant string value into a register. The “s” in “sget” stands for “static”, indicating that the field is a static field.\n\nWorking with Smali requires a good understanding of the Dalvik virtual machine and its instruction set, as well as experience with assembly language programming.\n\nYou can find dalvik-opcodes here that will help you get started with what a specific instruction does.\n\nNow we will look at three test cases where we will try to modify the smali code of the application and then repatch the application. So let us get started without any further delay.\n\nIn this test case, we will try to modify some variable to gain some confidence that smali is not at all hard to read. For this, we have created an android application named Smali Application 1 which is doing an addition operation on two numbers:\n\nSo, as the application is challenging us to prove it wrong.\n\nFirst, we will pull the apk file of the installed Smali Application 1 from the device, decompile it using apktool and then analyze the smali code.\n\nI have written a small bash script that pulls the base apk file and decompile the application:\n\nRunning the above bash script will create a directory named smali1 of Smali Application 1. First thing first, we will search for MainActivity in this directory as this Activity is usually the entry point for any application. So it is better to start looking into this file first.\n\nLoad the file smali1/smali_classes3/com/app/smali1/MainActivity.smali into any editor of your choice and try to read the smali code.\n\nYou will find a function named addInteger. In that function, there is one local variable used ,I.e v0. From line 18, we can conclude that It takes two arguments of data type Integer and return an integer. The .param p1, and p2 are the parameters that are given input as arguments in the function. And on line 24, it has an opcode add-int that is doing addition of p1 and p2 and storing the result in v0. And finally v0 get returned to the calling function of addInteger.\n\nScrolling below to the MainActivity.smali, you will find a method named onCreate which is calling addInteger method and giving arguments of v0 and v1. The value of v0 and v1 are set to 0x14 which is 20 in decimal.\n\nNow we will modify this variable simply to some another hex value let’s say 0x1f and patch the application and install it in the device. I am using APKlab extension in VSCode to patch and sign the application, but you are free to use whatever way you prefer.\n\nNow go to the dist folder and install the apk file in the device.\n\nIn the previous test case, we successfully modified the value of a variable. In this test case, we are going to change the return value of a function. For the demonstration of this test case, we have created another application named Smali Application2.\n\nIt is also performing addition operation on two numbers. Let’s decompile the apk and analyze the smali code to get understanding of the application. The MainActivity.smali has a function named add_nums as shown below\n\nSince the goal of this test case is to modify the return value of the function add_nums, we will modify the function itself. Instead of addition, we will perform subtraction by adding a new local variable v1 in the function. Thus, the locals directive count will increase to 2. Here is what the modified code will look like:\n\nLet’s patch the rebuild the application and install it in the device.\n\nAnd we have successfully modified this application. You are free to modify other variables as well, like you can try to modify this alert message.\n\nTest Case 3: Write a new evil function and calling that evil function instead of a legitimate function in smali\n\nTill now, we have successfully modified the variable, inserted new smali code inside a function. In this test case, we are going to insert an evil function in smali and call that evil function instead of a legitimate function. For the demonstration of this test case, we have created another application named Smali Application3,\n\nAs you can see, it is just displaying a Hello team… string on the homepage with an alert of “I am saying hello to the team”.\n\nLet’s analyze the application by decompiling it using apktool. The MainActivity.smali has a method named say_hello as shown below\n\nAnd this say_hello method gets called inside onCreate method of MainActivity.smali file.\n\nFirst, we will insert a new evil_method inside the MainActivity.smali file and call this evil_method instead of say_hello method. Here is how the evil_method will look like:\n\nIt is simply returning a string of “Cheers Team!!!” . Lets replace the say_hello() method in onCreate method with evil_method and rebuild the application.\n\nSo, we have successfully inserted a method inside the application by modifying the smali code.\n\nThis is it for this blog and for the next blog, we will see some real scenarios how an attacker can modify the Smali application to gain access to some sensitive data or bypass some checks."
    },
    {
        "link": "https://pysmali.readthedocs.io/en/stable/api/smali/language.html",
        "document": "Smali is an assembly-like language used to write code for Android apps. It is designed to be human-readable as well as easy to understand, while still being low-level enough to allow for fine-grained control over the app’s behavior.\n\nSmali files come with the extension and each of them correspond to a single Java class and has the same name as the class, but with slashes ( ) replacing dots ( ) in the package name. For example, the Java class would be represented by the Smali file . These names are referred to internal names.\n\nThe structure of a Smali source code can be broken down into the following sections:\n\nThe header of a Smali file contains several pieces of information that are used by the Smali assembler to build the final file for an Android app. It starts with the directive, which specifies the name of the class being defined in the file. Here’s an example: Here, we are defining a class called in the package with as its access modifier. The class name is preceded by the letter and is followed by a semicolon, which is the standard syntax for type descriptors in Smali. For more information about type descriptors, see chapter Type descriptors of the Smali API. After the directive, the header can include several optional directives to provide additional information about the class. For example, you can use the directive to specify the parent class of the current: This directive specifies that the our class inherits contents and functionalities from . Other optional directives that can appear in the header include:\n• None This directive is used to specify that the current class implements one or more interfaces. For instance, the following code specifies that our class implements and :\n• None This directive is used to specify the name of the original source that Smali code was generated from. This information can be useful for debugging purposes. Note that for lambda-classes the source definition would point to :\n• None This directive is used to enable debug information for the current class. When it is present, the Smali assembler will include additional metadata in the final file that can be used by debuggers: The visitor API provided by this repository uses different method call for each of these directives to provide more flexibility while parsing. Therefore, if you want to get the header information on a class, you have to implement the following methods: In summary, the header of a Smali source file contains important metadata about the class being defined, as well as optional directives that provide additional information.\n\nIn Smali, class annotations are used to provide metadata information about a class. They are defined using the directive followed by their descriptor and elements. Here is an example of how class annotations are defined in Smali: com/example/ ; java/lang/ ; runtime java/lang/ ; system dalvik/annotation/ ; value com/example/ ; system dalvik/annotation/ ; accessFlags name outer com/example/ ; # class definition and methods go here In this example, we have defined three different class annotations:\n• This runtime annotation indicates that the class is deprecated and should no longer be used. It is defined using the annotation descriptor.\n• This system annotation specifies the enclosing class of the current. It is defined using the descriptor. In this case, it specifies that the enclosing class of is .\n• This system annotation specifies that the class is an inner class. It is defined using the descriptor. In this case, it specifies that the access flags for the class are (which means it is static), the name of the class is , and the outer class is . There is also a special annotation used to mark classes to contain generic types, named . When used on a class, the annotation specifies the generic signature of the class, including its type parameters. Here is an example of how the signature annotation can be used on a class in Smali: # add the Signature annotation to the class In this example, the class is defined with a type parameter using the signature annotation. Converted into Java code, the class would look like the folowing: All type descriptors that are defined after geenric type descriptors define the super classes of the declared class. In this case, there is only one super class ( ).\n\nThe directive in Smali is used to define a field within a class. The general syntax for the field directive is as follows: Here is a breakdown of the different components of the field directive:\n• Access flags specifiy the access modifiers for the field being defined. It can be one of the following values: The field can be accessed from anywhere within the application. The field can be accessed within the same package or by a subclass. The field can only be accessed within the same class or by a non-static subclass. The field belongs to the class, but not to any instance of the class. The field cannot be modified once it has been initialized. The field is generated by the compiler and not present in the original source code. You can use a combination of these flags to specify the desired access level for the field. They can be retrieved by using the class:\n• This section specifies the name of the field. It should start with a letter and can contain letters, digits, underscores, and dollar signs. It must not start with a number.\n• The type descriptor is a string that represents the type of the field. The structure of type descriptors is described in the Type descriptors chapter of the Smali API.\n• The value definition is used when the field should be assigned directly with a value. Let’s take a quick look at a small example of the directive: Here, we are defining a private integer field named myField. The type descriptor indicates that this field has an integer as its value. This field can only be accessed within the same class or any non-static sub-class.\n\nIn Smali, a method definition consists of several components, including access modifiers, return type, parameter types, and implementation code. The code block contains the actual assembly-like code that is executed when the method is called. It can contain registers, instructions, labels, and exception handlers. Here is a breakdown of the different components of the method directive:\n• Access flags specifiy the access modifiers for the method. It can have the same values as defined before in field definitions.\n• Stores the actual method name used in references. There are two special method names that are pre-defined: for constructor methods and for static initializer blocks.\n• These are the type descriptors of the parameters of the method.\n• Defines the return type for this method (type descriptor).\n• This is the actual code that performs the functionality of the method. It may contain the following sections:\n• Registers are used to store temporary data and intermediate results during the execution of the method. They are specified using the letter followed by a number (e.g., , , , etc.).\n• Instructions are used to perform operations on registers or objects. Each instruction is represented by a mnemonic (e.g., , , , etc.) followed by its operands. Operands can be registers, constants, or labels.\n• Labels are used to mark specific locations in the code block. They are specified using a colon ( ) followed by its name (e.g., , , etc.).\n• Exception handlers are used to handle exceptions that may occur during the execution of the method. They are specified using the directive, followed by the type of the exception that is being caught and the label of the handler. The following example method written in Smali can be used to print to the console:\n• In the first line we defined a method with name that returns nothing and takes a string array ( ) as an argument.\n• declares that the method will use 2 registers, so we can use and within the method.\n• The instruction loads the object named out into the first register ( ).\n• The instruction defines a string variable that will be loaded into the register .\n• With we are calling the method println of the Java class to print our string in register to the console.\n\nThe directive in Smali is used to define an annotation. The structure of this directive is as follows: The annotation directive starts with the or keyword followed by the visibility and the type descriptor for the annotation. There are three possible values for the annotation’s visibility:\n• None : The annotation is visible at runtime and can be queried using reflection.\n• None : The annotation is a system annotation and is not visible to the user.\n• None : Another system annotation that indicates special treating of the annotated value. After the visibility and annotation type descriptor, the properties are defined. These are key-value pairs, where the key is the property’s name and the value is the property’s value. The properties are defined using the syntax . It is possible to define multiple properties on separate lines within one annotation directive. Finally, the annotation directive is closed using the keyword. Here is an example of an annotation directive in Smali: The sample defines an annotation named with two properties: name and age. The name property is a simple string and has a value of , and the age property is a sub-annotation with a value of 30. The keyword specifies that the annotation is visible at runtime of the application."
    },
    {
        "link": "https://xdaforums.com/t/guide-smali-coding-guide-for-beginners.2193735",
        "document": "So in the previous post I said we should call interceptOneFingerStatusBarRightTap in interceptTouchEvent method. But how does one find that out? In which function to call and where?Well first of all look at the names of the methods and variables and try to figure out what they do. Look at the parameters in function calls. Like interceptOneFingerStatusBarRightTap requires MotionEvent as its parameter in the function call to be able to use getRawX(). So now look at all the methods in PhoneStatusBar.smali which has acces to MotionEvent. In simple cases you might then be able to figure out where to put the method call if you understand the smali code and/or through trial and error. But in more complex cases you can take the help of logcatSo here our aim is to add the call to interceptOneFingerStatusBarRightTap to a method in PhoneStatusBar.smali that has access to MotionEvent and is called when the user touches the screen. Goto all such methods and add smali code to send messages to the logcat. The smali code would be like thisMake sure the variables used doesn't interfere with the code. Let us say we want to see when interceptTouchEvent is called. Add the above code at the beginning of the definition for interceptTouchEvent method. Instead of \"Message1\" write \"interceptTouchEvent\" and instead of \"Message2\" write \"beginning\". Now if you smali+compile the code to get the unsignedSystemUI.apk and get it working in your phone, connect the phone to your PC/laptop with USB debugging and open up logcat in cmd or eclipse. Now the \"interceptTouchEvent\" and \"beginning\" would come up in the logcat the moment the beginning part of interceptTouchEvent is executed. Like this you can find out which method is called when the user touches the status bar and where in the method should the code be added so that the right tap check happens only when you want it toIn some cases you would want to see what value a certain variable holds. Suppose you want to know the value in mTouchRight at the beginning of interceptTouchEvent. The following code would do itThe extra line is to convert the boolen value in mTouchRight to string as Log.d() needs string parameters.Finally get rid of the log.d() commands you wouldn't require before releasing the final version!"
    }
]