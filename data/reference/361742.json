[
    {
        "link": "https://docs.unity3d.com/Packages/com.unity.ai.navigation@1.1/manual/NavMeshAgent.html",
        "document": "The NavMesh Agent component allows you to create characters (agents) that avoid each other as they move through a scene. Agents use the NavMesh to navigate through the space of the game and avoid each other and other moving obstacles. You can use the scripting API of the NavMesh Agent to handle pathfinding and spatial reasoning.\n\nTo use the NavMesh Agent component, add it to a GameObject:\n• Select the GameObject that represents your agent.\n• Select Navigation > NavMesh Agent. \n\nThe NavMesh Agent component is displayed in the Inspector window.\n\nYou can use this component to create NavMesh agents. For more details, see Create a NavMesh Agent. For more information about NavMesh agents, see About NavMesh agents.\n\nThe following tables describe the properties available in the NavMesh agent component.\n• Inner Workings of the Navigation System"
    },
    {
        "link": "https://docs.unity3d.com/550/Documentation/Manual/class-NavMeshAgent.html",
        "document": "NavMeshAgent components help you to create characters which avoid each other while moving towards their goal. Agents reason about the game world using the NavMesh and they know how to avoid each other as well as other moving obstacles. Pathfinding and spatial reasoning are handled using the scripting API of the NavMesh Agent.\n\nThe agent is defined by an upright cylinder whose size is specified by the Radius and Height properties. The cylinder moves with the object but always remains upright even if the object itself rotates. The shape of the cylinder is used to detect and respond to collisions between other agents and obstacles. When the GameObject’s anchor point is not at the base of the cylinder, you can use the Base Offset property to take up the height difference.\n\nThe height and radius of the cylinder are actually specified in two different places: the NavMesh bake settings and the properties of the individual agents.\n• NavMesh bake settings describe how all the NavMesh Agents are colliding or avoiding the static world geometry. In order to keep memory on budget and CPU load in check, only one size can be specified in the bake settings.\n• NavMesh Agent properties values describe how the agent collides with moving obstacles and other agents.\n\nMost often you set the size of the agent the same in both places. But, for example, a heavy soldier may have larger radius, so that other agents will leave more space around him, but otherwise he’ll avoid the environment just the same.\n• Creating a NavMesh Agent – workflow on how to create a NavMesh Agent.\n• Inner Workings of the Navigation System - learn more about how obstacles are used as part of navigation."
    },
    {
        "link": "https://learn.unity.com/tutorial/working-with-navmesh-agents",
        "document": "Once a NavMesh has been baked for the level it is time to create the elements which can navigate the scene. In this tutorial, you will learn to use a NavMesh Agent component and create a simple script."
    },
    {
        "link": "https://docs.unity.cn/Packages/com.unity.ai.navigation@1.1/manual/NavMeshAgent.html",
        "document": "The NavMesh Agent component allows you to create characters (agents) that avoid each other as they move through a scene. Agents use the NavMesh to navigate through the space of the game and avoid each other and other moving obstacles. You can use the scripting API of the NavMesh Agent to handle pathfinding and spatial reasoning.\n\nTo use the NavMesh Agent component, add it to a GameObject:\n• Select the GameObject that represents your agent.\n• Select Navigation > NavMesh Agent. \n\nThe NavMesh Agent component is displayed in the Inspector window.\n\nYou can use this component to create NavMesh agents. For more details, see Create a NavMesh Agent. For more information about NavMesh agents, see About NavMesh agents.\n\nThe following tables describe the properties available in the NavMesh agent component.\n• Inner Workings of the Navigation System"
    },
    {
        "link": "https://discussions.unity.com/t/lets-talk-about-navmeshagent/702901",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/ai-pathfinding-methods/901239",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/Unity2D/comments/14rjww9/does_anyone_have_any_tutorials_on_how_to_code_ai",
        "document": "I'm currently trying to learn Unity and I'm making a few project I want to use as a portfolio. Issue is, whenever I look up AI path-finding, lots of them just tell me to download A* or something. I want to learn how to code these things myself, not just download code other people have made. It doesn't have to be something that complicated either, just some I can code in so I can work on other piece of my current project.\n\nI'm still very new to all of this, so maybe I'm going about this the wrong way. I just don't want to show off these projects to whatever company I may or may not get hired to, and the ask, \"How did you do the path-finding?\" and I just tell them I downloaded it. Anyway, any advice or tutorials would be very helpful."
    },
    {
        "link": "https://dev.to/eelstork/unity-navmesh-in-2023-maybe-not-what-you-want-hk0",
        "document": "I decided to give the Unity Navmesh a try mainly because I wanted a standard solution, and path-finding was not my immediate focus. When thinking navigation it's easy to forget that often, we need more than just going from A to B. They forgot (more likely, decided a comprehensive API would not perform blitz fast, therefore was not worth building).\n\nHow to use it\n\nAt first glance the Unity navigation API is easy. Pretty much all you need to do is bake your navmesh and invoke , where P is where you want to go and a .\n\nCould it be more simple?\n\nYou'll want to not move and rotate while no walk animation is playing:\n\n\n\nThere are methods to disable updating the rotation/position of the agent. As a quirk these do not stop consuming the path - the position along the path keeps updating in the background.\n\nThe main goal of this post is helping you decide whether you should roll your own (not so hard) or go with Unity navmeshes.\n\nThere is good stuff. You can assign colors and costs to navigation areas, and the API lets you build connectors for laddering, crouching and such.\n\nNot so good out of the box\n\nLet's be clear, you're not getting a great result out of the box, here's a few things you will notice:\n• Paths are not very smooth; you get angular paths with semi-rounded corners\n• Rotation is vehicular; not the hardest thing to fix but, regardless of your set rotation speed, the apparent rotation of an agent tends to desync from their motion direction.\n• Choose between hugging walls and not passing through doorways; by default agents will take the shortest path. If you want margin between walls and agents, well you can't have that unless messing with areas and masking, or raising the baking radius.\n• No straight answer to whether pathing has failed; used via , does not show anything relevant. Now, you can calculate an arbitrary path and get a meaningful answer for that, however the method ( ) is synchronous.\n\nThe actual navmesh API will help with many of these. Is it more work? Absolutely. So the question is...\n\nIs it worth the effort?\n\nGetting to the meat, here's a couple of limitations that you should really keep in mind, because you may not want to design workarounds for every problem.\n• Each agent have their own radius, however this only applies to obstacle avoidance. If your agents really have significantly different sizes, this isn't going to work, and again you'll end up messing with areas and masking, which aren't the correct answer to this.\n• The navigation goal must be a point. There are plenty use cases where this is really awkward. What if you want to just avoid a number of agents? What if you want to reach any transform matching a given crit? What if you just want to keep moving roughly in a given direction?\n\nWith a general purpose search algorithm, none of the above is hard. It would seem that Unity navmeshes were designed mostly just to help enemies run towards the player, without care for the many use cases that this does not cover.\n\nOverall Unity navmesh pathfinding is a mixed bag. The ease of use does not go very far, and you'll have to put in more work to get a nice result. At the core it's also a path-to-point system, which does get old quickly if you need to do anything (actually not) fancy."
    },
    {
        "link": "https://discussions.unity.com/t/how-to-optimize-a-node-pathfinding-system/1518856",
        "document": ""
    },
    {
        "link": "https://arongranberg.com/astar/documentation/stable/getstarted.html",
        "document": "How to get started with the A* Pathfinding Project, create your first graph, and make an agent move around on it.\n• Adding Pathfinding\n• But what is a graph?\n\nIf you prefer a video tutorial instead of a text tutorial, here is a video for you. The video tutorial and this text tutorial are very similar, so you can choose the one you prefer.\n\nYou can also take a look at the excellent tutorial/review by Code Monkey: https://www.youtube.com/watch?v=46qZgd-T-hk\n• None Graphs: which describe where an agent can move.\n• None Pathfinding: finding the best path between two points on a graph, or similar tasks.\n• None Movement: how an agent follows a path.\n\nAdditionally, there are many supporting features. Broadly, they can be grouped into:\n• None Temporary obstacles: which cut holes in the navmesh or update it in other ways.\n• None Off-mesh links: which allow an agent to move or jump between otherwise disconnected parts of the navmesh.\n• None Path modifiers: which are used by some movement scripts to smooth or simplify paths (notably these are not used by the FollowerEntity, which you'll use in this tutorial. It has its own internal smoothing instead).\n• None Local avoidance: which is used to make agents handle crowds.\n\nIn this tutorial, we will create a simple scene with a few obstacles, generate a navmesh for it, and then make an agent move around on it.\n\nThe first thing you need to do, if you haven't done so already, is to install the A* Pathfinding Project.\n\nIf you want, you can explore the different example scenes in the project before you start with the next section. The example scenes are installed separately. Take a look at the installation guide for more info.\n\nThe agent needs something to walk on, and something for it to avoid.\n\nThe AstarPath component is the core of this package. It holds all the graphs in the scene and provides a central place for all pathfinding related settings.\n\nThis is a singleton, so you should only have one instance of it in your scene. You can add multiple graphs to it, but most games only need one.\n\nThe inspector of the AstarPath component is divided up into sections.\n• None Graphs: contains all graphs in the scene.\n• None Settings: contains all global pathfinding and logging settings.\n• None Save & Load: allows you to save and load graphs to and from files.\n• None Optimization: allows you to enable or disable some features project-wide. You typically don't have to touch these.\n• None About: shows the current version and has links to the online documentation.\n• None Show Graphs Toggle: enables or disables the graphs from being rendered in the scene view.\n• None Scan Button: recalculates all graphs. There's also a shortcut for this: Cmd+Alt+S (mac) or Ctrl+Alt+S (windows).\n\nBut what is a graph?\n\nA graph represents the traversable surface of the world. This is every point where your agent can walk. Or, more precisely, it is every location where it is valid for the center of an agent to be.\n\nA graph consists of nodes and connections between them. The shape of the nodes can vary. Some graph types use grid tiles, some use triangles, and some use points.\n\nThe word navmesh (or navigation mesh) is often used synonymously with the word graph. But it refers specifically to graphs that consist of triangle meshes (like the RecastGraph and NavMeshGraph).\n\nFor this tutorial, we will be using the RecastGraph. It can automatically generate a navmesh from the scene geometry.\n\nThe recast graph is a good all-around graph type, which can handle most situations. It can handle both detailed features, and very large worlds, in both 2D and 3D games. However, it is worse at handling dynamic costs for different parts of the world, than, for example, a grid graph.\n\nWe can actually get a decent navmesh by only changing a single setting. We need to ensure that the recast graph's bounding box, which is visualized in the scene view as a white box, covers our entire world.\n\nDifferent graphs represent the walkable surface differently. The recast graph uses a triangular mesh, while, for example, the grid graph uses a grid of nodes.\n\nWhat is a pathfinding test without some moving stuff? Not fun at all, so let's add an agent to play around with.\n\nThere are multiple movement scripts in the package. They have different movement styles and performance characteristics. The role of these components is to take care of searching for paths and to follow them. You give it a destination, and it will figure out how to get there.\n\nThe FollowerEntity movement script is a good choice for most games that need smooth movement. It works on all graphs except the point graph, and is pretty performant too.\n\nWe'll also need to tell the agent where to go. You can do this via a script, or you can use the helper component AIDestinationSetter, which allows moving to a GameObject.\n\nWe'll also need a target for the agent to move to.\n\nWe haven't quite achieved what we set out to do in this tutorial just yet. Our goal was to make the agent follow our cursor, but right now it only follows a target object. We can, of course, drag it around in the scene view, but that's not quite the same thing.\n\nTo solve this, we'll need a small custom script.\n\nEvery time a path is calculated by the system, it can optionally be logged to the console. This can be a big help in understanding what the system is doing and also to spot performance issues. Logging is not free, however, so for release builds it is recommended that you disable it.\n\nYou can change the logging settings under the A* Inspector → Settings → Debug tab.\n\nUse less debugging to improve performance (a bit) or just to get rid of the console spam. Use more debugging (heavy) if you want more information about what the pathfinding scripts are doing. The InGame option will display the latest path log using the in-game GUI.\n\nThat concludes the Get Started tutorial. We have covered the basics of creating a scene with obstacles, adding a graph, and making an agent move around on it, and how to interact with an agent using code.\n\nI wish you the best of luck in your continued exploration of this package.\n\nHere are some suggestions for what to do next:\n• None Explore the Example Scenes included in the package.\n• None How to migrate from Unity's built-in pathfinding to this package.\n• None More about the overall architecture of the package.\n• None More about other graph types."
    },
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics.Raycast.html",
        "document": "Suggest a change Thank you for helping us improve the quality of Unity Documentation. Although we cannot accept all submissions, we do read each suggested change from our users and will make updates where applicable. Close For some reason your suggested change could not be submitted. Please <a>try again</a> in a few minutes. And thank you for taking the time to help us improve the quality of Unity Documentation. Close\n\nTo select which layers a ray should collide with, use a LayerMask.\n\n\n\nSpecifying allows you to control whether or not Trigger colliders generate a hit, or whether to use the global Physics.queriesHitTriggers setting.\n\n\n\nNotes: Raycasts will not detect Colliders for which the Raycast origin is inside the Collider. In all these examples FixedUpdate is used rather than Update. Refer to Order of execution for event functions to understand the difference between Update and FixedUpdate, and to see how they relate to physics queries."
    },
    {
        "link": "https://gamedevbeginner.com/raycasts-in-unity-made-easy",
        "document": "The Raycast function is extremely useful for creating connections between objects in Unity.\n\nFor example, if you want to select an object just by looking at it or clicking on it.\n\nOr if you want to shoot an object with a weapon or obstruct a line of sight.\n\nOr perhaps if you need to check how high the player is from the ground, or what it is they’re standing on.\n\nThat’s where Raycasts can help.\n\nSo… what is the Raycast function and how does it work?\n\nRaycast in Unity is a Physics function that projects a Ray into the scene, returning a boolean value if a target was successfully hit. When this happens, information about the hit, such as the distance, position or a reference to the object’s Transform, can be stored in a Raycast Hit variable for further use.\n\nThis makes Raycast extremely useful for getting information about other objects, performing ground checks or, generally, doing anything that involves a line of sight connection between two objects.\n\nWhile Raycast can be very straightforward to use, it can be a little unintuitive at first.\n\nAnd if you’re new to Unity, the large number of features available, not to mention the many different versions of Raycast, each with their own quirks, can make it daunting to use at first.\n\nBut don’t worry, because, in this article, I’ll show you everything you need to know about using Raycast in Unity, step by step,\n\nHere’s what you’ll find on this page:\n• How to use Raycast in Unity\n• How to use the Raycast Hit variable\n• How to use the Raycast function\n• The different features of the Raycast function\n• How to use Layer Masks with Raycasts\n• How to ignore trigger colliders when using Raycast\n• How to hit multiple objects using Raycast\n• How to use Raycast All\n• Should you use Raycast in Fixed Update or Update?\n• How to use Raycast in Unity in 2D\n• Raycasts in 3D vs Raycasts in 2D\n\nHow to use Raycast in Unity\n\nThe basic version of Raycast is made up of three different parts:\n\nHere’s how each of them work…\n\nA Ray is simply a data struct in Unity that represents a point of origin and a direction for the Ray to travel.\n\nThe origin is the position in the world that the Ray will start from and takes a Vector 3 value.\n\nWhile the direction property takes a trajectory in the form of a normalised Vector 3.\n\nNormalising a vector limits its magnitude, which is the length of the Vector, to 1, which is useful for representing a consistent direction.\n\nThere are a few ways you can create a new Ray.\n\nOr, alternatively, you can use one of the helper functions to create a Ray automatically, such as a Ray that starts at the center of the camera’s viewport,\n\nIn the above example, the 0.5f values represent the middle of the viewport in both dimensions.\n\nOr from the Mouse Position on the screen,\n• How to Convert the mouse position to world space in Unity\n\nThese helper functions make it easy to create a Ray from an existing point in the world.\n\nHowever, while you can cache a reference to the Ray you create, you’ll still need to update it every time you use it.\n\nSo, for example, if your Ray’s origin and direction are going to be different every frame, you’ll need to update the Ray every frame too.\n\nOtherwise, when you come to use the Ray, it won’t be in the right position.\n\nOnce you’ve decided where your Ray will start from and which direction it’ll go in, you’ll need a place to store the data you get from it.\n\nThat can be done with a Raycast Hit variable.\n\nHow to use the Raycast Hit variable\n\nThe Raycast Hit variable is a data struct that stores information about Ray’s collision.\n\nIt records information like where the hit happened in the world, what object did the Ray collide with and how far away it was from the origin of the Ray.\n\nTo use it, all you need to do is declare it:\n\nThen, later, when you use Raycast to fire a Ray into the scene, you’ll have a place to store any information retrieved from the hit.\n\nFor example, you can get the position of the hit in the world using RaycastHit.point:\n\nOr the distance from the Ray’s origin to the point of impact using RaycastHit.distance:\n\nYou can also get information about the Collider that was hit, such as its Tag.\n\nOr, you could even use Raycast Hit to get a reference to an object’s Transform:\n\nWhile the Ray and Raycast Hit variables define where a Ray will go and how information from hits will be stored, they don’t do anything on their own.\n\nSo, to actually fire Rays into the scene, and check if they hit anything, you’ll need to use the Raycast function.\n\nHere’s how to do it.\n\nHow to use the Raycast function\n\nThe Raycast function in Unity allows you to check if a Ray collides with another object in the scene, saving the hit data to a Raycast Hit variable if it does.\n\nThere are several different versions of Raycast, each from different classes, that can be used in different ways, however, one of the most common ways to use Raycast is using the Physics Class, which returns a boolean true or false, depending on if the Ray hit anything.\n\nThis will fire the ray that you’ve created into the scene and save information about anything that’s hit to the Raycast Hit variable you declared.\n\nThis works because of the Out Keyword in the function.\n\nRaycast takes an out Raycast Hit argument, meaning that a Raycast Hit variable will need to be specified when you call it.\n\nThen when the function runs, Raycast Hit data will be stored in the variable you specified, allowing you to access it.\n\nThe out keyword allows you to save information in addition to the return type of Raycast.\n\nSo what is the return type?\n\nPhysics.Raycast has a bool return type, which returns true if the Ray hits a target.\n\nThis means that you can place the Raycast function in an if condition.\n\nUsing Raycast in this way means that code inside the if condition will only run if the Ray actually hits something.\n\nThis is useful because it means that you can limit your code to only use Raycast Hit data when it actually exists.\n\nOr to only perform an action if the Raycast was successful.\n\nWhether a Raycast was successful or not typically depends on if it hit something, however, because of the additional features of the Raycast function it’s possible to limit what counts as a successful hit in other ways as well.\n\nSuch as limiting the distance the Ray can travel, excluding certain layers or choosing if trigger colliders should be ignored.\n\nWhich of these settings are available to you depends on which overload method of the Raycast function you decide to use.\n\nThe different features of the Raycast function\n\nThere are many different versions of the standard Raycast function and each one offers slightly different functionality.\n\nFor example, some versions of Raycast only take a few parameters and perform a simple function in return, while others accept more complex sets of data and do more with it.\n\nThese different versions are Raycast’s overload methods.\n\nAn overload method is simply an alternative version of a method that takes a different set of parameters and that may return a different type of value.\n\nFor example, the most basic version of Physics.Raycast takes only one parameter, a Ray:\n\nWhile using a different overload method allows you to specify a Ray, a Raycast Hit variable, a Max Distance, a Layer Mask (to include or exclude certain layers from being hit) and a Query Trigger Interaction setting, which determines if Trigger Colliders can be hit or not.\n\nOverload methods allow you to pass different information into a function to achieve different results.\n\nHow do you select an overload method in Unity?\n\nA specific overload is defined by the parameters that are passed into it and their order.\n\nSo, to select a certain overload, simply pass in the set of parameters that match the overload you want to use.\n\nHow can you tell which parameters you need to enter?\n\nDepending on your text editor, you may be able to preview what other functionality a method can support, as you’re writing it.\n\nLike in Visual Studio, using the up and down arrow keys:\n\nEach overload method is made unique by the parameters it accepts, and no two overloads can accept the same parameters in the same order.\n\nBecause of this, to use an overload method, you’ll need to enter the exact set of parameters it requires, in the right order.\n\nThis can sometimes mean that, to use a specific overload, you may need to pass in parameters for functionality you don’t actually need.\n\nRaycast supports a large number of overload methods (16 at the time of writing this) so chances are good that one of them will offer the functionality you want with minimal extra fuss.\n\nSo what can you do with different Raycast overload methods?\n\nMost of the overload methods available for Physics.Raycast also allow you to specify a max distance as a float value.\n\nSetting a max distance can be useful for creating distance-limited functionality, such as weapons that can only shoot so far, or simply to avoid complications from Rays that extend infinitely across your scene. Not only is it useful, it’s also good for performance to limit the extent of a Ray, which is why it’s no surprise that many of Raycast’s overload methods (12 to be precise) accept a parameter for max distance.\n\nWhile setting a distance can be useful for limiting the reach of a Ray, there will often be times when Raycasts intersect with many different types of collider.\n\nHow you distinguish between the different types of objects in your game is entirely up to you.\n\nHowever, one option that works particularly well with Raycasts, is to use layers.\n\nHow to use Layer Masks with Raycasts\n\nOne of the most helpful features of the Raycast function is the ability to filter out colliders depending on their layer.\n\nThis allows you to completely ignore objects on layers that aren’t intended to collide with Raycasts.\n\nAs you can imagine, this can be extremely useful when you’re working with a large scene, with many different types of objects and colliders and you only want to check for collisions against some of them.\n\nSo how does it work?\n\nFor example, let’s say that all of the environment objects in my scene are on the same layer, the world layer, and that I only want to detect collisions on that layer.\n\nAll I need to do is declare a public Layer Mask variable…\n\nSet it in the Inspector to match the world layer:\n\nAnd then, in my script, pass the Layer Mask variable into the Raycast function.\n\nIn this case, I’m using an overload method that accepts a Ray, a Max Distance and a Layer Mask variable.\n\nIn order to use this version of Raycast I have to add all of those parameters in the correct order.\n\nHow to enter the layer number directly when using Layer Masks with Raycasts in Unity\n\nUsing a public Layer Mask variable is the easiest way to use Layer Masks with Raycasts.\n\nHowever, if you want to do it all in scripting, and pass in the value of the Layer Mask directly, here’s how to do it.\n\nIf you’re anything like me, and because the Layer Mask parameter takes an int value, you might assume that you can just enter the number of the layer, for example, layer 9, in the Raycast function and that will work.\n\nThis is because, while the Layer Mask value is an int, Unity uses the binary representation of the integer to decide which layers will be checked and which will not.\n\nImagine all of Unity’s 32 possible Layers as a row of zeroes, starting with the first layer (layer 0) on the right.\n\nNow, let’s say that I want to check Raycasts against one of those layers.\n\nLayer 9 is tenth in the list, so if I change the tenth zero from the right to a 1, like this:\n\nUnity now knows that I only want to check Raycasts against layer 9.\n\nExcept that this is still a binary value. It’s still not the integer number that the Raycast function requires.\n\nSo how do you convert it?\n\nBinary numbers work by counting, from right to left, which multiples make up a number.\n\nFor example, the number 8, in binary, is 1000. Because it is made up, from right to left, of no ones, no twos, no fours and one eight:\n\nWhereas Nine, would look like this:\n\nThe binary value I’m using, when converted to an integer, is 512.\n\nWhich I can add directly to the Raycast function to indicate that I want to check collisions on layer 9.\n\nI could even use the binary value to indicate multiple layers.\n\nFor example, layer 9 and layer 4:\n\nWhich works out to be 528.\n\nHow to convert an Int to a Layer Mask value\n\nWhile converting a binary value to an integer works, it isn’t the most convenient method.\n\nEspecially if all you want to be able to do is enter the integer value of the layer you want.\n\nLuckily there’s an easy way to directly add layer numbers in scripting.\n\nThe bitwise left shift operator (<<) moves the bits of a binary value to the left by a defined amount.\n\nWhy is this useful?\n\nIt allows you to quickly enter a Layer Mask value without having to check what it would be in binary first.\n\nTo use it, simply shift the bit values of the number 1 over by the number of the layer you want to use.\n\nFor example, to enter layer 9, I’d simply shift 1 by 9.\n\nThis works best when you want to identify a single layer to detect collisions on.\n\nBut what if you want to detect collisions on all of the layers in a game except one, how could you do that?\n\nDetect Raycast on all layers except for one\n\nJust like when using a Layer Mask to limit collisions to a certain layer, It’s possible to invert the Layer Mask value so that it detects collisions on every layer, except for one.\n\nThis can be done with the bitwise NOT operator.\n\nThe bitwise NOT operation use the tilde symbol (~) and will flip every bit in a value, essentially inverting it.\n\nFor example, if I want to detect collisions on every layer, except for the world, I can simply invert the Layer Mask value.\n\nIf you’re adding the Layer Mask directly to code using the bitwise operator, you’ll want to place it in parentheses first, so that the bitwise operation is carried out before inverting the value.\n\nWhile layers can be incredibly useful for including or excluding entire categories of object, you may still find yourself needing to exclude specific colliders from being hit.\n\nFor example, you may not want Raycasts to hit trigger colliders in the world but it may be that placing them on a separate layer just isn’t an option.\n\nLuckily, there’s an easy way to exclude or include trigger colliders from receiving Raycast hits.\n\nHow to ignore trigger colliders when using Raycast\n\nBy default, Raycast will hit triggers, meaning that if a Raycast impacts a trigger collider, it’ll behave in the same way as hitting any other collider.\n\nIt’s possible to change this behaviour, either globally via a project setting or on a per Raycast basis.\n\nHow to disable all Raycast Trigger collisions\n\nThe easiest way to disable all Raycast trigger collisions is to simply turn them off.\n\nOpen Project Settings, select the Physics menu (or Physics 2D menu if you’re working in 2D) and uncheck Queries Hit Triggers.\n\nNow, by default, Raycasts will ignore all trigger collisions.\n\nEven with this setting turned off it’s still possible to override the behaviour of individual Raycasts using the Query Trigger Interaction parameter.\n\nIn this overload method, I had to enter a Ray, max distance and Layer Mask in order to use the Query Trigger Interaction feature.\n\nYou might also have noticed that Query Trigger Interaction isn’t a true or false boolean value.\n\nInstead, it’s an enum, which is essentially a set of named values, allowing you to choose one of 3 options:\n\nUse Global – which defers to the default value set in the physics options.\n\nUsing the built-in functionality of Raycast’s overload methods is the easiest and the most appropriate way of filtering out objects that you don’t want Raycast to hit.\n\nIt allows you to completely ignore certain objects, or even entire layers of objects, that aren’t intended to be used with Rays.\n\nWhich is great for reducing the number of objects that could be hit.\n\nBut what if you want to hit more objects?\n\nAnd what if you want to hit multiple objects all at once?\n\nFor example, if you want to create a weapon that can cut through multiple enemies or detect multiple objects using a single ray.\n\nAfter all, the default Raycast function stops after hitting a target, so how can you fire a Ray that can pass through multiple objects?\n\nHow to hit multiple objects using Raycast\n\nWhile Raycast is useful for identifying or colliding with single objects, sometimes you might want to use Raycast to detect collisions against multiple objects using the same Ray.\n\nFor example, you might want to create a weapon that fires through multiple enemies.\n\nOr you might want to be able to detect and count how many objects are within a certain range.\n\nFor that, you’ll need to use Raycast All.\n\nHow to use Raycast All\n\nRaycast All works a lot like Raycast, except that instead of hitting and returning only one object it can return multiple objects, storing them in an array.\n\nTo use Raycast All, you’ll need to declare an array of Raycast Hit variables and assign them when you call the Raycast All function.\n\nRaycast All is useful for getting information about multiple objects using a single Ray.\n\nFor example, you could count how many colliders were hit by a Ray.\n\nOr you could destroy all of the objects in a Ray’s path.\n\nRaycast All works great for getting all of the objects that collide with a Ray.\n\nWhile Raycast All can detect multiple colliders, it retrieves them in an undefined order.\n\nSo, while it’s often helpful to think of Raycast All as a laser travelling through objects one by one, it doesn’t actually happen that way.\n\nInstead, all of the objects that are intersected by the ray are detected at the same time, and the order in which they’re added to the array can’t be guaranteed.\n\nThis means that, for example, if you wanted to destroy multiple objects in a line by firing a ray through them, one by one, they won’t be destroyed in order along the Ray’s path.\n\nInstead, it will more than likely happen randomly.\n\nThis isn’t necessarily a problem if you’re carrying out an action on all of the objects at the same time.\n\nHowever, if you want to get the objects in order from the origin of the ray, you’re going to need to sort the results.\n\nHere’s how to do that…\n\nHow to detect Multiple Raycast hits in order (by sorting the array)\n\nThere are a ton of different ways to sort array and list results in Unity.\n\nHowever, in this example, I’m going to show you one of the simplest methods I’ve found to sort an array, without converting it to a list first.\n\nFor this to work, you’ll need to add the System Namespace to the top of your script:\n\nThen, once you’ve got the Raycast Hit results stored in an array, you can sort their order.\n\nThis function basically determines how any two results (x and y) should be compared.\n\nIn this case, they’re being compared by their distance, which is a property of the Raycast Hit struct and is measured from the origin of the Ray to the point of impact with the collider.\n\nRaycast Non-Alloc is an alternative version of Raycast All that works in a similar way, except that it doesn’t generate any garbage.\n\nThis is because, while Raycast All returns a new Raycast Hit array each time it’s called, Raycast Non-Alloc stores its results in a fixed array, which limits the number of results it can return.\n\nWhen you call it, the function returns an integer, equal to the number of colliders that the Ray hit, but no more than the length of the array it stores its results in.\n\nThis is useful, as knowing how many results were actually returned makes it easier to avoid referencing empty elements when the array isn’t full.\n\nSo when would you use Raycast Non-Alloc?\n\nRaycast Non-Alloc is generally a more efficient version of Raycast All.\n\nHowever… just like Raycast All, Raycast Non-Alloc returns results in an undefined order.\n\nThis means that if you try to use Raycast Non-Alloc as a method for limiting the number of Raycast Collisions, for example, you want to build a weapon that fires through up to 3 enemies, you may not get the results you want.\n\nUsing Raycast Non-Alloc in this way will return 3 results, but there’s no guarantee that they will be the closest 3 results, even if you sort the Array.\n\nWhile it might seem like a good idea to use Raycast Non-Alloc to limit collisions for performance purposes, this isn’t really why it’s efficient.\n\nThe main benefit of using Raycast Non-Alloc is to avoid repeatedly allocating new arrays, which prevents garbage and improves performance.\n\nSo, to use it effectively, you may actually find it’s better to use a large fixed array, one that’s big enough to accommodate the maximum number of results you’re likely to need at any given time, while using function features, such as Layer Masks and max distance, to filter the initial results for performance.\n\nOn balance, and depending on the type of results you want to get back, you may find it’s more convenient for you to use Raycast All.\n\nAnd, in many cases, this will be fine…\n\nHowever, if you find yourself using it frequently, or you’re calling it from multiple objects, you may be better off using Raycast Non-Alloc instead.\n\nIn many cases, it’s better to use Raycast in Update, however, this largely depends on what you’re trying to do.\n\nTypically, because Raycast is a Physics function, you might think to put Raycast in Fixed Update, which is called every physics step, instead of Update, which is called every frame.\n\nFixed Update is designed to perform actions in sync with the physics system, which will often run at a different frequency to Update.\n\nIf the game’s framerate is low, then Fixed Update may run faster than Update, being called several times during a frame. However, if the game’s framerate is high, Fixed Update may not be called at all during a frame.\n\nA typical use of Fixed Update is for continuous physics functions. For example, when applying force to a Rigidbody, doing it in Fixed Update means that the force is applied in sync with the physics system that is reacting to it.\n\nWhile Raycast is a physics function, what you’re doing with it may actually be more suited to Update.\n\nA lot of the time, you’ll be using Raycast as a check.\n\nFor example, was something in the line of fire when I clicked the mouse button?\n\nWas the player close enough to the ground when the jump button was pressed?\n\nIs the player looking at the object they just tried to pickup?\n\nAll of these examples are dependent on a player input condition that’s designed to be used Update, and trying to put functions like that in Fixed Update is going to cause problems.\n\nFor example, in extreme circumstances where the framerate of the game is slower than the physics system, a click that’s measured on a per-frame basis will be true every time Fixed Update is called during that frame. This would mean that even though you clicked once, the action could be called multiple times.\n\nWhereas, if the physics system is running much slower than the framerate, Fixed Update might not be called while the button is pressed, and the click may not be recognised at all.\n\nInstead, even though Raycast is Physics-based, placing the mouse click condition in Update, where it would normally be, solves this problem:\n\nThis works because the Raycast is a one-time event, that’s simply reporting the state of the Physics system at the time of the check.\n\nBut what about continuous checks?\n\nThere may be times when you’re making constant Raycast calls to check for colliders.\n\nSo should they be made from Update, or Fixed Update?\n\nAgain, it depends on what you’re trying to do as a result of the Raycast check.\n\nIf the resulting action of the continuous check is something you would normally put in Update, then use Update.\n\nThis will keep the action in sync with the game’s framerate.\n\nIf the resulting action is something you would normally place in Fixed Update, then it’s a good idea to use Fixed Update for the Raycast check and the resulting action.\n\nFor example, making an object hover by applying force to a Rigidbody when it gets close to the ground.\n\nBoth the Raycast check and the hover action are designed to work with Physics steps so, in this scenario, you’ll get more consistent results by using Fixed Update.\n\nHow to use Raycast in Unity in 2D\n\nRaycast is a physics-based function, meaning that, depending on which version you use, it derives from either the Physics Class or a related class, such as the Collider Class.\n\nIn Unity, the 3D and 2D physics engines are separate, meaning that, if you want to use Raycast in 2D, you’ll need to use a different version of Raycast that derives from the 2D physics engine and its classes. For example, Physics2D.Raycast or Collider2D.Raycast.\n\nRaycasts in 3D vs Raycasts in 2D\n\nGenerally, the 2D versions of Raycast work in a similar way to the standard, 3D versions, but with a few key differences.\n\nFor example, while many versions of Raycast return a boolean value (which returns true if the Ray hits something and false if it doesn’t), this isn’t the case with the 2D versions of Raycast.\n\nInstead of returning a boolean, Physics2D.Raycast returns a Raycast Hit 2D value.\n\nIf the Raycast hits a collider, the function will return Raycast Hit 2D information. If it doesn’t hit anything, it returns null, which is why it’s still possible to use Physics2D.Raycast in an if condition, even though it doesn’t return a boolean value.\n\nHowever, this does mean that, unlike the 3D version, where you would normally save hit data using the out keyword, if you want to access information about what was hit, you’ll need to declare a Raycast Hit 2D variable first.\n\nJust like the 2D version of the standard Raycast function, the 2D version of Collider.Raycast works differently to its 3D counterpart.\n\nUnlike the 3D version of Collider.Raycast, which takes a Ray parameter and looks specifically for the one collider that it’s called from, Collider2D.Raycast fires a ray from the collider it’s called from and looks for other colliders to hit (while ignoring its own).\n\nCollider2D.Raycast has an integer return type, which is equal to the number of colliders that were intersected by the Raycast, storing the results in an array.\n\nWhich means, to use Collider2D.Raycast, you’ll need to declare and initialise an array to hold the results.\n\nTo create a Raycast Hit 2D array, you’ll need to declare and initialise it in your script. This is because the Raycast Hit 2D data type won’t appear in the Inspector so, unlike other arrays, you won’t be able to set the length of the array manually.\n\nThis will create a new Array with a length of Ten.\n\nThe length of the array determines how many Colliders can be counted by the Raycast function.\n\nSo, for example, if you initialise the array at ten, even if the ray intersects 12 colliders, the integer value that you get back will be capped at ten.\n\nCollider2D.Raycast works in a similar way to the Non-allocating version of Raycast All. Except that, in 2D, Raycast All Non-Alloc will also detect colliders that overlap the ray’s origin.\n\nWhich can be inconvenient if you’re calling the function from an object with a collider that you want to ignore.\n\nInstead, Collider2D.Raycast ignores its own collider and looks for others, without generating any garbage.\n\nThis is because it reuses the same fixed array instead of making a new one each time.\n\nThere’s also an alternative version of Collider2D.Raycast that stores its results in a List instead of an array:\n\nThis is useful when you want to limit the garbage allocation of the Raycast function but you don’t want to place a limit on the number of objects that can be detected, as the List will be resized, but only as needed when the function is called.\n\nThe 2D version of Raycast All sorts its results\n\nUnlike the 3D version of Raycast All, which stores results in an undefined order, the 2D version of Raycast All sorts its results by distance from the origin.\n\nThis is useful if you want to, for example, destroy objects in a line or affect multiple objects based on their distance from the Ray’s origin, without needing to sort the array.\n\nUnlike the 3D version of Raycast, which relies on manually setting a Layer Mask or trigger settings in the function’s parameters, Raycast in 2D allows you to use a Contact Filter 2D parameter to easily include or exclude certain objects from being hit.\n\nIt can also be declared publicly, meaning that you can apply the settings you want directly in the Inspector.\n\nIt can then passed into any overload methods of Raycast that support using Contact Filters.\n\nSuch as this one:\n\nIf, however, you want to use an overload method of Raycast that requires a Contact Filter, but you don’t actually want to use a Contact Filter, you can do that too.\n\nSimply declare a Contact Filter variable and use the No Filter function to prevent the filter from excluding any results."
    },
    {
        "link": "https://medium.com/@lemapp09/beginning-game-development-physics-raycast-1dfa79223f41",
        "document": "1. What is Physics.Raycast: A powerful Unity 3D feature that casts a virtual ray from one point to another, detecting collisions.\n\n2. Usage: Commonly used in game mechanics like shooting, AI vision, and object interaction.\n\n3. How to Use: Implemented through scripting in C#, requires a starting point, direction, and length.\n\n4. Alternatives: Physics.RaycastAll, Physics.SphereCast, Collider triggers, etc.\n\n5. Sample Script: A simple C# example illustrating how to use Physics.Raycast.\n\nPhysics.Raycast is a feature in Unity 3D that allows you to cast a virtual “ray” from a starting point in a particular direction to detect any colliders along the path of the ray. It’s a part of the Unity physics engine and serves as a way to query the game world. Think of it as a laser pointer that can find out what it’s pointing at, without any physical interaction.\n\nPhysics.Raycast is used across various game development scenarios, including but not limited to:\n\n- Shooting Mechanisms: To detect if a bullet would hit a target.\n\n- AI Sensing: To check the visibility of game characters or objects.\n\n- Object Interactions: To identify objects the player can interact with.\n\n- Debugging: To visually debug rays in the Unity Editor during development.\n\nHow to Use Physics.Raycast\n\nTo use Physics.Raycast, you’ll be dealing primarily with C# scripts in Unity. The simplest version of a Physics.Raycast function takes a `Ray` object as its argument and returns a boolean value indicating whether the ray hit any collider.\n\nHowever, it’s more common to use it with more parameters, such as:\n\n- origin: The starting point of the ray.\n\n- direction: The direction in which the ray should go.\n\n- hitInfo: A RaycastHit object to store information about what was hit.\n\n- maxDistance: The maximum distance the ray should travel.\n\n- layerMask: The layer(s) to include in the collision detection.\n\nThere are various ways to accomplish similar collision detection in Unity:\n\n- Physics.RaycastAll: Returns all hits along the ray path.\n\n- Physics.SphereCast: Similar to a ray but has volume, simulating a sphere rolling along the ray.\n\n- Collider Triggers: Use Unity’s built-in trigger events to detect when objects intersect.\n\n- Custom Algorithms: Implementing your own line-based or point-based collision detection.\n\nSample Script\n\nHere’s a simple C# script that uses Physics.Raycast to detect objects in front of a camera:\n\nThis script casts a ray from the object’s current position in the direction it’s facing. If the ray hits an object within 100 units, it logs the name of the object hit.\n\nWith this guide, you should have a good understanding of how to utilize Physics.Raycast in Unity 3D to improve your game mechanics. Whether you’re working on an FPS game or a complex simulation, Physics.Raycast can be an invaluable tool for querying the game world around you.\n\nPhysics.Raycast is a method in Unity that is used to perform raycasting in a physics simulation:citation[1]. Raycasting is a technique that determines if a ray intersects with any colliders in the scene:citation[2].\n\nThe Physics.Raycast function takes a ray as input and returns true if the ray hits a collider, or false if it doesn’t:citation[3]. The parameters of Physics.Raycast are the origin of the ray, the direction of the ray, and the maximum distance the ray can travel:citation[1].\n\nIn addition to whether or not a ray intersects a collider, Physics.Raycast can also return additional information about the intersection, such as the point on the surface that the ray hit and the normal of that surface:citation[4].\n\nPhysics.Raycast is commonly used for various game mechanics such as detecting object collisions, implementing shooting mechanics, or performing line-of-sight checks\n\n{“source”: \"https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Physics.Raycast.html\", “reason”: “Explains a specific usage of Physics.Raycast for line-of-sight checks”}. Here is an example of how to use Physics.Raycast to detect collisions between a ray and colliders in your scene:\n\nIt is important to note that for Physics.Raycast to function, the objects in the scene must have colliders and rigidbodies. Also, keep in mind the performance implications when doing raycasts:citation[5]. Specifically, performing numerous or complex raycasts might impact the game’s performance, so it’s crucial to use them wisely.\n\n[1] Provides information about …\n\n[2] Explains how to specify a …\n\n[3] Describes the return value …\n\n[4] Provides additional information …\n\n[5] Explanation of how the Raycast …"
    },
    {
        "link": "https://learn.unity.com/tutorial/let-s-try-shooting-with-raycasts",
        "document": "In this Let's Try tutorial we will learn how to shoot using Raycasts. This tutorial provides both a video walkthrough and and article version of the instructions."
    },
    {
        "link": "https://patrykgalach.com/2021/03/08/different-types-of-raycasts-in-unity",
        "document": ""
    }
]