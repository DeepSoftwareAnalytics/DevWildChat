[
    {
        "link": "https://cplusplus.com/doc/tutorial/files",
        "document": "std; main () { ofstream myfile ( ); (myfile.is_open()) { myfile << ; myfile << \"This is another line.\n\n\" ; myfile.close(); } cout << ; 0; }\n\n[file example.txt] This is a line. This is another line."
    },
    {
        "link": "https://geeksforgeeks.org/file-handling-c-classes",
        "document": "File handling is used to store data permanently in a computer. Using file handling we can store our data in secondary memory (Hard disk).\n\nHow to achieve the File Handling\n\nFor achieving file handling we need to follow the following steps:-\n\n STEP 1-Naming a file\n\n STEP 2-Opening a file\n\n STEP 3-Writing data into the file\n\n STEP 4-Reading data from the file\n\n STEP 5-Closing a file.\n\nWe give input to the executing program and the execution program gives back the output. The sequence of bytes given as input to the executing program and the sequence of bytes that comes as output from the executing program are called stream. In other words, streams are nothing but the flow of data in a sequence.\n\nThe input and output operation between the executing program and the devices like keyboard and monitor are known as “console I/O operation”. The input and output operation between the executing program and files are known as “disk I/O operation”.\n\nThe I/O system of C++ contains a set of classes which define the file handling methods. These include ifstream, ofstream and fstream classes. These classes are derived from fstream and from the corresponding iostream class. These classes, designed to manage the disk files, are declared in fstream and therefore we must include this file in any program that uses files. File handling is essential for data storage and retrieval in applications.\n• None This class is the base class for other classes in this class hierarchy.\n• None This class contains the necessary facilities that are used by all the other derived classes for input and output operations.\n• None This class is derived from the class ‘ios’.\n• None The extraction operator(>>) is overloaded in this class to handle input streams from files to the program execution.\n• None This class declares input functions such as get(), getline() and read().\n• None This class is derived from the class ‘ios’.\n• None The insertion operator(<<) is overloaded in this class to handle output streams to files from the program execution.\n• None This class declares output functions such as put() and write().\n• None This class contains a pointer which points to the buffer which is used to manage the input and output streams.\n• None This class provides operations common to the file streams. Serves as a base for fstream, ifstream and ofstream class.\n• None This class contains open() and close() function.\n• None It contains open() function with default input mode.\n• None Inherits the functions get(), getline(), read(), seekg() and tellg() functions from the istream.\n• None It contains open() function with default output mode.\n• None Inherits the functions put(), write(), seekp() and tellp() functions from the ostream.\n• None This class provides support for simultaneous input and output operations.\n• None Inherits all the functions from istream and ostream classes through iostream.\n• None Its purpose is to set the file buffers to read and write.\n• None We can also use file buffer member function to determine the length of the file. \n\n\n\nIn C++, files are mainly dealt by using three classes fstream, ifstream, ofstream available in fstream headerfile. \n\nofstream: Stream class to write on files \n\nifstream: Stream class to read from files \n\nfstream: Stream class to both read and write from/to files.\n\nNow the first step to open the particular file for read or write operation. We can open file by \n\n1. passing file name in constructor at the time of object creation \n\n2. using the open method\n\nBoth ios::app and ios::ate take us to the end of the file when it is opened. The difference between the two modes is that ios :: app allow us to add data to the end of the file only, while ios :: ate mode permits us add data or to modify the existing data anywhere in the file.\n\nProblem Statement : To read and write a File in C++. \n\nExamples:\n\nBelow is the implementation by using ifstream & ofstream classes.\n\nBelow is the implementation by using fstream class."
    },
    {
        "link": "https://cplusplus.com/doc/oldtutorial/files",
        "document": "\n• fstream: Stream class to both read and write from/to files.\n• When the file is closed: before closing a file all buffers that have not yet been flushed are synchronized and all pending data is written or read to the physical medium.\n• When the buffer is full: Buffers have a certain size. When the buffer is full it is automatically synchronized.\n• Explicitly, with manipulators: When certain manipulators are used on streams, an explicit synchronization takes place. These manipulators are: and .\n• Explicitly, with member function sync(): Calling stream's member function , which takes no parameters, causes an immediate synchronization. This function returns an value equal to if the stream has no associated buffer or in case of failure. Otherwise (if the stream buffer was successfully synchronized) it returns .\n\nC++ provides the following classes to perform output and input of characters to/from files:These classes are derived directly or indirectly from the classes, and. We have already used objects whose types were these classes:is an object of classandis an object of class. Therefore, we have already been using classes that are related to our file streams. And in fact, we can use our file streams the same way we are already used to useand, with the only difference that we have to associate these streams with physical files. Let's see an example:This code creates a file calledand inserts a sentence into it in the same way we are used to do with, but using the file streaminstead.But let's go step by step:The first operation generally performed on an object of one of these classes is to associate it to a real file. This procedure is known as to. An open file is represented within a program by a stream object (an instantiation of one of these classes, in the previous example this was) and any input or output operation performed on this stream object will be applied to the physical file associated to it.In order to open a file with a stream object we use its member functionWhereis a null-terminated character sequence of type(the same type that string literals have) representing the name of the file to be opened, andis an optional parameter with a combination of the following flags:All these flags can be combined using the bitwise operator OR (). For example, if we want to open the filein binary mode to add data we could do it by the following call to member functionEach one of themember functions of the classesandhas a default mode that is used if the file is opened without a second argument:Forandclasses,andare automatically and respectively assumed, even if a mode that does not include them is passed as second argument to themember function.The default value is only applied if the function is called without specifying any value for the mode parameter. If the function is called with any value in that parameter the default mode is overridden, not combined.File streams opened in binary mode perform input and output operations independently of any format considerations. Non-binary files are known as, and some translations may occur due to formatting of some special characters (like newline and carriage return characters).Since the first task that is performed on a file stream object is generally to open a file, these three classes include a constructor that automatically calls themember function and has the exact same parameters as this member. Therefore, we could also have declared the previousobject and conducted the same opening operation in our previous example by writing:Combining object construction and stream opening in a single statement. Both forms to open a file are valid and equivalent.To check if a file stream was successful opening a file, you can do it by calling to memberwith no arguments. This member function returns a bool value of true in the case that indeed the stream object is associated with an open file, or false otherwise:When we are finished with our input and output operations on a file we shall close it so that its resources become available again. In order to do that we have to call the stream's member function. This member function takes no parameters, and what it does is to flush the associated buffers and close the file:Once this member function is called, the stream object can be used to open another file, and the file is available again to be opened by other processes.In case that an object is destructed while still associated with an open file, the destructor automatically calls the member functionText file streams are those where we do not include theflag in their opening mode. These files are designed to store text and thus all values that we input or output from/to them can suffer some formatting transformations, which do not necessarily correspond to their literal binary value.Data output operations on text files are performed in the same way we operated withData input from a file can also be performed in the same way that we did withThis last example reads a text file and prints out its content on the screen. We have created a while loop that reads the file line by line, using. The value returned byis a reference to the stream object itself, which when evaluated as a boolean expression (as in this while-loop) is true if the stream is ready for more operations, and false if either the end of the file has been reached or if some other error occurred.In addition to, which checks whether the stream is ready for input/output operations, other member functions exist to check for specific states of a stream (all of them return a bool value):In order to reset the state flags checked by any of these member functions we have just seen we can use the member function, which takes no parameters.All i/o streams objects have, at least, one internal stream pointer:, like, has a pointer known as thethat points to the element to be read in the next input operation., like, has a pointer known as thethat points to the location where the next element has to be written.Finally,, inherits both, the get and the put pointers, from(which is itself derived from bothand).These internal stream pointers that point to the reading or writing locations within a stream can be manipulated using the following member functions:These two member functions have no parameters and return a value of the member type, which is an integer data type representing the current position of the get stream pointer (in the case of) or the put stream pointer (in the case of).These functions allow us to change the position of the get and put stream pointers. Both functions are overloaded with two different prototypes. The first prototype is:Using this prototype the stream pointer is changed to the absolute position(counting from the beginning of the file). The type for this parameter is the same as the one returned by functionsand: the member type, which is an integer value.The other prototype for these functions is:Using this prototype, the position of the get or put pointer is set to an offset value relative to some specific point determined by the parameteris of the member type, which is also an integer type. Andis of type, which is an enumerated type () that determines the point from where offset is counted from, and that can take any of the following values:The following example uses the member functions we have just seen to obtain the size of a file:In binary files, to input and output data with the extraction and insertion operators (and) and functions likeis not efficient, since we do not need to format any data, and data may not use the separation codes used by text files to separate elements (like space, newline, etc...).File streams include two member functions specifically designed to input and output binary data sequentially:and. The first one () is a member function ofinherited by. Andis a member function ofthat is inherited by. Objects of classhave both members. Their prototypes are:Whereis of type \"pointer to char\" (), and represents the address of an array of bytes where the read data elements are stored or from where the data elements to be written are taken. Theparameter is an integer value that specifies the number of characters to be read or written from/to the memory block.In this example the entire file is read and stored in a memory block. Let's examine how this is done:First, the file is open with theflag, which means that the get pointer will be positioned at the end of the file. This way, when we call to member, we will directly obtain the size of the file. Notice the type we have used to declare variableis a specific type used for buffer and file positioning and is the type returned by. This type is defined as an integer type, therefore we can conduct on it the same operations we conduct on any other integer value, and can safely be converted to another integer type large enough to contain the size of the file. For a file with a size under 2GB we could useOnce we have obtained the size of the file, we request the allocation of a memory block large enough to hold the entire file:Right after that, we proceed to set the get pointer at the beginning of the file (remember that we opened the file with this pointer at the end), then read the entire file, and finally close it:At this point we could operate with the data obtained from the file. Our program simply announces that the content of the file is in memory and then terminates.When we operate with file streams, these are associated to an internal buffer of type. This buffer is a memory block that acts as an intermediary between the stream and the physical file. For example, with an, each time the member function(which writes a single character) is called, the character is not written directly to the physical file with which the stream is associated. Instead of that, the character is inserted in that stream's intermediate buffer.When the buffer is flushed, all the data contained in it is written to the physical medium (if it is an output stream) or simply freed (if it is an input stream). This process is calledand takes place under any of the following circumstances:"
    },
    {
        "link": "https://dev.to/tbhaxor/a-comprehensive-guide-to-file-handling-in-c-2p1b",
        "document": "Hello World! You have been working with data in the program and struggling with saving its states across multiple restarts. Yeah, I know that is temporary and will be gone as the program exists. In this post, I will teach you how you can use C++ file handling and save not only text data into it but also binary data like Class or Struct.\n\nYou can clone the repository for all the snippets and source code used in this tutorial https://github.com/tbhaxor/cpp-file-handling-tutorial.\n• Why do you need File Handling Anyway?\n• Check Whether the File is Open or Not\n• Using I/O Streams of the File\n\nWhy do you need File Handling Anyway?\n\nThe program state gets vanished when it is exited or the functions go out of scope during execution. Sometimes it's required to have the states for future execution.\n\nTake the example of a game, you don't play it continuously. Saving the same and loading it later is very basic. I had first seen this in the Project IGI game and then Age of Empires. Nowadays multiplayer games are getting popular and they use databases to store this information.\n\nThat's a great idea to use databases. So why not use the database, it can be shared easily. Let me tell you that there is no different magic going on there, DBMS uses files to store the data. So it boils down to file handling.\n\nThere are and will be 2 types of operation in the file: Read file will allow you to retrieve the content and write file will allow you to put the content into the file using the current stream. A stream is basically a channel that carries your data from/to the file.\n\nclass is used to open the file in reading mode and is used to open the file in the write mode.\n\nThese classes provide different methods and properties as an abstraction to deal with files, or I would say even the large files.\n\nThere are two types of files: Human readable (or text) and human non-readable (binary).\n\nIt is easy to determine whether a file is a text or binary: If you open a file in a text editor (let's assume notepad or vscode), it will show all the characters and you can pronounce them. They might or might not make sense, but it's not required here. This file is a text file. If you are unable to pronounce any character, then that file is a binary file.\n\nWhile seeing the file format and the number of total bytes, we can determine that there are n bytes in the file that can be read, but how does an opened stream will know in general? EOF is also known as End-of-File in computing. It is a condition or a notification to the file reader that tells no more retrieve more information from the file and seems like it is ended.\n\nWhen you try to read a file and it is failed, both failed and eof bits are set in the error flags. You can use method to get this information.\n\nSo when does this bit set? An EOF bit is set after the ifstream reader tried to read the contents from the file and fails while the stream is still good (there is no error while performing I/O operations). So at least in the case of an ifstream, it waits for the OS to tell it that there's no more data read more\n\nProgrammatically, it will look like the following\n\n\n\nEnough talking, let's start by writing a text content into the file using . Before all of that, you need to instantiate the ofstream and open the file:\n\n\n\nThe function, as it says, open the file with name (first argument) and the mode (second argument).\n\nI will discuss different modes with you as we proceed, mode is used to tell the function, that opens the file in write mode, overwrite the contents of it if it exists or create a new one.\n\nNow it's time to write into the file stream using the left shift operator . This will format all your data into before writing.\n\n\n\nSince we are using a pointer variable, therefore it is required to dereference the file handle to access the operator from the object stored.\n\nReading is pretty simple and uses and operator with mode.\n\n\n\nFor reading files in text mode, there is only one option \n\n\n\nWhen you write a file with it formats whitespaces and streams that to the file, but while reading the content, it will stop at either EOF or the first whitespace character hit.\n\nEOL or End-of-line is defined by the character or and is considered as the whitespace. So if there are multiple lines, you can use the function.\n\n\n\nCheck Whether the File is Open or Not\n\nTill now we are believing that the file exists and is ready for any I/O operation, but what if the condition is otherwise? What if it failed to open? Will it throw an error?\n\nThe answer to the question is, NO. It will not throw error but the RW will not work. You can use or . The functions returns boolean value, so if the file is actually opened successfully, it will return true.\n\n\n\nWhen you are done with the file operations, it is recommended to close the file handle which will dispose of the file stream after writing any pending sequence of characters and clearing the buffer for both input and output streams.\n\nFor this you can use or .\n\n\n\nIf the file is not successfully opened, the function will fail and set the flag.\n\nWhat if you want to append the data into the file without losing old content. In the , it overwrites the file and reading the content of files, appending in memory and then writing to a file doesn't seem to be a space and time-efficient solution.\n\nThere is another mode of opening the file that you can use in place of , which is append mode . This will allow you to write from the end of the file to the size of the data.\n\nWhen you choose to open the file with append mode, the put cursor of the handle is set at the end of the file.\n\n\n\nSo far you have seen me dealing with the text file, but in the real world, there are more than binary files with the custom format, like Zip archives, PDF files and other document files.\n\nTo open the file in binary mode, you need to specify mode in the method of or .\n\n\n\nFor reading and writing, you must use and because the binary file saves the raw bytes and does not perform any kind of formatting.\n\nWith this, you can now store the object of structs or classes directly into the file without serializing it into the textual format. It will be then automatically deserialized when the file is read.\n\nLet's create a simple class called that will have name and age fields and a whoami() method to return a std::string object.\n\n\n\nYou can save this to a file using the following snippet by casing it to because of its definition in the stdc++. read more\n\n\n\nOnce this is successfully saved into the file, you will verify that there are some weird characters present in the file and that is normal, because the string data also stores the information of deserializing the object.\n\n\n\nNow as a beginner, you must be thinking that the type is different from the type. So why does the casting pointer not affect serialization? I would like to tell you that, you are getting confused between pointer type and other data types. For any data type, the pointer type would be 8 bytes or 4 bytes based on the CPU architecture, because it stores the starting address of the memory where that actual data of a type is stored. If the type of data is char, then it will consume 1 byte in the memory otherwise .\n\nUsing I/O Streams of the File\n\nIt is not like you can open a file only in one mode (that is either read or write), using you can perform both input/output operations on the file with the same file handle.\n\nThere are two types of cursors in the file et and ut. The get cursor is responsible for handling reading from the file which is known as input operation and the put cursor is responsible for handling writing into the file which is known as output operation.\n\nTo get the current position of the cursors, use the or . You can also set the position of these cursors making (either forward or backward) while the file is open using or functions.\n\nYou can also seek the cursor relatively based on the three types of the seek directions\n• — from the beginning of file\n• — from the current position of the cursor\n• — from the ending of the file or where the reader hits EOF"
    },
    {
        "link": "https://edureka.co/blog/file-handling-in-cpp",
        "document": "Whether it is the programming world or not, files are vital as they store data. This article discuss working of file handling in C++. Following pointers will be covered in the article,\n\nFiles are used to store data in a storage device permanently. File handling provides a mechanism to store the output of a program in a file and to perform various operations on it.\n\nA stream is an abstraction that represents a device on which operations of input and output are performed. A stream can be represented as a source or destination of characters of indefinite length depending on its usage.\n\nIn C++ we have a set of file handling methods. These include ifstream, ofstream, and fstream. These classes are derived from fstrembase and from the corresponding iostream class. These classes, designed to manage the disk files, are declared in fstream and therefore we must include fstream and therefore we must include this file in any program that uses files.\n\nIn C++, files are mainly dealt by using three classes fstream, ifstream, ofstream.\n• ofstream: This Stream class signifies the output file stream and is applied to create files for writing information to files\n• ifstream: This Stream class signifies the input file stream and is applied for reading information from files\n• fstream: This Stream class can be used for both read and write from/to files.\n\nAll the above three classes are derived from fstreambase and from the corresponding iostream class and they are designed specifically to manage disk files.\n\n C++ provides us with the following operations in File Handling:\n\nMoving on with article on File Handling in C++\n\nGenerally, the first operation performed on an object of one of these classes is to associate it to a real file. This procedure is known to open a file.\n\nWe can open a file using any one of the following methods:\n\n 1. First is bypassing the file name in constructor at the time of object creation.\n\n 2. Second is using the open() function.\n\nHere, the first argument of the open function defines the name and format of the file with the address of the file.\n\nThe second argument represents the mode in which the file has to be opened. The following modes are used as per the requirements.\n\nIn the above example, new_file is an object of type fstream, as we know fstream is a class so we need to create an object of this class to use its member functions. So we create new_file object and call open() function. Here we use out mode that allows us to open the file to write in it.\n\nWe can combine the different modes using or symbol | .\n\nHere, input mode and append mode are combined which represents the file is opened for writing and appending the outputs at the end.\n\nAs soon as the program terminates, the memory is erased and frees up the memory allocated and closes the files which are opened.\n\n But it is better to use the close() function to close the opened files after the use of the file.\n\nUsing a stream insertion operator << we can write information to a file and using stream extraction operator >> we can easily read information from a file.\n\nExample of opening/creating a file using the open() function\n\nExplanation\n\n In the above example we first create an object to class fstream and name it ‘new_file’. Then we apply the open() function on our ‘new_file’ object. We give the name ‘new_file’ to the new file we wish to create and we set the mode to ‘out’ which allows us to write in our file. We use a ‘if’ statement to find if the file already exists or not if it does exist then it will going to print “File creation failed” or it will gonna create a new file and print “New file created”.\n\nMoving on with article on File Handling in C++\n\nHere we first create a new file “new_file_write” using open() function since we wanted to send output to the file so, we use ios::out. As given in the program, information typed inside the quotes after Insertion Pointer “<<” got passed to the output file.\n\nMoving on with this article on File Handling in C++\n\nIn this example, we read the file that generated id previous example i.e. new_file_write.\n\n To read a file we need to use ‘in’ mode with syntax ios::in. In the above example, we print the content of the file using extraction operator >>. The output prints without any space because we use only one character at a time, we need to use getline() with a character array to print the whole line as it is.\n\nMoving on with this article on File Handling in C++\n\nIt is simply done with the help of close() function.\n\nIn file handling, it’s important to ensure the file was opened without any error before we can perform any further operations on it.\n\n There are three commonly used ways to check files for errors:\n\nNotice the condition in the if statement:\n\nif (!my_file) {…}\n\n This method checks if the file is in an error state by evaluating the file object itself.\n\n If the file opens successfully, the condition evaluates to true.\n\n If an error is found, it is evaluated to false, and you can handle the error accordingly.\n\n Note This method is recomended\n\n 2. Using the is_open() Function\n\n The is_open() function is a boolean function that returns\n\n true – if the file was opened successfully.\n\n false -if the file was unable to be opened.\n\n For instance,\n\n3. Using the fail() Function\n\n The fail() function returns\n\n true – if the file was unable to open.\n\n false – if the file was opened without error.\n\nIf you open the file in append mode then you can add text to it and append it.\n\n In C++, you can achieve this by using the ios::app flag when opening the file:\n\n ofstream my_file(“example.txt”, ios::app);\n\nCurrently we only have this text in our example.txt\n\n line1\n\n Line2\n\n Line3\n\n Now, let’s add some more text to example.txt:\n\nThe above code will append the lines below to our existing content example.txt:\n\nLine 4\n\nLine 5\n\nLine 6\n\n Now, let’s see what our example.txt looks like, output is shown below.\n\nFile handling in C++ refers to the process of creating and reading/writing from a file.\n\n We can access various file handling methods in C++ by importing the includes two classes for file handling:\n\n ifstream – to read from a file.\n\n ofstream – to create/open and write to a file\n\n It combines the functionalities of ifstream (for input) and ofstream (for output) into a single class\n\n Let’s understand this with examples\n\n Opening a File with fstream\n\n To work with files using fstream, you typically start by opening a file. Here’s how you can open a file for reading and writing using fstream:\n\nYou can write data to a file using the > operator or the read() function. Here’s an example of reading from a file using fstream:\n\nIt’s important to check for errors when working with files. Use the bad() function to check if an error occurred during file operations:\n\nfstream in C++ provides a flexible way to handle files, allowing both input and output operations seamlessly. Ensure to handle file opening, reading, writing, and error checking to create robust file handling mechanisms in your applications.\n\n1. How to file handle in C++?\n\nFile handling in C++ is performed with the help of classes from the fstream library: ifstream, ofstream, fstream. You declare an object of a proper file stream class. Then, using open() with the proper modes like ios::in to read a file, ios::out to write, ios::app to append to the file, perform the operations needed, and close a file by the close() method.\n\n2.How does file handling work?\n\n C++ file handling is based on the stream-based model. It creates a bridge between your program and the file on the disk. Most of the time, this link will be managed through objects of type ifstream, ofstream, or fstream. There are methods in these stream classes to read, write, and manipulate the content of the file. Mode is usually specified at the time a file is opened. This informs whether you want to read, write, or append to the file. The input/ output operations, like>, getline(), which transfer data between your program and the file. Once the file operations are done, the file is closed, which releases the system resources.\n\n3.What are the modes of file handling C++?\n\n The various modes of dealing with files in C++ are realized using the flags defined in the class ios. They include:\n\nios::in; //For input\n\n ios::out; //For output\n\n ios::app; //Append; all output to that file goes to the end.\n\n ios::ate; //Open with the file pointer at end-of-file.\n\n ios::trunc; //If the file already exists, its contents are truncated; that is, destroyed.\n\n These flags can be combined using the bitwise OR operator [|] for combinations of functionalities like ios::in | ios::binary for binary file reads. These flags control the access and editing of files when performing any file-handling operation in C++.\n\n4 What is the syntax of a file in C++?\n\n #include\n\nThus we have come to an end of this article on ‘File Handling in C++’. If you wish to learn more, check out the Java Training by Edureka, a trusted online learning company. Edureka’s Java J2EE and SOA training and certification course is designed to train you for both core and advanced Java concepts along with various Java frameworks like Hibernate & Spring.\n\nGot a question for us? Please mention it in the comments section of this blog and we will get back to you as soon as possible."
    },
    {
        "link": "https://geeksforgeeks.org/vigenere-cipher",
        "document": "Vigenere Cipher is a method of encrypting alphabetic text. It uses a simple form of polyalphabetic substitution. A polyalphabetic cipher is any cipher based on substitution, using multiple substitution alphabets. The encryption of the original text is done using the Vigenère square or Vigenère table.\n• None The table consists of the alphabets written out 26 times in different rows, each alphabet shifted cyclically to the left compared to the previous alphabet, corresponding to the 26 possible\n• None At different points in the encryption process, the cipher uses a different alphabet from one of the rows.\n• None The alphabet used at each point depends on a repeating keyword.\n\nThe first letter of the plaintext, G is paired with A, the first letter of the key. So use row G and column A of the Vigenère square, namely G. Similarly, for the second letter of the plaintext, the second letter of the key is used, the letter at row E, and column Y is C. The rest of the plaintext is enciphered in a similar fashion.\n\nDecryption:\n\nDecryption is performed by going to the row in the table corresponding to the key, finding the position of the ciphertext letter in this row, and then using the column’s label as the plaintext. For example, in row A (from AYUSH), the ciphertext G appears in column G, which is the first plaintext letter. Next, we go to row Y (from AYUSH), locate the ciphertext C which is found in column E, thus E is the second plaintext letter.\n\nA more easy implementation could be to visualize Vigenère algebraically by converting [A-Z] into numbers [0–25].\n\nNote: D denotes the offset of the i-th character of the plaintext. Like offset of A is 0 and of B is 1 and so on.\n\nBelow is the implementation of the idea.\n\n// This function generates the key in // equal to the length of original text // generated with the help of the key // Driver program to test the above function // This function generates the key in // equal to the length of original text // generated with the help of the key // This function will convert the lower case character to Upper case // This code has been contributed by 29AjayKumar #previous code was only support the upper case letters #this code can be apply on both // This function generates the key in // equal to the length of original text // generated with the help of the key // This function generates the key in // equal to the length of original text // generated with the help of the key // This function will convert the lower\n\nTime Complexity : O(n), where n is the length of the string(here str).\n\nSpace Complexity :O(n), here n is the length of the string(here str)."
    },
    {
        "link": "https://stackoverflow.com/questions/26989291/vigen%C3%A8re-cipher-code",
        "document": "How would I go about modifying this code to accept input from the user rather than using a predetermined string? Specifically, I need the program to require exactly two command line arguments. The first will either be the code \"-e\" or \"-d\" to indicate encoding or decoding of a message (this determines adding or subtracting you shift values) and the second parameter will be a single word that will be the keyword that you use for the encryption or decryption.\n\nThanks to your input and a few other sources I have re-developed my main code as is shown below. I am having trouble getting the program to decrypt and encrypt strings properly and I am not sure if the error is somewhere in the code itself, or operator error. Does anything look out of the ordinary here and how could I get this code functional to where it can encrypt or decrypt given user input?"
    },
    {
        "link": "https://tutorialspoint.com/cplusplus-program-to-implement-the-vigenere-cypher",
        "document": "C++ Program to Implement the Vigenere Cypher\n\nVigenere Cipher is a kind of polyalphabetic substitution method of encrypting alphabetic text.\n\nVigenere Cipher Table is used in which alphabets from A to Z are written in 26 rows, for encryption and decryption in this method.\n\nHere we have to obtain a key by repeating the given key till its length becomes equal to original message length.\n\nFor encryption take first letter of message and key i.e. T and W. Take the alphabet in Vigenere Cipher Table where T row and W column coincides i.e. P.\n\nRepeat the same process for all remaining alphabets in message text.\n\nThe cipher text can be generated by below equation.\n\nHere P is plain text and K is key.\n\nTake generated key and first alphabet of encrypted message i.e. P and W. Analyze Vigenere Cipher Table, look for alphabet P in column W, the corresponding row will be the first alphabet of original message i.e. T.\n\nRepeat this process for all the alphabets in encrypted message.\n\nThis can be represented in algebraic form by following equation.\n\nHere is a C++ program to implement Vigenere cipher."
    },
    {
        "link": "https://linkedin.com/pulse/breaking-vigenere-cipher-c-which-once-believed-two-daniel-ramnath",
        "document": ""
    },
    {
        "link": "https://tutorialspoint.com/cryptography/cryptography_implementing_vigenere_cipher.htm",
        "document": ""
    }
]