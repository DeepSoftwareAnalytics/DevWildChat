[
    {
        "link": "https://docs.oracle.com/cd/E19957-01/802-5762/802-5762.pdf",
        "document": ""
    },
    {
        "link": "https://downloads.freepascal.org/fpc/docs-pdf/ref.pdf",
        "document": ""
    },
    {
        "link": "http://pascal.hansotten.com/uploads/standardpascal/Programming%20standard%20Pascal.pdf",
        "document": ""
    },
    {
        "link": "https://en.wikipedia.org/wiki/Pascal_(programming_language)",
        "document": "Pascal is an imperative and procedural programming language, designed by Niklaus Wirth as a small, efficient language intended to encourage good programming practices using structured programming and data structuring. It is named after French mathematician, philosopher and physicist Blaise Pascal.[a]\n\nPascal was developed on the pattern of the ALGOL 60 language. Wirth was involved in the process to improve the language as part of the ALGOL X efforts and proposed a version named ALGOL W. This was not accepted, and the ALGOL X process bogged down. In 1968, Wirth decided to abandon the ALGOL X process and further improve ALGOL W, releasing this as Pascal in 1970.\n\nOn top of ALGOL's scalars and arrays, Pascal enables defining complex datatypes and building dynamic and recursive data structures such as lists, trees and graphs. Pascal has strong typing on all objects, which means that one type of data cannot be converted to or interpreted as another without explicit conversions. Unlike C (and also unlike most other languages in the C-family), Pascal allows nested procedure definitions to any level of depth, and also allows most kinds of definitions and declarations inside subroutines (procedures and functions). A program is thus syntactically similar to a single procedure or function. This is similar to the block structure of ALGOL 60, but restricted from arbitrary block statements to just procedures and functions.\n\nPascal became very successful in the 1970s, notably on the burgeoning minicomputer market. Compilers were also available for many microcomputers as the field emerged in the late 1970s. It was widely used as a teaching language in university-level programming courses in the 1980s, and also used in production settings for writing commercial software during the same period. It was displaced by the C programming language during the late 1980s and early 1990s as UNIX-based systems became popular, and especially with the release of C++.\n\nA derivative named Object Pascal designed for object-oriented programming was developed in 1985. This was used by Apple Computer (for the Lisa and Macintosh machines) and Borland in the late 1980s and later developed into Delphi on the Microsoft Windows platform. Extensions to the Pascal concepts led to the languages Modula-2 and Oberon, both developed by Wirth.\n\nMuch of the history of computer language design during the 1960s can be traced to the ALGOL 60 language. ALGOL was developed during the 1950s with the explicit goal of being able to clearly describe algorithms. It included a number of features for structured programming that remain common in languages to this day.\n\nShortly after its introduction, in 1962 Wirth began working on his dissertation with Helmut Weber on the Euler programming language. Euler was based on ALGOL's syntax and many concepts but was not a derivative. Its primary goal was to add dynamic lists and types, allowing it to be used in roles similar to Lisp. The language was published in 1965.\n\nBy this time, a number of problems in ALGOL had been identified, notably the lack of a standardized string system. The group tasked with maintaining the language had begun the ALGOL X process to identify improvements, calling for submissions. Wirth and Tony Hoare submitted a conservative set of modifications to add strings and clean up some of the syntax. These were considered too minor to be worth using as the new standard ALGOL, so Wirth wrote a compiler for the language, which became named ALGOL W.\n\nThe ALGOL X efforts would go on to choose a much more complex language, ALGOL 68. The complexity of this language led to considerable difficulty producing high-performance compilers, and it was not widely used in the industry. This left an opening for newer languages.\n\nPascal was influenced by the ALGOL W efforts, with the explicit goals of teaching programming in a structured fashion and for the development of system software.[5] A generation of students used Pascal as an introductory language in undergraduate courses. Other goals included providing a reliable and efficient tool for writing large programs,[6] and bridging the canyon between scientific and commercial programming, as represented by the then-widespread languages Fortran and COBOL, with a general-purpose language.[7]\n\nOne of the early successes for the language was the introduction of UCSD Pascal, a version that ran on a custom operating system that could be ported to different platforms. A key platform was the Apple II, where it saw widespread use as Apple Pascal. This led to Pascal becoming the primary high-level language used for development in the Apple Lisa, and later, the Macintosh. Parts of the original Macintosh operating system were hand-translated into Motorola 68000 assembly language from the Pascal source code.[8]\n\nThe typesetting system TeX by Donald Knuth was written in WEB, the original literate programming system, based on DEC PDP-10 Pascal. Successful commercial applications like Adobe Photoshop[9] were written in Macintosh Programmer's Workshop Pascal, while applications like Total Commander, Skype[10] and Macromedia Captivate were written in Delphi (Object Pascal). Apollo Computer used Pascal as the systems programming language for its operating systems beginning in 1980.\n\nVariants of Pascal have also been used for everything from research projects to PC games and embedded systems. Newer Pascal compilers exist which are widely used.[11]\n\nWirth's example compiler meant to propagate the language, the Pascal-P system, used a subset of the language designed to be the minimal subset of the language that could compile itself. The idea was that this could allow bootstrapping the compiler, which would then be extended to full Pascal language status. This was done with several compilers, but one notable exception was UCSD Pascal, which was based on Pascal-P2. It kept the subset status of the language based on the idea that this would run better on the new (then) microprocessors with limited memory. UCSD also converted the Pascal-P2 interpreter into a \"byte machine\", again, because it would be a better fit for byte oriented microprocessors.\n\nUCSD Pascal formed the basis of many systems, including Apple Pascal. Borland Pascal was not based on the UCSD codebase, but arrived during the popular period of UCSD and matched many of its features. This started the line that ended with Delphi Pascal and the compatible Open Source compiler FPC/Lazarus.\n\nThe ISO standard for Pascal, ISO 7185, was published in 1983 and was widely implemented and used on mainframes, minicomputers and IBM-PCs and compatibles from 16 bits to 32 bits. The two dialects of Pascal most in use towards the end of the 20th century and up until today are the ISO 7185 standard version and the Delphi/Turbo Pascal versions (of which the two Borland versions are mostly compatible with each other).\n\nThe source for much of the early history on Pascal can be found in the Pascal User's Group newsletters at:\n\nDuring work on the Lisa, Larry Tesler began corresponding with Wirth on the idea of adding object-oriented extensions to the language, to make Pascal a multi-paradigm programming language. This led initially to Clascal, introduced in 1983. As the Lisa program faded and was replaced by the Macintosh, a further version was created and named Object Pascal. This was introduced on the Mac in 1985 as part of the MacApp application framework, and became Apple's main development language into the early 1990s.\n\nThe Object Pascal extensions were added to Turbo Pascal with the release of version 5.5 in 1989.[12] Over the years, Object Pascal became the basis of the Delphi system for Microsoft Windows, which is still used for developing Windows applications, and can cross-compile code to other systems. Free Pascal is an open source, cross-platform alternative with its own graphical IDE called Lazarus.\n\nThe first Pascal compiler was designed in Zürich for the CDC 6000 series mainframe computer family. Niklaus Wirth reports that a first attempt to implement it in FORTRAN 66 in 1969 was unsuccessful due to FORTRAN 66's inadequacy to express complex data structures. The second attempt was implemented in a C-like language (Scallop by Max Engeli) and then translated by hand (by R. Schild) to Pascal itself for boot-strapping.[13] It was operational by mid-1970. Many Pascal compilers since have been similarly self-hosting, that is, the compiler is itself written in Pascal, and the compiler is usually capable of recompiling itself when new features are added to the language, or when the compiler is to be ported to a new environment. The GNU Pascal compiler is one notable exception, being written in C.\n\nThe first successful port of the CDC Pascal compiler to another mainframe was completed by Welsh and Quinn at the Queen's University of Belfast (QUB) in 1972. The target was the International Computers Limited (ICL) 1900 series. This compiler, in turn, was the parent of the Pascal compiler for the Information Computer Systems (ICS) Multum minicomputer. The Multum port was developed – with a view to using Pascal as a systems programming language – by Findlay, Cupples, Cavouras and Davis, working at the Department of Computing Science in Glasgow University. It is thought that Multum Pascal, which was completed in the summer of 1973, may have been the first 16-bit implementation.\n\nA completely new compiler was completed by Welsh et al. at QUB in 1977. It offered a source-language diagnostic feature (incorporating profiling, tracing and type-aware formatted postmortem dumps) that was implemented by Findlay and Watt at Glasgow University. This implementation was ported in 1980 to the ICL 2900 series by a team based at Southampton University and Glasgow University. The Standard Pascal Model Implementation was also based on this compiler, having been adapted, by Welsh and Hay at Manchester University in 1984, to check rigorously for conformity to the BSI 6192/ISO 7185 Standard and to generate code for a portable abstract machine.\n\nThe first Pascal compiler written in North America was constructed at the University of Illinois under Donald B. Gillies for the PDP-11 and generated native machine code. Microsoft had Pascal compilers for IBM PCs, see Microsoft Pascal.\n\nTo propagate the language rapidly, a compiler porting kit was created in Zürich that included a compiler that generated so called p-code for a virtual stack machine, i.e., code that lends itself to reasonably efficient interpretation, along with an interpreter for that code – the Pascal-P system. The P-system compilers were named Pascal-P1, Pascal-P2, Pascal-P3, and Pascal-P4. Pascal-P1 was the first version, and Pascal-P4 was the last to come from Zürich. The version termed Pascal-P1 was coined after the fact for the many different sources for Pascal-P that existed. The compiler was redesigned to enhance portability, and issued as Pascal-P2. This code was later enhanced to become Pascal-P3, with an intermediate code backward compatible with Pascal-P2, and Pascal-P4, which was not backward compatible.\n\nThe Pascal-P4 compiler–interpreter can still be run and compiled on systems compatible with original Pascal (as can Pascal-P2). However, it only accepts a subset of the Pascal language.\n\nPascal-P5, created outside the Zürich group, accepts the full Pascal language and includes ISO 7185 compatibility.\n\nPascal-P6 is a follow on to Pascal-P5 that along with other features, aims to be a compiler for specific CPUs, including AMD64.\n\nUCSD Pascal branched off Pascal-P2, where Kenneth Bowles used it to create the interpretive UCSD p-System. It was one of three operating systems available at the launch of the original IBM Personal Computer.[14] UCSD Pascal used an intermediate code based on byte values, and thus was one of the earliest bytecode compilers. Apple Pascal was released in 1979 for the Apple II and Apple III computer systems. It was an implementation of, or largely based on, UCSD Pascal. Pascal-P1 through Pascal-P4 were not, but rather based on the CDC 6600 60-bit word length.\n\nA compiler based on the Pascal-P4 compiler, which created native binary object files, was released for the IBM System/370 mainframe computer by the Australian Atomic Energy Commission; it was named the AAEC Pascal 8000 Compiler after the abbreviation of the name of the commission.[15]\n\nApple Computer created its own Lisa Pascal for the Lisa Workshop in 1982, and ported the compiler to the Apple Macintosh and MPW in 1985. In 1985 Larry Tesler, in consultation with Niklaus Wirth, defined Object Pascal and these extensions were incorporated in both the Lisa Pascal and Mac Pascal compilers.\n\nIn the 1980s, Anders Hejlsberg wrote the Blue Label Pascal compiler for the Nascom-2. A reimplementation of this compiler for the IBM PC was marketed under the names Compas Pascal and PolyPascal before it was acquired by Borland and renamed Turbo Pascal.\n\nTurbo Pascal became hugely popular, thanks to an aggressive pricing strategy, having one of the first full-screen IDEs, and very fast turnaround time (just seconds to compile, link, and run). It was written and highly optimized entirely in assembly language, making it smaller and faster than much of the competition.\n\nIn 1986, Anders ported Turbo Pascal to the Macintosh and incorporated Apple's Object Pascal extensions into Turbo Pascal. These extensions were then added back into the PC version of Turbo Pascal for version 5.5. At the same time Microsoft also implemented the Object Pascal compiler.[16][17] Turbo Pascal 5.5 had a large influence on the Pascal community, which began concentrating mainly on the IBM PC in the late 1980s. Many PC hobbyists in search of a structured replacement for BASIC used this product. It also began to be adopted by professional developers. Around the same time a number of concepts were imported from C to let Pascal programmers use the C-based application programming interface (API) of Microsoft Windows directly. These extensions included null-terminated strings, pointer arithmetic, function pointers, an address-of operator, and unsafe typecasts.\n\nTurbo Pascal and other derivatives with unit or module structures are modular programming languages. However, it does not provide a nested module concept or qualified import and export of specific symbols.\n\nSuper Pascal adds non-numeric labels, a return statement and expressions as names of types.\n\nTMT Pascal was the first Borland-compatible compiler for 32-bit MS-DOS compatible protected mode, OS/2, and Win32. It extends the language with function and operator overloading.\n\nThe universities of Wisconsin–Madison, Zürich, Karlsruhe, and Wuppertal developed the Pascal-SC[18][19] and Pascal-XSC[20][21][22] (Extensions for Scientific Computation) compilers, aimed at programming numerical computations. Development for Pascal-SC started in 1978 supporting ISO 7185 Pascal level 0, but level 2 support was added at a later stage.[23] Pascal-SC originally targeted the Z80 processor, but was later rewritten for DOS (x86) and 68000. Pascal-XSC has at various times been ported to Unix (Linux, SunOS, HP-UX, AIX) and Microsoft/IBM (DOS with EMX, OS/2, Windows) operating systems. It operates by generating intermediate C source code which is then compiled to a native executable. Some of the Pascal-SC language extensions have been adopted by GNU Pascal.\n\nPascal Sol was designed around 1983 by a French team to implement a Unix-like system named Sol. It was standard Pascal level-1 (with parameterized array bounds) but the definition allowed alternative keywords and predefined identifiers in French and the language included a few extensions to ease system programming (e.g. an equivalent to lseek).[24] The Sol team later on moved to the ChorusOS project to design a distributed operating system.[25]\n\nIP Pascal is an implementation of the Pascal programming language using Micropolis DOS, but was moved rapidly to CP/M-80 running on the Z80. It was moved to the 80386 machine types in 1994, and exists today as Windows XP and Linux implementations. In 2008, the system was brought up to a new level and the resulting language termed \"Pascaline\" (after Pascal's calculator). It includes objects, namespace controls, dynamic arrays, and many other extensions, and generally features the same functionality and type protection as C#. It is the only such implementation that is also compatible with the original Pascal implementation, which is standardized as ISO 7185.\n\nPascal, in its original form, is a purely procedural language and includes the traditional array of ALGOL-like control structures with reserved words such as , , , , , and , ranging on a single statement or a - statements block. Pascal also has data structuring constructs not included in the original ALGOL 60 types, like records, variants, pointers, enumerations, and sets and procedure pointers. Such constructs were in part inherited or inspired from Simula 67, ALGOL 68, Niklaus Wirth's own ALGOL W and suggestions by C. A. R. Hoare.\n\nPascal programs start with the keyword with a list of external file descriptors as parameters[26] (not required in Turbo Pascal etc.); then follows the main block bracketed by the and keywords. Semicolons separate statements, and the full stop (i.e., a period) ends the whole program (or unit). Letter case is ignored in Pascal source.\n\nHere is an example of the source code in use for a very simple \"Hello, World!\" program:\n\nA Type Declaration in Pascal is used to define a range of values which a variable of that type is capable of storing. It also defines a set of operations that are permissible to be performed on variables of that type. The predefined types are:\n\nThe range of values allowed for the basic types (except Boolean) is implementation defined. Functions are provided for some data conversions. For conversion of to , the following functions are available: (which rounds to integer using banker's rounding) and (rounds towards zero).\n\nThe programmer has the freedom to define other commonly used data types (e.g. byte, string, etc.) in terms of the predefined types using Pascal's type declaration facility, for example\n\nOften-used types like byte and string are already defined in many implementations.\n\nNormally the system will use a word to store the data. For instance, the type may be stored in a machine integer - 32 bits perhaps - rather than an 8-bit value. Pascal does not contain language elements that allow the basic storage types to be defined more granularly. This capability was included in a number of Pascal extensions and follow-on languages, while others, like Modula-2, expanded the built-in set to cover most machine data types like 16-bit integers.\n\nThe keyword tells the compiler to use the most efficient method of storage for the structured data types: sets, arrays and records, rather than using one word for each element. Packing may slow access on machines that do not offer easy access to parts of a word.\n\nSubranges of any ordinal data type (any simple type except real) can also be made:\n\nIn contrast with other programming languages from its time, Pascal supports a set type:[27]\n\nA set is a fundamental concept for modern mathematics, and they may be used in many algorithms. Such a feature is useful and may be faster than an equivalent construct in a language that does not support sets. For example, for many Pascal compilers:\n\nSets of non-contiguous values can be particularly useful, in terms of both performance and readability:\n\nFor these examples, which involve sets over small domains, the improved performance is usually achieved by the compiler representing set variables as bit vectors. The set operators can then be implemented efficiently as bitwise machine code operations.\n\nAn example of a Pascal record type:\n\nAn example of a variant record type:\n\nVariant records allow several fields of the record to overlap each other to save space.\n\nTypes can be defined from other types using type declarations:\n\nFurther, complex types can be constructed from simple types:\n\nAs shown in the example above, Pascal files are sequences of components. Every file has a buffer variable which is denoted by f^. The procedures get (for reading) and put (for writing) move the buffer variable to the next element. Read is introduced such that read(f, x) is the same as x := f^; get(f);. Write is introduced such that write(f, x) is the same as f^ := x; put(f); The type is predefined as file of char. While the buffer variable could be used for inspecting the next character to be used (check for a digit before reading an integer), this leads to serious problems with interactive programs in early implementations, but was solved later with the \"lazy I/O\" concept, which waits until the file buffer variable is actually accessed before performing file operations.\n\nPascal supports the use of pointers:\n\nHere the variable NodePtr is a pointer to the data type Node, a record. Pointers can be used before they are declared. This is a forward declaration, an exception to the rule that things must be declared before they are used.\n\nTo create a new record and assign the value 10 and character A to the fields a and b in the record, and to initialise the pointer c to the null pointer (\"NIL\" in Pascal), the statements would be:\n\nThis could also be done using the statement, as follows:\n\nInside of the scope of the with statement, a and b refer to the subfields of the record pointer NodePtr and not to the record Node or the pointer type pNode.\n\nLinked lists, stacks and queues can be created by including a pointer type field (c) in the record.\n\nUnlike many languages that feature pointers, Pascal only allows pointers to reference dynamically created variables that are anonymous, and does not allow them to reference standard static or local variables. Pointers also must have an associated type, and a pointer to one type is not compatible with a pointer to another type (e.g. a pointer to a char is not compatible with a pointer to an integer). This helps eliminate the type security issues inherent with other pointer implementations, particularly those used for PL/I or C. It also removes some risks caused by dangling pointers, but the ability to dynamically deallocate referenced space by using the dispose function (which has the same effect as the free library function found in C) means that the risk of dangling pointers has not been eliminated[28] as it has in languages such as Java and C#, which provide automatic garbage collection (but which do not eliminate the related problem of memory leaks).\n\nSome of these restrictions can be lifted in newer dialects.\n\nPascal is a structured programming language, meaning that the flow of control is structured into standard statements, usually without 'goto' commands.\n\nPascal structures programs into procedures and functions. Generally, a procedure is used for its side effects, whereas a function is used for its return value.\n\nProcedures and functions can be nested to any depth, and the 'program' construct is the logical outermost block.\n\nBy default, parameters are passed by value. If 'var' precedes a parameter's name, it is passed by reference.\n\nEach procedure or function can have its own declarations of goto labels, constants, types, variables, and other procedures and functions, which must all be in that order. This ordering requirement was originally intended to allow efficient single-pass compilation. However, in some dialects (such as Delphi) the strict ordering requirement of declaration sections has been relaxed.\n\nPascal adopted many language syntax features from the ALGOL language, including the use of a semicolon as a statement separator. This is in contrast to other languages, such as PL/I and C, which use the semicolon as a statement terminator. No semicolon is needed before the keyword of a record type declaration, a block, or a case statement; before the keyword of a repeat statement; and before the keyword of an if statement.\n\nThe presence of an extra semicolon was not permitted in early versions of Pascal. However, the addition of ALGOL-like empty statements in the 1973 Revised Report and later changes to the language in ISO 7185:1983 now allow for optional semicolons in most of these cases. A semicolon is still not permitted immediately before the keyword in an if statement, because the follows a single statement, not a statement sequence. In the case of nested ifs, a semicolon cannot be used to avoid the dangling else problem (where the inner if does not have an else, but the outer if does) by putatively terminating the nested if with a semicolon – this instead terminates both if clauses. Instead, an explicit ... block must be used.[29]\n\nSeveral Pascal compilers and interpreters are available for general use:\n• Delphi is Embarcadero's (formerly Borland/CodeGear) flagship rapid application development (RAD) product. It uses the Object Pascal language (termed 'Delphi' by Borland), descended from Pascal, to create applications for Windows, macOS, iOS, and Android. The .NET support that existed from D8 through D2005, D2006, and D2007 has been terminated, and replaced by a new language (Prism, which is rebranded Oxygene, see below) that is not fully backward compatible. In recent years Unicode support and generics were added (D2009, D2010, Delphi XE).\n• Free Pascal is a cross-platform compiler written in Object Pascal (and is self-hosting). It is aimed at providing a convenient and powerful compiler, both able to compile legacy applications and to be the means to develop new ones. It is distributed under the GNU General Public License (GNU GPL), while packages and runtime library come under a modified GNU Lesser General Public License (GNU LGPL). In addition to compatibility modes for Turbo Pascal, Delphi, and Mac Pascal, it has its own procedural and object-oriented syntax modes with support for extended features such as operator overloading. It supports many platforms and operating systems. Current versions also feature an ISO mode.\n• Turbo51 is a free Pascal compiler for the Intel 8051 family of microcontrollers, with Turbo Pascal 7 syntax.\n• Oxygene (formerly named Chrome) is an Object Pascal compiler for the .NET and Mono platforms. It was created and is sold by RemObjects Software, and sold for a while by Embarcadero as the backend compiler of Prism.\n• Kylix was a descendant of Delphi, with support for the Linux operating system and an improved object library. It is no longer supported. Compiler and IDE are available now for non-commercial use.\n• GNU Pascal Compiler (GPC) is the Pascal compiler of the GNU Compiler Collection (GCC). The compiler is written in C, the runtime library mostly in Pascal. Distributed under the GNU General Public License, it runs on many platforms and operating systems. It supports the ANSI/ISO standard languages and has partial Turbo Pascal dialect support. One of the more notable omissions is the absence of a fully Turbo Pascal-compatible (short)string type. Support for Borland Delphi and other language variants is quite limited. There is some support for Mac-pascal, however.\n• Virtual Pascal was created by Vitaly Miryanov in 1995 as a native OS/2 compiler compatible with Borland Pascal syntax. Then, it had been commercially developed by fPrint, adding Win32 support, and in 2000 it became freeware. Today it can compile for Win32, OS/2, and Linux, and is mostly compatible with Borland Pascal and Delphi. Development was canceled on April 4, 2005.\n• Pascal-P4 compiler, the basis for many subsequent Pascal-implemented-in-Pascal compilers. It implements a subset of full Pascal.\n• Pascal-P5 compiler is an ISO 7185 (full Pascal) adaption of Pascal-P4.\n• Pascal-P6 compiler is an extended version of Pascal adaption of Pascal-P5 according to the Pascaline language specification.\n• Turbo Pascal was the dominant Pascal compiler for PCs during the 1980s and early 1990s, popular both because of its powerful extensions and extremely short compilation times. Turbo Pascal was compactly written and could compile, run, and debug all from memory without accessing disk. Slow floppy disk drives were common for programmers at the time, further magnifying Turbo Pascal's speed advantage. Currently, older versions of Turbo Pascal (up to 5.5) are available for free download from Borland's site.\n• IP Pascal implements the language \"Pascaline\" (named after Pascal's calculator), which is a highly extended Pascal compatible with original Pascal according to ISO 7185. It features modules with namespace control, including parallel tasking modules with semaphores, objects, dynamic arrays of any dimensions that are allocated at runtime, overloads, overrides, and many other extensions. IP Pascal has a built-in portability library that is custom tailored to the Pascal language. For example, a standard text output application from 1970's original Pascal can be recompiled to work in a window and even have graphical constructs added.\n• Pascal-XT was created by Siemens for their mainframe operating systems BS2000 and SINIX.\n• PocketStudio is a Pascal subset compiler and RAD tool for Palm OS and MC68xxx processors with some of its own extensions to assist interfacing with the Palm OS API. It resembles Delphi and Lazarus with a visual form designer, an object inspector and a source code editor.\n• MIDletPascal – A Pascal compiler and IDE that generates small and fast Java bytecode specifically designed to create software for mobiles.\n• Vector Pascal is a language for SIMD instruction sets such as the MMX and the AMD 3d Now, supporting all Intel and AMD processors, and Sony's PlayStation 2 Emotion Engine.\n• Morfik Pascal allows the development of Web applications entirely written in Object Pascal (both server and browser side).\n• WDSibyl – Visual Development Environment and Pascal compiler for Win32 and OS/2.\n• PP Compiler, a compiler for Palm OS that runs directly on the handheld computer.\n• CDC 6000 Pascal compiler is the source code for the first (CDC 6000) Pascal compiler.\n• VSI Pascal for OpenVMS (formerly HP Pascal for OpenVMS, Compaq Pascal, DEC Pascal, VAX Pascal and originally VAX-11 Pascal 31 ) is a Pascal compiler that runs on OpenVMS systems. 32 It was also supported under Tru64. 33 34 VSI Pascal for OpenVMS is compatible with ISO/IEC 7185:1990 Pascal as well some of ISO/IEC 10206:1990 Extended Pascal, and also includes its own extensions. 32 The compiler frontend is implemented in BLISS. 35\n• Stony Brook Pascal+ was a 16-bit (later 32-bit) optimizing compiler for DOS and OS/2, marketed as a direct replacement for Turbo Pascal, but producing code that executed at least twice as fast.\n• Dev-Pascal is a Pascal IDE that was designed in Borland Delphi and which supports Free Pascal and GNU Pascal as backends.\n• Lazarus is a free Delphi-like visual cross-platform IDE for rapid application development (RAD). Based on Free Pascal, Lazarus is available for numerous platforms including Linux, FreeBSD, macOS and Microsoft Windows.\n• Fire (macOS) and Water (Windows) for the Oxygene and the Elements Compiler\n• WOL Library for creating GUI applications with the Free Pascal Compiler.\n\nIn 1983, the language was standardized in the international standard IEC/ISO 7185[36] and several local country-specific standards, including the American ANSI/IEEE770X3.97-1983, and ISO 7185:1983. These two standards differed only in that the ISO standard included a \"level 1\" extension for conformant arrays (an array where the boundaries of the array are not known until run time), where ANSI did not allow for this extension to the original (Wirth version) language. In 1989, ISO 7185 was revised (ISO 7185:1990) to correct various errors and ambiguities found in the original document.\n\nThe ISO 7185 was stated to be a clarification of Wirth's 1974 language as detailed by the User Manual and Report [Jensen and Wirth], but was also notable for adding \"Conformant Array Parameters\" as a level 1 to the standard, level 0 being Pascal without conformant arrays. This addition was made at the request of C. A. R. Hoare, and with the approval of Niklaus Wirth. The precipitating cause was that Hoare wanted to create a Pascal version of the (NAG) Numerical Algorithms Library, which had originally been written in FORTRAN, and found that it was not possible to do so without an extension that would allow array parameters of varying size. Similar considerations motivated the inclusion in ISO 7185 of the facility to specify the parameter types of procedural and functional parameters.\n\nNiklaus Wirth himself referred to the 1974 language as \"the Standard\", for example, to differentiate it from the machine specific features of the CDC 6000 compiler. This language was documented in The Pascal Report,[37] the second part of the \"Pascal users manual and report\".\n\nOn the large machines (mainframes and minicomputers) Pascal originated on, the standards were generally followed. On the IBM PC, they were not. On IBM PCs, the Borland standards Turbo Pascal and Delphi have the greatest number of users. Thus, it is typically important to understand whether a particular implementation corresponds to the original Pascal language, or a Borland dialect of it.\n\nThe IBM PC versions of the language began to differ with the advent of UCSD Pascal, an interpreted implementation that featured several extensions to the language, along with several omissions and changes. Many UCSD language features survive today, including in Borland's dialect.\n\nIn 1990, an extended Pascal standard was created as ISO/IEC 10206,[38] which is identical in technical content[39] to IEEE/ANSI 770X3.160-1989[40] As of 2019, Support of Extended Pascal in FreePascal Compiler is planned.[41]\n\nNiklaus Wirth's Zürich version of Pascal was issued outside ETH in two basic forms: the CDC 6000 compiler source, and a porting kit called Pascal-P system. The Pascal-P compiler left out several features of the full language that were not required to bootstrap the compiler. For example, procedures and functions used as parameters, undiscriminated variant records, packing, dispose, interprocedural gotos and other features of the full compiler were omitted.\n\nUCSD Pascal, under Professor Kenneth Bowles, was based on the Pascal-P2 kit, and consequently shared several of the Pascal-P language restrictions. UCSD Pascal was later adopted as Apple Pascal, and continued through several versions there. Although UCSD Pascal actually expanded the subset Pascal in the Pascal-P kit by adding back standard Pascal constructs, it was still not a complete standard installation of Pascal.\n\nIn the early 1990s, Alan Burns and Geoff Davies developed Pascal-FC, an extension to Pl/0 (from the Niklaus' book Algorithms + Data Structures = Programs). Several constructs were added to use Pascal-FC as a teaching tool for Concurrent Programming (such as semaphores, monitors, channels, remote-invocation and resources). To be able to demonstrate concurrency, the compiler output (a kind of P-code) could then be executed on a virtual machine. This virtual machine not only simulated a normal – fair – environment, but could also simulate extreme conditions (unfair mode).\n\nBorland's Turbo Pascal, written by Anders Hejlsberg, was written in assembly language independent of UCSD and the Zürich compilers. However, it adopted much of the same subset and extensions as the UCSD compiler. This is probably because the UCSD system was the most common Pascal system suitable for developing applications on the resource-limited microprocessor systems available at that time.\n\nThe shrink-wrapped Turbo Pascal version 3 and later incarnations, including Borland's Object Pascal and Delphi and non-Borland near-compatibles became popular with programmers including shareware authors, and so the SWAG library of Pascal code features a large amount of code written with such versions as Delphi in mind.\n\nSoftware products (compilers, and IDE/Rapid Application Development (RAD)) in this category:\n• Turbo Pascal – \"TURBO.EXE\" up to version 7, and Turbo Pascal for Windows (\"TPW\") and Turbo Pascal for Macintosh.\n• Pure Pascal and HiSPeed Pascal 2 Pascal language Environment for the Atari ST range of computers.\n• Borland Pascal 7 – A professional version of Turbo Pascal line which targeted both DOS and Windows.\n• Object Pascal – an extension of the Pascal language that was developed at Apple Computer by a team led by Larry Tesler in consultation with Niklaus Wirth, the inventor of Pascal; its features were added to Borland's Turbo Pascal for Macintosh and in 1989 for Turbo Pascal 5.5 for DOS.\n• Free Pascal compiler (FPC) – Free Pascal adopted the standard dialect of Borland Pascal programmers, Borland Turbo Pascal and, later, Delphi.\n• Borland Kylix is a compiler and IDE formerly sold by Borland, but later discontinued. It is a Linux version of the Borland Delphi software development environment and C++Builder.\n• Lazarus – similar to Kylix in function, is a free cross-platform visual IDE for RAD using the Free Pascal compiler, which supports dialects of Object Pascal to varying degrees.\n• Virtual Pascal – VP2/1 is a fully Borland Pascal– and Borland Delphi–compatible 32-bit Pascal compiler for OS/2 and Windows 32 (with a Linux version \"on the way\"). 42\n• Sybil is an open source Delphi-like IDE and compiler; implementations include:\n• WDSibyl 43 for Microsoft Windows and OS/2, a commercial Borland Pascal compatible environment released by a company named Speedsoft that was later developed into a Delphi-like rapid application development (RAD) environment named Sybil and then open sourced under the GPL when that company closed down;\n• Open Sybil, which is an ongoing project, an open source tool for OS/2 and eCS that was originally based on Speedsoft's WDsybl Sibyl Portable Component Classes (SPCC) and Sibyl Visual Development Tool (SVDE) sources, but now its core is IBM System Object Model (SOM), WPS and OpenDoc. 44\n\nPascal generated a wide variety of responses in the computing community, both critical and complimentary.\n\nWirth's initial definition of the language was widely criticized. In particular, Nico Habermann commented in his \"Critical Comments on the Programming Language Pascal\" (1973) that many of its constructs were poorly defined, in particular for data types, ranges, structures, and goto.[45] Later, Brian Kernighan, who popularized the C language, outlined his criticisms of Pascal in 1981 in his article \"Why Pascal is Not My Favorite Programming Language\".[46] The most serious problem Kernighan described was that array sizes and string lengths were part of the type, so it was not possible to write a function that would accept variable-length arrays or even strings as parameters. This made it unfeasible to write, for example, a sorting library. Kernighan also criticized the unpredictable order of evaluation of Boolean expressions, poor library support, and lack of static variables, and raised a number of smaller issues. Also, he stated that the language did not provide any simple constructs to \"escape\" (knowingly and forcibly ignore) restrictions and limitations. More general complaints from other sources[28][47] noted that the scope of declarations was not clearly defined in the original language definition, which sometimes had serious consequences when using forward declarations to define pointer types, or when record declarations led to mutual recursion, or when an identifier may or may not have been used in an enumeration list. Another difficulty was that, like ALGOL 60, the language did not allow procedures or functions passed as parameters to predefine the expected type of their parameters.\n\nIn the two decades after 1975, Pascal gained increasing attention and became a major programming language for important platforms (including Apple II, Apple III, Apple Lisa, Commodore systems, Z-80-based machines and IBM PC) due to the availability of UCSD Pascal and Turbo Pascal.[48]\n\nDespite initial criticisms, Pascal continued to evolve, and most of Kernighan's points do not apply to versions of the language which were enhanced to be suitable for commercial product development, such as Borland's Turbo Pascal. As Kernighan predicted in his article, most of the extensions to fix these issues were incompatible from compiler to compiler. Since the early 1990s, however, most of the varieties seem condensed into two categories: ISO and Borland-like. Extended Pascal addresses many of these early criticisms. It supports variable-length strings, variable initialization, separate compilation, short-circuit Boolean operators, and default ( ) clauses for case statements.[49]\n\nSome of the problems arising from the differences in the implementations of Pascal were later partly solved by the advent of Free Pascal, which supports several dialects with mode directives.[50]\n• Comparison of Pascal and C\n• C. A. R. Hoare: \"Notes on data structuring\". In O.-J. Dahl, E. W. Dijkstra and C. A. R. Hoare, editors, Structured Programming, pages 83–174. Academic Press, 1972.\n• C. A. R. Hoare, Niklaus Wirth: An Axiomatic Definition of the Programming Language Pascal. 335–355, Acta Informatica, Volume 2, 1973.\n• Kathleen Jensen and Niklaus Wirth: Pascal – User Manual and Report. Springer-Verlag, 1974, 1985, 1991, ISBN 0-387-97649-3 and ISBN 3-540-97649-3.\n• Niklaus Wirth: An assessment of the programming language Pascal. 23–30 ACM SIGPLAN Notices Volume 10, Issue 6, June 1975.\n• D. W. Barron (Ed.): Pascal – The Language and its Implementation. John Wiley 1981, ISBN 0-471-27835-1\n• Richard S. Forsyth: Pascal in Work and Play, Chapman and Hall, 1982\n• N. Wirth, M. Broy, ed, and E. Denert, ed: Pascal and its Successors in Software Pioneers: Contributions to Software Engineering. Springer-Verlag, 2002, ISBN 3-540-43081-4\n• N. Wirth: Recollections about the Development of Pascal. ACM SIGPLAN Notices, Volume 28, No 3, March 1993."
    },
    {
        "link": "https://tutorialspoint.com/pascal/pascal_arrays.htm",
        "document": "Pascal programming language provides a data structure called the array, which can store a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.\n\nInstead of declaring individual variables, such as number1, number2, ..., and number100, you declare one array variable such as numbers and use numbers[1], numbers[2], and ..., numbers[100] to represent individual variables. A specific element in an array is accessed by an index.\n\nAll arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element.\n\nPlease note that if you want a C style array starting from index 0, you just need to start the index from 0, instead of 1.\n\nTo declare an array in Pascal, a programmer may either declare the type and then create variables of that array or directly declare the array variable.\n\nThe general form of type declaration of one-dimensional array is −\n• None array-identifier − indicates the name of the array type.\n• None index-type − specifies the subscript of the array; it can be any scalar data type except real\n• None element-type − specifies the types of values that are going to be stored\n\nNow, velocity is a variable array of vector type, which is sufficient to hold up to 25 real numbers.\n\nTo start the array from 0 index, the declaration would be −\n\nIn Pascal, an array subscript could be of any scalar type like, integer, Boolean, enumerated or subrange, except real. Array subscripts could have negative values too.\n\nLet us take up another example where the subscript is of character type −\n\nSubscript could be of enumerated type −\n\nIn Pascal, arrays are initialized through assignment, either by specifying a particular subscript or using a for-do loop.\n\nAn element is accessed by indexing the array name. This is done by placing the index of the element within square brackets after the name of the array. For example −\n\nThe above statement will take the first element from the array named alphabet and assign the value to the variable a.\n\nFollowing is an example, which will use all the above-mentioned three concepts viz. declaration, assignment and accessing arrays −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nArrays are important to Pascal and should need lots of more details. There are following few important concepts related to array which should be clear to a Pascal programmer −"
    },
    {
        "link": "https://tutorialspoint.com/pascal/pascal_loops.htm",
        "document": "There may be a situation, when you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.\n\nProgramming languages provide various control structures that allow for more complicated execution paths.\n\nA loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages −\n\nPascal programming language provides the following types of loop constructs to handle looping requirements. Click the following links to check their details.\n\nwhile-do loop Repeats a statement or group of statements while a given condition is true. It tests the condition before executing the loop body. for-do loop Executes a sequence of statements multiple times and abbreviates the code that manages the loop variable. repeat-until loop Like a while statement, except that it tests the condition at the end of the loop body. nested loops You can use one or more loop inside any another while, for or repeat until loop.\n\nLoop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.\n\nPascal supports the following control statements. Click the following links to check their details."
    },
    {
        "link": "https://tutorialspoint.com/pascal/pascal_arrays.htm",
        "document": "Pascal programming language provides a data structure called the array, which can store a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.\n\nInstead of declaring individual variables, such as number1, number2, ..., and number100, you declare one array variable such as numbers and use numbers[1], numbers[2], and ..., numbers[100] to represent individual variables. A specific element in an array is accessed by an index.\n\nAll arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element.\n\nPlease note that if you want a C style array starting from index 0, you just need to start the index from 0, instead of 1.\n\nTo declare an array in Pascal, a programmer may either declare the type and then create variables of that array or directly declare the array variable.\n\nThe general form of type declaration of one-dimensional array is −\n• None array-identifier − indicates the name of the array type.\n• None index-type − specifies the subscript of the array; it can be any scalar data type except real\n• None element-type − specifies the types of values that are going to be stored\n\nNow, velocity is a variable array of vector type, which is sufficient to hold up to 25 real numbers.\n\nTo start the array from 0 index, the declaration would be −\n\nIn Pascal, an array subscript could be of any scalar type like, integer, Boolean, enumerated or subrange, except real. Array subscripts could have negative values too.\n\nLet us take up another example where the subscript is of character type −\n\nSubscript could be of enumerated type −\n\nIn Pascal, arrays are initialized through assignment, either by specifying a particular subscript or using a for-do loop.\n\nAn element is accessed by indexing the array name. This is done by placing the index of the element within square brackets after the name of the array. For example −\n\nThe above statement will take the first element from the array named alphabet and assign the value to the variable a.\n\nFollowing is an example, which will use all the above-mentioned three concepts viz. declaration, assignment and accessing arrays −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nArrays are important to Pascal and should need lots of more details. There are following few important concepts related to array which should be clear to a Pascal programmer −"
    },
    {
        "link": "https://youtube.com/playlist?list=PLYBJzqz8zpWZUDwnt3TNi-8HkrR-B9RJe",
        "document": ""
    },
    {
        "link": "https://lechaamwe.weebly.com/uploads/2/6/6/5/26654545/pe231_lecture6b.pdf",
        "document": ""
    },
    {
        "link": "https://cise.ufl.edu/~mssz/Pascal-CGS2462/ifs-and-loops.html",
        "document": "A key feature of computer programs is decision making, where the program selects a result from among a list of alternatives. The PASCAL statements that support such decision making are collectively called selection structures and include the IF..THEN..ELSE and CASE statements. We will later see that the CASE statement is not in vogue (i.e., isn't used much) because it is harder to read clearly than an IF statement.\n\nComputer program design is also facilitated by the use of program structures called loops that cause the block of statements within the loop to repeat or iterate. The latter term gives rise to the concept of iteration structures, which in PASCAL include the FOR, WHILE, and REPEAT statements.\n\nThis section is organized as follows:\n\n4.1. Overview of Selection Structures \n\n 4.2. IF and CASE statements \n\n 4.3. Overview of Iteration Structures \n\n 4.4. WHILE, FOR, and REPEAT statements \n\n 4.5. Variable Loop Limits\n\nIn Section 4.1, we discuss the basic justification and concepts associated with iteration and selection structures, with examples of modularity in the block-IF statement. We then discuss usage of the IF and CASE statements (Section 4.2). An overview of iteration structures is given in Section 4.3, with usage of the WHILE, FOR, and REPEAT statements discussed in Section 4.4. The final topic of this section is the use of variable loop limits, which allows you to \"customize\" a loop with limit values that are passed into a procedure through its argument list.\n• Observation. In the early days of computer programming, when programmers did not have high-level languages like PASCAL, it was very difficult to make decision structures. One had to use assembly language constructs such as branch-on-zero and formulate decision tests based on numeric values. In contrast, humans tend to make decisions based on non-numeric and qualitative criteria. Since digital computers currently use only ones and zeroes, we have to find a way to reduce the decision tests to those simple values. Definition. A logical operator is an operation that inputs one or more values equal to zero or one, and outputs a zero (i.e., logical false) or a one (i.e., logical true). Definition. A relational operator is an operation that inputs one or more numeric or alphabetical values and compares them to a prespecified criterion (e.g., is x greater than 3?). The result of a relational operator is a zero, if the test that the operator implements fails, and a one if the test succeeds. Definition. A logical predicate is comprised of one or more logical or relational operations, and produces a zero or one as a result. Definition. A Boolean value is a one or a zero. Definition. The logical operators NOT(x), AND(x,y), and OR(x,y) are defined as follows, where x and y) are Boolean values: Definition. The relational operators are defined as: NAME SYMBOL MEANING --------------- ---------- ------------------------------------- greater-than x > y \"x\" is greater than \"y\" greater-equal x >= y \"x\" is greater than or equal to \"y\" equals x == y \"x\" equals \"y\" not-equals x <> y \"x\" does not equal \"y\" less-equal x <= y \"x\" is less than or equal to \"y\" less-than x < y \"x\" is less than \"y\" Observation. As we mentioned in Section 3, various attempts have been made to render computer languages more like English. One of the key constructs in this effort is the IF..THEN..ELSE statement, which is structured as follows: IF logical-predicate THEN -- statements to execute if the predicate evaluates to true -- ELSE -- statements to execute if the predicate evaluates to false -- ENDIF Example. Suppose your program has a flag (a logical or Boolean decision variable) that causes statements to be printed to your computer monitor. For example: IF flag THEN WRITELN('Flag is true') ELSE WRITELN('Flag is false') ENDIF Remark. PASCAL facilitates decisions among multiple alternatives via the BLOCK-IF statement, which is comprised of multiple IF..THEN..ELSE statements that are chained together, as follows: IF predicate-1 THEN -- statements to execute if predicate-1 evaluates to true -- ELSEIF predicate-2 THEN -- statements to execute if predicate-2 evaluates to true -- ELSEIF ... ELSEIF predicate-n THEN -- statements to execute if predicate-n evaluates to true -- ELSE -- statements to execute if the preceding predicates all evaluate to false -- ENDIF\n\nIn the 1970s, programming language designers were looking for simpler ways to write statements that were previously involved expressions. Since the programmers made more errors on complex statements, it seemed reasonable to attempt to distill the BLOCK-IF into a more concise representation. In PASCAL, this representation is called the CASE statement. Instead of relational operators, the CASE statement simply specifies possible values for a variable, together with statements to be executed if that variable has a given value. For example, consider the following CASE statement (written in pseudocode) for a academic grade evaluation:\n\nPurpose: The IF statement provides a mechanism for decision based on a logical predicate.\n\nare one or more PASCAL statements are one or more PASCAL statements\n\nNotes: When single statements are used in an IF statement block, one must take care not to put a semicolon after the statement that follows the IF...ELSE block. Otherwise, the PASCAL compiler will infer that the IF statement should be terminated at the semicolon. So, the semicolon goes after the ELSE predicates, as shown above. When the IF statement is used to execute large blocks of compound statements, then the BEGIN..END construct should be used to delimit those statement blocks.\n\nPurpose: The Block-IF statement provides a mechanism for decision based on multiple logical predicates. This can be useful for grouping data items into prespecified categories. Syntax: IF predicate1 THEN actions-if-predicate1-is-true\n\n ELSEIF predicate2 THEN \n\n :\n\n ELSEIF predicateN THEN \n\n ELSE actions-if-predicates-are-false ; , where\n\nare one or more PASCAL statements are one or more PASCAL statements\n\nPASCAL also supports nested decision structures, in which an IF statement contains other IF statements in its list of executable statements. This allows the programmer to specify decisions based on concepts or criteria that are hierarchically structured.\n• Observation. In the early days of computer programming, when programmers did not have high-level languages like PASCAL, the programming of repetitive sections of code was quite clumsy. For example, to make a section of code repeat N times, one had to use assembly language constructs that incremented a counter and tested it against N, using branch-on-zero and the infamous go-to for transferring control to the partition of code that executed after the loop ended. If the programmer did not code the loop properly, the loop could keep running... and running...forever (or until the computer was powered down). This condition is called an infinite loop, and is more difficult to accidentally program in Pascal than in assembly language. Definition. A loop is a section of code that repeats itself. Definition. A loop index or loop counter is an integer variable that is used to keep track of how many times a loop has executed. Definition. A loop limit is a variable or constant that is integer-valued, which determines the number of times a loop will execute, or a maximum value of the loop index to be reached at loop termination. Definition. A loop increment is the step size for incrementing the loop counter. Example. The following pseudocode fragment WRITELN('before loop starts') FOR i = 1 TO 5 DO: WRITELN('iteration number ',i) ENDFOR WRITELN('after loop ends') generates this output on the computer monitor: Here, the loop index is the variable \"i\", and the loop limits are one and five, with an implicit loop increment of one. Definition. In certain kinds of loops (WHILE..DO and REPEAT), there is no loop index, but a loop predicate that is a logical predicate (defined in Section 4.1). When the predicate evaluates to false, the loop terminates. Example. Let's rewrite the preceding FOR loop as a loop with a predicate. The following pseudocode fragment WRITELN('before loop starts') i := 0 ## Initialize counter variable WHILE (i <= 5) DO: ## Loop with predicate in () i := i + 1 ## Increment counter variable WRITELN('iteration number ',i) ENDFOR WRITELN('after loop ends') generates the same output as before, namely, Here, the loop predicate is the relational test \" \", which causes the loop to terminate after i is incremented to six.\n• Question. Apart from basic knowledge about iteration structures, what can we learn from the preceding examples? Answer. First observe that the WHILE..DO loop is more tedious to write and understand than the FOR loop, because the WHILE loop requires that the predicate variable (in this case, \"i\") be changed within the loop. In contrast, the FOR loop increments and keeps track of i internally (i.e., in a manner transparent to the programmer). Second, the WHILE..DO construct only executes the loop contents while the predicate is satisfied. As soon as the predicate evaluates to false, the loop terminates. Example. Consider a situation where one adds characters to a word to form a prespecified test word, as in the following pseudocode: WRITELN('before loop starts') string := 'ADDIS A' ## Initialize test variable test := 'ADDIS ABABA' ## Test value to stop loop on WHILE string <> test DO: WRITELN('string = ',string) ## Show string before it's modified string := string || 'AB' ## Append \"AB\" to the string WRITELN('string = ',string) ## Show string after it's modified ENDFOR WRITELN('after loop ends') WRITELN('string = ',string) ## Write final value of string which forms this output:\n• Question. What happened -- why did the string \"ADDIS ABABA\" not get printed within the loop? Why did we have to add a WRITELN statement after the loop to print it? Answer. The WHILE loop iterates until the predicate is satisfied. In the above example, the predicate tells the runtime module to stop executing the loop when string equals \"ADDIS ABABA\". That means that as soon as the string equals the test value of ADDIS ABABA, then the loop terminates. Thus, the value of the completed string never gets written from inside the loop. Hence, the value of string must be written outside the loop. Since flow of control is sequential, this means that the WRITELN statement must be placed at the end of the loop.\n• Observation. Suppose we want to have the loop execute completely at least once. This can be done by modifying the WHILE loop so that the controlling predicate is at the end of the loop, instead of at the beginning. Example. Contrast the following pseudocode fragment with the WHILE loop example that we just discussed: WRITELN('before loop starts') string := 'ADDIS A' ## Initialize test variable test := 'ADDIS ABABA' ## Test value to stop loop on REPEAT ## Start loop WRITELN('string = ',string) ## Show string before it's modified string := string || 'AB' ## Append \"AB\" to the string WRITELN('string = ',string) ## Show string after it's modified UNTIL (string == test) ## Test for loop termination WRITELN('after loop ends') WRITELN('string = ',string) ## Write final value of string which forms this output: Note that the output is the same, but the loop structure is different, because the predicate is expressed using the opposite relational operator (i.e., \"==\" instead of \"<>\"). This is due to the semantics or meaning of the statement WHILE (x is true) DO <statements> which has the same meaning as Thus, a WHILE loop can be approximated by a REPEAT loop merely by moving the predicate to the end of the loop and negating the logic of the predicate.\n\nWe next examine the PASCAL syntax of the FOR, WHILE, and REPEAT loops.\n\nPurpose: Repeat statements within the loop while the loop index is incremented within specified bounds. Syntax: FOR loop-index := initial-value TO final-value DO \n\n , where\n\nis the counter to be incremented is the beginning value of the loop index is the ending value of the loop index\n\nNotes: In the preceding example, we have used a parameterized loop, whereby the variable n contains the loop index' final value. This technique is useful in software engineering and will be discussed in greater detail in Section 4.5.\n\nPurpose: The WHILE loop is also called a conditional loop, since it terminates based on a condition encoded in a logical predicate.\n\nPurpose: The REPEAT loop is another example of a conditional loop.\n\nExample: (approximation of previous WHILE loop)\n\nIn the example of the FOR loop, we saw how a variable could be used to specify a loop index. We next elaborate this technique, and show how it can be used to encapsulate a loop in a procedural construct.\n\nVariable loop limits are especially useful when performing tasks in image and signal processing or database manipulations, where the data structure size is parameterized, i.e., can be changed by changing a value encoded in a variable. For example, one often processes images of varying size, cuts or pastes parts of images, etc. By having variable loop indices, you do not need to recode each loop explicity with different limits for different sized images. Once you know how large the image is, you can merely pass the loop limits through the procedure call's argument list and constrain processing to any size image or neighborhood of an image that is within the prespecified array limits.\n\nGood software engineering practice dictates that all loop limits be specified in terms of variables if the loop is to be called from within a procedure, and the loop limits are at any time expected to be flexible. Rather than having to recode a program with variable loop limits (which can be a difficult task), variable limits that are already implemented make the task of resizing a loop much easier. As noted previously, this facilitates modularity and portability of PASCAL code, and makes debugging much easier.\n\nThis concludes our overview of selection and iteration structures in PASCAL. \n\n We next discuss PASCAL files, file I/O, and arrays. \n\n\n\n Copyright © 1997 by Mark S. Schmalz\n\n All rights reserved except printing by UF students registered for this class."
    }
]