[
    {
        "link": "https://geeksforgeeks.org/python-opencv-cv2-imshow-method",
        "document": ""
    },
    {
        "link": "http://opencv24-python-tutorials.readthedocs.io/en/latest/py_tutorials/py_gui/py_image_display/py_image_display.html",
        "document": "Use the function cv2.imread() to read an image. The image should be in the working directory or a full path of image should be given. Second argument is a flag which specifies the way image should be read.\n• cv2.IMREAD_COLOR : Loads a color image. Any transparency of image will be neglected. It is the default flag. Instead of these three flags, you can simply pass integers 1, 0 or -1 respectively. Even if the image path is wrong, it won’t throw any error, but will give you\n\nUse the function cv2.imshow() to display an image in a window. The window automatically fits to the image size. First argument is a window name which is a string. second argument is our image. You can create as many windows as you wish, but with different window names. A screenshot of the window will look like this (in Fedora-Gnome machine): cv2.waitKey() is a keyboard binding function. Its argument is the time in milliseconds. The function waits for specified milliseconds for any keyboard event. If you press any key in that time, the program continues. If 0 is passed, it waits indefinitely for a key stroke. It can also be set to detect specific key strokes like, if key is pressed etc which we will discuss below. cv2.destroyAllWindows() simply destroys all the windows we created. If you want to destroy any specific window, use the function cv2.destroyWindow() where you pass the exact window name as the argument. There is a special case where you can already create a window and load image to it later. In that case, you can specify whether window is resizable or not. It is done with the function cv2.namedWindow(). By default, the flag is . But if you specify flag to be , you can resize window. It will be helpful when image is too large in dimension and adding track bar to windows.\n\nUse the function cv2.imwrite() to save an image. First argument is the file name, second argument is the image you want to save. This will save the image in PNG format in the working directory."
    },
    {
        "link": "https://docs.opencv.org/4.x/db/deb/tutorial_display_image.html",
        "document": "Prev Tutorial: Building OpenCV for Tegra with CUDA \n\n Next Tutorial: Writing documentation for OpenCV \n\n\n\nIn this tutorial you will learn how to:\n• Read an image from file (using cv::imread)\n• Display an image in an OpenCV window (using cv::imshow)\n• Write an image to a file (using cv::imwrite)\n\nIn OpenCV 3 we have multiple modules. Each one takes care of a different area or approach towards image processing. You could already observe this in the structure of the user guide of these tutorials itself. Before you use any of them you first need to include the header files where the content of each individual module is declared. You'll almost always end up using the:\n• core section, as here are defined the basic building blocks of the library\n• imgcodecs module, which provides functions for reading and writing\n• highgui module, as this contains the functions to show an image in a window We also include the iostream to facilitate console line output and input. By declaring , in the following, the library functions can be accessed without explicitly stating the namespace.\n\nAs a first step, the OpenCV python library is imported. The proper way to do this is to additionally assign it the name cv, which is used in the following to reference the library.\n\nNow, let's analyze the main code. As a first step, we read the image \"starry_night.jpg\" from the OpenCV samples. In order to do so, a call to the cv::imread function loads the image using the file path specified by the first argument. The second argument is optional and specifies the format in which we want the image. This may be:\n• IMREAD_COLOR loads the image in the BGR 8-bit format. This is the default that is used here.\n• IMREAD_UNCHANGED loads the image as is (including the alpha channel if present)\n• IMREAD_GRAYSCALE loads the image as an intensity one\n\nAfter reading in the image data will be stored in a cv::Mat object.\n\nAfterwards, a check is executed, if the image was loaded correctly.\n\nThen, the image is shown using a call to the cv::imshow function. The first argument is the title of the window and the second argument is the cv::Mat object that will be shown.\n\nBecause we want our window to be displayed until the user presses a key (otherwise the program would end far too quickly), we use the cv::waitKey function whose only parameter is just how long should it wait for a user input (measured in milliseconds). Zero means to wait forever. The return value is the key that was pressed.\n\nIn the end, the image is written to a file if the pressed key was the \"s\"-key. For this the cv::imwrite function is called that has the file path and the cv::Mat object as an argument."
    },
    {
        "link": "https://geeksforgeeks.org/python-opencv-namedwindow-function",
        "document": "Python OpenCV namedWindow() method is used to create a window with a suitable name and size to display images and videos on the screen. The image by default is displayed in its original size, so we may need to resize the image for it to fit our screen.\n\nCreated windows are referred by their names and can also be used as a placeholder. The function does nothing If a window exists with the same name.\n\nImage used for all the below examples:\n\nExample 1: Working of namedWindow() method with automatically sets the window size\n• In this code, in order to use namedWindow function OpenCV python library is imported.\n• Then by using cv2.imread, a file from a particular location(path) is loaded into ‘image’ variable in default mode.\n• Now to create a window with ‘Display’ name and automatic size for image namedWindow is used.\n• By using cv2.imshow, the custom window is displayed on the screen. After waiting for 0ms user can destroy all windows by pressing any key from the keyboard.\n\nNote: When a user randomly changes size, the window size is changed dimensions of the image remain unchanged."
    },
    {
        "link": "https://stackoverflow.com/questions/73375030/how-to-reduce-the-size-of-the-window-opened-with-cv2-imshow",
        "document": "I'm working on this code. I got a problem with the size of the windows showing 'lane1' and 'lane2'. they are so big and uncomfortable to work with. Does have any function that makes it possible to control the size of windows.\n\nPS: the code is about object detection on multiple ROIs. I'd like to count the number of vehicles showing on each line (that means I got to add some more steps on tracking)"
    },
    {
        "link": "https://stackoverflow.com/questions/8904694/how-to-normalize-a-2-dimensional-numpy-array-in-python-less-verbose",
        "document": "To normalize the rows of the 2-dimensional array I thought of\n\nThere must be a better way, isn't there?\n\nPerhaps to clearify: By normalizing I mean, the sum of the entrys per row must be one. But I think that will be clear to most people."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-normalize-an-array-in-numpy-in-python",
        "document": "How to normalize an array in NumPy in Python?\n\nIn this article, we are going to discuss how to normalize 1D and 2D arrays in Python using NumPy. Normalization refers to scaling values of an array to the desired range.\n\nSuppose, we have an array = [1,2,3] and to normalize it in range [0,1] means that it will convert array [1,2,3] to [0, 0.5, 1] as 1, 2 and 3 are equidistant.\n\nThis can also be done in a Range i.e. instead of [0,1], we will use [3,7].\n\nNow, Lets input array is [1,2,4,8,10,15] and range is again [0,1]\n\nTo normalize a 2D-Array or matrix we need NumPy library. For matrix, general normalization is using The Euclidean norm or Frobenius norm.\n\nThe formula for Simple normalization is\n\nHere, v is the matrix and |v| is the determinant or also called The Euclidean norm. v-cap is the normalized matrix.\n\nBelow are some examples to implement the above:\n\nWe can also use other norms like 1-norm or 2-norm\n\nIn this way, we can perform normalization with NumPy in python."
    },
    {
        "link": "https://stackoverflow.com/questions/42460217/how-to-normalize-a-4d-numpy-array",
        "document": "I have a three dimensional numpy array of images (CIFAR-10 dataset). The image array shape is like below:\n\nBefore I do any deep learning, I want to normalize the data to get better result. With a 1D array, I know we can do min max normalization like this:\n\nHowever, when it comes to a 3D array, I am totally lost. Specifically, I have the following questions:\n• Along which axis do we take the min and max?\n• How do we implement this with the 3D array?\n\nI appreciate your help!\n\nEDIT: It turns out I need to work with a 4D Numpy array with shape , so the first dimension would be the index for the image, and the last 3 dimensions are the actual image. It'll be great if someone can provide me with the code to normalize such a 4D array. Thanks!\n\nEDIT 2: Thanks to @Eric's code below, I've figured it out:"
    },
    {
        "link": "https://medium.com/@Doug-Creates/normalize-an-array-in-numpy-3bd5797fdfe9",
        "document": "Normalizing an array in NumPy involves scaling the values to a range, often between 0 and 1, to standardize the data for further processing, using mathematical operations to adjust the scale without distorting differences in the values of the data.\n\nData scientists, analysts, machine learning engineers, and anyone working with numerical data in Python.\n\n— Importing NumPy: The code starts by importing the NumPy library, which is essential for numerical computations in Python. .\n\n— Defining the Function: A function is defined to take an array as input. .\n\n— Normalization Formula: Inside the function, the normalization formula is applied to the input array.\n\n— Minimum Value: computes the minimum value in the array, which is subtracted from each element to ensure the minimum value of the normalized array is 0.\n\n— Maximum Value: computes the maximum value in the array. The difference between the maximum and minimum values is used as the denominator to scale the array.\n\n— Division: The subtraction result is divided by the maximum-minimum difference, scaling the array values between 0 and 1.\n\n— Returning the Result: The normalized array is returned as the output of the function. .\n\n— Usage: This function can be used to normalize any NumPy array, making it suitable for various data preprocessing tasks in machine learning and data analysis.\n\n— Efficiency: Utilizing NumPy for these operations ensures the code is efficient and can handle large arrays quickly.\n\n— Practical Application: Normalization is a crucial step in data preprocessing, especially in algorithms that are sensitive to the scale of data, such as gradient descent-based optimization.\n\nWhy: Normalization is a crucial step in data preprocessing, especially in machine learning and data analysis, to ensure that numerical data attributes have the same scale. This prevents models from being biased towards variables with higher magnitudes.\n\nNormalizing an array in NumPy involves adjusting the values in the array to a common scale, typically between 0 and 1, without distorting differences in the ranges of values.\n\nSuppose we were tasked with analyzing a dataset of temperature readings from various sensors across a city to identify patterns and anomalies. The dataset, stored as a NumPy array, contains readings in Fahrenheit. To compare these readings effectively and apply machine learning algorithms, we need to normalize the data. We decide to scale the values between 0 and 1. Using Python and NumPy, we calculate the minimum and maximum values of the array and apply the formula to normalize the data. This process allows us to standardize the dataset, making it easier to identify trends and outliers. The normalized data then becomes the foundation for our analysis, enabling us to apply clustering algorithms that reveal significant temperature patterns across the city. Our findings are documented in a report that suggests areas prone to extreme temperatures, guiding the city's resource allocation for improved environmental management.\n\n— Loss of original scale: Normalizing data alters the original scale, which can be problematic if the original scale needs to be referenced or interpreted directly.\n\n — Outliers: Extreme values or outliers can skew the normalization, disproportionately affecting the scaled data.\n\n — Uniformity assumption: Assuming all data should be normalized in the same way can lead to incorrect analyses, especially when dealing with heterogeneous datasets.\n\n— Batch processing: For large datasets, consider normalizing data in batches to optimize memory usage and computational efficiency.\n\n — Reversibility: Keep a record of the original min and max values if you need to revert the data back to its original scale.\n\n — Vectorization: Utilize NumPy’s vectorized operations to ensure the normalization process is as efficient as possible.\n\n— NumPy: A fundamental package for scientific computing with Python. https://en.wikipedia.org/wiki/NumPy\n\n — Data normalization: The process of adjusting values measured on different scales to a common scale. https://en.wikipedia.org/wiki/Feature_scaling\n\n — Machine Learning: The study of computer algorithms that improve automatically through experience. https://en.wikipedia.org/wiki/Machine_learning\n\nThroughout this guide, we’ve explored the essential techniques for normalizing arrays in NumPy, a critical step in data preprocessing for machine learning and statistical analysis. By implementing these methods, I’ve demonstrated how to adjust the scale of numerical data to a common range, enhancing the performance of algorithms and models. The practical examples and demonstrations provided serve as a foundation for anyone looking to standardize their data efficiently. As we move forward, it’s clear that mastering these normalization techniques is indispensable for data scientists and analysts aiming to optimize their workflows and achieve more accurate results in their projects."
    },
    {
        "link": "https://numpy.org/doc/stable/reference/generated/numpy.reshape.html",
        "document": "Gives a new shape to an array without changing its data.\n\nThe new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions. Read the elements of using this index order, and place the elements into the reshaped array using this index order. ‘C’ means to read / write the elements using C-like index order, with the last axis index changing fastest, back to the first axis index changing slowest. ‘F’ means to read / write the elements using Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the ‘C’ and ‘F’ options take no account of the memory layout of the underlying array, and only refer to the order of indexing. ‘A’ means to read / write the elements in Fortran-like index order if is Fortran contiguous in memory, C-like order otherwise. Deprecated since version 2.1: Replaced by argument. Retained for backward compatibility. If , then the array data is copied. If , a copy will only be made if it’s required by . For it raises a if a copy cannot be avoided. Default: . This will be a new view object if possible; otherwise, it will be a copy. Note there is no guarantee of the memory layout (C- or Fortran- contiguous) of the returned array.\n\nIt is not always possible to change the shape of an array without copying the data.\n\nThe keyword gives the index ordering both for fetching the values from , and then placing the values into the output array. For example, let’s say you have an array:\n\nYou can think of reshaping as first raveling the array (using the given index order), then inserting the elements from the raveled array into the new array using the same kind of index ordering as was used for the raveling."
    },
    {
        "link": "https://geeksforgeeks.org/matplotlib-pyplot-imshow-in-python",
        "document": "Matplotlib is a library in Python and it is numerical – mathematical extension for NumPy library. Pyplot is a state-based interface to a Matplotlib module which provides a MATLAB-like interface.\n\nThe imshow() function in pyplot module of matplotlib library is used to display data as an image; i.e. on a 2D regular raster.\n\nParameters: This method accept the following parameters that are described below:\n• X: This parameter is the data of the image.\n• cmap : This parameter is a colormap instance or registered colormap name.\n• norm : This parameter is the Normalize instance scales the data values to the canonical colormap range [0, 1] for mapping to colors\n• vmin, vmax : These parameter are optional in nature and they are colorbar range.\n• alpha : This parameter is a intensity of the color.\n• aspect : This parameter is used to controls the aspect ratio of the axes.\n• interpolation : This parameter is the interpolation method which used to display an image.\n• origin : This parameter is used to place the [0, 0] index of the array in the upper left or lower left corner of the axes.\n• resample : This parameter is the method which is used for resembling.\n• extent : This parameter is the bounding box in data coordinates.\n• filternorm : This parameter is used for the antigrain image resize filter.\n• filterrad : This parameter is the filter radius for filters that have a radius parameter.\n• url : This parameter sets the url of the created AxesImage. Returns: This returns the following:\n\nBelow examples illustrate the matplotlib.pyplot.imshow() function in matplotlib.pyplot:"
    },
    {
        "link": "https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html",
        "document": "The Colormap instance or registered colormap name used to map scalar data to colors. This parameter is ignored if X is RGB(A).\n\nThe normalization method used to scale scalar data to the [0, 1] range before mapping to colors using cmap. By default, a linear scaling is used, mapping the lowest value to 0 and the highest to 1. If given, this can be one of the following:\n• None An instance of or one of its subclasses (see Colormap normalization).\n• None A scale name, i.e. one of \"linear\", \"log\", \"symlog\", \"logit\", etc. For a list of available scales, call . In that case, a suitable subclass is dynamically generated and instantiated. This parameter is ignored if X is RGB(A).\n\nWhen using scalar data and no explicit norm, vmin and vmax define the data range that the colormap covers. By default, the colormap covers the complete value range of the supplied data. It is an error to use vmin/vmax when a norm instance is given (but using a norm name together with vmin/vmax is acceptable). This parameter is ignored if X is RGB(A).\n\nThe aspect ratio of the Axes. This parameter is particularly relevant for images since it determines whether data pixels are square. This parameter is a shortcut for explicitly calling . See there for further details.\n• None 'equal': Ensures an aspect ratio of 1. Pixels will be square (unless pixel sizes are explicitly made non-square in data coordinates using extent).\n• None 'auto': The Axes is kept fixed and the aspect is adjusted so that the data fit in the Axes. In general, this will result in non-square pixels. Normally, None (the default) means to use (default: ). However, if the image uses a transform that does not contain the axes data transform, then None means to not modify the axes aspect at all (in that case, directly call if desired).\n\nThe data X is resampled to the pixel size of the image on the figure canvas, using the interpolation method to either up- or downsample the data. If interpolation is 'none', then for the ps, pdf, and svg backends no down- or upsampling occurs, and the image data is passed to the backend as a native image. Note that different ps, pdf, and svg viewers may display these raw pixels differently. On other backends, 'none' is the same as 'nearest'. If interpolation is the default 'auto', then 'nearest' interpolation is used if the image is upsampled by more than a factor of three (i.e. the number of display pixels is at least three times the size of the data array). If the upsampling rate is smaller than 3, or the image is downsampled, then 'hanning' interpolation is used to act as an anti-aliasing filter, unless the image happens to be upsampled by exactly a factor of two or one. See Interpolations for imshow for an overview of the supported interpolation methods, and Image resampling for a discussion of image antialiasing. Some interpolation methods require an additional radius parameter, which can be set by filterrad. Additionally, the antigrain image resize filter is controlled by the parameter filternorm.\n\nPlace the [0, 0] index of the array in the upper left or lower left corner of the Axes. The convention (the default) 'upper' is typically used for matrices and images. Note that the vertical axis points upward for 'lower' but downward for 'upper'. See the origin and extent in imshow tutorial for examples and a more detailed description.\n\nThe bounding box in data coordinates that the image will fill. These values may be unitful and match the units of the Axes. The image is stretched individually along x and y to fill the box. The default extent is determined by the following conditions. Pixels have unit size in data coordinates. Their centers are on integer coordinates, and their center coordinates range from 0 to columns-1 horizontally and from 0 to rows-1 vertically. Note that the direction of the vertical axis and thus the default values for top and bottom depend on origin:\n• None For the default is .\n• None For the default is . See the origin and extent in imshow tutorial for examples and a more detailed description.\n\nA parameter for the antigrain image resize filter (see the antigrain documentation). If filternorm is set, the filter normalizes integer values and corrects the rounding errors. It doesn't do anything with the source floating point values, it corrects only integers according to the rule of 1.0 which means that any sum of pixel weights must be equal to 1.0. So, the filter function must produce a graph of the proper shape."
    },
    {
        "link": "https://forum.image.sc/t/display-multi-channel-images-with-scikit-image/51009",
        "document": ""
    },
    {
        "link": "https://matplotlib.org/stable/gallery/images_contours_and_fields/image_demo.html",
        "document": "The most common way to plot images in Matplotlib is with . The following examples demonstrate much of the functionality of imshow and the many images you can create.\n\nIt is also possible to show images of pictures.\n\nIt is also possible to interpolate images before displaying them. Be careful, as this may manipulate the way your data looks, but it can be helpful for achieving the look you want. Below we'll display the same (small) array, interpolated with three different interpolation methods.\n\nThe center of the pixel at A[i, j] is plotted at (i+0.5, i+0.5). If you are using interpolation='nearest', the region bounded by (i, j) and (i+1, j+1) will have the same color. If you are using interpolation, the pixel center will have the same color as it does with nearest, but other pixels will be interpolated between the neighboring pixels.\n\nTo prevent edge effects when doing interpolation, Matplotlib pads the input array with identical pixels around the edge: if you have a 5x5 array with colors a-y as below:\n\nMatplotlib computes the interpolation and resizing on the padded array\n\nand then extracts the central region of the result. (Extremely old versions of Matplotlib (<0.63) did not pad the array, but instead adjusted the view limits to hide the affected edge areas.)\n\nThis approach allows plotting the full extent of an array without edge effects, and for example to layer multiple images of different sizes over one another with different interpolation methods -- see Layer images with alpha blending. It also implies a performance hit, as this new temporary, padded array must be created. Sophisticated interpolation also implies a performance hit; for maximal performance or very large images, interpolation='nearest' is suggested.\n\nYou can specify whether images should be plotted with the array origin x[0, 0] in the upper left or lower right by using the origin parameter. You can also control the default setting image.origin in your matplotlibrc file. For more on this topic see the complete guide on origin and extent.\n\nFinally, we'll show an image using a clip path."
    },
    {
        "link": "https://stackoverflow.com/questions/41793931/plotting-images-side-by-side-using-matplotlib",
        "document": "I was wondering how I am able to plot images side by side using for example something like this:\n\nThe closest I got is this:\n\nThis was produced by using this code:\n\nBut I can't seem to get the other images to show. I'm thinking that there must be a better way to do this as I would imagine trying to manage the indexes would be a pain. I have looked through the documentation although I have a feeling I may be look at the wrong one. Would anyone be able to provide me with an example or point me in the right direction?\n\nSee the answer from @duhaime if you want a function to automatically determine the grid size."
    }
]