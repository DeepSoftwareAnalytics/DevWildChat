[
    {
        "link": "https://docs.nginx.com/nginx/admin-guide/dynamic-modules/rtmp",
        "document": "\n• Check the Technical Specifications page to verify that the module is supported by your operating system.\n\nAfter installation you will need to enable and configure the module in F5 NGINX Plus configuration file .\n• Enable dynamic loading of the module with the directive specified in the top-level (“ ”) context:\n• Perform additional configuration as required by the module.\n• Test the configuration and reload NGINX Plus to enable the module:"
    },
    {
        "link": "https://github.com/arut/nginx-rtmp-module",
        "document": "\n• RTMP Video on demand FLV/MP4, playing from local filesystem or HTTP\n• Advanced buffering techniques to keep memory allocations at a minimum level for faster streaming and low memory footprint\n• Proved to work with Wirecast, FMS, Wowza, JWPlayer, FlowPlayer, StrobeMediaPlayback, ffmpeg, avconv, rtmpdump, flvstreamer and many more\n\nSeveral versions of nginx (1.3.14 - 1.5.0) require http_ssl_module to be added as well:\n\nWindows support is limited. These features are not supported\n\napp - should match one of application {} blocks in config\n\nname - interpreted by each application can be empty\n\nModule supports multi-worker live streaming through automatic stream pushing to nginx workers. This option is toggled with rtmp_auto_push directive."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/how-to-set-up-a-video-streaming-server-using-nginx-rtmp-on-ubuntu-20-04",
        "document": "There are many use cases for streaming video. Service providers such as Twitch are very popular for handling the web discovery and community management aspects of streaming, and free software such as OBS Studio is widely used for combining video overlays from multiple different stream sources in real time. While these platforms are very powerful, in some cases you may want to be able to host a stream that does not rely on other service providers.\n\nIn this tutorial, you will learn how to configure the Nginx web server to host an independent RTMP video stream that can be linked and viewed in different applications. RTMP, the Real-Time Messaging Protocol, defines the fundamentals of most internet video streaming. You will also learn how to host HLS and DASH streams that support more modern platforms using the same technology.\n\nTo complete this guide, you will need:\n• An Ubuntu 20.04 server and a non-root user with sudo privileges. You can learn more about how to set up a user with these privileges in our Initial Server Setup with Ubuntu 20.04 guide.\n• Nginx installed, following How To Install Nginx on Ubuntu 20.04.\n\nThis tutorial will use the placeholder domain name your_domain for URLs and hostnames. Substitute this with your own domain name or IP address as you work through the tutorial.\n\nMost modern streaming tools support the RTMP protocol, which defines the basic parameters of an internet video stream. The Nginx web server includes a module that allows you to provide an RTMP stream with minimal configuration from a dedicated URL, just like it provides HTTP access to web pages by default. The Nginx RTMP module isn’t included automatically with Nginx, but on Ubuntu 20.04 and most other Linux distributions you can install it as an additional package.\n\nBegin by running the following commands as a non-root user to update your package listings and install the Nginx module:\n\nInstalling the module won’t automatically start providing a stream. You’ll need to add a configuration block to your Nginx configuration file that defines where and how the stream will be available.\n\nUsing or your favorite text editor, open Nginx’s main configuration file, , and add this configuration block to the end of the file:\n• means that RTMP will be listening for connections on port 1935, which is standard.\n• means that RTMP will be sending data in 4KB blocks, which is also standard.\n• and mean that the server will only allow video to be published from the same server, to avoid any other users pushing their own streams.\n• defines an application block that will be available at the URL path.\n• enables live mode so that multiple users can connect to your stream concurrently, a baseline assumption of video streaming.\n• disables Nginx-RTMP’s recording functionality, so that all streams are not separately saved to disk by default.\n\nSave and close the file. If you are using , press , then when prompted, and Enter.\n\nThis provides the beginning of your RTMP configuration. By default, it listens on port , which means you’ll need to open that port in your firewall. If you configured as part of your initial server setup run the following command.\n\nNow you can reload Nginx with your changes:\n\nYou should now have a working RTMP server. In the next section, we’ll cover streaming video to your RTMP server from both local and remote sources.\n\nThere are multiple ways to send video to your RTMP server. One option is to use , a popular command line audio-video utility, to play a video file directly on your server. If you don’t have a video file already on the server, you can download one using , a command line tool for capturing video from streaming platforms like YouTube. In order to use , you’ll need an up to date Python installation on your server as well.\n\nFirst, install Python and its package manager, :\n\nNext, use to install :\n\nNow you can use to download a video from YouTube. If you don’t have one in mind, try this video, introducing DigitalOcean’s App Platform:\n\nYou’ll see some output as combines the video and audio streams it’s downloading back into a single file – this is normal.\n\nYou should now have a video file in your current directory with a title like . In order to stream it, you’ll want to install :\n\nAnd use to send it to your RTMP server:\n\nThis command is doing a few things to prepare the video for a streaming-friendly format. This isn’t an tutorial, so you don’t need to examine it too closely, but you can understand the various options as follows:\n• specifies that input will be read at its native framerate.\n• specifies the path to our input file.\n• is set to , meaning that you’re copying over the video format you got from YouTube natively.\n• has other parameters, namely , because you need to resample the audio to an RTMP-friendly format. is a widely supported audio codec, hz is a common frequency, and specifies the first version of the AAC spec for compatibility purposes.\n• wraps the video in an format container for maximum compatibility with RTMP.\n\nThe video is sent to because you defined the configuration block in Step 1, and is an arbitrarily chosen URL for this video.\n\nWhile is streaming the video, it will print timecodes:\n\nThis is standard output. If you were converting video to a different format, these might be helpful in order to understand how efficiently the video is being resampled, but in this case, you just want to see that it’s being played back consistently. Using this sample video, you should get exact increments.\n\nWhile ffmpeg is running, you can connect to your RTMP stream from a video player. If you have , , or another media player installed locally, you should be able to view your stream by opening the URL in your media player. Your stream will terminate after has finished playing the video. If you want it to keep looping indefinitely, you can add to the beginning of your command.\n\nNow that you’ve learned to stream static video sources from the command line, you’ll learn how to stream video from dynamic sources using OBS on a desktop.\n\nStep 3 — Streaming Video to Your Server via OBS (Optional)\n\nStreaming via is convenient when you have a prepared video that you want to play back, but live streaming can be much more dynamic. The most popular software for live streaming is OBS, or Open Broadcaster Software – it is free, open source, and very powerful.\n\nOBS is a desktop application, and will connect to your server from your local computer.\n\nAfter installing OBS, configuring it means customizing which of your desktop windows and audio sources you want to add to your stream, and then adding credentials for a streaming service. This tutorial will not be covering your streaming configuration, as it is down to preference, and by default, you can have a working demo by just streaming your entire desktop. In order to set your streaming service credentials, open OBS’ settings menu, navigate to the Stream option and input the following options:\n\nis an arbitrarily chosen path – in this case, your video would be available at . You do not need to enable authentication, but you do need to add an additional entry to the IP whitelist that you configured in Step 1.\n\nBack on the server, open Nginx’s main configuration file, , and add an additional entry for your local IP address. If you don’t know your local IP address, it’s best to just go to a site like What’s my IP which can tell you where you accessed it from:\n\nSave and close the file, then reload Nginx:\n\nYou should now be able to close OBS’ settings menu and click from the main interface! Try viewing your stream in a media player as before. Now that you’ve seen the fundamentals of streaming video in action, you can add a few other features to your server to make it more production-ready.\n\nNow that you have Nginx configured to stream video using the Nginx-RTMP module, a common next step is to enable the RTMP statistics page. Rather than adding more and more configuration details to your main file, Nginx allows you to add per-site configurations to individual files in a subdirectory called . In this case, you’ll create one called :\n\nSave and close the file. The file from this configuration block is used to style and display an RTMP statistics page in your browser. It is provided by the library that you installed earlier, but it comes zipped up by default, so you will need to unzip it and put it in the directory to match the above configuration. Note that you can find additional information about any of these options in the Nginx-RTMP documentation.\n\nCreate the directory, and then uncompress the file with the following commands:\n\nFinally, to access the statistics page that you added, you will need to open another port in your firewall. Specifically, the directive is configured with port , so you will need to add a rule to access Nginx on that port. However, you probably don’t want others to be able to access your stats page, so it’s best only to allow it for your own IP address. Run the following command:\n\nNext, you’ll need to activate this new configuration. Nginx’s convention is to create symbolic links (like shortcuts) from files in to another folder called as you decide to enable or disable them. Using full paths for clarity, make that link:\n\nNow you can reload Nginx again to process your changes:\n\nYou should now be able to go to in a browser to see the RTMP statistics page. Visit and refresh the page while streaming video and watch as the stream statistics change.\n\nYou’ve now seen how to monitor your video stream and push it to third party providers. In the final section, you’ll learn how to provide it directly in a browser without the use of third party streaming platforms or standalone media player apps.\n\nAs a final step, you may want to add support for newer streaming protocols so that users can stream video from your server using a web browser directly. There are two protocols that you can use to create HTTP-based video streams: Apple’s HLS and MPEG DASH. They both have advantages and disadvantages, so you will probably want to support both.\n\nThe Nginx-RTMP module supports both standards. To add HLS and DASH support to your server, you will need to modify the block in your file. Open using or your preferred editor, then add the following highlighted directives:\n\nSave and close the file. Next, add this to the bottom of your :\n\nSave and close the file. Note that you’re using port here, which is another arbitrary choice for this tutorial to avoid conflicting with any services you may be running on port 80 or 443. You’ll want to open that port in your firewall for now too:\n\nFinally, create a directory in your web root to match the configuration block, so that Nginx can generate the necessary files for HLS and DASH:\n\nYou should now have an HLS stream available at and a DASH stream available at . These endpoints will generate any necessary metadata on top of your RTMP video feed in order to support modern APIs.\n\nThe configuration options that you used in this tutorial are all documented in the Nginx RTMP Wiki page. Nginx modules typically share common syntax and expose a very large set of configuration options, and you can review their documentation to change any of your settings from here.\n\nNearly all internet video streaming is implemented on top of RTMP, HLS, and DASH, and by using the approach that you have explored in this tutorial, you can provide your stream via other broadcasting services, or expose it any other way you choose. Next, you could look into configuring Nginx as a reverse proxy in order to make some of these different video endpoints available as subdomains."
    },
    {
        "link": "https://obsproject.com/forum/resources/how-to-set-up-your-own-private-rtmp-server-using-nginx.50",
        "document": "\n• Import other people's streams to incorporate for your own purposes (I use it in my casts for multiple camera angles, like in this video I did of a Tribes Ascend broadcast with multiple camera angles)\n\nMost people who stream enjoy using services such as Twitch.tv or Ustream to deliver video to viewers, and that works well enough. But sometimes you want some more control over your stream, or you want other people to be able to stream to you, or you want to stream to multiple places, or any number of things that requires you to have access to an actual RTMP stream from an RTMP server. This guide will cover the very basics of setting up a simple RTMP server on a Linux computer. Don't worry, it's not too complicated, but having familiarity with Linux will certainly help.A couple things you can do with your own RTMP server that you might be interested in:Alright, so how do you do these kinds of things?Believe it or not, RTMP is actually extremely light on system resources. Essentially it just grabs data from the input and forwards it on to the output, simple data transfer. Don't believe me? My RTMP server for a long time was a Raspberry Pi , a $35 mini-computer, sitting under my desk, and it was capable of hosting3 simultaneous streams, and I never even stressed it to see how many more it could handle. So I assure you, even a cheap old box would suffice.If you don't have your own box, a VPS can also work. I recommend Linode or Digital Ocean as providers. Just make sure you have enough bandwidth...remember that bandwidth usage will be (the size of a stream) * (the number of people uploading + the number of people downloading). So when I have 2 streamers stream to my server, and I download both of them, I can chew up 10GB of bandwidth in 2 hours.I recommend using Ubuntu for the server software for the sake of ease, but you can obviously use whatever you want. As long as you get the dependencies for nginx somewhere besides apt, you can follow this guide just fine.This guide focuses on using Linux. If you want to use Windows, you can find Windows binaries for nginx with the RTMP module already included here: http://nginx-win.ecsds.eu/download/ You can install nginx with the RTMP module via Homebrew: http://brew.sh/homebrew-nginx/ If you are hosting your server in your home, you will have to forward TCP port 1935 to the box...this varies by router, so look up how to set up port forwarding for your router. Also, I recommend using a dynamic DNS service to overcome dynamic IP issues that come up with residential hosting.Log into your box, and make sure you have the necessary tools to build nginx using the following command:Now a bit of info about nginx (pronounced \"engine-X\"). nginx is an extremely lightweight web server, but someone wrote a RTMP module for it, so it can host RTMP streams too. However, to add the RTMP module, we have to compile nginx from source rather than use the apt package. Don't worry, it's really easy. Just follow these instructions. :)From your home directory, download the nginx source code:As of this writing, the latest stable version of nginx is 1.15.1. You can find the latest version on the nginx download page Next, get the RTMP module source code from git:Unpack/unzip them both, and enter the nginx directory:Now we build nginx:And nginx is installed! By default it installs to /usr/local/nginx, so to start the server run the following command:And to test to make sure nginx is running, point your browser to http://<your server ip>/ and you should get the \"Welcome to nginx!\" page.Open your config file, located by default at /usr/local/nginx/conf/nginx.conf and add the following at the very end of the file:This is an extremely basic configuration with a \"live\" application that simply forwards the RTMP stream on to whoever requests it. You can play with it some more later. Here's the whole configuration guide , which shows you how to forward streams to other places (such as Twitch), save recordings of uploads, output stats, etc.Restart nginx with:Your server should now be ready to accept RTMP streams! Let's try it out.Create a new profile in OBS, and change your Broadcast Settings thusly:You may be wondering where that play path \"test\" came from. Well, we just made it up, just now. You can basically make up any play path and stream to it, and put that path into an RTMP player, and it will play back. For simple purposes, authentication isn't necessary in my experience.You should now be able to start streaming to your server. If you hit \"Start Streaming\" and don't get an error from OBS, that's a good sign.So how do you watch it? The easiest way to do so is with VLC (v2.1.0 or later). Just Open a Network Stream and enter in rtmp:// /live/test as the URL. If it all worked right, then you should now be seeing your stream in VLC!You now have a working RTMP server! Congrats!You can add the stream to OBS itself using the Media source or VLC source, or use something like JWPlayer to play back the RTMP stream on a web site you set up.You can also use your RTMP server to forward to other streaming services and channels! Underneath the \"record off;\" line in your nginx.conf, add the following:And any stream streamed to that application will be forwarded on to the other service, as well as being served up from the server! You can add multiple \"pushes\" to forward the stream to multiple locations.Q: Why nginx? Why not crtpmserver/Red5/Wowza?A: I've tried crtmpserver (aka rtmpd) before, and it works, but is harder to use. If you need to use RTSP, though, instead of RTMP, then I recommend it, since the nginx RTMP module doesn't do RTSP. Red5 seemed overly complicated and heavy to me, and written in Java...you can use it if you want though. I haven't investigated it deeply. Wowza is not free. You can use what you like, but so far nginx is lightweight, easy to use, and free, so you're going to have to pry it from my cold, dead hands.Q: How do I X?A: This FAQ is still in progress...ask questions so I can add them here!"
    },
    {
        "link": "https://github.com/microsoft/Broadcast-Development-Kit/blob/main/docs/common/install-and-configure-nginx-with-rtmp-module-on-windows.md",
        "document": "To support RTMP injection in {{insert the name of the solution}} we need to configure NGINX in the host machine. The objective of this guide is to explain how to correctly install and configure NGINX with the RTMP module in Windows, how to inject a live broadcast locally, and how to run NGINX as a Windows service.\n\nDownload as a zip NGINX with RTMP module from the following GitHub repository.\n\nBefore editing the file, to support RTMPS we must copy the SSL certificate (we've mentioned as prerequisite here) and its key into the host machine. (e.g.: C:\\certs)\n\nAfter that, unzip the file in a location of preference (e.g: C:), open file with your text editor of preferences and replace its content with the following code snippet:\n\n; logs/error.log; logs/error.log ; logs/error.log info; logs/nginx.pid; { ; # this.value * 20 = max concurrent connections currently tested with one worker # C1000K should be possible depending there is enough ram/cpu power } { { 127.0.0.1:2940; } { ssl; secure-extraction-1; c:\\\\certs\\\\fullchain.pem; c:\\\\certs\\\\privkey.pem; ; } { 127.0.0.1:2941; } { ssl; secure-extraction-2; c:\\\\certs\\\\fullchain.pem; c:\\\\certs\\\\privkey.pem; ; } { 127.0.0.1:2942; } { ssl; secure-extraction-3; c:\\\\certs\\\\fullchain.pem; c:\\\\certs\\\\privkey.pem; ; } { 127.0.0.1:2943; } { ssl; secure-extraction-4; c:\\\\certs\\\\fullchain.pem; c:\\\\certs\\\\privkey.pem; ; } { 127.0.0.1:2944; } { ssl; secure-extraction-5; c:\\\\certs\\\\fullchain.pem; c:\\\\certs\\\\privkey.pem; ; } { 127.0.0.1:2945; } { ssl; secure-extraction-6; c:\\\\certs\\\\fullchain.pem; c:\\\\certs\\\\privkey.pem; ; } { 127.0.0.1:2946; } { ssl; secure-extraction-7; c:\\\\certs\\\\fullchain.pem; c:\\\\certs\\\\privkey.pem; ; } { 127.0.0.1:2947; } { ssl; secure-extraction-8; c:\\\\certs\\\\fullchain.pem; c:\\\\certs\\\\privkey.pem; ; } { 127.0.0.1:2948; } { ssl; secure-extraction-9; c:\\\\certs\\\\fullchain.pem; c:\\\\certs\\\\privkey.pem; ; } { 127.0.0.1:2949; } { ssl; secure-extraction-10; c:\\\\certs\\\\fullchain.pem; c:\\\\certs\\\\privkey.pem; ; } { 127.0.0.1:29361; } { ssl; publish; c: \\\\certs\\\\fullchain.pem; #root path where your certificate is located e.g.: C:\\certs\\fullchain.pem ssl_certificate_key c: \\\\certs\\\\privkey.pem; #root path where your certificate key is located e.g.: C:\\certs\\privkey.pem allow ; } { 127.0.0.1:29351; } { ssl; live; c: \\\\certs\\\\fullchain.pem; #root path where your certificate is located e.g.: C:\\certs\\fullchain.pem ssl_certificate_key c: \\\\certs\\\\privkey.pem; #root path where your certificate key is located e.g.: C:\\certs\\privkey.pem allow ; # this is public (this is also the default) } } { { 127.0.0.1:2940; 4096; secure-extraction { on; off; publish ; } } { 127.0.0.1:2941; 4096; secure-extraction { on; off; publish ; } } { 127.0.0.1:2942; 4096; secure-extraction { on; off; publish ; } } { 127.0.0.1:2943; 4096; secure-extraction { on; off; publish ; } } { 127.0.0.1:2944; 4096; secure-extraction { on; off; publish ; } } { 127.0.0.1:2945; 4096; secure-extraction { on; off; publish ; } } { 127.0.0.1:2946; 4096; secure-extraction { on; off; publish ; } } { 127.0.0.1:2947; 4096; secure-extraction { on; off; publish ; } } { 127.0.0.1:2948; 4096; secure-extraction { on; off; publish ; } } { 127.0.0.1:2949; 4096; secure-extraction { on; off; publish ; } } { ; 4096; extraction { on; off; } } { ; 4096; extraction { on; off; } } { ; 4096; extraction { on; off; } } { ; 4096; extraction { on; off; } } { ; 4096; extraction { on; off; } } { ; 4096; extraction { on; off; } } { ; 4096; extraction { on; off; } } { ; 4096; extraction { on; off; } } { ; 4096; extraction { on; off; } } { ; 4096; extraction { on; off; } } { 127.0.0.1:29361; 4096; secure-ingest{ on; off; http://localhost/api/bot/validate-stream-key; publish ; play ; # for the pull from rtmp://localhost:19351/live } } { 127.0.0.1:29351; 4096; live { on; off; publish ; # no need to publish on /live -- IMPORTANT!!! play ; rtmp://127.0.0.1:29361/secure-ingest; } } { ; 4096; ingest { on; off; http://localhost/api/bot/validate-stream-key; } test-endpoint { on; off; } } } { { ; { html; } { all; stat.xsl; } { html; } } }\n\nTo start testing the NGINX server, we must open a terminal window, navigate to the NGINX root folder and execute .\n\nOnce the server is running, we are going to locally test the RTMP endpoint by injecting content with GStreamer.\n\nOpen a new command line window, and execute the following command:\n\nThe command will prompt you with a list of input and output multimedia devices. We must identify the audio input device we will be using. We must search for a device with Audio/Source class where its device.api property equals to wasapi, and copy the value of device.strid.\n\nOnce we identified the device and copied its id value, we need to run the following command (GStreamer CLI pipeline) to start capturing the video from your webcam and the audio of the selected device, and process it so we can inject it as an RTMP stream into the RTMP server.\n\nTo validate the server and GStreamer are correctly working, we must start consuming the live endpoint with a player.\n\nOnce VLC is installed, follow these steps:\n• Open VLC's Media menu and click Open Network Stream, or simply hold down CTRL and press N.\n• Paste the URL of the stream you want to watch, with the following format: in the Please enter a network URL box.\n\n\n\nIn order to run NGINX as Windows Service is necessary to wrap the executable file into a Windows Service using an external program.\n\nTo do so, we can use the nssm tool and execute it in the PC or VM where we want to install the service. Download the nssm tool (download link), unzip the package, and execute the tool from the command line.\n\nOnce the tool is open, set the path for the NGINX executable file and click on the Install Service button. After receiving the confirmation message the service is ready to start.\n\nThe first time, the service does not run automatically. We must initialize the service from the Windows services manager or, restart the machine.\n\n← Back to How to run the solution in Azure\n\n← Back to How to run the solution locally | Next: Ngrok →"
    },
    {
        "link": "https://github.com/JIEgOKOJI/nginx-rtmp/blob/master/directives.md",
        "document": "syntax: \n\n context: root\n\n The block which holds all RTMP settings\n\nCreates RTMP application. Unlike http location application name cannot be a pattern.\n\nSocket timeout. This value is primarily used for writing. Most of time RTMP module does not expect any activity on all sockets except for publisher socket. If you want broken socket to get quickly disconnected use active tools like keepalive or RTMP ping. Default is 1 minute.\n\nRTMP ping interval. Zero turns ping off. RTMP ping is a protocol feature for active connection check. A special packet is sent to remote peer and a reply is expected within a timeout specified with ping_timeout directive. If ping reply is not received within this time then connection is closed. Default value for ping is 1 minute. Default ping timeout is 30 seconds.\n\nSets maximum number of RTMP streams. Data streams are multiplexed into a single data stream. Different channels are used for sending commands, audio, video etc. Default value is 32 which is usually ok for many cases.\n\nSets RTMP acknowledge window size. It's the number of bytes received after which peer should send acknowledge packet to remote side. Default value is 5000000.\n\nMaximum chunk size for stream multiplexing. Default is 4096. The bigger this value the lower CPU overhead. This value cannot be less than 128.\n\nMaximum size of input data message. All input data comes split into messages (and further in chunks). A partial message is kept in memory while waiting for it to complete. In theory incoming message can be very large which can be a problem for server stability. Default value 1M is enough for many cases.\n\nSets default buffer length. Usually client sends RTMP command before playing and resets this setting. Default is .\n\nAllow publishing/playing from addresses specified or from all addresses. Allow/deny directives are checked in order of appearance.\n\nSee allow for description.\n\nSpecifies external command with arguments to be executed on every stream published. When publishing stops the process is terminated. Full path to binary should be specified as the first argument. There are no assumptions about what this process should do. However this feature is useful with ffmpeg for stream transcoding. FFmpeg is supposed to connect to nginx-rtmp as a client and output transcoded stream back to nginx-rtmp as publisher. Substitutions of form {var} can be used within command line:\n\nShell-style redirects can be specified in directive for writing output and accepting input. Supported are\n\nMake sure there's no space between redirection character and stream name/number.\n\nYou can specify full path to the command to execute or short command name. In the latter case binary is looked up in directories specified by the environment variable. By default nginx clears the environment which will usually make rtmp module run only binaries located in standard directories like and . To make this always work please keep the original variable value with the following nginx directive.\n\nThe following ffmpeg call transcodes incoming stream to HLS-ready stream (H264/AAC). FFmpeg should be compiled with libx264 & libfaac support for this example to work.\n\nSpecifies external command with arguments to be executed on play event. The command is executed when first client connects to the stream and is killed when the last one disconnects. This directive makes it possible to pull remote stream in any format for local clients.\n\nThe feature works reliably only in single-worker mode. The reason for this is we cannot make sure external process always connects to the right worker. It will obviously connect to a random one. While this will still work in most cases it's not a recommended architecture, it will be unstable and buggy.\n\nDirective arguments are the same as for .\n\nIn the above configuration directive serves all streams. That leads to certain limitations on remote stream name format. It should be possible to construct the remote url using available variables like , etc. When it's not possible you can add directive which permits setting additional stream options in exec-family directives. The only option supported now is option.\n\nis an alias of\n\nThe directive toggles exec options mode. When activated you can add exec-family directive options. The only exec option supported is . This option makes it possible to apply exec only to specified stream. Default if off.\n\nSimilar to but runs specified command at nginx start. Does not support substitutions since has no session context.\n\nSets process termination signal. Default is kill (SIGKILL). You can specify numeric or symbolic name (for POSIX.1-1990 signals).\n\nIf turned on respawns child process when it's terminated while publishing is still on. Default is on;\n\nSets respawn timeout to wait before starting new child instance. Default is 5 seconds.\n\nSpecifies external command with arguments to be executed on publish event. Return code is not analyzed. Substitutions of are supported here as well. In addition variable is supported holding query string arguments.\n\nSpecifies external command with arguments to be executed on play event. Return code is not analyzed. Substitution list is the same as for .\n\nSpecifies external command with arguments to be executed on play_done event. Return code is not analyzed. Substitution list is the same as for .\n\nSpecifies external command with arguments to be executed on publish_done event. Return code is not analyzed. Substitution list is the same as for .\n\nSpecifies external command with arguments to be executed when recording is finished. Substitution of are supported here as well as additional variables\n\nSets metadata sending mode. The value of makes subscribers receive reconstructed metadata packets containing predefined fields like width, height etc. The value of makes clients receive exact copy of publisher metadata block including both standard and specific fields. The value of turns off sending any RTMP metadata to subscribers. Defaults to on.\n\nToggles interleave mode. In this mode audio and video data is transmitted on the same RTMP chunk stream. Defaults to off.\n\nMakes video stream start with a key frame. Defaults to off.\n\nDisable audio until first video frame is sent. Defaults to off. Can be combined with to make client receive video key frame with all other data following it. However this usually increases connection delay. You can tune keyframe interval in your encoder to reduce the delay.\n\nRecent versions of IE need this option to be enabled for normal playback.\n\nSend and to subscribers. Defaults to off.\n\nDrop publisher connection which has been idle (no audio/video data) within specified time. Default is off. Note this only works when connection is in publish mode (after sending command).\n\nSynchronize audio and video streams. If subscriber bandwidth is not enough to receive data at publisher rate, some frames are dropped by server. This leads to synchronization problem. When timestamp difference exceeds the value specified as argument an absolute frame is sent fixing that. Default is 300ms.\n\nIf enabled nginx-rtmp sends NetStream.Play.Start and NetStream.Play.Stop to each subscriber every time publisher starts or stops publishing. If disabled each subscriber receives those notifications only at the start and end of playback. Default is off.\n\nIf disabled nginx-rtmp prevents subscribers from connecting to idle/nonexistent live streams and disconnects all subscribers when stream publisher disconnects. Default is on.\n\nToggles record mode. Stream can be recorded in flv file. This directive specifies what exactly should be recorded:\n• off - no recording at all\n• manual - never start recorder automatically, use control interface to start/stop\n\nThere can be any compatible combination of keys in a single record directive.\n\nRecord suffix can be a pattern in format. The following directive\n\nwill produce files of the form . All supported format options can be found on strftime man page.\n\nIf turned on appends current timestamp to recorded files. Otherwise the same file is re-written each time new recording takes place. Default is off.\n\nToggles file append mode. When turned on recorder appends new data to the old file or creates it when it's missing. There's no time gap between the old data and the new data in file. Default is off.\n\nWhen turned on currently recorded file gets locked with call. That can be checked from elsewhere to find out which file is being recorded. Default is off.\n\nOn FreeBSD you can use tool to check that. On Linux and are unrelated so you are left with writing a simple script checking file lock status. Here's an example of such script .\n\nRestart recording after this number of (milli)seconds. Off by default. Zero means no delay between recordings. If record_unique is off then all record fragments are written to the same file. Otherwise timestamp is appended which makes files differ (given record_interval is longer than 1 second).\n\nCreate recorder block. Multiple recorders can be created withing single application. All the above mentioned recording-related directives can be specified in block. All settings are inherited from higher levels.\n\nToggles sending NetStream.Record.Start and NetStream.Record.Stop status messages (onStatus) to publisher when specific recorder starts or stops recording file. Status description field holds recorder name (empty for default recorder). Off by default.\n\nPlay flv or mp4 file from specified directory or HTTP location. If the argument is prefixed with then it is assumed that file should be downloaded from remote http location before playing. Note playing is not started until the whole file is downloaded. You can use local nginx to cache files on local machine.\n\nMultiple play locations can be specified in a single directive. When multiple directives are specified the location lists are merged and inherited from higher scopes. An attempt to play each location is made until a successful location is found. If such location is not found error status is sent to client.\n\nIndexed FLVs are played with random seek capability. Unindexed FLVs are played with seek/pause disabled (restart-only mode). Use FLV indexer (for example, yamdi) for indexing.\n\nIf you play FLVs recorded with the directive please do not forget to index them before playing. They are created unindexed.\n\nMp4 files can only be played if both video and audio codec are supported by RTMP. The most common case is H264/AAC.\n\nThe two slashes after make ffplay use and application name and the rest of the url as playpath.\n\nSets location where remote VOD files are stored before playing. Default is ;\n\nSets location where remote VOD files copied from directory after they are completely downloaded. Empty value disables the feature. By default it's empty. The feature can be used for caching remote files locally.\n\nThis path should be on the same device as .\n\nCreates pull relay. Stream is pulled from remote machine and becomes available locally. It only happens when at least one player is playing the stream locally.\n\nUrl syntax: . If application is missing then local application name is used. If playpath is missing then current stream name is used instead.\n\nThe following parameters are supported:\n• name - local stream name to bind relay to; if empty or non-specified then all local streams within application are pulled\n• static - makes pull static, such pull is created at nginx start\n\nIf a value for a parameter contains spaces then you should use quotes around the WHOLE key=value pair like this : .\n\nPush has the same syntax as pull. Unlike pull push directive publishes stream to remote server.\n\nTimeout to wait before reconnecting pushed connection after disconnect. Default is 3 seconds.\n\nToggles session relay mode. In this mode relay is destroyed when connection is closed. When the setting is off relay is destroyed when stream is closed so that another relay could possibly be created later. Default is off.\n\nSets HTTP connection callback. When clients issues connect command an HTTP request is issued asynchronously and command processing is suspended until it returns result code. If HTTP 2xx code is returned then RTMP session continues. The code of 3xx makes RTMP redirect to another application whose name is taken from HTTP response header. Otherwise connection is dropped.\n\nNote this directive is not allowed in application scope since application is still unknown at connection stage.\n\nHTTP request receives a number of arguments. POST method is used with application/x-www-form-urlencoded MIME type. The following arguments are passed to caller:\n\nIn addition to the above mentioned items all arguments passed explicitly to connect command are also sent with the callback. You should distinguish connect arguments from play/publish arguments. Players usually have a special way of setting connection string separate from play/publish stream name. As an example here's how these arguments are set in JWPlayer\n\nSets HTTP play callback. Each time a clients issues play command an HTTP request is issued asynchronously and command processing is suspended until it returns result code. HTTP result code is then analyzed.\n• HTTP 3xx redirects RTMP to another stream whose name is taken from HTTP response header. If new stream name is started with then remote relay is created instead. Relays require that IP address is specified instead of domain name and only work with nginx versions greater than 1.3.10. See also .\n\nHTTP request receives a number of arguments. POST method is used with application/x-www-form-urlencoded MIME type. The following arguments are passed to caller:\n\nIn addition to the above mentioned items all arguments passed explicitly to play command are also sent with the callback. For example if stream is accessed with the url then , & are also sent with callback.\n\nSet on_playlist callback. In addition to common HTTP callback variables it receives the following values:\n\nTriggered on every update of playlist written by HLS/DASH handler.\n\nThe same as on_play above with the only difference that this directive sets callback on publish command. Instead of remote pull push is performed in this case.\n\nSets play/publish terminate callback. All the above applies here. However HTTP status code is not checked for this callback.\n\nSame behavior as but only for play end event.\n\nSame behavior as but only for publish end event.\n\nSet record_done callback. In addition to common HTTP callback variables it receives the following values\n• recorder - recorder name in config or empty string for inline recorder\n\nSet update callback. This callback is called with period of . If a request returns HTTP result other than 2xx connection is terminated. This can be used to synchronize expired sessions. Two additional arguments and are passed to this handler:\n• is the number of seconds since play/publish call\n• is RTMP timestamp of the last audio/video packet sent to the client\n\nYou can use argument to individually limit playback duration for each user.\n\nToggles strict mode for callbacks. Default is off. When turned on all connection errors, timeouts as well as HTTP parse errors and empty responses are treated as update failures and lead to connection termination. When off only valid HTTP response codes other that 2xx lead to failure.\n\nEnables local stream redirect for and remote redirects. New stream name is MD5 hash of RTMP URL used for remote redirect. Default is off.\n\nEnables remote stream redirect by return value. New stream name is get through HTTP redirect - must return 30x code and Location header with new streaming URL. Default is off.\n\nSets HTTP method for notifications. Default is POST with content type. In certain cases GET is preferable, for example if you plan to handle the call in section of nginx. In this case you can use variables to access arguments.\n\nWith GET method handling notifications in section can be done this way\n\nIn section set up the following location for clients to play HLS.\n\nSets HLS playlist and fragment directory. If the directory does not exist it will be created.\n\nSets HLS timestamp synchronization threshold. Default is 2ms. This feature prevents crackling noises after conversion from low-resolution RTMP (1KHz) to high-resolution MPEG-TS (90KHz).\n\nToggles HLS continuous mode. In this mode HLS sequence number is started from where it stopped last time. Old fragments are keeped. Default is off.\n\nToggles HLS nested mode. In this mode a subdirectory of is created for each stream. Playlist and fragments are created in that subdirectory. Default is off.\n\nSets base url for HLS playlist items. When empty those items have no prefix and assumed to be at the same location as parent playlist or one level lower when is used. This feature applies both to master (variant) and slave HLS playlists. It can let you download the playlist and play it locally since it contains full references to child playlists or fragments. Empty by default.\n\nToggles HLS cleanup. By default the feature is on. In this mode nginx cache manager process removes old HLS fragments and playlists from HLS directory.\n\nSets granularity for hls fragment ids. If above zero, changes ids to divide the provided value. Default is zero.\n• aligned - switch fragment when incoming timestamp is a multiple of fragment duration. This mode makes it possible to generate identical fragments on different nginx instances\n\nAdds HLS variant entry. When suffix is matched on stream name then variant playlist is created for the current stream with all entries specified by directives in current application. Stripped name without suffix is used as variant stream name. The original stream is processed as usual.\n\nOptional parameters following the suffix are appended to in m3u8 playlist. See HLS spec. 3.3.10. EXT-X-STREAM-INF for the full list of supported parameters.\n\nSets HLS playlist type specified in playlist directive. Live HLS stream is usually played from the current live position which is several fragments to the end of playlist. Event HLS stream is always played from the start of playlist. When in mode make sure playlist length is enough for the whole event. Default is ;\n\nEnables (or disables) client cache with playlist directive. Setting value to enabled allows supported clients to cache segments in a live DVR manner. Setting value to disabled explicitly tells supported clients to never cache segments. Unset by default (playlist directive will be absent).\n\nEnables HLS encryption. AES-128 method is used to encrypt the whole HLS fragments. Off by default.\n\nHere's the example configuration using the HLS encryption. This configuration requires that nginx is built with for https support.\n\nSets the directory where auto-generated HLS keys are saved. Key files have extension and pseudo-random 16-byte content created with the OpenSSL routine. If the directory does not exist it's created in runtime. By default, directory is used for key files. Remember however you should normally restrict access to key files which is easier when these files are stored separately from playlist and fragments.\n\nSets url for HLS key file entries. When empty those items have no prefix and keys are assumed to be at the same location as the playlist. Empty by default.\n\nExample playlist entry with the above setting\n\nSets the number of HLS fragments encrypted with the same key. Zero means only one key is created at the publish start and all fragments within the session are encrypted with this key. Default is zero.\n\nIn section set up the following location for clients to play MPEG-DASH.\n\nSets MPEG-DASH playlist and fragment directory. If the directory does not exists it will be created.\n\nToggles MPEG-DASH nested mode. In this mode a subdirectory of is created for each stream. Playlist and fragments are created in that subdirectory. Default is off.\n\nToggles MPEG-DASH cleanup. By default the feature is on. In this mode nginx cache manager process removes old MPEG-DASH fragments and manifests from MPEG-DASH directory. Init fragments are deleted after stream manifest is deleted.\n\nToggles MPEG-DASH clock compentation element output into MPD. In this mode nginx provides element for MPEG-DASH manifest. Clock compensation provided by DASH-client if possible.\n• http_iso - client must fetch date in ISO format from URI ( )\n\nSets access log parameters. Logging is turned on by default. To turn it off use directive. By default access logging is done to the same file as HTTP access logger ( ). You can specify another log file path in directive. Second argument is optional. It can be used to specify logging format by name. See directive for more details about formats.\n\nCreates named log format. Log formats look very much the same as nginx HTTP log formats. Several variables are supported within log format:\n• - number of bytes sent to client\n• - local time at the end of client connection\n\nDefault log format has the name . Here's the definition of this format\n\nSets maximum number of connections for rtmp engine. Off by default.\n\nStatistics module is NGINX HTTP module unlike all other modules listed here. Hence statistics directives should be located within http{} block.\n\nSets RTMP statistics handler to the current HTTP location. RTMP statistics is dynamic XML document. To watch this document in browser as XHTML page use rtmp_stat_stylesheet directive.\n\nAdds XML stylesheet reference to statistics XML to make it viewable in browser. See rtmp_stat description and example for more information.\n\nMulti-worker live streaming is implemented through pushing stream to remaining nginx workers.\n\nSets auto-push reconnect timeout when worker is killed. Default is 100 milliseconds.\n\nSets directory for UNIX domains sockets used for stream pushing. Default is .\n\nControl module is NGINX HTTP module and should be located within http{} block."
    },
    {
        "link": "https://stackoverflow.com/questions/66091844/rtmp-nginx-exec-push-with-alaw-and-h264",
        "document": "I have 2 RTMP servers, one NGINX with the RTMP module, and a second one that can only consume RTMP with H264 and ALAW, which will receive video from the NGINX one.\n\nI successfully pushed my camera image to the second server using Gstreamer:\n\nNow, I need to send a video from the NGINX server to the second server, but it needs to have H264 video encoding and ALAW audio encoding.\n\nI tried one more intermediate step, where I streamed to the NGINX server and ran\n\nWhat am I missing in the GStreamer command? And how can I add it to the NGINX application to automatically push the streams received? I'm ok with doing it with FFmpeg if I need to.\n\nMy first server will be fed with a stream from a mobile app. This server (NGINX) is configured like this:\n\nThis server should push to a second server (written in Go), which is going to convert RTMP to WebRTC so I can play the stream in a browser. As I previously stated, I have successfully streamed RTMP to the second server with GStreamer, but I want the first server to automatically push to the second, and it's that push that I been able todo yet.\n\nI have used VLC and the encoding is H264, so no problem there. But I do need ALAW instead of MPEG AAC audio, how can I change on the NGINX server when I push it to the second server?"
    },
    {
        "link": "https://stackoverflow.com/questions/71443294/prepend-to-log-output-for-ffmpeg-when-using-exec-push-with-nginx-rtmp-module",
        "document": "I currently have Nginx setup with nginx-rtmp-module and I use it to stream into the live application and then do some FFmpeg work on it into our hls application. My goal is to prepend the stream name to all FFmpeg's log output. In the past, I would just use unique log file names to solve this, but with Docker, it is easier to use a single file.\n\nHere is an excerpt from the live application (non-working)\n\nWhen I use an RTMP connection url like:\n\nMy goal is to generate logs that look like: FFMPEG: [myTestName] [info] ffmpeg version 4.2.4-1ubuntu0.1 Copyright (c) 2000-2020 the FFmpeg developers FFMPEG: [myTestName] [info] built with gcc 9 (Ubuntu 9.3.0-10ubuntu2) FFMPEG: [myTestName] [info] configuration: --prefix=/usr --extra-version=1ubuntu0.1 --toolchain=hardened --libdir=/usr/lib/x86_64-linux-gnu --incdir=/usr/include/x86_64-linux-gnu --arch=amd64 --enable-gpl --disable-stripping --enable-avresample --disable-filter=resample --enable-avisynth --enable-gnutls --enable-ladspa --enable-libaom --enable-libass --enable-libbluray --enable-libbs2b --enable-libcaca --enable-libcdio --enable-libcodec2 --enable-libflite --enable-libfontconfig --enable-libfreetype --enable-libfribidi --enable-libgme --enable-libgsm --enable-libjack --enable-libmp3lame --enable-libmysofa --enable-libopenjpeg --enable-libopenmpt --enable-libopus --enable-libpulse --enable-librsvg --enable-librubberband --enable-libshine --enable-libsnappy --enable-libsoxr --enable-libspeex --enable-libssh --enable-libtheora --enable-libtwolame --enable-libvidstab --enable-libvorbis --enable-libvpx --enable-libwavpack --enable-libwebp --enable-libx265 --enable-libxml2 --enable-libxvid --enable-libzmq --enable-libzvbi --enable-lv2 --enable-omx --enable-openal --enable-opencl --enable-opengl --enable-sdl2 --enable-libdc1394 --enable-libdrm --enable-libiec61883 --enable-nvenc --enable-chromaprint --enable-frei0r --enable-libx264 --enable-shared FFMPEG: [myTestName] [info] libavutil 56. 31.100 / 56. 31.100 FFMPEG: [myTestName] [info] libavcodec 58. 54.100 / 58. 54.100\n\nThank you for your help!"
    },
    {
        "link": "https://github.com/arut/nginx-rtmp-module/issues/920",
        "document": "When utilizing the push directive is there a way to redirect any parameters passed in to the source url to the target url?"
    },
    {
        "link": "https://docs.nginx.com/nginx/admin-guide/dynamic-modules/rtmp",
        "document": "\n• Check the Technical Specifications page to verify that the module is supported by your operating system.\n\nAfter installation you will need to enable and configure the module in F5 NGINX Plus configuration file .\n• Enable dynamic loading of the module with the directive specified in the top-level (“ ”) context:\n• Perform additional configuration as required by the module.\n• Test the configuration and reload NGINX Plus to enable the module:"
    }
]