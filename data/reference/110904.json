[
    {
        "link": "https://stackoverflow.com/questions/37507937/margin-between-items-in-recycler-view-android",
        "document": "I made a class to manage this issue. This class set different margins for the items inside the recyclerView: only the first row will have a top margin and only the first column will have left margin.\n\nyou can set it in your recyclerview this way"
    },
    {
        "link": "https://cesarmorigaki.medium.com/a-better-way-to-set-recyclerview-items-margin-708ea9d3ac25",
        "document": "List is a common component that every Android developer implements in its routine/daily basis. At some point, we need to add a divider between items and/or just adjust the margin for cards to be displayed harmonically. As it’s a common problem, there are plenty of old answers on the internet on how to solve them but most of them are not the best solution. Let’s stick with the margin issue.\n\nSuppose we’re creating a screen that displays a list of cards that each is expected to have a margin of 16dp. We build the item.xml adding the desired margin:\n\nThe item layout alone seems fine but composing it with several others leads to incorrect margins between them. The vertical margin accumulates with the next one, breaking our expectations.\n\nA lazy solution would be to reduce vertical margins to half. Almost everything looks good except for the top margin of the first item and the bottom of the last one. We could play with the margins adding a logic inside the ViewHolder to fix the first and last item.\n\nBut would we duplicate margin/code for every new list? And if we need to reuse the same card view inside a Grid? There is a better way to achieve the same result!\n\nCool! That’s what we need! Using we can create a cleaner and reusable solution. Instead of including the margin inside each item view and adding the logic inside ViewHolder, we’ll create a generic implementation to do this for us.\n\nSetting the ItemDecoration to the RecyclerView:\n\nAlso, we may improve the solution for multiple columns (using ):\n\nAnd the final result using two columns:\n\nI’m not covering these in this article but here are some examples:"
    },
    {
        "link": "https://stackoverflow.com/questions/60579713/recyclerview-different-spacing-between-items-using-scale",
        "document": "Horizontal recyclerView (DiscreteScrollView library) with scaling set to 50% between selected view and others doesn't keep spacing the same. Example below shows that spacing between 1/2 and 4/5 are more spacious than views next to currently selected item on center. It happens gradually by scrolling, for an example going from item 3 to item 2 will be moving item 3/4 apart from each other when onScroll is happening.\n\nspacing between items example I Thought about checking the current width of view when onScroll is happening and programatically reduce the left/right margin by applying new layout params so the space would stay the same.\n\n1. Is it possible to manipulate layoutParams from within viewHolder?\n\n2. Are there any other options to set fixed spacing?\n\nEDIT: adding DividerItemDecoration shows better where the problem is coming from: DividerItemDecoration\n\n3. Is ItemDecoration the right direction for fixing the issue then?"
    },
    {
        "link": "https://developer.android.com/develop/ui/views/layout/recyclerview",
        "document": "Save and categorize content based on your preferences.\n\nRecyclerView makes it easy to efficiently display large sets of data. You supply the data and define how each item looks, and the RecyclerView library dynamically creates the elements when they're needed.\n\nAs the name implies, RecyclerView recycles those individual elements. When an item scrolls off the screen, RecyclerView doesn't destroy its view. Instead, RecyclerView reuses the view for new items that have scrolled onscreen. RecyclerView improves performance and your app's responsiveness, and it reduces power consumption.\n\nSeveral classes work together to build your dynamic list.\n• None is the that contains the views corresponding to your data. It's a view itself, so you add to your layout the way you would add any other UI element.\n• None Each individual element in the list is defined by a view holder object. When the view holder is created, it doesn't have any data associated with it. After the view holder is created, the binds it to its data. You define the view holder by extending .\n• None The requests views, and binds the views to their data, by calling methods in the adapter. You define the adapter by extending .\n• None The layout manager arranges the individual elements in your list. You can use one of the layout managers provided by the RecyclerView library, or you can define your own. Layout managers are all based on the library's abstract class.\n\nYou can see how all the pieces fit together in the RecyclerView sample app (Kotlin) or RecyclerView sample app (Java).\n\nIf you're going to use RecyclerView, there are a few things you need to do. They are explained in detail in the following sections.\n• None Decide how the list or grid looks. Ordinarily, you can use one of the RecyclerView library's standard layout managers.\n• None Design how each element in the list looks and behaves. Based on this design, extend the class. Your version of provides all the functionality for your list items. Your view holder is a wrapper around a , and that view is managed by .\n• None Define the that associates your data with the views.\n\nThere are also advanced customization options that let you tailor your RecyclerView to your exact needs.\n\nThe items in your RecyclerView are arranged by a class. The RecyclerView library provides three layout managers, which handle the most common layout situations:\n• arranges the items in a two-dimensional grid:\n• If the grid is arranged vertically, tries to make all the elements in each row have the same width and height, but different rows can have different heights.\n• If the grid is arranged horizontally, tries to make all the elements in each column have the same width and height, but different columns can have different widths.\n• is similar to , but it does not require that items in a row have the same height (for vertical grids) or items in the same column have the same width (for horizontal grids). The result is that the items in a row or column can end up offset from each other.\n\nYou also need to design the layout of the individual items. You need this layout when you design the view holder, as described in the next section.\n\nOnce you determine your layout, you need to implement your and . These two classes work together to define how your data is displayed. The is a wrapper around a that contains the layout for an individual item in the list. The creates objects as needed and also sets the data for those views. The process of associating views to their data is called binding.\n\nWhen you define your adapter, you override three key methods:\n• None : calls this method whenever it needs to create a new . The method creates and initializes the and its associated , but does not fill in the view's contents—the has not yet been bound to specific data.\n• None : calls this method to associate a with data. The method fetches the appropriate data and uses the data to fill in the view holder's layout. For example, if the displays a list of names, the method might find the appropriate name in the list and fill in the view holder's widget.\n• None : calls this method to get the size of the dataset. For example, in an address book app, this might be the total number of addresses. RecyclerView uses this to determine when there are no more items that can be displayed.\n\nHere's a typical example of a simple adapter with a nested that displays a list of data. In this case, the RecyclerView displays a simple list of text elements. The adapter is passed an array of strings containing the text for the elements.\n\n> * Provide a reference to the type of views that you are using // Create new views (invoked by the layout manager) // Create a new view, which defines the UI of the list item // Replace the contents of a view (invoked by the layout manager) // Get element from your dataset at this position and replace the // contents of the view with that element // Return the size of your dataset (invoked by the layout manager) > * Provide a reference to the type of views that you are using * Initialize the dataset of the Adapter * @param dataSet String[] containing the data to populate views to be used // Create new views (invoked by the layout manager) // Create a new view, which defines the UI of the list item // Replace the contents of a view (invoked by the layout manager) // Get element from your dataset at this position and replace the // contents of the view with that element // Return the size of your dataset (invoked by the layout manager)\n\nThe layout for the each view item is defined in an XML layout file, as usual. In this case, the app has a file like this:\n\nThe following code snippet shows how you can use the .\n\nThe library also offers many ways to customize your implementation. For more information, see Advanced RecyclerView customization.\n\nFollow these steps to enable an edge-to-edge display for a :\n• If the list items initially overlap the system bars, apply insets on the . You can do this by setting to or by using .\n• Allow the list items to draw under the system bars while scrolling by setting to on the .\n\nThe following video shows a with edge-to-edge display disabled (left) and enabled (right):\n\nFor more information about testing on Android, consult the following resources."
    },
    {
        "link": "https://oguzhanaslann.medium.com/a-cleaner-way-to-manage-spacing-in-recyclerview-fcad061f7edb",
        "document": "RecyclerView is one of Android’s most powerful tools for displaying large data sets efficiently in a scrollable list or grid format. However, customizing the spacing between items can be a challenge, particularly when you need fine-grained control over the layout. Developers often rely on padding or margins applied directly to item views, but this approach can become unwieldy and error-prone, especially in complex layouts or when dealing with multiple item types.\n\nIn this article, we’ll explore a cleaner and more flexible approach to adding spacing in a RecyclerView using custom classes. This method provides a maintainable and scalable solution for managing item spacing without the pitfalls of manual padding and margin adjustments. Whether you’re working with simple lists or complex multi-type layouts, decorators offer a more elegant way to handle spacing, minimizing redundant code and ensuring consistent UI layout\n\nWhat are older version of spacing in RecyclerView?\n\nDevelopers often use padding or margins to add spacing directly to item views in a RecyclerView. While this may work in some cases, it’s not the most efficient approach. The main issue is that spacing is applied to the item view itself, which requires manual calculations and adjustments, especially for items at the edges of the list. For example, in a vertical list, you don’t want to add bottom spacing to the last item, which means adding conditions to check if the item is the last one. Though this might seem like a simple check, it quickly leads to duplicated code across adapters.\n\nAlternatively, if your list contains multiple item types, you’ll need to add spacing for each type individually, which can make the code more complex and harder to maintain.\n\nWhat is a better way to add spacing in RecyclerView?\n\nA better solution is to use a custom to manage spacing between items in a . An allows you to add custom drawing and layout offsets to specific item views. Essentially, it provides a way to apply spacing to the top, bottom, left, and right of each item view, ensuring consistent spacing regardless of the view's definition.\n\nHere’s a streamlined implementation of the class. This class extends and includes four properties: top, start, end, and bottom, which define the spacing applied to each side of an item view. The method is overridden to apply these spacings, making it the key function where the spacing is set.\n\nOnce you add this decorator to your , you'll notice the desired spacing between items.\n\nHowever, this approach alone isn’t enough. If applied multiple times to a RecyclerView, it will result in duplicate spacing between items. To resolve this, I developed the following solution:\n\nHere, we check if the decorator is already applied to the . If it is, we remove it before adding the new one, preventing duplicate decorators.\n\nYou might be thinking, “But it still applies the same spacing to all sides of the item view.” You’re right. However, we can extend the class to allow different spacings for each side of the item view. Here’s the extended version of the class:\n\nThis is why the class was designed as an open class—it allows us to easily extend it and apply different spacings to each side of the item view. Additionally, the class is extended and overridden to create a .\n\nWith this setup, we can now introduce a new extension function as follows:\n\nNow we can apply different spacing to different sides of the item view. For instance, we can apply top spacing to the first item and bottom spacing to the last item.\n\nThis solution still works for multi-type items. we can still apply a dedicated spacing decorator for each item type.\n\nFor simplicity, I will use a new extension of Decorator class rather than using SpaceDecorator class.\n\nHere we simply check the adapter type and apply the spacing to the item view based on the item type.\n\nAnd that’s it! We have successfully added spacing between items in a RecyclerView using decorators in Android. This approach is more flexible and maintainable than adding spacing directly to the item view. It allows us to apply custom spacing to different sides of the item view and prevents the duplication of spacing decorators. I hope you found this article helpful and that you can use this approach in your own projects. And as a homework, you can extend the SpacingDecorator class to apply different spacing to different sides of the item view. Happy coding!"
    },
    {
        "link": "https://stackoverflow.com/questions/24618829/how-to-add-dividers-and-spaces-between-items-in-recyclerview",
        "document": "In that case, is it ok to define margins and/or add a custom divider view directly into a list item's layout or is there a better way to achieve my goal?\n\nHowever, I don't see such possibility in the RecyclerView class.\n\nThis is an example of how it could have been done previously in the ListView class, using the divider and dividerHeight parameters:\n\nThe version 25.0.0 of Android Support Library introduced the class: DividerItemDecoration is a RecyclerView.ItemDecoration that can be used as a divider between items of a . It supports both and orientations. Some answers either use methods that have since become deprecated, or don't give a complete solution, so I tried to do a short, up-to-date wrap-up. Unlike , the class doesn't have any divider-related parameters. Instead, you need to extend , a 's inner class: An allows the application to add a special drawing and layout offset to specific item views from the adapter's data set. This can be useful for drawing dividers between items, highlights, visual grouping boundaries and more. All are drawn in the order they were added, before the item views (in ) and after the items (in onDrawOver( , , . Extend , add a custom constructor which takes space as a parameter and override the method: If you don't want to insert space below the last item, add the following condition: Note: you can also modify , and properties for the desired effect. public class DividerItemDecoration extends RecyclerView.ItemDecoration { private static final int[] ATTRS = new int[]{android.R.attr.listDivider}; private Drawable divider; /** * Default divider will be used */ public DividerItemDecoration(Context context) { final TypedArray styledAttributes = context.obtainStyledAttributes(ATTRS); divider = styledAttributes.getDrawable(0); styledAttributes.recycle(); } /** * Custom divider will be used */ public DividerItemDecoration(Context context, int resId) { divider = ContextCompat.getDrawable(context, resId); } @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) { int left = parent.getPaddingLeft(); int right = parent.getWidth() - parent.getPaddingRight(); int childCount = parent.getChildCount(); for (int i = 0; i < childCount; i++) { View child = parent.getChildAt(i); RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams(); int top = child.getBottom() + params.bottomMargin; int bottom = top + divider.getIntrinsicHeight(); divider.setBounds(left, top, right, bottom); divider.draw(c); } } } You can either call the first constructor that uses the default Android divider attributes, or the second one that uses your own drawable, for example drawable/divider.xml: Note: if you want the divider to be drawn over your items, override the method instead. To use your new class, add or to , for example in your fragment's method: private static final int VERTICAL_ITEM_SPACE = 48; private RecyclerView recyclerView; private LinearLayoutManager linearLayoutManager; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View rootView = inflater.inflate(R.layout.fragment_feed, container, false); recyclerView = (RecyclerView) rootView.findViewById(R.id.fragment_home_recycler_view); linearLayoutManager = new LinearLayoutManager(getActivity()); recyclerView.setLayoutManager(linearLayoutManager); //add ItemDecoration recyclerView.addItemDecoration(new VerticalSpaceItemDecoration(VERTICAL_ITEM_SPACE)); //or recyclerView.addItemDecoration(new DividerItemDecoration(getActivity())); //or recyclerView.addItemDecoration( new DividerItemDecoration(getActivity(), R.drawable.divider)); recyclerView.setAdapter(...); return rootView; } There's also Lucas Rocha's library which is supposed to simplify the item decoration process. I haven't tried it though.\n\nFor those who are looking just for spaces between items in the , see my approach where you get equal spaces between all items, except in the first and last items where I gave a bigger padding. I only apply padding to left/right in a horizontal and to top/bottom in a vertical . public class PaddingItemDecoration extends RecyclerView.ItemDecoration { private int mPaddingPx; private int mPaddingEdgesPx; public PaddingItemDecoration(Activity activity) { final Resources resources = activity.getResources(); mPaddingPx = (int) resources.getDimension(R.dimen.paddingItemDecorationDefault); mPaddingEdgesPx = (int) resources.getDimension(R.dimen.paddingItemDecorationEdge); } @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) { super.getItemOffsets(outRect, view, parent, state); final int itemPosition = parent.getChildAdapterPosition(view); if (itemPosition == RecyclerView.NO_POSITION) { return; } int orientation = getOrientation(parent); final int itemCount = state.getItemCount(); int left = 0; int top = 0; int right = 0; int bottom = 0; /** Horizontal */ if (orientation == LinearLayoutManager.HORIZONTAL) { /** All positions */ left = mPaddingPx; right = mPaddingPx; /** First position */ if (itemPosition == 0) { left += mPaddingEdgesPx; } /** Last position */ else if (itemCount > 0 && itemPosition == itemCount - 1) { right += mPaddingEdgesPx; } } /** Vertical */ else { /** All positions */ top = mPaddingPx; bottom = mPaddingPx; /** First position */ if (itemPosition == 0) { top += mPaddingEdgesPx; } /** Last position */ else if (itemCount > 0 && itemPosition == itemCount - 1) { bottom += mPaddingEdgesPx; } } if (!isReverseLayout(parent)) { outRect.set(left, top, right, bottom); } else { outRect.set(right, bottom, left, top); } } private boolean isReverseLayout(RecyclerView parent) { if (parent.getLayoutManager() instanceof LinearLayoutManager) { LinearLayoutManager layoutManager = (LinearLayoutManager) parent.getLayoutManager(); return layoutManager.getReverseLayout(); } else { throw new IllegalStateException(\"PaddingItemDecoration can only be used with a LinearLayoutManager.\"); } } private int getOrientation(RecyclerView parent) { if (parent.getLayoutManager() instanceof LinearLayoutManager) { LinearLayoutManager layoutManager = (LinearLayoutManager) parent.getLayoutManager(); return layoutManager.getOrientation(); } else { throw new IllegalStateException(\"PaddingItemDecoration can only be used with a LinearLayoutManager.\"); } } }\n\nWe can decorate the items using various decorators attached to the recyclerview such as the DividerItemDecoration: Simply use the following ...taken from the answer byEyesClear: public class DividerItemDecoration extends RecyclerView.ItemDecoration { private static final int[] ATTRS = new int[]{android.R.attr.listDivider}; private Drawable mDivider; /** * Default divider will be used */ public DividerItemDecoration(Context context) { final TypedArray styledAttributes = context.obtainStyledAttributes(ATTRS); mDivider = styledAttributes.getDrawable(0); styledAttributes.recycle(); } /** * Custom divider will be used */ public DividerItemDecoration(Context context, int resId) { mDivider = ContextCompat.getDrawable(context, resId); } @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) { int left = parent.getPaddingLeft(); int right = parent.getWidth() - parent.getPaddingRight(); int childCount = parent.getChildCount(); for (int i = 0; i < childCount; i++) { View child = parent.getChildAt(i); RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams(); int top = child.getBottom() + params.bottomMargin; int bottom = top + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); } } } And then use the above as follows: This will display dividers between each item within the list as shown below: And for those of who are looking for more details can check out this guide Using the RecyclerView _ CodePath Android Cliffnotes. Some answers here suggest the use of margins, but the catch is that: If you add both top and bottom margins, they will appear both added between items and they will be too large. If you only add either, there will be no margin either at the top or the bottom of the whole list. If you add half of the distance at the top, half at the bottom, the outer margins will be too small. Thus, the only aesthetically correct solution is the divider that the system knows where to apply properly: between items, but not above or below items."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-add-dividers-in-android-recyclerview",
        "document": "In the article Android RecyclerView in Kotlin, it’s been demonstrated how to implement the Recycler View in Android. But in the case of User Experience, the items need to be distinguished with the divider and proper padding and margins in each item. In this case, the Recycler View Item Decoration comes into the picture. So, in this its been demonstrated how to make actually use the Recycler View Item Decoration and use the dividers and custom dividers in between Recycler View Items. Have a look at the following image to get an overview of the entire discussion.\n\nTo create a new project in Android Studio please refer to How to Create/Start a New Project in Android Studio.\n\nInclude Google material design components dependency in the build.gradle file. After adding the dependencies don’t forget to click on the “Sync Now” button present at the top right corner.\n\nNote that while syncing the project you need to be connected to the network and make sure that you are adding the dependency to the app-level Gradle file as shown below.\n\nThe main layout of the project contains one RecyclerView for demonstration purposes. To implement the same invoke the following code inside the activity_main.xml file.\n\nBefore going to the output we need to populate the RecyclerView with the data. So we need to now work with RecyclerView Adapter and a custom view for the RecyclerView.\n\nThe custom view for the RecyclerView contains one simple icon at the left and two TextViews. To implement the same create a file named recycler_data_view.xml inside the layout folder and invoke the following code.\n\nThe above custom view produces the following output for each item in the list:\n\nNow creating the data for the above custom view by creating a Data Class, using the following code.\n\nThe following code needs to invoke in a separate class by creating the class named as MyRecyclerAdapter.\n\nIn this class, we have to create some sample data for the RecyclerView in the form of a list. To implement the same invoke the following code inside the MainActivity.kt file (comments are added for better understanding).\n\nCreating the default divider for the items in RecyclerView\n\nWe have to create a default Divider using addItemDecoration() method with the RecyclerView instance, we need to pass the ItemDecoration(in this case it is DividerItemDecoration()) instance and the orientation of the LayoutManager(in this case it is vertical) of the recycler view. To implement the same invoke the following code inside the MainActivity.kt file(Comments are added for better understanding).\n\nIf the divider needs to be custom then there is a need to create our own shape in the drawable folder. So here the shape is a rectangle with the height of 2dp and the color, green. To implement the same shape invoke the following code inside the divider.xml file and create this file inside the drawable folder.\n\nNow we need to create our own ItemDecoration class and override the onDraw() method. This method is called once and this method decides where the divider needs to be drawn and how to be drawn. One main important thing here is to do not add the divider for the first and last items. To implement the same invoke the following code inside the RecyclerViewItemDecoration.kt file(comments are added for better understanding).\n\nNow, this custom ItemDecoration needs to be attached to the recycler view. So now working with the MainActivity.kt file, where we need to pass the instance of custom ItemDecoration class(in this case RecyclerViewItemDecoration). To implement the same invoke the following code inside the MainActivity.kt file."
    },
    {
        "link": "https://stackoverflow.com/questions/31242812/how-can-a-divider-line-be-added-in-an-android-recyclerview",
        "document": "below is my xml code -\n\nI am developing an android application where I am using RecyclerView . I need to add a divider in RecyclerView . I tried to add -\n\nThe Right way is to define for the is as following public class SimpleDividerItemDecoration extends RecyclerView.ItemDecoration { private Drawable mDivider; public SimpleDividerItemDecoration(Context context) { mDivider = ContextCompat.getDrawable(context, R.drawable.line_divider); } @Override public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) { int left = parent.getPaddingLeft(); int right = parent.getWidth() - parent.getPaddingRight(); int childCount = parent.getChildCount(); for (int i = 0; i < childCount; i++) { View child = parent.getChildAt(i); RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams(); int top = child.getBottom() + params.bottomMargin; int bottom = top + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); } } } Or If you are using kotlin: SimpleDividerItemDecoration.kt class SimpleDividerItemDecoration(context: Context, @DrawableRes dividerRes: Int) : ItemDecoration() { private val mDivider: Drawable = ContextCompat.getDrawable(context, dividerRes)!! override fun onDrawOver(c: Canvas, parent: RecyclerView) { val left = parent.paddingLeft val right = parent.width - parent.paddingRight val childCount = parent.childCount for (i in 0 until childCount) { val child: View = parent.getChildAt(i) val params = child.layoutParams as RecyclerView.LayoutParams val top: Int = child.bottom + params.bottomMargin val bottom = top + mDivider.intrinsicHeight mDivider.setBounds(left, top, right, bottom) mDivider.draw(c) } } } As pointed out by @Alan S. is depreciated instead of that you can use\n\nAll of these answers got me close but they were each missing a key detail. After a bit of research, I found the easiest route to be a combination of these 3 steps:\n• Create a divider with the right color\n• Set this divider in your theme as the listDivider EDIT: Updated to skip last divider:\n\n After using this a bit, I realized it was drawing a divider after the last item, which was annoying. So I modified Step 1 as follows to override that default behavior in DividerItemDecoration (of course, making a separate class is another option): recyclerView.addItemDecoration( new DividerItemDecoration(context, layoutManager.getOrientation()) { @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) { int position = parent.getChildAdapterPosition(view); // hide the divider for the last child if (position == parent.getAdapter().getItemCount() - 1) { outRect.setEmpty(); } else { super.getItemOffsets(outRect, view, parent, state); } } } );\n\nThe way how I'm handling the Divider view and also Divider Insets is by adding a RecyclerView extension. Add a new extension file by naming View or RecyclerView: and add the extension method inside the RecyclerViewExtension.kt file. where you can specify the left and right margin on and . On your Activity or Fragment where the RecyclerView is initialized, you can set the custom drawable by calling:\n\nSo this might not be the correct way, but I just added a view to the single item view of the RecyclerView (as I don't think there is a built-in function) like so: This means each item will have a line which fills it at its bottom. I made it about 1dp high with a background. This also gives it a kind of \"3D\" effect.\n\nAndroid just makes little things too complicated unfortunately. Easiest way to achieve what you want, without implementing DividerItemDecoration here: Add background color to the RecyclerView to your desired divider color: Add bottom margin (android:layout_marginBottom) to the layout root of the item (list_item.xml): This should give 1dp space between the items and the background color of RecyclerView (which is dark gray would appear as divider).\n\nStart asking to get answers Find the answer to your question by asking. Ask question See similar questions with these tags."
    },
    {
        "link": "https://medium.com/android-news/part-4-item-decorations-in-recyclerview-133cd8c218bb",
        "document": "Hi, if you’re joining from this tutorial, you should check out my first one: Understanding RecyclerView. A high-level Insight. Part -1. Today I am attempting to explain the Item Decorations in RecyclerView in very simple way so that all the developers new to Android World can fully understand how the RecyclerView Works.\n\nBefore we begin, I would love for you to try my latest gaming application that implements all of the features that I am going to talking in this series. Any feedback is appreciated. Open this link in your mobile, if possible.\n\nTry it: Gamezop\n\nThis has been a long journey and I have received much positive feedback on the previous articles. The fact that the articles procures information for the new and coming developers, is the reason why they have succeeded. So following the same pattern, today I am bringing this tutorial that highlights Item Decoration in Recyclerviews."
    },
    {
        "link": "https://repeato.app/how-to-add-dividers-and-spaces-between-items-in-recyclerview",
        "document": "When working with in Android, you might want to add dividers and spaces between items to enhance the UI. Unlike , doesn’t have built-in properties for dividers. However, you can achieve this functionality using . This guide provides a practical approach to adding dividers and spaces.\n\nThe Android Support Library introduced the class, which simplifies adding dividers between items in a with a . It supports both horizontal and vertical orientations.\n\nTo use , follow these steps:\n\nIf you want to customize the divider, you can use a custom drawable:\n\nYou can define your custom drawable in the folder. For example, create a file named :\n\nIf you need more control over the spacing and dividers, you can create a custom . Below is an example of a custom ItemDecoration class for adding vertical space between items:\n\nTo use this custom ItemDecoration, add it to your RecyclerView in your fragment or activity:\n\nFor advanced customization, you can override the and methods of to draw custom dividers:\n\nAdding dividers and spaces in a can significantly improve the user interface of your app. Whether you use the built-in or create a custom , you have the flexibility to achieve the desired look and feel.\n\nWhile working on enhancing your app’s UI, consider using Repeato, a no-code test automation tool for iOS and Android. Repeato allows you to create, run, and maintain automated tests effortlessly. It’s particularly useful for mobile developers, enabling them to focus on creating a great product rather than spending time on test maintenance. Repeato’s computer vision and AI capabilities make it easy to forward test automation tasks to non-technical colleagues or QAs, ensuring a smooth and efficient development process.\n\nLike this article? there’s more where that came from!"
    }
]