[
    {
        "link": "https://stackoverflow.com/questions/48780003/why-and-when-to-use-jvmstatic-with-companion-objects",
        "document": "A is an instance of a real called . So, when you call the Kotlin code from Java, an object of the class is first instantiated behind the scenes. To understand this, let's consider a simple example.\n\nBehind the scenes without\n\nAs you can see in the simplified decompiled Java code above, a class named is generated to represent the . The class holds the singleton instance of the class . The instance is also named as . This is the reason you need to call the functions/properties of the in Java using the :\n\nBehind the scenes with\n\nWhen you annotate a function of a with in Kotlin, a pure function is generated in addition to the non static function . So, now you are able to call the function without the name which is more idiomatic to Java:\n\nThe singleton pattern is generated in both cases. As you can see, in both cases, the instance holds the singleton object and the constructor is made to prevent multiple instances.\n\nThe Java keyword does not create the singletons. You will get the singleton feature only if you create a in Kotlin and then use it from Java. To get singleton from Java, you'll need to write the singleton pattern, the code for which looks like the decompiled Java code shown above.\n\nThere is no performance gain or loss in terms of memory allocation. The reason is that, as you can see in the code above, the extra function that is generated delegates its work to the non static function . This means, creation of the instance is required in both the cases, with as well as without .\n\nThe behaviour of both the setups is the same apart from the extra method that is generated. In Android, if you worry about the method count, you may need to keep an eye on this because an extra copy is created for each annotated function.\n\nWhen to use\n\nWhen you know that your Kotlin code won't be used in Java, you don't have to worry about adding the annotation. This keeps your code cleaner. However, if your Kotlin code is called from Java, it makes sense to add the annotation. This will prevent your Java code from polluting with the name everywhere.\n\nIt's not like an additional keyword on either side. If you add in one place, you can prevent writing the extra word in thousands of places, wherever you call that function. This is especially useful for library creators, if they add in their Kotlin library, the users of that library won't have to use the word in their Java code.\n\nThat's it! Hopefully that helps get the clearer picture of the ."
    },
    {
        "link": "https://stackoverflow.com/questions/48225293/kotlin-static-functions-companion-object-jvmstatic-jvmfield",
        "document": "I have just started messing around with the Kotlin programming language, which is pretty much cooler than Java. I have some doubts related to static methods and fields:\n\nBut if you see below I can access method as a static method, which works without using annotation. But on official doc its throwing error -> Kotlin static method.\n\nQ2: Do I really need and to make things static? As you can see with object, things are working as expected."
    },
    {
        "link": "https://discuss.kotlinlang.org/t/request-remove-annotation-jvmstatic-for-companion-object-functions-and-treat-them-as-such-in-java/12585",
        "document": "Currently, when we convert a Java code into Kotlin, it pollutes all Java files that use the static functions.\n\n This means that if I have this in Java: And I convert the file of class “Foo”, I get this instead: So it changed the Java class file too, and it would have changed all other usages of this static function to be with , polluting them and causing un-needed clutter. On the other hand, we can add to the function on Kotlin, to avoid this and not force the Java code to change.\n\n However, this requires that we add it to every static function, and by definition, it shouldn’t even be needed, because behind the scenes, even though Java “thinks” it’s a static function, it’s not: Note that, even though the members of companion objects look like static members in other languages, at runtime those are still instance members of real objects, and can, for example, implement interfaces: So my request:\n\n Remove all need for in the first place.\n\n Make it work the same for all languages. Let Java access it like on Kotlin, even if it looks like it’s something else. This removes clutter of both in Kotlin files and in Java files.\n\n It also doesn’t force us to change the code of both Kotlin and Java.\n\n No effort, and doesn’t cost anything.\n\nUnfortunately the way Kotlin and Java are compiled do not work in a way that static wrappers can be created on demand. The underpinning cause is the fact that files are compiled individually (and incrementally) mainly for reasons of compilation speed and modularisation (library jars). Another issue is that the Java compiler does not even know about Kotlin so would not be able to recognise the need to generate a forwarding function (or calling the object function directly). What I think you actually want is that the functions are generated as static on the class file rather than as members of the companion object. This also cannot really work well (as you expect it) due to the semantics of companion objects. Member functions of companion objects (even if they do not refer to the companion object itself - so could be static) do still have the scope to access other members of the companion. This capability is provided at jvm level, not compiler level. To make “static” members of companion objects defined on the outer class means that the companion object itself would need to contain synthetic accessor methods as Java for example generates to access private fields in inner classes (we just reversed the problem but didn’t solve anything). Still, this path leads us to the compiler determining that a method could be defined as static (in the same way some quick fixes/static analysis can suggest you to make something static). This would technically not be hard but would be linguistically poor. Basically the accessibility of a function from static context would now depend on implementation details rather than be an explicit part of the interface (by providing it a static keyword). The only case were this may be valid is as optimization in the case of private static members. However, it is a very easy optimization that the JVM can do itself, so JVM targeting compilers normally do not optimize this case. Of course private static members are not that interesting to your case either.\n\nGuys you go too far. Please keep it simple.\n\n If I can add this annotation (and similar ones) manually to each place Java files use the functions, the IDE/compiler (or whatever that converts the Java file into Kotlin) can do it on its own too.\n\n It doesn’t matter what Kotlin/Java think between themselves, because the way it works stay the same. The code behind, as written in the docs, stay the same. The request is to avoid having so many changes to the various Java files, just because we converted a single file from Java to Kotlin.\n\n The changes should be only in the file that was converted. Not in files that use it.\n\nI don’t know who suggested that you ask to remove the annotation entirely. I haven’t seen anything like this in the kotlin slack or this forum and I can’t imagine that someone from the kotlin team would have done so.\n\n Both Alexy and pdvrieze explained, why it’s not possible to simply remove the annotation and I suggested an alternative that as far as I can tell would solve your problem. If changing the java2kotlin converter to automatically add the annotation would help you, you simply need to create an issue (and maybe link it here for other people with a similar problem to find it). If you see a problem in my suggestion I love to hear it so we can find a solution.\n\nIt was told that we should be given a choice of whether to auto-add the annotations or not.\n\n It was also suggested that we would have a LINT check to remove unused or un-needed such annotations (when there is no Java code that uses them).\n\n And someone said that adding the annotations is a clutter, but I explained that having them once per function is less clutter than having “INSTANCE” or something similar in every call to it, and having multiple files being affected is more clutter.\n\n And removing the annotation completely would mean even less clutter. There is really no need for this annotation. Just handle the kotlin code as if everything is annotated, to make Java completely working with Kotlin, without the useless stuff.\n\nMmmm, this gives an interesting reason for not adding the annotation automatically. I don’t think I agree though, for the same reason that the kotlin compiler does not complain about the annotation being present if it is never used as a static method. The function could be used (statically) from another jar outside of the project. It was told that we should be given a choice of whether to auto-add the annotations or not. I think he meant that the choice to add the annotation to each function should be made by you, not that there is a choice of removing the annotation entirely from the kotlin language. I think there can be a strong argument for adding the annotation automatically. Not doing so would in many cases break existing libraries.\n\n Let’s say you are developing a library in java and start moving to kotlin. You convert some file to kotlin. In your project Intellij automatically replaces all static calls to calls to the companion object. So all your tests run fine. This will however break other projects using your library. I’m not sure the clutter of the additional reference is a good enough argument.\n\n If you convert the entire program and not just one or a few files adding the annotation is not what you want.\n\n This might be different if you develop a library and don’t want to change your API (as I explained above). In the discussion on the issue you mentioned interoperability multiple times. Although I understand your argument, I don’t fully agree. Yes, kotlin is committed to interoperability with java, this does not mean however that kotlin can’t have features that java doesn’t or that kotlin needs to support all features java does in a similar way. In other words kotlin only guarantees that every kotlin function can be called from java and vice versa and that they make it as seamless as possible.\n\n For normal functions and classes this means that you won’t even notice them. For properties it means that kotlin automatically generates getters and setters for you and detects java getters and setters and converts them into properties so that you can use them.\n\n There are a few more complicated cases though, mainly inline classes, suspend functions/coroutines and companion objects.\n\n Inline classes for example could be more powerful (eg. with custom constructors) but that would break interoperability so they are not.\n\n For suspend functions there are extra classes in the std-lib so that they can interface with popular java libraries like rx2(https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-rx2/).\n\n As for companion objects kotlin decided to go a different route than java and not add static functions to the language. Instead the created the concept of companion objects, which have a few advantages, like the fact that they can use inheritance. Whether this was the right decision is not 100% clear yet (IMO). This means however that the interoperability between java and kotlin on this point is not completely seamless. Kotlin can handle java statics fine, but java code is a bit more verbose in handling companion objects. To make this a bit easier we have the annotation. TL;DR I don’t think interop is a good argument to argue against the annotation.\n\nWell I just want to avoid having those annotations as they are not really needed, and I also don’t want to affect so many files in the process.\n\n Having no static functions on Kotlin is a disadvantage. And having a single companion object block is annoying (on most languages constants are supposed to be at the top of the code, and this forces us to put them together with other stuff at the bottom).\n\n About interoperability , I think that if Kotlin is supposed to replace Java, it has to provide the same power of coding as on Java. It’s still weird to me that there is no package-visibility-modifier for functions, as I used it a lot, and because of this the IDE gives me a lot of suggestions for auto-completion that I don’t need.\n\n Can you please give an example in code about your argument, of why not to remove the and ?\n\n For , is it because the Java class could have both static and normal functions (meaning methods) ?"
    },
    {
        "link": "https://proandroiddev.com/kotlin-under-the-hood-exploring-objects-companion-objects-and-annotations-jvmstatic-71e1bf1128df",
        "document": "A companion object is tied to a class in Kotlin, allowing us to define static members and methods similar to those in Java.\n• A companion object can only be defined within classes.\n• The companion object is instantiated as soon as the containing class is loaded, meaning it is created even if we haven’t accessed the companion object.\n• You can omit the name for a companion object; if you do, it will default to the name . You can call the method in two ways:\n• With the name of the companion object:\n• Without specifying the name: If you do not give a name to the companion object, you can access it using:\n\nNow, let’s take a closer look at how it all works under the hood. To gain deeper insights, we can use IntelliJ IDEA’s decompilation feature. By navigating to Tools -> Kotlin -> Kotlin Bytecode and selecting Decompile, we can view the underlying Java code generated from our Kotlin constructs. Let’s see what happens when we create an object in Kotlin: Here’s the underlying Java code generated from this Kotlin code: I’ve simplified it by removing assertions and other metadata for clarity. So, what do we observe here?\n• A static variable, , holds the single instance of the class, adhering to the singleton design pattern.\n• The private constructor prevents external instantiation, ensuring that the only way to access the instance is through .\n• Inside the static block, a new instance of is created and assigned to , ensuring that this instance is created only once.\n• Also, we have the method. Note: In Java, a static{ } block is known as a static initialization block. It allows you to execute a block of code when the class is loaded, before any instances of the class are created or any static methods are called.\n\nThis annotation tells the Kotlin compiler to generate an additional static method for a function or static getter/setter methods for a property.\n• It only works in companion objects or object declarations.\n• It is useful when we want to access Kotlin method/property from Java code.\n• The annotation only affects how the code is compiled to bytecode; it has no effect on how the code behaves in Kotlin itself. Let’s take our previous example and see how to call the method of from Java without using . In Kotlin, you can call it directly like this: However, in Java, if you try to do the same: String version = Setting.Utils.getVersion(); // This will give an error You’ll encounter an error. Instead, you need to access the method like this: Why Does This Work Differently? As we previously discussed regarding the under-the-hood code of objects, when we create an object in Kotlin, a final class is generated in Java for that object. This class contains a static variable, , which holds the single instance of the class & compiler generates a private constructor to prevent instantiation from outside the class, ensuring that the only way to access this instance is through . Therefore, in Java, we need to call if we do not use . Now, let’s use in our previous example: With , we can now access these methods directly without needing to reference an instance variable:\n• To get the version from the object, you can simply call:\n• To generate a unique ID from the companion object, you can call: String uid = Setting.generateUniqueId();\n\n// You can also specify the companion object’s name if you want:\n\nString uid = Setting.MyUtils.generateUniqueId(); Now you might wonder how the underlying code looks.\n• An extra static method is created in the parent class for the companion object ( ).\n• The method in the object is treated differently. Instead of creating an extra static method, the method is made static.\n\nUsing tells the Kotlin compiler not to create getters and setters for a property. Instead, it allows you to access the property directly like a regular field in Java. Let’s explore this with an example. In Kotlin, you can access the property easily: However, if you try to access it from Java like this: Utils utils = new Utils();\n\nString version = utils.version; // This will give you an error! You’ll encounter a compilation error. Why is that? Let’s take a look under the hood. Here, you can see that Kotlin generates a private field for and provides a public getter method. Since the field is private, Java cannot access it directly. Now, let’s see what happens when we apply to our property: Now you can access the property from Java. Decompiled code with , it looks like this: is now a public field, with no generated getter. This makes it accessible directly from Java.\n\nIt instructs the compiler to generate multiple overloads of a function based on its default parameter values. In Kotlin, you can call the function in different ways: val repo = Repository()\n\nrepo.getData() // Uses all default values\n\nrepo.getData(page = 2) // Uses default for category and includeTranslation\n\nrepo.getData(includeTranslation = true) // Uses default for category and page However, when you try to call this function from Java, you’ll run into a problem: Repository repo = new Repository();\n\nrepo.getData(); // This will give you an error! public final class Repository {\n\n public final void getData(@NotNull String category, int page, boolean includeTranslation) {\n\n Intrinsics.checkNotNullParameter(category, \"category\");\n\n }\n\n // ... synthetic method\n\npublic static void getData$default(Repository var0, String var1, int var2, boolean var3, int var4, Object var5) {\n\n if ((var4 & 1) != 0) {\n\n var1 = \"default\";\n\n }\n\n\n\n if ((var4 & 2) != 0) {\n\n var2 = 1;\n\n }\n\n\n\n if ((var4 & 4) != 0) {\n\n var3 = false;\n\n }\n\n\n\n var0.getData(var1, var2, var3);\n\n }\n\n} In this case, the method is generated only with all parameters. Java doesn’t support default parameters, so you need to provide values for all of them. Kotlin generates a synthetic method to handle default parameters, but this method isn’t accessible from Java. This synthetic method, like , uses bitwise operations to determine which default values to apply based on the parameters provided. Now, let’s see what happens when we apply :\n• It’s important to note that there’s no overload for just the and parameters. As per the documentation, if a method has parameters and of them have default values, Kotlin generates overloads. These overloads progressively omit parameters from the end.\n• In this case, since is the last parameter with a default value, Kotlin generates overloads that skip directly to and , but you won’t see an overload for just and because is in between.\n• That’s why when you try to call from Java, it will not work. repo.getData(); // ✅\n\nrepo.getData(\"default\"); // Calls with page = 1, includeTranslation = false ✅\n\nrepo.getData(\"default\", 2); // Calls with includeTranslation = false ✅\n\nrepo.getData(\"default\", 2, true); // ✅\n\n\n\nrepo.getData(\"default\", false); // This won't compile ❌"
    },
    {
        "link": "https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.jvm/-jvm-static",
        "document": "Specifies that an additional static method needs to be generated from this element if it's a function. If this element is a property, additional static getter/setter methods should be generated.\n\nSee the Kotlin language documentation for more information."
    },
    {
        "link": "https://kotlinlang.org/docs/null-safety.html",
        "document": "Null safety is a Kotlin feature designed to significantly reduce the risk of null references, also known as The Billion-Dollar Mistake.\n\nOne of the most common pitfalls in many programming languages, including Java, is that accessing a member of a null reference results in a null reference exception. In Java, this would be the equivalent of a , or an NPE for short.\n\nKotlin explicitly supports nullability as part of its type system, meaning you can explicitly declare which variables or properties are allowed to be . Also, when you declare non-null variables, the compiler enforces that these variables cannot hold a value, preventing an NPE.\n\nKotlin's null safety ensures safer code by catching potential null-related issues at compile time rather than runtime. This feature improves code robustness, readability, and maintainability by explicitly expressing values, making the code easier to understand and manage.\n\nThe only possible causes of an NPE in Kotlin are:\n• None Data inconsistency during initialization, such as when:\n• None An uninitialized available in a constructor is used somewhere else (a \"leaking \").\n• None A superclass constructor calling an open member whose implementation in the derived class uses an uninitialized state.\n• None\n• None Attempts to access a member of a reference of a platform type.\n• None Nullability issues with generic types. For example, a piece of Java code adding into a Kotlin , which would require to handle it properly.\n\nIn Kotlin, the type system distinguishes between types that can hold (nullable types) and those that cannot (non-nullable types). For example, a regular variable of type cannot hold : fun main() { //sampleStart // Assigns a non-null string to a variable var a: String = \"abc\" // Attempts to re-assign null to the non-nullable variable a = null print(a) // Null can not be a value of a non-null type String //sampleEnd } You can safely call a method or access a property on . It's guaranteed not to cause an NPE because is a non-nullable variable. The compiler ensures that always holds a valid value, so there's no risk of accessing its properties or methods when it's : fun main() { //sampleStart // Assigns a non-null string to a variable val a: String = \"abc\" // Returns the length of a non-nullable variable val l = a.length print(l) // 3 //sampleEnd } To allow values, declare a variable with a sign right after the variable type. For example, you can declare a nullable string by writing . This expression makes a type that can accept : fun main() { //sampleStart // Assigns a nullable string to a variable var b: String? = \"abc\" // Successfully re-assigns null to the nullable variable b = null print(b) // null //sampleEnd } If you try accessing directly on , the compiler reports an error. This is because is declared as a nullable variable and can hold values. Attempting to access properties on nullables directly leads to an NPE: fun main() { //sampleStart // Assigns a nullable string to a variable var b: String? = \"abc\" // Re-assigns null to the nullable variable b = null // Tries to directly return the length of a nullable variable val l = b.length print(l) // Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type String? //sampleEnd } In the example above, the compiler requires you to use safe calls to check for nullability before accessing properties or performing operations. There are several ways to handle nullables:\n• None Check for with the conditional Read the next sections for details and examples of handling tools and techniques.\n\nCheck for null with the if conditional When working with nullable types, you need to handle nullability safely to avoid an NPE. One way to handle this is checking for nullability explicitly with the conditional expression. For example, check whether is and then access : fun main() { //sampleStart // Assigns null to a nullable variable val b: String? = null // Checks for nullability first and then accesses length val l = if (b != null) b.length else -1 print(l) // -1 //sampleEnd } In the example above, the compiler performs a smart cast to change the type from nullable to non-nullable . It also tracks the information about the check you performed and allows the call to inside the conditional. More complex conditions are supported as well: fun main() { //sampleStart // Assigns a nullable string to a variable val b: String? = \"Kotlin\" // Checks for nullability first and then accesses length if (b != null && b.length > 0) { print(\"String of length ${b.length}\") // Provides alternative if the condition is not met } else { print(\"Empty string\") // String of length 6 } //sampleEnd } Note that the example above only works when the compiler can guarantee that doesn't change between the check and its usage, same as the smart cast prerequisites.\n\nThe safe call operator allows you to handle nullability safely in a shorter form. Instead of throwing an NPE, if the object is , the operator simply returns : fun main() { //sampleStart // Assigns a nullable string to a variable val a: String? = \"Kotlin\" // Assigns null to a nullable variable val b: String? = null // Checks for nullability and returns length or null println(a?.length) // 6 println(b?.length) // null //sampleEnd } The expression checks for nullability and returns if is non-null, or otherwise. The type of this expression is . You can use the operator with both and variables in Kotlin:\n• None A nullable can hold a (for example, ) or a non-null value (for example, ). If it's a non-null value, you can change it to at any point.\n• None A nullable can hold a (for example, ) or a non-null value (for example, ). If it's a non-null value, you cannot change it to subsequently. Safe calls are useful in chains. For example, Bob is an employee who may be assigned to a department (or not). That department may, in turn, have another employee as a department head. To obtain the name of Bob's department head (if there is one), you write the following: This chain returns if any of its properties are . Here's the equivalent of the same safe call but with the conditional: You can also place a safe call on the left side of an assignment: In the example above, if one of the receivers in the safe call chain is , the assignment is skipped, and the expression on the right is not evaluated at all. For example, if either or is , the function is not called.\n\nWhen working with nullable types, you can check for and provide an alternative value. For example, if is not , access . Otherwise, return an alternative value: fun main() { //sampleStart // Assigns null to a nullable variable val b: String? = null // Checks for nullability. If not null, returns length. If null, returns 0 val l: Int = if (b != null) b.length else 0 println(l) // 0 //sampleEnd } Instead of writing the complete expression, you can handle this in a more concise way with the Elvis operator : fun main() { //sampleStart // Assigns null to a nullable variable val b: String? = null // Checks for nullability. If not null, returns length. If null, returns a non-null value val l = b?.length ?: 0 println(l) // 0 //sampleEnd } If the expression to the left of is not , the Elvis operator returns it. Otherwise, the Elvis operator returns the expression to the right. The expression on the right-hand side is evaluated only if the left-hand side is . Since and are expressions in Kotlin, you can also use them on the right-hand side of the Elvis operator. This can be handy, for example, when checking function arguments: fun foo(node: Node): String? { // Checks for getParent(). If not null, it's assigned to parent. If null, returns null val parent = node.getParent() ?: return null // Checks for getName(). If not null, it's assigned to name. If null, throws exception val name = node.getName() ?: throw IllegalArgumentException(\"name expected\") // ... }\n\nThe not-null assertion operator converts any value to a non-nullable type. When you apply the operator to a variable whose value is not , it's safely handled as a non-nullable type, and the code executes normally. However, if the value is , the operator forces it to be treated as non-nullable, which results in an NPE. When is not and the operator makes it return its non-null value (which is a in this example), it accesses correctly: fun main() { //sampleStart // Assigns a nullable string to a variable val b: String? = \"Kotlin\" // Treats b as non-null and accesses its length val l = b!!.length println(l) // 6 //sampleEnd } When is and the operator makes it return its non-null value, and an NPE occurs: fun main() { //sampleStart // Assigns null to a nullable variable val b: String? = null // Treats b as non-null and tries to access its length val l = b!!.length println(l) // Exception in thread \"main\" java.lang.NullPointerException //sampleEnd } The operator is particularly useful when you are confident that a value is not and there’s no chance of getting an NPE, but the compiler cannot guarantee this due to certain rules. In such cases, you can use the operator to explicitly tell the compiler that the value is not .\n\nThe regular Kotlin operator for type casts is the operator. However, regular casts can result in an exception if the object is not of the target type. You can use the operator for safe casts. It tries to cast a value to the specified type and returns if the value is not of that type: fun main() { //sampleStart // Declares a variable of type Any, which can hold any type of value val a: Any = \"Hello, Kotlin!\" // Safe casts to Int using the 'as?' operator val aInt: Int? = a as? Int // Safe casts to String using the 'as?' operator val aString: String? = a as? String println(aInt) // null println(aString) // \"Hello, Kotlin!\" //sampleEnd } The code above prints because is not an , so the cast fails safely. It also prints because it matches the type, so the safe cast succeeds."
    },
    {
        "link": "https://developer.android.com/codelabs/basic-android-kotlin-compose-nullability",
        "document": "This codelab teaches you about nullability and the importance of null safety. Nullability is a concept commonly found in many programming languages. It refers to the ability of variables to have an absence of value. In Kotlin, nullability is intentionally treated to achieve null safety.\n\nNote: While you should use nullable variables for variables that can carry null , you should use non-nullable variables for variables that can never carry null because the access of nullable variables requires more complex handling. You learn about various techniques to handle nullable variables in the next section.\n\nNow that you can use the nullable String? type, can you initialize a variable with an Int value and reassign it to null ?\n\nThe favoriteActor variable originally held a string and is then reassigned to null .\n\nThe output looks like this code snippet:\n\nTo declare nullable variables in Kotlin, you need to add a ? operator to the end of the type. For example, a String? type can hold either a string or null , whereas a String type can only hold a string. To declare a nullable variable, you need to explicitly add the nullable type. Without the nullable type, the Kotlin compiler infers that it's a non-nullable type.\n\nA type is only nullable if you explicitly let it hold null . As the error message says, the String data type is a non-nullable type, so you can't reassign the variable to null .\n\nIn Kotlin, there's a distinction between nullable and non-nullable types:\n\nTo reassign the favoriteActor variable to null , follow these steps:\n\nThere are occasions after you declare a variable when you may want to assign the variable to null . For example, after you declare your favorite actor, you decide that you don't want to reveal your favorite actor at all. In this case, it's useful to assign the favoriteActor variable to null .\n\nPreviously, you learned that you can reassign variables defined with the var keyword to different values of the same type. For example, you can reassign a name variable that's declared with one name to another name as long as the new name is of String type.\n\nThe output looks like this code snippet:\n\nTo use null in code, follow these steps:\n\nHowever, what if you don't have a favorite actor? You might want to assign the variable a \"Nobody\" or \"None\" value. This isn't a good approach because your program interprets the favoriteActor variable to have a \"Nobody\" or \"None\" value rather than no value at all. In Kotlin, you can use null to indicate that there's no value associated with the variable.\n\nIn Unit 1, you learned that when you declare a variable, you need to assign it a value immediately. For example, when you declare a favoriteActor variable, you may assign it a \"Sandra Oh\" string value immediately.\n\nPreviously, you learned to use the operator to access methods and properties of non-nullable variables. In this section, you learn how to use it to access methods and properties of nullable variables.\n\nTo access a property of the non-nullable variable, follow these steps:\n• Remove all the code in the function, and then declare a variable of type and assign it to the name of your favorite actor:\n• Print the number of characters in the variable value with the property and then run this program:\n\nThe output is as expected:\n\nThere are nine characters in the value of the variable, which includes spaces. The number of characters in your favorite actor's name might be different.\n\nImagine that you want to make the variable nullable so that people who don't have a favorite actor can assign the variable to .\n\nTo access a property of the nullable variable, follow these steps:\n• Change the variable type to a nullable type and then run this program:\n\nYou get this error message:\n\nThis error is a compile error. As mentioned in a previous codelab, a compile error happens when Kotlin isn't able to compile the code due to a syntax error in your code.\n\nKotlin intentionally applies syntactic rules so that it can achieve safety, which refers to a guarantee that no accidental calls are made on potentially variables. This doesn't mean that variables can't be . It means that if a member of a variable is accessed, the variable can't be .\n\nThis is critical because if there's an attempt to access a member of a variable that's - known as reference - during the running of an app, the app crashes because the variable doesn't contain any property or method. This type of crash is known as a runtime error in which the error happens after the code has compiled and runs.\n\nDue to the safety nature of Kotlin, such runtime errors are prevented because the Kotlin compiler forces a check for nullable types. check refers to a process of checking whether a variable could be before it's accessed and treated as a non-nullable type. If you wish to use a nullable value as its non-nullable type, you need to perform a check explicitly. You learn about this in the Use conditionals section later in this codelab.\n\nIn this example, the code fails at compile time because the direct reference to the property for the variable isn't allowed because there's a possibility that the variable is .\n\nNext, you learn various techniques and operators to work with nullable types.\n\nYou can use the safe call operator to access methods or properties of nullable variables.\n\nTo use the safe call operator to access a method or property, add a symbol after the variable name and access the method or property with the notation.\n\nThe safe call operator allows safer access to nullable variables because the Kotlin compiler stops any attempt of member access to references and returns for the member accessed.\n\nTo safely access a property of the nullable variable, follow these steps:\n• In the statement, replace the operator with the safe call operator:\n• Run this program and then verify that the output is as expected:\n\nThe number of characters of your favorite actor's name might differ.\n• Reassign the variable to and then run this program:\n\nYou see this output:\n\nNotice that the program doesn't crash despite an attempt to access the property of a variable. The safe call expression simply returns .\n\nYou can also use the not-null assertion operator to access methods or properties of nullable variables.\n\nAfter the nullable variable, you need to add the not-null assertion operator followed by the operator and then the method or property without any spaces.\n\nAs the name suggests, if you use the not-null assertion, it means that you assert that the value of the variable isn't , regardless of whether it is or isn't.\n\nUnlike safe-call operators, the use of a not-null assertion operator may result in a error being thrown if the nullable variable is indeed . Thus, it should be done only when the variable is always non-nullable or proper exception handling is set in place. When not handled, exceptions cause runtime errors. You learn about exception handling in later units of this course.\n\nTo access a property of the variable with the not-null assertion operator, follow these steps:\n• Reassign the variable to your favorite actor's name and then replace the safe-call operator with the not-null assertion operator in statement:\n• Run this program and then verify that the output is as expected:\n\nThe number of characters of your favorite actor's name might differ.\n• Reassign the variable to and then run this program:\n\nThis Kotlin error shows that your program crashed during execution. As such, it's not recommended to use the not-null assertion operator unless you're sure that the variable isn't .\n\nYou can use the branch in the conditionals to perform checks.\n\nTo perform checks, you can check that the nullable variable isn't equal to with the comparison operator.\n\nAn statement can be used together with a check as follows:\n\nThe null check is useful when combined with an statement:\n• The check of the expression is used as the condition.\n• Body 1 inside the branch assumes that the variable is not . Therefore, in this body, you can freely access methods or properties of the variable as if it's a non-nullable variable without using a safe-call operator or a not-null assertion operator.\n• Body 2 inside the branch assumes that the variable is . Therefore, in this body, you can add statements that should run when the variable is . The branch is optional. You can use only the conditional to run a check without providing default action when the check fails.\n\nThe check is more convenient to use with the condition when there are multiple lines of code that use the nullable variable. In contrast, the safe-call operator is more convenient for a single reference of the nullable variable.\n\nTo write an statement with a check for the variable, follow these steps:\n• Assign the variable to the name of your favorite actor again and then remove the statement:\n• In the body of the branch, add a statement that accepts a \"The number of characters in your favorite actor's name is ${favoriteActor.length}.\" string and then run this program:\n\nThe output is as expected.\n\nThe number of characters in your favorite actor's name might differ.\n\nNotice that you can access the name's length method directly with the operator because you access the method inside the branch after the check. As such, the Kotlin compiler knows that there's no possibility that the variable is , so the compiler allows direct access to the property.\n• Optional: Add an branch to handle a situation in which the actor's name is :\n• In the body of the branch, add a statement that takes a string:\n• Assign the variable to and then run this program:\n\nThe output is as expected:\n\nYou can also combine the check with an expression to convert a nullable variable to a non-nullable variable.\n\nTo assign an expression to a non-nullable type:\n• The check is used as the condition.\n• Body 1 inside the branch assumes that the variable is not . Therefore, in this body, you can access methods or properties of the variable as if it's a non-nullable variable without a safe call operator or a not-null assertion operator.\n• Body 2 inside the branch assumes that the variable is . Therefore, in this body you can add statements that should run when the variable is .\n• In the final line of body 1 and 2, you need to use an expression or value that results in a non-nullable type so that it's assigned to the non-nullable variable when the check passes or fails respectively.\n\nTo use the expression to rewrite the program so that it only uses one statement, follow these steps:\n• Assign the variable to the name of your favorite actor:\n• Create a variable and then assign it to the expression:\n• Remove both statements from the and branches:\n• In the body of the branch, add a expression:\n\nThe property of the variable is accessed directly with the operator.\n• In the body of the branch, add a value:\n\nThe value serves as the default value when the name is .\n• At the end of the function, add a statement that takes a \"The number of characters in your favorite actor's name is $lengthOfName.\" string and then run this program:\n\nThe output is as expected:\n\nThe number of characters of the name that you used might differ.\n\nThe Elvis operator is an operator that you can use together with the safe-call operator. With the Elvis operator, you can add a default value when the safe-call operator returns . It's similar to an expression, but in a more idiomatic way.\n\nIf the variable isn't , the expression before the Elvis operator executes. If the variable is , the expression after the Elvis operator executes.\n\nTo modify your previous program to use the Elvis operator, follow these steps:\n• Remove the conditional and then set the variable to the nullable variable and use the safe-call operator to call its property:\n• After the property, add the Elvis operator followed by a value and then run this program:\n\nThe output is the same as the previous output:"
    },
    {
        "link": "https://stackoverflow.com/questions/72380994/kotlin-safe-calls-vs-non-null-assertions",
        "document": "Hi guys I was doing a little bit of reading and playing around with the kotlin language. I still can't figure out why would anybody use null checks over safe calls?\n\nSafe calls would just return a null value if the value is null, this won't crash your app. Null checks on the other hand would raise a nullexceptionerror if the value is null. I have tried searching for the reason to use one over the other, but I can't find any resource about that.\n\nIs there a reason to use safe calls over null checks and vice-versa?"
    },
    {
        "link": "https://dhiwise.com/post/kotlin-null-safety-a-comprehensive-guide-for-developers",
        "document": "Passionate about designing and crafting efficient algorithms—because slow code is a crime. Thrives on optimizing performance, tackling complex problems, and transforming logic into elegant solutions. Probably refining an algorithm while sipping tea.\n\nNull safety is a fundamental building block in the Kotlin programming language. Kotlin's null safety is a procedure to eliminate the risk of null reference from the code which is known to create the notorious NullPointerException that we often end up with in Java.\n\nYou have experienced unending headaches if you have ever encountered a NullPointerException in your code. Kotlin's null safety features come as a rescue here.\n\nIn many programming languages, including Java, accessing a member of a null reference typically results in a null reference exception. Kotlin offers many ways to avoid null reference exceptions.\n\nConsider the following example:\n\nIn Kotlin, if you try to assign null to a non-nullable variable, the compiler will raise a compilation error.\n\nKotlin null safety is a major step forward in the world of programming because it brings in checks and codified practices to make your code safer and your apps more stable.\n\nIn Kotlin, the type system differentiates between references that can hold null (nullable references) and those that cannot (non-null references). By default, all types are non-nullable in Kotlin. So you can't assign null to them. For instance, the following Kotlin code will not compile:\n\nIn the preceding code, the name is a variable of non-nullable String type and we are trying to assign null to it which is not allowed.\n\nTo hold null values, you need to create a nullable reference using the \"?\" symbol. For example:\n\nName is a nullable string in the above fragment, which can hold null values. It can be either a String or null.\n\nTo understand the origin and importance of Kotlin's null safety feature, it's crucial to understand the issues nullability poses. In other programming languages, coding errors, data inconsistency, or even just unexpected inputs can lead to null references where objects are expected. This can result in NullPointerExceptions which lead to application crashes.\n\nHandling null values and avoiding null pointer exceptions is one of the concepts that makes Kotlin stand out from other languages. Providing this feature in Kotlin is a brilliant way to improve code quality.\n\nIn Kotlin, null safety is baked into its type system. Variables are by default non-nullable.\n\nFor nullable references, Kotlin provides a few operators:\n\nSafe call operator (?): Invokes the method, if the property is not null, otherwise, returns null.\n\nElvis operator (?:): Returns the left operand if it's not null; otherwise, returns the right one.\n\nNot-null assertion operator (!!): Converts the nullable reference to a non-null reference and throws a null pointer exception if the reference is null.\n\nUsing these powerful operators, Kotlin's null safety approach is much more robust than those in many counterparts. It transforms potential runtime exceptions into compile-time errors.\n\nIn other languages, handling null can require additional code or may involve third-party libraries. Such methods can introduce more complexity or grow the application size.\n\nIn comparison, Kotlin incorporates null safety at the language level. This reduces boilerplate and approaches null safety consistently throughout your Kotlin code, enhancing readability and reducing error-prone null-handling practices.\n\nIn conclusion, Kotlin achieved null safety by using nullable and non-nullable types, safe calls, and the Elvis operator. It has impressively mitigated the dreaded NullPointerException, to keep our code safer and cleaner.\n\nDifferent Types of Null in Kotlin\n\nIn Kotlin, nullability is embedded in the default static type system. That means nullability is checked at compile time. Broadly, Kotlin null types can be classified into nullable and non-nullable types.\n\nHere name1 is a non-nullable type, meaning it cannot hold null. On the other hand, name2 is a nullable type, it allows the assignment of the null value to it.\n\nHow To Check if Null In Kotlin?\n\nKotlin offers explicit methods to check if a variable is null. This helps to prevent Null Pointer Exceptions or, more commonly, a runtime exception at the time of application execution. Here is an example of a null check in Kotlin:\n\nKotlin doesn't have an 'isnull' operator like some other languages. Instead, it provides a safe call operator (?.). This operator allows developers to perform a null check and method invocation in a single expression.\n\nHere, the length variable will be assigned the length of the name if the name is not null; otherwise, it will be assigned null.\n\nKotlin includes the !! operator, also known as the Not Null Assertion Operator. It converts any nullable type to a non-nullable type and throws a Null Pointer Exception if the value is null. This operator should only be used when you are certain that the value will not be null.\n\nThis allows developers to spot potential null pointer exceptions more easily during debugging and ensures Kotlin's null safety mechanism is upheld.\n\nWorking with null values effectively is crucial to maintain Kotlin's null safety standards. Here is an example using the Elvis operator (?:):\n\nHere, if name is not null, its length will be stored in the length variable. Otherwise, zero will be returned.\n\nUnderstanding the Default Value Concept in Kotlin\n\nKotlin's default value is a value to be assigned to a variable when no other value is explicitly assigned to it. This enables the handling of null values without contradicting Kotlin's null safety norms.\n\nHere, \"Guest\" is the default value. If we invoke the function display() without passing any value, the default value \"Guest\" is used.\n\nUsing Kotlin allows for easily avoiding NullPointerException due to null safety features incorporated in its design. Let's put theory into practice through a Kotlin null check and Kotlin is null exercises.\n\nAs we see, null safety in Kotlin drastically reduces the risk of NullPointerExceptions. The benefits Kotlin brought to the development environment are high and so it demonstrates the progressive future for null safety in Kotlin. Newer versions of Kotlin will seek to optimize null safety provisions even further.\n\nWith the advent of more advanced frameworks and the expansion of Kotlin for different environments (such as native and JS), effective null safety provisions will further evolve to cater to various coding requirements and paradigms.\n\nSince its initiation, Kotlin's null safety provisions have been instrumental in minimizing the possibility of NullPointerExceptions, which are one of the most common run-time problems faced in other programming languages.\n\nKotlin's approach to solving the null safety issue using nullable and non-nullable types, safe calls, and not null assertions has been reliable and effective. Developers can now write code in Kotlin, knowing that it will prevent unforeseen null pointer exceptions that can arise from data inconsistency or unexpected behavior.\n\nKotlin's safety provisions, including null safety, are at the forefront of making it one of the most loved programming languages currently. It enables developers to write code more fearlessly and confidently. As the Kotlin journey continues, it addresses the dreadful NullPointerException issue that has tormented developers for quite some time now.\n\nGuided by the principle of \"safety and precision,\" Kotlin makes a developer's life easier and more efficient by providing a far more straightforward and streamlined approach to null safety.\n\nShort on time? Speed things up with DhiWise!\n\nTired of manually designing screens, coding on weekends, and technical debt? Let DhiWise handle it for you!\n\nYou can build an e-commerce store, healthcare app, portfolio, blogging website, social media or admin panel right away. Use our library of 40+ pre-built free templates to create your first application using DhiWise."
    },
    {
        "link": "https://stackoverflow.com/questions/34498562/in-kotlin-what-is-the-idiomatic-way-to-deal-with-nullable-values-referencing-o",
        "document": "First, you should read all about Null Safety in Kotlin which covers the cases thoroughly.\n\nIn Kotlin, you cannot access a nullable value without being sure it is not (Checking for null in conditions), or asserting that it is surely not using the sure operator, accessing it with a Safe Call, or lastly giving something that is possibly a default value using the Elvis Operator.\n\nFor your 1st case in your question you have options depending on the intent of the code you would use one of these, and all are idiomatic but have different results:\n\nFor the \"Why does it work when null checked\" read the background information below on smart casts.\n\nFor your 2nd case in your question in the question with , if you as a developer are sure of the result never being , use sure operator as an assertion:\n\nor in another case, when the map COULD return a null but you can provide a default value, then itself has a method:\n\nNote: in the examples below I am using explicit types to make the behavior clear. With type inference, normally the types can be omitted for local variables and private members.\n\nMore about the sure operator\n\nThe operator asserts that the value is not or throws an NPE. This should be used in cases where the developer is guaranteeing that the value will never be . Think of it as an assert followed by a smart cast.\n\nMore about Checking and Smart Casts\n\nIf you protect access to a nullable type with a check, the compiler will smart cast the value within the body of the statement to be non-nullable. There are some complicated flows where this cannot happen, but for common cases works fine.\n\nOr if you do a check for a non-nullable type:\n\nAnd the same for 'when' expressions that also safe cast:\n\nSome things do not allow the check to smart cast for the later use of the variable. The example above uses a local variable that in no way could have mutated in the flow of the application, whether or this variable had no opportunity to mutate into a . But, in other cases where the compiler cannot guarantee the flow analysis, this would be an error:\n\nThe lifecycle of the variable is not completely visible and may be assigned from other threads, the check cannot be smart cast into a non-nullable value. See the \"Safe Calls\" topic below for a workaround.\n\nAnother case that cannot be trusted by a smart cast to not mutate is a property on an object that has a custom getter. In this case, the compiler has no visibility into what mutates the value and therefore you will get an error message:\n\nread more: Checking for null in conditions\n\nMore about the Safe Call operator\n\nThe safe call operator returns null if the value to the left is null, otherwise continues to evaluate the expression to the right.\n\nAnother example where you want to iterate a list but only if not and not empty, again the safe call operator comes in handy:\n\nIn one of the examples above we had a case where we did an check but have the chance another thread mutated the value and therefore no smart cast. We can change this sample to use the safe call operator along with the function to solve this:\n\nMore about the Elvis Operator\n\nThe Elvis operator allows you to provide an alternative value when an expression to the left of the operator is :\n\nIt has some creative uses as well, for example throw an exception when something is :\n\nor to return early from a function:\n\nKotlin stdlib has a series of functions that work really nicely with the operators mentioned above. For example:\n\nIn Kotlin, most applications try to avoid values, but it isn't always possible. And sometimes makes perfect sense. Some guidelines to think about:\n• None in some cases, it warrants different return types that include the status of the method call and the result if successful. Libraries like Result give you a success or failure result type that can also branch your code. And the Promises library for Kotlin called Kovenant does the same in the form of promises.\n• None for collections as return types always return an empty collection instead of a , unless you need a third state of \"not present\". Kotlin has helper functions such as or to create these empty values.\n• None when using methods which return a nullable value for which you have a default or alternative, use the Elvis operator to provide a default value. In the case of a use the which allows a default value to be generated instead of method which returns a nullable value. Same for\n• None when overriding methods from Java where Kotlin isn't sure about the nullability of the Java code, you can always drop the nullability from your override if you are sure what the signature and functionality should be. Therefore your overridden method is more safe. Same for implementing Java interfaces in Kotlin, change the nullability to be what you know is valid.\n• None look at functions that can help already, such as for and which can operate on a nullable value safely and do what you expect. In fact, you can add your own extensions to fill in any gaps in the standard library.\n• None assertion functions like and in the standard library.\n• None helper functions like which remove nulls from collections, or for returning a zero or single item list from a possibly value.\n• None there is a Safe (nullable) cast operator as well that allows a cast to non-nullable type return null if not possible. But I do not have a valid use case for this that isn't solved by the other methods mentioned above."
    }
]