[
    {
        "link": "https://tutorialspoint.com/c_standard_library/c_function_system.htm",
        "document": "The C stdlib library system() function is used to execute an operating system command specified by the string 'command' from a c/c++ program. It returns an integer status indicating the success or failure of the command execution.\n\nThis function is OS-dependent. We use 'system(\"dir\")' on Windows and 'system(\"ls\")' on Unix to list the directory contents.\n\nNote: This function lists the files of the current directory when compiled on our system. If compiled using an online compiler, it will only show 'main main.c'.\n\nFollowing is the syntax of the system() function −\n• None string − it represents a pointer to a null-terminated string contains a command we want to execute.\n\nThis function returns 0 if the command is executed successfully. Otherwise, it returns a non-zero value.\n\nIn this example, we create a basic c program to demonstrate the use of system() function.\n\nFollowing is the output, which shows the list of current directory −\n\nLet's create another c program and use the system() function to run an external command (the echo command).\n\nFollowing is the output −"
    },
    {
        "link": "https://ibm.com/docs/en/i/7.5?topic=extensions-standard-c-library-functions-table-by-name",
        "document": "1 This function is not supported for files opened with type=record. 2 This function is not supported for files opened with type=record and mode=ab+, rb+, or wb+. 3 The ILE C compiler only supports fully buffered and line-buffered streams. Since a block and a line are equal to the record length of the opened file, fully buffered and line-buffered streams are supported in the same way. The and functions have no effect. 4 This function is not available when LOCALETYPE(*CLD) is specified on the compilation command. 5 This function is available only when SYSIFCOPT(*IFSIO) is specified on the CRTCMOD or CRTBNDC command. 6 This function is not available when either LOCALETYPE(*CLD) or SYSIFCOPT(*NOIFSIO) is specified on the compilation command."
    },
    {
        "link": "https://geeksforgeeks.org/system-call-in-c",
        "document": "The system() function is used to invoke an operating system command from a C/C++ program. For example, we can call system(“dir”) on Windows and system(“ls”) in a Unix-like environment to list the contents of a directory.\n\nIt is a standard library function defined in <stdlib.h> header in C and <cstdlib> in C++.\n\nThe syntax of system() function is:\n• command : A pointer to a null-terminated string that contains the command we want to execute.\n• None It returns 0 if the command is successfully executed.\n• None It returns a non-zero value if command execution is not completed.\n\nExample: Program to Illustrate the system() Function\n\nIn this program, we will use the echo command to print the “Hello World” string. To learn about its usage and best practices, the C++ Course offers detailed explanations and practical examples.\n\nWriting a C/C++ program that compiles and runs other programs?\n\nWe can invoke gcc from our program using system(). See below the code written for Linux. We can easily change code to run on Windows.\n\n\n\nTo convert the above code for Windows we need to make some changes. The executable file extension is .exe on Windows. So, when we run the compiled program, we use a.exe instead of ./a.out.\n\nSome common uses of system() in Windows OS are:\n• system(“pause”) : This command is used to execute the pause command and make the screen/terminal wait for a key press.\n• system(“cls”) : This command is used to make the screen/terminal clear.\n\nHowever, making a call to system command should be avoided due to the following reasons:\n• non-portable to some extent which means this works only on systems that have the pause command at the system level, like DOS or Windows. But not Linux, MAC OSX, and most others.\n\nLet us take a simple C++ code to output Hello World using the system(“pause”):\n\nThe output of the above program in Windows OS:\n\nThis program is OS-dependent and uses the following heavy steps:\n• None It prints “Hello World!” on the screen.\n• None It displays a message “Press any key to continue…”.\n• None The system() function opens the shell of the Operating System that will first scan the string passed inside the system() function and then execute the command.\n• None The “pause” command waits for the user input and the shell window remains open until the user presses any key.\n• None When the user presses any key, the “pause command” receives an input, and the shell window is closed.\n\nInstead of using the system(“pause”), we can also use the functions that are defined natively in C. Let us take a simple example to output Hello World with cin.get():\n\nThus, we see that both system(“pause”) and cin.get() are actually performing a wait for a key to be pressed, but, cin.get() is not OS dependent and neither does it follow the above-mentioned steps to pause the program.\n\nWhat is the common way to check if we can run commands using system() in an OS?\n\nThe common way to check if we can run commands using system() in an OS is to check if a command processor (shell) exists in the operating system.\n\nUsing the following way, we can check if a command processor exists in an OS:\n\nIf we pass a null pointer in place of a string for the command parameter,\n• None The system returns a nonzero value if a command processor exists (or the system can run)."
    },
    {
        "link": "https://reddit.com/r/C_Programming/comments/udl68m/where_can_i_get_documentation_for_standard_c_and",
        "document": "I have experienced having documentations that are not up to date. Right now what I am doing is searching google and mostly open one's from geekforgeeks and tutorialspoint. I was wondering if there is an official or maybe a consolidated documentation for functions, data types, etc. for standard C and/or POSIX library. Thanks!"
    },
    {
        "link": "https://en.wikipedia.org/wiki/C_standard_library",
        "document": "Standard library for the C programming language\n\nThe C standard library, sometimes referred to as libc,[1] is the standard library for the C programming language, as specified in the ISO C standard.[2] Starting from the original ANSI C standard, it was developed at the same time as the C POSIX library, which is a superset of it.[3] Since ANSI C was adopted by the International Organization for Standardization,[4] the C standard library is also called the ISO C library.[5]\n\nThe C standard library provides macros, type definitions and functions for tasks such as string manipulation, mathematical computation, input/output processing, memory management, and input/output.\n\nThe application programming interface (API) of the C standard library is declared in a number of header files. Each header file contains one or more function declarations, data type definitions, and macros.\n\nAfter a long period of stability, three new header files ( , , and ) were added with Normative Addendum 1 (NA1), an addition to the C Standard ratified in 1995. Six more header files ( , , , , , and ) were added with C99, a revision to the C Standard published in 1999, five more files ( , , , , and ) with C11 in 2011 and one more file ( ) with C23 in 2023. In total, there are now 30 header files:\n\nThree of the header files ( , , and ) are conditional features that implementations are not required to support.\n\nThe POSIX standard added several nonstandard C headers for Unix-specific functionality. Many have found their way to other architectures. Examples include and . A number of other groups are using other nonstandard headers – the GNU C Library has , and OpenVMS has the function.\n\nOn Unix-like systems, the authoritative documentation of the API is provided in the form of man pages. On most systems, man pages on standard library functions are in section 3; section 7 may contain some more generic pages on underlying concepts (e.g. in Linux).\n\nUnix-like systems typically have a C library in shared library form, but the header files (and compiler toolchain) may be absent from an installation so C development may not be possible. The C library is considered part of the operating system on Unix-like systems; in addition to functions specified by the C standard, it includes other functions that are part of the operating system API, such as functions specified in the POSIX standard. The C library functions, including the ISO C standard ones, are widely used by programs, and are regarded as if they were not only an implementation of something in the C language, but also de facto part of the operating system interface. Unix-like operating systems generally cannot function if the C library is erased. This is true for applications which are dynamically as opposed to statically linked. Further, the kernel itself (at least in the case of Linux) operates independently of any libraries.\n\nOn Microsoft Windows, the core system dynamic libraries (DLLs) provide an implementation of the C standard library for the Microsoft Visual C++ compiler v6.0; the C standard library for newer versions of the Microsoft Visual C++ compiler is provided by each compiler individually, as well as redistributable packages. Compiled applications written in C are either statically linked with a C library, or linked to a dynamic version of the library that is shipped with these applications, rather than relied upon to be present on the targeted systems. Functions in a compiler's C library are not regarded as interfaces to Microsoft Windows.\n\nMany C library implementations exist, provided with both various operating systems and C compilers. Some of the popular implementations are the following:\n• The BSD libc, various implementations distributed with BSD-derived operating systems\n• GNU C Library (glibc), used in GNU Hurd, GNU/kFreeBSD, and most Linux distributions\n• Microsoft C run-time library, part of Microsoft Visual C++. There are two versions of the library: MSVCRT that was a redistributable till v12 / Visual Studio 2013 with low C99 compliance, and a new one UCRT (Universal C Run Time) that is part of Windows 10 and 11, so always present to link against, and is C99 compliant too [1].\n• dietlibc, an alternative small implementation of the C standard library (MMU-less)\n• μClibc, a C standard library for embedded μClinux systems (MMU-less)\n• uclibc-ng, an embedded C library, fork of μClibc, still maintained, with memory management unit (MMU) support\n• Newlib, a C standard library for embedded systems (MMU-less) 6 and used in the Cygwin GNU distribution for Windows\n• musl, another lightweight C standard library implementation for Linux systems 7\n• Bionic, originally developed by Google for the Android embedded system operating system, derived from BSD libc\n• picolibc, developed by Keith Packard, targeting small embedded systems with limited RAM, based on code from Newlib and AVR Libc\n\nSome compilers (for example, GCC[8]) provide built-in versions of many of the functions in the C standard library; that is, the implementations of the functions are written into the compiled object file, and the program calls the built-in versions instead of the functions in the C library shared object file. This reduces function-call overhead, especially if function calls are replaced with inline variants, and allows other forms of optimization (as the compiler knows the control-flow characteristics of the built-in variants), but may cause confusion when debugging (for example, the built-in versions cannot be replaced with instrumented variants).\n\nHowever, the built-in functions must behave like ordinary functions in accordance with ISO C. The main implication is that the program must be able to create a pointer to these functions by taking their address, and invoke the function by means of that pointer. If two pointers to the same function are derived in two different translation units in the program, these two pointers must compare equal; that is, the address comes by resolving the name of the function, which has external (program-wide) linkage.\n\nUnder FreeBSD[9] and glibc,[10] some functions such as sin() are not linked in by default and are instead bundled in the mathematical library libm. If any of them are used, the linker must be given the directive . POSIX requires that the c99 compiler supports , and that the functions declared in the headers , , and are available for linking if is specified, but does not specify if the functions are linked by default.[11] musl satisfies this requirement by putting everything into a single libc library and providing an empty libm.[12]\n\nAccording to the C standard the macro shall be defined to 1 if the implementation is hosted. A hosted implementation has all the headers specified by the C standard. An implementation can also be freestanding which means that these headers will not be present. If an implementation is freestanding, it shall define to 0.\n\nSome functions in the C standard library have been notorious for having buffer overflow vulnerabilities and generally encouraging buggy programming ever since their adoption.[13][a] The most criticized items are:\n• string-manipulation routines, including and , for lack of bounds checking and possible buffer overflows if the bounds are not checked manually;\n• string routines in general, for side-effects, encouraging irresponsible buffer usage, not always guaranteeing valid null-terminated output, linear length calculation; b\n• family of routines, for spoiling the execution stack when the format string does not match the arguments given. This fundamental flaw created an entire class of attacks: format string attacks;\n• and family of I/O routines, for lack of (either any or easy) input length checking.\n\nExcept the extreme case with , all the security vulnerabilities can be avoided by introducing auxiliary code to perform memory management, bounds checking, input checking, etc. This is often done in the form of wrappers that make standard library functions safer and easier to use. This dates back to as early as The Practice of Programming book by B. Kernighan and R. Pike where the authors commonly use wrappers that print error messages and quit the program if an error occurs.\n\nThe ISO C committee published Technical reports TR 24731-1[14] and is working on TR 24731-2[15] to propose adoption of some functions with bounds checking and automatic buffer allocation, correspondingly. The former has met severe criticism with some praise,[16][17] and the latter saw mixed response.\n\nDespite concerns, TR 24731-1 was integrated into the C standards track in ISO/IEC 9899:2011 (C11), Annex K (Bounds-checking interfaces), and implemented approximately in Microsoft’s C/++ runtime (CRT) library for the Win32 and Win64 platforms.\n\n(By default, Microsoft Visual Studio’s C and C++ compilers issue warnings when using older, \"insecure\" functions. However, Microsoft’s implementation of TR 24731-1 is subtly incompatible with both TR 24731-1 and Annex K,[18] so it’s common for portable projects to disable or ignore these warnings. They can be disabled directly by issuing\n\nbefore/around the call site[s] in question, or indirectly by issuing\n\nbefore including any headers.[19] Command-line option should have the same effect as this .)\n\nThe routine is criticized for being thread unsafe and otherwise vulnerable to race conditions.\n\nThe error handling of the functions in the C standard library is not consistent and sometimes confusing. According to the Linux manual page , \"The current (version 2.8) situation under glibc is messy. Most (but not all) functions raise exceptions on errors. Some also set errno. A few functions set errno, but do not raise an exception. A very few functions do neither.\"[20]\n\nThe original C language provided no built-in functions such as I/O operations, unlike traditional languages such as COBOL and Fortran.[citation needed] Over time, user communities of C shared ideas and implementations of what is now called C standard libraries. Many of these ideas were incorporated eventually into the definition of the standardized C language.\n\nBoth Unix and C were created at AT&T's Bell Laboratories in the late 1960s and early 1970s. During the 1970s the C language became increasingly popular. Many universities and organizations began creating their own variants of the language for their own projects. By the beginning of the 1980s compatibility problems between the various C implementations became apparent. In 1983 the American National Standards Institute (ANSI) formed a committee to establish a standard specification of C known as \"ANSI C\". This work culminated in the creation of the so-called C89 standard in 1989. Part of the resulting standard was a set of software libraries called the ANSI C standard library.\n\nPOSIX, as well as SUS, specify a number of routines that should be available over and above those in the basic C standard library. The POSIX specification includes header files for, among other uses, multi-threading, networking, and regular expressions. These are often implemented alongside the C standard library functionality, with varying degrees of closeness. For example, glibc implements functions such as within , but before NPTL was merged into glibc it constituted a separate library with its own linker flag argument. Often, this POSIX-specified functionality will be regarded as part of the library; the basic C library may be identified as the ANSI or ISO C library.\n\nBSD libc is a superset of the POSIX standard library supported by the C libraries included with BSD operating systems such as FreeBSD, NetBSD, OpenBSD and macOS. BSD libc has some extensions that are not defined in the original standard, many of which first appeared in 1994's 4.4BSD release (the first to be largely developed after the first standard was issued in 1989). Some of the extensions of BSD libc are:\n• – contains an implementation of red–black tree and splay tree 21 22\n• – defined in . This can be used to read a file line by line. 25 26 27\n• – contains some functions to traverse a file hierarchy 28 29\n• – some functions to connect to the Berkeley DB 30 31\n• and – secure alternatives for and 32 33 34 35 36\n• – contains some functions to print formatted error messages 37 38\n• – contains the function. This function is used to display non-printable characters in a visual format. 39 40 41\n\nSome languages include the functionality of the standard C library in their own libraries. The library may be adapted to better suit the language's structure, but the operational semantics are kept similar.\n\nThe C++ language incorporates the majority of the C standard library’s constructs into its own, excluding C-specific machinery. C standard library functions are exported from the C++ standard library in two ways.\n\nFor backwards-/cross-compatibility to C and pre-Standard C++, functions can be accessed in the global namespace ( ::), after ing the C standard header name as in C.[42] Thus, the C++98 program\n\nFrom C++98 on, C functions are also made available in namespace ::std (e.g., C printf as C++ ::std::printf, atoi as ::std::atoi, feof as ::std::feof), by including header instead of corresponding C header . E.g., <cstdio> substitutes for <stdio.h> and <cmath> for <math.h>; note lack of .h extension on C++ header names.\n\nThus, an equivalent (generally preferable) C++≥98 program to the above two is:\n\nA declaration above or within main can be issued to apply the ::std:: prefix automatically, although it’s generally considered poor practice to use it globally in headers because it pollutes the global namespace.[43]\n\nA few of the C++≥98 versions of C’s headers are missing; e.g., C≥11 <stdnoreturn.h> and <threads.h> have no C++ counterparts.[44]\n\nOthers are reduced to placeholders, such as (until C++20) <ciso646> for C95 <iso646.h>, all of whose requisite macros are rendered as keywords in C++98. C-specific syntactic constructs aren’t generally supported, even if their header is.[45]\n\nSeveral C headers exist primarily for C++ compatibility, and these tend to be near-empty in C++. For example, C99–17 <stdbool.h> require only\n\nin order to feign support for the C++98 bool, false, and true keywords in C. C++11 requires <stdbool.h> and <cstdbool> for compatibility, but all they need to define is __bool_true_false_are_defined. C23 obsoletes older _Bool keyword in favor of new, C++98-equivalent bool, false, and true keywords, so the C≥23 and C++≥11 <stdbool.h>/ <cstdbool> headers are fully equivalent. (In particular, C23 doesn’t require any __STDC_VERSION_BOOL_H__ macro for <stdbool.h>.)\n\nAccess to C library functions via namespace ::std and the C++≥98 header names is preferred where possible. To encourage adoption, C++98 obsoletes the C ( *.h) header names, so it’s possible that use of C compatibility headers will cause an especially strict C++98–20 preprocessor to raise a diagnostic of some sort. However, C++23 (unusually) de-obsoletes these headers, so newer C++ implementations/modes shouldn’t complain without being asked to specifically.[46]\n\n\n\n Other languages take a similar approach, placing C compatibility functions/routines under a common namespace; these include D, Perl, and Ruby.\n\nCPython includes wrappers for some of the C library functions in its own common library, and it also grants more direct access to C functions and variables via its ctypes package.[47]\n\nMore generally, Python 2. specifies the built-in file objects as being “implemented using C's stdio package,\"[48] and frequent reference is made to C standard library behaviors; the available operations ( , , , etc.) are expected to have the same behavior as the corresponding C functions ( , , , etc.).\n\nPython 3’s specification relies considerably less on C specifics than Python 2, however.\n\nRust offers crate libc, which allows various C standard (and other) library functions and type definitions to be used.[49]\n\nThe C standard library is small compared to the standard libraries of some other languages. The C library provides a basic set of mathematical functions, string manipulation, type conversions, and file and console-based I/O. It does not include a standard set of \"container types\" like the C++ Standard Template Library, let alone the complete graphical user interface (GUI) toolkits, networking tools, and profusion of other functionality that Java and the .NET Framework provide as standard. The main advantage of the small standard library is that providing a working ISO C environment is much easier than it is with other languages, and consequently porting C to a new platform is comparatively easy.\n• Handy list of which headers are in which standard\n• Microsoft Universal C runtime routines by category on MSDN\n• NetBSD C libraries manual Archived 23 December 2015 at the Wayback Machine and full C library source\n• Manual pages for the original C standard libraries in Unix"
    },
    {
        "link": "https://labex.io/tutorials/linux-commands-full-list-practical-examples-423950",
        "document": ""
    },
    {
        "link": "https://redhat.com/en/blog/one-line-linux-commands",
        "document": "Many Linux users have experienced a lasting sense of accomplishment after composing a particularly clever command that achieves multiple actions in just one line or that manages to do in one line what usually takes 10 clicks and as many windows in a graphical user interface (GUI). Aside from being the stuff of legend, one-liners are great examples of why the terminal is considered to be such a powerful tool.\n\nBy the end of this article, you will have:\n• A list of 20 commands that will make your tasks easier when working on Linux\n• An understanding of the possibilities of combining simple commands to create more powerful commands\n• More fun than you might expect running these commands\n\nWithout any specific order of importance, these are our top 20 one-liners for the Linux terminal. Although we've divided some of the longer commands with the symbol for easier readability, you can enter them all on a single line in your terminal because, after all, they are one-liners.\n\n1. Apply a command on files with different names\n\nThe shell operator is great for this. Here's an example with three directories enclosed in :\n\nDo you want to replace a string on one or more files without using an editor? Sure, to the rescue:\n\nBut wait, Perl lovers will tell you they can do the same:\n\nRaise your hand if you haven't used this at least once to share a directory quickly:\n\nSometimes things break. You can find the most recent errors using a combination of , along with the classic tools and :\n\nIn this case, it seems that the Docker daemon is unhappy.\n\n[ Download this eBook to get ready for your Red Hat remote exam. ]\n\nUse and to make secure backups. They go together like peanut butter and jelly:\n\nYou can add flavor to the backup job with compression and encryption—just like adding ingredients to your sandwich.\n\nThis is a great trick when you need to write multiline documents:\n\nYou can also just , and when you are done editing, just input the EOF character (Ctrl+D):\n\n7. Search for a file, and include some extensions and exclude others\n\nThis example uses the way to search for specific files. It's pretty fast and easy to remember:\n\nOr you can try the way (use to handle a large number of matches properly):\n\nWhy , you may ask? You can combine with to execute actions on your files first and then pass the results to the filter. The processing possibilities are endless here.\n\nThis one is almost cheating. It repeats a command, such as , every five seconds and highlights the differences:\n\nUse (list block) and (to manipulate a JSON on the command line) to display partition information:\n\nThe What is function is called with . It quickly tells you a file's type.\n\nNOTE: Functions are superior and can do the same work as an alias.\n\n11. Display the size of an installed RPM\n\nIf you have an RPM-based system, sooner or later, you will format your queries. Here's an example:\n\n[ Train and test on our latest courses and exams from Red Hat Training & Certification: Red Hat Enterprise Linux skills path. ]\n\n12. Display the total size of a group of files\n\nIn this case, the command acts as a filter, displays the size of each file in bytes, and finally, shows the total size:\n\nOr, if you want a function (better), try this approach:\n\nYou already know how useful Git is. Here's a trick to be more efficient with your updates:\n\nContainers are critical today. This one-liner exposes a directory via Podman:\n\nUse this function to find out whether you need a jacket today:\n\nHere's a task web admins may use frequently with Nginx (it may also work with Apache) to grab the top 10 internet protocol addresses hitting a webserver from the access log:\n\n17. Round floats in Bash with Python's help\n\nYou can do pretty cool stuff with Python, but this example just rounds numbers:\n\nThis function defines a quick calculator on the command line with variable precision (the default is 2). It uses bc. Create the function like this:\n\nIn case you need additional precision, just define a second parameter:\n\nThis tool is called because it's an improvement on the old function .\n\nThis trick is a modification of this popular recipe to convert CSV files to the JSON format:\n\nIf you have Docker installed and you want to run a command without installing a bunch of dependencies on your system (while doing a quick run), this may be all you need:\n\nThe command runs the latest version of from a container, and later removes it. Notice that the command ends with a dash ( ), which tells to output to your terminal. The possibilities are endless here.\n\nThe ability to build powerful combinations of simple commands is one of the reasons Unix and Linux are so popular.\n\nFortunately. it is not difficult to learn these one-liners. Focus on remembering what a simple command does, and then think about how you can mix many simple commands to make a powerful recipe.\n\nAlways check the page or use the command to figure out what else the tool can do. You may be surprised to learn that one tool can do everything without combining it with another utility.\n\nThere are many sites on the internet with plenty of one-line examples. We hope these examples will lead you to write better one-liners of your own."
    },
    {
        "link": "https://unix.stackexchange.com/questions/699840/explanation-about-free-available-and-buff-cache-and-how-to-find-what-process-is",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/4/html/introduction_to_system_administration/s1-resource-rhlspec",
        "document": "Red Hat Enterprise Linux comes with a variety of resource monitoring tools. While there are more than those listed here, these tools are representative in terms of functionality. The tools are:\n\nLet us examine each one in more detail."
    },
    {
        "link": "https://linux-commands.labex.io",
        "document": ""
    }
]