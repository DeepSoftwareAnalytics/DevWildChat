[
    {
        "link": "https://tutorialspoint.com/c_standard_library/c_function_printf.htm",
        "document": "The C library printf() function is a fundamental tool for outputting formatted text to the standard output stream. It allows for versatile printing of variables, strings, and other data types.\n\nFollowing is the C library syntax of the printf() function −\n\nFollowing is the list of parameters −\n• format : A string that may contain format specifiers like %d, %s, etc., which control the formatting of subsequent arguments.\n• ... : A variable number of arguments to be formatted and printed according to the format string.\n\nReturns the number of characters printed (excluding the null byte used to end the output to strings) if successful.On error, it returns a negative value.\n\nHere, printf() prints an integer and a string using format specifiers %d and %s respectively.\n\nBelow is the illustration of the C library printf() function.\n\nThe above code produces following result −\n\nHere, the printf() prints an octal number (octal_num) using %o format specifier and a hexadecimal number (hex_num) using %X format specifier.\n\nAfter execution of above code, we get the following result"
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/c-runtime-library/format-specification-syntax-printf-and-wprintf-functions?view=msvc-170",
        "document": "The various and functions take a format string and optional arguments and produce a formatted sequence of characters for output. The format string contains zero or more directives, which are either literal characters for output or encoded conversion specifications that describe how to format an argument in the output. This article describes the syntax used to encode conversion specifications in the format string. For a listing of these functions, see Stream I/O.\n\nA conversion specification consists of optional and required fields in this form:\n\nEach field of the conversion specification is a character or a number that signifies a particular format option or conversion specifier. The required type field specifies the kind of conversion to be applied to an argument. The optional flags, width, and precision fields control other format aspects such as leading spaces or zeroes, justification, and displayed precision. The size field specifies the size of the argument consumed and converted.\n\nA basic conversion specification contains only the percent sign and a type character. For example, specifies a string conversion. To print a percent-sign character, use . If a percent sign is followed by a character that has no meaning as a format field, the invalid parameter handler is invoked. For more information, see Parameter validation.\n\nThe type conversion specifier character specifies whether to interpret the corresponding argument as a character, a string, a pointer, an integer, or a floating-point number. The type character is the only required conversion specification field, and it appears after any optional fields.\n\nThe arguments that follow the format string are interpreted according to the corresponding type character and the optional size prefix. Conversions for character types and are specified by using or , and single-byte and multi-byte or wide character strings are specified by using or , depending on which formatting function is being used. Character and string arguments that are specified by using and are interpreted as and by family functions, or as and by family functions. Character and string arguments that are specified by using and are interpreted as and by family functions, or as and by family functions. This behavior is Microsoft-specific. For historical reasons, the functions use and to refer to characters, and and specify narrow characters.\n\nInteger types such as , , , , and their variants, are specified by using , , , , , and . Floating-point types such as , , and , are specified by using , , , , , , , and . By default, unless they're modified by a size prefix, integer arguments are coerced to type, and floating-point arguments are coerced to . On 64-bit systems, an is a 32-bit value; so, 64-bit integers will be truncated when they're formatted for output unless a size prefix of or is used. Pointer types that are specified by use the default pointer size for the platform.\n\nIn Visual Studio 2015 and later versions, if the argument that corresponds to a floating-point conversion specifier ( , , , , , , , ) is infinite, indefinite, or NaN, the formatted output conforms to the C99 standard. This table lists the formatted output:\n\nAny of these strings may be prefixed by a sign. If a floating-point type conversion specifier character is a capital letter, then the output is also formatted in capital letters. For example, if the format specifier is instead of , an infinity is formatted as instead of . The functions can also parse these strings, so these values can make a round trip through and functions.\n\nBefore Visual Studio 2015, the CRT used a different, non-standard format for output of infinite, indefinite, and NaN values:\n\nAny of these strings may have been prefixed by a sign, and may have been formatted differently depending on field width and precision, sometimes with unusual effects. For example, prints because the #INF would be \"rounded\" to two digits of precision.\n\nThe first optional field in a conversion specification contains flag directives. This field contains zero or more flag characters that specify output justification and control output of signs, blanks, leading zeros, decimal points, and octal and hexadecimal prefixes. More than one flag directive may appear in a conversion specification, and the flag characters can appear in any order.\n\nIn a conversion specification, the optional width specification field appears after any flags characters. The argument is a non-negative decimal integer that controls the minimum number of characters that are output. If the number of characters in the output value is less than the specified width, blanks are added to the left or the right of the values—depending on whether the left-alignment flag ( ) is specified—until the minimum width is reached. If is prefixed by 0, leading zeros are added to integer or floating-point conversions until the minimum width is reached, except when conversion is to an infinity or .\n\nThe width specification never causes a value to be truncated. If the number of characters in the output value is greater than the specified width, or if isn't provided, all characters of the value are output, subject to the precision specification.\n\nIf the width specification is an asterisk ( ), an argument from the argument list supplies the value. The argument must precede the value that's being formatted in the argument list, as shown in this example:\n\nA missing or small value in a conversion specification doesn't cause the truncation of an output value. If the result of a conversion is wider than the value, the field expands to contain the conversion result.\n\nIn a conversion specification, the third optional field is the precision specification. It consists of a period ( ) followed by a non-negative decimal integer that, depending on the conversion type, specifies the number of string characters, the number of decimal places, or the number of significant digits to be output.\n\nUnlike the width specification, the precision specification can cause either truncation of the output value or rounding of a floating-point value. If is specified as 0, and the value to be converted is 0, the result is no characters output, as shown in this example:\n\nIf the precision specification is an asterisk ( ), an argument from the argument list supplies the value. In the argument list, the argument must precede the value that's being formatted, as shown in this example:\n\nThe character determines either the interpretation of or the default precision when is omitted, as shown in the following table.\n\nIn a conversion specification, the size field is an argument length modifier for the type conversion specifier. The size field prefixes to the type field— , , , (lowercase L), , , , , , (uppercase i), , and —specify the \"size\" of the corresponding argument—long or short, 32-bit or 64-bit, single-byte character or wide character—depending on the conversion specifier that they modify. These size prefixes are used with type characters in the and families of functions to specify the interpretation of argument sizes, as shown in the following table. The size field is optional for some argument types. When no size prefix is specified, the formatter consumes integer arguments—for example, signed or unsigned , , , , and enumeration types—as 32-bit types, and , , and floating-point arguments are consumed as 64-bit types. This behavior matches the default argument promotion rules for variable argument lists. For more information about argument promotion, see Ellipsis and Default Arguments in Postfix expressions. On both 32-bit and 64-bit systems, the conversion specification of a 64-bit integer argument must include a size prefix of or . Otherwise, the behavior of the formatter is undefined.\n\nSome types are different sizes in 32-bit and 64-bit code. For example, is 32 bits long in code compiled for x86, and 64 bits in code compiled for x64. To create platform-agnostic formatting code for variable-width types, you can use a variable-width argument size modifier. Instead, use a 64-bit argument size modifier and explicitly promote the variable-width argument type to 64 bits. The Microsoft-specific (uppercase i) argument size modifier handles variable-width integer arguments, but we recommend the type-specific , , and modifiers for portability.\n\nThe and types are or on 32-bit platforms, and or on 64-bit platforms. The (uppercase i), , , and size prefixes take the correct argument width for the platform.\n\nIn Visual C++, although is a distinct type, it has the same internal representation as .\n\nAn or type specifier is synonymous with in functions and with in functions. A , , , or type specifier is synonymous with in functions and with in functions. An or type specifier is synonymous with in functions and with in functions. An , , , or type specifier is synonymous with in functions and with in functions."
    },
    {
        "link": "https://gnu.org/s/libc/manual/html_node/Formatted-Output-Functions.html",
        "document": "This section describes how to call and related functions. Prototypes for these functions are in the header file . Because these functions take a variable number of arguments, you must declare prototypes for them before using them. Of course, the easiest way to make sure you have all the right prototypes is to just include .\n\nThis is like , except that the output is stored in the character array instead of written to a stream. A null character is written to mark the end of the string. The function returns the number of characters stored in the array , not including the terminating null character. The behavior of this function is undefined if copying takes place between objects that overlap—for example, if is also given as an argument to be printed under control of the ‘ ’ conversion. See Copying Strings and Arrays. Warning: The function can be dangerous because it can potentially output more characters than can fit in the allocation size of the string . Remember that the field width given in a conversion specification is only a minimum value. To avoid this problem, you can use or , described below.\n\nThis is like , except that the output is stored in the wide character array instead of written to a stream. A null wide character is written to mark the end of the string. The argument specifies the maximum number of characters to produce. The trailing null character is counted towards this limit, so you should allocate at least wide characters for the string . The return value is the number of characters generated for the given input, excluding the trailing null. If not all output fits into the provided buffer a negative value is returned, and is set to . (The setting of is a GNU extension.) You should try again with a bigger output string. Note: this is different from how handles this situation. Note that the corresponding narrow stream function takes fewer parameters. in fact corresponds to the function. Since the function can be dangerous and should be avoided the ISO C committee refused to make the same mistake again and decided to not define a function exactly corresponding to .\n\nThe function is similar to , except that the argument specifies the maximum number of characters to produce. The trailing null character is counted towards this limit, so you should allocate at least characters for the string . If is zero, nothing, not even the null byte, shall be written and may be a null pointer. The return value is the number of characters which would be generated for the given input, excluding the trailing null. If this value is greater than or equal to , not all characters from the result have been stored in . If this happens, you should be wary of using the truncated result as that could lead to security, encoding, or other bugs in your program (see Truncating Strings while Copying). Instead, you should try again with a bigger output string. Here is an example of doing this: /* Construct a message describing the value of a variable whose name is and whose value is . */ char * make_message (char *name, char *value) { /* Guess we need no more than 100 bytes of space. */ size_t size = 100; char *buffer = xmalloc (size); /* Try to print in the allocated space. */ int buflen = snprintf (buffer, size, \"value of %s is %s\", name, value); if (! (0 <= buflen && buflen < SIZE_MAX)) fatal (\"integer overflow\"); if (buflen >= size) { /* Reallocate buffer now that we know how much space is needed. */ size = buflen; size++; buffer = xrealloc (buffer, size); /* */ snprintf (buffer, size, \"value of %s is %s\", name, value); } /* The last call worked, return the string. */ return buffer; } In practice, it is often easier just to use , below. Attention: In versions of the GNU C Library prior to 2.1 the return value is the number of characters stored, not including the terminating null; unless there was not enough space in to store the result in which case is returned. This was changed in order to comply with the ISO C99 standard."
    },
    {
        "link": "https://cplusplus.com/reference/cstdio/printf",
        "document": ""
    },
    {
        "link": "https://en.wikipedia.org/wiki/Printf",
        "document": "C function to format and output text\n\nprintf is a C standard library function that formats text and writes it to standard output.\n\nThe name, printf is short for print formatted where print refers to output to a printer although the functions are not limited to printer output.\n\nThe standard library provides many other similar functions that form a family of printf-like functions. These functions accept a format string parameter and a variable number of value parameters that the function serializes per the format string and writes to an output stream or a string buffer.\n\nThe format string is encoded as a template language consisting of verbatim text and format specifiers that each specify how to serialize a value. As the format string is processed left-to-right, a subsequent value is used for each format specifier found. A format specifier starts with a character and has one or more following characters that specify how to serialize a value.\n\nThe format string syntax and semantics is the same for all of the functions in the printf-like family.\n\nMismatch between the format specifiers and count and type of values can cause a crash or vulnerability.\n\nThe printf format string is complementary to the scanf format string, which provides formatted input (lexing a.k.a. parsing). Both format strings provide relatively simple functionality compared to other template engines, lexers and parsers.\n\nThe formatting design has been copied in other programming languages.\n\nEarly programming languages like Fortran used special statements with different syntax from other calculations to build formatting descriptions.[1] In this example, the format is specified on line , and the [a] command refers to it by line number:\n• indicates an integer field of width 5;\n• indicates a floating-point field of width 10 with 2 digits after the decimal point.\n\nAn output with input arguments , , and might look like this:\n\nIn 1967, BCPL appeared.[2] Its library included the routine.[3] An example application looks like this:\n• indicates an integer of width 2 (the order of the format specification's field width and type is reversed compared to C's );\n• indicates an integer of width 5;\n• is a BCPL language escape sequence representing a newline character (for which C uses the escape sequence ).\n\nIn 1968, ALGOL 68 had a more function-like API, but still used special syntax (the delimiters surround special formatting syntax):\n\nIn contrast to Fortran, using normal function calls and data types simplifies the language and compiler, and allows the implementation of the input/output to be written in the same language.\n\nThese advantages were thought to outweigh the disadvantages (such as a complete lack of type safety in many instances) up until the 2000s, and in most newer languages of that era I/O is not part of the syntax.\n\nPeople have since learned[4] that this potentially results in consequences, ranging from security exploits to hardware failures (e.g., phone's networking capabilities being permanently disabled after trying to connect to an access point named \"%p%s%s%s%s%n\"[5]). Modern languages, such as C++20 and later, tend to include format specifications as a part of the language syntax,[6] which restore type safety in formatting to an extent, and allow the compiler to detect some invalid combinations of format specifiers and data types at compile time.\n\nIn 1973, was included as a C standard library routine as part of Version 4 Unix.[7]\n\nIn 1990, a shell command was attested as part of 4.3BSD-Reno. It is modeled after the C standard library function.[8]\n\nIn 1991, a command was included with GNU shellutils (now part of GNU Core Utilities).\n\nThe need to do something about the range of problems resulting from lack of type safety has prompted attempts to make the C++ compiler -aware.\n\nThe option of GCC allows compile-time checks to calls, enabling the compiler to detect a subset of invalid calls (and issue either a warning or an error, stopping the compilation altogether, depending on other flags).[9]\n\nSince the compiler is inspecting format specifiers, enabling this effectively extends the C++ syntax by making formatting a part of it.\n\nAs said above, numerous issues[10] with 's lack of type safety resulted in the revision[11] of approach to formatting, and C++20 onwards include format specifications in the language[12] to enable type-safe formatting.\n\nThe approach (and syntax) of C++20 resulted from effectively incorporating Victor Zverovich's [13] API into the language specification [14] (Zverovich wrote[15] the first draft of the new format proposal); consequently, is an implementation of the C++20 format specification.\n\nThe formatting function has been combined with output in C++23, which provides[16] the command as a replacement for .\n\nAs the format specification has become a part of the language syntax, a C++ compiler is able to prevent invalid combinations of types and format specifiers in many cases. Unlike the option, this is not an optional feature.\n\nThe format specification of and is, in itself, an extensible \"mini-language\" (referred to as such in the specification),[17] an example of a domain-specific language.\n\nIncorporation of a separate, domain specific mini-language specifically for formatting into the C++ language syntax for , therefore, completes the historical cycle, bringing the state-of-the-art (as of 2024) back to what it was in the case of FORTRAN's first implementation in the 1950s discussed in the beginning of this section.\n\nFormatting of a value is specified as markup in the format string. For example, the following outputs and then the value of the variable in decimal format.\n\nThe syntax for a format specifier is:\n\nThe parameter field is optional. If included, then matching specifiers to values is not sequential. The numeric value selects the n-th value parameter.\n\nThis is a POSIX extension; not C99.\n\nThis field allows for using the same value multiple times in a format string instead of having to pass the value multiple times. If a specifier includes this field, then subsequent specifiers must also.\n\nThis field is particularly useful for localizing messages to different natural languages that use different word orders.\n\nIn Microsoft Windows, support for this feature is via a different function, .\n\nThe flags field can be zero or more of (in any order):\n\nThe width field specifies the minimum number of characters to output. If the value can be represented in fewer characters, then the value is left-padded with spaces so that output is the number of characters specified. If the value requires more characters, then the output is longer than the specified width. A value is never truncated.\n\nFor example, specifies a width of 3 and outputs with a space on the left to output 3 characters. The call outputs which is 4 characters long since that is the minimum width for that value even though the width specified is 3.\n\nIf the width field is omitted, the output is the minimum number of characters for the value.\n\nIf the field is specified as , then the width value is read from the list of values in the call.[18] For example, outputs where the second parameter, , is the width (matches with ) and is the value to serialize (matches with ).\n\nThough not part of the width field, a leading zero is interpreted as the zero-padding flag mentioned above, and a negative value is treated as the positive value in conjunction with the left-alignment flag also mentioned above.\n\nThe width field can be used to format values as a table (tabulated output). But, columns do not align if any value is larger than fits in the width specified. For example, notice that the last line value ( ) does not fit in the first column of width 3 and therefore the column is not aligned.\n\nThe precision field usually specifies a maximum limit of the output, depending on the particular formatting type. For floating-point numeric types, it specifies the number of digits to the right of the decimal point to which the output should be rounded; for and it specifies the total number of significant digits (before and after the decimal, not including leading or trailing zeroes) to round to. For the string type, it limits the number of characters that should be output, after which the string is truncated.\n\nThe precision field may be omitted, or a numeric integer value, or a dynamic value when passed as another argument when indicated by an asterisk ( ). For example, outputs .\n\nThe length field can be omitted or be any of:\n\nPlatform-specific length options came to exist prior to widespread use of the ISO C99 extensions, including:\n\nISO C99 includes the header file that includes a number of macros for platform-independent coding. For example: specifies decimal format for a 64-bit signed integer. Since the macros evaluate to a string literal, and the compiler concatenates adjacent string literals, the expression compiles to a single string.\n\nThe type field can be any of:\n\nA common way to handle formatting with a custom data type is to format the custom data type value into a string, then use the specifier to include the serialized value in a larger message.\n\nSome printf-like functions allow extensions to the escape-character-based mini-language, thus allowing the programmer to use a specific formatting function for non-builtin types. One is the (now deprecated) glibc's . However, it is rarely used due to the fact that it conflicts with static format string checking. Another is Vstr custom formatters, which allows adding multi-character format names.\n\nSome applications (like the Apache HTTP Server) include their own printf-like function, and embed extensions into it. However these all tend to have the same problems that has.\n\nThe Linux kernel function supports a number of ways to display kernel structures using the generic specification, by appending additional format characters.[23] For example, prints an IPv4 address in dotted-decimal form. This allows static format string checking (of the portion) at the expense of full compatibility with normal printf.\n\noutputs to a system file object instead of standard output.\n\nwrites to a string buffer instead of standard output.\n\nprovides a level of safety over since the caller provides a length n that is the length of the output buffer in bytes (including space for the trailing nul).\n\n's first argument is a handle) (char **) which is then set to point to an allocated string of sufficient size to contain the output.\n\nEach of these has a variant that accepts rather than comma-separated parameters: , , , .\n\nThese functions return the number bytes that would be printed ( may return a value >= n when output is truncated). Errors return -1.[24]\n\nExtra value parameters are ignored, but if the format string has more format specifiers than value parameters passed the behavior is undefined. For some C compilers, an extra format specifier results in consuming a value even though there isn't one. This can allow the format string attack. Generally, for C, arguments are passed on the stack. If too few arguments are passed, then printf can read past the end of the stack frame, thus allowing an attacker to read the stack.\n\nSome compilers, like the GNU Compiler Collection, will statically check the format strings of printf-like functions and warn about problems (when using the flags or ). GCC will also warn about user-defined printf-style functions if the non-standard \"format\" is applied to the function.\n\nThe format string is often a string literal, which allows static analysis of the function call. However, the format string can be the value of a variable, which allows for dynamic formatting but also a security vulnerability known as an uncontrolled format string exploit.\n\nAlthough an output function on the surface, allows writing to a memory location specified by an argument via . This functionality is occasionally used as a part of more elaborate format-string attacks.[25]\n\nThe functionality also makes accidentally Turing-complete even with a well-formed set of arguments. A game of tic-tac-toe written in the format string is a winner of the 27th IOCCC.[26]\n\nExcluded are languages that use format strings that deviate from the style in this article (such as AMPL and Elixir), languages that inherit their implementation from the JVM or other environment (such as Clojure and Scala), and languages that do not have a standard native printf implementation but have external libraries which emulate printf behavior (such as JavaScript).\n• \"Hello, World!\" program – A basic example program first featured in The C Programming Language (the \"K&R Book\"), which in the C example uses printf to output the message \"Hello, World!\"\n• Format (Common Lisp) – function in Common Lisp that can produce formatted text using a format string similar to the printf format string\n• C standard library – Standard library for the C programming language\n• : print formatted output – System Interfaces Reference, The Single UNIX Specification, Version 4 from The Open Group"
    },
    {
        "link": "https://reddit.com/r/C_Programming/comments/1i25zdi/best_practices_for_error_management_in_c",
        "document": "First of all, I want to thank all active commenters, I am learning a lot by reading this subreddit.\n\nI am studying Hanson's \"C interfaces and implementations\". He proposes creating a rather complex interface to manage exceptions, but reading the subreddit here I have seen that his approach, based on / , is considered outdated. I found this comment by u/pgetreuer to be particularly interesting.\n\nMy question is this: where can I study modern error management in C? Is it possible to create some error interface that gives me a trace not only of the function where the error happened but also of its caller, as happens e.g. in Python?"
    },
    {
        "link": "https://stackoverflow.com/questions/385975/error-handling-in-c-code",
        "document": "I have seen five main approaches used in error reporting by functions in C:\n• return value with no error code reporting or no return value\n• return value that is an error code only\n• return value that is a valid value or an error code value\n• return value indicating an error with some way of fetching an error code possibly with error context information\n• function argument that returns a value with an error code possibly with error context information\n\nIn addition to the choice of function error return mechanism there is also the consideration of error code mnemonics and ensuring that the error code mnemonics do not clash with any other error code mnemonics being used. Typically this requires the use of a Three Letter Prefix approach to the naming of mnemonics defining them with , , or . See this discussion \"static const\" vs \"#define\" vs \"enum\"\n\nThere are a couple of different outcomes once an error is detected and that may be a consideration how functions provide error codes and error information. These outcomes are really divided into two camps, recoverable errors and unrecoverable errors:\n• document the system state and then abort\n\nAn error type may use more than one of these outcomes depending on the context of the error. For instance a file open that fails because the file doesn't exist may be retried with a different file name or notify a user and ask for assistance or continue execution in a degraded state.\n\nSome functions do not provide an error code. The functions either can't fail or if they fail, they fail silently. An example of this type of function are the various character test functions such as which indicates if a character value is a digit or is not. A character value either is or is not a digit or an alphabetic character. Similarly with the function, comparing two strings results in a value indicating which one is higher in the collating sequence than the other should they not be the same.\n\nIn some cases an error code is not necessary because a value indicating failure is a valid result. For example the function from the Standard Library returns a pointer to the searched for character if found in the string to be scanned or if it is not found. In this case a failure to find the character is a valid and useful indicator. A function using may require the character searched for not be in the string to be successful and finding the character is an error condition.\n\nOther functions do not return an error code but instead report an error through an external mechanism. This is used by most of the math library functions in the Standard Library which require the user to set to a value of zero, call the function, and then check that the value of is still zero. The range of output values from many of the math functions do not allow a special return value to be used to indicate an error and they do not have an error reporting argument in their interfaces.\n\nSome functions perform an action and return an error code value with one of the possible error code values indicating success and the rest of the range of values indicating an error code. For example a function may return a value of 0 if successful or a positive or negative non-zero value indicating an error with the value returned being the error code.\n\nSome functions may perform an action and return either a value from a range of valid values if successful or a value from a range of invalid values indicating an error code. A simple approach is to use a positive value (0, 1, 2, ...) for valid values and a negative value for error codes allowing a check such as .\n\nSome functions return a valid value or an invalid value indicating an error requiring the additional step of fetching the error code by some means. For example the function returns either a pointer to a object or it returns an invalid pointer value of and sets to an error code indicating the reason for the failure. A number of Windows API functions that return a value to reference a resource may also return a value of and the function is used to obtain the error code. The OPOS Control Objects standard requires an OPOS Control Object to provide two functions, and , to allow for the retrieval of error status information in the event a COM object method call fails.\n\nThis same approach is used in other APIs that use a handle or reference to a resource in which there is a range of valid values with one or more values outside of that range used to indicate an error. A mechanism is then provided to fetch additional error information such as an error code.\n\nA similar approach is used with functions that return a boolean value of to indicate the function was successful or to indicate an error. The programmer must then examine other data to determine an error code such as with the Windows API.\n\nSome functions have a pointer argument containing the address of a memory area for the function called to provide an error code or error information. Where this approach really shines is when in addition to a simple error code there is additional, error context information that helps to pin point the error. For example a JSON string parsing function may not only return an error code but also a pointer to where in the JSON string the parsing failed.\n\nI have also seen functions where the function returned an error indicator such as a boolean value with the argument used for error information. I recall that the error information argument could in some cases be indicating the caller didn't want to know the specifics of a failure.\n\nThis approach to returning error code or error information seems to be uncommon in my experience though for some reason I think I've seen it used in the Windows API from time to time or perhaps with an XML parser.\n\nWhen using the approach of an additional error code access through a mechanism as in checking a global such as or using a function such as there is the problem of sharing the global across multiple threads.\n\nModern compilers and libraries deal with this by using thread local storage to ensure that each thread has its own storage that is not shared by other threads. However there is still the issue of multiple functions sharing the same thread local storage location for status information which may require some accomodation. For instance, a function that uses several files may need to work around the issue that all of the calls that may fail share a single in the same thread.\n\nIf the API uses some type of handle or reference then error code storage can be made handle specific. The function could be wrapped in another function which performs the and then sets an API control block with both the returned by the as well as the value of .\n\nMy preference is for an error code to be returned as a function return value so that I can either check it at the point of call or save it for later. In most cases, an error is something to be dealt with immediately which is why I prefer this approach.\n\nAn approach I have used with functions is to have the function return a simple which contains two members, a status code and the return value. For example:\n\nThis allows me to do an immediate check for an error. Many functions end up returning a status without returning an actual value as well because the data returned is complex. One or more arguments may be modified by the function but the function doesn't return a value other than a status code."
    },
    {
        "link": "https://geeksforgeeks.org/implement-stack-in-c",
        "document": "Stack is the linear data structure that follows the Last in, First Out(LIFO) principle of data insertion and deletion. It means that the element that is inserted last will be the first one to be removed and the element that is inserted first will be removed at last. Think of it as the stack of plates stacked on top of one another where we can only add or remove the top plate.\n\nStacks are widely used in programming for tasks like expression evaluation, function call management, and backtracking algorithms. In this article, we will learn how to implement a stack in the C programming language. We will also look at some of its basic operations along with their time and space complexity analysis.\n\nImplementation of a Stack in C\n\nIn C, we can implement a stack using an array or a linked list. In this article, we will use the array data structure to store the stack elements and use a pointer to keep track of the topmost element of the stack. The stack will offer some basic operations like push, pop, peek, isEmpty, and isFull to the users.\n\nRepresentation of Stack in C\n\nThe stack can be represented as a structure that contains a fixed-size array in C which stores the data of the stack and an index pointer which is used to track the top element of the stack.\n\nWe can use a utility function initialize the stack array along with the top pointer. The initial value of the top should be -1 representing that there are currently no elements in the stack.\n\nMax size of the stack can be defined as per our requirements.\n\nFollowing are some basic operations in the stack that make it easy to manipulate the stack data structure:\n\nAs we can see, the stack offers O(1) time complexity for all the operation but with a catch that we can only perform these operation to the topmost element. So, we need to consider our requirements to take advantage of stack data structure.\n\nLet's see how to implement these basic operations for our stack in C.\n\nThe isFull() function provides the information about whether the stack have some space left or it is completely full. We know that the max capacity of the stack is MAX_SIZE elements. So, the max value of top can be MAX_SIZE - 1.\n\nThe isEmpty function will check whether the stack is empty or not. We know that when the stack is empty, the top is equal to -1.\n\nThe push function will add (or push) an element to the stack. The edge case here will be when we try to add a new element when the stack is already full. It is called stack overflow and we have to check for it before inserted new element.\n\nFollowing is the algorithm for the push operation:\n\nThe pop function will remove an element from the stack. One case that can occur here is when we try to remove the top using pop() function when the stack is already empty. Such condition is called stack underflow and can be easily checked.\n\nFollowing is the algorithm for the pop operation:\n\nThe peek function will return the topmost element of the stack in constant time. If the stack is empty it returns -1.\n\nFollowing is the algorithm for top operation on the stack:\n\nThe following program demonstrates how we can implement a Stack in C:\n\nApplications of Stack in C\n\nStack is widely used for Following are some common applications of Stack:\n• None Stacks are commonly used to evaluate postfix expressions. It is also used in infix to postfix conversion.\n• None It is used in recursion where a different stack is allocated for every recursive call.\n• None It is used in browsers to provide the backward and forward functionality.\n• None It is also used in text editor, image editors to provide the undo and redo funtionality.\n• None It is used in various algorithms in computer science."
    },
    {
        "link": "https://softwareengineering.stackexchange.com/questions/147059/the-modern-way-to-perform-error-handling",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://quora.com/What-are-the-best-practices-when-implementing-C-error-handling",
        "document": "Something went wrong. Wait a moment and try again."
    }
]