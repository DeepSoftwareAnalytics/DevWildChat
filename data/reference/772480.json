[
    {
        "link": "https://docs.python.org/3/tutorial/datastructures.html",
        "document": "This chapter describes some things you’ve learned about already in more detail, and adds some new things as well.\n\nThe list data type has some more methods. Here are all of the methods of list objects: Add an item to the end of the list. Similar to . Extend the list by appending all the items from the iterable. Similar to . Insert an item at a given position. The first argument is the index of the element before which to insert, so inserts at the front of the list, and is equivalent to . Remove the first item from the list whose value is equal to x. It raises a if there is no such item. Remove the item at the given position in the list, and return it. If no index is specified, removes and returns the last item in the list. It raises an if the list is empty or the index is outside the list range. Remove all items from the list. Similar to . Return zero-based index in the list of the first item whose value is equal to x. Raises a if there is no such item. The optional arguments start and end are interpreted as in the slice notation and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument. Return the number of times x appears in the list. Sort the items of the list in place (the arguments can be used for sort customization, see for their explanation). Reverse the elements of the list in place. Return a shallow copy of the list. Similar to . An example that uses most of the list methods: You might have noticed that methods like , or that only modify the list have no return value printed – they return the default . This is a design principle for all mutable data structures in Python. Another thing you might notice is that not all data can be sorted or compared. For instance, doesn’t sort because integers can’t be compared to strings and can’t be compared to other types. Also, there are some types that don’t have a defined ordering relation. For example, isn’t a valid comparison. The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved (“last-in, first-out”). To add an item to the top of the stack, use . To retrieve an item from the top of the stack, use without an explicit index. For example: It is also possible to use a list as a queue, where the first element added is the first element retrieved (“first-in, first-out”); however, lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from the beginning of a list is slow (because all of the other elements have to be shifted by one). To implement a queue, use which was designed to have fast appends and pops from both ends. For example: # The first to arrive now leaves # The second to arrive now leaves List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition. For example, assume we want to create a list of squares, like: Note that this creates (or overwrites) a variable named that still exists after the loop completes. We can calculate the list of squares without any side effects using: which is more concise and readable. A list comprehension consists of brackets containing an expression followed by a clause, then zero or more or clauses. The result will be a new list resulting from evaluating the expression in the context of the and clauses which follow it. For example, this listcomp combines the elements of two lists if they are not equal: Note how the order of the and statements is the same in both these snippets. If the expression is a tuple (e.g. the in the previous example), it must be parenthesized. # create a new list with the values doubled # apply a function to all the elements # the tuple must be parenthesized, otherwise an error is raised File , line : did you forget parentheses around the comprehension target? # flatten a list using a listcomp with two 'for' List comprehensions can contain complex expressions and nested functions: The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension. Consider the following example of a 3x4 matrix implemented as a list of 3 lists of length 4: The following list comprehension will transpose rows and columns: As we saw in the previous section, the inner list comprehension is evaluated in the context of the that follows it, so this example is equivalent to: which, in turn, is the same as: # the following 3 lines implement the nested listcomp In the real world, you should prefer built-in functions to complex flow statements. The function would do a great job for this use case: See Unpacking Argument Lists for details on the asterisk in this line.\n\nWe saw that lists and strings have many common properties, such as indexing and slicing operations. They are two examples of sequence data types (see Sequence Types — list, tuple, range). Since Python is an evolving language, other sequence data types may be added. There is also another standard sequence data type: the tuple. A tuple consists of a number of values separated by commas, for instance: File , line , in : # but they can contain mutable objects: As you see, on output tuples are always enclosed in parentheses, so that nested tuples are interpreted correctly; they may be input with or without surrounding parentheses, although often parentheses are necessary anyway (if the tuple is part of a larger expression). It is not possible to assign to the individual items of a tuple, however it is possible to create tuples which contain mutable objects, such as lists. Though tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are immutable, and usually contain a heterogeneous sequence of elements that are accessed via unpacking (see later in this section) or indexing (or even by attribute in the case of ). Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list. A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. For example: The statement is an example of tuple packing: the values , and are packed together in a tuple. The reverse operation is also possible: This is called, appropriately enough, sequence unpacking and works for any sequence on the right-hand side. Sequence unpacking requires that there are as many variables on the left side of the equals sign as there are elements in the sequence. Note that multiple assignment is really just a combination of tuple packing and sequence unpacking.\n\nPython also includes a data type for sets. A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like union, intersection, difference, and symmetric difference. Curly braces or the function can be used to create sets. Note: to create an empty set you have to use , not ; the latter creates an empty dictionary, a data structure that we discuss in the next section. Here is a brief demonstration: # show that duplicates have been removed # Demonstrate set operations on unique letters from two words # letters in a but not in b # letters in a or b or both # letters in both a and b # letters in a or b but not both Similarly to list comprehensions, set comprehensions are also supported:\n\nAnother useful data type built into Python is the dictionary (see Mapping Types — dict). Dictionaries are sometimes found in other languages as “associative memories” or “associative arrays”. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by keys, which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You can’t use lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like and . It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: . Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output. The main operations on a dictionary are storing a value with some key and extracting the value given the key. It is also possible to delete a key:value pair with . If you store using a key that is already in use, the old value associated with that key is forgotten. It is an error to extract a value using a non-existent key. Performing on a dictionary returns a list of all the keys used in the dictionary, in insertion order (if you want it sorted, just use instead). To check whether a single key is in the dictionary, use the keyword. Here is a small example using a dictionary: The constructor builds dictionaries directly from sequences of key-value pairs: In addition, dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments:\n\nWhen looping through dictionaries, the key and corresponding value can be retrieved at the same time using the method. When looping through a sequence, the position index and corresponding value can be retrieved at the same time using the function. To loop over two or more sequences at the same time, the entries can be paired with the function. What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. To loop over a sequence in reverse, first specify the sequence in a forward direction and then call the function. To loop over a sequence in sorted order, use the function which returns a new sorted list while leaving the source unaltered. Using on a sequence eliminates duplicate elements. The use of in combination with over a sequence is an idiomatic way to loop over unique elements of the sequence in sorted order. It is sometimes tempting to change a list while you are looping over it; however, it is often simpler and safer to create a new list instead.\n\nThe conditions used in and statements can contain any operators, not just comparisons. The comparison operators and are membership tests that determine whether a value is in (or not in) a container. The operators and compare whether two objects are really the same object. All comparison operators have the same priority, which is lower than that of all numerical operators. Comparisons can be chained. For example, tests whether is less than and moreover equals . Comparisons may be combined using the Boolean operators and , and the outcome of a comparison (or of any other Boolean expression) may be negated with . These have lower priorities than comparison operators; between them, has the highest priority and the lowest, so that A and not B or C is equivalent to (A and (not B)) or C . As always, parentheses can be used to express the desired composition. The Boolean operators and are so-called short-circuit operators: their arguments are evaluated from left to right, and evaluation stops as soon as the outcome is determined. For example, if and are true but is false, A and B and C does not evaluate the expression . When used as a general value and not as a Boolean, the return value of a short-circuit operator is the last evaluated argument. It is possible to assign the result of a comparison or other Boolean expression to a variable. For example, Note that in Python, unlike C, assignment inside expressions must be done explicitly with the walrus operator . This avoids a common class of problems encountered in C programs: typing in an expression when was intended.\n\nSequence objects typically may be compared to other objects with the same sequence type. The comparison uses lexicographical ordering: first the first two items are compared, and if they differ this determines the outcome of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is exhausted. If two items to be compared are themselves sequences of the same type, the lexicographical comparison is carried out recursively. If all items of two sequences compare equal, the sequences are considered equal. If one sequence is an initial sub-sequence of the other, the shorter sequence is the smaller (lesser) one. Lexicographical ordering for strings uses the Unicode code point number to order individual characters. Some examples of comparisons between sequences of the same type: Note that comparing objects of different types with or is legal provided that the objects have appropriate comparison methods. For example, mixed numeric types are compared according to their numeric value, so 0 equals 0.0, etc. Otherwise, rather than providing an arbitrary ordering, the interpreter will raise a exception."
    },
    {
        "link": "https://geeksforgeeks.org/python-dictionary",
        "document": "A Python dictionary is a data structure that stores the value in key: value pairs. Values in a dictionary can be of any data type and can be duplicated, whereas keys can’t be repeated and must be immutable.\n\nExample: Here, The data is stored in key:value pairs in dictionaries, which makes it easier to find values.\n\nIn Python, a dictionary can be created by placing a sequence of elements within curly {} braces, separated by a ‘comma’.\n• Dictionary keys are case sensitive: the same name but different cases of Key will be treated distinctly.\n• Keys must be immutable: This means keys can be strings, numbers, or tuples but not lists.\n• Keys must be unique: Duplicate keys are not allowed and any duplicate key will overwrite the previous value.\n• None . Hence, operations like search, insert, delete can be performed in Constant Time\n\nWe can access a value from a dictionary by using the key within square brackets orget()method.\n\nWe can add new key-value pairs or update existing keys by using assignment.\n\nWe can remove items from dictionary using the following methods:\n• None : Removes an item by key and returns its value.\n• None : Removes and returns the last key-value pair.\n\nWe can iterate over keys [using keys() method] , values [using values() method] or both [using item() method] with a for loop.\n\nRead in detail – Ways to Iterating Over a Dictionary\n• None Check if two arrays are equal or not\n• None Max distance between two occurrences in array\n• None Count all pairs with absolute difference equal to k\n• None Remove minimum elements such that no common elements exist in two arrays\n• None Count distinct elements in every window of size k\n\nHow to use dictionaries in Python?\n\nHow to print dictionaries in Python?\n\nHow to declare a dictionary in Python?\n\nWhat are dictionary keys and values in Python?"
    },
    {
        "link": "https://w3schools.com/python/python_dictionaries.asp",
        "document": "Dictionaries are used to store data values in key:value pairs.\n\nA dictionary is a collection which is ordered*, changeable and do not allow duplicates.\n\nDictionaries are written with curly brackets, and have keys and values:\n\nDictionary items are ordered, changeable, and do not allow duplicates.\n\nDictionary items are presented in key:value pairs, and can be referred to by using the key name.\n\nWhen we say that dictionaries are ordered, it means that the items have a defined order, and that order will not change.\n\nUnordered means that the items do not have a defined order, you cannot refer to an item by using an index.\n\nDictionaries are changeable, meaning that we can change, add or remove items after the dictionary has been created.\n\nDictionaries cannot have two items with the same key:\n\nTo determine how many items a dictionary has, use the function:\n\nThe values in dictionary items can be of any data type:\n\nFrom Python's perspective, dictionaries are defined as objects with the data type 'dict':\n\nIt is also possible to use the dict() constructor to make a dictionary.\n\nThere are four collection data types in the Python programming language:\n• List is a collection which is ordered and changeable. Allows duplicate members.\n• Tuple is a collection which is ordered and unchangeable. Allows duplicate members.\n• Set is a collection which is unordered, unchangeable*, and unindexed. No duplicate members.\n• Dictionary is a collection which is ordered** and changeable. No duplicate members.\n\n*Set items are unchangeable, but you can remove and/or add items whenever you like. **As of Python version 3.7, dictionaries are ordered. In Python 3.6 and earlier, dictionaries are unordered.\n\nWhen choosing a collection type, it is useful to understand the properties of that type. Choosing the right type for a particular data set could mean retention of meaning, and, it could mean an increase in efficiency or security."
    },
    {
        "link": "https://realpython.com/python-dicts",
        "document": "Python dictionaries are a powerful built-in data type that allows you to store key-value pairs for efficient data retrieval and manipulation. Learning about them is essential for developers who want to process data efficiently. In this tutorial, you’ll explore how to create dictionaries using literals and the constructor, as well as how to use Python’s operators and built-in functions to manipulate them.\n\nBy learning about Python dictionaries, you’ll be able to access values through key lookups and modify dictionary content using various methods. This knowledge will help you in data processing, configuration management, and dealing with JSON and CSV data.\n\nBy the end of this tutorial, you’ll understand that:\n• A dictionary in Python is a mutable collection of key-value pairs that allows for efficient data retrieval using unique keys.\n• Both and can create dictionaries in Python. Use for concise syntax and for dynamic creation from iterable objects.\n• is a class used to create dictionaries. However, it’s commonly called a built-in function in Python.\n• is a special attribute in Python that holds an object’s writable attributes in a dictionary.\n• Python is implemented as a hashmap, which allows for fast key lookups.\n\nTo get the most out of this tutorial, you should be familiar with basic Python syntax and concepts such as variables, loops, and built-in functions. Some experience with basic Python data types will also be helpful.\n\nDictionaries are one of Python’s most important and useful built-in data types. They provide a mutable collection of key-value pairs that lets you efficiently access and mutate values through their corresponding keys: # Access a value through its key A Python dictionary consists of a collection of key-value pairs, where each key corresponds to its associated value. In this example, is a key, and is the associated value. Dictionaries are a fundamental part of Python. You’ll find them behind core concepts like scopes and namespaces as seen with the built-in functions and : The function returns a dictionary containing key-value pairs that map names to objects that live in your current global scope. Python also uses dictionaries to support the internal implementation of classes. Consider the following demo class: The special attribute is a dictionary that maps attribute names to their corresponding values in Python classes and objects. This implementation makes attribute and method lookup fast and efficient in object-oriented code. You can use dictionaries to approach many programming tasks in your Python code. They come in handy when processing CSV and JSON files, working with databases, loading configuration files, and more. Python’s dictionaries have the following characteristics:\n• Mutable: The dictionary values can be updated in place.\n• Dynamic: Dictionaries can grow and shrink as needed.\n• Efficient: They’re implemented as hash tables, which allows for fast key lookup.\n• Ordered: Starting with Python 3.7, dictionaries keep their items in the same order they were inserted. The keys of a dictionary have a couple of restrictions. They need to be:\n• Hashable: This means that you can’t use unhashable objects like lists as dictionary keys.\n• Unique: This means that your dictionaries won’t have duplicate keys. In contrast, the values in a dictionary aren’t restricted. They can be of any Python type, including other dictionaries, which makes it possible to have nested dictionaries. It’s important to note that dictionaries are collections of pairs. So, you can’t insert a key without its corresponding value or vice versa. Since they come as a pair, you always have to insert a key with its corresponding value. Note: In some situations, you may want to add keys to a dictionary without deciding what the associated value should be. In those cases, you can use the method to create keys with a default or placeholder value. In practice, you can use a dictionary when you need an efficient and mutable data structure that maps keys to values. In the following sections, you’ll learn how to create and use dictionaries in your Python code.\n\nYou can create Python dictionaries in a couple of ways, depending on your needs. The most common way is to use dictionary literals, which are a comma-separated series of key-value pairs in curly braces. The second way is to use the constructor, which lets you create dictionaries from iterables of key-value pairs, other mappings, or a series of keyword arguments. It also lets you create empty dictionaries when you call it without arguments. In the following sections, you’ll dive deeper into how to create Python dictionaries using literals and the constructor. You can define a dictionary by enclosing a comma-separated series of key-value pairs in curly braces ( ). To separate the keys from their values, you need to use a colon ( ). Here’s the syntax for a dictionary literal: The keys and values are completely optional, which means that you can use an empty pair of curly braces to create an empty dictionary. Then, you have the keys, a colon, and the value associated with the current key. To separate the pairs, you use a comma. The keys must be hashable objects like numbers, strings, or tuples. Being hashable means they can be passed to a hash function. A hash function takes data of arbitrary size and maps it to a fixed-size value called a hash value—or just hash—which is used for table lookup and comparison. In Python, the built-in immutable data types are hashable, and the mutable types are unhashable. Note: Python sets also use curly braces to define their literals, but they enclose individual elements rather than key-value pairs. To create an empty set, you need to use instead of an empty pair of curly braces because this syntax is reserved for empty dictionaries. The following code defines a dictionary that maps cities or states to the names of their corresponding Major League Baseball (MLB) teams: You can only use hashable Python objects as dictionary keys. The following example shows a dictionary with integer, float, and Boolean objects used as keys: You can even use objects like data types and functions as keys: However, you can’t use unhashable objects as keys. If you try to, then you’ll get an error: Python lists are unhashable because any changes to their content would change their hash value, violating the requirement that hash values must remain constant for hashable types. In practice, you can’t use any mutable data type as a key in a dictionary. This means that lists, sets, and dictionaries themselves aren’t allowed. If you need to use sequences as dictionary keys, then you can use tuples because tuples are immutable: It’s important to note that even though tuples are immutable, they can contain mutable objects. You can’t use a tuple that contains mutable objects as a dictionary key: In this example, the tuple that you try to use as a dictionary key contains a list. As a result, the tuple isn’t hashable anymore, so you get an error. Duplicate keys aren’t allowed in Python’s data type. Because of this restriction, when you assign a value to an existing key, you won’t add a second instance of the key. Instead, you’ll replace the previously associated value with a new one. For example, say that a given city has a second MLB team. You may try to add the second team by assigning it to the same key: In this example, you try to add a new key-value pair for the second MLB team in Chicago. However, what happens is that you replace the old team name ( ) with the new one ( ). Similarly, if you specify a key a second time during the creation of a dictionary, the second occurrence will override the first: In this example, your dictionary ends up containing the pair because you inserted it after with the same key. Unlike dictionary keys, there are no restrictions for dictionary values. Literally none at all. A dictionary value can be any type of object, including mutable types like lists and dictionaries, as well as user-defined objects: In this example, you create a dictionary with a list, a set, an integer, and a custom object as values. All these objects work because values have no restrictions. There’s also no restriction against a particular value appearing in a dictionary multiple times: In this example, your dictionary contains multiple instances of the letter as a value. This is completely okay because values don’t have the restriction of needing to be unique. You can also build dictionaries with the constructor. The arguments to can be a series of keyword arguments, another mapping, or an iterable of key-value pairs. Here are the constructor’s signatures: If you call the constructor without arguments, then you get an empty dictionary: In most cases, you’ll use an empty pair of curly braces to create empty dictionaries. However, in some situations, using the constructor might be more explicit. If the keys of your dictionary are strings representing valid Python identifiers, then you can specify them as keyword arguments. Here’s how you’d create the dictionary with this approach: Again, to build a dictionary using keyword arguments, the keys must be strings holding valid Python names. Otherwise, they won’t work as argument names. This is a syntactical restriction of Python. You can also create a dictionary from an iterable of key-value pairs. Here’s how you can build the dictionary this way: In this example, you build the dictionary using a list of two-item tuples. The first item acts as the key, and the second is the associated value. A cool way to create dictionaries from sequences of values is to combine them with the built-in function and then call as shown below: The function takes one or more iterables as arguments and yields tuples that combine items from each iterable. Note that your original data must be stored in ordered sequences for this technique to work correctly because the order is essential. Otherwise, you can end up with a dictionary that maps keys to values incorrectly. The data type has a class method called that lets you create new dictionaries from an iterable of keys and a default value. The method’s signature looks like the following: The argument provides the keys that you want to include in your dictionary. Even though the input iterable can have duplicate items, the final dictionary will have unique keys as usual. The argument allows you to define an appropriate default value for all the keys. This argument defaults to , which can serve as a good default value in several scenarios. Here’s an example of how to create a new dictionary with the method: In this example, you create a dictionary to store an inventory of fruits. Initially, you have the list of fruits in stock but don’t have the corresponding amounts. So, you use as the default amount in the call to .\n\nPython dictionaries have several methods that you can call to perform common actions like accessing keys, values, and items. You’ll also find methods for updating and removing values. In the following sections, you’ll learn about these methods and how to use them in your Python code. To get started, you’ll learn about methods you can use to access the data stored in an existing dictionary. You’ll also learn about methods for getting a single key and retrieving all the values, keys, and pairs from a dictionary. These methods are useful in real-world Python programming. The method provides a convenient way to retrieve the value associated with a key without checking whether the key exists beforehand. The key you want to search for is the first argument to . The second argument, which is optional, is a default value that will be used if the target key doesn’t exist in the dictionary. Note that the default value of is : If the target key exists in the dictionary, then you get the corresponding value. If the key isn’t found in the dictionary and the optional argument is specified, then you get as a result. You can also provide a convenient value to : In this example, the key isn’t in the dictionary. Because of this, you get the custom default value ( ) as a result. The method returns a dictionary view object, which provides a dynamic view of the values in a dictionary: The object contains all the values in . Note that any duplicate values will be returned as many times as they occur. The method returns a dictionary view object with a dynamic view of the keys in the target dictionary: Again, the view object contains all the keys in the dictionary. Since dictionary keys are unique, you won’t get any duplicate keys. Getting All the Items or Key-Value Pairs: The method returns a dictionary view containing tuples of keys and values. The first item in each tuple is the key, while the second item is the associated value: The view object contains the key-value pairs of your dictionary as two-item tuples of the form . Python’s built-in data type also has methods for adding and updating key-value pairs. For this purpose, you have the and methods. You’ll learn about them in the following sections. The method lets you set default values to keys. If is in the dictionary, then the method returns the associated value. If isn’t in the dictionary, it’s inserted with as its associated value. Then, it returns : When you call with an existing key, you get the associated value. If the key is missing, you get —which is the value—and a new key-value pair is inserted. If the key is missing and you provide a custom value, then you get the custom and a new key-value pair. The method merges a dictionary with another dictionary or with an iterable of key-value pairs. If is a dictionary, then merges the entries from into . For each key in , you can have one of the following results:\n• If the key isn’t present in , then the key-value pair from is added to .\n• If the key is present in , then the corresponding value in is updated to the value in . Here’s an example showing two dictionaries merged together: In this example, you update the dictionary with content from the dictionary. Note how the existing keys were updated while the missing ones were added to the end of . The argument may also be a sequence of key-value pairs: Here, you pass a list of tuples as an argument to . The method updates the existing keys or adds new keys as needed. Finally, you can also call with keyword arguments: In this example, you call with keyword arguments, and the method updates the existing keys or adds new keys as needed. Removing key-value pairs is another common operation that you may need to perform on your dictionaries. To do this, the class provides a few useful methods. In the following sections, you’ll learn about these methods and how they work. The method removes key-value pairs by keys. If the key exists, then the method returns its associated value. On the other hand, if the key doesn’t exist and isn’t provided, then you get a . Otherwise, you get the value: If the target key isn’t present in the dictionary, and the optional argument is specified, then that value is returned and no exception is raised. When you want to both delete an item and retain its value, you’ll commonly use . If you just want to remove the item, then you typically go with the statement: In this example, you remove the key and its associated value without returning the value as does. The method removes a key-value pair from a dictionary. This method returns the removed pair as a tuple of the form . The pairs are removed in LIFO (last-in, first-out) order: Calling removes a key-value pair from the dictionary and returns it as a two-item tuple. The first item is the key, and the second is the value. Note that the items are removed from right to left, starting with the last item added. Note: In Python versions prior to 3.6, returned an arbitrary key-value pair because Python dictionaries were unordered before this version. If the dictionary is empty, then raises a exception: When you call on an empty dictionary, you get a because there are no items to remove. The method removes all the items from a dictionary: Calling the method on an existing dictionary will remove all the current key-value pairs from the dictionary.\n\nThere are a few Python operators you can use with dictionaries. The most notable ones are the membership, equality, and union operators. In the following sections, you’ll learn how these operators work with dictionaries by coding and running some quick examples. The membership operators and allow you to determine whether a given key, value, or item is in a dictionary, depending on the target iterable you use. Note: To learn more about membership tests, check out Python’s “in” and “not in” Operators: Check for Membership. For example, to check whether:\n• A key is in a dictionary, you can use the dictionary itself or the method to provide the target iterable\n• A value is in a dictionary, you can use the method to provide the target iterable\n• An item is in a dictionary, you can use the method to provide the target iterable To illustrate, say that you want to check whether a given city is in your dictionary. To do this, you can use the and operator with the dictionary itself or with the method: In the first membership test, you check whether Milwaukee is included in the dictionary. Because this city is in the dictionary, you get as a result. Then, you check whether Indianapolis is a member of the dictionary, which returns . In this first series of examples, you use the dictionary as the target iterable for the and operators. In the second series of examples, you use . As you can see, both techniques work the same. However, using in membership is redundant and slightly less efficient than using the dictionary directly. For an execution time comparison, click to open the collapsible section below and run the script on your computer: Run this script to test the speed of membership tests on vs : The script uses to repeat the membership tests one million times each. When you run it, you’ll see output similar to the following: You can see that while the differences are noticeable, they aren’t particularly significant. You can also use the and operators with the method to determine whether a given value is in your dictionary: In this example, you use the method to provide the target iterable for the membership test. This is how to know if a given team is in your dictionary. Finally, in some situations, you may want to know whether a key-value pair is in the target dictionary. To figure this out, you can use the membership operators with the method: Note that in this example, you use a tuple containing the key-value pair as the value to check. Then, you use the method to provide the target iterable. The equality ( ) and inequality ( ) operators also work with dictionaries. These operators disregard element order when you use them with dictionaries, which is different from what happens with lists, for example: When you compare a list using the equality operator, the result depends on both the content and the order. In contrast, when you compare two dictionaries that contain the same series of key-value pairs, the order of those pairs isn’t considered. The inequality operator when used with dictionaries doesn’t consider the order of pairs either. The union operator ( ) creates a new dictionary by merging the keys and values of two initial dictionaries. The values of the dictionary to the right of the operator take precedence when both dictionaries share keys: In this example, you merge the and dictionaries to build the final dictionary using the union operator. Note that the and keys are common to both initial dictionaries, and . After the union, the values associated with these keys in prevail. The key-value pairs that didn’t exist in are added to the end of the new dictionary. Similarly, the augmented union operator ( ) updates an existing dictionary with key-value pairs from another dictionary, mapping, or iterable of key-value pairs. Again, when the operands share keys, the values from the right-hand side operand take priority: In this new version of the dictionary, you don’t create a new dictionary for the final configuration. Instead, you update the existing dictionary with the content of using the augmented union operator. In a sense, the augmented union operator works like the method, updating an existing dictionary with the content of another.\n\nIn Python, you’ll find several built-in functions that you can use for processing or working with dictionaries. Here’s a quick summary of some of these functions: Returns if all the items in an iterable are truthy and otherwise. Returns if at least one element in the iterable is truthy and otherwise. Returns an integer representing the number of items in the input object. Returns the largest value in an iterable or series of arguments. Returns the smallest value in an iterable or series of arguments. Returns a new sorted list of the elements in the iterable. Returns the sum of a start value and the values in the input iterable from left to right. As you can see, all these functions have different goals. Also, you can use them with different dictionary components. In the following sections, you’ll learn about using these functions to process Python dictionaries. Checking for Truthy Data in Dictionaries: and To start off, say that you have a dictionary that maps products to their amounts. You want to know whether all of the products are stocked. To figure this out, you can use the function with the dictionary values as a target: In the first call to , you get because all product amounts differ from . In the second example, you get because you’re out of mangoes. You can use the function in a similar fashion. Note: To learn more about and , check out the following tutorials:\n• How to Use in Python You can use these functions with keys as well. To do this, you can use either the dictionary directly or the method. Finally, using these functions with items doesn’t make sense because the method returns non-empty tuples. Sometimes, you need to know the number of key-value pairs in an existing dictionary. The built-in function returns exactly that number: When you use a dictionary as an argument for , the function returns the number of items in the dictionary. In this example, the input dictionary has six key-value pairs, so you get 6 as a result. If you ever need to find the minimum and maximum value stored in a dictionary, then you can use the built-in and functions: In this example, you use the and functions to find the lower and higher prices with the method. You can also use the functions with dictionary keys and even with items. However, note that these functions are mostly used with numeric values. Sorting the items of a dictionary may be another common requirement. To do this, you can use the built-in function. To illustrate, say that you have a dictionary matching student names with their average grades and you want to sort the data by grades. Here’s how you can do this sorting: The function returns a list of sorted values, so you wrap its call with to build a new sorted dictionary. In the first call, you sort the items by value in ascending order. To do this, you use a function that takes a two-value tuple as an argument and returns the second item, which has an index of . In the second call to , you set the argument to so that the function returns a list of items stored in reverse order. Note: To dive deeper into sorting dictionaries, check out the Sorting a Python Dictionary: Values, Keys, and More tutorial. You can also sort the dictionary by its keys: In this example, you sort the dictionary by keys using a function that returns the first value in the input tuple. Finally, you can also use to sort the keys and values: In the first call to , you use the dictionary as an argument. This results in a list of sorted keys. Next, you use the method to get a list of sorted values. You can also use the built-in function with dictionaries. For example, you can use the function to sum up numeric dictionary values or keys. Note: To learn more about about , check out Python’s : The Pythonic Way to Sum Values. To illustrate, say that you have a dictionary containing daily sales data and want to know the average daily sales. In this scenario, you can do something like the following: In this example, you use the function to calculate the total sales. To do this, you use the method. Then, you compute the average with the help of .\n\nIterating over data collections, including dictionaries, is a common task in programming. In this sense, Python dictionaries are pretty versatile, allowing you to iterate over their keys, values, and items. Note: To learn more about dictionary iteration, check out the How to Iterate Through a Dictionary in Python tutorial. In the following sections, you’ll learn the basics of iterating over Python dictionaries and their components. To kick things off, you’ll start by iterating over dictionary keys. There are two different ways you can iterate over the keys of a dictionary. You can either use the dictionary directly, or use the method. The following examples show how to use these two approaches: In these examples, you first iterate over the keys of a dictionary using the dictionary directly in the loop header. In the second loop, you use the method to iterate over the keys. Both loops are equivalent. The second loop is more explicit and readable, but it can be less efficient than the first loop because of the additional method call. Note that in both loops, you can access the dictionary values as well: To access the values in this type of iteration, you can use the original dictionary and a key lookup operation, as shown in the highlighted line. When it comes to iterating through dictionary values, you can use the method to feed the loop. To illustrate, say that you’re working with the dictionary and need to iterate over the team names only: To iterate over the values of a dictionary, you can use the method. In this example, you iterate over the registered MLB teams one by one. Note that when you use the method, you can’t access the dictionary keys. Finally, in many cases, you’ll need to iterate over both keys and values in a Python dictionary. In this case, the recommended and most Pythonic approach is to use the method: When iterating over keys and values this way, you typically use a tuple of loop variables. The first variable will get the key, while the second will get the associated value. In this example, you have the and variables, which make the code clear and readable.\n\nIn the Python standard library, you’ll find a few dictionary-like classes that have been adapted to perform specific tasks. The most notable examples are the following: A dictionary subclass specially designed to remember the order of items, which is defined by the insertion order of keys. A dictionary subclass specially designed to provide efficient counting capabilities out of the box. All these classes and a few others are available in the module found in the Python standard library. isn’t that useful anymore because since Python 3.6, dictionaries keep their items in the same insertion order. However, you may find some interesting differences between and that can help you decide which dictionary best suits your needs. The class provides an efficient tool convenient for counting objects: In this example, you use to count the letters in a string. The resulting dictionary’s keys are the letters, while the values are the number of occurrences of each letter. Note that the items in a instance are sorted in descending order out of the box, which can be useful for building rankings. The class automatically creates a new key and generates a default value for it when you try to access or modify a missing key. To illustrate, say that you have the following data in a list of tuples: You want to create a dictionary that uses the departments as keys. Each key should map a list of people working in the department. Here’s how you can do this quickly with , which is an invaluable tool when you want to group elements together: In this example, you create a called and use a loop to iterate through your list. The line creates the keys for the departments, initializes them to an empty list if necessary, and then appends the employees to each department."
    },
    {
        "link": "https://dataquest.io/blog/python-dictionaries",
        "document": "What Is a Dictionary in Python?\n\nA Python dictionary is a data structure that allows us to easily write very efficient code. In many other languages, this data structure is called a hash table because its keys are hashable. We'll understand in a bit what this means.\n\nA Python dictionary is a collection of pairs. You can think about them as words and their meaning in an ordinary dictionary. Values are said to be mapped to keys. For example, in a physical dictionary, the definition science that searches for patterns in complex data using computer methods is mapped to the key Data Science.\n\nIn this Python tutorial, you'll learn how to create a Python dictionary, how to use its methods, and dictionary comprehension, as well as which is better: a dictionary or a list. To get the most out of this tutorial, you should be already familiar with Python lists, for loops, conditional statements, and reading datasets with the method. If you aren't, you can learn more at Dataquest.\n\nWhat Are Python Dictionaries Used for?\n\nPython dictionaries allow us to associate a value to a unique key, and then to quickly access this value. It's a good idea to use them whenever we want to find (lookup for) a certain Python object. We can also use lists for this scope, but they are much slower than dictionaries.\n\nThis speed is due to the fact that dictionary keys are hashable. Every immutable object in Python is hashable, so we can pass it to the function, which will return the hash value of this object. These values are then used to lookup for a value associated with its unique key. See the example of the use of the function below:\n\nThe string has a hash value of . This value may be different in your case.\n\nBut let's stop with the theory and go straight to the dictionary creation. We have two main methods to define a dictionary: with curly braces or using the method. We'll create two empty dictionaries:\n\nWe can see that both dictionaries have the same data type and are equivalent. Now let's populate a dictionary with keys and values. We can do it by using squared brackets, like this . We can then access the value by using bracket notation with the key we want the value of between the brackets: .\n\nThe value of is returned. We can also create a prepopulated dictionary using the syntax below:\n\nUltimately, another method is using , in which we supply keys and values as a keyword argument list or as a list of tuples:\n\nWe used the string data type for the key and the value, but what are the other admissible data types? In Python dictionaries, keys should be hashable objects (even if it's not technically correct, we can also say that the objects should be immutable). Thus, mutable data types like lists, aren't allowed. Let's try to different data types and see what happens:\n\nIntegers, floats, strings, and tuples are hashable data types (and they are also immutable) while lists are an unhashable data type (and they are mutable). Python uses hash values to quickly access a dictionary's values.\n\nOn the other hand, values can be of whatever type. Let's add more elements to the dictionary using different data types:\n\nAdditionally, we can modify the value of a key with bracket notation that we used to populate a dictionary:\n\nFinally, dictionary keys should be unique. Let's try to create a dictionary with duplicate keys:\n\nOnly the value of the last key is returned, so we can technically use duplicate keys, but it's not recommended because one of the strengths of dictionaries is to quickly retrieve a value associated with some key. If there are duplicates, we may return a value we didn't want. Imagine that we look up for the meaning of the word \"data\" and find 10 different entries for this word in a dictionary; it may be confusing.\n\nNow let's see what methods we can use to work with dictionaries.\n\nThe method is useful whenever we want to merge dictionaries or add new pairs using an iterable (iterables are, for instance, lists or tuples). Let's make an example using characters from the Harry Potter universe and the houses they belong to (spoiler: we'll use Harry Potter datasets later on!):\n\nLet's now add other characters and their houses using different options we have available for the method:\n\nWe can see that the dictionary now contains Albus Dumbledore and Luna Lovegood. We can also use an iterable to add new elements to the dictionary:\n\nWe used a list of lists where the first element of each list is the character name and the second element is their house. The method then will automatically associate the first element (key) with the second element (value). For the sake of the experiment, try to update the dictionary with a list of lists but with three elements in each nested list.\n\nWe can also use a list of tuples:\n\nWhat if we want to delete a pair from a dictionary? We can use the statement. It's essential to say that isn't an exclusive dictionary method but rather a Python keyword that we can use in multiple situations to delete whatever Python object (like variable, function, class, list's element, etc.).\n\nIf we're trying to delete a pair that isn't present in the dictionary, we'll get a :\n\nSometimes, we need to delete the last item that was inserted in a dictionary. The method is the way! Note that before Python 3.7, this method removes a random element from a dictionary:\n\nWe can also remove a specific pair and return the value using the method:\n\nIf we try to access a value of the key that doesn't exist in the dictionary, Python will return a . To get around this problem, we can use the method that will return the value if its key is in the dictionary, or it will return some default value that we set:\n\nThe method is often confused with the method. They perform more or less the same task. Indeed, if we suspect that there is a non-existing key in the dictionary, we can use this method to return a default value. However, in contrast to , this method inserts the default value of this key in the dictionary:\n\nWhat if we want to return all the pairs? Or just the keys? What about the values?\n\nThe answer to the first question is the method. When used on a dictionary, it will return a object, which is essentially a list of tuples, each containing a key and a value. This method may be useful when we loop through a dictionary as we'll see later.\n\nIf we want to get just the keys, we should use the method. It will return a object:\n\nFinally, we have the method that will return the values as a object:\n\nWhen Do I Use All These Methods?\n\nAfter this overview, you may feel overwhelmed by the amount of information. It's also not easy to determine when you should use the Python dictionary methods. No worries — that's absolutely okay. You shouldn't try to remember every single method and its use cases. When you have a real-world problem in front of you (Dataquest guided projects can be a good start), and you have to use dictionaries, just head back to this Python tutorial and see if you can solve your problems with one of these methods. This is the only way you can gain valuable experience and become much faster at using dictionary methods in your future projects!\n\nAs we're able to loop through lists, we're also able to loop through dictionaries. They hold two different types of elements, keys and values, so we can either loop through both types of elements simultaneously or just one of them.\n\nFirst of all, we'll use the method, which yields both keys and values:\n\nWe can see that this method allows us to access both keys and values. What if we're only interested in keys? Or only in values?\n\nLet's get more practical and also learn a slightly more advanced method. Sometimes, we need to compute the frequency of each value in a dictionary. We can use the method from , which is a great Python module with plenty of useful containers that make our coding lives easier.\n\nThe returned object is actually very similar to a dictionary. We can use the , , and methods on it!\n\nPython dictionaries are immensely handy when we have to create so-called frequency tables. Simply put, keys are the objects for which we want to count the frequency, and the values are the frequencies. As an example, we'll be using the Harry Potter Movies Dataset from Kaggle (the dataset). Let's say that we want to count the frequency of each house present in the dataset. To do so, we first have to create an empty dictionary that will contain the frequency table. Then, we have to loop through the list of houses, and if the key for a house is already present in the frequency table, we add 1 to its value. Otherwise, we create a key for the current house and map it to value 1 (it's one because we encounter this element for the first time). We also have to account for missing data in our dataset.\n\nMost of the characters from the dataset are from Gryffindor. To practice, try to create frequency tables of the other columns.\n\nSimilar to lists, there are also nested dictionaries. In other words, a dictionary can contain another dictionary! Let's use the dataset from the same set of Harry Potter datasets. It may happen that in your career, you work with multiple datasets at the same time. One way to organize them is by using dictionaries:\n\nNow we can easily access each dataset or a specific entry. To illustrate this, let's access the columns of the dataset:\n\nWe can also access the columns of both datasets with a for loop:\n\nAn alternative to this approach (especially when we don't have dozens of datasets) is to reorganize each dataset in a dictionary. It will simplify our work when we have to access different entries:\n\nDictionary comprehension in Python is an elegant and efficient method to create new dictionaries. You have probably already learned something about list comprehension. Just a quick reminder: comprehension in Python means applying the same operation on each element of an iterable (like a list). Let's illustrate how this technique works. For example, we want a dictionary that holds the runtimes of each of the Harry Potter movies. Let's create it from the dataset's dictionary :\n\nNow we want to convert each runtime from minutes to hours. First of all, we can do it with a regular for loop:\n\nHowever, we can simplify the above code by creating the runtime dictionary in just one line:\n\nLet's dissect the code above. First, look at where the for loop is now: we're still looping through the items of the dictionary. Now notice the curly braces: we're writing the code inside a dictionary! is the current key of our for loop, and after the colon ( ) we perform the operation of rounding and division by 60 directly on , which is the value of the for loop.\n\nThis code performs exactly the same operations as before, but it does it in 1 line instead of 3 lines.\n\nMoreover, we can also add conditional statements. Let's say that we want to exclude the movies that are shorter than 2.5 hours:\n\nWe just add an if-statement, and that's it.\n\nDictionary comprehension also works with the keys in a similar manner. Try it yourself!\n\nNote that if we have multiple conditional statements or complicated operations, it's better to use a regular for loop because dictionary comprehension may become an incomprehensible coding jungle, which undermines the benefits of Python readability.\n\nPython Dictionary vs List: Which Is Better?\n\nNow that we know more about Python dictionaries, it's time to compare dictionaries and lists. Which is better? Neither better than the other, but they are helpful in different coding tasks.\n\nThe rules to choose one of these data structures are actually pretty simple:\n• When you just need a sequence of elements that you can access with indexing, choose a list.\n• If you need to quickly access an element mapped to a specific unique key, choose a dictionary.\n\nThere is a bit more than that. Dictionaries are much faster if we want to access a specific element because they have a constant runtime, which means that the runtime doesn't depend on the size of the input object. In contrast, when we want to see if an element exists in a list, the runtime will depend on the size of this list (Python loops through the entire list). Look at the examples:\n\nIt may seem that the difference is negligible, but as we increase the input size the difference will skyrocket.\n\nLet's make a more concrete example. Often, we'll want to access a certain element in either a list or a dictionary. To find this element in a list, we first have to loop through the entire list, while in a dictionary, we can quickly access the same element by using its unique key. Let's find 9000000 in the list and the dictionary defined above.\n\nIt took the dictionary almost no time to locate the number, while the list took around 1 second to perform the same operation. The dictionary is almost one million times faster!\n\nRecall that we used the method to insert a default key and its value in a dictionary. We also used the method to return a default value of a non-existing key. A more Pythonic way to perform similar operations is by using from the module(). We can initialize a dictionary with a default value data type by calling it and passing the data type we want to the method. Now if we try to access a missing key, the dictionary will create this key and map a default value to it:\n\nHere the method created a key and assigned an empty list to it because that's the default value of our dictionary. We can now append some values to this list:\n\nThe arguments we pass to must be callable. If we pass a non-callable object to we'll get a :\n\nIn contrast, we can pass whatever object to the method:\n\nLet's also look at the method. We use it when we want to return a value of a key we suspect doesn't exist. This method will return only the value but won't change the dictionary in any way:\n\nNow we should be able to understand the difference between these three methods.\n\nHere's what we've covered in this tutorial:\n• How dictionaries allow us to quickly access a certain Python object\n• Creating a dictionary with the method or curly braces\n• When to use a list or a dictionary\n\nFeel free to connect with me on LinkedIn or GitHub. Happy coding!"
    },
    {
        "link": "https://stackoverflow.com/questions/49185191/python-dictionary-inside-get",
        "document": "The method replaces (which you normally access via bracket notation). is actually performing two lookups:\n• then looks up the name of the capital as the country. There are very few cases where this won't fail.\n\nIf you look up a country that does not exist, will just raise a .\n\nWhat you probably meant to do was\n\nOne more consideration you may want to address is that Python dictionaries are case sensitive. You probably want to get back whether you pass in , , or . The standard way of doing this is to make the keys of the dictionary all lowercase, and then look up with either the lowercase or case-folded version:\n\nNotice that I replaced the first with an argument to , and removed the operators in the second ."
    },
    {
        "link": "https://stackoverflow.com/questions/56440976/filling-a-list-of-dictionaries-of-key-values-from-list-of-data",
        "document": "I have a 'huge' list of countries and data relevant to each of the countries as lists in python. I need to map the data to each list. Therefore after some googling, have come to use dictionaries in python for this purpose. That is, each dictionary for each country resulting in a list of dictionaries. Then populate these dictionaries with the data(keys) like capital, language and population and their corresponding values. Ultimately I should have them all as numpy array as I need to plot graph for say example, country and its population.\n\nI am just a beginner so please feel free to suggest any better ways of doing this. Here is what I began with(reduced my dictionary to just 4) and somehow reached a dead end.\n\nMy problem is I do not see how to interatively create dictionaries and populate the keys with their values iteratively. The only fixed metric is the key (for now just 3 being population, language and capital)."
    },
    {
        "link": "https://geeksforgeeks.org/python-accessing-key-value-in-dictionary",
        "document": "A dictionary in Python is a useful way to store data in pairs, where each key is connected to a value. To access an item in the dictionary, refer to its key name inside square brackets.\n\nLet’s explore various ways to access keys, values or items in the Dictionary.\n\nWe can access dictionary items by using get() method. This method returns None if the key is not found instead of raising an error. Additionally, we can specify a default value that will be returned if the key is not found:\n\nBy using methods like keys(), values(), and items() methods we can easily access required items from the dictionary.\n\nGet all Keys Using key() Method\n\nIn Python dictionaries, keys() method returns a view of the keys. By iterating through this view using a for loop, you can access keys in the dictionary efficiently. This approach simplifies key-specific operations without the need for additional methods.\n\nGet all values Using values() Method\n\nIn Python, we can access the values in a dictionary using the values() method. This method returns a view of all values in the dictionary, allowing you to iterate through them using a for loop or convert them to a list.\n\nThe in is most used method that can get all the keys along with its value, the “in” operator is widely used for this very purpose and highly recommended as it offers a concise method to achieve this task.\n\nThe items() method allows you to iterate over both keys and values simultaneously. It returns a view of key-value pairs in the dictionary as tuples.\n• None Check whether given Key already exists in Dictionary\n• None Sort Python Dictionaries by Key or Value"
    },
    {
        "link": "https://pypod.github.io/chapter-6/lesson-6.1.html",
        "document": "Let us assume that we want to store the following information in Python:\n\nA minor geographical observation: South Africa has three capitals; we have only mentioned the legislative capital for convenience. A geopolitical point: these five countries form a part of a block called BRICS [refer].\n\nComing back to Python, a dictionary is possibly the most interesting data structure offered by Python. It is basically a look-up table. This is how we would store the details of the BRiCS nations and their capitals:\n\nA dictionary is a collection of key-value pairs. In the code given above, is a dictionary. It has countries mapped to their respective capitals. For instance, is mapped to . Here, is the key and is the value. That is, the country is the key and its capital is the value. A dictionary object is of type :\n\nTo access the value corresponding to a given key, we do the following:\n\nThe value corresponding to a given key can be updated:\n\nNew key-value pairs can be added to a dictionary. Let us expand the horizons of our dictionary to include countries outside the BRICS nations. It no longer makes sense to call this , so let us create a new dictionary called which starts off as a copy of . Recall the method that we used to copy lists. A similar method is defined for dictionaries:\n\nAdding a new key-value pair is as simple as the statement given in line-9 of the code given above. Keys of a dictionary are unique. This means that a dictionary cannot have two or more identical keys mapped to different values. On the other hand, two different keys could have the same value. For example:\n\nTrying to access a key that is not present in the dictionary will result in a :\n\nThe key of a dictionary can be any immutable object. There is a small catch here. We will return to this constraint in the next section. Let us look at different combinations key-value pairs that are possible beginning with the basic types: :\n\nNext, we have dictionaries that have and as the type of their values:\n\nTuples can be keys, provided they don't contain any mutable objects within them:\n\nTowards the end, we will look at an example where a tuple cannot be a key. Finally, the richness of dictionaries comes out in the following example:\n\nEarlier, it was mentioned that the keys of dictionaries have to be immutable. This statement is not entirely accurate. In this section, we will explore why. What happens if we use a list as a key?\n\nIt throws a with the following message: . A list cannot be a key in a dictionary; but the error message doesn't talk about immutability, instead it says that the type is unhashable. A more accurate statement about keys in a dictionary is given below:\n\nTo understand what we mean by the term hashable, we shall briefly look at the way Python implements dictionaries. The following section on hash tables is a bit involved and can be skipped.\n\nPython dictionaries are implemented using a data structure called a hash table. It is best to think about a hash table as a book-rack that has a number of rows. Picture the key-value pairs as books that are going to be stored in these racks. To access a book, we need to know the row number in which it is present. This is where the idea of a hash function comes in. The hash function is denoted by and converts the key to the row number.\n\nThe hash function accepts a key as input and returns a value, , as output. This is called the hash value. In our analogy, the hash value is synonymous with the rack number. Once we know the rack number, the book (key-value) stored in it can be easily retrieved. The description is somewhat naive, but you get the point.\n\nNow, an object in Python is hashable if it has a hash value which never changes during its lifetime and can be compared to other objects. Most of the immutable objects that we have seen so far are hashable: . Mutable containers such as lists are not hashable. So, can we just go back to the original definition and claim that all immutable objects can be used as keys in dictionaries? No! Consider the following example:\n\nThough is immutable, it contains a sequence of lists which are mutable. According to the Python documentation, immutable containers are hashable only if their elements are hashable. So, is not hashable, and hence it cannot be used as a key! For a better explanation, check out the docs.\n\nWe can iterate over the keys of a dictionary:\n\nreturns a sequence of keys over which we can iterate. Python makes things even more simple and lets us drop the method.\n\nWe can also iterate over the key-value pairs in a dictionary:\n\nAn empty dictionary can be defined in one of the following ways:\n\nLet us now solve the following problem:\n\nA piece of trivia: what is common among the words in the list ?\n\nLike lists dictionaries are mutable objects. To see the mutability of objects in action, consider the following code:\n\nWe see that is alias of and both point to the same object. If we want a new object with the same contents as , we could either use the method or the built-in function:\n\nThe last line prints which confirms that we have two different objects. So modifying one doesn't affect the other. But note that only produces a shallow copy. As long as the values are immutable, this doesn't matter. But if we have mutable values, then we have a problem:\n\nHere, we see that the value corresponding to the key in both dictionaries gets affected. This is because and are still the same object. This can be seen from the last statement of the code given above. To set this right, we need to do a deepcopy:"
    },
    {
        "link": "https://python-course.eu/python-tutorial/dictionaries.php",
        "document": "In the preceding chapters, we delved into the fundamentals of lists, , including subtle intricacies. Now, as we progress through this chapter of our online Python course, we turn our attention to dictionaries, exploring their syntax, operators, and methods. Lists and dictionaries are indispensable components of Python programming, making Python a powerful and extremely useful programming language.\n\nLet's begin with a straightforward example to illustrate the concept of a dictionary:\n\nIn Python, a dictionary is a data structure that stores key-value pairs. Let's take a closer look at our example dictionary to explain the essential details:\n• The keys in our dictionary are strings and are positined in front of the colons. The keys of our example dictionary are 'name', 'age', 'city', and 'email'.\n• Each key is associated with a corresponding value separated by a colon : 'Anna Schmidt' is the value associated with the key 'name', 28 with 'age', 'Berlin' with 'city', and '[email protected]' with 'email'.\n• We call a key-value pair like 'name': 'Anna Schmidt' an item. So a dictionary contains an arbitrary sequence of pairs separated by commas.\n\nDictionaries are useful for organizing data in a way that allows quick and easy access based on specific keys.\n\nWe can also consider a dictionary like a digital information card about a person named Anna Schmidt from Berlin, Germany and keeps track of important details in a structured way.\n• 'name': This is where we keep Anna's full name, which is 'Anna Schmidt'.\n• 'age': Here we store Anna's age, which is 28 years old.\n• 'city': This tells us where Anna lives, which is in Berlin.\n• 'email': Anna's email address, which is '[email protected]', is stored here.\n\nIn the code snippet below, we demonstrate how to retrieve specific pieces of information from our dictionary, such as the 'name' or 'age', from the dictionary:\n\nNow, we'll illustrate how dictionaries can be modified because they are mutable. Let's consider a scenario where Anna relocates from Berlin to Freiburg, renowned as one of Germany's most picturesque cities, known for its favorable weather compared to other regions in the country.\n\nLike lists, they can be easily changed, can be shrunk and grown ad libitum at run time. They shrink and grow without the necessity of making copies. Dictionaries can be contained in lists and vice versa.\n\nLet's add Anna's gender and her favorite hobbies, which include reading, music, and programming (as she's a beginner in Python), to the existing dictionary:\n\nNow, we remove again the gender information from the dictionary:\n\nMore theoretically, we can say that dictionaries are the Python implementation of an abstract data type, known in computer science as an associative array. Associative arrays consist - like dictionaries of (key, value) pairs, such that each possible key appears at most once in the collection. Any key of the dictionary is associated (or mapped) to a value. The values of a dictionary can be any type of Python data. So, dictionaries are unordered key-value-pairs. Dictionaries are implemented as hash tables, and that is the reason why they are known as \"Hashes\" in the programming language Perl.\n\nDictionaries don't support the sequence operation of the sequence data types like strings, tuples and lists. Dictionaries belong to the built-in mapping type, but so far, they are the sole representative of this kind!\n\nAt the end of this chapter, we will demonstrate how a dictionary can be turned into one list, containing (key,value)-tuples or two lists, i.e. one with the keys and one with the values. This transformation can be done reversely as well.\n\nBut what's the difference between lists and dictionaries?\n\nA list is a sequence of objects where the order matters. You can access list elements directly by their position in this order. Similarly, dictionaries are also ordered, but unlike lists, you can't access elements by their position. We can also say that contrary to lists that the order of a dictionary is not important. The order of items in a dictionary is determined by the sequence in which they were added. If we print a dictionary, we can see this ordering.\n\nLet's demonstrate this with the following dictionary:\n\nWe will add now the German cities \"München\" (Munich) and \"Köln' (Cologne) to our dictionary:\n\nWe can see that the cities \"München\" (Munich) and \"Köln' (Cologne) had been added to the end of the dictionary as expected.\n\nIf you have worked for a while with Python, nearly inevitably the moment will come, when you want or have to convert lists into dictionaries or vice versa. It wouldn't be too hard to write a function doing this. But Python wouldn't be Python, if it didn't provide such functionalities. We can convert the previously defined dictionary into a list with the following expression:\n\nThis list holds the identical information as the dictionary city_population. However, retrieving this data differs significantly. What if you want to get the population of Amsterdam? It's extremely easy with the dictionary:\n\nIt's a lot more complicated in the list representation. We're limited to accessing indices rather than city names. Consequently, we must iterate over the list and inspect all the tuples to determine if the first entry corresponds to the city of Amsterdam.\n\nIn this aspect, the dictionary method outperforms the list approach by enabling swifter data access. In a dictionary, you can directly retrieve the population of a city using its name as the key, which is much quicker compared to searching through a list to find the population. Think of it like looking up a word in a dictionary versus flipping through the pages of a book to find it. The dictionary provides instant access, while the list requires more time to search through.\n\nThe efficiency of this algorithm depends on the size of the city_population_list. Since it iterates through the entire list linearly to find the population of a given city, the time complexity is O(n), where n is the number of cities in the list.\n\nFor a small number of cities, this approach is acceptable. However, as the number of cities grows larger, the linear search becomes less efficient, especially if the city being searched for is towards the end of the list or if the list contains a large number of cities.\n\nIn scenarios where performance is critical or when dealing with a large dataset, a more efficient approach would be to use a dictionary instead of a list, where the keys are the city names. This would allow constant-time (O(1)) lookups, providing faster access to population data.\n\nIf we apply the method items() to a dictionary, we don't get a list back, as it used to be the case in Python 2, but a so-called items view. The items view can be turned into a list by applying the list function. We have no information loss by turning a dictionary into an item view or an items list, i.e. it is possible to recreate the original dictionary from the view created by items().\n\nAccessing dictionary items via a method like items() provides a more efficient approach compared to creating lists directly due to several reasons:\n\n1) Lazy Evaluation: The items() method doesn't generate the entire list of key-value pairs upfront. Instead, it returns a view object that generates items on-the-fly as needed. This lazy evaluation saves memory and processing time, especially when dealing with large dictionaries where creating a complete list of items upfront may be resource-intensive.\n\n2) Memory Efficiency: Generating a list of items directly requires storing all key-value pairs in memory simultaneously, which can be inefficient for large dictionaries. In contrast, using items() provides a memory-efficient solution as it generates items dynamically without storing the entire list in memory at once.\n\n3) Time Complexity: While both approaches have similar time complexity for iterating over all items (O(n), where n is the number of items in the dictionary), using items() may provide better performance in certain scenarios. For example, if only a subset of items is needed, items() allows for efficient iteration over only the required items without iterating over the entire dictionary.\n\nOverall, using methods like items() for accessing dictionary items provides a more efficient and memory-friendly approach, especially for large dictionaries or scenarios where lazy evaluation and selective item retrieval are beneficial.\n\nThe keys() method returns a view object that displays a list of all keys in the dictionary. This allows you to iterate over or access the keys directly without needing to create a separate list of keys.\n\nWhile the keys() method is available in Python dictionaries, it's less commonly used because iterating over a dictionary directly implicitly iterates over its keys. Here's an example demonstrating this:\n\nWe can also iterate directly over the values of a dictionary:\n\nNow we will turn our attention to the art of cooking, but don't be afraid, this remains a python course and not a cooking course. We want to show you, how to turn lists into dictionaries, if these lists satisfy certain conditions. We have two lists, one containing the names of the largest German cities and the other one the corresponding areas:\n\nIn this example, we have two lists: containing the names of the five largest cities in Germany, and containing their respective areas in square kilometers. We use the function to combine these lists into a list of tuples, then we use the function to convert this list of tuples into a dictionary, where each city is paired with its respective area.\n\nTo gain further insight into the functionality of the zip function, explore our tutorial available at 'zip'.\n\nWhat is wrong with the following example:\n\nThe issue with this example is that we are converting items to a list using list(items) before iterating over it. Once you convert items to a list, it becomes exhausted, meaning it doesn't contain any more elements for iteration.\n\nSo, it's possible to create a dictionary incrementally by starting with an empty dictionary. We haven't mentioned so far, how to define an empty one. It can be done by using an empty pair of brackets. The following defines an empty dictionary called city:\n\nCloser Look at Keys and Values\n\nLooking at our first examples with the cities and their population, you might have gotten the wrong impression that the values in the dictionaries have to be different. The values can be the same, as you can see in the following example. In honour to the patron saint of Python \"Monty Python\", we'll have now some special food dictionaries. What's Python without \"bacon\", \"egg\" and \"spam\"?\n\nKeys of a dictionary are unique. In casse a keys is defined multiple times, the value of the last \"wins\":\n\nOur next example is a simple English-German dictionary:\n\nWhat about having another language dictionary, let's say German-French?\n\nNow it's even possible to translate from English to French, even though we don't have an English-French-dictionary. de_fr[en_de[\"red\"]] gives us the French word for \"red\", i.e. \"rouge\":\n\nWe can use arbitrary types as values in a dictionary, but there is a restriction for the keys. Only immutable data types can be used as keys, i.e. no lists or dictionaries can be used: If you use a mutable data type as a key, you get an error message:\n\nTuple as keys are okay, as you can see in the following example:\n\nNested dictionaries are dictionaries that contain other dictionaries as values. In Python, dictionaries can hold any data type as their values, including other dictionaries. This allows for the creation of hierarchical or nested data structures where each level of the dictionary can store its own set of key-value pairs.\n\nLet's improve our examples with the natural language dictionaries a bit. We create now a nested dictionary, i.e. a dictionary of dictionaries:\n\nThe following dictionary contains a mapping from latin characters to morsecode.\n\nThe numbers of characters contained in this dictionary can be determined by calling the len function:\n\nThe dictionary contains only upper case characters, so that \"a\" returns False, for example:\n\nNow, we will output a space character with three spaces in the morsecode encoding:\n\nLists can serve as stacks, with the pop() method used to extract an element from the stack. This functionality is straightforward for lists. However, considering dictionaries, does it make sense to have a pop() method? Unlike lists, dictionaries are not sequential data structures; they lack indexing. Consequently, the pop() method behaves differently with dictionaries.\n\nIn dictionaries, the pop() method is used to remove a specific key-value pair from the dictionary and return the corresponding value. Here's how it works:\n\n1) You specify the key of the item you want to remove as an argument to the pop() method. 2) The pop() method then searches for this key in the dictionary. 3) If the key is found, the corresponding key-value pair is removed from the dictionary, and the value associated with the key is returned. 4) If the key is not found, a KeyError is raised.\n\nHere's an example to illustrate:\n\nIf we try to find out the capital of France in the previous example, we raise a KeyError. To prevent these errors, there is an elegant way. The method pop() has an optional second parameter, which can be used as a default value, if key is not in the dictionary:\n\npopitem() is a method of dict, which doesn't take any parameter and removes and returns a (key,value) pair as a 2-tuple. If popitem() is applied on an empty dictionary, a KeyError will be raised.\n\nIf you try to access a key which doesn't exist, you will get an error message:\n\nTo prevent getting an exception we can check first, if the city is in:\n\nAnother method to access the values via the key consists in using the get() method. get() is not raising an error, if an index doesn't exist. In this case it will return None. It's also possible to set a default value, which will be returned, if an index doesn't exist:\n\nA dictionary can be copied with the method copy():\n\nThis copy is a shallow copy, not a deep copy. If a value is a complex data type like a list, for example, in-place changes in this object have effects on the copy as well:\n\nIf we check the output, we can see that the title of course2 has been changed not only in the dictionary training but in trainings2 as well.\n\nEverything works the way you expect it, if you assign a new value, i.e. a new object, to a key:\n\nIf you want to understand the reason for this behaviour, we recommend our chapter \"Shallow and Deep Copy\".\n\nThe content of a dictionary can be cleared with the method clear(). The dictionary is not deleted, but set to an empty dictionary:\n\nWhat about concatenating dictionaries, like we did with lists? There is someting similar for dictionaries: the update method update() merges the keys and values of one dictionary into another, overwriting values of the same key:\n\nNo method is needed to iterate over the keys of a dictionary:\n\nHowever, it's possible to use the method keys(), we will get the same result:\n\nThe method values() is a convenient way for iterating directly over the values:\n\nThe above loop is logically equivalent to the following one:\n\nWe said logically, because the second way is less efficient!\n\nIf you are familiar with the timeit possibility of ipython, you can measure the time used for the two alternatives:\n\nWrite a function dict_merge_sum that takes two dictionaries and as parameters. The values of both dictionaries are numerical. The function should return the merged sum dictionary of those dictionaries. If a key is both in and , the corresponding values will be added and included in the dictionary If is only contained in one of the dictionaries, the and the corresponding value will be included in\n\nGiven is the following simplified data of a supermarket:\n\nTo be ready for an imminent crisis you decide to buy everything. This isn't particularly social behavior, but for the sake of the task, let's imagine it. The question is how much will you have to pay?\n• Create a virtual supermarket. For every article there is a price per article and a quantity, i.e. the stock. (Hint: you can use the one from the previous exercise!)\n• Create shopping lists for customers. The shopping lists contain articles plus the quantity.\n• The customers fill their carts, one after the other. Check if enough goods are available! Create a receipt for each customer.\n\nGiven is the island of Vannoth\n\nCreate a dictionary, where we get for every city of Vannoth the distance to the capital city of Rogeburgh\n\nCreate a dictionary where you can get the distance between two arbitrary cities\n\nA salesperson takes the following route: Port Carol to Rogerburgh to Smithstad to Scottshire to Clarkhaven to Dixonshire to Port Carol. How many kilometres did the salesperson drive?\n\nTo solve this dictionary exercise it will be optimal, if you are familiar with 'for' or while loops in Python. We recommend to work through the corresponding chapters in our python course.\n\nWrite Pyhton code to create a dictionary with the city names as keys and the corresponding areas and population numbers as values.\n\nTo solve this exercise you have to be familiar with functions in Python, see our introduction on functions in our python course.\n\nCreate a Python program to manage a student gradebook using nested dictionaries. Follow these steps to implement the functionality:\n• Initialize an empty dictionary to serve as the gradebook.\n• Implement a function that takes the gradebook dictionary and a student name as input and adds an empty dictionary for the student's grades to the gradebook.\n• Implement a function that takes the gradebook dictionary, a student name, a subject name, and a grade as input. This function should add the grade for the specified subject to the grades dictionary of the specified student in the gradebook.\n• Implement a function that takes the gradebook dictionary and a student name as input and calculates the average grade for the specified student.\n• Implement a function that takes the gradebook dictionary as input and displays the contents of the gradebook, including student names, subjects, and grades, as well as the average grade for each student.\n\nUse the provided sample usage to demonstrate the functionality of your program.\n\nNote: You may assume that each student will have unique names, and subjects may have duplicate names but within the context of different students.\n\nAn example dictionary may look like this:\n\nSample usage looks like this:\n\nWe offer two solutions to this exercise:\n\nThe first one is only using things you will have learned, if you followed our Python course sequentially. The second solution uses techniques which will be covered later in our tutorial.\n\nAlternative solution to exercise 3, in which we create the chopping lists randomly:\n\n1 The city of Constance, also known as Konstanz in German, holds historical significance as it was the site of the Council of Constance from 1414 to 1418. This council played a crucial role in resolving the Papal Schism, which involved multiple claimants to the papacy. Additionally, Constance is located at the western end of Lake Constance (Bodensee), where Germany, Switzerland, and Austria meet, making it a picturesque and culturally rich destination.\n\n2 If you would like to learn more about how iterators work and how to use them, we recommend that you go through our Iterators and Generators chapter."
    }
]