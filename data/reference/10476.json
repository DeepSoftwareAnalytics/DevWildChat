[
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html",
        "document": "A sequence of elements supporting sequential and parallel aggregate operations. The following example illustrates an aggregate operation using and In this example,is a. We create a stream ofobjects via , filter it to produce a stream containing only the red widgets, and then transform it into a stream ofvalues representing the weight of each red widget. Then this stream is summed to produce a total weight.\n\nIn addition to , which is a stream of object references, there are primitive specializations for , , and , all of which are referred to as \"streams\" and conform to the characteristics and restrictions described here.\n\nTo perform a computation, stream operations are composed into a stream pipeline. A stream pipeline consists of a source (which might be an array, a collection, a generator function, an I/O channel, etc), zero or more intermediate operations (which transform a stream into another stream, such as ), and a terminal operation (which produces a result or side-effect, such as or ). Streams are lazy; computation on the source data is only performed when the terminal operation is initiated, and source elements are consumed only as needed.\n\nCollections and streams, while bearing some superficial similarities, have different goals. Collections are primarily concerned with the efficient management of, and access to, their elements. By contrast, streams do not provide a means to directly access or manipulate their elements, and are instead concerned with declaratively describing their source and the computational operations which will be performed in aggregate on that source. However, if the provided stream operations do not offer the desired functionality, the and operations can be used to perform a controlled traversal.\n\nA stream pipeline, like the \"widgets\" example above, can be viewed as a query on the stream source. Unless the source was explicitly designed for concurrent modification (such as a ), unpredictable or erroneous behavior may result from modifying the stream source while it is being queried.\n\nMost stream operations accept parameters that describe user-specified behavior, such as the lambda expression passed to in the example above. To preserve correct behavior, these behavioral parameters:\n• must be non-interfering (they do not modify the stream source); and\n• in most cases must be stateless (their result should not depend on any state that might change during execution of the stream pipeline).\n\nSuch parameters are always instances of a functional interface such as , and are often lambda expressions or method references. Unless otherwise specified these parameters must be non-null.\n\nA stream should be operated on (invoking an intermediate or terminal stream operation) only once. This rules out, for example, \"forked\" streams, where the same source feeds two or more pipelines, or multiple traversals of the same stream. A stream implementation may throw if it detects that the stream is being reused. However, since some stream operations may return their receiver rather than a new stream object, it may not be possible to detect reuse in all cases.\n\nStreams have a method and implement , but nearly all stream instances do not actually need to be closed after use. Generally, only streams whose source is an IO channel (such as those returned by ) will require closing. Most streams are backed by collections, arrays, or generating functions, which require no special resource management. (If a stream does require closing, it can be declared as a resource in a -with-resources statement.)\n\nStream pipelines may execute either sequentially or in parallel. This execution mode is a property of the stream. Streams are created with an initial choice of sequential or parallel execution. (For example, creates a sequential stream, and creates a parallel one.) This choice of execution mode may be modified by the or methods, and may be queried with the method."
    },
    {
        "link": "https://stackoverflow.com/questions/71888924/how-to-filter-element-from-a-list-using-java-8-streams",
        "document": "You are getting an empty list because operation will retain in the stream only elements that match the given predicate.\n\nSince all values that have in the source list are present in the list predicate always returns .\n\nIf you want to retain only elements that exist in the list, change your predicate to:\n\nTo reduce time complexity of checks, you might also make to be .\n\nIf you want to do the opposite check - find a list of available s ( s from list that are not present in the ) you can do it like this:\n\nAnd if that is what you're trying to achieve, my suggestion is to improve the code above by generating a - person by id based on the list. And check whether the is not present in the map instead of iterating over the whole list."
    },
    {
        "link": "https://stackoverflow.com/questions/51464116/filter-and-collect-nested-collection-elements-using-java-8-stream",
        "document": "I have a collection of objects and each has a collection of elements, for example:\n\nHow would I use Java 8 functional programming to filter and collect together a collection of where the type is equal to 'A'?\n\nI have attempted this with the following:\n\nBut I get the following error:\n\nVariable 'filteredChildren' initializer 'parents.stream() .forEach(p -> ...' is redundant less... (⌘F1) This inspection points out the cases where a variable value is never used after its assignment, i.e.: - the variable never gets read after assignment OR - the value is always overwritten with another assignment before the next variable read OR - the variable initializer is redundant (for one of the above two reasons)\n\nHow do I filter the nested collections by type and collect them?"
    },
    {
        "link": "https://labex.io/tutorials/java-how-to-filter-a-collection-using-stream-api-in-java-415586",
        "document": "Filtering is one of the most common operations performed on collections using the Java Stream API. Filtering allows you to select a subset of elements from a collection based on a given predicate.\n\nThe method is used to apply a filter to a stream. This method takes a lambda expression or a method reference as an argument, which represents the filtering condition.\n\nIn the example above, we create a stream from a list of names and then use the method to select only the names that start with the letter \"J\".\n\nYou can chain multiple calls to apply multiple filtering conditions to a stream.\n\nIn this example, we first filter the numbers to select only the even numbers, and then we apply a second filter to select only the even numbers greater than 5.\n\nFiltering can be combined with other stream operations, such as mapping, sorting, and reducing, to create more complex data transformations.\n\nIn this example, we first filter the list of objects to select only the young adults (between 18 and 30 years old), then we map the property of each object, and finally we collect the results into a new list.\n\nBy understanding the power of filtering with the Java Stream API, you can effectively manipulate and process your collections of data. In the next section, we'll explore more practical examples of applying filters."
    },
    {
        "link": "https://geeksforgeeks.org/stream-in-java",
        "document": "Introduced in Java 8, Stream API is used to process collections of objects. A stream in Java is a sequence of objects that supports various methods that can be pipelined to produce the desired result.\n\nUse of Stream in Java:\n\nJava Stream Creation is one of the most basic steps before considering the functionalities of the Java Stream. Below is the syntax given for declaring Java Stream.\n\nHere T is either a class, object, or data type depending upon the declaration.\n\nThe features of Java stream are mentioned below:\n• None A stream is not a data structure instead it takes input from the Collections, Arrays or I/O channels.\n• None Streams don’t change the original data structure, they only provide the result as per the pipelined methods.\n• None Each intermediate operation is lazily executed and returns a stream as a result, hence various intermediate operations can be pipelined. Terminal operations mark the end of the stream and return the result.\n\nThere are two types of Operations in Streams:\n\nIntermediate Operations are the types of operations in which multiple methods are chained in a row.\n• None It enables the concept of filtering where one method filters data and passes it to another method after processing.\n\nThere are some benefits because of which we use Stream in Java as mentioned below:\n• None Can be created from collections, arrays, Files Lines, Methods in Stream, IntStream etc.\n\nThere are a few Intermediate Operations mentioned below:\n\nThe map method is used to return a stream consisting of the results of applying the given function to the elements of this stream.\n\nThe filter method is used to select elements as per the Predicate passed as an argument.\n\nThe sorted method is used to sort the stream.\n\nThe flatMap operation in Java Streams is used to flatten a stream of collections into a single stream of elements.\n\n5. distinct ()\n\nRemoves duplicate elements. It returns a stream consisting of the distinct elements (according to Object.equals(Object)).\n\nPerforms an action on each element without modifying the stream. It returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream.\n\nJava program that demonstrates the use of all the intermediate operations\n\nExplanation of the above Program:\n• None is created as a list containing other lists of strings.\n• : Flattens the nested lists into a single stream of strings.\n• : Filters the strings to only include those that start with “S”.\n• : Converts each string in the stream to uppercase.\n• : Adds each processed element to the\n\nThe program prints the intermediate results stored in the set. Finally, it prints the list, which contains the fully processed strings after all stream operations.\n\nThis example showcases how Java Streams can be used to process and manipulate collections of data in a functional and declarative manner, applying transformations and filters in a sequence of operations.\n\nTerminal Operations are the type of Operations that return the result. These Operations are not processed further just return a final result value.\n\nThere are a few Terminal Operations mentioned below:\n\nThe collect method is used to return the result of the intermediate operations performed on the stream.\n\nThe forEach method is used to iterate through every element of the stream.\n\nThe reduce method is used to reduce the elements of a stream to a single value. The reduce method takes a BinaryOperator as a parameter.\n\n4. count()\n\nReturns the count of elements in the stream.\n\nReturns the first element of the stream, if present.\n\n6. allMatch()\n\nChecks if all elements of the stream match a given predicate.\n\nChecks if any element of the stream matches a given predicate.\n\nHere ans variable is assigned 0 as the initial value and i is added to it.\n\nExplanation of the above Program:\n• : Prints each name in the list.\n• : Filters names starting with ‘S’ and collects them into a new list.\n• : Finds and prints the first name in the list.\n• : Checks if all names start with ‘S’.\n• : Checks if any name starts with ‘S’.\n\nThe program prints each name, names starting with ‘S’, concatenated names, the count of names, the first name, whether all names start with ‘S’, and whether any name starts with ‘S’.\n• None A stream consists of a source followed by zero or more intermediate methods combined together (pipelined) and a terminal method to process the objects obtained from the source as per the methods described.\n• None Stream is used to compute elements as per the pipelined methods without altering the original value of the object."
    },
    {
        "link": "https://stackoverflow.com/questions/31881561/how-to-average-bigdecimals-using-streams",
        "document": "I didn't want to count the size of my stream. Then, I developed the following using accumulator and combiner.\n\nand, here is the code for the identity class;\n\nIt is up to you how to round the divided value though (I use RoundingMode.HALF_UP for my case).\n\nThe above is similar to the way explained in https://stackoverflow.com/a/23661052/1572286"
    },
    {
        "link": "https://stackoverflow.com/questions/54278847/averaging-bigdecimals-using-streams-api-collectors",
        "document": "Take a look at how or is implemented.\n\nEssentially, you need a mutable accumulation type that would hold a which is a sum of product prices, and an which is a number of products processed. Having that, the problem boils down to writing a simple .\n\nI simplified an example and removed getters/setters and an all-args constructor. Instead of a nested class , you might use any mutable holder class for 2 elements."
    },
    {
        "link": "https://baeldung.com/java-stream-add-bigdecimals",
        "document": "We usually use the Java Stream API for processing collections of data.\n\nOne nice feature is support for operations on numeric streams, like the sum operation. However, we cannot process all numeric types in this way.\n\nIn this tutorial, we’ll see how to perform the sum operation on streams of numbers like BigDecimal.\n\n2. How We Usually Sum a Stream\n\nThe Stream API provides streams of numbers, including IntStream, DoubleStream, and LongStream.\n\nLet’s remind ourselves how these work by creating a numeric stream. Then, we’ll calculate its total with IntStream#sum:\n\nWe can do a similar thing starting with a list of Doubles. By using streams, we can convert from an object stream to a DoubleStream using mapToDouble:\n\nSo, it would be useful if we could sum up a collection of BigDecimal numbers the same way.\n\nUnfortunately, there isn’t a BigDecimalStream. So, we need another solution.\n\nInstead of relying on sum, we can use Stream.reduce:\n\nThis works on anything that can be logically added together, including BigDecimal:\n• Identity – is the equivalent of 0 – it is the starting value for the reduction\n• Accumulator function – takes two parameters, the result so far, and the next element of the stream\n\nIn this article, we looked at how to find the sum of some numbers in a numeric Stream. Then we discovered how to use reduce as an alternative.\n\nUsing reduce allows us to sum a collection of BigDecimal numbers. It can be applied to any other type."
    },
    {
        "link": "https://dzone.com/articles/grouping-and-aggregations-with-java-streams",
        "document": "When we group elements from a list, we can subsequently aggregate the fields of the grouped elements to perform meaningful operations that help us analyze the data. Some examples are addition, averages, or max/min values. These aggregations of single fields can be easily done with Java Streams and Collectors. The documentation provides simple examples of how to do these types of calculations.\n\nHowever, there are more sophisticated aggregations like weighted averages, geometric means. Additionally, there might be the need to do simultaneous aggregations of several fields. In this article, we are going to show a straightforward path to solve these kinds of problems using Java Streams. Using this framework allows us to process large amounts of data quickly and efficiently.\n\nWe'll assume that the reader has a basic understanding of Java Streams and the utility Collectors class.\n\n*Affiliate link. See Terms of Use.\n\nLet's consider a simple example to showcase the type of issues that we want to solve. We'll make it very generic so we can easily generalize it. Let's consider a list of entities that it's defined by the following code:\n\nIt is very simple to compute the total number of entries for a given city:\n\ntakes two parameters: a classifier function to do the grouping and a Collector that does the downstream aggregation for all the elements that belong to a given group. We use as the classifier function. For the downstream, we use which returns a that sums the number of tax entries that we get for each grouped element.\n\nThings are a little more complicated if we try to find compound groupings. For example, with the previous example, the total number of entries for a given state and city. There are several ways to do this, but a very straightforward approach is first to define:\n\nNotice that we’re using a Java , which is a concise way to define an immutable class. Furthermore, the Java compiler generates for us field accessor methods, , equals, and implementations. With this in hand, the solution now is simple:\n\nFor we set the classifier function using a lambda expression that creates a new record that encapsulates each state-city. The downstream Collector is the same as before.\n\nNote: for the sake of conciseness, in the code samples, we are going to assume static imports for all the methods of the Collectors class, so we don't have to show their class qualification.\n\nWhere things start to get more complicated is if we want to do several aggregations simultaneously. For example, find the sum of the number of entries and the average price for a given state and city. The library does not provide a simple solution to this problem.\n\nTo begin untangling this issue, we take a cue from the previous aggregation and define a record that encapsulates all the fields that need to be aggregated:\n\nNow, how do we do the aggregation simultaneously for the two fields? There is always the possibility of doing the stream collection twice to find each of the aggregations separately, as it's suggested in the following code:\n\nThe grouping is done as before, but for the downstream, we do the aggregation using (line 3). This function takes two parameters:\n• The download stream from the initial grouping that we convert into a list (using in line 3)\n• Finisher function (lines 4–9) where we use a lambda expression to create two different streams from the previous list to do the aggregations and return them combined in a new record\n\nImagine that we wanted to do more field aggregations simultaneously. We will need to increase accordingly the number of streams from the downstream list. The code becomes, inefficient, very repetitive, and less than desirable. We should look for better alternatives.\n\nAlso, the problems don’t end here, and in general, we're constrained on the types of aggregations that we can do with the Collectors helper class. Their methods, summing*, averaging*, and summarizing*, provide support only for integer, long, and double native types. What do we do if we have more sophisticated types like or ?\n\nTo add insult to injury the summarizing* methods only provide summary statistics for, min, max, count, sum, and average. What if we want to perform more sophisticated calculations such as weighted averages or geometric means?\n\nSome people will argue that we can always write custom Collectors, but this requires knowing the Collector interface and a good understanding of the stream collector flow. It’s more straightforward to use built-in collectors provided with the utility methods in the Collectors class. In the next section, we’ll show a couple of strategies on how to accomplish this.\n\nLet’s consider a simple example that will highlight the challenges that we have mentioned in the previous section. Suppose that we have the following entity:\n\nWe start by asking how for each distinct state-city pair, we can find the total count of entries and the total sum of the product of and (∑(rate * price)). Notice that we are doing a multifield aggregation using .\n\nAs we did in the previous section, we define a class that encapsulates the aggregation:\n\nIt might seem surprising at first, but a straightforward solution to groupings that are followed by simple aggregations is to use . Let’s see how we would do it:\n\nThe (line 2) takes three parameters, we do the following implementation:\n• The first parameter is a lambda expression to generate the keys of the map. This function creates as keys to the map. This will group the elements by state and city (line 2).\n• The second parameter produces the values of the map. In our case, we create a initialized with a count of 1 and the product of rate and price (line 3).\n• Finally, the last parameter is a to merge cases where multiple elements map to the same state-city key. We sum the counts and prices to do our aggregation (line 4).\n\nLet’s demonstrate how this will work setting up some sample data:\n\nTo get the results for New York from the previous code sample is trivial:\n\nThis is a straightforward implementation that determines the grouping and aggregation of multiple fields and non-primitive data types ( in our case). However, it has the drawback that it does not have any finalizers that allow you to perform extra operations. For example, you can’t do averages of any kind.\n\nTo showcase this issue, let’s consider a more complex problem. Suppose that we want to find the weighted average of the rate-price, and the sum of all the prices for each state and city pair. In particular, to find the weighted average, we need to calculate the sum of the product of the rate and price for all the entries that belong to each state-city pair, and then divide by the total number of entries n for each case: 1/n ∑(rate * price).\n\nTo tackle this problem we start defining a record that comprises the aggregation:\n\nWith this in hand, we can do the following implementation:\n\nWe can see that the code is somewhat more complicated, but allows us to get the solution we are looking for. We'll follow it more in detail:\n• (line 2):\n• For the classification function, we create a record\n• For the downstream, we invoke (line 3):\n• For the first parameter, the mapper that we apply to the input elements transforms the grouped state-city tax records to new entries that assign the initial count to 1, multiply the rate with price, and set the price (line 3).\n• For the downstream, we invoke (line 4), and as we’ll see, this will allow us to apply to the downstream collector a finishing transformation.\n• Invoke (line 4)\n• Create a default to cover the cases where there are no downstream elements (line 4).\n• Lambda expression to do the reduction and return a new that has the aggregations of the fields (line 5, 6 7)\n• Perform the finishing transformation calculating the averages using the count calculated in the previous reduction and returning the final (lines 9, 10, 11).\n\nWe see that this implementation not only allows us to do multiple field aggregations simultaneously but can also perform complex calculations in several stages.\n\nThis can be easily generalized to solve more complex problems. The path is straightforward: define a record that encapsulates all the fields that need to be aggregated, use to initialize the records, and then apply to do the reduction and final aggregation.\n\nAs before we can get the aggregations for New York:\n\nWe get the results:\n\nIt is also worth pointing out that because is a Java , it’s immutable, so the calculation can be parallelized using the support provided by the stream collector’s library.\n\nWe have shown a couple of strategies to do complex multi-field groupings with aggregations that include non-primitive data types with multi and cross-field calculations. This is for a list of records using Java streams and the Collectors API, so it provides us the ability to process huge amounts of data quickly and efficiently."
    },
    {
        "link": "https://mkyong.com/java8/java-8-how-to-sum-bigdecimal-using-stream",
        "document": "In Java 8, we can use the to sum a list of .\n\nJava example to sum a list of values, using a normal for loop and a .\n\nSum all from a list of .\n• How to calculate monetary values in Java"
    }
]