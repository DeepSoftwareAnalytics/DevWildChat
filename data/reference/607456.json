[
    {
        "link": "https://geeksforgeeks.org/number-substrings-divisible-6-string-integers",
        "document": ""
    },
    {
        "link": "https://algo.monster/liteproblems/2950",
        "document": "In this problem, we have a string composed of lowercase English letters. Each letter is mapped to a digit according to a given keyboard layout that resembles an old phone keypad. Under this mapping, certain groups of letters correspond to the digits from 1 to 9. To determine if a substring of is \"divisible\", we sum the mapped values of all its characters, and if this sum is divisible by the length of the substring, then the substring is considered divisible. Our task is to find the total count of these divisible substrings in the string . Remember, substrings are contiguous sequences of characters, and they must be non-empty. For example, if , and the mapping is , then \"abc\" (summing to 6) is a divisible substring since 6 (the sum of its mapped values) is divisible by 3 (the length of the substring). To solve this problem, we can use a brute force approach, which involves enumerating over every possible substring, calculating the sum of the numeric values of its characters according to the given mapping, and checking if this sum is divisible by the substring's length. Here's a step-by-step breakdown of the intuition behind this approach:\n• Create a mapping from characters to digits based on the provided image or keyboard layout. This will be our reference to convert characters to their corresponding numerical values.\n• Iterate over all possible starting indices of substrings in the string .\n• For each starting index, iterate over all possible ending indices that follow it to generate every possible substring starting from that index.\n• For each substring, calculate the sum of its character's numerical values.\n• Check if the sum is divisible by the length of the substring. If it is, we've found a divisible substring, and we increment our counter. This enumeration algorithm ensures we do not miss any possible substrings while systematically checking each one. While this is not the most efficient method, given the problem's constraints, it is an approach that is easy to understand and implement.\n\nThe implementation of the solution is straightforward once the brute force approach has been understood. The solution uses a couple of basic concepts in Python: loops and hash tables (dictionaries).\n• Hash Table for Character to Number Mapping: We use a dictionary to map each character to its corresponding number. The mapping is taken from an image that displays characters on an old phone keypad layout.\n• Nested Loops to Enumerate Substrings: Two nested loops are utilized to consider every possible substring of the given string . The outer loop sets the starting index of the substring, while the inner loop sets the ending index.\n• Sum of Mapped Characters: Inside the inner loop, as we extend our substring one character at a time, we keep adding the mapped numerical value of the recently included character to a running sum .\n• Checking for Divisibility: After including each character, we check if the current sum is divisible by the length of the current substring, which is (as is the starting index and is the ending index).\n• Incrementing the Count: Each time we find that the sum is divisible by the substring's length, we increment by 1.\n• Returning the Result: After all substrings have been considered, contains the total count of divisible substrings, which is then returned. The algorithm's time complexity is O(n^2) in the worst case, where n is the length of string . This is due to the fact that we are checking every substring possible. The space complexity is O(1) or O(n) depending on whether we consider the space taken by the hash table which has a fixed size (there are 26 lowercase English letters). Here is the key portion of the solution code, which represents the described logic: mp = {} mp[c] = i s += mp[word[j]] # Check if sum is divisible by the length of the substring The implementation exploits the elegance of Python's dictionaries for fast look-ups of character mappings and the efficiency of for-loops for checking each substring.\n\nLet's go through a small example using the string , with the mapping . According to this mapping, the numeric values for each character are their respective positions in the English alphabet. We aim to enumerate all substrings of and determine which ones are divisible. Let's visualize the process of iterating over substrings and checking their divisibility:\n• We start with the outer loop at (character 'a').\n• The inner loop starts at .\n• For the first iteration, and , the substring is \"a\" with a sum of . Since is , \"a\" is a divisible substring.\n• Next, and , the substring is \"ab\". The sum is . Since is not , \"ab\" is not divisible.\n• Continuing this, and , the substring is \"abc\" with sum . Since is , \"abc\" is divisible.\n• We repeat this process, incrementing and to explore all substrings. Now for a visualization of the nested loops in action: From this, we can count that the divisible substrings are: \"a\", \"abc\", \"b\", \"c\", \"cde\", \"d\", \"e\". There are a total of 7. In our Python implementation, we would follow these steps:\n• Use nested loops to extract all substrings.\n• Calculate the sum of the numerical values of characters in the current substring.\n• Check if this sum is divisible by the length of this substring; if so, increment the count ( ).\n• After considering all substrings, will represent the total count of divisible substrings.\n\n# Define substrings where each character maps to a number (1-9) # Dictionary to map characters to their respective numbers # Variable to keep track of divisible substrings count # Iterate over the word to check each possible substring # Sum of numbers corresponding to characters in the current substring # Add the number corresponding to current character # Increase the count if the sum is divisible by the length of the substring // Mapping for characters to their respective group values // Initialize the mapping for each character to its group value } } // Iterate over all possible starting points of substrings // 'sum' will hold the sum of the group values for the current substring // Iterate over all possible ending points of substrings // Add group value of the current character to 'sum' // Increment the count if sum is divisible by the length of the substring } } } } // An array to hold strings that represent the respective remainders // Array to map characters to their divisor group number // Populate the mappings array with corresponding group numbers } } // Variable to keep the count of divisible substrings // The length of the input word // Iterate over all starting positions of the substrings in the word // To keep the sum of divisor group numbers // Iterate over all possible ending positions of the substring // Increment the sum with the mapping of the current character // Check if the sum is divisible by the length of the substring // If it is, increment the count } } } }; // Function to count the number of substrings where the sum of the mapped values of letters is divisible // by the length of the substring // Define an array that represents the groups of letters, each group has the same weight // Initialize a mapping array with 26 elements set to 0 to store the weight of each letter // Populate the letterWeights with the corresponding group index + 1 (as weights) } } // Get the length of the word // Check all substrings starting from each character in the word // Initialize the sum of letter weights for the current substring // Iterate over the substring from the current startIndex // Add the corresponding letter weight to the sum // If the sum is divisible by the substring length, increase the count count++; } } } }\n\nThe time complexity of the given code is . This is because there are two nested loops. The outer loop runs for iterations ( being the length of the word), and for each iteration of the outer loop, the inner loop runs for at most iterations - starting from the current index of the outer loop to the end of the word. During each iteration of the inner loop, a constant number of operations are executed. So, for each element, we potentially loop through every other element to the right of it, leading to the term, which simplifies to . The space complexity of the code is where is the size of the character set. In this case, as there are 26 lowercase English letters. The space is used to store the mapping of each character to its associated integer, which in this instance does not change with the size of the input string and is hence constant. Learn more about how to find time and space complexity quickly using problem constraints.\n\nDiscover Your Strengths and Weaknesses: Take Our 2-Minute Quiz to Tailor Your Study Plan:\n\nWant a Structured Path to Master System Design Too? Don’t Miss This!"
    },
    {
        "link": "https://leetcode.com/problems/count-substrings-divisible-by-last-digit",
        "document": ""
    },
    {
        "link": "https://liverungrow.medium.com/recursion-and-dynamic-programming-4ddd262b7ca1",
        "document": "Dynamic programming is mostly just a matter of taking a recursive algorithm and finding the overlapping subproblems. You then cache the results for future recursive calls.\n\nThere are generally 2 approaches to such questions\n\nLooking at the tree above, you see that fib(3) appears twice etc…so we should do caching to save on amount of work done.\n• Bottom-Up Approach -> Solve the problem for a simple case, then build up the solution.\n\nThis can be thought of as similar to doing the recursive memoized approach but in reverse.\n\nFirst, we compute fib(1) and fib(0), which are already known from the base cases. Then we use those to compute fib(2). Then we use the prior answers to compute fib(3), then fib(4) and so on.\n\nFor Fibonacci qns, during interviews they like to ask you about the time complexity. The ans is O(2^n).\n\nThe best solution is to use iteration so you can deal with large numbers\n\nHow to determine when to give a dynamic programming solution?\n• When the problem is recursive and can be built off subproblems.\n• “Design an algorithm to compute the nth…” “Write code to list the first nth…” “Implement a method to compute all..”\n\nYou are given balloons, indexed from to . Each balloon is painted with a number on it represented by an array . You are asked to burst all the balloons.\n\nIf you burst the balloon, you will get coins. If or goes out of bounds of the array, then treat it as if there is a balloon with a painted on it.\n\nReturn the maximum coins you can collect by bursting the balloons wisely.\n\nThis problem seems like the order of solving sub prob changes the ans. The subproblems are not independent of each other. i=start and j=end.\n\nInstead of thinking, which k balloon to burst first we think of it in the other way round.\n\nWe choose the kth balloon as the last one to be burst. Now the subproblems will become independent since (k — 1)th balloon and (k + 1)th balloon won’t need each other in order to calculate the answer. (Try it out using pen and paper).\n\nNow for each k starting from i to j, we choose the kth balloon to be the last one to be burst and calculate the profit by solving the subproblems recursively. Whichever choice of k gives us the best answer, we store it and return.\n\nImportant point to be noted here is that the balloons in the range (i, k — 1) and (k + 1, j) will be burst BEFORE kth balloon. So, when we burst the kth balloon, the profit will be nums[i — 1] * nums[k] * nums[j + 1] PROVIDED that index i — 1 and j + 1 are valid.\n\nQns 1 a: Write a recursive method for generating all permutations of an input string. Return them as a set.\n\nDefinition of permutation: Any ordering of words. For eg, “cat” has the following permutation:\n\nIf we want to form the permutation of cats, and we have all the permutations of cat, then what we need to do is to put “s” in each possible position in each of these permutations.\n\nNow that we can break the problem into subproblem, we just need a base case and we have a recursive algorithm.\n\nQns 1 b: Given a collection of distinct integers, return all possible permutations.\n\nThe trick to understanding the code here is very simple: Simply write out and follow through the code with a simple example, for eg [1,2,3]\n• We first traverse to the end of the int array. Return the last element of the num array as a list. For eg, if last element is 3, we return [[3]]\n• Then, the caller function will receive this returned list.\n• At the caller function, the second last element -> The element before -> will be stored in a variable called firstChar. This firstChar will then be inserted in all possible positions of the returned list. For eg, here, firstChar=2. So after going through line 24–34, the output finalised list will be [[2,3],[3,2]]\n• Again, this list will be returned to the previous caller function. Repeating 3, we then get\n\nThis gives us all the permutations :)\n• Might be better to use HashSet instead of List because List can have duplicates.\n\nLeet Code 47 Permutations II (same as above)\n\nGiven a collection of numbers, , that might contain duplicates, return all possible unique permutations in any order.\n\nBrute Force: To generate all possible permutations like Qns 1a, 1b. Then check the validity of each permutation and discard those invalid ones.\n\nMore efficient solution: Think of it as trying out every permutation of the string, deciding whether to add an open-bracket or close-bracket to a string.\n• The first char of the string must always be a (, hence i start by initialising the base string to only contain (.\n• If the number of ( is smaller than the number of ), only then we can add )\n• We can always add ( as long as there are (\n\nFor this, we notice that we cannot really return the ArrayList<String> of all possible permutations because we want to have a complete string each time we return something (unlike previous 1a,1b questions where we will create the new permutation based on the returned permutations). So i created a public static ArrayList instead and we will append all possible combinations to this.\n\nQns 2: Write a method fib() that takes an integer n and returns the nth Fibonacci number.\n\nQns 3: Your quirky boss collects rare, old coins… (Also Leet Code 322)\n\nYou are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return .\n\nYou may assume that you have an infinite number of each kind of coin.\n\nYou are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.\n\nGiven an array of distinct integers and a target integer , return a list of all unique combinations of where the chosen numbers sum to . You may return the combinations in any order.\n\nThe same number may be chosen from an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n\nIt is guaranteed that the number of unique combinations that sum up to is less than combinations for the given input.\n\nGiven a collection of candidate numbers ( ) and a target number ( ), find all unique combinations in where the candidate numbers sum to .\n\nEach number in may only be used once in the combination.\n\nNote: The solution set must not contain duplicate combinations.\n\nLine 52 skips duplicates because consider when we are at recursion R1. For eg, if we have [1,1,2] where the start is at index 0, the first 1, we skip evaluating the second 1 at line 52. This second 1 will then be evaluated in the next recursion R2 where start=1. Here, tempList will then contain [1,1] where 1 comes from the first index 0 and the second 1 comes from the second index 1.\n\nIf we did not skip (do not have line 52), then it could be that at R2, the tempList would be [1,1], where both 1s comes from the same second index of the original int[] cand. For example, we add in the first 1 (in index 1, second 1) was added in R1 and the second 1 (index 1) was repeatedly added in R2.\n\nFind all valid combinations of numbers that sum up to such that the following conditions are true:\n• Only numbers through are used.\n• Each number is used at most once.\n\nReturn a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.\n\nVisualise this problem to be like BFS traversal. From the number n, we want to find the next smaller value and traverse until we reach 0. It’s similar to another leetcode qns 279.\n\nGiven a positive integer n, find the least number of perfect square numbers (for example, ) which sum to n.\n\nThis question is similar to Coin Change…\n\nTime complexity: because in the worst case we can search level in depth (worst case the perfect squares are made up all by s) from and the tree can thus contains up to nodes ( ).\n\nSpace complexity: because of the queue used to store each level we are iterating through.\n\nQns 4: You are a renowned thief who has recently switched from stealing precious metals to stealing cakes because of the insane profit margins. You end up hitting the jackpot, breaking into the world’s largest privately owned stock of cakes — the vault of the Queen of England.\n\nWhile Queen Elizabeth has a limited number of types of cake, she has an unlimited supply of each type.\n\nEach type of cake has a weight and a value, stored in objects of a CakeType class:\n\nEach type of cake has a weight and a value, stored in objects of a CakeType class:\n\nYou brought a duffel bag that can hold limited weight, and you want to make off with the most valuable haul possible.\n\nWrite a method maxDuffelBagValue() that takes an array of cake type objects and a weight capacity, and returns the maximum monetary value the duffel bag can hold. Weights and values may be any non-negative integer.\n\nQns 1: Leet code 70 Climbing stairs. You are climbing a stair case. It takes n steps to reach to the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\nNote: Given n will be a positive integer.\n\nQns 2: Robots in a grid: A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).\n\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).\n\nHow many possible unique paths are there?\n\nOn a 2-dimensional , there are 4 types of squares:\n• represents the starting square. There is exactly one starting square.\n• represents the ending square. There is exactly one ending square.\n• represents empty squares we can walk over.\n• represents obstacles that we cannot walk over.\n\nReturn the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.\n\nQns 2: Power Set -> Write a set to return all possible subset (Leet Code 78)\n\nNote that the solution below is wrong. In the solution below, List<> seems to be shared across different recursion functions. Even though in line 26, i appear to be modifying just duplicate list but i am actually modifying the original list. This is because, previously in line 21, i am adding the d from list. d is referring to the original list and we are directly modifying it.\n• Add yourself to all existing lists\n\nIf nums contains non distinct integers, can have duplicates.\n\nQns 3: Longest Increasing subsequence -> Can be non contiguous\n\nHow can we have a O(nlogn) solution?\n• Let’s construct the idea from following example.\n• Consider the example , let's try to build the increasing subsequences starting with an empty one: .\n• Let pick the first element, .\n• is less than previous number, we can't extend the subsequence , but we must keep because in the future there may have the longest subsequence start with , .\n• With , we can't extend , but we can extend , so .\n• With , we can't extend , but we can extend , so .\n• With , we can extend neither nor , but we need to keep , so .\n• In the above steps, we need to keep different arrays ( , ..., ) which causes poor performance. But we notice that we can just keep one array, when new number is not greater than the last element of the subsequence , we do binary search to find the smallest element >= in , and replace with number .\n• Let’s run that example again:\n• Let pick the first element, .\n• is less than previous number, so we can't extend the subsequence . We need to find the smallest number >= in , it's . Then we overwrite it, now .\n• is less than previous number, so we can't extend the subsequence . We overwrite by , so .\n• is less than previous number, so we can't extend the subsequence . We overwrite by , so .\n\nGiven an integer array , return the number of longest increasing subsequences.\n\nNotice that the sequence has to be strictly increasing.\n\nNeed to make sure that the two if statements are not swapped. This is because if we swapped them both, then the program will enter both if loops.\n\nGiven a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.\n\nNote: You can only move either down or right at any point in time.\n\nGiven an array of integers, we need to find the maximum possible sum of elements of the array such that it is divisible by three.\n\nGiven a dictionary of words, each word has a positive score. Given a string, cut it to exactly K (K > 0) words and all of them must be found in the dictionary, and the word segmentation score is the sum of the K segmented word’s scores.\n\nReturn the max words segmentation score. If it is impossible, return -1.\n\nGiven a string and a dictionary of strings , return if can be segmented into a space-separated sequence of one or more dictionary words.\n\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\n\nGiven a string and a dictionary of strings , add spaces in to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.\n\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\n\nWe have two integer sequences and of the same non-zero length.\n\nWe are allowed to swap elements and . Note that both elements are in the same index position in their respective sequences.\n\nAt the end of some number of swaps, and are both strictly increasing. (A sequence is strictly increasing if and only if .)\n\nGiven A and B, return the minimum number of swaps to make both sequences strictly increasing. It is guaranteed that the given input always makes it possible.\n\nLine 17: Swap at i but don’t swap at i-1\n\nLine 18: Swap at i-1 but don’t swap at i.\n\nSet first element to be 0 and 1.\n\nAll other places could be initialised to value of length of A or B, in this case 4.\n\nNext, we look at {3,2}. We know that we can don’t perform any swap since 3 is already bigger than 1. Hence, the value at the second column of no swap remains as 0.\n\n0 is less than 1, so keep it.\n\n0+1=1 which is smaller than 2 -> Update value to be the lower value 1.\n\nGiven an binary filled with 's and 's, find the largest square containing only 's and return its area.\n\nHmmm hard to think that this is a dynamic programming question.\n\nAt every point, we just try to find out if the current point can be the top left corner of a square.\n• Space complexity : O(mn). Another matrix of same size is used for d.\n\nGiven n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.\n\nAbove is a histogram where width of each bar is 1, given height = .\n\nThe largest rectangle is shown in the shaded area, which has area = unit.\n\nWe see that at every height[i], we want to compute the max possible rectangle formed. We want to expand from index i the furthest we can to the left and right direction. The stopping condition for the expansion is when we arrive at a height which is smaller than current height[i].\n\nWith this in mind, we then make use of 2 arrays indexLeft and indexRight. indexLeft[i] contains the first index on the left which has height < height[i]. The above illustration explains how to get the width of the rectangle. r-l+1.\n\nGiven a binary filled with 's and 's, find the largest rectangle containing only 's and return its area.\n\nThis question is similar to the previous question.\n\nWe can visualise each row as a histogram of bars. First, for each row, we construct this histogram of bars. The heights of a bar (column) in the histogram is the sum of the numbers in the current row and above for that column. For eg, see the image below.\n\nThen, once we have a histogram for each rows constructed, we will then attempt to find the max rectangle for the histogram at each level. We apply the previous question technique to each row (1 histogram) and the final result would be the max rectangle formed from a histogram.\n\nGiven non-negative integers representing an elevation map where the width of each bar is , compute how much water it can trap after raining.\n\nThis is quite hard…everything about leetcode is hard :( …it took me around 2 hours (second time, months after my first try) to come up with this solution.\n\nThe idea is to compute the max left and max right and then minus existing height of the bar.\n\nThe n-queens puzzle is the problem of placing queens on an chessboard such that no two queens attack each other.\n\nGiven an integer , return all distinct solutions to the n-queens puzzle.\n\nEach solution contains a distinct board configuration of the n-queens’ placement, where and both indicate a queen and an empty space, respectively.\n\nWe know for sure that when we have reached colIndex == board.length, all the rows have been filled. This is due to the validate function which ensures that a recursion call will not be called on a board that adds Q to the same row repeatedly. We only make new recursion call when Q is added to the next row. Hence, when colIndex == board.length, we know that board.length number of rows has been filled.\n\nSee that if we want to know if we can place Q in position (1,1), we will need its’ diagonals to be empty. So, when we are in the i,j position we want to check if the difference in magnitude in x-y direction from this (1,1) position is the same. If it is the same, we know that the current position i,j is in a diagonal position.\n\nAn edit between two strings is one of the following changes.\n\nGiven two string s1 and s2, find if s1 can be converted to s2 with exactly one edit. Expected time complexity is O(m+n) where m and n are lengths of two strings.\n\nWe can classify into the different cases as seen in part 1 and then call the corresponding functions.\n\n72. Edit Distance (Different from above)\n\nInstead of just checking if they differ by 1 operation, now there can be >1 operations.\n\nGiven two strings and , return the minimum number of operations required to convert to .\n\nYou have the following three operations permitted on a word:\n\nHence, we use dynamic programming.\n\nGiven an integer matrix, find the length of the longest increasing path.\n\nFrom each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).\n\nGiven a list of airline tickets represented by pairs of departure and arrival airports , reconstruct the itinerary in order. All of the tickets belong to a man who departs from . Thus, the itinerary must begin with .\n• If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary has a smaller lexical order than .\n• All airports are represented by three capital letters (IATA code).\n• You may assume all tickets form at least one valid itinerary.\n• One must use all the tickets once and only once.\n\nWhenever each “Node” cannot be represented by a number, we use HashMap instead of an ArrayList.\n\nWe use Recursion here.\n\nHence, the best way is not to use Stack or Queue but to use Recursion. Using Stack or Queue does not enable us to discard nodes that were previously visited, but not supposed to be in the path.\n\nCheck out around 12 minute of this video\n\nRun through of the algorithm on an example:\n\nEach time you see a node, you will add it to the stack. When you find that you have reached a dead end, pop that single last element to the result list. Then, remove that element from the stack and continue.\n\nThen, go on to N and then J. At N->J ticket, we see we have finished. So we pop from the stack.\n\nThe answer is in reversed order.\n\nThe count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n• is the way you would \"say\" the digit string from , which is then converted into a different digit string.\n\nTo determine how you “say” a digit string, split it into the minimal number of groups so that each group is a contiguous section all of the same character. Then for each group, say the number of characters, then say the character. To convert the saying into a digit string, replace the counts with a number and concatenate every saying.\n\nFor example, the saying and conversion for digit string :\n\nGiven a positive integer , return the term of the count-and-say sequence.\n\nGiven an array of integers and a positive integer , find whether it's possible to divide this array into non-empty subsets whose sums are all equal.\n\nThe above solution exceeded the time limit. Use the one below instead."
    },
    {
        "link": "https://stackoverflow.com/questions/38697912/efficient-algorithm-for-finding-if-the-numbers-represented-by-substrings-of-a-ve",
        "document": "So this was a question on one of the challenges I came across in an online competition, a few days ago.\n• The number of questions Q to be asked.\n\nIn each of the question, you have to find if the number formed by the string between indices L and R is divisible by 7 or not.\n\nFirst line contains the number consisting on N digits. Next line contains Q, denoting the number of questions. Each of the next Q lines contains 2 integers L and R .\n\nFor each question, print \"YES\" or \"NO\", if the number formed by the string between indices L and R is divisible by 7.\n\nYES \n\n NO \n\n YES \n\n\n\nFor the first query, number will be 35 which is clearly divisible by 7.\n\nNow according to the constraints, the maximum length of the number i.e. N can be upto 105. This big a number cannot be fitted into a numeric data structure and I am pretty sure thats not the efficient way to go about it.\n\nI thought of this algorithm to apply the generic rules of division to each individual digit of the number. This would work to check divisibility amongst any two numbers, in linear time, i.e. O(N).\n\nBut in this case, the algorithm has to also loop through all the values of Q, which can also be upto 105.\n\nTherefore, the time taken to solve the problem becomes O(Q.N) which can also be considered as Quadratic time. Hence, this crossed the given time limit and was not efficient.\n\nAfter that didn't work, I tried searching for a divisibility rule of 7. All the ones I found, involved calculations based on each individual digit of the number. Hence, that would again result in a Linear time algorithm. And hence, combined with the number of Questions, it would amount to Quadratic Time, i.e. O(Q.N)\n\nI did find one algorithm named Pohlman–Mass method of divisibility by 7, which suggested\n\nBut all that did was, make the time 1/3rd Q.N, which didn't help much.\n\nAm I missing something here? Can anyone help me find a way to solve this efficiently?\n\nAlso, is there a chance this is a Dynamic Programming problem?"
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html",
        "document": "A simple text scanner which can parse primitive types and strings using regular expressions.\n\nA breaks its input into tokens using a delimiter pattern, which by default matches whitespace. The resulting tokens may then be converted into values of different types using the various methods.\n\nFor example, this code allows a user to read a number from :\n\nAs another example, this code allows types to be assigned from entries in a file :\n\nThe scanner can also use delimiters other than whitespace. This example reads several items in from a string:\n\nThe same output can be generated with this code, which uses a regular expression to parse all four tokens at once:\n\nThe default whitespace delimiter used by a scanner is as recognized by . . The method will reset the value of the scanner's delimiter to the default whitespace delimiter regardless of whether it was previously changed.\n\nThe and methods and their primitive-type companion methods (such as and ) first skip any input that matches the delimiter pattern, and then attempt to return the next token. Both and methods may block waiting for further input. Whether a method blocks has no connection to whether or not its associated method will block.\n\nThe , , and methods operate independently of the delimiter pattern. These methods will attempt to match the specified pattern with no regard to delimiters in the input and thus can be used in special circumstances where delimiters are not relevant. These methods may block waiting for more input.\n\nWhen a scanner throws an , the scanner will not pass the token that caused the exception, so that it may be retrieved or skipped via some other method.\n\nDepending upon the type of delimiting pattern, empty tokens may be returned. For example, the pattern will return no empty tokens since it matches multiple instances of the delimiter. The delimiting pattern could return empty tokens since it only passes one space at a time.\n\nA scanner can read text from any object which implements the interface. If an invocation of the underlying readable's method throws an then the scanner assumes that the end of the input has been reached. The most recent thrown by the underlying readable can be retrieved via the method.\n\nWhen a is closed, it will close its input source if the source implements the interface.\n\nA is not safe for multithreaded use without external synchronization.\n\nUnless otherwise mentioned, passing a parameter into any method of a will cause a to be thrown.\n\nA scanner will default to interpreting numbers as decimal unless a different radix has been set by using the method. The method will reset the value of the scanner's radix to regardless of whether it was previously changed.\n\nAn instance of this class is capable of scanning numbers in the standard formats as well as in the formats of the scanner's locale. A scanner's initial locale is the value returned by the method; it may be changed via the method. The method will reset the value of the scanner's locale to the initial locale regardless of whether it was previously changed.\n\nThe localized formats are defined in terms of the following parameters, which for a particular locale are taken from that locale's object, , and its and object, .\n\nThe strings that can be parsed as numbers by an instance of this class are specified in terms of the following regular-expression grammar, where Rmax is the highest digit in the radix being used (for example, Rmax is 9 in base 10).\n\nWhitespace is not significant in the above regular expressions."
    },
    {
        "link": "https://w3schools.com/java/java_user_input.asp",
        "document": "The class is used to get user input, and it is found in the package.\n\nTo use the class, create an object of the class and use any of the available methods found in the class documentation. In our example, we will use the method, which is used to read Strings:\n\nIn the example above, we used the method, which is used to read Strings. To read other types, look at the table below:\n\nIn the example below, we use different methods to read data of various types:\n\nNote: If you enter wrong input (e.g. text in a numerical input), you will get an exception/error message (like \"InputMismatchException\"). You can read more about exceptions and how to handle errors in the Exceptions chapter."
    },
    {
        "link": "https://stackoverflow.com/questions/2506077/how-to-read-integer-value-from-the-standard-input-in-java",
        "document": "This causes headaches so I updated a solution that will run using the most common hardware and software tools available to users in December 2014. Please note that the JDK/SDK/JRE/Netbeans and their subsequent classes, template libraries compilers, editors and debuggerz are free.\n\nThis program was tested with Java v8 u25. It was written and built using\n\n Netbeans IDE 8.0.2, JDK 1.8, OS is win8.1 (apologies) and browser is Chrome (double-apologies) - meant to assist UNIX-cmd-line OG's deal with modern GUI-Web-based IDEs at ZERO COST - because information (and IDEs) should always be free. By Tapper7. For Everyone."
    },
    {
        "link": "https://beginnersbook.com/2017/09/java-program-to-read-integer-value-from-the-standard-input",
        "document": "In this program we will see how to read an integer number entered by user. Scanner class is in java.util package. It is used for capturing the input of the primitive types like int, double etc. and strings.\n\nExample: Program to read the number entered by user\n\nWe have imported the package to use the Scanner. In order to read the input provided by user, we first create the object of Scanner by passing as parameter. Then we are using nextInt() method of Scanner class to read the integer. If you are new to Java and not familiar with the basics of java program then read the following topics of Core Java:\n\n→ Writing your First Java Program\n\n→ How JVM works\n• Java program to get input from user\n• Java packages and how to use them"
    },
    {
        "link": "https://geeksforgeeks.org/how-to-read-and-print-an-integer-value-in-java",
        "document": ""
    }
]