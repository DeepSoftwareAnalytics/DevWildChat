[
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/ScriptReference/EditorWindow.html",
        "document": "Use this class to create Editor windows that can either float independently or dock as tabs, similar to the default windows in the Unity Editor.\n\n\n\nYou can use the MenuItem attribute to configre an Editor windows to be opened in the Unity Editor menu.\n\n\n\nWhen creating a custom Editor window, follow these guidelines:\n• Put code dependent on UXML/USS loading in the CreateGUI method to ensure that all necessary assets are available.\n• Keep the event registration code inside CreateGUI or after CreateGUI is called. The following diagram shows the order of execution of an Editor window:\n• OnEnable: Called when the script is loaded or when the object is enabled.\n• EditorApplication.isUpdating: If true, the Editor is currently refreshing the AssetDatabase.\n• CreateGUI: Generates the graphical user interface if the Editor is not updating.\n• Update: Called once per frame to update the script's logic.\n• OnGUI: Called multiple times per frame for rendering and handling GUI events.\n• OnDisable: Called when the script is disabled or the object is destroyed to finalize and clean up resources. For an example on how to create an Editor window that reacts to user input, refer to Create a custom Editor window with C# script."
    },
    {
        "link": "https://docs.unity3d.com/Manual/editor-EditorWindows.html",
        "document": "Note: It’s strongly recommended to use the UI Toolkit to extend the Unity Editor, as it provides a more modern, flexible, and scalable solution than IMGUI.\n\nYou can create any number of custom windows in your app. These behave just like the InspectorA Unity window that displays information about the currently selected GameObject, asset or project settings, allowing you to inspect and edit the values. More info\n\nSee in Glossary, SceneA Scene contains the environments and menus of your game. Think of each unique Scene file as a unique level. In each Scene, you place your environments, obstacles, and decorations, essentially designing and building your game in pieces. More info\n\nSee in Glossary or any other built-in ones. This is a great way to add a user interface to a sub-system for your game.\n• Use code to trigger the window to display itself.\n• Implement the GUI code for your tool.\n\nIn order to make your Editor Window, your script must be stored inside a folder called “Editor”. Make a class in this script that derives from EditorWindow. Then write your GUI controls in the inner OnGUI function.\n\nMyWindow.cs - placed in a folder called ‘Editor’ within your project.\n\nIn order to show the window on screen, make a menu item that displays it. This is done by creating a function which is activated by the MenuItem property.\n\nThe default behavior in Unity is to recycle windows, so selecting the menu item again would show existing windows. This is done by using the function EditorWindow.GetWindow Like this:\n\nThis will create a standard, dockable editor window that saves its position between invocations, can be used in custom layouts, etc. To have more control over what gets created, you can use GetWindowWithRect\n\nThe actual contents of the window are rendered by implementing the OnGUI function. You can use the same UnityGUI classes you use for your ingame GUI (GUI and GUILayout). In addition we provide some additional GUI controls, located in the editor-only classes EditorGUI and EditorGUILayout. These classes add to the controls already available in the normal classes, so you can mix and match at will.\n\nThe following C# code shows how you can add GUI elements to your custom EditorWindow:\n\nThis example results in a window which looks like this:\n\nFor more info, take a look at the example and documentation on the EditorWindow page."
    },
    {
        "link": "https://learn.unity.com/tutorial/editor-scripting",
        "document": "Editor Scripting can help you customize and extend the Unity editor to make it easier to use on your projects. This tutorial covers the basics of editor scripting, including building custom inspectors, gizmos, and other Editor windows."
    },
    {
        "link": "https://discussions.unity.com/t/how-to-add-custom-script-created-from-editor-window-to-a-gameobject/1540790",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/docking-custom-editor-windows-from-script/941338",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/what-is-your-process-for-dealing-with-unused-assets/778324",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/remove-unused-assets/101852",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/Unity3D/comments/1e3hop7/should_i_delete_the_assets_i_dont_use",
        "document": "Let’s say I download an asset package from the unity asset store, but out of 20 assets the package have I use 2, should I remove the others from the project? Will leaving them in the project slow down my game or make it have lower fps?"
    },
    {
        "link": "https://reddit.com/r/Unity3D/comments/1cpx4k/finding_deleting_unused_assets_in_a_unity_project",
        "document": "My project is getting large enough so that manually checking if assets are still in use takes a long time.\n\nI know Unity strips unused assets when I do a build. Is there a way way to find unused / unreferenced assets in the editor somehow?\n\nMy main problem is materials - the auto-creation that happens when I mass-import meshes leaves a ton of unused materials behind. A way to auto-delete them would be a godsend."
    },
    {
        "link": "https://makaka.org/unity-tutorials/optimization",
        "document": "Are you planning to optimize your game made with Unity and get the best performance? In this Complete Unity Optimization Guide, I will show you how to increase performance in Unity correctly, so your game will run fast and stable.\n\nHere I will consider optimization tools provided by Unity Game Engine and also by Indie Developers (Publishers) in Unity Asset Store — Top Unity Assets (Tools) for Unity Optimization.\n\nI will also deep into details of common performance issues in video games and find solutions for them: optimization of code and assets, tips & tricks.\n\nUnity Optimization refers to the process of making your game run better. Usually, the main reason for optimization is to make the gameplay smoother, or to make the game more available to a wider audience, so the game runs better on lower end devices.\n\nNext will be presented common optimization cycle, which you need to go sequentially every time when noticeably low FPS suddenly occurs in your game after next stage of development:\n• If your game works without lags and freezes on target platforms, then the game does not need to be optimized. Do more important things like new levels in current game.\n\n Optimization for the sake of optimization is a waste of time.\n• If you have lags and freezes then the starting point is Profiling (firstly with Unity Profiler) to detect what kind of performance issues Unity Project has.\n• After the optimization tasks have been determined and before the process of optimization is started, it is advisable to take some time and consider which area of optimization is the priority. This is done by comparing the approximated time each specific implementing of optimization would take and a performance gain in result.\n\nResulting ordered list of optimization tasks will work as a guideline for the entire process of optimization starting with the most effective action. This also helps to gain the most performance with the least efforts. Follow this list until the game on target platforms has smooth gameplay and stable frame rate.\n• If the game is executing excellent without visible problems and the list of optimization tasks is not empty then forget further optimization process.\n• If the game still has problems then project should be profiled and the data stored. Next stored data can be compared with a previous data allowing for closer inspection of the state of the whole optimization process.\n\nRepeated profiling allows you to understand what happened after the completion of a single optimization task, whether this procedure brought a performance improvement or not.\n\nYou can Optimize Unity Game in different ways depending on problem nature. Performance problems can be divided into several types depending on their nature.\n\nSpike is a sudden drop in the frame rate of a game. This is noticed when a game suddenly stops and doesn’t move for a noticeable time. This can break the immersion of the player or cause him to make a mistake he wouldn’t have otherwise made. Spikes can be seen as a high points on Profiler Graph.\n\nSpikes are mainly caused by complex calculations or difficult operations performed during a single frame. Annoying Spikes are a problem in high-intensity games which need a stable frame rate and high control over the game to feel good, such as driving or shooting games (FPS).\n\nGarbage collection spikes are frame rate drops specifically caused by the garbage collection system of Unity. These can be huge frame rate spikes and are easily noticed while playing the game. The spikes happen when the memory garbage limits met and the collection runs, cleaning up the unnecessary objects from the memory. Their frequency is mandated by how much garbage the game generates each frame. The frequency can be slowed down by generating less garbage during runtime.\n\nThe only way of preventing these spikes completely is to generate no garbage during runtime. This is a huge undertaking and must be considered from the very beginning of a project.\n\nEvery-frame costs are the calculations and operations that are run every single frame. These can be, for example, physics calculations, running AI behavior or handling animations of characters.\n\nEvery-frame costs slow down the general frame rate of the game. They are the little things that slow the game down and make it feel less fluid. If a game just generally runs poorly, this is the area that needs work.\n\nLoading time refers to how long the game takes to load. This includes the first load when the game is opened, and loading that happens during runtime, for example between scenes.\n\nWhile not usually a major issue, having extremely long loading times or having loading screens appear far too often can negatively affect the user experience.\n\nTo reduce the length of loading screens, consider splitting up the work done during them. This can mean preloading assets beforehand to reduce the number of objects that need to be loaded during loading screen, or reducing the complexity of loaded scenes.\n\nIn an open world game, where many objects need to be loaded during runtime, a method of recycling or streaming assets can be implemented. In “Inside” Game a small part of every frame is dedicated to loading and unloading assets. This allows the whole four-hour experience to be played through with just a single initial loading screen.\n\nRAM (Random Access Memory) is the memory on which a game is loaded while running. RAM stores everything needed by a game during runtime.\n\nVRAM (Video Random Access Memory) is on a graphics card and is intended for graphical effects. VRAM is the storage used to store textures and models drawn by the graphics card.\n\nRAM is what your CPU uses, while VRAM is what your GPU uses. Either or both might become a bottleneck on a project running with unoptimized or simply with far too many assets. When there is not enough memory, stuttering may occur.\n\nTo reduce the amount of memory needed by your project, consider next:\n• Reduce the complexity of objects and the resolution of textures;\n• Make less unique assets in the project;\n\nTo know what is the issue with the performance of a project, profiling is needed. Profiling assists in understanding the unique issues found in a project, and should always be the starting point for optimizing a project.\n\nProcess of Profiling means reading the performance data of the project and finding out where the performance issues are located. From this data bottlenecks can be found.\n\nUnity provides some different tools for profiling:\n\nThis chapter goes through each of these tools, analyses them and gives information on how to use them.\n\nUnity Profiler and Frame Debugger can both be used to profile a project currently running on the same editor. However, the editor affects the performance of the project and the profiling information can be inaccurate. For this reason, if accurate profiling data is needed, a separate build should be created for profiling purposes.\n\nTo make a build which can be profiled, turn on options “Development build” and “Autoconnect Profiler” in Build Setting before making a build. This allows Unity Editor to find the build and for the Profiler to connect to it.\n\nTo get accurate profiling data, the build should be profiled on end user device. When you optimize Unity Game for Mobiles then Profiling on a powerful PC gives little insight on how a user will experience the game.\n\nThe easiest way to connect the Profiler to an external device is to have the two devices share the same local network. If there is a device running a development build of the project, it should be selected in the “Editor” dropdown menu of Unity Profiler, Frame Debugger or Console.\n\nOnce the correct device has been selected, the Profiler should automatically start profiling it. Profiling on an external device still affects the performance, but the effect is less than when profiling on the same device.\n\nModern mobile devices are powerful but often lack an active cooling system. Because of this, the heat of the device affects its performance highly.\n\nOn mobile devices, the performance of a game can be directly compared to the heat level of the device. When the device is just turned on and the application is launched, the performance is at its best. Once the device has warmed up the performance starts to fall as the device tries to cool itself. And again, once the device has cooled down enough, performance is improved.\n\nTo effectively profile a mobile device, it should be warmed up first. After the build has run for 10 minutes, and the device has warmed up properly, the profiling information becomes more accurate and more applicable to an actual user experience.\n\nUnity Profiler is the main tool for profiling Unity Projects. It provides much information on the different performance areas of a project:\n\nThis tool is the beginning of every optimization process on Unity. From information provided by it, bottlenecks are found and from these bottlenecks the first optimization tasks are created. Learning to use it helps to understand the work of Unity Engine and Current Project.\n\nThe Highlights Profiler module displays information on whether your application is meeting its target frame rate and if its performance is bound by the CPU or the GPU, and where to begin investigating potential performance problems.\n\nStarting with Unity 2023.2, it helps you quickly identify app bottlenecks so that you can have an entry point for your new optimization cycle.\n\nThis module is not enabled by default, so you will have to open the Profiler window, then select the Profiler Modules drop-down menu to toggle the Highlights feature on to use it.\n\nProfiler Window can be opened through the “Window > Analysis” tab of Unity Editor, or by pressing the shortcut CTRL+7 on Windows or CMD+7 on macOS.\n\nOnce Unity Profiler has been connected to a running build and the record button has been pressed, profiling information will begin to be collected and displayed in the window. To stop or pause Unity Profiler simply toggle the Record button.\n\nOn the left side of the window the different profiling categories can be seen, and more can be added from the “Add Profiler” dropdown menu at the top.\n\nWhen profiling, information on each active category appears on the right side of the window. Each slice of the information presents a single frame. On the CPU usage category, execution time the frame is presented by the height of the slice. Frames can be switched by pressing the arrow keys on the window, or by clicking a slice with the mouse.\n\nInformation on the selected category and target frame appears at the bottom of the screen.\n\nNext to the function name different values are shown. The values provide information on the performance of the function in the selected frame. These values are the percentage of the total CPU time spend on this function, the number of times the function is called in the chosen frame, how much garbage the function generated and the time it took to finish the function in milliseconds (total time including inner functions (Time ms) and without them (Self ms)).\n\nIf these functions themselves call other functions, a small arrow is shown next to the name of the function. Clicking this arrow opens a function hierarchy that shows how the full time of the function is split among the functions called by it.\n\nThe height of the lines shown on the upper half of the window tells how long that frame took to finish. If these lines have noticeable spikes in them, there has been a frame rate drop. Hunting down what function caused the spike and optimizing it is a way of making the frame rate and gameplay experience smoother.\n\nHierarchy Raw Mode will separate global Unity function calls into individual lines. This will tend to make Profiled Data more difficult to read, but may helpful if we are trying to:\n• to count how many times a particular global method has been invoked,\n• to determine if one of these calls is costing more CPU/Memory than expected.\n\nYou can also use Timeline Mode of Profiled Data. It’s just another way to show the data. You have in quick glance the whole situation of a frame in order of occurrence for all threads. So events showed at the left are the first that happened and the right are the last.\n\nTimeline Mode can be useful since it show more details than the normal version, and if you will click on some block then Timeline will tell you what Game Object connected to this block (e.g., for Skinned Mesh Renderer or Animator).\n\nIt is useful to discover some bottlenecks, maybe you can notice the rendering is taking very little but it’s waiting a lot for CPU to send commands. You have the same data on Hierarchy Mode of Profiler but for some cases it’s easier to spot certain issues as you can graphically compare two items. Hierarchy Mode of Profiler is better when you are focusing on specific parts, the Timeline Mode it’s better for a general picture.\n\nUnity Profile Analyzer (package) the Unity Profiler’s single-frame analysis by adding the ability to analyze multiple frames at once. This is useful when it’s important to have a wider view of your performance, such as:\n• tracking performance as part of your development cycle.\n\nIt analyzes CPU frame and marker data that is pulled from the active set of frames currently loaded in the Unity Profiler or loaded from a previously saved Profile Analyzer session. The analyzed CPU frame and marker data gets summarized and graphed using histograms, and box and whisker plots, which compliment ordered list of activity for each marker, including:\n• which frame the marker first appeared in.\n• Open your project in Unity and go to “Window > Package Manager”.\n• If you don’t see “Profile Analyzer” in package list then open the “Advanced” drop-down and make sure “Show Preview Packages” is set.\n\nDraw Call — single task performed on the GPU used to draw the screen. A single frame consists of multiple Draw Calls. Modern 3D games with complex graphical assets and effects may need thousands of Draw Calls to render the screen each frame.\n\nReducing the number of Draw Calls is a simple method to reduce the workload of the GPU.\n\nTo get information on what the GPU spends its Draw Calls on, Unity Frame Debugger can be used. By using the tool, more insight on the rendering process can be got. It also is used to find the areas where the most Draw Calls are spent, and where optimization is required.\n\nFrame Debugger Window can be opened through the “Window > Analysis” tab of Unity Editor.\n\nFrame Debugger is connected the same way as Unity Profiler and can easily be used either inside Unity Editor, debugging “Game” Window, or on a separate device.\n\nDebugging a build on the same device as the editor can cause some issues like window freeze.\n\nOnce Frame Debugger has been activated, it freezes the profiled build and collects data on the frozen frame. Once the data has been collected, information on every Draw Call used to render that frame appears on the left side of the window. Draw Calls are organized into hierarchies such as drawing and image effects. Next to the hierarchy name is shown the amount of Draw Calls it took to finish rendering that area.\n\nBy switching between Draw Calls on Frame Debugger Window, changes can be seen on the frozen frame of profiled build (or in the “Game” View in Unity Editor if you are profiling without build) as the debugger shows what was drawn by each call.\n\nBy clicking a single Draw Call, more information on that specific call appears on the right side of the window. Switching between Draw Calls and watching the frozen screen change can give enough of an idea on where optimization is required.\n\nIf the most of Draw Calls are spent drawing a single object or a character in the scene, work on that object might be required.\n\nUse the Memory Profiler (package) to identify potential areas in your Unity project (and the Unity Editor itself) where you can reduce memory usage. For example, use the Memory Profiler to capture a snapshot (represents the whole memory usage of the project), inspect, and compare 2 memory snapshots.\n\nThe Memory Profiler is unified solution allowing you to profile both small projects on mobile devices and big AAA projects on high-end machines.\n\nThe Memory Profiler is a window in Unity Editor with an overview of native and managed memory allocations and can help you detect memory leaks and fragmentation with some different tool:\n• Tables (Lists of All Managed Objects with Filtering, Difference between 2 snapshots);\n• Open your project in Unity and go to “Window > Package Manager”.\n• If you don’t see “Memory Profile” in package list then open the “Advanced” drop-down and make sure “Show Preview Packages” is set.\n\nTo use it, a build of the profiled project is needed because separate build has more accurate data in comparison with running project in Unity Editor. Profiler must be connected to the build when the build is running and Memory Profiler is open in Unity Editor.\n\nOnce the window has been opened, the “Capture Player” button can be pressed. Wait for Problem Moment of Game and Capture Second Snapshot.\n\nOnce the snapshots have been captured, they show up on the Memory Profiler and the profiled build is no longer needed. Next you can investigate each snapshot with different tools and compare them with “Diff” button.\n\nTree Map — Visual Representation of Memory like Programs for Space Analyzing of Hard Disk.\n\nDifferent colored squares indicate memory taken by different object types, for example textures or meshes. By clicking a square, it is divided further into smaller squares representing individual objects. More information on these individual objects can be seen at the bottom of window by clicking them, and even a reference on what is using the object can be seen.\n\nJust by looking at the memory usage snapshot split up by object type tells which objects use the most memory. Tracking down the individual big spenders and working on those can quickly bring down the memory used by the project.\n\nPhysics Debugger — tool for quickly inspecting the Collider geometry in your Scene, and profile common physics-based scenarios. It provides a visualization of which Game Objects should and should not collide with each other. This is particularly useful when there are many Colliders in your Scene, or if the Render and Collision Meshes are out of sync.\n\nYou can use Physics Debug to profile and troubleshoot physics activity in your game.\n\nYou can customize which types of Colliders or Rigidbody components you can see in the visualizer, to help you find the source of activity.\n\nTo see only the Rigidbody components that are active and therefore using CPU/GPU resources, tick “Hide Static Colliders” and “Hide Sleeping Bodies”.\n\nNon-convex (triangle-based) Mesh Colliders tend to generate the most contacts (comparing to colliders of simple forms) when their attached Rigidbody components are very near a collision with another Rigidbody or Collider.\n\nTo visualize only the non-convex Mesh Colliders, set the window to Show Selected Items mode, click the “Select None” button, then tick the “Show Mesh Colliders (concave)” checkbox.\n\nHot to Fix the Broken Physics after updating the Unity Engine?\n\nHow to Fix Bugs in Unity Physics and Solve any Problems after Updating the Version of Unity Engine? It’s a Tutorial about step-by-step bug solving in Unity. Learn more here.\n\nUIElements Debugger — tool for debugging of Unity Editor Extensions that was written with UIElements, a new retained-mode GUI system for extending the Editor in Unity 2019 and higher. It is useful for Asset Store Publishers who develop Editor Tools like “Bolt“.\n\nWhen you are working with UIElements, UIElements Debugger helps you visualize the hierarchy tree, properties and USS (Unity Style Sheets) files applied to each element.\n\nBenchmarking refers to collecting data from a project to measure its performance. This is different from profiling in that the benchmarking data should be as close to the performance of the final product as possible. Because of this the data should not be collected by using the Unity Profiling tools, since just running the tool has an impact on the performance.\n\nBenchmarks should be taken on the same device as the final product is meant to run on. A single device can be good enough, but for getting many data, multiple devices of different performance capabilities should be benchmarked on. This way gives more information of the performance on low- mid- and high-tier devices.\n\nWhen benchmarking the frame rate of the project, a separate script can be used to track the frame rate instead of using the profiling tool.\n\nRead Also Complete Article about Benchmarking on Unity Blogs.\n\nTo keep the frame rate data accurate between benchmarks, the gameplay should be reproduced as accurately as possible. The best way to handle this is to have a script that plays the game the same way every time. When the gameplay is identical between benchmarks, they can be compared to each other and Unity Optimization Process can easily be monitored.\n\nYou can create a script having a single “Hub” Scene from which the other scenes were launched. The script would start the project on the lowest quality setting in the “Hub” Scene. From this scene it would open and play through the gameplay scenes, always returning to “Hub” Scene after a scene was completed. After finishing all the gameplay scenes, the quality level would be increased and playing through the scenes started again.\n\nThe automatic system would also collect performance information while running. This information was then stored on text files created by the script. These files were saved on the hard drive of the device and organized by scene and quality level. You can run script on two or more devices over the night and fresh data could be gathered on the next morning.\n\nAdvanced FPS Counter — Simple and flexible in-game frames per second counter with advanced features, made to let you monitor stats of your game right on the target device.\n\nAlso, take a look at These Awesome Tools:\n\nEvery Unity Project is unique and has its own unique issues. However, there are a many of well-known performance related problems associated with Unity Engine itself. This chapter goes through several of the known performance issues in Unity and provides information on avoiding them.\n\nYou should stay with Unity LTS (Long-term support) versions only.\n\nTech Stream is a non-LTS version of Unity: e.g., 2023.1, 2023.2.\n\nSo Using Tech Stream in production development is a risky deal.\n\nNew Unity 6 is 2023.3 LTS version, so Unity 2022.3 LTS is the last version for production dev without new Runtime Fee. So you have about 1.5 more years to work without a new pricing policy because usually LTS versions are supported for 2 years.\n\nOn the other side, New Features in future releases are not applied backwardly to LTS — Only Fixes and critical stuff like “Hide home button on iPhone X” in Player Settings.\n\nYou need to use C# Events instead of UnityEvents.\n\nYes, C# Events are not as convenient to use as Unity Events because Unity Events can be shown in Unity Editor at least, but Unity Events have bad performance in most cases. You can read research about comparing C# & Unity Events. Moreover, assigning methods to events with Unity Editor is a bad practice in terms of code because debugging a project by another person in this case becomes hard.\n\nDon’t combine 2 strings in Update () Function because every time it creates garbage by memory allocation.\n\nInstead of it you need to create 2 separate text objects (TextMesh Pro, of course):\n• For updating the text with current score.\n\nThe most common optimization issue with new Unity projects is the UI system.\n\nThe basic element of the Unity UI is a canvas. These canvases then house all other elements of the UI, be it text or images. The issue with these canvases is that when a single UI element on a canvas changes, the whole canvas is marked dirty and needs to be redrawn.\n\nOften with developers who haven’t had much experience with Unity, all the UI in the game is set up under a single canvas. This can mean that a complex menu system, even while hidden, needs to be redrawn every frame because it shares the canvas with a timer, for example.\n\nOptimize Unity UI with common method by splitting UI elements to separate canvases by update frequency. Elements that are updated regularly, like Timers or Mana Orbs, under a single canvas and static elements under another one. This fixes the issue of having to update every single UI element in every frame.\n\nUI is a bottleneck especially on mobile devices. Transparent graphics are not handled well by mobile graphics cards, and all the UI elements in Unity are considered transparent. For this reason, splitting elements between multiple canvases can have a huge effect on the performance of the project.\n\nUnity Text Component (UI) & Unity 3D Text (Text Mesh component) have bad performance.\n\nOptimize Text with TextMesh Pro instead of default Unity Texts.\n• Open your project in Unity and go to “Window > Package Manager”.\n\nRead Next: Making the most of TextMesh Pro.\n\nYour asset can have a texture that must contain static text (e.g., Road Signs). Yes, you can use TextMesh Pro to create a text over the texture, but this can be a bad idea, since UI elements that move and resize in 3D space as the player moves cause performance load. In this case signs can be replaced with transparent textures so Texture of Road Sign must contain image & text now.\n\nMemory Management is done automatically in Unity. When deallocating the memory, Unity Engine often causes a huge frame rate drops. These drops are especially noticeable in fast reaction games, where stable frame rate is important.\n\nMany Unity Functions generate a garbage, making it almost impossible to fix the garbage collection spikes, without changing the source code of the engine which is available for purchasing exclusively to Pro and Enterprise customers of Unity Engine.\n\nFollowing are listed several methods of possible fixing of garbage collection issues.\n\nAll memory deallocation in Unity is done by Garbage Collector. When enough memory has been allocated, the garbage collector automatically clears unused objects from the memory for a single frame. This is referred to as running the garbage collector, and always causes a frame rate drop.\n\nThere are multiple ways to reduce the performance impact and the frequency of running the garbage collector. The simplest is to generate less garbage during runtime. When profiling the CPU, the amount of garbage generated by each function can be seen. Then you can change these functions to generate less garbage.\n\nOne way to solve the issue is to manually run the garbage collection when the gameplay is less active, and the frame rate drop won’t affect the user experience. For example, during loading screens or during more peaceful (passive) periods of gameplay.\n\nThis still caused a noticeable frame rate drop, but at a time when it did not negatively affect the gameplay.\n\nI don’t recommend to use Manual Garbage Collection because is a last measure — in 95% of cases you will success without it. First of all, you should deal with all the bottlenecks of your project.\n\nCaching is a technique of reusing object. Caching refers to storing something that is often needed as a variable instead of calculating or fetching it whenever it is needed. For example, this can mean storing the camera as a variable in a script instead of calling “Camera.Main” whenever the camera is needed.\n\nUnity APIs such as “Camera.main” or “gameObject.transform” causes a little overhead. Camera.Main is a shortcut for finding a camera object from the scene with the tag Main. This value is never stored so every time the function is called, a search operation is performed. All this overhead can be fixed by storing a reference to the object as a variable after the first call of the function.\n\nFor example, no need of creating the same local variable every frame in Update () Function:\n\nInstead of it you can assign the variable when declare a variable as a field of class, and initialize it here or in Awake () or Start () functions if it makes sense in your case.\n\nObject Pooling is also Caching, but in this case we are dealing with several objects of the same type (e.g. with the same script components) or same prefabs. Read more about Object Pool.\n\nYou can reduce the resolution by adjusting “Max Size”. “Max Size” setting is non-destructive meaning it does not change the original texture size — it only adjusts the imported size. E.g, set max size to 1024 instead of 2048 press apply to save the changes.\n\nTexture Adjustments (Unity Asset) can be used to crop, resize and adjust textures in Editor and Runtime using GPU accelerated ultra-fast filters.\n\nNormal Maps can usually be set to a lower resolution than Albedo or Color textures as the lower resolution is less noticeable in case of Normal Maps.\n\nCommon pitfall of texture memory usage is using “Read/Write Enabled” option on a texture that does not need it. If the option is enabled on a texture, it will stay in CPU memory even after being sent to the GPU (which you can’t access directly without a performance penalty). This can double texture memory in most cases.\n\nThe option is needed to enable access to the Texture data from script functions (such as Texture2D.SetPixels, Texture2D.GetPixels and other Texture2D functions). Note that a copy of the Texture data is made, doubling the amount of memory required for Texture Assets, so only use this property if necessary. This is only valid for uncompressed and DXT compressed Textures; other types of compressed textures cannot be read from. This property is disabled by default.\n\nPCM — the most memory intensive format. PCM compression is a lossless format useful for short sounds as the CPU processing required to decode PCM is very low. For long clips you can use lossy Vorbis compression format. It will help us save the space in memory and on disk.\n\nBy reducing the quality setting with PCM we can trade audio quality for even more memory savings.\n\nYou can hear audio delay, Especially on mobiles: iOS & Android. To fix this issue you can set “Audio Setting > DSP Buffer Size > Best latency”.\n\nIf the problem is still relevant, then use Native Audio (Unity Asset).\n\nUnity pre-allocates a minimum amount of memory on startup. This is called the heap. When the heap is filled, new memory must be allocated and this can be performance intensive.\n\nOne way to avoid the issue is to manually allocate a large amount of memory on startup and then empty that memory. This amount should be close to the measured maximum amount of memory needed by the program. This forces Unity to expand the heap on startup and removes the performance issues caused by expanding the heap during runtime.\n\nThe simplest way to optimize Game Objects is to remove objects drawn. This can be done by removing not critical (redundant) objects from the scene.\n\nGame objects can be marked as static in the editor. This mark tells the engine that the marked object will never move. This allows the engine to use a method called batching to render it.\n\nBatching happens when the engine draws multiple objects on a single Draw Call.\n• the objects must be marked as static & share the same material;\n\nBy using the Frame Debugger that was considered in the first part of this article, you can see when batching has been used to reduce the number of Draw Calls. The debugger will also tell you why a Draw Call was not rendered in the same batch as the previous one.\n\nFrustum Culling removes objects outside the camera view from the rendering process, saving Draw Calls without affecting the user experience. In Unity, this is an automated process and is always on, requiring no setup from the developer.\n\nOcclusion Culling works alongside Frustum Culling as an additional method of reducing Draw Calls. While Frustum Culling hides objects outside the view, occlusion culling aims to minimize draw calls in view. This is achieved by removing objects hidden behind other objects from the rendering process.\n\nUnlike frustum culling, an automated process, the occlusion culling must be set up and baked beforehand in Unity Editor. Unity has provided an object called “Occlusion Culling Area”, which can be created from the “Occlusion Culling” window. The window can be found under the “Window > Rendering” menu item. These objects need to be placed in the world before the data can be baked. This can be done manually or through scripts.\n\nGame Objects with the tags “Occluder Static” and “Occludee Static” are included in the Occlusion Culling process. These are on by default in Static Game Objects. When an object marked with “Occluder” tag hides an object marked with “Occludee” tag behind it from camera view, the “Occludee” object is removed from the rendering process.\n\nThe occlusion areas are to be set up such that the camera will never wander outside them. If the camera go outside the occlusion culling areas, no occlusion culling will be applied, causing errors such as invisible objects and holes in the terrain.\n\nOnce the occlusion areas have been set up, occlusion culling can be baked. This is done from “Occlusion” Window. Once completed, the effects of occlusion culling can be viewed by using the “Visualize” tab on the scene window. This allows for debugging by moving the camera and observing the changes in editor.\n\nIf pop-in of objects and other errors occur, there are few ways to solve the issue:\n• The values provided in the occlusion window can be tweaked, affecting the precision of the culling, the size of the baked file and the time it takes to finish the baking process.\n• Other way of adjusting the culling precision is to change the size and frequency of occlusion areas. Multiple small areas can be more precise compared to a single larger area, but can increase the baking time and the size of the baked occlusion data file.\n• If there are still objects that are not correctly culled, they can be taken out of the occlusion process entirely by removing the Occludee Static tag from the game object.\n\nOptimize Mesh Data with LODs (level of detail — system used on 3D objects to reduce their impact on the performance). It functions by replacing the high-quality 3D object with a similar object of lower quality when they get further away from the camera. Often the 3D object is replaced further with a 2D render of it and even removed completely.\n\nLOD levels can be set up by adding the LOD component to Game Object. From the component the amount of levels and the level changing distance can be modified. The way Unity determines when the LOD level should be changed, is how much of the object is on the screen at a given time. This can cause weird behavior in objects partially hidden or underground, for example rocks. This method of reducing Draw Calls causes more work on the artists end since the lower quality objects need to be made by someone.\n• Use the lowest LOD level of the terrain, losing some of the fidelity but removing the need for runtime calculations.\n• Replace most of the trees in scenes with 2D images, reducing the workload of the foliage system without much affecting the user experience.\n\nJust having many objects, especially terrains, in a single scene caused the performance of scene go down drastically.\n\nYou can use several ways to stream scenes:\n• The initial scene was split into multiple smaller scenes, and they were loaded and unloaded when necessary (when player enters in portal, e.g.).\n• Streaming the terrains inside the scene. Instead of having over 30 terrains always active in the scene, only 9 terrains around the player character would be active at once. For the rest of the terrains a boundary was set up that would trigger when the player would move inside it. When a boundary was triggered, system moves the already existing terrains in front of the player and replaces the data of the moved terrain by a new one. So no spawning was necessary, and instead the same 9 terrains were being recycled through the whole scene.\n\nUnity allows you to use only convex mesh colliders because they have less performance load instead of non-convex ones. In some cases, it is not what you need because the collider covers more space, than the object itself in some points.\n\nUse the following techniques to achieve accuracy of collider space:\n• Create many simple forms of colliders and place them on Game Object manually.\n• To quickly & automatically get a convex mesh collider for complex objects, use Technie Collider Creator (Asset Store).\n\nIt is very important to keep your project clean without errors, missing stuff, and unnecessary files.\n\nThis is necessary so that the size of your project is minimal (for fast loading to the user’s device) and there are no sudden errors at the most unnecessary moment during the gameplay.\n\nMaintainer — top editor tool that allows keeping your project clean by fixing project issues, removing unused assets, and finding assets references/hierarchy references.\n\nUnity 2022.2 introduces a new optimization technique: Removing Unused Overrides in Prefab Instances. You can clear unused Overrides stored in a scene but never accessed (because the property has been removed from a script).\n\nIn the worst case, such properties might reference assets that are then pulled into the final build, taking up space on the storage device and in memory – but never used.\n\nOverrides are now flagged as unused for:\n• Unknown Property Paths (which are not subject to scripted FormerlySerializedAsAttribute usage);\n\nAsset Hunter PRO — solution for cleaning your project from garbage and missing elements.\n\nThe most massive performance boost you can get by disabling the Depth and Opaque textures creation using the Universal Render Pipeline (URP). It’s very effective for AR/VR.\n\nActually, I don’t use Unreal Engine. While there has been a tendency for years to hate Unity engine by “guru” programmers, Unity engine itself remains the #1 game engine in the world in popularity.\n\nI create mobile games and apps, and I don’t need a powerful laptop for these purposes.\n\nAn obvious reason why I continue to work with Unity Engine is the impossibility of comfortable work of the Unreal Engine 5 on weak laptops.\n\nUnity Editor behaves more optimized, and does not run all the fans at full power in a standard FPS scene. So my choice is Unity ❤️.\n\nOptimize Unity Game with the thought in your head that each project is unique and the performance issues found in them are unique as well. Learning the usage of the tools provided helps immensely in finding and understanding these issues.\n\nUnity Optimization Process should be started in a project lifetime as soon as there is something to optimize. This should be done before there are too much to change if big changes are needed. However, over-optimization can also be an issue.\n\nRemember to not spend time optimizing what doesn’t provide much performance gain.\n\nWhen starting a project, take some time to consider some baseline practices for the assets created for the project:\n• Do you really need those 2K textures for your mobile game?\n• Does it really need these complicated calculations done every frame?\n\nChanges to an already existing asset or code can be tedious and take a long time to do. Doing them before the project has grown too large to handle can save a lot of time."
    }
]