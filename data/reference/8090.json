[
    {
        "link": "https://postgresql.org/docs/current/sql-altertable.html",
        "document": "This form changes the type of a column of a table. Indexes and simple table constraints involving the column will be automatically converted to use the new column type by reparsing the originally supplied expression. The optional clause specifies a collation for the new column; if omitted, the collation is the default for the new column type. The optional clause specifies how to compute the new column value from the old; if omitted, the default conversion is the same as an assignment cast from old data type to new. A clause must be provided if there is no implicit or assignment cast from old to new type. When this form is used, the column's statistics are removed, so running on the table afterwards is recommended.\n\nThese forms change whether a column is marked to allow null values or to reject null values. may only be applied to a column provided none of the records in the table contain a value for the column. Ordinarily this is checked during the by scanning the entire table; however, if a valid constraint is found which proves no can exist, then the table scan is skipped. If this table is a partition, one cannot perform on a column if it is marked in the parent table. To drop the constraint from all the partitions, perform on the parent table. Even if there is no constraint on the parent, such a constraint can still be added to individual partitions, if desired; that is, the children can disallow nulls even if the parent allows them, but not the other way around.\n\nThis form sets or resets per-attribute options. Currently, the only defined per-attribute options are and , which override the number-of-distinct-values estimates made by subsequent operations. affects the statistics for the table itself, while affects the statistics gathered for the table plus its inheritance children. When set to a positive value, will assume that the column contains exactly the specified number of distinct nonnull values. When set to a negative value, which must be greater than or equal to -1, will assume that the number of distinct nonnull values in the column is linear in the size of the table; the exact count is to be computed by multiplying the estimated table size by the absolute value of the given number. For example, a value of -1 implies that all values in the column are distinct, while a value of -0.5 implies that each value appears twice on the average. This can be useful when the size of the table changes over time, since the multiplication by the number of rows in the table is not performed until query planning time. Specify a value of 0 to revert to estimating the number of distinct values normally. For more information on the use of statistics by the PostgreSQL query planner, refer to Section 14.2.\n\nThis form adds a new constraint to a table using the same constraint syntax as , plus the option , which is currently only allowed for foreign key and CHECK constraints. Normally, this form will cause a scan of the table to verify that all existing rows in the table satisfy the new constraint. But if the option is used, this potentially-lengthy scan is skipped. The constraint will still be enforced against subsequent inserts or updates (that is, they'll fail unless there is a matching row in the referenced table, in the case of foreign keys, or they'll fail unless the new row matches the specified check condition). But the database will not assume that the constraint holds for all rows in the table, until it is validated by using the option. See Notes below for more information about using the option. Although most forms of require an lock, requires only a lock. Note that also acquires a lock on the referenced table, in addition to the lock on the table on which the constraint is declared. Additional restrictions apply when unique or primary key constraints are added to partitioned tables; see . Also, foreign key constraints on partitioned tables may not be declared at present.\n\nThis form adds a new or constraint to a table based on an existing unique index. All the columns of the index will be included in the constraint. The index cannot have expression columns nor be a partial index. Also, it must be a b-tree index with default sort ordering. These restrictions ensure that the index is equivalent to one that would be built by a regular or command. If is specified, and the index's columns are not already marked , then this command will attempt to do against each such column. That requires a full table scan to verify the column(s) contain no nulls. In all other cases, this is a fast operation. If a constraint name is provided then the index will be renamed to match the constraint name. Otherwise the constraint will be named the same as the index. After this command is executed, the index is “owned” by the constraint, in the same way as if the index had been built by a regular or command. In particular, dropping the constraint will make the index disappear too. This form is not currently supported on partitioned tables. Adding a constraint using an existing index can be helpful in situations where a new constraint needs to be added without blocking table updates for a long time. To do that, create the index using , and then convert it to a constraint using this syntax. See the example below.\n\nThese forms configure the firing of trigger(s) belonging to the table. A disabled trigger is still known to the system, but is not executed when its triggering event occurs. (For a deferred trigger, the enable status is checked when the event occurs, not when the trigger function is actually executed.) One can disable or enable a single trigger specified by name, or all triggers on the table, or only user triggers (this option excludes internally generated constraint triggers, such as those that are used to implement foreign key constraints or deferrable uniqueness and exclusion constraints). Disabling or enabling internally generated constraint triggers requires superuser privileges; it should be done with caution since of course the integrity of the constraint cannot be guaranteed if the triggers are not executed. The trigger firing mechanism is also affected by the configuration variable session_replication_role. Simply enabled triggers (the default) will fire when the replication role is “origin” (the default) or “local”. Triggers configured as will only fire if the session is in “replica” mode, and triggers configured as will fire regardless of the current replication role. The effect of this mechanism is that in the default configuration, triggers do not fire on replicas. This is useful because if a trigger is used on the origin to propagate data between tables, then the replication system will also replicate the propagated data; so the trigger should not fire a second time on the replica, because that would lead to duplication. However, if a trigger is used for another purpose such as creating external alerts, then it might be appropriate to set it to so that it is also fired on replicas. When this command is applied to a partitioned table, the states of corresponding clone triggers in the partitions are updated too, unless is specified.\n\nThis form attaches an existing table (which might itself be partitioned) as a partition of the target table. The table can be attached as a partition for specific values using or as a default partition by using . For each index in the target table, a corresponding one will be created in the attached table; or, if an equivalent index already exists, it will be attached to the target table's index, as if had been executed. Note that if the existing table is a foreign table, it is currently not allowed to attach the table as a partition of the target table if there are indexes on the target table. (See also CREATE FOREIGN TABLE.) For each user-defined row-level trigger that exists in the target table, a corresponding one is created in the attached table. A partition using uses same syntax for as . The partition bound specification must correspond to the partitioning strategy and partition key of the target table. The table to be attached must have all the same columns as the target table and no more; moreover, the column types must also match. Also, it must have all the and constraints of the target table, not marked . Currently constraints are not considered. and constraints from the parent table will be created in the partition, if they don't already exist. If the new partition is a regular table, a full table scan is performed to check that existing rows in the table do not violate the partition constraint. It is possible to avoid this scan by adding a valid constraint to the table that allows only rows satisfying the desired partition constraint before running this command. The constraint will be used to determine that the table need not be scanned to validate the partition constraint. This does not work, however, if any of the partition keys is an expression and the partition does not accept values. If attaching a list partition that will not accept values, also add a constraint to the partition key column, unless it's an expression. If the new partition is a foreign table, nothing is done to verify that all the rows in the foreign table obey the partition constraint. (See the discussion in CREATE FOREIGN TABLE about constraints on the foreign table.) When a table has a default partition, defining a new partition changes the partition constraint for the default partition. The default partition can't contain any rows that would need to be moved to the new partition, and will be scanned to verify that none are present. This scan, like the scan of the new partition, can be avoided if an appropriate constraint is present. Also like the scan of the new partition, it is always skipped when the default partition is a foreign table. Attaching a partition acquires a lock on the parent table, in addition to the locks on the table being attached and on the default partition (if any). Further locks must also be held on all sub-partitions if the table being attached is itself a partitioned table. Likewise if the default partition is itself a partitioned table. The locking of the sub-partitions can be avoided by adding a constraint as described in Section 5.12.2.2.\n\nThis form detaches the specified partition of the target table. The detached partition continues to exist as a standalone table, but no longer has any ties to the table from which it was detached. Any indexes that were attached to the target table's indexes are detached. Any triggers that were created as clones of those in the target table are removed. lock is obtained on any tables that reference this partitioned table in foreign key constraints. If is specified, it runs using a reduced lock level to avoid blocking other sessions that might be accessing the partitioned table. In this mode, two transactions are used internally. During the first transaction, a lock is taken on both parent table and partition, and the partition is marked as undergoing detach; at that point, the transaction is committed and all other transactions using the partitioned table are waited for. Once all those transactions have completed, the second transaction acquires on the partitioned table and on the partition, and the detach process completes. A constraint that duplicates the partition constraint is added to the partition. cannot be run in a transaction block and is not allowed if the partitioned table contains a default partition. If is specified, a previous invocation that was canceled or interrupted is completed. At most one partition in a partitioned table can be pending detach at a time."
    },
    {
        "link": "https://stackoverflow.com/questions/8330357/trying-to-modify-a-constraint-in-postgresql",
        "document": "As of version 9.4, PostgreSQL supports for foreign keys.\n\nThis features will \"Allow constraint attributes to be altered, so the default setting of NOT DEFERRABLE can be altered to DEFERRABLE and back.\" Looking at your question I think that is (kind of) what you have been looking for.\n\nMore detailed information and an example can be found here:\n\n http://www.depesz.com/2013/06/30/waiting-for-9-4-alter-table-alter-constraint-for-fks/"
    },
    {
        "link": "https://postgresql.org/docs/current/ddl-alter.html",
        "document": "When you create a table and you realize that you made a mistake, or the requirements of the application change, you can drop the table and create it again. But this is not a convenient option if the table is already filled with data, or if the table is referenced by other database objects (for instance a foreign key constraint). Therefore PostgreSQL provides a family of commands to make modifications to existing tables. Note that this is conceptually distinct from altering the data contained in the table: here we are interested in altering the definition, or structure, of the table.\n\nAll these actions are performed using the ALTER TABLE command, whose reference page contains details beyond those given here.\n\nTo add a column, use a command like: The new column is initially filled with whatever default value is given (null if you don't specify a clause). From PostgreSQL 11, adding a column with a constant default value no longer means that each row of the table needs to be updated when the statement is executed. Instead, the default value will be returned the next time the row is accessed, and applied when the table is rewritten, making the very fast even on large tables. However, if the default value is volatile (e.g., ) each row will need to be updated with the value calculated at the time is executed. To avoid a potentially lengthy update operation, particularly if you intend to fill the column with mostly nondefault values anyway, it may be preferable to add the column with no default, insert the correct values using , and then add any desired default as described below. You can also define constraints on the column at the same time, using the usual syntax: In fact all the options that can be applied to a column description in can be used here. Keep in mind however that the default value must satisfy the given constraints, or the will fail. Alternatively, you can add constraints later (see below) after you've filled in the new column correctly.\n\nTo remove a column, use a command like: Whatever data was in the column disappears. Table constraints involving the column are dropped, too. However, if the column is referenced by a foreign key constraint of another table, PostgreSQL will not silently drop that constraint. You can authorize dropping everything that depends on the column by adding : See Section 5.15 for a description of the general mechanism behind this.\n\nTo add a constraint, the table constraint syntax is used. For example: To add a not-null constraint, which cannot be written as a table constraint, use this syntax: The constraint will be checked immediately, so the table data must satisfy the constraint before it can be added.\n\nTo remove a constraint you need to know its name. If you gave it a name then that's easy. Otherwise the system assigned a generated name, which you need to find out. The psql command can be helpful here; other interfaces might also provide a way to inspect table details. Then the command is: As with dropping a column, you need to add if you want to drop a constraint that something else depends on. An example is that a foreign key constraint depends on a unique or primary key constraint on the referenced column(s). This works the same for all constraint types except not-null constraints. To drop a not-null constraint use:\n\nTo set a new default for a column, use a command like: Note that this doesn't affect any existing rows in the table, it just changes the default for future commands. To remove any default value, use: This is effectively the same as setting the default to null. As a consequence, it is not an error to drop a default where one hadn't been defined, because the default is implicitly the null value."
    },
    {
        "link": "https://geeksforgeeks.org/postgresql-alter-table",
        "document": "In PostgreSQL, the statement is a powerful and essential tool that allows us to modify the structure of an existing table to meet evolving database needs. With PostgreSQL ALTER TABLE, we can perform various modifications on the table without disrupting the ongoing operations of our database.\n\nIn this article, we will explain the core functionalities of the ALTER TABLE command in PostgreSQL, providing clear examples and best practices to enhance our database management. Whether we’re adding or dropping columns, renaming them, or setting constraints, this guide will walk us through each operation step-by-step.\n\nPostgreSQL ALTER TABLE is a DDL (Data Definition Language) command used to modify an existing table’s structure. With , we can add new columns, drop columns, rename columns, modify constraints, and much more. These operations are performed while the table remains in use, ensuring minimal disruption to our database’s functionality.\n• is the name of the table we want to modify.\n• defines the type of modification you wish to perform on the table, such as adding, dropping, or modifying columns\n\nPostgreSQL supports several types of actions that can be performed using the ALTER TABLE statement. Let’s look into each of these actions with examples.\n\nTo add a new column to an existing table, use the ‘ADD COLUMN’ action. This is particularly useful when we need to store additional data in our table.\n\nSuppose we have a table named ‘links’, and we want to add a new boolean column named ‘active’:\n\nIf a column is no longer needed, you can remove it using the ‘DROP COLUMN‘ action. This helps keep your table structure clean and relevant to current data requirements.\n\nFor instance, to remove the ‘active’ column from the ‘links’ table:\n\nTo rename a column, use the ‘RENAME COLUMN‘ action. This is useful when the column name needs to better reflect the data it holds.\n\nTo rename the ‘title’ column to ‘link_title’ in the ‘links’ table:\n\n4. Changing the Default Value of a Column\n\nWe can modify the default value of a column using the ‘ALTER COLUMN’ action. This is helpful when the default value needs to be updated to meet new business rules.\n\nTo set the default value of the ‘ column to ‘ :\n\nTo enforce that a column must have a value, we can add a NOT NULL constraint. Conversely, we can drop this constraint if it’s no longer required.\n\nTo remove the constraint, use:\n\nTo add a constraint to the column:\n\nCHECK constraints allow you to define a condition that the data in a column must meet. This ensures data integrity by restricting the values entered into the column.\n\nTo add a CHECK constraint ensuring that the column must start with ‘http’:\n\nWe can add constraints such as UNIQUE, PRIMARY KEY, or FOREIGN KEY to ensure data integrity and enforce relational rules in our database.\n\nTo add a PRIMARY KEY constraint to the column:\n\nIf we need to change the name of an entire table, we can do so using the RENAME TO action.\n\nIf we want to rename the links table to website_links:\n\nNow let’s look into an example. For the same purpose let’s first create a table (say, ‘links’) that we can alter in our example using the below statement:\n\nNow, let’s add a new column named ‘target’ to this table:\n\nNext, we’ll set ‘_blank’ as the default value for the ‘target’ column:\n\nLet’s insert some data into the ‘links’ table:\n\nFinally, to check the data in the ‘links’ table, use:\n• ‘ALTER TABLE … ADD COLUMN’ without a default value first, and then setting the default in a separate statement to avoid locking the entire table for long periods.\n• None When adding constraints to a table with existing data, PostgreSQL checks the current data against the new constraint. If the data doesn’t satisfy the constraint, the ALTER TABLE\n• None While we can add or drop constraints using ALTER TABLE , modifying an existing constraint directly is not supported. Instead, we must drop the existing constraint and add a new one.\n• ALTER TABLE statement can be applied to both permanent and temporary tables. However, changes to temporary tables are only valid within the session that created them.\n\nThe PostgreSQL ALTER TABLE statement is an essential command for efficiently managing and modifying table structures in PostgreSQL databases. Whether we’re adding, removing, or renaming columns, or setting constraints to enforce data integrity, the ALTER TABLE statement provides the flexibility to adapt to our evolving database needs without disrupting operations.\n\nHow do I alter the table in Postgres?\n\nHow do I edit a table in PostgreSQL?\n\nHow to alter data in PostgreSQL?"
    },
    {
        "link": "https://postgresql.org/docs/7.2/sql-altertable.html",
        "document": "The user name of the new owner of the table.\n\nALTER TABLE changes the definition of an existing table. The form adds a new column to the table using the same syntax as CREATE TABLE. The forms allow you to set or remove the default for the column. Note that defaults only apply to subsequent INSERT commands; they do not cause rows already in the table to change. The form allows you to set the statistics-gathering target for subsequent ANALYZE operations. The clause causes the name of a table, column, index, or sequence to change without changing any of the data. The data will remain of the same type and size after the command is executed. The ADD clause adds a new constraint to the table using the same syntax as CREATE TABLE. The DROP CONSTRAINT clause drops all constraints on the table (and its children) that match . The OWNER clause changes the owner of the table to the user .\n\nYou must own the table in order to change its schema.\n\nThe keyword is noise and can be omitted. In the current implementation of , default and NOT NULL clauses for the new column are not supported. You can use the form of ALTER TABLE to set the default later. (You may also want to update the already existing rows to the new default value, using UPDATE.) In DROP CONSTRAINT, the RESTRICT keyword is required, although dependencies are not yet checked. The CASCADE option is unsupported. Currently DROP CONSTRAINT drops only CHECK constraints. To remove a PRIMARY or UNIQUE constraint, drop the relevant index using the DROP INDEX command. To remove FOREIGN KEY constraints you need to recreate and reload the table, using other parameters to the CREATE TABLE command. For example, to drop all constraints on a table : CREATE TABLE temp AS SELECT * FROM distributors; DROP TABLE distributors; CREATE TABLE distributors AS SELECT * FROM temp; DROP TABLE temp; You must own the table in order to change it. Changing any part of the schema of a system catalog is not permitted. The PostgreSQL User's Guide has further information on inheritance. Refer to CREATE TABLE for a further description of valid arguments."
    },
    {
        "link": "https://dbvis.com/thetable/all-you-need-to-know-about-postgresql-unique-constraint",
        "document": "The PostgreSQL constraint makes sure that each record in our table is identifiable in its own unique way, preventing the creation of duplicate data and further protecting the evenness of our database. In this guide, you will learn what this constrain is, how to use it, and when. Let’s dive in! What Is the UNIQUE PostgreSQL Constraint? The PostgreSQL constraint guarantees that all values in a column or a group of columns are distinct from one another. This means no two rows can have the same value(s) in the specified column(s). The primary characteristics of a constraint are:\n• None Ensuring Uniqueness: Each value in the column or a set of columns is unique.\n• None Nullability: Unlike primary keys, columns with the constraints can contain values, but s are not considered equal to other s. Unique constraints can be defined on a single column or a combination of multiple columns, known as a composite unique constraint. This flexibility allows us to tailor our data model to our specific requirements, assuring that unique business rules are enforced at the database level. How to Use the PostgreSQL UNIQUE Constraint Defining a PostgreSQL constraint is pretty straightforward. When it is applied on a column constraint in a query, the syntax is:\n\nThis indicates that, although any one of the columns need not be (and typically isn't) unique, the combination of values in the stated columns must be unique throughout the entire table. You may also call this style of application the composite constraint style. These are the scenarios where a constraint is violated in PostgreSQL:\n• None Trying to insert a new record with a value in a column (or set of columns) that already exists in the table will cause PostgreSQL to throw a unique constraint violation error.\n• None Updating an existing record with a value in a column (or set of columns) that already exists in another row. Now that you know the syntax behind PostgreSQL and how it works, you are ready to explore its use cases. Keep it at the back of your mind that all demonstrations will be done in DbVisualizer—the database client with the highest user satisfaction in the market, and the only database client that is capable of doing this —Joking haha! Any other database client can take care of this. The statement below creates a table with a constraint on the column.\n\nPreviously, we said that the PostgreSQL constraint is violated and will throw an error if you try to insert a new record with a value in a column (or set of columns) that already exists in the table, right? Let’s test this rule to see if indeed, PostgreSQL will throw this constraint violation error - we got all the time in the world, and the best database client on our side! First, populate the table with data with this statement👇🏽\n\nAnd indeed, PostgreSQL issues an error. Use Case #2 - Implementing a Unique Constraint on a Group of Columns We’ve also learned that the unique constraints can be applied to a combination of columns and this is known as a composite unique constraint. This can be particularly useful when you need to ensure the uniqueness of a set of values, rather than a single column only. Assuming you have a table where you are monitoring order details and want to ensure that every order is distinct using the combination of and :\n\nConsider the following best practices when working with constraints in PostgreSQL:\n• None Evaluate whether a single-column unique constraint or a composite unique constraint better suits your data model and business requirements.\n• None constraints automatically create indexes to enforce uniqueness, but you can also manually create indexes to further constraints automatically create indexes to enforce uniqueness, but you can also manually create indexes to further optimize query performance\n• None In your application, be prepared to handle unique constraint violations and provide meaningful feedback to users when they attempt to insert duplicate data. Both primary keys and constraints enforce the uniqueness of our database records. However, there are some subtle distinctions you must know: Do not allow values Creates a non-clustered index which does not affect the physical order of the table data Create a clustered index that affects the physical order of the table data A table can have only one primary key constraint. NB: Only use the constraint when you need to ensure the uniqueness of your db records without the restrictions imposed by primary keys. In this blog, we have looked at the constraint in PostgreSQL, its power syntax, how to use it and every other thing - not excluding the its violation rules. To better appreciate the power of this constraint, you need a tool that helps you manage databases and visually explore query results. This is where a full-featured database client like DbVisualizer comes in. In addition to being able to connect to several DBMSs, it offers advanced query optimization functionality and full support for all database features. Download DbVisualizer for free now! It will surprise you with many things. Take an expo of all of our features, the Pro version of DbVisualizer is free for 21 days. What is the UNIQUE constraint in PostgreSQL? The constraint in PostgreSQL ensures that the values in a column (or a set of columns) are unique across all rows in a table, meaning you cannot have duplicate values in the column(s) with this constraint. Creating it is simple. You can create a PostgreSQL constraint using any of the following ways: During the creation of a new table:\n\nYes, a constraint in PostgreSQL allows values. You can have multiple rows where all columns in the constraint are , and it won't cause a violation error. Can I have multiple UNIQUE constraints on a single table? Yes, you can have multiple constraints on a single table in PostgreSQL. Each constraint applies to a specific column or a set of columns."
    },
    {
        "link": "https://stackoverflow.com/questions/635937/how-do-i-specify-unique-constraint-for-multiple-columns-in-mysql",
        "document": "To add a unique constraint, you need to use two components:\n\n- to change the table schema and,\n\nYou then can define your new unique key with the format\n\nSo for your particular issue, you could use this command:"
    },
    {
        "link": "https://postgresql.org/docs/current/ddl-constraints.html",
        "document": "Data types are a way to limit the kind of data that can be stored in a table. For many applications, however, the constraint they provide is too coarse. For example, a column containing a product price should probably only accept positive values. But there is no standard data type that accepts only positive numbers. Another issue is that you might want to constrain column data with respect to other columns or rows. For example, in a table containing product information, there should be only one row for each product number.\n\nTo that end, SQL allows you to define constraints on columns and tables. Constraints give you as much control over the data in your tables as you wish. If a user attempts to store data in a column that would violate a constraint, an error is raised. This applies even if the value came from the default value definition.\n\nA check constraint is the most generic constraint type. It allows you to specify that the value in a certain column must satisfy a Boolean (truth-value) expression. For instance, to require positive product prices, you could use: As you see, the constraint definition comes after the data type, just like default value definitions. Default values and constraints can be listed in any order. A check constraint consists of the key word followed by an expression in parentheses. The check constraint expression should involve the column thus constrained, otherwise the constraint would not make too much sense. You can also give the constraint a separate name. This clarifies error messages and allows you to refer to the constraint when you need to change it. The syntax is: So, to specify a named constraint, use the key word followed by an identifier followed by the constraint definition. (If you don't specify a constraint name in this way, the system chooses a name for you.) A check constraint can also refer to several columns. Say you store a regular price and a discounted price, and you want to ensure that the discounted price is lower than the regular price: The first two constraints should look familiar. The third one uses a new syntax. It is not attached to a particular column, instead it appears as a separate item in the comma-separated column list. Column definitions and these constraint definitions can be listed in mixed order. We say that the first two constraints are column constraints, whereas the third one is a table constraint because it is written separately from any one column definition. Column constraints can also be written as table constraints, while the reverse is not necessarily possible, since a column constraint is supposed to refer to only the column it is attached to. (PostgreSQL doesn't enforce that rule, but you should follow it if you want your table definitions to work with other database systems.) The above example could also be written as: Names can be assigned to table constraints in the same way as column constraints: It should be noted that a check constraint is satisfied if the check expression evaluates to true or the null value. Since most expressions will evaluate to the null value if any operand is null, they will not prevent null values in the constrained columns. To ensure that a column does not contain null values, the not-null constraint described in the next section can be used. PostgreSQL does not support constraints that reference table data other than the new or updated row being checked. While a constraint that violates this rule may appear to work in simple tests, it cannot guarantee that the database will not reach a state in which the constraint condition is false (due to subsequent changes of the other row(s) involved). This would cause a database dump and restore to fail. The restore could fail even when the complete database state is consistent with the constraint, due to rows not being loaded in an order that will satisfy the constraint. If possible, use , , or constraints to express cross-row and cross-table restrictions. If what you desire is a one-time check against other rows at row insertion, rather than a continuously-maintained consistency guarantee, a custom trigger can be used to implement that. (This approach avoids the dump/restore problem because pg_dump does not reinstall triggers until after restoring data, so that the check will not be enforced during a dump/restore.) PostgreSQL assumes that constraints' conditions are immutable, that is, they will always give the same result for the same input row. This assumption is what justifies examining constraints only when rows are inserted or updated, and not at other times. (The warning above about not referencing other table data is really a special case of this restriction.) An example of a common way to break this assumption is to reference a user-defined function in a expression, and then change the behavior of that function. PostgreSQL does not disallow that, but it will not notice if there are rows in the table that now violate the constraint. That would cause a subsequent database dump and restore to fail. The recommended way to handle such a change is to drop the constraint (using ), adjust the function definition, and re-add the constraint, thereby rechecking it against all table rows.\n\nA not-null constraint simply specifies that a column must not assume the null value. A syntax example: A not-null constraint is always written as a column constraint. A not-null constraint is functionally equivalent to creating a check constraint , but in PostgreSQL creating an explicit not-null constraint is more efficient. The drawback is that you cannot give explicit names to not-null constraints created this way. Of course, a column can have more than one constraint. Just write the constraints one after another: CREATE TABLE products ( product_no integer NOT NULL, name text NOT NULL, price numeric NOT NULL CHECK (price > 0) ); The order doesn't matter. It does not necessarily determine in which order the constraints are checked. The constraint has an inverse: the constraint. This does not mean that the column must be null, which would surely be useless. Instead, this simply selects the default behavior that the column might be null. The constraint is not present in the SQL standard and should not be used in portable applications. (It was only added to PostgreSQL to be compatible with some other database systems.) Some users, however, like it because it makes it easy to toggle the constraint in a script file. For example, you could start with: and then insert the key word where desired. In most database designs the majority of columns should be marked not null.\n\nUnique constraints ensure that the data contained in a column, or a group of columns, is unique among all the rows in the table. The syntax is: when written as a column constraint, and: To define a unique constraint for a group of columns, write it as a table constraint with the column names separated by commas: This specifies that the combination of values in the indicated columns is unique across the whole table, though any one of the columns need not be (and ordinarily isn't) unique. You can assign your own name for a unique constraint, in the usual way: Adding a unique constraint will automatically create a unique B-tree index on the column or group of columns listed in the constraint. A uniqueness restriction covering only some rows cannot be written as a unique constraint, but it is possible to enforce such a restriction by creating a unique partial index. In general, a unique constraint is violated if there is more than one row in the table where the values of all of the columns included in the constraint are equal. By default, two null values are not considered equal in this comparison. That means even in the presence of a unique constraint it is possible to store duplicate rows that contain a null value in at least one of the constrained columns. This behavior can be changed by adding the clause , like The default behavior can be specified explicitly using . The default null treatment in unique constraints is implementation-defined according to the SQL standard, and other implementations have a different behavior. So be careful when developing applications that are intended to be portable.\n\nA primary key constraint indicates that a column, or group of columns, can be used as a unique identifier for rows in the table. This requires that the values be both unique and not null. So, the following two table definitions accept the same data: Primary keys can span more than one column; the syntax is similar to unique constraints: Adding a primary key will automatically create a unique B-tree index on the column or group of columns listed in the primary key, and will force the column(s) to be marked . A table can have at most one primary key. (There can be any number of unique and not-null constraints, which are functionally almost the same thing, but only one can be identified as the primary key.) Relational database theory dictates that every table must have a primary key. This rule is not enforced by PostgreSQL, but it is usually best to follow it. Primary keys are useful both for documentation purposes and for client applications. For example, a GUI application that allows modifying row values probably needs to know the primary key of a table to be able to identify rows uniquely. There are also various ways in which the database system makes use of a primary key if one has been declared; for example, the primary key defines the default target column(s) for foreign keys referencing its table.\n\nA foreign key constraint specifies that the values in a column (or a group of columns) must match the values appearing in some row of another table. We say this maintains the referential integrity between two related tables. Say you have the product table that we have used several times already: Let's also assume you have a table storing orders of those products. We want to ensure that the orders table only contains orders of products that actually exist. So we define a foreign key constraint in the orders table that references the products table: Now it is impossible to create orders with non-NULL entries that do not appear in the products table. We say that in this situation the orders table is the referencing table and the products table is the referenced table. Similarly, there are referencing and referenced columns. You can also shorten the above command to: because in absence of a column list the primary key of the referenced table is used as the referenced column(s). You can assign your own name for a foreign key constraint, in the usual way. A foreign key can also constrain and reference a group of columns. As usual, it then needs to be written in table constraint form. Here is a contrived syntax example: Of course, the number and type of the constrained columns need to match the number and type of the referenced columns. Sometimes it is useful for the “other table” of a foreign key constraint to be the same table; this is called a self-referential foreign key. For example, if you want rows of a table to represent nodes of a tree structure, you could write A top-level node would have NULL , while non-NULL entries would be constrained to reference valid rows of the table. A table can have more than one foreign key constraint. This is used to implement many-to-many relationships between tables. Say you have tables about products and orders, but now you want to allow one order to contain possibly many products (which the structure above did not allow). You could use this table structure: Notice that the primary key overlaps with the foreign keys in the last table. We know that the foreign keys disallow creation of orders that do not relate to any products. But what if a product is removed after an order is created that references it? SQL allows you to handle that as well. Intuitively, we have a few options:\n• Delete the orders as well To illustrate this, let's implement the following policy on the many-to-many relationship example above: when someone wants to remove a product that is still referenced by an order (via ), we disallow it. If someone removes an order, the order items are removed as well: Restricting and cascading deletes are the two most common options. prevents deletion of a referenced row. means that if any referencing rows still exist when the constraint is checked, an error is raised; this is the default behavior if you do not specify anything. (The essential difference between these two choices is that allows the check to be deferred until later in the transaction, whereas does not.) specifies that when a referenced row is deleted, row(s) referencing it should be automatically deleted as well. There are two other options: and . These cause the referencing column(s) in the referencing row(s) to be set to nulls or their default values, respectively, when the referenced row is deleted. Note that these do not excuse you from observing any constraints. For example, if an action specifies but the default value would not satisfy the foreign key constraint, the operation will fail. The appropriate choice of action depends on what kinds of objects the related tables represent. When the referencing table represents something that is a component of what is represented by the referenced table and cannot exist independently, then could be appropriate. If the two tables represent independent objects, then or is more appropriate; an application that actually wants to delete both objects would then have to be explicit about this and run two delete commands. In the above example, order items are part of an order, and it is convenient if they are deleted automatically if an order is deleted. But products and orders are different things, and so making a deletion of a product automatically cause the deletion of some order items could be considered problematic. The actions or can be appropriate if a foreign-key relationship represents optional information. For example, if the products table contained a reference to a product manager, and the product manager entry gets deleted, then setting the product's product manager to null or a default might be useful. The actions and can take a column list to specify which columns to set. Normally, all columns of the foreign-key constraint are set; setting only a subset is useful in some special cases. Consider the following example: CREATE TABLE tenants ( tenant_id integer PRIMARY KEY ); CREATE TABLE users ( tenant_id integer REFERENCES tenants ON DELETE CASCADE, user_id integer NOT NULL, PRIMARY KEY (tenant_id, user_id) ); CREATE TABLE posts ( tenant_id integer REFERENCES tenants ON DELETE CASCADE, post_id integer NOT NULL, author_id integer, PRIMARY KEY (tenant_id, post_id), FOREIGN KEY (tenant_id, author_id) REFERENCES users ON DELETE SET NULL ); Without the specification of the column, the foreign key would also set the column to null, but that column is still required as part of the primary key. Analogous to there is also which is invoked when a referenced column is changed (updated). The possible actions are the same, except that column lists cannot be specified for and . In this case, means that the updated values of the referenced column(s) should be copied into the referencing row(s). Normally, a referencing row need not satisfy the foreign key constraint if any of its referencing columns are null. If is added to the foreign key declaration, a referencing row escapes satisfying the constraint only if all its referencing columns are null (so a mix of null and non-null values is guaranteed to fail a constraint). If you don't want referencing rows to be able to avoid satisfying the foreign key constraint, declare the referencing column(s) as . A foreign key must reference columns that either are a primary key or form a unique constraint, or are columns from a non-partial unique index. This means that the referenced columns always have an index to allow efficient lookups on whether a referencing row has a match. Since a of a row from the referenced table or an of a referenced column will require a scan of the referencing table for rows matching the old value, it is often a good idea to index the referencing columns too. Because this is not always needed, and there are many choices available on how to index, the declaration of a foreign key constraint does not automatically create an index on the referencing columns. More information about updating and deleting data is in Chapter 6. Also see the description of foreign key constraint syntax in the reference documentation for CREATE TABLE."
    },
    {
        "link": "https://stackoverflow.com/questions/23542794/postgres-unique-constraint-vs-index",
        "document": "I had some doubts about this basic but important issue, so I decided to learn by example.\n\nLet's create test table master with two columns, con_id with unique constraint and ind_id indexed by unique index.\n\nIn table description (\\d in psql) you can tell unique constraint from unique index.\n\nNow we'll define detail table with two foreign keys referencing to our two columns in master.\n\nWell, no errors. Let's make sure it works.\n\nBoth columns can be referenced in foreign keys.\n\nYou can add table constraint using existing unique index.\n\nNow there is no difference between column constraints description.\n\nIn table constraint declaration you cannot create partial indexes. It comes directly from the definition of . In unique index declaration you can set to create partial index. You can also create index on expression (not only on column) and define some other parameters (collation, sort order, NULLs placement).\n\nYou cannot add table constraint using partial index."
    },
    {
        "link": "https://dba.stackexchange.com/questions/144/when-should-i-use-a-unique-constraint-instead-of-a-unique-index",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    }
]