[
    {
        "link": "https://reference.wolfram.com/language/ref/ImageData.html.en",
        "document": "ImageData and Raster assume a different ordering of the rows:\n\nTo visualize image data using Raster, the rows need to be reversed:"
    },
    {
        "link": "https://reference.wolfram.com/language/ref/Image",
        "document": "The value of a system option \"IndeterminateValue\" is used to replace values that cannot be stored in an image including ComplexInfinity and Indeterminate.\n\nBy default, 0 is used:\n\nSee the behavior using power:\n\nChange the current value of the \"IndeterminateValue\" option:"
    },
    {
        "link": "https://reference.wolfram.com/language/tutorial/ImageProcessing.html",
        "document": "give the pixel dimensions of the raster associated with give the ratio of height to width of give the number of channels present in the data for give the color space associated with give the type of values used for each pixel element in if has the form of a valid object and otherwise give the list of default options assigned to a symbol the array of pixel values in\n\nconveniently complements . Instead of specifying the exact number of rows or columns to be extracted, it allows you to define the desired dimensions of the resulting image, namely, the number of rows or columns that are to be retained. By default, the cropping operation is centered, thus an equal number of rows and columns is deleted from the edges of the image. conveniently complements. Instead of specifying the exact number of rows or columns to be extracted, it allows you to define the desired dimensions of the resulting image, namely, the number of rows or columns that are to be retained. By default, the cropping operation is centered, thus an equal number of rows and columns is deleted from the edges of the image.\n\nis another common spatial operation. It results in an image whose pixel positions are all rotated counterclockwise with respect to a pivot point centered on the image. is another common spatial operation. It results in an image whose pixel positions are all rotated counterclockwise with respect to a pivot point centered on the image.\n\ngive a list of pixel values and counts for each channel in plot a histogram of the pixel levels for each channel in\n\napply to the range of each pixel in each channel of give the convolution of with kernel\n\nreplace every value by the mean value in its range replace every value by the median in its range replace every value by the minimum in its range replace each pixel with the most common pixel value in its range\n\ngive the fixed point of the geodesic dilation of the image constrained by the image give the fixed point of the geodesic erosion of the image constrained by the image give the distance transform of in which the value of each pixel is replaced by its distance to the nearest background pixel give an array in which each pixel of is replaced by an integer index representing the connected foreground image component in which the pixel lies"
    },
    {
        "link": "https://mathematica.stackexchange.com/questions/87936/imagetype-used-by-imagedata",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://mathematica.stackexchange.com/questions/108449/imagedata-to-image-conversion",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://reference.wolfram.com/language/ref/BitXor.html.en",
        "document": "Enable JavaScript to interact with content and submit forms on Wolfram websites. Learn how"
    },
    {
        "link": "https://reference.wolfram.com/language/guide/BitwiseOperations.html.en",
        "document": "The Wolfram Language can represent bit vectors of arbitrary length as integers, and uses highly optimized algorithms—including several original to Wolfram Research—to perform bitwise operations with maximal efficiency on all standard computer systems.\n\nFromDigits — convert to an integer from a list of digits"
    },
    {
        "link": "https://rosettacode.org/wiki/Bitwise_operations",
        "document": "Write a routine to perform a bitwise AND, OR, and XOR on two integers, a bitwise NOT on the first integer, a left shift, right shift, right arithmetic shift, left rotate, and right rotate.\n\nAll shifts and rotates should be done on the first integer with a shift/rotate amount of the second integer.\n\nIf any operation is not available in your language, note it. \n\n\n\n\n\nBitwise operations are done using the accumulator and an immediate constant (prefixed with #) or a value at a specified memory location (no #.)\n\nThe 6502 doesn't have arithmetic shift right, but it can be replicated, provided the negative flag is set according to the value in the accumulator.\n\nThe 6502 can only rotate a value by one, not an arbitrary number. A looping routine is needed for rotates larger than 1. Also, the 6502's and rotate instructions both rotate through the carry, unlike the instructions on other architectures with the same name. (68000, x86, and ARM all have a \"ROR\" command but it doesn't rotate through the carry on those CPUs.)\n\nInteger one is assumed to be a, integer two assumed to be b. Each operation affects one or both operands and would not be used sequentially. The end result of each operation resides in a. The shift and rotate operations should likely push psw and pop psw because they affect the carry flag.\n\nLike with most 68000 commands, you can specify a length parameter. Anything outside that length is unaffected by the operation.\n\nThis works in ABAP 7.40 and above. The missing arithmetic shift operations have been implemented with arithmetic, whereas the logical shift and the rotate operations have been implemented using the built in string functions shift_left and shift_right.\n\nUnlisted operations are not available\n\nThe following program performs all required operations and prints the resulting values in base 2 for easy checking of the bit values.\n\nThere is no rotate support built in to Aikido.\n\nAside from decimal, ALGOL 68 has 5 different alternative was of representing the number 170:\n• and as an array of BOOL: FFFFFFFFFFFFFFFFFFFFFFFFTFTFTFTF\n\nNote that an INT can be widened into BITS, and BITS can be widened into an array of BOOL. eg:\n\nApplescript has no bitwise operators. It's probably not the right tool to reach for if you need to work with bits.\n\nIf we really do need to use Applescript for bitwise operations, two immediate possibilities come to mind:\n• We can use JavaScript operators through an ObjC bridge to JavaScript for Automation, or\n• we can write our own functions – converting between 32-bit signed integers and corresponding lists of booleans, and performing the bitwise operations on the boolean lists before converting back to integers.\n\n\n\n First option – 'dialling out to JavaScript for Automation':\n\nThis is feasible, (see below) subject to the limitations that:\n• in the case of the JS left shift operator (<<) the right operand needs to be masked with 0x1F (31), which is its maximum effective value.\n\n\n\n Second option – writing our own bitwise functions for Applescript:\n\n's 's -- bindLR (>>=) :: Either a -> (a -> Either b) -> Either b 's -- 'The mapAccumR function behaves like a combination of map and foldr; -- it applies a function to each element of a list, passing an accumulating -- parameter from |Right| to |Left|, and returning a final value of this -- accumulator together with the new list.' (see Hoogle) -- stages of doubling to an accumulator where needed for binary\n\nA third option is the mathematical one, although it still involves looping through the hypothetical bits where two numbers are involved, unless I've missed a trick. The handlers below all assume positive number inputs (except for arithmeticRightShift()) and attempt to return results of class integer. The \"hi bits\" of numbers which don't fit the specified register sizes are discarded.\n\nStandard awk does not have bitwise operators. Gawk has built-in functions for many bitwise operations. No rotation of bits.\n\nOpenBSD (a variant of nawk) has these same functions, with a few differences. Gawk uses 53-bit unsigned integers, but OpenBSD awk uses 32-bit signed integers. Therefore Gawk prints , but OpenBSD awk prints .\n\nNote that the symbols for AND, OR, and XOR are the stat plot marks near the bottom of the Catalog.\n\nIn Babel, we prefix the logic operators with a 'c' to denote that they are C-style operations, that is, they are word-width operations, not arbitrary size operations. The following program combines the numbers 5 and 9 using the various bitwise operators and then displays the results.\n\nThe cnot operator works on just one operand:\n\nQuickBasic does not have shift or rotate operations defined. Here are the logical operations:\n\nFreeBASIC does not have rotate operators. Shift Right operator performs arithmetic shift if the left value is signed number and logical shift if the left value is unsigned number.\n\nCommodore BASIC V2.0 does not have XOR, left shift, right shift, right arithmetic shift, left rotate, and right rotate operators. In this implementation the XOR operation is done with an equivalent formula.\n\nZX81 BASIC has no integer type (a major lacuna) and consequently no bitwise operations; but the CPU has them, so we can use a tiny machine code routine to do the actual work and then return to BASIC to print the answers.\n\nThis program is a proof of concept, really, and will only work with 8-bit values. In addition, with 1k of RAM there is only space for the first of the shifts/rotates; the others could be implemented along exactly the same lines.\n\nThe disassembly of the Z80 code would be:\n\nWe then use statements to replace the instruction with each successive operation we want to perform.\n\nNote that the left shift instruction shifts by one bit at a time, so we need a loop. The present program has the loop written in BASIC, because it seemed sensible to use BASIC for anything we could use it for and only drop into machine code when there was no alternative; it would of course be faster to do the whole thing in machine code.\n\nFinally, observe that the first line reserves 15 bytes for our machine code routine by hiding them in a comment.\n\nTiny BASIC has only one data type- the signed 16-bit integer- and no bitwise operations. This code emulates bitwise operations on unsigned 15-bit integers. Since the logic gates AND, NOR, and NXOR are characterised by having exactly two, exactly zero, and exactly one on bit in their inputs, their code is identical except for having a different number of target on bits (line 500 onward). The OR and XOR gates are just NOT NOR and NOT NXOR. The shift and rotate operations are simple divisions and mutiplications by 2, with care taken to avoid overflow, and a carry flag where applicable.\n\nuBasic/4tH provides the most common bitwise operations as functions. It's not too difficult to provide the arithmetic left and right shift operations.\n\nThe SET command with the /A option supports arithmetic and bit operations on signed 8 byte integers.\n\nThe SET /? documentation claims it supports logical shift operations, but in reality it performs an arithmetic right shift.\n\nThe following script (bitops.bat) not only demonstrates the basic bit operations, it also uses bit operations to convert each integral value into a string of 32 binary digits.\n\nThe natural number range for beeswax is unsigned Int64, but it is easy to implement signed Int64 by realizing negative numbers by their 2’s complements or interpreting numbers as negative if their MSB is 1, as shown in the example above.\n\nArithmetic shift right is not originally implemented in beeswax because it does not make sense for unsigned integers, but for negative numbers, it can be realized easily with\n\nIn beeswax, rotate left (ROL) and rotate right (ROT) operators are implemented using modulo 64, so rotations by more than 63 bits wrap around:\n\nThe labelled points (1 to G) are: 1. Read in A and B, 2. Set the current operating row (R) to 4, 3. Set the current bit value (M) to 64, 4. Set Current operating column (C) to 3, 5. Check if M > A (i.e. bit is 0 or 1), 6. Write the bit value into location (R,C), 7. A = A - M, 8. M = M/2, 9. C++, A&B. Storage of corresponding bits, C. Initialise R & C to operation storage (OP) and M to 1, D. Increment OP by M if true, E. M = M*2, F (2 rows below). Print value of OP, increment operation to perform by moving \">\" down, G. If doing the NOT, LSHFT or RSHFT (current operation to perform > 3) only read A.\n\nThe code requires input be separated by spaces and only works for numbers less than 128, due to form of bit storage and ASCII locations not able to store beyond 127. Overflow will happen if 127 is shifted left due to aforementioned ASCII limit in most Befunge-93 interpreters.\n\nTo rotate an integer, you can combine a left shift and a right shift:\n\nWith a smart enough compiler, the above actually compiles into a single machine bit rotate instruction when possible. E.g. on IA32 produced following assembly code:\n\nCOBOL 2002 added support for bitwise operations. Shift and rotation operators were added in COBOL 2023. Results are displayed in decimal.\n\nIn older implementations, non-standard extensions were developed as built-in subroutines.\n\nCoffeeScript provides sugar for some JavaScript operators, but the bitwise operators are taken directly from JS. See more here: http://coffeescript.org/#operators\n\nLeft and right logical shift may be implemented by the following functions:\n\nLeft and right rotation may be implemented by the following functions:\n\nCompilers are usually able to optimize the code pattern of the rot function to one CPU instruction plus loads. The DMD compiler too performs such optimization.\n\nDuckDB provides bitwise operations for all the bitwise operators mentioned except for rotations, as illustrated by the first function and table below.\n\nThe second table illustrates that the behavior of bitwise `NOT` for integers depends on the type of the argument.\n\nE provides arbitrary-size integers, so there is no distinct arithmetic and logical shift right. E does not provide bit rotate operations.\n\nResults in (extracted for just one of the test values):\n\nAll these operations are built-in functions except right arithmetic shift, left rotate, and right rotate.\n\nCurrently rotation and logical shifts are not implemented.\n\nOnly AND, OR, and NOT are available.\n\nRotation is not standard, but may be provided in particular Forth implementations, or as an assembly instruction in CODE words.\n\nIn ISO Fortran 90 and later the following BIT INTRINSIC functions are defined:\n\nThe following INTRINSIC ELEMENTAL SUBROUTINE is also defined:\n\nFB does not have a bitwise symbol for not, but rather uses the \"not\" expression. It does not support predefined bitwise symbols for rotate left and rotate right, but functions in this demo provide that capability.\n\nHarbour language has a set of core functions, which are fully optimized at compile time, to perform bitwise operations.\n\nThe operations in Data.Bits work on Int, Integer, and any of the sized integer and word types.\n\nIf you were shifting Words (unsigned integers) instead of Ints, then the shift would be automatically logical shifts:\n\nThere is no rotate and no shift support built in to HicEst\n\nIcon/Unicon implements bitwise operations on integers. Because integers can be transparently large integers operations that require fixed sizes don't make sense and aren't defined. These include rotation and logical shifting (shift is arithmetic) . Please note also that 'not' is a reserved word and the negation function is 'icom'\n\nInform 6 has no xor or rotate operators. It also has no shift operators, although the Z-machine, its usual target architecture, does. These can be accessed with inline assembly, which is done here.\n\nHere are the \"bitwise operators\":\n\nAnd here is a routine which takes a list of bitwise operators and two numbers and displays a table of results from combining those two numbers with each of the operators:\n\nAnd here they are in action:\n\nAll of the operators may be combined with the operator to save space. For example, the following lines each do the same thing:\n\nThere are no integers in Javascript, but there are still bitwise operators. They will convert their number operands into integers before performing they task. In other languages, these operators are very close to the hardware and very fast. In JavaScript, they are very far from the hardware and very slow and rarely used.\n\nWorks with jq, the C implementation of jq\n\nWorks with gojq, the Go implementation of jq\n\njq has no built-in bitwise operations, but the \"bitwise\" module defines all those needed for the task at hand except for rotations. Here `rotateLeft` and rotateRight` functions are defined relative to a given width.\n\nThe examples are taken from the entry for Wren.\n\nAll these operations are built-in functions except right arithmetic shift, left rotate, and right rotate.\n\nLingo has built-in functions for bitwise AND, OR, XOR and NOT:\n\nBit shifting and rotating has to be implemented by custom functions.\n\nThe output of this program is:\n\nThe RiscLua dialect, for RISC OS, has 32-bit integers as the default number type. It provides binary operations & (and), | (or), ^^ (xor), << (logical shift left), >> (logical shift right) and a unary operation ~ (negate).\n\nAs of Lua 5.3 most of the required operations are built-in, and those still missing could be derived from them:\n\nMost functions are built-in or can be made really easily:\n\nThe function BitShiftLeft, BitShiftRight, RotateRight, RotateLeft all take a second argument, which is the displacement, by default it is set to 1. BitAnd, BitXor and BitOr can handle more than 2 arguments:\n\nNewer versions of MATLAB have even more bitwise operations than those demonstrated here. A complete list of bitwise operations for the newest version of MATLAB can be found at MathWorks\n\nML/I only supports bitwise AND and OR operations. These are available from version CKD onwards.\n\nAll bitwise operations in NSIS are handled by the IntOp instruction.\n\nThere's no arithmetic shift nor rotation (and the not can be done through a xor)\n\nThere is no built-in for not and rotation\n\nThe only bit operators available in OpenEdge are the GET-BITS() and PUT-BITS() functions. These functions can be used to implement all bitwise operators.\n\nPari does not support bitwise rotations, which have no obvious meaning with arbitrary-precision integers. See also for another bitwise operator. For shifts, see also .\n\nWhile Standard Pascal does not have bitwise operations, most Pascal implementations (including Turbo Pascal and Delphi) extend the standard logical operators to also provide bitwise operations:\n\nPhix has four builtin bitwise operations (and/or/xor/not)_bits, which each have sequence and unsigned variants. Note careful use of latter (unsigned) routines here, since Phix naturally preserves signs (and common sense) when it can, rather than rudely treat, for instance, +4,294,967,295 as -1, unless explicitly told to do so as it is below. Likewise the builtin shift operators deliver signed and unbounded results, so we'll wrap them here. There are no builtin rotate routines, but easy enough to devise. The distributed copy (1.0.2+) also contains an (older) inline assembly version, which is obviously not JavaScript compatible, but may be significantly faster, for desktop-only applications.\n\nPicoLisp has no specific word size. Numbers grow to arbitrary length. Therefore, bitwise NOT, logical (non-arithmetic) SHIFTs, and rotate operations do not make sense.\n\nBitwise AND-Test (tests if all bits in the first argument are set in the following arguments):\n\nShift (right with a positive count, left with a negative count):\n\nRotate operations are not available\n\nConceptually in Pop11 integers have infinite precision, in particular negative numbers conceptually have infinitely many leading 1's in two's complement notation. Hence, logical right shift is not defined. If needed, logical right shift can be simulated by masking high order bits.\n\nLogical right shift and rotations are not supported in PowerShell.\n\nPython has variable length integers. Usually implementations require fixed-width integers. This we get by &-ing values with a mask of all ones of sufficient length. Below we use a combination of a mask and zero-extended fixed-width binary output formatting in calculations and result displays.\n\nPython does not have built in rotate or logical right shift operations.\n\nNote: Newer Python versions (circa 2.4?) will automatically promote integers into \"long integers\" (arbitrary length, bounded by available memory). This can be noticed especially when using left shift operations. When using bitwise operations one usually wants to keep these bounded to specific sizes such as 8, 16, 32 or 64 bit widths. To do these we use the AND operator with specific values (bitmasks). For example:\n\nWe can easily implement our own rotation functions. For left rotations this is down by ORing the left shifted and masked lower bits against the right shifted upper bits. For right rotations we perform the converse operations, ORing a set of right shifted lower bits against the appropriate number of left shifted upper bits.\n\nIn this example we show a relatively straightforward function for converting integers into strings of bits, and another simple mask() function to create arbitrary lengths of bits against which we perform our masking operations. Also note that the implementation of these functions defaults to single bit rotations of 8-bit bytes. Additional arguments can be used to over-ride these defaults. Any case where the number of rotations modulo the width is zero represents a rotation of all bits back to their starting positions. This implementation should handle any integer number of rotations over bitfields of any valid (positive integer) length.\n\nIntegers in Quackery are bignums, so the bitwise left rotate word rotates specifically the least significant 64 bits of an integer. There is no corresponding bitwise right rotate, but it is readily defined from .\n\nThe logical operators in R, namely &, | and !, are designed to work on logical vectors rather than bits. It is possible to convert from integer to logical vector and back to make these work as required, e.g.\n\nThere is no predefined arithmetic shifts in Retro.\n\nIn RLaB the bitwise operations are available for integers type of numbers. For the operations below if both arguments are integers then the result of the operation is an integer as well.\n\nS-BASIC does not have bitwise shift or rotate operators. The test values are taken from the 11l example.\n\nNote: bitwise operations were also described in SRFI-60, with additional aliases (and previously discussed in SRFI-33 which remained draft).\n\nThe type integer is intended for arithmetic operations. Besides arithmetic shifts, which are seen as multiplication and division by powers of two, no bitwise operations are supported. The type bin32 is intended for bit-pattern operations. Bin32 has the same internal representation as integer. That way conversions between them don't cause an overhead. Right shifting of bin32 values is done with logical shifts.\n\nSince GNU Smalltalk by default runs without a graphical user interface, I wrote the program in that dialect. The actual methods for bitwise operations (bitAnd:, etc.) are the same in all implementations.\n\nin addition to the above,\n\nNotice that all of those work on arbitrarily large integers (i.e. 1000 factorial lowBit -> 995).\n\nMore shifts are available for words (unsigned ints):\n\nStata does not have bitwise operators as of version 15.1. It's possible to use Mata functions inbase and frombase to convert integers to binary strings, and operate on these, but it will be much slower than native operators. William Matsuoka has written functions for this here.\n\nVerilog, being a hardware description language, had pretty comprehensive support for bit twiddling; though rotation is still a slightly manual operation. Just to be different, I decided to use a couple of 53-bit integers:\n\nIf we want to do a variable bit rotation, then we need to think in hardware terms, and build a mux structure (this could be a function, but using a module allows it to be parameterized:\n\nof course, one could always write the foreach loop inline.\n\nBytes values are infinitely extended to the left by sign extension when needed. The shift message can be used for all types of shifts, depending on the fill pattern which is infinitely repeated as needed to supply bits for vacated positions.\n\nThere are no built-in operations for arithmetic right shift or for bit rotation. Indeed, rotation precludes the use of arbitrary-width integers and can only be defined with respect to a particular width. However, we can simulate these operations for 32-bit values (requires Tcl 8.5):\n\nWhile the TI-89 supports arbitrary-size integers, all bitwise arithmetic is performed on the rightmost 32 bits of the integers' two's complement representation.\n\nThe right shift operation fills the new leftmost bit with a copy of the old leftmost bit.\n\nIn VBA, the logical operators And, Or, Xor, Not are actually binary operators. There are also Eqv and Imp (for bitwise \"equivalence\" and \"logical implication\").\n\nThe other operations in the task are not builtin, but are easy to implement. Integers are signed, and overflow throws and exception, one must take care of this.\n\nIn Wren all numbers are represented in 64-bit floating point form.\n\nAlthough the same bitwise operators are supported as in C, the operands are converted to unsigned 32-bit integers before the operation is performed and return values of this form.\n\nConsequently, it is not usually a good idea to try and perform bitwise operations on integer values outside this range or on non-integral values.\n\nGiven this limitation, there is no difference between logical and arithmetic left and right shift operations. Although Wren doesn't support circular shift operators, it is not difficult to write functions to perform them.\n\nIt must be linked with the libc and \"start\" code; lazyly a works, being bitops.o produced by (I've chosen ELF since I am on a GNU/Linux box)\n\nThe reason the \"!\" and \"|\" symbols may seem reversed is that the OR operator was introduced at a time when only uppercase characters were available (such as on the Apple II). The XOR operator was added later.\n\nZ80 has two different types of bit rotates.\n• rotates through the carry. The state of the carry before the rotate gets rotated in, and the bit that rotates out is put into the carry.\n• copies the bit \"pushed out\" to the carry but the old carry isn't rotated in."
    },
    {
        "link": "https://mathematica.stackexchange.com/questions/41125/how-to-efficiently-mask-an-image",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://files.wolframcdn.com/pub/www.wolframscience.com/nks/nks-notes.pdf",
        "document": ""
    }
]