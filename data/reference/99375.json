[
    {
        "link": "https://dev.to/smartmuv/smart-contract-data-extraction-how-it-works-1hj1",
        "document": "In the world of blockchain, smart contracts play a fundamental role in creating and managing decentralized applications (dApps) by handling transactions, assets, and user interactions. These contracts store various data types within the blockchain to ensure transparency and trust. However, accessing and understanding this stored data isn’t straightforward due to the way data is managed on the Ethereum Virtual Machine (EVM) especially keys of mapping variables. Smart contract data extraction, therefore, becomes essential, especially when looking to audit, migrate, or analyze data for optimization.\n\nLet’s walk through the steps involved in data extraction, explain the technology behind it, and explore why it’s such a critical process for anyone working with smart contracts.\n\nSmart contract data extraction is the process of retrieving data stored within a blockchain-based contract. Smart contracts hold various types of data like user balances, transaction details, and more complex data structures, which developers and auditors may need to access and analyze to monitor performance, conduct audits, or power analytics.\n\nThis process involves scanning the contract’s storage, identifying the variables, analyzing their storage slots, and finally, decoding and extracting this data into a readable format. In other words, data extraction provides a way to bridge the gap between raw, stored blockchain data and useful, interpretable information.\n\nThe importance of smart contract data extraction can’t be overstated. Here are several reasons why:\n• Security and Audits: For ensuring the safety of blockchain applications, data extraction allows auditors to examine every contract state, improving the detection of any anomalies.\n• Transparency and Accountability: Blockchain’s promise of transparency is only fulfilled if users can verify and access data directly from smart contracts. Data extraction makes this possible by making stored data accessible.\n• Performance Optimization: Understanding how data is stored and used in contracts can help developers design contracts that use storage more efficiently, thereby lowering operational costs.\n• Migration and Upgrades: During smart contract upgrades and migrations, data extraction ensures seamless continuity, safeguarding data integrity for applications and users.\n\nTo understand how to extract data, it’s essential to grasp how smart contracts store data on the blockchain. In an EVM-based blockchain, each smart contract has its own storage layout, which is divided into “slots” of 32 bytes. Each variable occupies one or more slots based on its type and complexity.\n• Simple Variables: Data types like integers, booleans, and addresses occupy a single slot each.\n• Arrays and Structs: These occupy multiple slots since they hold multiple elements, with each element stored sequentially.\n• Mappings: Mappings are key-value pairs that use hash functions to calculate the storage location of each entry, making it challenging to get all mapping keys and then calculate corresponding slot without a proper tool.\n\nThe process of extracting data from smart contracts involves three main steps: scanning, slot analysis, and storage extraction. Here’s a breakdown of each step.\n\nThe first step in data extraction is scanning the smart contract’s data. This involves:\n• Locating the Contract Address: Every deployed smart contract has a unique address. By connecting to the blockchain through a provider (such as Infura, Alchemy, or Etherscan), you can locate the contract and start interacting with its data.\n• Accessing the Contract’s ABI (Application Binary Interface): The ABI provides the “blueprint” of the contract, listing its functions and variables. It’s essential for interpreting the data stored in the contract’s slots.\n• Reading Storage Slots: With a connection to the blockchain and access to the contract’s ABI, you can initiate the process of reading data from specific storage slots.\n\nSmart contract storage is optimized for performance, not readability, so it’s necessary to analyze the slot layout to interpret the data accurately.\n• Simple Variables: Simple data types like uint or bool are mapped directly to specific slots. Tools like Ethers.js or Web3.js can help read these slots, allowing you to decode and access values easily.\n• Mapping Arrays and Structs: These data structures require more detailed slot mapping since they span multiple slots. For instance, a dynamic array requires knowing the length and slot layout to read each element.\n• Handling Mappings: Mappings, which are commonly used to store complex data, rely on hash functions to determine the location of each entry. Using the hash of the key (for example, keccak256(key)) helps locate the data slot for each key-value pair.\n\nThe final step in data extraction is to retrieve and decode data from the smart contract’s storage:\n• Retrieve Data Using a Blockchain Node or API: With a connected node, you can call storage slots to pull data from each slot directly. This raw data is generally in hexadecimal format.\n• Decode the Data: Converting this data from hexadecimal into human-readable values is essential. Tools like ABI Decoders and Solidity decoders are commonly used to parse and convert this raw data.\n• Process Data for Readability: Once decoded, data can be further processed and formatted into JSON or CSV files for easy reading or to integrate into other applications for analysis.\n\nThe following tools and frameworks can help in different stages of data extraction:\n• Etherscan: Offers a public API for basic data retrieval, though it has limitations with complex data.\n• Ethers.js and Web3.js: JavaScript libraries that enable interaction with Ethereum, allowing developers to fetch and decode contract storage data.\n• Hardhat: A development environment for Ethereum, Hardhat supports data extraction in test environments, making it ideal for testing and developing contracts before deployment.\n• SmartMuv: Advanced tools like SmartMuv can analyze deep storage data structures, handling nested arrays and mappings efficiently. This is especially useful for auditing, smart contract migrations, and extracting complex contract states.\n\nImagine a smart contract designed to manage player data in a Web3 game. The contract has variables like playerID, score, and status:\n• Connect to the blockchain using Ethers.js, specifying the contract address and ABI.\n• playerID might be in slot 0.\n• score could be in slot 1.\n• status might be stored in slot 2.\n• Use Ethers.js to call these slots and retrieve the data in hexadecimal format.\n• Decode and convert this data into human-readable format, showing the player’s ID, score, and status in a JSON object for use in other applications.\n• Storage Collisions: Migrating contracts can sometimes lead to storage collisions if storage layouts aren’t adequately managed, which can result in data loss or corruption.\n• Complex Mappings: Nested mappings and arrays can be difficult to interpret without advanced tooling.\n• Hexadecimal Encoding: Data stored on the blockchain is often in hexadecimal, requiring decoding for human readability.\n• Variable Upgrades: When upgrade smart contracts, new variables can change the storage layout, complicating data extraction and smart contract migration.\n\nSmart contract data extraction is crucial for developers, auditors, and users who need to interpret the stored data on blockchains accurately. By scanning contracts, analyzing slot layouts, and extracting storage data, users can gain deep insights into how contracts operate, verify transactions, and ensure data integrity.\n\nWith tools like Ethers.js, SmartMuv, and Etherscan, users now have more accessible means to read and analyze contract data—enabling blockchain transparency and enhancing contract management practices.\n\nQ: Can I extract data from any smart contract?\n\n Yes, but access depends on the contract’s design. Data extraction is possible for public storage variables, while private or protected data may be more challenging to access without permission.\n\nQ: Why do I need tools to extract data from smart contracts?\n\n Smart contract storage is optimized for efficiency rather than readability. Tools like SmartMuv are necessary to read, interpret, and convert storage data into a human-readable format.\n\nQ: How does data extraction help in contract migration?\n\n During migration, data extraction allows developers to capture the current state of a contract, which can be essential for maintaining continuity between old and new contracts.\n\nQ: How are complex data types like mappings and arrays extracted?\n\n Specialized tools like SmartMuv automatically calculate the specific storage slots for these data structures, allowing precise extraction and interpretation of each element.\n\nQ: How often should data extraction be performed for monitoring?\n\n For dynamic applications like dApps, data extraction may be performed frequently (daily or weekly) to keep track of usage, balances, and contract states."
    },
    {
        "link": "https://4soft.co/blog/demystifying-data-extraction-from-ethereum-blockchain-a-deep-dive-into-the-world-of-evm",
        "document": "Ethereum transcends the conventional boundaries of cryptocurrency and has over the years evolved into an expansive ecosystem designed to support decentralized applications (dApps) and smart contracts.\n\nThe Ethereum blockchain stands out thanks to its complex data structures, transaction records and programmable logic in the form of smart contracts. This intricate setup paves the way for many applications, from finance to healthcare, going beyond traditional industry limitations.\n\nThe Ethereum Virtual Machine (EVM) is what enables Ethereum's smart contract functionality, making Ethereum a programmable blockchain. However, data extraction from EVM is often complex because transactions and contract executions are encoded in bytecode, which is not human-readable.\n\nIn March 2024, Dencun was launched to bring a new age of quicker, cheaper transactions. Ethereum has always struggled to increase the speed of its base layer in response to demand; hence, Dencun focuses on scaling via Layer 2.\n\nHow can you extract data from the Ethereum blockchain? And what are the key methods for accelerating this complex process? Keep reading to explore industry best practices for this challenging area of blockchain.\n• Credit Risk Assessment: Companies can use transaction histories and smart contract interactions to assess borrowers' creditworthiness properly.\n• Real-time Audit and Compliance: Continuously monitor and extract data from blockchain transactions to ensure real-time adherence to financial rules.\n• Counterfeit Goods Detection: Detect and verify the authenticity of luxury items, electronics, and medications to avoid counterfeiting.\n• Automated Payments and Settlements: Use smart contract data to automate payments based on contractual circumstances, expediting the settlement process.\n• Clinical Trial Data Management: Manage clinical trial data securely on blockchain for transparency and integrity.\n• Pharmaceutical Supply Chain Transparency: Trace pharmaceuticals' production and distribution chains to prevent counterfeit drugs from entering the market.\n• Lease Management: Automate rental payments and property management by extracting and analyzing data from blockchain lease agreements.\n• Real Estate Investment Trusts (REITs): Extract transaction data from blockchain-based REITs to provide investors with transparent, real-time performance statistics.\n• Energy trading: Companies can extract transaction data from peer-to-peer networks to buy and sell excess renewable energy.\n• Carbon Credit Tracking: Use blockchain data to track and verify the issue, transfer, and retirement of carbon credits, ensuring environmental accountability.\n• Identity Verification: Use blockchain-extracted data to improve the security and efficiency of verification operations.\n• Subsidy Tracking: Automate and track the disbursement of government grants and subsidies using smart contracts to ensure transparency.\n\nHow Is Smart Contract Interaction Data Stored On Ethereum?\n\nUnlike Bitcoin and its relatively simple Bitcoin Script, the Ethereum blockchain provides more than just money transfers through end-to-end transactions. Ethereum's smart contracts allow for much more complexity and are primarily based on a Turing-complete language, meaning they can run any computation given enough resources. Running Turing-complete code is Ethereum's fundamental differentiator, that’s why the most interesting data is found in the smart contract interactions.\n\nTo run code, Ethereum provides a virtual machine known as the Ethereum Virtual Machine (EVM). EVM abstracts the underlying machine, allowing smart contracts to operate on any computer with an Ethereum node running. A smart contract is just a program or piece of code written in a programming language and compiled for use with the Ethereum virtual machine.\n\nSmart contracts create logs by firing events whenever a function is invoked by an external account (transaction) or another smart contract (internal transaction). Events can be broadly defined as asynchronous triggers with data. They’re asynchronous because the log isn’t written until the initiating transaction has been mined into a block.\n\nThe primary use case for events is to give smart contract return values to a user interface. Logs can also be used as a cost-efficient storage option.\n\nTo understand how the function is invoked, consider the contents of a transaction's (optional) data field. It might be any data, but it is usually a function call to a smart contract.\n\nThe transaction is directed at the smart contract and includes its address in the \"to\" column.\n\nTo determine which function the transaction is calling within the smart contract, the contract's functions must be understood before creating a hash table. The first 32 bits in the transaction data field correspond to the function's hash (function selector). This is followed by 256 bits for each parameter of the function. In essence, this implies that data fields in function calls are encoded. Decoding them is required before they can be used and interpreted.\n\nExtracting and Interpreting Data: From Raw to Refined\n\nInteracting with smart contracts involves decoding and understanding the data structured by Ethereum's Solidity programming language. It’s vital for reading from and writing to the blockchain. However, transforming this raw data into actionable insights is the real challenge.\n\nOnce you know the source code and have access to its ABI (Application Binary Interface), decoding the contract is quite easy. That is why contracts are verified on websites such as Etherscan or sourcify.dev. You can generate the contract ABI and that is enough to interact with it, for example, with the help of libraries such as ethers.\n\nEthereum's blockchain is a sequential ledger composed of blocks containing transactions and smart contract executions. These are linked using cryptographic hashes, which are secure but not straightforward to interpret without specialized tools.\n\nEthereum data, such as addresses and transaction values, is typically represented in hexadecimal format, making direct interpretation challenging without conversion tools. The data is sequential and sluggish.\n\nThe most obvious challenge is that almost everything is made of hexadecimal hashes rather than explicit text labels. For account addresses, this may be seen as a feature that allows for pseudonymity. However, to interact with smart contracts, you need to transform the data into a human-readable format.\n\nAnother consideration is the serialized nature of the data. Only a few use cases such as token analytics or DeFi tracking allow you to read the response from the blockchain in a single query. Typically, you'll have to traverse the chain with many queries for simple operations like showing an account's transaction history.\n\nFinally, the interface for querying the data must be investigated. Before you begin, you must set up an archive node (such as Geth or Parity) to ensure all past data is available. As of March 2024, the size is around 1 TB, and it must be stored on SSD hard drives to function successfully. Synchronizing the Ethereum Mainnet would take many days or even weeks. Once the node operates, you can only query it using the JSON-RPC API. This is quite slow, especially given the large number of calls required due to the serial structure of the data.\n\nSharding represents a significant evolution in blockchain technology to enhance scalability and speed. By partitioning the blockchain into smaller, manageable pieces (shards), Ethereum aims to increase transaction throughput, paving the way for broader adoption. This development is especially pertinent as Ethereum grows and attracts diverse applications.\n\nInitially proposed as part of Ethereum 2.0, sharding aims to split the blockchain into smaller, manageable pieces (shards) to improve scalability and transaction speed. However, traditional sharding presents technical and security challenges.\n\nEthereum's new approach, which focuses on data availability and rollups, is Danksharding. It divides data into \"blobs\" rather than partitioning the entire blockchain, aiming for a more scalable and secure solution.\n\nProto-Danksharding is a transitional step towards Danksharding, introducing data blobs for temporary storage, which helps reduce costs for Layer 2 solutions like rollups and increase network throughput.\n\nThere are a few approaches teams can use to accelerate data extraction from Ethereum:\n• Ethereum Nodes and RPC providers - Using full nodes or RPC providers like Infura or Alchemy can streamline data access. These services provide efficient interfaces for querying blockchain data.\n• Web3 Libraries - Tools like Web3.js or Web3.py abstract the complexities of direct blockchain interactions, offering a more user-friendly way to retrieve and manipulate Ethereum data.\n• Indexing Services - Platforms such as The Graph allow developers to create APIs (subgraphs) that index specific blockchain data, enabling faster and more efficient queries.\n• ETL Processes - Extract, Transform, and Load techniques can be employed to streamline data processing. Users can perform complex analyses more efficiently by extracting relevant data, transforming it into a readable format, and loading it into a database.\n\nTo monitor smart contract development on a test net or the Ethereum Mainnet, you need to set up a node and create an index (database). There are essentially two ways to do so: by indexing the entire blockchain or by limiting the amount of data drained from the node and into the index. The choice of strategy depends on the balance of resource consumption and flexibility limits.\n\nAnother important factor in querying your blockchain index is the volume and type of data that you want to retrieve. The query language and database system are largely linked, so you must evaluate them simultaneously.\n\nYou need to be aware of the growing complexity of architectural issues and the distribution of such a database index across many teams/departments or even corporate organizations. This would call for authorization features and more.\n\nETL in Ethereum: Here’s how it works\n\nHere’s a quick overview of the Extract, Transform, and Load (ETL) method for moving the Ethereum content into the database index.\n\nFirst, extract the data relevant to you from the node, such as all information about certain smart contracts or the whole blockchain history beginning at a given point in time. The issue of how quickly you want to retrieve incoming blocks is of particular significance.\n\nWhile it is certainly advantageous to keep up to date rapidly, you may encounter chain reorganizations on occasion. This happens when a client node discovers a new difficulty-longest well-formed blockchain that excludes one or more blocks that the client had previously assumed were part of the longest blockchain. These omitted blocks become orphans, and the data stored inside them must be cleansed from or at least marked in the index.\n\nDuring the transformation process, you should probably make the data human-readable. Examples include labeling Ethereum accounts of known provenance (exchange wallets, smart contract names, etc.) and retrieving smart contract thanks to Application Binary Interfaces (ABI).\n\nTo match the raw data to the clear text labels, you'll need to use some sort of mapping. This might also imply obtaining previous pricing information for ERC-20 tokens and integrating the timestamp with the correct block height. That would be required to quantify value transfer transactions in fiat currencies, an example of enhancing blockchain data with external sources.\n\nStep 3: Load into the database index for quicker queries\n\nThis data must then be placed into a database and indexed to ensure optimal query performance. Depending on the technology used, this procedure may take time and include several processes. You can now read from a database index considerably faster and begin looking into the blockchain data.\n\nWhile the Ethereum Virtual Machine (EVM) has been foundational to Ethereum’s architecture, the future beckons with the possibility of incorporating a broader range of programming languages and technologies. Ethereum's exploration into environments like WebAssembly (Wasm) could revolutionize smart contract development by enabling compilation from multiple languages, not limited to Rust. This adaptability allows developers the flexibility to employ languages they are already proficient in, moving beyond the necessity of learning Solidity.\n\nThe integration of languages with robust safety and performance features, such as Rust, certainly presents exciting prospects due to its famed memory safety. However, the broader perspective includes leveraging any advanced technology that enhances performance, security, and developer accessibility. As Ethereum evolves with developments like sharding, the ease and efficiency of handling blockchain data are set to improve significantly, paving the way for a more robust and versatile platform.\n\nThese advancements in Ethereum’s technological framework could significantly widen its appeal and utility, fostering a more inclusive and innovative blockchain community.\n\nEthereum offers a complex but profoundly impactful framework for developing and deploying decentralized applications. Understanding its components, from the EVM to data extraction methods, is crucial for leveraging its full potential. As Ethereum continues to evolve, notably with sharding and potential new programming paradigms, its influence across industries is bound to grow."
    },
    {
        "link": "https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html",
        "document": "Let us begin with a basic example that sets the value of a variable and exposes it for other contracts to access. It is fine if you do not understand everything right now, we will go into more details later. The first line tells you that the source code is licensed under the GPL version 3.0. Machine-readable license specifiers are important in a setting where publishing the source code is the default. The next line specifies that the source code is written for Solidity version 0.4.16, or a newer version of the language up to, but not including version 0.9.0. This is to ensure that the contract is not compilable with a new (breaking) compiler version, where it could behave differently. Pragmas are common instructions for compilers about how to treat the source code (e.g. pragma once). A contract in the sense of Solidity is a collection of code (its functions) and data (its state) that resides at a specific address on the Ethereum blockchain. The line declares a state variable called of type (unsigned integer of 256 bits). You can think of it as a single slot in a database that you can query and alter by calling functions of the code that manages the database. In this example, the contract defines the functions and that can be used to modify or retrieve the value of the variable. To access a member (like a state variable) of the current contract, you do not typically add the prefix, you just access it directly via its name. Unlike in some other languages, omitting it is not just a matter of style, it results in a completely different way to access the member, but more on this later. This contract does not do much yet apart from (due to the infrastructure built by Ethereum) allowing anyone to store a single number that is accessible by anyone in the world without a (feasible) way to prevent you from publishing this number. Anyone could call again with a different value and overwrite your number, but the number is still stored in the history of the blockchain. Later, you will see how you can impose access restrictions so that only you can alter the number. Be careful with using Unicode text, as similar looking (or even identical) characters can have different code points and as such are encoded as a different byte array. All identifiers (contract names, function names and variable names) are restricted to the ASCII character set. It is possible to store UTF-8 encoded data in string variables. The following contract implements the simplest form of a cryptocurrency. The contract allows only its creator to create new coins (different issuance schemes are possible). Anyone can send coins to each other without a need for registering with a username and password, all you need is an Ethereum keypair. // This will only compile via IR balances // Events allow clients to react to specific // Constructor code is only run when the contract minter // Sends an amount of newly created coins to an address // Can only be called by the contract creator minter balances receiver amount // Errors allow you to provide information about // why an operation failed. They are returned // to the caller of the function. error InsufficientBalance // from any caller to an address amount balances InsufficientBalance amount balances balances amount balances receiver amount emit Sent receiver amount This contract introduces some new concepts, let us go through them one by one. The line declares a state variable of type address. The type is a 160-bit value that does not allow any arithmetic operations. It is suitable for storing addresses of contracts, or a hash of the public half of a keypair belonging to external accounts. The keyword automatically generates a function that allows you to access the current value of the state variable from outside of the contract. Without this keyword, other contracts have no way to access the variable. The code of the function generated by the compiler is equivalent to the following (ignore and for now): You could add a function like the above yourself, but you would have a function and state variable with the same name. You do not need to do this, the compiler figures it out for you. The next line, also creates a public state variable, but it is a more complex datatype. The mapping type maps addresses to unsigned integers. Mappings can be seen as hash tables which are virtually initialized such that every possible key exists from the start and is mapped to a value whose byte-representation is all zeros. However, it is neither possible to obtain a list of all keys of a mapping, nor a list of all values. Record what you added to the mapping, or use it in a context where this is not needed. Or even better, keep a list, or use a more suitable data type. The getter function created by the keyword is more complex in the case of a mapping. It looks like the following: You can use this function to query the balance of a single account. The line declares an “event”, which is emitted in the last line of the function . Ethereum clients such as web applications can listen for these events emitted on the blockchain without much cost. As soon as it is emitted, the listener receives the arguments , and , which makes it possible to track transactions. To listen for this event, you could use the following JavaScript code, which uses web3.js to create the contract object, and any user interface calls the automatically generated function from above: The constructor is a special function that is executed during the creation of the contract and cannot be called afterwards. In this case, it permanently stores the address of the person creating the contract. The variable (together with and ) is a special global variable that contains properties which allow access to the blockchain. is always the address where the current (external) function call came from. The functions that make up the contract, and that users and contracts can call are and . The function sends an amount of newly created coins to another address. The require function call defines conditions that reverts all changes if not met. In this example, ensures that only the creator of the contract can call . In general, the creator can mint as many tokens as they like, but at some point, this will lead to a phenomenon called “overflow”. Note that because of the default Checked arithmetic, the transaction would revert if the expression overflows, i.e., when in arbitrary precision arithmetic is larger than the maximum value of ( ). This is also true for the statement in the function . Errors allow you to provide more information to the caller about why a condition or operation failed. Errors are used together with the revert statement. The statement unconditionally aborts and reverts all changes, much like the require function. Both approaches allow you to provide the name of an error and additional data which will be supplied to the caller (and eventually to the front-end application or block explorer) so that a failure can more easily be debugged or reacted upon. The function can be used by anyone (who already has some of these coins) to send coins to anyone else. If the sender does not have enough coins to send, the condition evaluates to true. As a result, the will cause the operation to fail while providing the sender with error details using the error. If you use this contract to send coins to an address, you will not see anything when you look at that address on a blockchain explorer, because the record that you sent coins and the changed balances are only stored in the data storage of this particular coin contract. By using events, you can create a “blockchain explorer” that tracks transactions and balances of your new coin, but you have to inspect the coin contract address and not the addresses of the coin owners.\n\nBlockchains as a concept are not too hard to understand for programmers. The reason is that most of the complications (mining, hashing, elliptic-curve cryptography, peer-to-peer networks, etc.) are just there to provide a certain set of features and promises for the platform. Once you accept these features as given, you do not have to worry about the underlying technology - or do you have to know how Amazon’s AWS works internally in order to use it? A blockchain is a globally shared, transactional database. This means that everyone can read entries in the database just by participating in the network. If you want to change something in the database, you have to create a so-called transaction which has to be accepted by all others. The word transaction implies that the change you want to make (assume you want to change two values at the same time) is either not done at all or completely applied. Furthermore, while your transaction is being applied to the database, no other transaction can alter it. As an example, imagine a table that lists the balances of all accounts in an electronic currency. If a transfer from one account to another is requested, the transactional nature of the database ensures that if the amount is subtracted from one account, it is always added to the other account. If due to whatever reason, adding the amount to the target account is not possible, the source account is also not modified. Furthermore, a transaction is always cryptographically signed by the sender (creator). This makes it straightforward to guard access to specific modifications of the database. In the example of the electronic currency, a simple check ensures that only the person holding the keys to the account can transfer some compensation, e.g. Ether, from it. One major obstacle to overcome is what (in Bitcoin terms) is called a “double-spend attack”: What happens if two transactions exist in the network that both want to empty an account? Only one of the transactions can be valid, typically the one that is accepted first. The problem is that “first” is not an objective term in a peer-to-peer network. The abstract answer to this is that you do not have to care. A globally accepted order of the transactions will be selected for you, solving the conflict. The transactions will be bundled into what is called a “block” and then they will be executed and distributed among all participating nodes. If two transactions contradict each other, the one that ends up being second will be rejected and not become part of the block. These blocks form a linear sequence in time, and that is where the word “blockchain” derives from. Blocks are added to the chain at regular intervals, although these intervals may be subject to change in the future. For the most up-to-date information, it is recommended to monitor the network, for example, on Etherscan. As part of the “order selection mechanism”, which is called attestation, it may happen that blocks are reverted from time to time, but only at the “tip” of the chain. The more blocks are added on top of a particular block, the less likely this block will be reverted. So it might be that your transactions are reverted and even removed from the blockchain, but the longer you wait, the less likely it will be. Transactions are not guaranteed to be included in the next block or any specific future block, since it is not up to the submitter of a transaction, but up to the miners to determine in which block the transaction is included. If you want to schedule future calls of your contract, you can use a smart contract automation tool or an oracle service.\n\nThe Ethereum Virtual Machine or EVM is the runtime environment for smart contracts in Ethereum. It is not only sandboxed but actually completely isolated, which means that code running inside the EVM has no access to network, filesystem or other processes. Smart contracts even have limited access to other smart contracts. There are two kinds of accounts in Ethereum which share the same address space: External accounts that are controlled by public-private key pairs (i.e. humans) and contract accounts which are controlled by the code stored together with the account. The address of an external account is determined from the public key while the address of a contract is determined at the time the contract is created (it is derived from the creator address and the number of transactions sent from that address, the so-called “nonce”). Regardless of whether or not the account stores code, the two types are treated equally by the EVM. Every account has a persistent key-value store mapping 256-bit words to 256-bit words called storage. Furthermore, every account has a balance in Ether (in “Wei” to be exact, is ) which can be modified by sending transactions that include Ether. A transaction is a message that is sent from one account to another account (which might be the same or empty, see below). It can include binary data (which is called “payload”) and Ether. If the target account contains code, that code is executed and the payload is provided as input data. If the target account is not set (the transaction does not have a recipient or the recipient is set to ), the transaction creates a new contract. As already mentioned, the address of that contract is not the zero address but an address derived from the sender and its number of transactions sent (the “nonce”). The payload of such a contract creation transaction is taken to be EVM bytecode and executed. The output data of this execution is permanently stored as the code of the contract. This means that in order to create a contract, you do not send the actual code of the contract, but in fact code that returns that code when executed. While a contract is being created, its code is still empty. Because of that, you should not call back into the contract under construction until its constructor has finished executing. Upon creation, each transaction is charged with a certain amount of gas that has to be paid for by the originator of the transaction ( ). While the EVM executes the transaction, the gas is gradually depleted according to specific rules. If the gas is used up at any point (i.e. it would be negative), an out-of-gas exception is triggered, which ends execution and reverts all modifications made to the state in the current call frame. This mechanism incentivizes economical use of EVM execution time and also compensates EVM executors (i.e. miners / stakers) for their work. Since each block has a maximum amount of gas, it also limits the amount of work needed to validate a block. The gas price is a value set by the originator of the transaction, who has to pay up front to the EVM executor. If some gas is left after execution, it is refunded to the transaction originator. In case of an exception that reverts changes, already used up gas is not refunded. Since EVM executors can choose to include a transaction or not, transaction senders cannot abuse the system by setting a low gas price. The Ethereum Virtual Machine has different areas where it can store data with the most prominent being storage, transient storage, memory and the stack. Each account has a data area called storage, which is persistent between function calls and transactions. Storage is a key-value store that maps 256-bit words to 256-bit words. It is not possible to enumerate storage from within a contract, it is comparatively costly to read, and even more to initialise and modify storage. Because of this cost, you should minimize what you store in persistent storage to what the contract needs to run. Store data like derived calculations, caching, and aggregates outside of the contract. A contract can neither read nor write to any storage apart from its own. Similar to storage, there is another data area called transient storage, where the main difference is that it is reset at the end of each transaction. The values stored in this data location persist only across function calls originating from the first call of the transaction. When the transaction ends, the transient storage is reset and the values stored there become unavailable to calls in subsequent transactions. Despite this, the cost of reading and writing to transient storage is significantly lower than for storage. The third data area is called memory, of which a contract obtains a freshly cleared instance for each message call. Memory is linear and can be addressed at byte level, but reads are limited to a width of 256 bits, while writes can be either 8 bits or 256 bits wide. Memory is expanded by a word (256-bit), when accessing (either reading or writing) a previously untouched memory word (i.e. any offset within a word). At the time of expansion, the cost in gas must be paid. Memory is more costly the larger it grows (it scales quadratically). The EVM is not a register machine but a stack machine, so all computations are performed on a data area called the stack. It has a maximum size of 1024 elements and contains words of 256 bits. Access to the stack is limited to the top end in the following way: It is possible to copy one of the topmost 16 elements to the top of the stack or swap the topmost element with one of the 16 elements below it. All other operations take the topmost two (or one, or more, depending on the operation) elements from the stack and push the result onto the stack. Of course it is possible to move stack elements to storage or memory in order to get deeper access to the stack, but it is not possible to just access arbitrary elements deeper in the stack without first removing the top of the stack. There are also other data areas which are not as apparent as those discussed previously. However, they are routinely used during the execution of smart contract transactions. The calldata region is the data sent to a transaction as part of a smart contract transaction. For example, when creating a contract, calldata would be the constructor code of the new contract. The parameters of external functions are always initially stored in calldata in an ABI-encoded form and only then decoded into the location specified in their declaration. If declared as , the compiler will eagerly decode them into memory at the beginning of the function, while marking them as means that this will be done lazily, only when accessed. Value types and pointers are decoded directly onto the stack. The returndata is the way a smart contract can return a value after a call. In general, external Solidity functions use the keyword to ABI-encode values into the returndata area. The code is the region where the EVM instructions of a smart contract are stored. Code is the bytes read, interpreted, and executed by the EVM during smart contract execution. Instruction data stored in the code is persistent as part of a contract account state field. Immutable and constant variables are stored in the code region. All references to immutables are replaced with the values assigned to them. A similar process is performed for constants which have their expressions inlined in the places where they are referenced in the smart contract code. The instruction set of the EVM is kept minimal in order to avoid incorrect or inconsistent implementations which could cause consensus problems. All instructions operate on the basic data type, 256-bit words or on slices of memory (or other byte arrays). The usual arithmetic, bit, logical and comparison operations are present. Conditional and unconditional jumps are possible. Furthermore, contracts can access relevant properties of the current block like its number and timestamp. For a complete list, please see the list of opcodes as part of the inline assembly documentation. Contracts can call other contracts or send Ether to non-contract accounts by the means of message calls. Message calls are similar to transactions, in that they have a source, a target, data payload, Ether, gas and return data. In fact, every transaction consists of a top-level message call which in turn can create further message calls. A contract can decide how much of its remaining gas should be sent with the inner message call and how much it wants to retain. If an out-of-gas exception happens in the inner call (or any other exception), this will be signaled by an error value put onto the stack. In this case, only the gas sent together with the call is used up. In Solidity, the calling contract causes a manual exception by default in such situations, so that exceptions “bubble up” the call stack. As already said, the called contract (which can be the same as the caller) will receive a freshly cleared instance of memory and has access to the call payload - which will be provided in a separate area called the calldata. After it has finished execution, it can return data which will be stored at a location in the caller’s memory preallocated by the caller. All such calls are fully synchronous. Calls are limited to a depth of 1024, which means that for more complex operations, loops should be preferred over recursive calls. Furthermore, only 63/64th of the gas can be forwarded in a message call, which causes a depth limit of a little less than 1000 in practice. There exists a special variant of a message call, named delegatecall which is identical to a message call apart from the fact that the code at the target address is executed in the context (i.e. at the address) of the calling contract and and do not change their values. This means that a contract can dynamically load code from a different address at runtime. Storage, current address and balance still refer to the calling contract, only the code is taken from the called address. This makes it possible to implement the “library” feature in Solidity: Reusable library code that can be applied to a contract’s storage, e.g. in order to implement a complex data structure. It is possible to store data in a specially indexed data structure that maps all the way up to the block level. This feature called logs is used by Solidity in order to implement events. Contracts cannot access log data after it has been created, but they can be efficiently accessed from outside the blockchain. Since some part of the log data is stored in bloom filters, it is possible to search for this data in an efficient and cryptographically secure way, so network peers that do not download the whole blockchain (so-called “light clients”) can still find these logs. Contracts can even create other contracts using a special opcode (i.e. they do not simply call the zero address as a transaction would). The only difference between these create calls and normal message calls is that the payload data is executed and the result stored as code and the caller / creator receives the address of the new contract on the stack. The only way to remove code from the blockchain is when a contract at that address performs the operation. The remaining Ether stored at that address is sent to a designated target and then the storage and code is removed from the state. Removing the contract in theory sounds like a good idea, but it is potentially dangerous, as if someone sends Ether to removed contracts, the Ether is forever lost. From onwards, will only send all Ether in the account to the given recipient and not destroy the contract. However, when is called in the same transaction that creates the contract calling it, the behaviour of before Cancun hardfork (i.e., ) is preserved and will destroy the current contract, deleting any data, including storage keys, code and the account itself. See EIP-6780 for more details. The new behaviour is the result of a network-wide change that affects all contracts present on the Ethereum mainnet and testnets. It is important to note that this change is dependent on the EVM version of the chain on which the contract is deployed. The setting used when compiling the contract has no bearing on it. Also, note that the opcode has been deprecated in Solidity version 0.8.18, as recommended by EIP-6049. The deprecation is still in effect and the compiler will still emit warnings on its use. Any use in newly deployed contracts is strongly discouraged even if the new behavior is taken into account. Future changes to the EVM might further reduce the functionality of the opcode. Even if a contract is removed by , it is still part of the history of the blockchain and probably retained by most Ethereum nodes. So using is not the same as deleting data from a hard disk. Even if a contract’s code does not contain a call to , it can still perform that operation using or . If you want to deactivate your contracts, you should instead disable them by changing some internal state which causes all functions to revert. This makes it impossible to use the contract, as it returns Ether immediately. There is a small set of contract addresses that are special: The address range between and (including) contains “precompiled contracts” that can be called as any other contract but their behavior (and their gas consumption) is not defined by EVM code stored at that address (they do not contain code) but instead is implemented in the EVM execution environment itself. Different EVM-compatible chains might use a different set of precompiled contracts. It might also be possible that new precompiled contracts are added to the Ethereum main chain in the future, but you can reasonably expect them to always be in the range between and (inclusive)."
    },
    {
        "link": "https://sciencedirect.com/science/article/pii/S0167739X24005302",
        "document": ""
    },
    {
        "link": "https://dl.acm.org/doi/10.1145/3548683",
        "document": ""
    },
    {
        "link": "https://web3js.readthedocs.io",
        "document": "web3.js is a collection of libraries that allow you to interact with a local or remote ethereum node using HTTP, IPC or WebSocket.\n\nThe following documentation will guide you through installing and running web3.js as well as providing an API reference documentation with examples.\n\nSpecial thanks to Netlify for providing build and deploy services for our end-to-end integration tests."
    },
    {
        "link": "https://docs.web3js.org",
        "document": "Web3.js is a robust and flexible collection of TypeScript and JavaScript libraries that allows developers to interact with local or remote Ethereum nodes (or any EVM-compatible blockchain) over HTTP, IPC or WebSocket connections. It is a powerful and efficient toolkit for crafting applications within the Ethereum ecosystem and beyond.\n\nThis documentation is the entrypoint to Web3.js for developers. It covers basic and advanced usage with examples, and includes comprehensive API documentation as well as guides for common tasks, like upgrading from older versions.\n• Efficient\n• Use of native BigInt (instead of large BigNumber libraries)\n• Developer-Friendly\n• In compliance with the Ethereum JSON-RPC Specification\n\nThere is a lot to learn about Web3.js! Here are some tips for developers of different skill levels. Remember, you can always reach out directly with Discord or Twitter if you're feeling stuck.\n\nNew Web3.js developers should proceed to the Quickstart section to learn how to get started with Web3.js. Once you understand the basics, you may want to consider learning more about providers, wallets and accounts, smart contracts, and how to use Web3.js with the Hardhat development environment.\n\nIf you're already familiar with Ethereum and Web3.js development, you may want to review the Web3.js package structure and proceed directly to the package-level documentation and API documentation. Application developers may wish to review the Web3.js configuration guide or learn how to use Web3.js with tools like EIP-6963 wallets or the WalletConnect wallet selection modal. Don't forget to review the list of available plugins or even learn how to build your own Web3.js plugin!\n\nWeb3.js is a modular collection of packages, each of which serves a specific needs. This means developers don't need to install the entire Web3 library for most use cases. Instead, necessary packages are selectively installed for a more efficient development experience. Here is an overview of a selection of available packages:\n• Web3Eth: The package is the entrypoint to Web3.js - it's the control center for managing interactions with Ethereum and other EVM-compatible networks.\n• Net: The package provides discovery and interactions for an Ethereum node's network properties.\n• Accounts: The package has tools for creating Ethereum accounts and the secure signing of transactions and data.\n• Personal: Use for direct communication about your accounts with the Ethereum node, which streamlines account management during development. NOTE: For enhanced security in production and when interacting with public nodes, consider using for local signing operations, which keeps your private keys and sensitive information secure on your local machine\n• Utils: The package provides helpers to perform a range of essential Ethereum development tasks, including converting data formats, checking addresses, encoding and decoding data, hashing, handling numbers, and much more..\n• Contract: The package makes it easy to interact with smart contracts through JavaScript or TypeScript, which streamlines the development process and makes it less error-prone.\n• ABI: The package simplifies decoding logs and parameters, encoding function calls and signatures, and inferring types for efficient Ethereum smart contract interactions.\n• ENS: The package makes it easy for developers to communicate with the Ethereum Name Service (ENS).\n• Iban: The package allows you to switch between Ethereum addresses and special banking-like addresses (IBAN or BBAN) and simplifies conversion between the types.\n• Web3 Core: subscriptions, request management, and configuration used by other Web3 packages\n• Web3 Types: data structures, objects, interfaces and types used by Web3\n• Web3 Errors: error codes and common error classes that are used by other Web3 packages\n• Web3 RPC Methods: functions for making RPC requests to Ethereum using a given provider\n\nWeb3.js supports plugins, which are another way to encapsulate capabilities that support a specific need. There are plugins that exist to support native features, like those described by EIPs as well as plugins that are designed to support specific smart contracts, middleware, or even other Ethereum-compatible networks. Visit the Web3.js plugins homepage to view a list of the most important Web3.js plugins, which includes:\n• Extensive Documentation and Community: Web3.js is one of the most established Ethereum libraries, which means it benefits from extensive documentation and a large, active community. Web3.js is widely adopted and has been thoroughly tested in various production environments, and is compatible with a broad range of other tools and services in the Ethereum ecosystem.\n• Modular Design: Web3.js is designed to be modular, which allows developers to use specific packages according to their needs. This leads to smaller bundle sizes and faster load times for web applications.\n• Active Development and Support: Web3.js sees regular updates and active development. This support is crucial for developers needing assurance that the library they're using will keep pace with the evolving Ethereum landscape."
    },
    {
        "link": "https://web3js.readthedocs.io/en/v1.2.11/web3-eth-contract.html",
        "document": "The object makes it easy to interact with smart contracts on the ethereum blockchain. When you create a new contract object you give it the json interface of the respective smart contract and web3 will auto convert all calls into low level ABI calls over RPC for you.\n\nThis allows you to interact with smart contracts as if they were JavaScript objects.\n\nTo use it standalone:\n\nThe address used for this contract instance. All transactions generated by web3.js from this contract will contain this address as the . The address will be stored in lowercase. - : The address for this contract, or if not yet set.\n\nCreates a transaction object for that method, which then can be called, send, estimated, or ABI encoded. The methods of this smart contract are available through:\n• The name with parameters: This allows calling functions with same name but different parameters from the JavaScript contract object. Parameters of any method depend on the smart contracts methods, defined in the JSON interface.\n• - arguments: The arguments passed to the method before. They can be changed.\n• - : Will call the “constant” method and execute its smart contract method in the EVM without sending a transaction (Can’t alter the smart contract state).\n• - : Will send a transaction to the smart contract and execute its method (Can alter the smart contract state).\n• - : Will estimate the gas used when the method would be executed on chain.\n• - : Encodes the ABI for this method. This can be send using a transaction, call the method or passing into another smart contracts method as argument. // or sending and using a promise // receipt can also be a new contract instance, when coming from a \"contract.deploy({...}).send()\" // or sending and using the events\n\nWill call a “constant” method and execute its smart contract method in the EVM without sending any transaction. Note calling cannot alter the smart contract state.\n• None - (optional): The options used for calling.\n• - (optional): The address the call “transaction” should be made from. For calls the property is optional however it is highly recommended to explicitly set it or it may default to depending on your node or provider.\n• - (optional): The gas price in wei to use for this call “transaction”.\n• - (optional): The maximum gas provided for this call “transaction” (gas limit).\n• - (optional): If you pass this parameter it will not use the default block set with . Pre-defined block numbers as , , and can also be used. Useful for requesting data from or replaying transactions in past blocks.\n• - (optional): This callback will be fired with the result of the smart contract method execution as the second argument, or with an error object as the first argument. returns : The return value(s) of the smart contract method. If it returns a single value, it’s returned as is. If it has multiple return values they are returned as an object with properties and indices: // these are here as fallbacks if the name is not know or given\n\nWill send a transaction to the smart contract and execute its method. Note this can alter the smart contract state.\n• None - : The options used for sending.\n• - : The address the transaction should be sent from.\n• - (optional): The gas price in wei to use for this transaction.\n• - (optional): The maximum gas provided for this transaction (gas limit).\n• - Number|String|BN|BigNumber``(optional): The value transferred for the transaction in wei.\n• - (optional): This callback will be fired first with the “transactionHash”, or with an error object as the first argument. The callback will return the 32 bytes transaction hash. : A promise combined event emitter. Resolves when the transaction receipt is available, OR if this is called from a , then the promise will resolve with the new contract instance. Additionally the following events are available:\n• returns : Fired immediately after the request body has been written to the client, but before the transaction hash is received.\n• returns : Fired when the transaction hash is available.\n• returns : Fired when the transaction receipt is available. Receipts from contracts will have no property, but instead an property with event names as keys and events as properties. See for details about the returned event object.\n• returns , , : Fired for every confirmation up to the 24th confirmation.\n• returns : Fired if an error occurs during sending. If the transaction was rejected by the network with a receipt, the receipt will be available as a property on the error object. // receipt can also be a new contract instance, when coming from a \"contract.deploy({...}).send()\" // If there are multiple of the same event, they will be in an array // If the transaction was rejected by the network with a receipt, the second parameter will be the receipt.\n\nEncodes the ABI for this method. The resulting hex string is 32-bit function signature hash plus the passed parameters in Solidity tightly packed format. This can be used to send a transaction, call a method, or pass it into another smart contract’s method as arguments. Set the field on options as the result and it is the same as calling the contract method with . Some use cases for include: preparing a smart contract transaction for a multisignature wallet, working with offline wallets and cold storage and creating transaction payload for complex smart contract proxy calls. : The encoded ABI byte code to send via a transaction or call."
    },
    {
        "link": "https://web3js.readthedocs.io/en/v1.2.11/web3-eth.html",
        "document": "The package allows you to interact with an Ethereum blockchain and Ethereum smart contracts.\n\nAll Ethereum addresses returned by functions of this package are returned as checksum addresses. This means some letters are uppercase and some are lowercase. Based on that it will calculate a checksum for the address and prove its correctness. Incorrect checksum addresses will throw an error when passed into functions. If you want to circumvent the checksum check you can make an address all lower- or uppercase.\n• None\n• - : The address for the sending account. Uses the property, if not specified. Or an address or index of a local wallet in .\n• - : (optional) The destination address of the message, left undefined for a contract-creation transaction.\n• - : (optional) The value transferred for the transaction in , also the endowment if it’s a contract-creation transaction.\n• - : (optional, default: To-Be-Determined) The amount of gas to use for the transaction (unused gas is refunded).\n• - : (optional) The price of gas for this transaction in , defaults to .\n• - : (optional) Either a ABI byte string containing the data of the function call on a contract, or in the case of a contract-creation transaction the initialisation code.\n• - : (optional) Integer of the nonce. This allows to overwrite your own pending transactions that use the same nonce.\n• None\n• None\n• - : (optional) The name of the chain\n• - : (optional) Optional callback, returns an error object as first parameter and the result as second. The property can also be an address or index from the web3.eth.accounts.wallet. It will then sign locally using the private key of that account, and send the transaction via web3.eth.sendSignedTransaction(). If the properties and or are not set, Web3 will try to set appropriate values by querying the network for its chainId and networkId. The callback will return the 32 bytes transaction hash. : A promise combined event emitter. Resolves when the transaction receipt is available. The following events are also available:\n• returns : Fired immediately after the request body has been written to the client, but before the transaction hash is received.\n• returns : Fired when the transaction hash is available.\n• returns : Fired when the transaction receipt is available.\n• returns , , : Fired for every confirmation up to the 12th confirmation. Receives the confirmation number as the first and the as the second argument. Fired from confirmation 0 on, which is the block where it’s mined. returns : Fired if an error occurs during sending. If the transaction was rejected by the network with a receipt, the receipt will be available as a property on the error object. // If a out of gas error, the second parameter is the receipt.\n\nThis method will request/enable the accounts from the current environment. This method will only work if you’re using the injected provider from a application like Metamask, Status or TrustWallet. It doesn’t work if you’re connected to a node with a default Web3.js provider (WebsocketProvider, HttpProvidder and IpcProvider). For more information about the behavior of this method please read EIP-1102: Opt-in account exposure.\n• - (optional) Optional callback, returns an error object as first parameter and the result as second."
    },
    {
        "link": "https://medium.com/coinmonks/interacting-with-ethereum-smart-contracts-through-web3-js-e0efad17977",
        "document": "Smart contracts are self-executing contracts with the terms of the agreement between buyer and seller which is directly written into lines of code. The code and the agreements contained therein exist across a distributed, decentralized blockchain network. A smart contract enables individuals to exchange data in a trusted, conflict-free manner without relying on a third party like a bank, lawyer or notary. These smart contracts are being stored on the Ethereum Blockchain, hence are needed to be validated or mined like a regular transaction. Ethereum smart contracts are stored as special transactions that can be used to build applications. Contracts written in smart-contract-specific programming languages are compiled into ‘bytecode’, \n\nwhich a feature called the ‘ethereum virtual machine’ (EVM) can read and execute.\n\nSolidity is the language that you can use to code the actual smart contracts. The syntax is very similar to JavaScript and it’s designed with the Ethereum Virtual Machine in mind. Solidity is statically typed, supports inheritance, libraries and contains complex user-defined types.\n\nhash: 256-bit, 32-byte data chunk, indexable into bytes and operable with bitwise operations.\n\nuint: 256-bit unsigned integer, operable with bitwise and unsigned arithmetic operations.\n\nint: 256-bit signed integer, operable with bitwise and signed arithmetic operations.\n\nstring32: zero-terminated ASCII string of maximum length 32-bytes (256-bit).\n\naddress: account identifier, similar to a 160-bit hash type.\n\nbool: two-state value.\n\npublic — all\n\nprivate — only this contract\n\ninternal — only this contract and contracts deriving from it\n\nexternal — Cannot be accessed internally, only externally.\n\nThe solidiy programs can be executed in local machines or using an online IDE called remix. For this blog post, we will be using the online editor.\n\nYou can find the remix ide at\n\nThe smart contracts are sort of like API’s. The objective of this blog is to show how the smart contract can interact with a web UI.\n\nFor brevity, I will be using a very small smart contract.\n\nThe code contains a getter method and a setter method. The setInstructor method sets the value of variables fName and age. And the getInstructor retrieves these values.\n\nThis program can be compiled and executed using the Javascript VM environment of the remix. But in order to attach a web UI to this program we have to use a web3 provider.\n\nNow we’ll be installing Ganache CLI and Web3.js to create a simple user interface that will allow us to interact with our ethereum smart contract.\n\nGanache CLI previously known as TestRPC uses ethereumjs to simulate full client behavior and makes developing Ethereum applications faster, easier, and safer. It also includes all popular RPC functions and features like events and can be run deterministically to make development a breeze. Because it’s based on Node.js, we need Node.js installed along with NPM (Node Package Manager) to install Ganache CLI.\n\nMake sure the node and npm versions are the latest before installing Ganache CLI, using the following commands,\n\nGanache CLI can be installed using the following command\n\nOnce finished, run the following command to start it:\n\nThere are a lot of options for running ganache-cli, which can be referred in their Github page.\n\nThis provides you with 10 different accounts and private keys, along with a local server at localhost:8545.\n\nThe web3.js library is the official Ethereum Javascript API. It is used to interact with Ethereum smart contracts. It is a collection of modules which contain specific functionality for the ethereum ecosystem.\n\nCreate a new directory and change to that directory.\n\nNext, run the npm init command to create a package.json file, which will store project dependencies:\n\nInstall web3.js using the following command\n\nSwitch over to the Remix IDE, click on the Run tab, and then change the Environment drop-down from Javascript VM to Web3 Provider.\n\nHit “OK” and then specify the testrpc/ganache-cli localhost address (by default, it’s http://localhost:8545)\n\nNow instead of deploying and testing in the Javascript VM, we’re now using the Ganache CLI client on your computer.\n\nNext part is to create a simple UI page for our smart contract using HTML, javascript, and CSS. The UI will accept the Instructor’s name and age using two input fields and displays this data in a text field.\n\nWeb3.js library is already present in the head tags and we can connect it to our testrpc/ganache-cli client.\n\nAll the following code should be present inside the script tag in the index.html\n\nIf the web3 is not undefined, we will be using the current provider. This is applicable in cases when we use chrome extensions like meta-mask or if we are using ethereum browsers like Mist. If it’s undefined, we can manually specify the provider ourselves (that is our ganache-cli/testrpc).\n\nNow we have to specify the web3 default account. This can be done by web3.eth.defaultAccount method\n\nHere we are using the first one of the 10 accounts provided by the ganache-cli.\n\nNext, we need to use the web3.eth.contract() method to initialize (or create) the contract on an address. It accepts one parameter, which is referred to as the ABI (Application Binary Interface).\n\nABI is the interface between two program modules, one of which is often at the level of machine code. The interface is the de facto method for encoding/decoding data into/out of the machine code. In Ethereum, it’s basically how you can encode Solidity contract calls for the EVM and, backward, how to read the data out of the transaction\n\nABI can be obtained from remix by clicking on Compile tab and clicking on Details. Scroll down and copy the content of Interface — ABI. This should be passed as the parameter of web3.eth.contract().\n\nNow we have created a variable CoursesContract, the interface for interacting with our contract.\n\nNext step is to specify the address of the contract. This address is available after creating the smart contract by clicking Run in the remix.\n\nIf we check the console of the page in the browser, we can see that variable can be used to call the functions of the contract, like\n\nThese functions can be used in our web-page by calling them using javascript and jquery.\n\nHere we are passing the content of fields, name and age to the smart contract using setInstructor function.\n\nThis function call will display the name and age of the instructor, in the text field of the UI by fetching the data from the smart contact using getInstructor function.\n\nNow if we check the values in remix, we will get\n\nThis is very simple example of how we can interact with a smart contract and this can only be checked in a local environment. Further research should be done to study the interaction in actual environments. Hope this was helpful in understanding some basic concepts.\n\nPlease check out the following links too.\n• YouHodler vs CoinLoan vs Hodlnaut | Cryptohopper vs HaasBot"
    }
]