[
    {
        "link": "https://docs.arduino.cc/libraries/liquidcrystal-i2c",
        "document": ""
    },
    {
        "link": "https://arduino.cc/en/Tutorial/HelloWorld",
        "document": ""
    },
    {
        "link": "https://docs.arduino.cc/learn/electronics/lcd-displays",
        "document": ""
    },
    {
        "link": "https://reference.arduino.cc/reference/en/libraries/liquidcrystal-i2c",
        "document": "Doubts on how to use Github? Learn everything you need to know in this tutorial .\n\nFind anything that can be improved? Suggest corrections and new documentation via GitHub.\n\nA library for I2C LCD displays. \n\n The library allows to control I2C displays with functions extremely similar to LiquidCrystal library. THIS LIBRARY MIGHT NOT BE COMPATIBLE WITH EXISTING SKETCHES.\n\nThis library is compatible with the avr architecture so you should be able to use it on the following Arduino boards:\n\nNote: while the library is supposed to compile correctly on these architectures, it might require specific hardware features that may be available only on some boards.\n\nTo use this library, open the Library Manager in the Arduino IDE and install it from there."
    },
    {
        "link": "https://make-it.ca/i2c-lcd-display-on-arduino",
        "document": "How To Control an I2C LCD with Arduino\n\nHow To Setup a 2×16 or 4×20 LCD Display\n\nThe Arduino family of devices is features rich and offers many capabilities. The ability to interface to external devices readily is very enticing, although the Arduino has a limited number of input/output options. Adding an external display would typically require several of the limited I/O pins. Using an I2C interface, only two connections for an LCD character display are possible with stunning professional results. We offer both 2 x 16 and 4 x 20 LCD displays.\n\nThe character LCD is ideal for displaying text and numbers and special characters. LCDs incorporate a small add-on circuit (backpack) mounted on the back of the LCD module. The module features a controller chip handling I2C communications and an adjustable potentiometer for changing the intensity of the LED backlight. An I2C LCD advantage is that wiring is straightforward, requiring only two data pins to control the LCD.\n\nA standard LCD requires over ten connections, which can be a problem if your Arduino does not have many GPIO pins available. If you happen to have an LCD without an I2C interface incorporated into the design, these can be easily acquired separately.\n\nThe LCD displays each character through a matrix grid of 5×8 pixels. These pixels can display standard text, numbers, or special characters and can also be programmed to display custom characters easily.\n\nHow To Connect the I2C LCD to Arduino UNO\n\nConnecting the Arduino UNO to the I2C interface of the LCD requires only four connections. The connections include two for power and two for data. The chart below shows the connections needed.\n\nOnce you have the four connections to your LCD made, you can power your Arduino, which will provide power to the LCD. The LCD has an adjustment on it which needs to be approximately set to allow you to see characters on the display. You must now adjust that contrast setting.\n\nLocated on the back of the LCD screen is the I2C interface board, and on the interface is an adjustable potentiometer. This adjustment is made with a small screwdriver. You will adjust the potentiometer until a series of rectangles appear – this will allow you to see your programming results.\n\nAfter you have your first program loaded, and you can see the output on the LCD, you can go back and adjust the contrast control for optimal viewing.\n\nThe Arduino module and editor do not know how to communicate with the I2C interface on the LCD. The parameter to enable the Arduino to send commands to the LCD are in separately downloaded LiquidCrystal_I2C library.\n\nThe LiquidCrystal_I2C is available from GitHub. When visiting the GitHub page, select the Code button and from the drop-down menu, choose Download ZIP option to save the file to a convenient location on your workstation.\n\nWe also have the LiquidCrystal_I2C library available for download directly on our site should the master GitHub repository ever disappear.\n\nBefore installing LiquidCrystal_I2C, remove any other libraries that may reside in the Arduino IDE with the same LiquidCrystal_I2C name. Doing this will ensure that only the known good library is in use. LiquidCrystal_I2C works in combination with the preinstalled Wire.h library in the Arduino editor.\n\nTo install the LiquidCrystal_I2C library, use the SketchSketch > Include Library > Add .ZIP Library… from the Arduino IDE (see example). Point to the LiquidCrystal_I2C-master.zip which you previously downloaded and the Library will be installed and set up for use.\n\nSeveral examples and code are included in the Library installation, which can provide some reference and programming examples. You can use these example sketches as a basis for developing your own code for the LCD display module.\n\nThere may be situations where you should uninstall the Arduino IDE. The reason for this could be due to Library conflicts or other configuration issues. There are a few simple steps to uninstalling the IDE.\n• Delete the Documents -> Arduino -> Libraries to remove all your libraries\n• Delete the User -> AppData -> Local -> Arduino15 folder to remove all the preferences\n\nDetermining the I2C Address of the LCD Module\n\nNot all I2C adapters have the same or consistent I2C address. Many use the default address of 0x27, while others may use the address of 0x20.\n\nThe I2c address can be changed by shorting the address solder pads on the I2C module. You will need to know the actual address of the LCD before you can start using it.\n\nWe have a simple Arduino sketch that scans the I2C bus and displays the I2C address of any devices in the serial monitor.\n\nUse the sketch below and turn on the Serial Monitor (keyboard shortcut of Ctrl + Shift + M).\n\nRecord the I2C address displayed, as you will need it later when programming the LCD.\n\nOnce you have the LCD connected and have determined the I2C address, you can proceed to write code to display on the screen. The code segment below is a complete sketch ready for downloading to your Arduino.\n\nThe code assumes the I2C address of the LCD screen is at 0x27 and can be adjusted on the LiquidCrystal_I2C lcd = LiquidCrystal_I2C(0x27,16,2); as required.\n\n// ------------------------------------------------------------ // Hello World! Demo - Updated for PCBoard.ca 2024-08-23 // // This sketch displays a simple message to the LCD screen // ------------------------------------------------------------ #include <LiquidCrystal_I2C.h> // Driver Library for the LCD Module // Wiring: Connect SDA pin to A4 and SCL pin to A5 // Connects to LCD via I2C, at address 0x27 (A0-A2 not jumpered) LiquidCrystal_I2C lcd = LiquidCrystal_I2C(0x27,16,2); // Adjust to (0x27,20,4) for 20x4 LCD void setup() { // Initiate the LCD and turn on the backlight lcd.init(); // Initiate the LCD module lcd.backlight(); // Turn on the backlight } void loop() { // Print 'Hello World!' on the first line of the LCD lcd.setCursor(0, 0); // Set the cursor on the first column and first row. lcd.print(\"Hello World!\"); // Print the string \"Hello World!\" lcd.setCursor(1, 1); //Set cursor to 2nd column and 2nd row (counting starts at 0) lcd.print(\"www.PCBoard.ca\"); } // This sketch displays a simple message to the LCD screen // Wiring: Connect SDA pin to A4 and SCL pin to A5 // Connects to LCD via I2C, at address 0x27 (A0-A2 not jumpered) // Initiate the LCD and turn on the backlight // Print 'Hello World!' on the first line of the LCD // Set the cursor on the first column and first row. //Set cursor to 2nd column and 2nd row (counting starts at 0)"
    },
    {
        "link": "https://github.com/JChristensen/DS3232RTC",
        "document": "This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License v3.0 as published by the Free Software Foundation.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License along with this program. If not, see https://www.gnu.org/licenses/gpl.html\n\nThe 2.0.0 version of the library has some significant changes and is not completely backwards compatible with earlier versions. These changes provide a more consistent API and reduce the possibility of name collisions. While sketches using this library will likely require changes as a result, these should be mostly straightforward.\n• The library no longer defines a object, therefore each sketch needs to define one. (Previous versions of the library defined a DS3232RTC object named , although only for AVR architecture. Consider using a name other than as this can cause a name collision on some architectures.)\n• The constructor no longer has the capability to initialize the I2C bus and no longer accepts an optional parameter. Therefore, the sketch needs to call in the function or elsewhere as appropriate.\n• To reduce the possibility of name collisions, the enumerations as well as register addresses, etc. are now defined in the header file within the DS3232RTC class. Therefore, when using any of these names, it will be necessary to include the DS3232RTC scope, e.g.\n• Also to reduce collisions, register address names and bit names have been prefixed with (see the header file.)\n• The example sketches and documentation have been updated to reflect these changes.\n\nDS3232RTC is an Arduino library that supports the Maxim Integrated DS3231 and DS3232 Real-Time Clocks. This library is intended to be used with PJRC's Arduino Time library.\n\nThe DS3232RTC library also implements functions to support the additional features of the DS3232 and DS3231. The DS3232 has the same features as the DS3231, but the DS3232 also has these extra features:\n\nThe following example sketches are included with the DS3232RTC library:\n• TimeRTC: A simple example to display the time and date.\n• SetSerial: Set the RTC's date and time from the Arduino serial monitor. Displays date, time and temperature.\n• rtc_temperature: Displays time and temperature but initiates a temperature conversion every 10 seconds in addition to the RTC's default conversion period of 64 seconds.\n• rtc_interrupt: Uses a 1Hz interrupt from the RTC to keep time.\n• mcu_clock_drift: Demonstrates that MCU time as kept by the Time library will drift as compared to RTC time, and that MCU time may not increase by one second every second.\n• tiny3232_KnockBang: Demonstrates interfacing an ATtiny45/85 to a DS3231 or DS3232 RTC.\n• Several examples for using the RTC alarms. See the alarm primer for more information.\n\nWhen using the DS3232RTC library, the user is responsible for ensuring that reads and writes do not exceed the device's address space (0x00-0x12 for DS3231, 0x00-0xFF for DS3232); no bounds checking is done by the library.\n\nSymbolic names used with the function (described below).\n• ALM1_EVERY_SECOND -- causes an alarm once per second.\n• ALM1_MATCH_SECONDS -- causes an alarm when the seconds match (i.e. once per minute).\n• ALM1_MATCH_MINUTES -- causes an alarm when the minutes and seconds match.\n• ALM1_MATCH_HOURS -- causes an alarm when the hours and minutes and seconds match.\n• ALM1_MATCH_DATE -- causes an alarm when the date of the month and hours and minutes and seconds match.\n• ALM1_MATCH_DAY -- causes an alarm when the day of the week and hours and minutes and seconds match.\n• ALM2_EVERY_MINUTE -- causes an alarm once per minute.\n• ALM2_MATCH_MINUTES -- causes an alarm when the minutes match (i.e. once per hour).\n• ALM2_MATCH_HOURS -- causes an alarm when the hours and minutes match.\n• ALM2_MATCH_DATE -- causes an alarm when the date of the month and hours and minutes match.\n• ALM2_MATCH_DAY -- causes an alarm when the day of the week and hours and minutes match.\n\nSymbolic names used with the squareWave() function (described below).\n\nReads the current date and time from the RTC and returns it as a value. Returns zero if an I2C error occurs (RTC not present, etc.).\n\nSets the RTC date and time to the given value. Clears the oscillator stop flag (OSF) bit in the control/status register. See the function and also the DS323x datasheet for more information on the OSF bit.\n\nt: The date and time to set the RTC to (time_t)\n\nReads the current date and time from the RTC and returns it as a structure. See the Arduino Time Library for details on the structure.\n\ntm: Address of a structure to which the date and time are returned.\n\nI2C status (uint8_t). Returns zero if successful. The date and time read from the RTC are returned to the parameter.\n\nSets the RTC to the date and time given by a structure. Clears the oscillator stop flag (OSF) bit in the control/status register. See the function and also the DS323x datasheet for more information on the OSF bit.\n\ntm: Address of a structure used to set the date and time.\n\nThe DS3231 and DS3232 have two alarms. Alarm1 can be set to seconds precision; Alarm2 can only be set to minutes precision.\n\nSet an alarm time. Sets the alarm registers only. To cause the INT pin to be asserted on alarm match, use . This function can set either Alarm 1 or Alarm 2, depending on the value of (use the enumeration above). When setting Alarm 2, the seconds value must be supplied but is ignored, recommend using zero. (Alarm 2 has no seconds register.)\n\nalarmType: A value from the enumeration, above. (ALARM_TYPES_t)\n\n seconds: The seconds value to set the alarm to. (uint8_t)\n\n minutes: The minutes value to set the alarm to. (uint8_t)\n\n hours: The hours value to set the alarm to. (uint8_t)\n\n dayOrDate: The day of the week or the date of the month. For day of the week, use a value from the Time library enumeration, i.e. dowSunday, dowMonday, dowTuesday, dowWednesday, dowThursday, dowFriday, dowSaturday. (uint8_t)\n\nSet an alarm time. Sets the alarm registers only. To cause the INT pin to be asserted on alarm match, use . This function can set either Alarm 1 or Alarm 2, depending on the value of e (use the enumeration above). However, when using this function to set Alarm 1, the seconds value is set to zero. (Alarm 2 has no seconds register.)\n\nalarmType: A value from the ALARM_TYPES_t enumeration, above. (ALARM_TYPES_t)\n\n minutes: The minutes value to set the alarm to. (uint8_t)\n\n hours: The hours value to set the alarm to. (uint8_t)\n\n dayOrDate: The day of the week or the date of the month. For day of the week, use a value from the Time library timeDayOfWeek_t enumeration, i.e. dowSunday, dowMonday, dowTuesday, dowWednesday, dowThursday, dowFriday, dowSaturday. (uint8_t)\n\nEnable or disable an alarm \"interrupt\". Note that this \"interrupt\" just causes the RTC's INT pin to be asserted. To use this signal as an actual interrupt to (for example) a microcontroller, the RTC \"interrupt\" pin needs to be connected to the microcontroller and the microcontroller application firmware must properly configure the interrupt and also provide for handling it.\n\nalarmNumber: The number of the alarm to enable or disable, ALARM_1 or ALARM_2 (ALARM_NBR_t)\n\n alarmEnabled: true or false (bool)\n\nTests whether an alarm has been triggered. If the alarm was triggered, returns true and resets the alarm flag in the RTC, else returns false.\n\nalarmNumber: The number of the alarm to test, or (ALARM_NBR_t)\n\nValue of the alarm flag bit (bool)\n\nTests whether an alarm has been triggered. If the alarm was triggered, returns true, else returns false. The alarm flag is not reset.\n\nalarmNumber: The number of the alarm to test, or (ALARM_NBR_t)\n\nValue of the alarm flag bit (bool)\n\nalarmNumber: The number of the alarm to test, ALARM_1 or ALARM_2 (ALARM_NBR_t)\n\nValue of the alarm flag bit, before it was cleared (bool)\n\nThe DS3232RTC.h file defines symbolic names for the timekeeping, alarm, status and control registers. These can be used for the addr argument in the functions below.\n\nWrite one or more bytes to RTC memory.\n\naddr: First SRAM address to write (uint8_t). The valid address range is 0x00-0x12 for DS3231, 0x00-0xFF for DS3232. The general-purpose SRAM for the DS3232 begins at address 0x14. Address is not checked for validity by the library.\n\n values: An array of values to write (*uint8_t)\n\n nBytes: Number of bytes to write (uint8_t). Must be between 1 and 31 (Wire library limitation) but is not checked by the library.\n\naddr: SRAM address to write (uint8_t). The valid address range is 0x00-0x12 for DS3231, 0x00-0xFF for DS3232. The general-purpose SRAM for the DS3232 begins at address 0x14. Address is not checked for validity by the library.\n\n value: Value to write (uint8_t)\n\nRead one or more bytes from RTC RAM.\n\naddr: First SRAM address to read (uint8_t). The valid address range is 0x00-0x12 for DS3231, 0x00-0xFF for DS3232. The general-purpose SRAM for the DS3232 begins at address 0x14. Address is not checked for validity by the library.\n\n values: An array to receive the values read (*uint8_t)\n\n nBytes: Number of bytes to read (uint8_t). Must be between 1 and 32 (Wire library limitation) but is not checked by the library.\n\naddr: SRAM address to read (uint8_t). The valid address range is 0x00-0x12 for DS3231, 0x00-0xFF for DS3232. The general-purpose SRAM for the DS3232 begins at address 0x14. Address is not checked for validity by the library.\n\nValue read from the RTC (uint8_t)\n\nfreq: a value from the enumeration above. (SQWAVE_FREQS_t)\n\nReturns the value of the oscillator stop flag (OSF) bit in the control/status register which indicates that the oscillator is or was stopped, and that the timekeeping data may be invalid. Optionally clears the OSF bit depending on the argument passed. If the argument is omitted, the OSF bit is cleared by default. Calls to and also clear the OSF bit.\n\nclearOSF: an optional true or false value to indicate whether the OSF bit should be cleared (reset). If not supplied, a default value of true is used, resetting the OSF bit. (bool)"
    },
    {
        "link": "https://reference.arduino.cc/reference/en/libraries/ds3232rtc",
        "document": "Find anything that can be improved? Suggest corrections and new documentation via GitHub.\n\nDoubts on how to use Github? Learn everything you need to know in this tutorial."
    },
    {
        "link": "https://forum.arduino.cc/t/using-the-ram-of-ds3232rtc-with-arduino-uno/955234",
        "document": "I am new on this forum. (but I already read some very interesting exchanges here)\n\nMy current project is to follow the curse of the sun during the day. For that I use an arduino Uno with a RTC (DS3231 or DS3232).\n\nFor the RTC I use the Library DS3232RTC-master of Jack Christensen.\n\nMy problem is that I cannot manage to register and read data using the RAM of the RTC module. :\n\nI want either read variables through USB (no problem for that ) :\n\nthen record the data in the RAM of RTC by using the following command :\n\neither read in the RAM of RTC by using the following command :\n\nI don’t manage to fill the 2nd parameter and I didn’t find any example of the use of these 2 commands on the net.\n\nSomeone can give an advice or propose an example ?\n\nThanks in advance for your help !"
    },
    {
        "link": "https://steemit.com/utopian-io/@drencolha/ds3232-real-time-clock-module-setup-arduino-library-use-shown-with-an-example-project-tutorial",
        "document": "This is a tutorial of an open source Arduino library, which lets you turn your Arduino to a “Clock”, with a Maxim Integrated DS3232 Real Time Clock module. I will show you how to install the library to Arduino IDE and make an example project with the library, throughout this tutorial while giving information digital clocks and their working principle.\n\nIn this tutorial you will learn:\n• How to install DS3232RTC library to Arduino IDE.\n• How to use DS3232RTC library and how to use It’s functions.\n• How to apply Arduino real time clock project using the library functions.\n\nWhat is a Digital Clock and How It Works\n\nA digital clock is a clock consisting of a power supply, a circuit consisting of an crystal oscillator and a display to show the time, which shows the time digitally unlike traditional analog clocks. First digital clock is made by an Austrian engineer named Josef Pallweber using a jump hour mechanism. Digital clocks have the same fundamental working principle as the analog clocks. They need a source of power to run the clock, which is the power supply, a battery or AC power, a display which can be a LED, LCD display or a seven segment display, and a time base that keeps track of the time which is the time circuit consisting of an crystal oscillator and a counter. The crystal oscillator creates a steady 60 or 50 Hertz signal. Then created signal is divided down using a counter circuit in order to create a binary number. Then this number is converted to the time format desired (12 hour or 24 hour format) and sent to the display. Digital clocks are used in nearly everywhere in our lives, such as ovens, cars, phones, televisions, computers, radios, industrial timers.\n\nHow to Install DS3232RTC Library to Arduino IDE\n\n2. Open Arduino IDE. Then go to and select Sketch->Include Library->Add .ZIP Library.\n\nAn Example Project Using DS3232RTC Arduino Library\n\nI'll show you step by step how to use the DS3232RTC Arduino library with a simple example. In this example project, we will make a real time digital clock with an Arduino microcontroller, and a Maxim Integrated DS3232 or DS3231 Real-Time Clock module. In order to make a real time digital clock with an Arduino, first we’ll have to get the time from the real time clock module. Then we need to print the time in certain intervals to the serial monitor screen. Connections for DS3232 real time clock module to Arduino is shown below.\n\nIf you use this library in your other projects please tell in the comments.\n\nConnection diagram for DS3232 real time clock module to Arduino. Made with Fritzing.\n\n1. Open a new sketch and save it as \"Real_Time_Clock”.\n\n2. To add our library to our sketch, type #include <DS3232RTC.h> at the beginning of the code.\n\n3. First we need to add the setup commands. In the void setup() function, add the code that starts serial communication in 9600 baud rate. Then type the library function to get the time from the RTC module. Add an if statement afterwards, which will trigger if the Arduino cannot sync up with the real time clock module and prints the situation to serial monitor. Add an else statement and make it print that the system time is set.\n\n4. After setup is done, we need to create a function that returns the time and prints the time to serial monitor. Name the void returning function “displayTime”. Add the codes below which prints the time to serial monitor.\n\n5. Then we need to add the digit function that that prints preceding colon and leading 0, as used in the “displayTime” function. Add the codes below.\n\n6. In the void loop() function, add the function that we created in order to print the real world time to serial monitor. Then add an 1 second interval between the time printings using delay command. You can change the interval as desired.\n\n7. Click “Verify” and then “Upload” in order to compile and execute your codes. You should get a readings screen like this. Make sure your COM port and board setting is set right.\n\nIn this tutorial I’ve shown how to install “DS3232RTC” Arduino library, written by GitHub user “JChristensen” to Arduino IDE, showing how to use the library functions with an example, while giving information about what digital clocks are and their working principle.\n\n I hope that you enjoyed this tutorial and the information that I’ve given. Thank you for reading.\n\nIf you want more information about the library and the source use the link below."
    },
    {
        "link": "https://arduino.stackexchange.com/questions/71928/setting-time-function-with-ds3232-library",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    }
]