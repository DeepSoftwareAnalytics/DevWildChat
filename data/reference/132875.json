[
    {
        "link": "https://stackoverflow.com/questions/44003524/inherit-callable-objects-with-different-arguments",
        "document": "I have this problem which looks quite weird... so maybe I am just getting the whole thing wrong -- in such case, please, let me know.\n\nI have a base class which implements method. This method does some pre-processing, then invokes an abstract method and does some post-processing, like this:\n\nI would like to be able to subclass the base callable object adding a method, with a proper docstring, that accepts different arguments and then bounces onto . I am having some issues as I should also change the signature of the concrete implementation of the , e.g.:\n\nI did like this and since complains:\n\nI assume there is something fishy going on. Any suggestion for a better design? Maybe I should constrain the and methods to accept only ? Thanks in advance!"
    },
    {
        "link": "https://realpython.com/python-callable-instances",
        "document": "In Python, a callable is any object that you can call using a pair of parentheses and, optionally, a series of arguments. Functions, classes, and methods are all common examples of callables in Python. Besides these, you can also create custom classes that produce callable instances. To do this, you can add the special method to your class.\n\nInstances of a class with a method behave like functions, providing a flexible and handy way to add functionality to your objects. Understanding how to create and use callable instances is a valuable skill for you as a Python developer.\n• Understand the concept of callable objects in Python\n• Create callable instances by providing your classes with a method\n• Understand the difference between and\n• Code several examples of using callable instances to solve real-world problems\n\nTo get the most out of this tutorial, you should be comfortable with the basics of object-oriented programming in Python, including how to define and use classes and methods. Some familiarity with Python decorators and the strategy design pattern will also help. You should also understand the concept of state.\n\nA callable in Python is any object that you can call using a pair of parentheses and a series of arguments if required. You’ll find different examples of callables in your daily interaction with Python. Some of them include:\n• User-defined functions that you create with the keyword\n• Anonymous functions that you write using the keyword\n• The constructors of your custom classes\n• Instances of classes that implement the method\n• Closures that you return from your functions\n• Generator functions that you define using the keyword\n• Asynchronous functions and methods that you create with the keyword All these different callables have something in common. They all implement the special method. To confirm this fact, you can use the built-in function, which takes an object as an argument and returns the object’s list of attributes and methods: In the first two examples, you call with the built-in and functions as arguments. In both cases, you can see that the method is present in the output. In the final example, you define a custom function that prints a message to the screen. This function also has . Note how you can use this method to call the function: Note that using as you did in this example produces the same effect as calling the function directly with . Note: Even though you can call special methods like directly, doing so isn’t a recommended or best practice. Instead, call the functions as usual. Now, how does all this work internally? When you run something like , Python internally translates the operation into . The arguments to the regular function are the same as those used in . In other words, whenever you call a callable object, Python automatically runs its method behind the scenes using the arguments you’ve passed into the callable. Now take a look at the following custom class: In Python, everything is an object. Classes like are objects of , which you can confirm by calling with the class object as an argument or by accessing the attribute. The class constructor of falls back to using . That’s why you can call to get a new instance. So, class constructors are callable objects that return new instances of the underlying class. In the example above, you can observe that method objects, like , also have a special method that turns them into callable objects. The main takeaway here is that to be callable, an object needs to have a method. If you inspect a closure, generator function, or asynchronous function, then you’ll get similar results. You’ll always find a method in callable objects.\n\nChecking Whether an Object Is Callable If you ever need to check whether a Python object is callable, then you can use the built-in function like in the following examples: The function takes an object as an argument and returns if the object is callable. Otherwise, it returns . Note: Because checks if a given object has a method, you could use it to check if that object is callable. Even though can be useful when you’re experimenting with code and examples, isn’t particularly helpful when you need to quickly check whether an object is callable. The function, in contrast, is a predicate function that you can directly use in a Boolean context. In the above examples, all the tested objects are callable except for . That’s foreseeable because doesn’t implement a method for its instances. Yes, you guessed it! You can make the instances of your custom classes callable by writing a method. In the following section, you’ll learn the basics of turning the instances of your classes into callable objects. But first, it’s important to note that sometimes may produce false positives: In this example, returns . However, instances of this custom class aren’t callable, and you get an error if you try to call them. So, only guarantees that the target instance comes from a class that implements a method.\n\nIf you want the instances of a given class to be callable, then you need to implement the special method in the underlying class. This method enables you to call the instances of your class as you’d call regular Python functions. Unlike other special methods, doesn’t have special requirements for what arguments it must accept. It works like any other instance method in the sense that it takes as its first argument and can take as many extra arguments as you need. Here’s an example of how instances of a class with a method work: In this class, you have a instance attribute to keep track of the current count. Then you have an method that adds to the count every time you call it. Finally, you add a method. In this example, falls back to calling , providing a shortcut for running the increment operation. Take a look at how the class works in practice: After creating an instance of , you call . This call increments the attribute by , as you can confirm by accessing the attribute. In the rest of the examples, you take advantage of the fact that your class has a method and call the instance directly to increment the count. In this example, provides a quick shortcut for running the count increment operation. This feature gives your class a convenient and user-friendly interface. The method in the above example doesn’t take any arguments. The method doesn’t return an explicit value either. However, there are no restrictions on how to write the method in your custom classes. So, you can make them take arguments, return values, and even cause side effects like in your class example. For a second example, consider the following class, which allows you to create callable objects to compute different powers: In this example, your class takes as an argument, which you’ll use later to run different power operations. The method takes a argument and calculates its power using the previously provided exponent. Finally, the method returns the computed result. Here, you use to create two different callable instances. The first instance raises numbers to the power of , while the second instance raises numbers to the power of . In this example, you need to pass as an argument when calling or because those calls fall back to calling , which takes a argument. Finally, note how you get the power back from every call. That’s because returns the result of calculating the desired power. Defining a method in custom classes allows you to use the instances of those classes as regular Python functions. This feature can come in handy in several situations, as you’ll learn in the section Putting Python’s Into Action. Before jumping into common use cases of callable instances, you’ll explore the differences between the and methods. These two methods and their corresponding roles in Python classes can be confusing for people who are beginning to work with Python.\n\nDifferentiating the roles of and in a Python class can be a confusing task for developers who are starting to study the language or its object-oriented features. However, these two methods are pretty different, and each one has specific goals. The method is the instance initializer. Python calls this method automatically whenever you create an instance of a class by calling the class constructor. The arguments to will be the same as the arguments to the class constructor, and they’ll typically provide initial values for instance attributes. Meanwhile, the method turns instances into callable objects. As you already learned, Python automatically calls this method whenever you call a concrete instance of a given class. To illustrate the differences between both methods, consider the following example class: This class implements both and . In , you print a message and initialize the attribute. In , you only print a message so that you learn when the method gets called with a given argument. Call an instance of Demo with Hello! As you can see, each method has a different role in your class. The method gets called when you create instances of the class. Its main goal is to initialize instance attributes with sensible initial values. You’ll find in all Python classes. Some classes will have an explicit implementation, and others will inherit the method from a parent class. In many cases, is the class that provides this method: Remember that is the ultimate parent class of all Python classes. So, even if you don’t define an explicit method in one of your custom classes, that class will still inherit the default implementation from . In contrast, the method runs when you call a concrete instance of its containing class, such as in this example. The goal of is to turn your instances into callable objects. In other words, its purpose is to create objects that you can call as you would call a regular function. Most Python classes don’t implement this method. Your custom classes will have it only if you need to use your instances as functions. Great! After clarifying the differences between and , you’re ready to continue learning about by discovering how you can take advantage of this method in your Python code.\n\nWriting classes that produce callable instances can be pretty useful in a few situations. For example, you can take advantage of callable instances when you need to: Even though you can use functions or classes with regular methods to solve all these problems, using callable instances may be a good option in some situations. This is especially true when you already have an existing class and face the need for function-like behavior. In the following sections, you’ll write practical examples that illustrate each of these use cases of callable instances in Python. Sometimes, you may want to write callable objects that retain state between calls, which are commonly known as stateful callables. For example, say that you want to write a callable that takes consecutive numeric values from a data stream and computes their cumulative average. Between calls, the callable must keep track of previously passed values. To solve this problem, you can use a closure that looks something like this: In , you use a local variable called to hold the data between calls. Then you define an inner function called . This function takes a new value in each call and appends it to . Then the function computes and returns the average of the currently stored data. Finally, returns the inner function. In practice, it returns a closure, which is a special object that packs together the function and its non-local scope. In this example, that closure includes the variable. Once you’ve finished writing , then you can create custom closures like . This object is callable, so you can use it as a function to compute the cumulative average of a data stream, as you did in the final examples above. Even though closures allow you to retain state between calls, these tools may be hard to understand and process. In this sense, writing a class with a method can facilitate the task and make your code more readable and explicit. Note: To dive deeper into closures and scopes in Python, check out Exploring Scopes and Closures in Python. Here’s how you can solve the above problem using a class with a method: In this example, your class has an instance attribute called to hold the data. The method takes a new value in each call, appends the value to , and finally computes and returns the average. In this case, your code is quite readable. The attribute retains the state between calls, while the method computes the cumulative average. Here’s how this class works in practice: The instances of are callables that retain the previously entered values and compute the cumulative average in each call. This approach makes your code easier to reason about. To write this class, you don’t have to know about the intricacies of how closures work in Python. Another interesting advantage is that now you have direct access to the current data through the attribute. Another common use case of callable instances is when you need a stateful callable that caches computed data between calls. This will be handy when you need to optimize some algorithms. For example, say that you want to compute the factorial of a given number. Because you plan to run this computation multiple times, you need to make it efficient. A way to do this is to cache the already-computed values so that you don’t have to recompute them all the time. Here’s a class that achieves this result using and caching: In this class, you use a dictionary to cache already-computed factorial values. The dictionary keys hold already-passed numbers, and the dictionary values hold already-calculated factorials. The method checks if the current input number is already in the dictionary. If that’s the case, then the method returns the corresponding value without running the computation again. This behavior optimizes your algorithm, making it faster. If the current input number isn’t in the dictionary, then the method computes the factorial recursively, caches the result, and returns the final value to the caller. Each call to the instance of checks the cache for already-computed values. The instance only computes factorials for those numbers that haven’t been passed yet. Note how all the input values and their corresponding factorials end up stored in the dictionary. Writing classes that produce callable instances also allows you to design convenient and user-friendly application programming interfaces (APIs) for your libraries, packages, and modules. For example, say you’re writing a new and cool library for creating GUI applications. Your library will have a class that provides all the functionalities to create the main window of your GUI apps. The class will have several methods, including a method to draw the window on the screen. In this case, you can provide a method like the following: In this example, the method falls back to calling the method. This implementation enables you to show your main window by calling either or the window instance itself: In this example, provides a handy shortcut to display the app’s window on your screen. This can improve your user’s experience. So, this trick is a great way to create user-friendly and intuitive interfaces for your Python projects. Another use case where can help you improve your APIs is when you have a class whose primary purpose is to provide a single action or behavior. For example, say you want a class that takes care of logging messages to a file: In this example, the main purpose of is to write messages to a log file that you should provide. By implementing the method, you provide a shortcut for accessing this functionality by calling the object like a function.\n\nSo far, you’ve learned a lot about creating callable instances using the method in your classes. This method also has some advanced use cases in Python. One of these use cases is when you want to create class-based decorators. In this situation, the method is the only way to go because it enables callable instances. Another interesting use case of is when you need to implement the strategy design pattern in Python. In this case, you can take advantage of to create classes that provide implementations for your different strategies. In the following sections, you’ll learn how to use to create class-based decorators and also to implement the strategy pattern in Python. Python’s decorators are callables that take another callable as an argument and extend its behavior without explicitly modifying its code. Decorators provide an excellent tool for adding new functionality to existing callables. It’s pretty common to find and write function-based decorators. However, you can also write class-based decorators by taking advantage of the special method. To illustrate how you can do this, say that you want to create a decorator that measures the execution time of your custom functions. The code below shows how you can write this decorator as a class: The class takes a function object as an argument at instantiation time. The method operates on that function object. In this example, uses the and generic arguments to handle any arguments that the input function requires. Next, you use to get the time before and after the input function executes. Then you print a message with the function’s name and the execution time in milliseconds. The final step is to return the result of calling the input function. Note: For a deep dive into best practices for timing code in Python, check out Python Timer Functions: Three Ways to Monitor Your Code. With this class in place, you can start measuring the execution time of your Python functions right away: In this code snippet, you have a function that takes a list of numbers and returns a list of square values. You want to measure the execution time of this function, so you use your decorator to that end. Once the function is decorated, whenever you run it, you get a message with the function name and the execution time in milliseconds. Then you get the function’s return value. Now say that you want to add a argument to your decorator. This argument will allow you to run the input function several times and compute the average execution time: This updated version of is quite different from your original implementation. The class initializer takes an argument that you need to provide as part of the decorator call. In , you take the input function as an argument. Then you create an inner function to process the input function’s execution. Inside this inner function, you use a loop to run the input function multiple times and compute the total execution time. Next, you calculate the average execution time and print an informative message as usual. Finally, you return the input function’s result. Note that returns the function object represented by . With these changes in place, go ahead and try again. Note that to access this new version of , you need to reload the file or restart your current interactive session first: Your decorator now allows you to run the target function a specific number of times and calculate the average execution time. That’s great! The strategy design pattern allows you to define a family of similar algorithms and make them interchangeable at runtime. In other words, the pattern implements different solutions to a given type of problem, with each solution bundled in a specific object. Then, you can choose the appropriate solution dynamically. Note: The strategy design pattern is also pretty useful in languages where functions aren’t first-class citizens. For example, in C++ or Java, using this pattern allows you to pass functions as arguments to other functions. As an example of how to use to implement the strategy pattern, say that you need to serialize some data into JSON or YAML, depending on certain conditions. In this case, you can use the strategy pattern. You’ll have a class to serialize data into JSON and another class to serialize data into YAML. In the example below, you’ll code a possible solution to your problem. Note that for the example to work, you first need to install using because the Python standard library doesn’t offer appropriate tools for processing YAML data. It’s a missing battery. Note: To install , you should first create a Python virtual environment if you haven’t yet. That way, you’ll avoid cluttering your system Python installation with packages that you won’t use on a daily basis. In this example, you have the and classes, which represent your serializing strategies. Their methods use appropriate tools to serialize the input data into JSON and YAML, respectively. Then you have the class, which provides the higher-level class. You’ll use this class to serialize your data. First, you need to provide an appropriate callable instance of a concrete serializer class: In this code snippet, you have a dictionary containing some sample data. To process this data, you create an instance of using as an argument. After this step, your instance can convert your dictionary into JSON. In the final example, you change the serializing strategy and use your data serializer to convert the data into YAML code. Do you have ideas for other useful data serializers?"
    },
    {
        "link": "https://stackoverflow.com/questions/24793119/how-does-automatic-inheritance-from-collections-callable-and-other-classes-wor",
        "document": "This is more of a Python 2 question, but I'm curious about whether there are any differences in Python 3 as well.\n\nI noticed that when creating certain methods on class (whether they are new-style or not), Python automatically decides that those classes are instances of some classes from the collections module. My example below demonstrates this with collections.Callable.\n\nYou'll notice that I haven't explicitly made any of those classes inherit from collections.Callable, but for some reason they all do as long as they create a method. Is this done for a specific purpose and is it well defined somewhere? Is Python automatically giving classes certain base classes just for defining methods or is something else going on?\n\nYou'll get similar results for collections.Iterable and the method and some other special methods as well."
    },
    {
        "link": "https://docs.python.org/3/reference/datamodel.html",
        "document": "Objects are Python’s abstraction for data. All data in a Python program is represented by objects or by relations between objects. (In a sense, and in conformance to Von Neumann’s model of a “stored program computer”, code is also represented by objects.) Every object has an identity, a type and a value. An object’s identity never changes once it has been created; you may think of it as the object’s address in memory. The operator compares the identity of two objects; the function returns an integer representing its identity. CPython implementation detail: For CPython, is the memory address where is stored. An object’s type determines the operations that the object supports (e.g., “does it have a length?”) and also defines the possible values for objects of that type. The function returns an object’s type (which is an object itself). Like its identity, an object’s type is also unchangeable. The value of some objects can change. Objects whose value can change are said to be mutable; objects whose value is unchangeable once they are created are called immutable. (The value of an immutable container object that contains a reference to a mutable object can change when the latter’s value is changed; however the container is still considered immutable, because the collection of objects it contains cannot be changed. So, immutability is not strictly the same as having an unchangeable value, it is more subtle.) An object’s mutability is determined by its type; for instance, numbers, strings and tuples are immutable, while dictionaries and lists are mutable. Objects are never explicitly destroyed; however, when they become unreachable they may be garbage-collected. An implementation is allowed to postpone garbage collection or omit it altogether — it is a matter of implementation quality how garbage collection is implemented, as long as no objects are collected that are still reachable. CPython implementation detail: CPython currently uses a reference-counting scheme with (optional) delayed detection of cyclically linked garbage, which collects most objects as soon as they become unreachable, but is not guaranteed to collect garbage containing circular references. See the documentation of the module for information on controlling the collection of cyclic garbage. Other implementations act differently and CPython may change. Do not depend on immediate finalization of objects when they become unreachable (so you should always close files explicitly). Note that the use of the implementation’s tracing or debugging facilities may keep objects alive that would normally be collectable. Also note that catching an exception with a … statement may keep objects alive. Some objects contain references to “external” resources such as open files or windows. It is understood that these resources are freed when the object is garbage-collected, but since garbage collection is not guaranteed to happen, such objects also provide an explicit way to release the external resource, usually a method. Programs are strongly recommended to explicitly close such objects. The … statement and the statement provide convenient ways to do this. Some objects contain references to other objects; these are called containers. Examples of containers are tuples, lists and dictionaries. The references are part of a container’s value. In most cases, when we talk about the value of a container, we imply the values, not the identities of the contained objects; however, when we talk about the mutability of a container, only the identities of the immediately contained objects are implied. So, if an immutable container (like a tuple) contains a reference to a mutable object, its value changes if that mutable object is changed. Types affect almost all aspects of object behavior. Even the importance of object identity is affected in some sense: for immutable types, operations that compute new values may actually return a reference to any existing object with the same type and value, while for mutable objects this is not allowed. For example, after , a and b may or may not refer to the same object with the value one, depending on the implementation. This is because is an immutable type, so the reference to can be reused. This behaviour depends on the implementation used, so should not be relied upon, but is something to be aware of when making use of object identity tests. However, after , c and d are guaranteed to refer to two different, unique, newly created empty lists. (Note that assigns the same object to both e and f.)"
    },
    {
        "link": "https://datacamp.com/tutorial/python-inheritance",
        "document": "Inheritance is one of the foundational pillars of object-oriented programming (OOP) that allows one class (called the child class) to derive attributes and methods from another class (called the parent class). This feature is central to code reuse and simplifies maintenance, making it easier to build scalable and efficient programs.\n\nBefore going further, let's explore the relationship between parent and child classes.\n\nLet’s start with the parent class. A parent class is the base class from which child classes derive. It encapsulates shared attributes and methods.\n\nUsing Python, here is how we define a parent class:\n\nA child class inherits attributes and methods from the parent class. This allows it to use the functionality defined in the parent class. The following code shows how a child class inherits attributes and methods from a parent class:\n\nThis simple syntax allows the child class to utilize and extend the functionality defined in the parent class.\n\nLet’s create a practical example with a class as the parent and a class as the child.\n\nThe class contains shared attributes and a method to display information:\n\nThe class inherits from and adds a new method .\n• The class uses the method from to initialize and .\n• The method is unique to the class, extending its functionality.\n• The method is inherited directly from .\n\nInheritance in Python allows classes to inherit attributes and behaviors from other classes, promoting code reuse and clean design, as we talked about earlier. In this section, we can talk about the different types of Python inheritance, which includes single, multiple, hierarchical, and hybrid inheritance as separate categories.\n\nSingle inheritance occurs when a child class inherits from a single parent class, allowing it to extend the functionality of the parent. This is useful when an object type shares common properties with a broader category but also requires additional attributes or behavior.\n\nThe example I started to work through earlier was single inheritance, but let's now look a bit more closely: In a school management system, all individuals, including students, teachers, and staff, share some common details like and . However, students also have academic records such as grades and enrolled courses. Using single inheritance, we can create a class for shared attributes and extend it with a class for academic details.\n\nHere’s a good example of the above scenario:\n\nThe class inherits the method from but extends it to include and . This is a good example of how single inheritance promotes what is known as modular code.\n\nMultiple inheritance, like a family tree, in a way, allows a child class to inherit from more than one parent class, combining attributes and behaviors from each. This can lead to potential conflicts, which Python resolves using method resolution order (MRO).\n\nWe see that the class inherited attributes and methods from both and . Without any additional effort, the class has access to the method from the parent class and the method from the parent class. We are effectively combining functionality from multiple sources.\n\nHowever, inheriting from multiple classes can lead to conflicts. What if both parent classes define a method or attribute with the same name? I mentioned something about method resolution order earlier but let me know say a little something more about it. Method resolution order determines the order in which classes are searched for methods and attributes. The MRO follows a depth-first, left-to-right approach.\n\nYou can view the MRO of a class using the attribute or the method:\n\nPython also supports more complex inheritance structures. I'll show these more complex ideas using the same example.\n\nMultilevel inheritance happens when a child class inherits from another child class, and that child class inherits from a parent class. This creates a chain of inheritance.\n\nHere, each class in the chain adds something new: manages names and IDs, includes grades, and introduces a thesis. Thanks to , we reuse the initialization logic without duplicating code. It’s efficient, neat, and ensures every level of the “inheritance ladder”, as I think of it, works.\n\nIn hierarchical inheritance, multiple child classes inherit from a single parent class, allowing for shared behavior across subclasses with unique attributes.\n\nLet’s look at a good example together:\n\nHere, the class serves as the foundation, offering common attributes and methods ( , , and ). The and classes then extend this functionality by adding their unique properties ( and ) and customizing the method to reflect their specific contexts.\n\nWith this approach, shared functionality stays in one place (the class), while specialized behavior is neatly encapsulated in the subclasses.\n\nHybrid inheritance combines multiple inheritance types, such as multilevel or multiple inheritance, to model more complex relationships.\n\nLet’s look at an example that shows the complexity of hybrid inheritance.\n\nIn this example, the class demonstrates hybrid inheritance by inheriting attributes and methods from both (which itself inherits from ) and . This combines hierarchical inheritance (where inherits from ) and multiple inheritance (where inherits from both and ).\n\nNow, it's time to see the strengths and weaknesses:\n• Reusability: With inheritance you can write code once in the parent class and reuse it in the child classes. Using the example, both and can inherit a method from the parent class.\n• Simplicity: Inheritance models relationships clearly. A good example is the class which “is-a” type of the parent class.\n• Scalability: It also add new features or child classes without affecting existing code. For example, we can easily add a new class as a child class.\n• Complexity: This won't be surprising, but too many levels of inheritance can make the code hard to follow. For example, if an has too many child classes like , , , etc., it may become confusing.\n• Dependency: Changes to a parent class can unintentionally affect all subclasses. If you modify for example, it might break or .\n• Misuse: Using inheritance when it is not the best fit can complicate designs. You would not want to create a solution where inherits from just to reuse . The relationship doesn’t make sense.\n\nNow that we have explored the basics of inheritance, let’s look at some advanced techniques. These techniques, like method overriding, , abstract base classes, and polymorphism, enhance code flexibility and allow for more sophisticated design patterns.\n\nMethod overriding allows a child class to provide a specific implementation for a method already defined in its parent class. This is useful when the inherited behavior doesn’t fully meet the requirements of the child class.\n\nHere, the class overrides the method from the class to give its own specific implementations. This allows the child class to have its own behavior while still following the same method name.\n\nSo why do we override? We override because we want to customize inherited behavior and also because we want to tailor the functionality of a parent method to a child class’s unique requirements.\n\nThe function is used to call methods in the parent class from the child class. This is particularly useful when you want to extend or modify the functionality of a parent class method, such as the constructor method.\n\nSo why do we use the function? We use the super function because we want to call and initialize the parent class’s constructor and also because we want to avoid explicitly naming the parent class. This is helpful, especially in cases of multiple inheritance.\n\nHere, the class uses to call the method of the parent class, so it does not need to repeat code to initialize the and attributes. The child class then introduces a attribute, which is specific to the class.\n\nAn abstract base class (ABC) is a class that cannot be directly used to create objects. It is meant to define a common set of methods that other classes should implement. So ABCs are useful when you want to ensure that certain methods are always present in the child classes.\n\nThe class here is an abstract class that requires any child class to implement the method. This method is being later implemented by the child class, .\n\nPolymorphism means many shapes. In Python, it allows different classes to use the same method name, but each can implement that method in a different way.\n\nPolymorphism helps us write code that can work with objects of different classes, even if those classes have different behaviors:\n\nIn this example, the function can accept any object of type , but it will call the appropriate method based on whether the object is a or a .\n\nWhile inheritance is powerful, it is easy to misuse. I will share some ideas to help you make the most of the ideas.\n\nWhen a child class overrides a method from its parent, the behavior can change.\n\nFor example, if the parent class has a method, and the child class overrides it without considering all scenarios, it might produce incorrect pay calculations.\n\nThe best practice, in this case, is to always test overridden methods thoroughly and document their behavior.\n\nI know this article is about inheritance, but it is not always the right approach. Sometimes, composition, where you build classes by combining objects rather than extending them might be a better fit with whatever you are doing.\n\nTo distll the differences in the most basic way, think that:\n• Inheritance refers to “Is-a” relationships. For example, a is an .\n• Composition refers to “Has-a” relationships. For example, a has an .\n\nSo, how do you know when composition is the best approach to use? Use composition when the relationship is not strictly hierarchical and/or when you want to reduce tight coupling between classes.\n\nOr, we could also say that, while inheritance models relationships, composition focuses on functionality. To help, consider this:\n• Use inheritance when objects are naturally hierarchical. For example, .\n• Use composition when objects share functionality but are not related. For example, a and both use a .\n\nDeep inheritance chains (many levels of parent-child relationships) can make your code hard to read and maintain. This is a problem because changes to a parent class may unintentionally affect many child classes. Also, debugging becomes complex as behavior is spread across multiple levels.\n\nThe best practice in this case is to keep hierarchies shallow. Also, consider using composition (as I mentioned earlier) or breaking a chain into separate hierarchies if you find it is becoming too deep.\n\nInheritance is a major pillar of object-oriented programming that enables developers like you to create reusable, modular, and scalable code. If you can master inheritance, you will find it easy to simplify complex systems.\n\nA good way to deepen your understanding is to try building inheritance structures in your projects. Start simple, then experiment with more complex hierarchies to see how they work in practice.\n\nIf you are eager to explore even deeper, you can check out our Programming Paradigm Concepts course for a deeper understanding of inheritance and other ideas. Our Python Developer career track is also a good resource that offers a comprehensive path to developing advanced programming skills that will equip you for software development."
    },
    {
        "link": "https://docs.python.org/3/library/stdtypes.html",
        "document": "The following sections describe the standard types that are built into the interpreter.\n\nThe principal built-in types are numerics, sequences, mappings, classes, instances and exceptions.\n\nSome collection classes are mutable. The methods that add, subtract, or rearrange their members in place, and don’t return a specific item, never return the collection instance itself but .\n\nSome operations are supported by several object types; in particular, practically all objects can be compared for equality, tested for truth value, and converted to a string (with the function or the slightly different function). The latter function is implicitly used when an object is written by the function.\n\nThere are three distinct numeric types: integers, floating-point numbers, and complex numbers. In addition, Booleans are a subtype of integers. Integers have unlimited precision. Floating-point numbers are usually implemented using double in C; information about the precision and internal representation of floating-point numbers for the machine on which your program is running is available in . Complex numbers have a real and imaginary part, which are each a floating-point number. To extract these parts from a complex number z, use and . (The standard library includes the additional numeric types , for rationals, and , for floating-point numbers with user-definable precision.) Numbers are created by numeric literals or as the result of built-in functions and operators. Unadorned integer literals (including hex, octal and binary numbers) yield integers. Numeric literals containing a decimal point or an exponent sign yield floating-point numbers. Appending or to a numeric literal yields an imaginary number (a complex number with a zero real part) which you can add to an integer or float to get a complex number with real and imaginary parts. Python fully supports mixed arithmetic: when a binary arithmetic operator has operands of different numeric types, the operand with the “narrower” type is widened to that of the other, where integer is narrower than floating point, which is narrower than complex. A comparison between numbers of different types behaves as though the exact values of those numbers were being compared. The constructors , , and can be used to produce numbers of a specific type. All numeric types (except complex) support the following operations (for priorities of the operations, see Operator precedence): absolute value or magnitude of x a complex number with real part re, imaginary part im. im defaults to zero. conjugate of the complex number c\n• None Also referred to as integer division. For operands of type , the result has type . For operands of type , the result has type . In general, the result is a whole integer, though the result’s type is not necessarily . The result is always rounded towards minus infinity: is , is , is , and is .\n• None Not for complex numbers. Instead convert to floats using if appropriate.\n• None Conversion from to truncates, discarding the fractional part. See functions and for alternative conversions.\n• None float also accepts the strings “nan” and “inf” with an optional prefix “+” or “-” for Not a Number (NaN) and positive or negative infinity.\n• None Python defines and to be , as is common for programming languages.\n• None The numeric literals accepted include the digits to or any Unicode equivalent (code points with the property). See the Unicode Standard for a complete list of code points with the property. All types ( and ) also include the following operations: x rounded to n digits, rounding half to even. If n is omitted, it defaults to 0. For additional numeric operations see the and modules. Bitwise operations only make sense for integers. The result of bitwise operations is calculated as though carried out in two’s complement with an infinite number of sign bits. The priorities of the binary bitwise operations are all lower than the numeric operations and higher than the comparisons; the unary operation has the same priority as the other unary numeric operations ( and ). This table lists the bitwise operations sorted in ascending priority: bitwise exclusive or of x and y\n• None Negative shift counts are illegal and cause a to be raised.\n• None A left shift by n bits is equivalent to multiplication by .\n• None A right shift by n bits is equivalent to floor division by .\n• None Performing these calculations with at least one extra sign extension bit in a finite two’s complement representation (a working bit-width of or more) is sufficient to get the same result as if there were an infinite number of sign bits. The int type implements the abstract base class. In addition, it provides a few more methods: Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: More precisely, if is nonzero, then is the unique positive integer such that . Equivalently, when is small enough to have a correctly rounded logarithm, then . If is zero, then returns . Return the number of ones in the binary representation of the absolute value of the integer. This is also known as the population count. Example: Return an array of bytes representing an integer. The integer is represented using length bytes, and defaults to 1. An is raised if the integer is not representable with the given number of bytes. The byteorder argument determines the byte order used to represent the integer, and defaults to . If byteorder is , the most significant byte is at the beginning of the byte array. If byteorder is , the most significant byte is at the end of the byte array. The signed argument determines whether two’s complement is used to represent the integer. If signed is and a negative integer is given, an is raised. The default value for signed is . The default values can be used to conveniently turn an integer into a single byte object: However, when using the default arguments, don’t try to convert a value greater than 255 or you’ll get an . \"byteorder must be either 'little' or 'big'\" Changed in version 3.11: Added default argument values for and . Return the integer represented by the given array of bytes. The argument bytes must either be a bytes-like object or an iterable producing bytes. The byteorder argument determines the byte order used to represent the integer, and defaults to . If byteorder is , the most significant byte is at the beginning of the byte array. If byteorder is , the most significant byte is at the end of the byte array. To request the native byte order of the host system, use as the byte order value. The signed argument indicates whether two’s complement is used to represent the integer. \"byteorder must be either 'little' or 'big'\" Changed in version 3.11: Added default argument value for . Return a pair of integers whose ratio is equal to the original integer and has a positive denominator. The integer ratio of integers (whole numbers) is always the integer as the numerator and as the denominator. The float type implements the abstract base class. float also has the following additional methods. Return a pair of integers whose ratio is exactly equal to the original float. The ratio is in lowest terms and has a positive denominator. Raises on infinities and a on NaNs. Return if the float instance is finite with integral value, and otherwise: Two methods support conversion to and from hexadecimal strings. Since Python’s floats are stored internally as binary numbers, converting a float to or from a decimal string usually involves a small rounding error. In contrast, hexadecimal strings allow exact representation and specification of floating-point numbers. This can be useful when debugging, and in numerical work. Return a representation of a floating-point number as a hexadecimal string. For finite floating-point numbers, this representation will always include a leading and a trailing and exponent. Class method to return the float represented by a hexadecimal string s. The string s may have leading and trailing whitespace. Note that is an instance method, while is a class method. where the optional may by either or , and are strings of hexadecimal digits, and is a decimal integer with an optional leading sign. Case is not significant, and there must be at least one hexadecimal digit in either the integer or the fraction. This syntax is similar to the syntax specified in section 6.4.4.2 of the C99 standard, and also to the syntax used in Java 1.5 onwards. In particular, the output of is usable as a hexadecimal floating-point literal in C or Java code, and hexadecimal strings produced by C’s format character or Java’s are accepted by . Note that the exponent is written in decimal rather than hexadecimal, and that it gives the power of 2 by which to multiply the coefficient. For example, the hexadecimal string represents the floating-point number , or : Applying the reverse conversion to gives a different hexadecimal string representing the same number: For numbers and , possibly of different types, it’s a requirement that whenever (see the method documentation for more details). For ease of implementation and efficiency across a variety of numeric types (including , , and ) Python’s hash for numeric types is based on a single mathematical function that’s defined for any rational number, and hence applies to all instances of and , and all finite instances of and . Essentially, this function is given by reduction modulo for a fixed prime . The value of is made available to Python as the attribute of . CPython implementation detail: Currently, the prime used is on machines with 32-bit C longs and on machines with 64-bit C longs. Here are the rules in detail:\n• None If is a nonnegative rational number and is not divisible by , define as , where gives the inverse of modulo .\n• None If is a nonnegative rational number and is divisible by (but is not) then has no inverse modulo and the rule above doesn’t apply; in this case define to be the constant value .\n• None If is a negative rational number define as . If the resulting hash is , replace it with .\n• None The particular values and are used as hash values for positive infinity or negative infinity (respectively).\n• None For a number , the hash values of the real and imaginary parts are combined by computing , reduced modulo so that it lies in . Again, if the result is , it’s replaced with . To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, , or : Assumes m and n are integers, with n positive. # Remove common factors of P. (Unnecessary if m and n already coprime.) # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P.\n\nThere are three basic sequence types: lists, tuples, and range objects. Additional sequence types tailored for processing of binary data and text strings are described in dedicated sections. The operations in the following table are supported by most sequence types, both mutable and immutable. The ABC is provided to make it easier to correctly implement these operations on custom sequence types. This table lists the sequence operations sorted in ascending priority. In the table, s and t are sequences of the same type, n, i, j and k are integers and x is an arbitrary object that meets any type and value restrictions imposed by s. The and operations have the same priorities as the comparison operations. The (concatenation) and (repetition) operations have the same priority as the corresponding numeric operations. if an item of s is equal to x, else if an item of s is equal to x, else the concatenation of s and t equivalent to adding s to itself n times slice of s from i to j with step k index of the first occurrence of x in s (at or after index i and before index j) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Forward and reversed iterators over mutable sequences access values using an index. That index will continue to march forward (or backward) even if the underlying sequence is mutated. The iterator terminates only when an or a is encountered (or when the index drops below zero).\n• None While the and operations are used only for simple containment testing in the general case, some specialised sequences (such as , and ) also use them for subsequence testing:\n• None Values of n less than are treated as (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: What has happened is that is a one-element list containing an empty list, so all three elements of are references to this single empty list. Modifying any of the elements of modifies this single list. You can create a list of different lists this way: Further explanation is available in the FAQ entry How do I create a multidimensional list?.\n• None If i or j is negative, the index is relative to the end of sequence s: or is substituted. But note that is still .\n• None The slice of s from i to j is defined as the sequence of items with index k such that . If i or j is greater than , use . If i is omitted or , use . If j is omitted or , use . If i is greater than or equal to j, the slice is empty.\n• None The slice of s from i to j with step k is defined as the sequence of items with index such that . In other words, the indices are , , , and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to if they are greater. When k is negative, i and j are reduced to if they are greater. If i or j are omitted or , they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is , it is treated like .\n• None Concatenating immutable sequences always results in a new object. This means that building up a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length. To get a linear runtime cost, you must switch to one of the alternatives below:\n• None if concatenating objects, you can build a list and use at the end or else write to an instance and retrieve its value when complete\n• None if concatenating objects, you can similarly use or , or you can do in-place concatenation with a object. objects are mutable and have an efficient overallocation mechanism\n• None for other types, investigate the relevant class documentation\n• None Some sequence types (such as ) only support item sequences that follow specific patterns, and hence don’t support sequence concatenation or repetition.\n• None raises when x is not found in s. Not all implementations support passing the additional arguments i and j. These arguments allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using , only without copying any data and with the returned index being relative to the start of the sequence rather than the start of the slice. The only operation that immutable sequence types generally implement that is not also implemented by mutable sequence types is support for the built-in. This support allows immutable sequences, such as instances, to be used as keys and stored in and instances. Attempting to hash an immutable sequence that contains unhashable values will result in . The operations in the following table are defined on mutable sequence types. The ABC is provided to make it easier to correctly implement these operations on custom sequence types. In the table s is an instance of a mutable sequence type, t is any iterable object and x is an arbitrary object that meets any type and value restrictions imposed by s (for example, only accepts integers that meet the value restriction ). item i of s is replaced by x slice of s from i to j is replaced by the contents of the iterable t the elements of are replaced by those of t removes the elements of from the list appends x to the end of the sequence (same as ) removes all items from s (same as ) creates a shallow copy of s (same as ) extends s with the contents of t (for the most part the same as ) inserts x into s at the index given by i (same as ) retrieves the item at i and also removes it from s removes the first item from s where is equal to x reverses the items of s in place\n• None If k is not equal to , t must have the same length as the slice it is replacing.\n• None The optional argument i defaults to , so that by default the last item is removed and returned.\n• None raises when x is not found in s.\n• None The method modifies the sequence in place for economy of space when reversing a large sequence. To remind users that it operates by side effect, it does not return the reversed sequence.\n• None and are included for consistency with the interfaces of mutable containers that don’t support slicing operations (such as and ). is not part of the ABC, but most concrete mutable sequence classes provide it.\n• None The value n is an integer, or an object implementing . Zero and negative values of n clear the sequence. Items in the sequence are not copied; they are referenced multiple times, as explained for under Common Sequence Operations. Lists are mutable sequences, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application). Lists may be constructed in several ways:\n• None Using a pair of square brackets to denote the empty list:\n• None Using the type constructor: or The constructor builds a list whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a list, a copy is made and returned, similar to . For example, returns and returns . If no argument is given, the constructor creates a new empty list, . Many other operations also produce lists, including the built-in. Lists implement all of the common and mutable sequence operations. Lists also provide the following additional method: This method sorts the list in place, using only comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, ). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of means that list items are sorted directly without calculating a separate key value. The utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to , then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use to explicitly request a new sorted list instance). The method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting Techniques. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises if it can detect that the list has been mutated during a sort. Tuples are immutable sequences, typically used to store collections of heterogeneous data (such as the 2-tuples produced by the built-in). Tuples are also used for cases where an immutable sequence of homogeneous data is needed (such as allowing storage in a or instance). Tuples may be constructed in a number of ways:\n• None Using a pair of parentheses to denote the empty tuple:\n• None Using a trailing comma for a singleton tuple: or\n• None Using the built-in: or The constructor builds a tuple whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a tuple, it is returned unchanged. For example, returns and returns . If no argument is given, the constructor creates a new empty tuple, . Note that it is actually the comma which makes a tuple, not the parentheses. The parentheses are optional, except in the empty tuple case, or when they are needed to avoid syntactic ambiguity. For example, is a function call with three arguments, while is a function call with a 3-tuple as the sole argument. Tuples implement all of the common sequence operations. For heterogeneous collections of data where access by name is clearer than access by index, may be a more appropriate choice than a simple tuple object. The type represents an immutable sequence of numbers and is commonly used for looping a specific number of times in loops. The arguments to the range constructor must be integers (either built-in or any object that implements the special method). If the step argument is omitted, it defaults to . If the start argument is omitted, it defaults to . If step is zero, is raised. For a positive step, the contents of a range are determined by the formula where and . For a negative step, the contents of the range are still determined by the formula , but the constraints are and . A range object will be empty if does not meet the value constraint. Ranges do support negative indices, but these are interpreted as indexing from the end of the sequence determined by the positive indices. Ranges containing absolute values larger than are permitted but some features (such as ) may raise . Ranges implement all of the common sequence operations except concatenation and repetition (due to the fact that range objects can only represent sequences that follow a strict pattern and repetition and concatenation will usually violate that pattern). The value of the start parameter (or if the parameter was not supplied) The value of the stop parameter The value of the step parameter (or if the parameter was not supplied) The advantage of the type over a regular or is that a object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the , and values, calculating individual items and subranges as needed). Range objects implement the ABC, and provide features such as containment tests, element index lookup, slicing and support for negative indices (see Sequence Types — list, tuple, range): Testing range objects for equality with and compares them as sequences. That is, two range objects are considered equal if they represent the same sequence of values. (Note that two range objects that compare equal might have different , and attributes, for example or .) Changed in version 3.2: Implement the Sequence ABC. Support slicing and negative indices. Test objects for membership in constant time instead of iterating through all items. Changed in version 3.3: Define ‘==’ and ‘!=’ to compare range objects based on the sequence of values they define (instead of comparing based on object identity).\n• None The linspace recipe shows how to implement a lazy version of range suitable for floating-point applications."
    },
    {
        "link": "http://python-reference.readthedocs.io/en/latest/docs/str/startswith.html",
        "document": "Returns a Boolean stating whether a string starts with the specified prefix."
    },
    {
        "link": "https://w3schools.com/python/ref_string_startswith.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://docs.python.org/3/library/string.html",
        "document": "A string containing all ASCII characters that are considered whitespace. This includes the characters space, tab, linefeed, return, formfeed, and vertical tab.\n\nBy design, string.printable.isprintable() returns False . In particular, string.printable is not printable in the POSIX sense (see LC_CTYPE ).\n\nString of ASCII characters which are considered printable by Python. This is a combination of digits , ascii_letters , punctuation , and whitespace .\n\nString of ASCII characters which are considered punctuation characters in the C locale: !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ .\n\nThe uppercase letters 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' . This value is not locale-dependent and will not change.\n\nThe lowercase letters 'abcdefghijklmnopqrstuvwxyz' . This value is not locale-dependent and will not change.\n\nThe concatenation of the ascii_lowercase and ascii_uppercase constants described below. This value is not locale-dependent.\n\nConverts the value (returned by get_field() ) given a conversion type (as in the tuple returned by the parse() method). The default version understands ‘s’ (str), ‘r’ (repr) and ‘a’ (ascii) conversion types.\n\nformat_field() simply calls the global format() built-in. The method is provided so that subclasses can override it.\n\nImplement checking for unused arguments if desired. The arguments to this function is the set of all argument keys that were actually referred to in the format string (integers for positional arguments, and strings for named arguments), and a reference to the args and kwargs that was passed to vformat. The set of unused args can be calculated from these parameters. check_unused_args() is assumed to raise an exception if the check fails.\n\nIf the index or keyword refers to an item that does not exist, then an IndexError or KeyError should be raised.\n\nSo for example, the field expression ‘0.name’ would cause get_value() to be called with a key argument of 0. The name attribute will be looked up after get_value() returns by calling the built-in getattr() function.\n\nFor compound field names, these functions are only called for the first component of the field name; subsequent components are handled through normal attribute and indexing operations.\n\nThe args parameter is set to the list of positional arguments to vformat() , and the kwargs parameter is set to the dictionary of keyword arguments.\n\nRetrieve a given field value. The key argument will be either an integer or a string. If it is an integer, it represents the index of the positional argument in args; if it is a string, then it represents a named argument in kwargs.\n\nGiven field_name as returned by parse() (see above), convert it to an object to be formatted. Returns a tuple (obj, used_key). The default version takes strings of the form defined in PEP 3101 , such as “0[name]” or “label.title”. args and kwargs are as passed in to vformat() . The return value used_key has the same meaning as the key parameter to get_value() .\n\nThe values in the tuple conceptually represent a span of literal text followed by a single replacement field. If there is no literal text (which can happen if two replacement fields occur consecutively), then literal_text will be a zero-length string. If there is no replacement field, then the values of field_name, format_spec and conversion will be None .\n\nLoop over the format_string and return an iterable of tuples (literal_text, field_name, format_spec, conversion). This is used by vformat() to break the string into either literal text, or replacement fields.\n\nIn addition, the Formatter defines a number of methods that are intended to be replaced by subclasses:\n\nThis function does the actual work of formatting. It is exposed as a separate function for cases where you want to pass in a predefined dictionary of arguments, rather than unpacking and repacking the dictionary as individual arguments using the *args and **kwargs syntax. vformat() does the work of breaking up the format string into character data and replacement fields. It calls the various methods described below.\n\nThe primary API method. It takes a format string and an arbitrary set of positional and keyword arguments. It is just a wrapper that calls vformat() .\n\nThe built-in string class provides the ability to do complex variable substitutions and value formatting via the format() method described in PEP 3101 . The Formatter class in the string module allows you to create and customize your own string formatting behaviors using the same implementation as the built-in format() method.\n\nThe method and the class share the same syntax for format strings (although in the case of , subclasses can define their own format string syntax). The syntax is related to that of formatted string literals, but it is less sophisticated and, in particular, does not support arbitrary expressions.\n\nFormat strings contain “replacement fields” surrounded by curly braces . Anything that is not contained in braces is considered literal text, which is copied unchanged to the output. If you need to include a brace character in the literal text, it can be escaped by doubling: and .\n\nThe grammar for a replacement field is as follows:\n\nIn less formal terms, the replacement field can start with a field_name that specifies the object whose value is to be formatted and inserted into the output instead of the replacement field. The field_name is optionally followed by a conversion field, which is preceded by an exclamation point , and a format_spec, which is preceded by a colon . These specify a non-default format for the replacement value.\n\nSee also the Format Specification Mini-Language section.\n\nThe field_name itself begins with an arg_name that is either a number or a keyword. If it’s a number, it refers to a positional argument, and if it’s a keyword, it refers to a named keyword argument. An arg_name is treated as a number if a call to on the string would return true. If the numerical arg_names in a format string are 0, 1, 2, … in sequence, they can all be omitted (not just some) and the numbers 0, 1, 2, … will be automatically inserted in that order. Because arg_name is not quote-delimited, it is not possible to specify arbitrary dictionary keys (e.g., the strings or ) within a format string. The arg_name can be followed by any number of index or attribute expressions. An expression of the form selects the named attribute using , while an expression of the form does an index lookup using .\n\nThe conversion field causes a type coercion before formatting. Normally, the job of formatting a value is done by the method of the value itself. However, in some cases it is desirable to force a type to be formatted as a string, overriding its own definition of formatting. By converting the value to a string before calling , the normal formatting logic is bypassed.\n\nThree conversion flags are currently supported: which calls on the value, which calls and which calls .\n\nThe format_spec field contains a specification of how the value should be presented, including such details as field width, alignment, padding, decimal precision and so on. Each value type can define its own “formatting mini-language” or interpretation of the format_spec.\n\nMost built-in types support a common formatting mini-language, which is described in the next section.\n\nA format_spec field can also include nested replacement fields within it. These nested replacement fields may contain a field name, conversion flag and format specification, but deeper nesting is not allowed. The replacement fields within the format_spec are substituted before the format_spec string is interpreted. This allows the formatting of a value to be dynamically specified.\n\nSee the Format examples section for some examples.\n\n“Format specifications” are used within replacement fields contained within a format string to define how individual values are presented (see Format String Syntax and f-strings). They can also be passed directly to the built-in function. Each formattable type may define how the format specification is to be interpreted. Most built-in types implement the following options for format specifications, although some of the formatting options are only supported by the numeric types. A general convention is that an empty format specification produces the same result as if you had called on the value. A non-empty format specification typically modifies the result. The general form of a standard format specifier is: If a valid align value is specified, it can be preceded by a fill character that can be any character and defaults to a space if omitted. It is not possible to use a literal curly brace (” ” or “ ”) as the fill character in a formatted string literal or when using the method. However, it is possible to insert a curly brace with a nested replacement field. This limitation doesn’t affect the function. The meaning of the various alignment options is as follows: Forces the field to be left-aligned within the available space (this is the default for most objects). Forces the field to be right-aligned within the available space (this is the default for numbers). Forces the padding to be placed after the sign (if any) but before the digits. This is used for printing fields in the form ‘+000000120’. This alignment option is only valid for numeric types, excluding . It becomes the default for numbers when ‘0’ immediately precedes the field width. Forces the field to be centered within the available space. Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case. The sign option is only valid for number types, and can be one of the following: indicates that a sign should be used for both positive as well as negative numbers. indicates that a sign should be used only for negative numbers (this is the default behavior). indicates that a leading space should be used on positive numbers, and a minus sign on negative numbers. The option coerces negative zero floating-point values to positive zero after rounding to the format precision. This option is only valid for floating-point presentation types. Changed in version 3.11: Added the option (see also PEP 682). The option causes the “alternate form” to be used for the conversion. The alternate form is defined differently for different types. This option is only valid for integer, float and complex types. For integers, when binary, octal, or hexadecimal output is used, this option adds the respective prefix , , , or to the output value. For float and complex the alternate form causes the result of the conversion to always contain a decimal-point character, even if no digits follow it. Normally, a decimal-point character appears in the result of these conversions only if a digit follows it. In addition, for and conversions, trailing zeros are not removed from the result. The option signals the use of a comma for a thousands separator for floating-point presentation types and for integer presentation type . For other presentation types, this option is an error. For a locale aware separator, use the integer presentation type instead. Changed in version 3.1: Added the option (see also PEP 378). The option signals the use of an underscore for a thousands separator for floating-point presentation types and for integer presentation type . For integer presentation types , , , and , underscores will be inserted every 4 digits. For other presentation types, specifying this option is an error. Changed in version 3.6: Added the option (see also PEP 515). width is a decimal integer defining the minimum total field width, including any prefixes, separators, and other formatting characters. If not specified, then the field width will be determined by the content. When no explicit alignment is given, preceding the width field by a zero ( ) character enables sign-aware zero-padding for numeric types, excluding . This is equivalent to a fill character of with an alignment type of . Changed in version 3.10: Preceding the width field by no longer affects the default alignment for strings. The precision is a decimal integer indicating how many digits should be displayed after the decimal point for presentation types and , or before and after the decimal point for presentation types or . For string presentation types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is not allowed for integer presentation types. Finally, the type determines how the data should be presented. The available string presentation types are: String format. This is the default type for strings and may be omitted. The available integer presentation types are: Character. Converts the integer to the corresponding unicode character before printing. Hex format. Outputs the number in base 16, using lower-case letters for the digits above 9. Hex format. Outputs the number in base 16, using upper-case letters for the digits above 9. In case is specified, the prefix will be upper-cased to as well. Number. This is the same as , except that it uses the current locale setting to insert the appropriate number separator characters. In addition to the above presentation types, integers can be formatted with the floating-point presentation types listed below (except and ). When doing so, is used to convert the integer to a floating-point number before formatting. The available presentation types for and values are: Scientific notation. For a given precision , formats the number in scientific notation with the letter ‘e’ separating the coefficient from the exponent. The coefficient has one digit before and digits after the decimal point, for a total of significant digits. With no precision given, uses a precision of digits after the decimal point for , and shows all coefficient digits for . If , the decimal point is omitted unless the option is used. Scientific notation. Same as except it uses an upper case ‘E’ as the separator character. Fixed-point notation. For a given precision , formats the number as a decimal number with exactly digits following the decimal point. With no precision given, uses a precision of digits after the decimal point for , and uses a precision large enough to show all coefficient digits for . If , the decimal point is omitted unless the option is used. Fixed-point notation. Same as , but converts to and to . General format. For a given precision , this rounds the number to significant digits and then formats the result in either fixed-point format or in scientific notation, depending on its magnitude. A precision of is treated as equivalent to a precision of . The precise rules are as follows: suppose that the result formatted with presentation type and precision would have exponent . Then, if , where is -4 for floats and -6 for , the number is formatted with presentation type and precision . Otherwise, the number is formatted with presentation type and precision . In both cases insignificant trailing zeros are removed from the significand, and the decimal point is also removed if there are no remaining digits following it, unless the option is used. With no precision given, uses a precision of significant digits for . For , the coefficient of the result is formed from the coefficient digits of the value; scientific notation is used for values smaller than in absolute value and values where the place value of the least significant digit is larger than 1, and fixed-point notation is used otherwise. Positive and negative infinity, positive and negative zero, and nans, are formatted as , , , and respectively, regardless of the precision. General format. Same as except switches to if the number gets too large. The representations of infinity and NaN are uppercased, too. Number. This is the same as , except that it uses the current locale setting to insert the appropriate number separator characters. Percentage. Multiplies the number by 100 and displays in fixed ( ) format, followed by a percent sign. For this is like the type, except that when fixed-point notation is used to format the result, it always includes at least one digit past the decimal point, and switches to the scientific notation when . When the precision is not specified, the latter will be as large as needed to represent the given value faithfully. For , this is the same as either or depending on the value of for the current decimal context. The overall effect is to match the output of as altered by the other format modifiers. The result should be correctly rounded to a given precision of digits after the decimal point. The rounding mode for matches that of the builtin. For , the rounding mode of the current context will be used. The available presentation types for are the same as those for ( is not allowed). Both the real and imaginary components of a complex number are formatted as floating-point numbers, according to the specified presentation type. They are separated by the mandatory sign of the imaginary part, the latter being terminated by a suffix. If the presentation type is missing, the result will match the output of (complex numbers with a non-zero real part are also surrounded by parentheses), possibly altered by other format modifiers.\n\nThis section contains examples of the syntax and comparison with the old -formatting. In most of the cases the syntax is similar to the old -formatting, with the addition of the and with used instead of . For example, can be translated to . The new format syntax also supports new and different options, shown in the following examples. is formed from the real part 'The complex number (3-5j) is formed from the real part 3.0 and the imaginary part -5.0.' Aligning the text and specifying a width: Replacing , , and and specifying a sign: # show only the minus -- same as '{:f}; {:f}' Replacing and and converting the value to different bases: # with 0x, 0o, or 0b as prefix: Using the comma as a thousands separator:"
    },
    {
        "link": "https://geeksforgeeks.org/python-string-startswith",
        "document": "method in Python is a built-in string method that checks whether a given string starts with a specific prefix. It helps in efficiently verifying whether a string begins with a certain substring, which can be useful in various scenarios like filtering or validating input. In this article, we will understand about startswith() method.\n• None with the value\n• None We then call the\n• None The method checks if the string starts with , and since it does, the result is\n• prefix : The substring or a tuple of substrings to check for at the start of the string.\n• start (optional): The index where the search for the prefix begins. By default, it starts from index 0.\n• end (optional): The index where the search for the prefix ends. If not specified, the search goes till the end of the string.\n• Boolean\n• None if the string starts with the specified prefix.\n• None if it does not.\n\nHere’s a simple example where we check if the string starts with the word “Python”.\n• Explanation : The string starts with the word\n\nLet’s check the string using the parameter to begin from a specific index.\n• None We start the check from index\n• None because the substring at that position is\n\nWe can also check if the string starts with any one of several prefixes by passing a tuple of prefixes.\n• None We pass a tuple with two prefixes:\n• None Since the string starts with\n\nWhat happens if we pass invalid start and end indices?\n\nDoes the method modify the original string?"
    }
]