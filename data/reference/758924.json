[
    {
        "link": "https://geeksforgeeks.org/operator-overloading-cpp",
        "document": "in C++, Operator overloading is a compile-time polymorphism. It is an idea of giving special meaning to an existing operator in C++ without changing its original meaning.\n\nIn this article, we will further discuss about operator overloading in C++ with examples and see which operators we can or cannot overload in C++.\n\nC++ has the ability to provide the operators with a special meaning for a data type, this ability is known as operator overloading. Operator overloading is a compile-time polymorphism. For example, we can overload an operator ‘+’ in a class like String so that we can concatenate two strings by just using +. Other example classes where arithmetic operators may be overloaded are Complex Numbers, Fractional Numbers, Big integers, etc.\n\nHere, variables “a” and “b” are of types “int” and “float”, which are built-in data types. Hence the addition operator ‘+’ can easily add the contents of “a” and “b”. This is because the addition operator “+” is predefined to add variables of built-in data type only.\n\n\n\nIn this example, we have 3 variables “a1”, “a2” and “a3” of type “class A”. Here we are trying to add two objects “a1” and “a2”, which are of user-defined type i.e. of type “class A” using the “+” operator. This is not allowed, because the addition operator “+” is predefined to operate only on built-in data types. But here, “class A” is a user-defined type, so the compiler generates an error. This is where the concept of “Operator overloading” comes in.\n\nNow, if the user wants to make the operator “+” add two class objects, the user has to redefine the meaning of the “+” operator such that it adds two class objects. This is done by using the concept of “Operator overloading”. So the main idea behind “Operator overloading” is to use C++ operators with class variables or class objects. Redefining the meaning of operators really does not change their original meaning; instead, they have been given additional meaning along with their existing ones.\n\nExample of Operator Overloading in C++\n\nOperator functions are the same as normal functions. The only differences are, that the name of an operator function is always the operator keyword followed by the symbol of the operator, and operator functions are called when the corresponding operator is used.\n\nCan We Overload All Operators?\n\nAlmost all operators can be overloaded except a few. Following is the list of operators that cannot be overloaded.\n\nOperators that can be Overloaded in C++\n\nBut, among them, there are some operators that cannot be overloaded. They are\n\nWhy can’t the above-stated operators be overloaded?\n\nThis returns the size of the object or datatype entered as the operand. This is evaluated by the compiler and cannot be evaluated during runtime. The proper incrementing of a pointer in an array of objects relies on the sizeof operator implicitly. Altering its meaning using overloading would cause a fundamental part of the language to collapse.\n\nThis provides a CPP program with the ability to recover the actually derived type of the object referred to by a pointer or reference. For this operator, the whole point is to uniquely identify a type. If we want to make a user-defined type ‘look’ like another type, polymorphism can be used but the meaning of the typeid operator must remain unaltered, or else serious issues could arise.\n\nThis helps identify and specify the context to which an identifier refers by specifying a namespace. It is completely evaluated at runtime and works on names rather than values. The operands of scope resolution are note expressions with data types and CPP has no syntax for capturing them if it were overloaded. So it is syntactically impossible to overload this operator.\n\nThe importance and implicit use of class member access operators can be understood through the following example:\n\nThe statement ComplexNumber c3 = c1 + c2; is internally translated as ComplexNumber c3 = c1.operator+ (c2); in order to invoke the operator function. The argument c1 is implicitly passed using the ‘.’ operator. The next statement also makes use of the dot operator to access the member function print and pass c3 as an argument.\n\nBesides, these operators also work on names and not values and there is no provision (syntactically) to overload them.\n\nThe ternary or conditional operator is a shorthand representation of an if-else statement. In the operator, the true/false expressions are only evaluated on the basis of the truth value of the conditional expression.\n\nconditional statement ? expression1 (if statement is TRUE) : expression2 (else)\n\nA function overloading the ternary operator for a class say ABC using the definition\n\nwould not be able to guarantee that only one of the expressions was evaluated. Thus, the ternary operator cannot be overloaded.\n\n1) For operator overloading to work, at least one of the operands must be a user-defined class object.\n\n2) Assignment Operator: Compiler automatically creates a default assignment operator with every class. The default assignment operator does assign all members of the right side to the left side and works fine in most cases (this behavior is the same as the copy constructor). See this for more details.\n\n3) Conversion Operator: We can also write conversion operators that can be used to convert one type to another type.\n\nOverloaded conversion operators must be a member method. Other operators can either be the member method or the global method.\n\n4) Any constructor that can be called with a single argument works as a conversion constructor, which means it can also be used for implicit conversion to the class being constructed."
    },
    {
        "link": "https://stackoverflow.com/questions/4421706/what-are-the-basic-rules-and-idioms-for-operator-overloading",
        "document": "Most of the work in overloading operators is boilerplate code. That is little wonder, since operators are merely syntactic sugar. Their actual work could be done by (and often is forwarded to) plain functions. But it is important that you get this boilerplate code right. If you fail, either your operator’s code won’t compile, your users’ code won’t compile, or your users’ code will behave surprisingly.\n\nThere's a lot to be said about assignment. However, most of it has already been said in GMan's famous Copy-And-Swap FAQ, so I'll skip most of it here, only listing the perfect assignment operator for reference:\n\nThe bitwise shift operators and , although still used in hardware interfacing for the bit-manipulation functions they inherit from C, have become more prevalent as overloaded stream input and output operators in most applications.\n\nThe stream operators, among the most commonly overloaded operators, are binary infix operators for which the syntax does not specify any restriction on whether they should be members or non-members. However, their left operands are streams from the standard library, and you cannot add member functions to those1, so you need to implement these operators for your own types as non-member functions2. The canonical forms of the two are these:\n\nWhen implementing , manually setting the stream’s state is only necessary when the reading itself succeeded, but the result is not what would be expected.\n\n1 Note that some of the overloads of the standard library are implemented as member functions, and some as free functions. Only the locale-dependent functions are member functions, such as .\n\n2 According to the rules of thumb, the insertion/extraction operators should be member functions because they modify the left operand. However, we cannot follow the rules of thumb here.\n\nThe function call operator, used to create function objects, also known as functors, must be defined as a member function, so it always has the implicit argument of member functions. Other than this, it can be overloaded to take any number of additional arguments, including zero.\n\nHere's an example of the syntax:\n\nThroughout the C++ standard library, function objects are always copied. Your own function objects should therefore be cheap to copy. If a function object absolutely needs to use data which is expensive to copy, it is better to store that data elsewhere and have the function object refer to it.\n\nIn the most simple case, you can overload all comparison comparison operators by defaulting in C++20:\n\nIf you can't do this, continue to the linked answer.\n\nThe unary prefix negation should be implemented as a member function. It is usually not a good idea to overload it because of how rare and surprising it is.\n\nThe remaining binary logical operators ( , ) should be implemented as free functions. However, it is very unlikely that you would find a reasonable use case for these1.\n\n1 It should be noted that the built-in version of and use shortcut semantics. While the user defined ones (because they are syntactic sugar for method calls) do not use shortcut semantics. User will expect these operators to have shortcut semantics, and their code may depend on it, Therefore it is highly advised NEVER to define them.\n\nThe unary increment and decrement operators come in both prefix and postfix flavor. To tell one from the other, the postfix variants take an additional dummy int argument. If you overload increment or decrement, be sure to always implement both prefix and postfix versions.\n\nHere is the canonical implementation of increment, decrement follows the same rules:\n\nNote that the postfix variant is implemented in terms of prefix. Also note that postfix does an extra copy.1\n\nOverloading unary minus and plus is not very common and probably best avoided. If needed, they should probably be overloaded as member functions.\n\n1 Also note that the postfix variant does more work and is therefore less efficient to use than the prefix variant. This is a good reason to generally prefer prefix increment over postfix increment. While compilers can usually optimize away the additional work of postfix increment for built-in types, they might not be able to do the same for user-defined types (which could be something as innocently looking as a list iterator). Once you got used to do , it becomes very hard to remember to do instead when is not of a built-in type (plus you'd have to change code when changing a type), so it is better to make a habit of always using prefix increment, unless postfix is explicitly needed.\n\nFor the binary arithmetic operators, do not forget to obey the third basic rule operator overloading: If you provide , also provide , if you provide , do not omit , etc. Andrew Koenig is said to have been the first to observe that the compound assignment operators can be used as a base for their non-compound counterparts. That is, operator is implemented in terms of , is implemented in terms of , etc.\n\nAccording to our rules of thumb, and its companions should be non-members, while their compound assignment counterparts ( , etc.), changing their left argument, should be a member. Here is the exemplary code for and ; the other binary arithmetic operators should be implemented in the same way:\n\nreturns its result per reference, while returns a copy of its result. Of course, returning a reference is usually more efficient than returning a copy, but in the case of , there is no way around the copying. When you write , you expect the result to be a new value, which is why has to return a new value.1\n\nAlso note that can be slightly shortened by passing by value, not by reference. However, this would be leaking implementation details, make the function signature asymmetric, and would prevent named return value optimization where is the same object as the one being returned.\n\nSometimes, it's impractical to implement in terms of , such as for matrix multiplication. In that case, you can also delegate to :\n\nThe bit manipulation operators should be implemented in the same way as the arithmetic operators. However, (except for overloading and for output and input) there are very few reasonable use cases for overloading these.\n\n1 Again, the lesson to be taken from this is that is, in general, more efficient than and should be preferred if possible.\n\nThe subscript operator is a binary operator which must be implemented as a class member. It is used for container-like types that allow access to their data elements by a key. The canonical form of providing these is this:\n\nUnless you do not want users of your class to be able to change data elements returned by (in which case you can omit the non-const variant), you should always provide both variants of the operator.\n\nFor defining your own iterators or smart pointers, you have to overload the unary prefix dereference operator and the binary infix pointer member access operator :\n\nNote that these, too, will almost always need both a const and a non-const version. For the operator, if is of (or or ) type, another is called recursively, until an returns a value of non-class type.\n\nThe unary address-of operator should never be overloaded.\n\nFor (and more details about ) see this question. is rarely used and thus rarely ever overloaded. In fact, even iterators do not overload it."
    },
    {
        "link": "https://programiz.com/cpp-programming/operator-overloading",
        "document": "In C++, we can define how operators behave for user-defined types like class and structures. For example,\n\nThe operator, when used with values of type , returns their sum. However, when used with objects of a user-defined type, it is an error.\n\nIn this case, we can define the behavior of the operator to work with objects as well.\n\nThis concept of defining operators to work with objects and structure variables is known as operator overloading.\n\nThe syntax for overloading an operator is similar to that of function with the addition of the keyword followed by the operator symbol.\n• - the return type of the function\n• - the operator we want to overload ( , , , , etc.)\n• - the arguments passed to the function\n\nFollowing is a program to demonstrate the overloading of the operator for the class .\n\nHere, we first created a friend function with a return type .\n\nThe operator keyword followed by indicates that we are overloading the operator.\n• indicates that we are passing objects by reference and and are references to objects. This is an efficient approach because it avoids unnecessary copying, especially for large objects. To learn more, visit C++ References.\n• indicates that referenced objects are constant, meaning we cannot modify and within the function.\n\nInside the function, we created another object, to store the result of addition.\n\nWe then add the real parts of two objects and store it into the attribute of the object.\n\nSimilarly, we add the imaginary parts of the two objects and store them into the attribute of the object.\n\nAt last, we return the temp object from the function.\n\nFollowing is a program to demonstrate the overloading of the operator for the class .\n\nHere, when we use , the is called. This increases the value attribute for the object by 1.\n\nNote: When we overload operators, we can use it to work in any way we like. For example, we could have used ++ to increase value by 100. However, this makes our code confusing and difficult to understand. It's our job as a programmer to use operator overloading properly and in a consistent and intuitive way.\n\nThings to Remember in C++ Operator Overloading\n\n1. By default, operators and are already overloaded in C++. For example,\n\nwe can directly use the operator to copy objects of the same class. Here, we do not need to create an operator function.\n\n2. We cannot change the precedence and associativity of operators using operator overloading.\n\n3. We cannot overload following operators in C++:\n\n4. We cannot overload operators for fundamental data types like , , etc\n• How to overload increment operator in right way?\n• How to overload binary operator - to subtract complex numbers?"
    },
    {
        "link": "http://cs.caltech.edu/courses/cs11/material/cpp/donnie/cpp-ops.html",
        "document": ""
    },
    {
        "link": "https://medium.com/@AlexanderObregon/the-inner-workings-of-c-operator-overloading-65db57870bbb",
        "document": "Operator overloading is a powerful feature in C++ that allows us to redefine the behavior of operators for user-defined types. This capability helps operators to work with objects in a way that feels natural and intuitive, similar to how they work with built-in types. In this article, we will explore how operator overloading is implemented in C++, including syntax, best practices, and plenty code examples.\n\nOperator overloading in C++ allows developers to redefine the functionality of operators for user-defined data types. This means you can customize how operators like , , , , and others behave when applied to instances of your classes. Operator overloading improves the expressiveness and readability of your code by allowing you to use intuitive syntax for complex operations on objects.\n\nThe primary reason for using operator overloading is to make code involving user-defined types as intuitive and readable as code involving built-in types. For example, if you have a class to represent complex numbers, overloading the operator allows you to write instead of . This can make mathematical operations on complex numbers look more natural and familiar.\n\nIn C++, operators are essentially functions with special names. When you overload an operator, you define a function that provides the operator’s new behavior for specific types. The name of this function is formed by the keyword followed by the symbol of the operator being overloaded.\n\nOperators can be overloaded in two primary ways:\n• Member Function: The operator function is defined as a member of the class.\n• Non-Member Function: The operator function is defined outside the class, usually as a friend function.\n\nEach approach has its use cases and benefits.\n\nTo overload an operator in C++, you define a function using the keyword followed by the operator symbol. This function can take one or more arguments depending on the operator being overloaded. Here is a basic example of overloading the operator for a class:\n\nIn this example, the function is defined as a member of the class. It takes another object as a parameter and returns a new object representing the sum of the two.\n\nOperators can be categorized as unary or binary based on the number of operands they take. Unary operators take one operand, while binary operators take two.\n• Unary Operators: such as (increment) and (decrement), operate on a single operand. To overload a unary operator, you define a member function with no parameters or a non-member function with one parameter.\n\nIn this example, the function is defined as a member of the class and negates the real and imaginary parts of the complex number.\n• Binary Operators: such as , , , and , operate on two operands. To overload a binary operator, you define a member function with one parameter or a non-member function with two parameters.\n\nIn this example, the function is defined as a member of the class and multiplies two complex numbers using the formula for complex multiplication.\n\nWhile C++ allows overloading most operators, there are some restrictions:\n• Operators that cannot be overloaded: (scope resolution), (member access), (member pointer access), (ternary conditional), and .\n• Preserving operator precedence: Overloaded operators maintain their original precedence and associativity. This amkes sure that the expressions involving both overloaded and built-in operators are evaluated correctly.\n\nWhen overloading operators, it is essential to consider the implications on class design and maintainability. Overloading operators can make your classes more intuitive, but it can also introduce complexity if not done thoughtfully.\n\nThe operator can be overloaded to provide custom array-like access to elements within a class. This can be particularly useful for classes that manage collections or arrays internally.\n\nIn this example, the operator is overloaded to provide access to elements of an internal array within the class. The function performs bounds checking and returns a reference to the specified element.\n\nWhile operator overloading can greatly improve the usability and readability of your classes, it is essential to follow certain best practices to make sure that the overloaded operators are intuitive, maintainable, and efficient. Below are some key guidelines to keep in mind when implementing operator overloading in C++.\n\nKeep It Intuitive and Predictable\n\nOverloaded operators should behave in a way that is consistent with their conventional meanings. For instance, the operator should perform an addition-like operation, and the operator should perform a multiplication-like operation. This consistency helps users of your class understand and predict the behavior of the operators.\n\nExample: Overloading the and Operators\n\nIn this example, the operator is overloaded to add two objects, and the operator is overloaded to multiply a object by a scalar. The behavior of these operators is intuitive and consistent with their conventional meanings.\n\nMake sure to have Symmetry and Consistency\n\nWhen overloading operators, it is crucial to maintain symmetry and consistency, especially for operators that are commonly used together, such as and . If you overload one, you should typically overload the other to ensure consistent behavior.\n\nExample: Overloading the and Operators\n\nIn this example, the operator is overloaded to compare two objects, and the operator is overloaded to return the negation of the operator's result. This makes sure consistent and predictable behavior when comparing objects.\n\nOperator overloading can introduce performance overhead, especially when dealing with large objects or complex operations. To mitigate this, consider using references and avoiding unnecessary copies. Additionally, for operators that involve complex calculations, make sure that the implementation is efficient.\n\nIn this example, the operator is overloaded to add another to the current object. The implementation makes sure that the dimensions of the matrices match and performs the addition efficiently. Using the operator avoids creating temporary objects, thus improving performance.\n\nOverloaded operators should logically group together. For example, if you overload the arithmetic operators ( , , , ), you should also overload the corresponding compound assignment operators ( , , , ). This consistency helps maintain logical groupings and makes the class easier to use.\n\nIn this example, the , , , and operators are overloaded for the class. This logical grouping makes sure that the class provides a complete set of arithmetic operations, making it more intuitive and easier to use.\n\nIt is essential to document your overloaded operators clearly, explaining their behavior, usage, and any constraints. This documentation helps users understand how to use the operators correctly and can prevent misuse or confusion.\n\nIn this example, documentation comments are added to the and operators to explain their behavior and usage. This documentation helps users understand how to use the operators and the expected outcomes.\n\nTo further show the practical use of operator overloading, let’s explore some different and unique examples involving various types of operators. These examples will demonstrate how operator overloading can be used to create more intuitive and readable code for custom data types.\n\nOverloading the and Operators for Comparison\n\nOverloading comparison operators like and allows you to define custom comparison logic for your objects. This can be useful when you need to compare objects based on specific criteria.\n\nExample: Overloading the and Operators for a Class\n\nIn this example, the operator is overloaded to compare two objects for equality, while the operator is overloaded to compare the dates chronologically.\n\nOverloading the operator can simplify the concatenation of strings or custom string-like objects, making the code more intuitive.\n\nExample: Overloading the Operator for a Class\n\nn this example, the operator is overloaded to concatenate two objects. The function allocates new memory for the concatenated result and make sure that the original string is updated correctly.\n\nThe operator can be overloaded to create custom smart pointers that manage the lifetime of dynamically allocated objects, providing automatic memory management and cleaner syntax.\n\nExample: Overloading the Operator for a Class\n\nIn this example, the operator is overloaded to allow a object to access the members of the object it manages. This provides a convenient syntax for accessing resource members while making sure to have proper memory management.\n\nOverloading the function call operator allows objects to be used as if they were functions. This can be useful for creating functor objects that encapsulate callable behavior.\n\nExample: Overloading the Operator for a Class\n\nIn this example, the operator is overloaded for the class, allowing objects to be called like functions. The function takes a string parameter and prints a message.\n\nOperator overloading in C++ is a great feature to define custom behaviors for operators, improving the intuitiveness and readability of code involving user-defined types. By following best practices and implementing operator overloading thoughtfully, you can create flexible and efficient classes that seamlessly integrate with C++ syntax. The practical examples provided show the basics on how to effectively use operator overloading to simplify complex operations, making your code more maintainable and user-friendly.\n\nThank you for reading! If you find this article helpful, please consider highlighting, clapping, responding or connecting with me on Twitter/X as it’s very appreciated and helps keeps content like this free!"
    },
    {
        "link": "https://geeksforgeeks.org/const-member-functions-c",
        "document": "Constant member functions are those functions that are denied permission to change the values of the data members of their class. To make a member function constant, the keyword const is appended to the function prototype and also to the function definition header.\n\nLike member functions and member function arguments, the objects of a class can also be declared as const. An object declared as const cannot be modified and hence, can invoke only const member functions as these functions ensure not to modify the object. A const object can be created by prefixing the const keyword to the object declaration. Any attempt to change the data member of const objects results in a compile-time error.\n\nThe const member function can be defined in three ways:\n\n2. For function definition within the class declaration.\n\n3. For function definition outside the class.\n• None When a function is declared as const, it can be called on any type of object, const object as well as non-const objects.\n• None Whenever an object is declared as const, it needs to be initialized at the time of declaration. however, the object initialization while declaring is possible only with the help of constructors.\n• None A function becomes const when the const keyword is used in the function’s declaration. The idea of const functions is not to allow them to modify the object on which they are called.\n• None It is recommended practice to make as many functions const as possible so that accidental changes to objects are avoided.\n\nThe below C++ program demonstrates that data members can be updated in a member function that is not constant.\n\nThe below C++ program demonstrates that data cannot be updated in a Constant member function.\n\nThe below C++ code demonstrates how to define constant member functions outside the class definition and showcases the usage of a constant member function to set and retrieve the value of a private member variable.\n\nThe below C++ program demonstrates that const functions can be called by non-const objects.\n\nWhen a function is declared as const, it can be called on any type of object. Non-const functions can only be called by non-const objects.\n\nFor example, the following program has compiler errors.\n\nLet’s look at another example:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/cpp/const-cpp?view=msvc-170",
        "document": "When it modifies a data declaration, the keyword specifies that the object or variable isn't modifiable.\n\nThe keyword specifies that a variable's value is constant and tells the compiler to prevent the programmer from modifying it.\n\nIn C++, you can use the keyword instead of the preprocessor directive to define constant values. Values defined with are subject to type checking, and can be used in place of constant expressions. In C++, you can specify the size of an array with a variable as follows:\n\nIn C, constant values default to external linkage, so they can appear only in source files. In C++, constant values default to internal linkage, which allows them to appear in header files.\n\nThe keyword can also be used in pointer declarations.\n\nA pointer to a variable declared as can be assigned only to a pointer that is also declared as .\n\nYou can use pointers to constant data as function parameters to prevent the function from modifying a parameter passed through a pointer.\n\nFor objects that are declared as , you can only call constant member functions. The compiler ensures that the constant object is never modified.\n\nYou can call either constant or non-constant member functions for a non-constant object. You can also overload a member function using the keyword; this feature allows a different version of the function to be called for constant and non-constant objects.\n\nYou can't declare constructors or destructors with the keyword.\n\nDeclaring a member function with the keyword specifies that the function is a \"read-only\" function that doesn't modify the object for which it's called. A constant member function can't modify any non-static data members or call any member functions that aren't constant. To declare a constant member function, place the keyword after the closing parenthesis of the argument list. The keyword is required in both the declaration and the definition.\n\nC and C++ differences\n\nWhen you define a variable in a C source code file, you do so as:\n\nYou can then use this variable in another module as follows:\n\nBut to get the same behavior in C++, you must define your variable as:\n\nSimilar to C, you can then use this variable in another module as follows:\n\nIf you wish to define an variable in a C++ source code file for use in a C source code file, use:\n\nto prevent name mangling by the C++ compiler.\n\nWhen following a member function's parameter list, the keyword specifies that the function doesn't modify the object for which it's invoked.\n\nFor more information on , see the following articles:"
    },
    {
        "link": "https://stackoverflow.com/questions/3141087/what-is-meant-with-const-at-end-of-function-declaration",
        "document": "A \"const function\", denoted with the keyword after a function declaration, makes it a compiler error for this class function to change a data member of the class. However, reading of a class variables is okay inside of the function, but writing inside of this function will generate a compiler error.\n\nAnother way of thinking about such \"const function\" is by viewing a class function as a normal function taking an implicit pointer. So a method (without the const at the end) results in a function like , and a call such as will internally correspond to something like . Now adding the const at the end ( ) can then be understood as a declaration with a const this pointer: . Since the type of in such case is const, no modifications of data members are possible.\n\nIt is possible to loosen the \"const function\" restriction of not allowing the function to write to any variable of a class. To allow some of the variables to be writable even when the function is marked as a \"const function\", these class variables are marked with the keyword . Thus, if a class variable is marked as mutable, and a \"const function\" writes to this variable then the code will compile cleanly and the variable is possible to change. (C++11)\n\nAs usual when dealing with the keyword, changing the location of the const key word in a C++ statement has entirely different meanings. The above usage of only applies when adding to the end of the function declaration after the parenthesis.\n\nis a highly overused qualifier in C++: the syntax and ordering is often not straightforward in combination with pointers. Some readings about correctness and the keyword:\n\nThe C++ 'const' Declaration: Why & How"
    },
    {
        "link": "https://tutorialspoint.com/const-member-functions-in-cplusplus",
        "document": "The const member functions are the functions which are declared as constant in the program. The object called by these functions cannot be modified. It is recommended to use const keyword so that accidental changes to object are avoided.\n\nA const member function can be called by any type of object. Non-const functions can be called by non-const objects only.\n\nHere is the syntax of const member function in C++ language,\n\nHere is an example of const member function in C++,"
    },
    {
        "link": "https://scaler.com/topics/what-are-const-member-function",
        "document": "Constant member functions do not permit any change in the values of their class's data members. To make a member function constant, the term \"const\" is applied to both the function prototype and the function definition header. The const keyword signifies that a member function is a \"read-only\" function that does not alter the object for which it is called. A class can also specify its objects as const, like member functions and member function arguments. A const object cannot be modified and can only invoke const member functions, ensuring that the object is not modified. A const object is constructed by prefixing the object declaration with the const keyword. Any attempt to alter the data member of a const object results in a compile-time error.\n\nThis program gives an error because we try to update a constant member function value. Example of a Const Member Function Defined Outside a Class as a standalone Function For a standalone function in C++, we use the concept of the friend function. This program will give an error if we try to change any value in the fun() function. Example of a Const Member Function Defined Outside a Class as its Member Function. This program will give an error if we try to update the value of x in the get_value() function.\n\nLet's look at the program given below to understand the calling of const and non-const member functions. In this program, obj1 is a non-const function while obj2 is const object also get_square() is a non-const function while get_value() is a const function. As we know from the use cases of the const member function, the non-const function cannot be called by a const object. This is why the last cout gives an error while all the three don't.\n\nIf you pass an argument to the non-const function by reference and you don't want that, the function changes the value of the variable. So we add the const keyword to the function's argument so that the function does not change its value. In the program given below, we add the const keyword to variables a and b so that the get_value() function can never manipulate the values of the variables. This program gives an error as we try to update a const argument of the set_value() function.\n\nUse of Const Keywords with Different Parameters It is a const variable that is used to define variable values that will never change during program execution, and when we attempt to change the value results in an error. This program gives an error because we try to update the value of the const variable.\n\nTo make a const pointer, precede the pointer's name with the const keyword. We cannot modify the address of the const pointer after it has been created. Therefore the pointer will always point to the same address once it has been initialized as a const pointer. Program to use const keyword with pointers This program generates an error as we try to update the address of the const pointer. To use a const pointer with a variable we put the const keyword before the pointer variable. In this, we are allowed to update the address but we cannot change the value. Program to use const pointer with variables This program successfully updated the address stored in the const ptr pointer. This program will generate an error if we try to update the value stored in the pointer. We can use the const keyword to declare the function arguments as constant arguments. Furthermore, if the value of a function argument is marked const, it cannot be changed. Program to use const keyword with function argument The above program will generate an error if we try to modify the value of the arguments of the fun() function. Constant member functions do not permit any change in the values of their class's data members. To make a member function constant, the term \"const\" is applied to both the function prototype and the function definition header. The const keyword signifies that a member function is a \"read-only\" function that does not alter the object for which it is called."
    }
]