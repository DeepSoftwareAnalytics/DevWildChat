[
    {
        "link": "https://stackoverflow.com/questions/18649881/handling-input-arrays-in-express-forms",
        "document": "For , if you set the option to , attribute names of the format will be interpreted by the middleware as:\n\nJust be sure to initialize the middleware like so:\n\nAfterwards, change the above form declaration to have the message property be an object, instead of a string value, like so:\n\nAnd then, on the server side, would be an object, that looks like:\n\nAnd then, you can easily convert into an array:\n\nAnd now, you should be able to access each elements like so (note: I prefer a functional style, but I'll keep it consistent with yours):\n\nP.S.: if you're wondering of a functional style, then here it is:\n\nEdit: special thanks to @eye_mew for pointing out that we need to set to ."
    },
    {
        "link": "https://stackoverflow.com/questions/37054050/javascript-push-results-from-for-loop-into-array-with-soundcloud-api",
        "document": "I'm not expert on SoundCloud APIs but watching your code I thought this solution:\n\nYou were trying to push the contents to a wrong variable, which was the response from the API. In this solution we are saving to meGenrePref all genres."
    },
    {
        "link": "https://dev.to/ryhenness/making-a-node-js-soundcloud-music-player-315d",
        "document": "What's up, it's been a while since I've posted! I'm excited about this one and I'm glad that you're here. :) I'm going to be building a SoundCloud music player using Node.js. This project's code can be found in my SweetCode repository alongside other code.\n\nThere are three main sections in this post. Following the post will walk you through the entire journey of building the SoundCloud music player - from setting up the 'Hello, world' server to changing the volume of the player:\n\nLet's start it off by making our server.js file. This is going to be our Node.js server, and it can stay simple for this project because a lot of the work will be done on the client-side. For this app, I'm going to be using Express as our minimalist server framework, and EJS as our view engine. If you're unfamiliar with setting up/running a Node.js server up, check this post out.\n\nAs you can see in our first route, we're going to be rendering client. \"Client\" is actually our .ejs file that is going to live in a folder called views. We've also got a public folder, this is where most of our JavaScript will live. Here is what the current folder structure looks like:\n\nWhenever I am starting work on a new project, I like to start simple and figure out what to focus on first. This project is mostly about making the browser play music from SoundCloud, so I want to keep the view as simple as possible for now. Let's set up our client.ejs file with a simple play button (this will give us a button to set the set up of our music player, it does nothing for now!).\n\nOkay so we're to the cool part! But how are we going to do this, what are we going to use? Well, we could use the vanilla SoundCloud API or we could search for some sort of wrapper package that someone has made for the SoundCloud API. I think I'm going to use this soundcloud-audio npm package written by Dmitri Voronianski, it seems solid and it's got good documentation to get us going.\n\nSince this npm package is written for the server-side, we're going to have to use some sort of bundler to allow us to use it on the client-side (the browser). You can find an explanation for this here. The bundler I am going to use is Browserify.\n\nLet's write our player.js file and then I'll show you how to bundle it and use it with your play button. Inside of our public folder, let's create our player.js. For this example, I'm going to be using this mix by Biskwiq.\n\n\n\nIn player.js let's first require our soundcloud-audio package and create our player. Creating the player requires you to use your own client id (I have scraped one from the web that you can use!)\n\nWe can give the window a function called play in which the player will call its resolve function with the link to the desired SoundCloud song.\n\nSweet, now all we have to do is include this script to our client.ejs file and assign it to the play button like so:\n\n\n\nOh wait! That's player-bundle.js, not player.js. We need to make this bundle file so that we can use this player on the client-side. Download Browserify by running this command in the root of your project:\n\n\n\nNow we can bundle the player.js by running the following command:\n\n\n\nThis will tell browserify to take the player.js file and bundle it up and throw its output into the same folder with the name player-bundle.js. Whenever we make a change to the player.js we need to rebundle it with this command. Running this command again will overwrite the bundle file without prompting.\n\nSweet! The play button now streams that song! NOTE: The volume will be high as we have not touched that setting yet. :)\n\nSo it plays music, but it doesn't do much else yet. I definitely expect a music player to have a pause button, and be able to change the volume. Let's do it! I'm first going to give my client.ejs the buttons:\n\nFirst, let's implement the pause function for the player since we're referencing it in the onclick but it's not actually defined yet. It's very easy, the function we want to use is already on the player constant we made:\n\nBam, the song pauses! Now let's get that volume control working so that we don't blow our ears off again. Our player is going to need to know what volume level to set the volume to, so let's make a function that takes a level. Note that this level needs to be a decimal, we'll be passing in a whole number then dividing it by 100 so that it's in decimal form for the player's setVolume function.\n\nSince we're not using a button for the volume, we can't use an onclick. What we can do is get the \"volume-range* control and call the setVolume function whenever it the control gets input.\n\nIf you followed along with me, congrats! You just made a SoundCloud music player. You used an Express Node.js server to serve a bundled npm package that wraps functionality for the SoundCloud API. If you want to continue development on this project, I've got a few suggestions:\n• Add a timeline for the song so that the user can change the time of the song.\n• Add some styling so that the player looks better!\n• Add a queue so that the user can add songs to be played next (also add a next button).\n• Show the currently playing song's cover art, title, and artist name.\n• Make it so that the player is shared across web browsers (if one user plays, skips, etc. then that function also happens for other users on the site). Look into socket.io.\n\nThanks for sticking around until the end. If you've got any questions feel free to comment/message me directly here, or on my socials: @rhenness & @ryhenness most places. :)\n\nIf you liked this post, you might also like Make a Node.js Twitter Bot: Bogus Definition."
    },
    {
        "link": "https://github.com/expressjs/multer/issues/133",
        "document": "I'm really unsure of this myself, but I wanted to get the discussion started. Should be an array?\n\nIt would certainly help #59 since there then would be only one array to check. I also think that the most common case is having one file upload which then would be really easy to find, .\n\nThe downside would be pages that has multiple files with different fieldnames, it would be a bit more complicated to find a specific file.\n\nTo mitigate that we could expose a function. would obviously be the filename and would be a boolean on wether to allow multiple files or not. It would default to .\n\nIf is and there is more than one file uploaded to that fieldname, I think that it should throw an error.\n\nOn top of this we could also expose a function. That could help with sites that allows uploading any files, and then want to treat music, pictures or movies differently.\n\nAlthough I feel that we are maybe providing a bit too much with the functions. If is just a normal array, it's very easy to do this with both built in functions, and already popular libraries."
    },
    {
        "link": "https://developers.soundcloud.com/docs/api/sdks",
        "document": "The SDKs will make it easier to access the SoundCloud API on your framework of choice. We officially provide and support only JavaScript. All other SDKs (Ruby, Python) are supported by third-party developers.\n\nWe welcome contributions to the open source projects so imagine how happy we'd be if you submit an SDK of your own for any additional language.\n\nThe JavaScript SDK lets you easily integrate SoundCloud into your website or webapp.\n\nTo start using the SDK just add this script to your HTML and initialize the client with your own and optionally your in case you want to use authentication:\n\nYou can also install the SDK via NPM now: .\n\nOnce that's done you are all set and ready to use the SoundCloud API. For example getting a user's latest track:\n\nThe JavaScript SDK is open source and can be found on Github. If you are looking for example applications, have a look at the examples on this page.\n\nTo use the authentication you have to host a file on your server and set it as the in your app settings and when initializing the SDK. This file needs to contain just a few lines:\n\nYou initiate the connect flow by calling . Once your users are authenticated and authorized, your app is allowed to use the HTTP methods SC.post, SC.put and SC.delete to create comments, liking a track or updating user profiles. The following example shows how to follow a user, after connecting the current user:\n\nThe SDK provides easy access to all HTTP endpoints through the SC.get, SC.post, SC.put and SC.delete methods.\n\nFor a list of available endpoints, check the API Reference.\n\nStreaming tracks from the SDK is powered by the same player that is also used on soundcloud.com to ensure the best playback experience.\n\nThe player has all basic methods to control the playback flow like , , , , etc.\n\nThe SDK uses getUserMedia, Web Workers and the Web Audio API to record from a user's computer, so make sure to check if the user's browser supports all of it (1, 2, 3) before you start recording. This example will record 5 seconds and play it back right away:\n\nIn addition to recording from the user's computer, the SDK also supports recording from an arbitrary AudioNode by passing it to the Recorder's constructor. Check out the documentation and the examples for more information.\n\nYou can upload recordings and files using the SDK's method. This method requires the user's browser to support FormData (supported in all modern browsers and IE10+, 1).\n\nUploads can take a while and it makes sense to inform the user about the progress. For this reason, returns the original request as well so that you can calculate the progress yourself.\n\nThe function is a wrapper for the SoundCloud oEmbed endpoint.\n\nIt takes the URL you want to embed as an argument, and an optional options object that can contain an element that should be replaced by the embed code. All of the object's properties will be passed as parameters to the oEmbed endpoint. For example , , or . The options are described in detail in the oEmbed documentation.\n\nIf you want to check out more SDK usage examples, head over to the API Guide. It shows how to use API methods in all available SDKs.\n\nAn example of an application that is using a combination of several SDK methods can be found on Github. It records a user's microphone and uploads it together with an artwork that is generated from the user's webcam. (no Flash required!)\n\nThe SDK uses Promises for most of its methods. They provide a way to easily compose API calls and offer a sane way to handle the various errors that can occur.\n\nPromises can be chained by using their method and errors can be handled in a handler. If you are new to Promises, check out this introductory blog artice on HTML5 rocks: html5rocks.com/en/tutorials/es6/promises.\n\nIn order to conform with the ES6 standard, the SDK uses es6-promise which shims the object on systems where it is not available. We also expose the library via SC.Promise, so that you can use methods like or even if your user's browser is not supporting Promises yet.\n• :\n• (optional): Only needed if you want to authenticate users\n• (optional): If you want to reuse an access token\n• :\n• : the redirect URI as defined in your app settings.\n\nReturns: A promise that will resolve with a session data object\n• : the path to the requested resource e.g. '/users/183'\n• : an object of additional parameters to pass in the request.\n\nReturns: A promise that will resolve with the requested resource\n• : the path to the requested resource e.g. '/me/followings'\n• : an object of additional parameters to pass in the request body.\n\nReturns: A promise that will resolve with the requested resource\n• : the path to the requested resource e.g. '/me'\n• : an object of additional parameters to pass in the request body.\n\nReturns: A promise that will resolve with the requested resource\n• : the path to the requested resource\n\nReturns: A promise that will resolve when the resource has been deleted\n• :\n• : a Blob of the file or the recording (see recorder.getWAV()).\n• It also accepts all other params for upload requests, such as or (see API Reference for a full list).\n\nReturns: A promise that will resolve when the resource has been uploaded. It also contains a reference to the original request (see Uploading)\n\nResolves a SoundCloud URL to a JSON representation of the requested resource\n• : a URL to a track, playlist or user on SoundCloud.\n\nReturns: A promise that will resolve with a JSON object\n\nWill lookup the embed code for the passed URL (track, set or user) using oEmbed\n• : a URL to a track, set or user on SoundCloud.\n• : additional parameters for oEmbed. See oEmbed docs. In addition to that, it accepts an property that will replace the HTML element with the widget.\n\nReturns: A promise that will resolve with the oEmbed info for the resource\n• : the path of the track to be streamed e.g. /tracks/293\n\nReturns: A promise that will resolve with a player for the track\n\nThe constructor function which returns an instance of the Web Audio Recorder (has to be called with )\n• :\n• : You can pass an AudioContext if you want to reuse it\n• : Pass a source if you want to record from an AudioNode\n\nStarts recording from the user's computer or the that was passed into the constructor\n\nRequires the Web Audio API, Web Workers and getUserMedia to be available in the user's browser\n\nPlays back what was just recorded\n\nReturns: The AudioNode that is used to play the sound\n\nReturns: A promise that resolves with a WAV Blob of the current recording\n\nReturns: A promise that resolves with an AudioBuffer of the current recording\n\nDownloads the recorded WAV to the user's computer\n• : The desired name of the file\n\nThe promise prototype that is used in the SDK internally (es6-promise). Use it to create your own promises or to use methods like Promise.all or Promise.race.\n\nYou can use the methods below to control the player that is returned from SC.stream\n• : Starts to play the sound. Returns a Promise that resolves when playback starts, and may reject if the browser refuses playback.\n• : Seeks to the position in the song (in milliseconds). Returns a Promise that resolves when the seek completes, or may reject if the seek is not possible.\n• : Sets the volume (from 0 to 1)\n• : Returns true whilst the intended state is to be playing. This flips with and calls.\n• : Returns true whilst the player is actually playing\n• : Returns true if the player is dead because of an error\n• : Returns true if the player is dead\n• : Kill the player. Call this when you do not need it anymore.\n• : Subscribes the handler to the given event\n\nYou can subscribe to the events below by using the player's method.\n• : when audio controller changes state (e.g. from pause to play). Possible values: 'playing', 'paused', 'loading', 'ended', 'error' or 'dead'\n• : when playback actually starts, the first time\n• : when playback starts, the second time onwards\n• : if a play request is rejected by the browser\n• : when a seek is rejected for some reason\n• : when there's no available streams for a sound, as it is not allowed to be played in the user's territory.\n• : when no supported protocol could be found\n• : when we failed to connect to an endpoint due to missing transport or request timeout"
    },
    {
        "link": "https://stackoverflow.com/questions/64211282/multiple-file-uploads-in-nodejs-using-express-fileupload",
        "document": "Currently I am able to post this to mongodb. It works fine.\n\nPROBLEM Instead of one attachment, I should be able to post many attachments independent of each other, there will be N different buttons available for the N uploads.\n\nI tried moving outside the block and do somthing like this``` const file1 = req.files.photo1;"
    },
    {
        "link": "https://medium.com/@mavi.baris96/have-you-uploaded-multiple-images-with-the-express-fileupload-package-but-cant-update-50847f9a7dd8",
        "document": "Our main goal begins now.. Let’s consider a product with 3 photos. We can easily show the features of the product, except for the visual section, on the page where we will update it, so that we can easily see what and where we have updated the product.\n\nThe only difference of the above code from the add-product.ejs file is to add the value of the product we are going to update as a method. But we need to follow a different path for the image.\n\nWe thought of a product with 3 photos.. Let’s also assume that we somehow reflect them on the page we are going to update. For example, I want to delete 1 of 3 photos and add 2 more images on top of the remaining photos. Here jquery comes to our rescue.\n\nWe define a subfolder called scripts in our public folder and create a file called main.js in it and write our jquery codes here. Here we are actually going to do HTML/DOM manipulation.\n\nBefore we started using the jquery library, in edit-product.ejs, we were able to access information such as name, description other than image, thanks to the value method. The codes we will write for the image section are below.\n\nThe first of the two inputs available in the code block above is to upload a new photo; the second is to show the update page of the photos we added while creating the product at the beginning..\n\nNext, we add a ✘ icon on the images that will appear on the update page, thanks to the <span class=”close”></span> code. We will manage the functionality of this ✘ icon in main.js.\n\nNow we need a function to collect the images loaded on the page into an array, and this function has to run again and again from the beginning whenever any image is deleted. For this;\n• We created a function called updateEditedImages to perform all these operations.\n• We def ined a new array called images to collect all images inside the function.\n• Since the data in the input should always be in string form, we made use of the JSON.stringify() method.\n• When we clicked on the ✘ icon, we deleted that image and triggered the updateEditedImages function to work again.\n\nIn summary, the inside of the editedImages array at the top is constantly emptying as the ✘ icon is pressed on the page, and whatever images are left on the page are filled back into the editedImages array. For now, it is possible to manage the photos we uploaded while creating the product! Now, we will learn what to do if there is a new image that we want to add other than the images inside the editedImages array.\n\nWe came to the controller folder on the backend side:\n\nIn order to process our Edit Images as objects, we convert them from string to object with the JSON.parse method and catch the last changes we made with jquery on the front. (The reason I use the map method is that it should be saved to mongoDb as uploads/imageName.jpg, but since it comes to me as /uploads/imageName.jpg, I remove the “/” sign at the beginning of the images thanks to the slice method.)\n\nNext, we add the images that we want to add to our product, apart from the existing images, by typing the same codes as we wrote while uploading the product image at the beginning of the page. Finally, with the help of the spread operator, we place the newly added images behind the images we keep in the edit image.\n\nIn the final, after we specify the other parts we want to update in the product, we save all of them and the process is complete.\n\nThus ended my first medium post… I hope I helped. Hope to encounter other problems…"
    },
    {
        "link": "https://linkedin.com/pulse/how-upload-files-using-express-fileupload-expressjs-project-biswas-8zcic",
        "document": "First, you need to install the express-fileupload package.\n\nIn your main app.js or server.js file, set up Express and import express-fileupload.\n\nNext, add express-fileupload as middleware to your Express app. This will allow you to handle file uploads.\n\nYou need a frontend where users can upload files. Create an HTML form that sends a file to the server using a POST request.\n\nNow, you’ll create a route to handle the file upload. This route will capture the file sent from the form, and then store it on the server.\n\napp.post('/upload', (req, res) => { if (!req.files || Object.keys(req.files).length === 0) { return res.status(400).send('No files were uploaded.'); } // Access the file through req.files.<input_name> let uploadedFile = req.files.file; // Set the file upload path const uploadPath = path.join(__dirname, 'uploads', uploadedFile.name); // Use the mv() method to place the file in the desired directory uploadedFile.mv(uploadPath, (err) => { if (err) { return res.status(500).send(err); } res.send('File uploaded successfully!'); }); });\n\nCreate a folder named uploads in your project’s root directory where the uploaded files will be stored.\n\nIf you want to allow users to access uploaded files, you can serve them as static files by adding this line:\n\nFinally, start your Express server and visit the form in your browser to upload a file.\n• Open a browser and navigate to http://localhost:3000 (assuming your server is running).\n• The file should be uploaded to the uploads folder.\n• You can set size limits for uploaded files and customize error handling as needed."
    },
    {
        "link": "https://stackoverflow.com/questions/23691194/node-express-file-upload",
        "document": "I'm using node v0.10.26 and express v4.2.0 and I'm pretty new to node. I've been beating my head against my desk for the past three or so hours trying to get a file upload form working with node. At this point I'm just trying to get req.files to not return undefined. My view looks like this var express = require('express'); var path = require('path'); var favicon = require('static-favicon'); var logger = require('morgan'); var cookieParser = require('cookie-parser'); var bodyParser = require('body-parser'); var routes = require('./routes/index'); var users = require('./routes/users'); var app = express(); // view engine setup app.set('views', path.join(__dirname, 'views')); app.set('view engine', 'hjs'); app.use(favicon()); app.use(logger('dev')); app.use(bodyParser.json()); app.use(bodyParser.urlencoded()); app.use(cookieParser()); app.use(express.static(path.join(__dirname, 'public'))); app.use('/', routes); app.use('/users', users); /// catch 404 and forward to error handler app.use(function(req, res, next) { var err = new Error('Not Found'); err.status = 404; next(err); }); /// error handlers // development error handler // will print stacktrace if (app.get('env') === 'development') { app.use(function(err, req, res, next) { res.status(err.status || 500); res.render('error', { message: err.message, error: err }); }); } // production error handler // no stacktraces leaked to user app.use(function(err, req, res, next) { res.status(err.status || 500); res.render('error', { message: err.message, error: {} }); }); module.exports = app; I saw somewhere that including and was supposed to help but I can't even launch my server if I add those lines."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-implement-file-uploading-and-downloading-with-express",
        "document": "File uploading and downloading are important features of a web app. Here we are going to handle file upload using express-fileupload npm package, and the download is handled using res.download() function of the express. The express-fileupload is passed to the app as the middleware.\n\nApproach: First, install express-fileupload module and then require it and pass it as middleware to the app as shown below:\n\nThen in order to access the uploaded files inside POST request using:\n\nIt provides some functions and values such as file name, mime type, data, and size. It provides an important mv() function which is used to save the uploaded file. It takes the upload path and an error handling function as parameters.\n\nThe download is handled using res.download() function which takes two parameters: file path and error handling function.\n\nStep 1: Create an app.js file, index.html file, and initialize the project using the following command:\n\nStep 2: Install express and express-fileupload using the following command:\n\nProject Structure: The project structure would look like the following. Create an upload folder inside the project directory and also create a file named download_gfg.txt inside the project folder, which would be downloaded.\n\nStep 3: Now let’s first code the index.html file. In it, we create two forms, the one which handles upload has action=’/upload’ and the one which handles download has action=’/download’.\n\nStep 4: Now we will code the app.js file. In it, we have created a POST route – ‘/upload’ to handle upload and GET route – ‘/download’ to handle download. For the GET request to the root of the app, we send the index.html file.\n\nStep to run the application: Start the application using the following command.\n\nOutput: Open the browser and go to you will see the following command:"
    }
]