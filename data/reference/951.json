[
    {
        "link": "https://mongodb.com/developer/languages/javascript/getting-started-with-mongodb-and-mongoose",
        "document": ""
    },
    {
        "link": "https://mongoosejs.com/docs/connections.html",
        "document": "You can connect to MongoDB with the method.\n\nThis is the minimum needed to connect the database running locally on the default port (27017). For local MongoDB databases, we recommend using instead of . That is because Node.js 18 and up prefer IPv6 addresses, which means, on many machines, Node.js will resolve to the IPv6 address and Mongoose will be unable to connect, unless the mongodb instance is running with ipv6 enabled.\n\nYou can also specify several more parameters in the :\n\nSee the mongodb connection string spec for more details.\n\nMongoose lets you start using your models immediately, without waiting for mongoose to establish a connection to MongoDB.\n\nThat's because mongoose buffers model function calls internally. This buffering is convenient, but also a common source of confusion. Mongoose will not throw any errors by default if you use a model without connecting.\n\nTo disable buffering, turn off the option on your schema. If you have on and your connection is hanging, try turning off to see if you haven't opened a connection properly. You can also disable globally:\n\nNote that buffering is also responsible for waiting until Mongoose creates collections if you use the option. If you disable buffering, you should also disable the option and use to create capped collections or collections with collations.\n\nThere are two classes of errors that can occur with a Mongoose connection.\n• Error on initial connection: If initial connection fails, Mongoose will emit an 'error' event and the promise returns will reject. However, Mongoose will not automatically try to reconnect.\n• Error after initial connection was established: Mongoose will attempt to reconnect, and it will emit an 'error' event.\n\nTo handle initial connection errors, you should use or with async/await.\n\nTo handle errors after initial connection was established, you should listen for error events on the connection. However, you still need to handle initial connection errors as shown above.\n\nNote that Mongoose does not necessarily emit an 'error' event if it loses connectivity to MongoDB. You should listen to the event to report when Mongoose is disconnected from MongoDB.\n\nThe method also accepts an object which will be passed on to the underlying MongoDB driver.\n\nA full list of options can be found on the MongoDB Node.js driver docs for . Mongoose passes options to the driver without modification, modulo a few exceptions that are explained below.\n• - This is a mongoose-specific option (not passed to the MongoDB driver) that disables Mongoose's buffering mechanism\n• / - The username and password for authentication. These options are Mongoose-specific, they are equivalent to the MongoDB driver's and options.\n• - By default, mongoose will automatically build indexes defined in your schema when it connects. This is great for development, but not ideal for large production deployments, because index builds can cause performance degradation. If you set to false, mongoose will not automatically build indexes for any model associated with this connection.\n• - Specifies which database to connect to and overrides any database specified in the connection string. This is useful if you are unable to specify a default database in the connection string like with some syntax connections.\n\nBelow are some of the options that are important for tuning Mongoose.\n• - The maximum number of sockets the MongoDB driver will keep open for this connection. By default, is 100. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See Slow Trains in MongoDB and Node.js. You may want to decrease if you are running into connection limits.\n• - The minimum number of sockets the MongoDB driver will keep open for this connection. The MongoDB driver may close sockets that have been inactive for some time. You may want to increase if you expect your app to go through long idle times and want to make sure your sockets stay open to avoid slow trains when activity picks up.\n• - How long the MongoDB driver will wait before killing a socket due to inactivity after initial connection. A socket may be inactive because of either no activity or a long-running operation. defaults to 0, which means Node.js will not time out the socket due to inactivity. This option is passed to Node.js function after the MongoDB driver successfully completes.\n• - Whether to connect using IPv4 or IPv6. This option passed to Node.js' function. If you don't specify this option, the MongoDB driver will try IPv6 first and then IPv4 if IPv6 fails. If your call takes a long time, try\n• - The database to use when authenticating with and . In MongoDB, users are scoped to a database. If you are getting an unexpected login failure, you may need to set this option.\n• - The MongoDB driver will try to find a server to send any given operation to, and keep retrying for milliseconds. If not set, the MongoDB driver defaults to using (30 seconds).\n• - The MongoDB driver sends a heartbeat every to check on the status of the connection. A heartbeat is subject to , so the MongoDB driver will retry failed heartbeats for up to 30 seconds by default. Mongoose only emits a event after a heartbeat has failed, so you may want to decrease this setting to reduce the time between when your server goes down and when Mongoose emits . We recommend you do not set this setting below 1000, too many heartbeats can lead to performance degradation.\n\nThe option is extremely important: it controls how long the MongoDB Node.js driver will attempt to retry any operation before erroring out. This includes initial connection, like , as well as any operations that make requests to MongoDB, like or .\n\nBy default, is 30000 (30 seconds). This means that, for example, if you call when your standalone MongoDB server is down, your call will only throw an error after 30 seconds.\n\nSimilarly, if your standalone MongoDB server goes down after initial connection, any or calls will error out after 30 seconds, unless your MongoDB server is restarted.\n\nWhile 30 seconds seems like a long time, means you're unlikely to see any interruptions during a replica set failover. If you lose your replica set primary, the MongoDB Node driver will ensure that any operations you send during the replica set election will eventually execute, assuming that the replica set election takes less than .\n\nTo get faster feedback on failed connections, you can reduce to 5000 as follows. We don't recommend reducing unless you are running a standalone MongoDB server rather than a replica set, or unless you are using a serverless runtime like AWS Lambda.\n\nThere is no way to tune independently for vs for queries. If you want to reduce for queries and other operations, but still retry for longer, you are responsible for retrying the calls yourself using a loop or a tool like p-retry.\n\nThe function also accepts a callback parameter and returns a promise.\n\nYou can also specify driver options in your connection string as parameters in the query string portion of the URI. This only applies to options passed to the MongoDB driver. You can't set Mongoose-specific options like in the query string.\n\nThe disadvantage of putting options in the query string is that query string options are harder to read. The advantage is that you only need a single configuration option, the URI, rather than separate options for , etc. Best practice is to put options that likely differ between development and production, like or , in the connection string, and options that should remain constant, like or , in the options object.\n\nThe MongoDB docs have a full list of supported connection string options. Below are some options that are often useful to set in the connection string because they are closely associated with the hostname and authentication information.\n• - The database to use when authenticating with and . In MongoDB, users are scoped to a database. If you are getting an unexpected login failure, you may need to set this option.\n• - Whether to connect using IPv4 or IPv6. This option passed to Node.js' function. If you don't specify this option, the MongoDB driver will try IPv6 first and then IPv4 if IPv6 fails. If your call takes a long time, try\n\nConnections inherit from Node.js' class, and emit events when something happens to the connection, like losing connectivity to the MongoDB server. Below is a list of events that a connection may emit.\n• : Emitted when Mongoose starts making its initial connection to the MongoDB server\n• : Emitted when Mongoose successfully makes its initial connection to the MongoDB server, or when Mongoose reconnects after losing connectivity. May be emitted multiple times if Mongoose loses connectivity.\n• : Emitted after and is executed on all of this connection's models. May be emitted multiple times if Mongoose loses connectivity.\n• : Your app called to disconnect from MongoDB. This includes calling , which calls on all connections.\n• : Emitted when Mongoose lost connection to the MongoDB server. This event may be due to your code explicitly closing the connection, the database server crashing, or network connectivity issues.\n• : Emitted after successfully closes the connection. If you call , you'll get both a 'disconnected' event and a 'close' event.\n• : Emitted if Mongoose lost connectivity to MongoDB and successfully reconnected. Mongoose attempts to automatically reconnect when it loses connection to the database.\n• : Emitted if an error occurs on a connection, like a due to malformed data or a payload larger than 16MB.\n\nWhen you're connecting to a single MongoDB server (a \"standalone\"), Mongoose will emit if it gets disconnected from the standalone server, and if it successfully connects to the standalone. In a replica set, Mongoose will emit if it loses connectivity to the replica set primary, and if it manages to reconnect to the replica set primary.\n\nIf you are using , you can use the following to listen to the above events:\n\nWith , use the following instead:\n\nBefore Mongoose 5.2.0, you needed to enable the option to initiate TCP keepalive to prevent errors. However, has been by default since Mongoose 5.2.0, and the is deprecated as of Mongoose 7.2.0. Please remove and options from your Mongoose connections.\n\nTo connect to a replica set you pass a comma delimited list of hosts to connect to rather than a single host.\n\nTo connect to a single node replica set, specify the option.\n\nThe underlying MongoDB driver uses a process known as server selection to connect to MongoDB and send operations to MongoDB. If the MongoDB driver can't find a server to send an operation to after , you'll get the below error:\n\nYou can configure the timeout using the option to :\n\nA has a property that explains why server selection timed out. For example, if you're connecting to a standalone server with an incorrect password, will contain an \"Authentication failed\" error.\n\nMongoDB replica sets rely on being able to reliably figure out the domain name for each member.\n\nOn Linux and OSX, the MongoDB server uses the output of the command to figure out the domain name to report to the replica set. This can cause confusing errors if you're connecting to a remote MongoDB replica set running on a machine that reports its as :\n\nIf you're experiencing a similar error, connect to the replica set using the shell and run the command to check the host names of each replica set member. Follow this page's instructions to change a replica set member's host name.\n\nYou can also check the property of to see what the MongoDB Node driver thinks the state of your replica set is. The property contains a map of server descriptions.\n\nYou can also connect to multiple mongos instances for high availability in a sharded cluster. You do not need to pass any special options to connect to multiple mongos in mongoose 5.x.\n\nSo far we've seen how to connect to MongoDB using Mongoose's default connection. Mongoose creates a default connection when you call . You can access the default connection using .\n\nYou may need multiple connections to MongoDB for several reasons. One reason is if you have multiple databases or multiple MongoDB clusters. Another reason is to work around slow trains. The function takes the same arguments as and returns a new connection.\n\nThis connection object is then used to create and retrieve models. Models are always scoped to a single connection.\n\nThe function returns a connection instance, not a promise. If you want to use to make sure Mongoose successfully connects to MongoDB, use the function:\n\nIf you use multiple connections, you should make sure you export schemas, not models. Exporting a model from a file is called the export model pattern. The export model pattern is limited because you can only use one connection.\n\nIf you use the export schema pattern, you still need to create models somewhere. There are two common patterns. The first is to create a function that instantiates a new connection and registers all models on that connection. With this pattern, you may also register connections with a dependency injector or another inversion of control (IOC) pattern.\n\nExporting a function that creates a new connection is the most flexible pattern. However, that pattern can make it tricky to get access to your connection from your route handlers or wherever your business logic is. An alternative pattern is to export a connection and register the models on the connection in the file's top-level scope as follows.\n\nYou can create separate files for each connection, like and if you want to create separate connections for your web API backend and your mobile API backend. Your business logic can then or the connection it needs.\n\nEach , whether created with or are all backed by an internal configurable connection pool defaulting to a maximum size of 100. Adjust the pool size using your connection options:\n\nThe connection pool size is important because MongoDB currently can only process one operation per socket. So functions as a cap on the number of concurrent operations.\n\nIn the context of Mongoose, a multi-tenant architecture typically means a case where multiple different clients talk to MongoDB through a single Mongoose application. This typically means each client makes queries and executes updates through a single Mongoose application, but has a distinct MongoDB database within the same MongoDB cluster.\n\nWe recommend reading this article about multi-tenancy with Mongoose; it has a good description of how we define multi-tenancy and a more detailed overview of our recommended patterns.\n\nThere are two patterns we recommend for multi-tenancy in Mongoose:\n• Maintain one connection pool, switch between tenants using the method.\n• Maintain a separate connection pool per tenant, store connections in a map or POJO.\n\nThe following is an example of pattern (1). We recommend pattern (1) for cases where you have a small number of tenants, or if each individual tenant's workload is light (approximately < 1 request per second, all requests take < 10ms of database processing time). Pattern (1) is simpler to implement and simpler to manage in production, because there is only 1 connection pool. But, under high load, you will likely run into issues where some tenants' operations slow down other tenants' operations due to slow trains.\n\nThe following is an example of pattern (2). Pattern (2) is more flexible and better for use cases with > 10k tenants and > 1 requests/second. Because each tenant has a separate connection pool, one tenants' slow operations will have minimal impact on other tenants. However, this pattern is harder to implement and manage in production. In particular, MongoDB does have a limit on the number of open connections, and MongoDB Atlas has separate limits on the number of open connections, so you need to make sure the total number of sockets in your connection pools doesn't go over MongoDB's limits.\n\nNow that we've covered connections, let's take a look at models."
    },
    {
        "link": "https://mongodb.com/developer/languages/javascript/mongoose-versus-nodejs-driver",
        "document": ""
    },
    {
        "link": "https://mongoosejs.com/docs",
        "document": "First be sure you have MongoDB and Node.js installed.\n\nNext install Mongoose from the command line using :\n\nNow say we like fuzzy kittens and want to record every kitten we ever meet in MongoDB. The first thing we need to do is include mongoose in our project and open a connection to the database on our locally running instance of MongoDB.\n\nFor brevity, let's assume that all following code is within the function.\n\nWith Mongoose, everything is derived from a Schema. Let's get a reference to it and define our kittens.\n\nSo far so good. We've got a schema with one property, , which will be a . The next step is compiling our schema into a Model.\n\nA model is a class with which we construct documents. In this case, each document will be a kitten with properties and behaviors as declared in our schema. Let's create a kitten document representing the little guy we just met on the sidewalk outside:\n\nKittens can meow, so let's take a look at how to add \"speak\" functionality to our documents:\n\nFunctions added to the property of a schema get compiled into the prototype and exposed on each document instance:\n\nWe have talking kittens! But we still haven't saved anything to MongoDB. Each document can be saved to the database by calling its save method. The first argument to the callback will be an error if any occurred.\n\nSay time goes by and we want to display all the kittens we've seen. We can access all of the kitten documents through our Kitten model.\n\nWe just logged all of the kittens in our db to the console. If we want to filter our kittens by name, Mongoose supports MongoDBs rich querying syntax.\n\nThis performs a search for all documents with a name property that begins with \"fluff\" and returns the result as an array of kittens to the callback.\n\nThat's the end of our quick start. We created a schema, added a custom document method, saved and queried kittens in MongoDB using Mongoose. Head over to the guide, or API docs for more."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Server-side/Express_Nodejs/mongoose",
        "document": "Before you jump in and start coding the models, it's worth taking a few minutes to think about what data we need to store and the relationships between the different objects. We know that we need to store information about books (title, summary, author, genre, ISBN) and that we might have multiple copies available (with globally unique ids, availability statuses, etc.). We might need to store more information about the author than just their name, and there might be multiple authors with the same or similar names. We want to be able to sort information based on the book title, author, genre, and category. When designing your models it makes sense to have separate models for every \"object\" (a group of related information). In this case some obvious candidates for these models are books, book instances, and authors. You might also want to use models to represent selection-list options (e.g. like a drop-down list of choices), rather than hard-coding the choices into the website itself — this is recommended when all the options aren't known up front or may change. A good example is a genre (e.g. fantasy, science fiction, etc.). Once we've decided on our models and fields, we need to think about the relationships between them. With that in mind, the UML association diagram below shows the models we'll define in this case (as boxes). As discussed above, we've created models for the book (the generic details of the book), book instance (status of specific physical copies of the book available in the system), and author. We have also decided to have a model for the genre so that values can be created dynamically. We've decided not to have a model for the — we will hard code the acceptable values because we don't expect these to change. Within each of the boxes, you can see the model name, the field names and types, and also the methods and their return types. The diagram also shows the relationships between the models, including their multiplicities. The multiplicities are the numbers on the diagram showing the numbers (maximum and minimum) of each model that may be present in the relationship. For example, the connecting line between the boxes shows that and a are related. The numbers close to the model show that a must have zero or more s (as many as you like), while the numbers on the other end of the line next to the show that a book can have zero or more associated s. Note: As discussed in our Mongoose primer below it is often better to have the field that defines the relationship between the documents/models in just one model (you can still find the reverse relationship by searching for the associated in the other model). Below we have chosen to define the relationship between / and / in the Book schema, and the relationship between the / in the Schema. This choice was somewhat arbitrary — we could equally well have had the field in the other schema. Note: The next section provides a basic primer explaining how models are defined and used. As you read it, consider how we will construct each of the models in the diagram above.\n\nDatabase methods to create, find, update, or delete records are asynchronous. What this means is that the methods return immediately, and the code to handle the success or failure of the method runs at a later time when the operation completes. Other code can execute while the server is waiting for the database operation to complete, so the server can remain responsive to other requests. JavaScript has a number of mechanisms for supporting asynchronous behavior. Historically JavaScript relied heavily on passing callback functions to asynchronous methods to handle the success and error cases. In modern JavaScript callbacks have largely been replaced by Promises. Promises are objects that are (immediately) returned by an asynchronous method that represent its future state. When the operation completes, the promise object is \"settled\", and resolves an object that represents the result of the operation or an error. There are two main ways you can use promises to run code when a promise is settled, and we highly recommend that you read How to use promises for a high level overview of both approaches. In this tutorial, we'll primarily be using to wait on promise completion within an , because this leads to more readable and understandable asynchronous code. The way this approach works is that you use the keyword to mark a function as asynchronous, and then inside that function apply to any method that returns a promise. When the asynchronous function is executed its operation is paused at the first method until the promise settles. From the perspective of the surrounding code the asynchronous function then returns and the code after it is able to run. Later when the promise settles, the method inside the asynchronous function returns with the result, or an error is thrown if the promise was rejected. The code in the asynchronous function then executes until either another is encountered, at which point it will pause again, or until all the code in the function has been run. You can see how this works in the example below. is an asynchronous function that is called within a block. When is run, code execution is paused at until the promise resolves, at which point the code continues to and waits again. The code in the block runs if an error is thrown in the asynchronous function, and this will happen if the promise returned by either of the methods is rejected. The asynchronous methods above are run in sequence. If the methods don't depend on each other then you can run them in parallel and finish the whole operation more quickly. This is done using the method, which takes an iterable of promises as input and returns a single . This returned promise fulfills when all of the input's promises fulfill, with an array of the fulfillment values. It rejects when any of the input's promises rejects, with this first rejection reason. The code below shows how this works. First, we have two functions that return promises. We on both of them to complete using the promise returned by . Once they both complete returns and the results array is populated, the function then continues to the next , and waits until the promise returned by is settled. You would call the in a block to catch any errors. Promises with / allow both flexible and \"comprehensible\" control over asynchronous execution!\n\nModels are defined using the interface. The Schema allows you to define the fields stored in each document along with their validation requirements and default values. In addition, you can define static and instance helper methods to make it easier to work with your data types, and also virtual properties that you can use like any other field, but which aren't actually stored in the database (we'll discuss a bit further below). Schemas are then \"compiled\" into models using the method. Once you have a model you can use it to find, create, update, and delete objects of the given type. Note: Each model maps to a collection of documents in the MongoDB database. The documents will contain the fields/schema types defined in the model . The code fragment below shows how you might define a simple schema. First you mongoose, then use the Schema constructor to create a new schema instance, defining the various fields inside it in the constructor's object parameter. In the case above we just have two fields, a string and a date. In the next sections, we will show some of the other field types, validation, and other methods. Models are created from schemas using the method: The first argument is the singular name of the collection that will be created for your model (Mongoose will create the database collection for the model SomeModel above), and the second argument is the schema you want to use in creating the model. Note: Once you've defined your model classes you can use them to create, update, or delete records, and run queries to get all records or particular subsets of records. We'll show you how to do this in the Using models section, and when we create our views. A schema can have an arbitrary number of fields — each one represents a field in the documents stored in MongoDB. An example schema showing many of the common field types and how they are declared is shown below. const schema = new Schema({ name: String, binary: Buffer, living: Boolean, updated: { type: Date, default: Date.now() }, age: { type: Number, min: 18, max: 65, required: true }, mixed: Schema.Types.Mixed, _someId: Schema.Types.ObjectId, array: [], ofString: [String], // You can also have an array of each of the other types too. nested: { stuff: { type: String, lowercase: true, trim: true } }, }); Most of the SchemaTypes (the descriptors after \"type:\" or after field names) are self-explanatory. The exceptions are:\n• : Represents specific instances of a model in the database. For example, a book might use this to represent its author object. This will actually contain the unique ID ( ) for the specified object. We can use the method to pull in the associated information when needed.\n• : An array of items. You can perform JavaScript array operations on these models (push, pop, unshift, etc.). The examples above show an array of objects without a specified type and an array of objects, but you can have an array of any type of object. The code also shows both ways of declaring a field:\n• Field name and type as a key-value pair (i.e. as done with fields , and ).\n• Field name followed by an object defining the , and any other options for the field. Options include things like:\n• Whether the field is required\n• Whether fields should automatically be set to lowercase, uppercase, or trimmed (e.g. ) For more information about options see SchemaTypes (Mongoose docs). Mongoose provides built-in and custom validators, and synchronous and asynchronous validators. It allows you to specify both the acceptable range of values and the error message for validation failure in all cases.\n• All SchemaTypes have the built-in required validator. This is used to specify whether the field must be supplied in order to save a document.\n• \n• enum: specifies the set of allowed values for the field.\n• match: specifies a regular expression that the string must match.\n• maxLength and minLength for the string. The example below (slightly modified from the Mongoose documents) shows how you can specify some of the validator types and error messages: const breakfastSchema = new Schema({ eggs: { type: Number, min: [6, \"Too few eggs\"], max: 12, required: [true, \"Why no eggs?\"], }, drink: { type: String, enum: [\"Coffee\", \"Tea\", \"Water\"], }, }); For complete information on field validation see Validation (Mongoose docs). Virtual properties are document properties that you can get and set but that do not get persisted to MongoDB. The getters are useful for formatting or combining fields, while setters are useful for de-composing a single value into multiple values for storage. The example in the documentation constructs (and deconstructs) a full name virtual property from a first and last name field, which is easier and cleaner than constructing a full name every time one is used in a template. Note: We will use a virtual property in the library to define a unique URL for each model record using a path and the record's value. For more information see Virtuals (Mongoose documentation). A schema can also have instance methods, static methods, and query helpers. The instance and static methods are similar, but with the obvious difference that an instance method is associated with a particular record and has access to the current object. Query helpers allow you to extend mongoose's chainable query builder API (for example, allowing you to add a query \"byName\" in addition to the , and methods).\n\nOnce you've created a schema you can use it to create models. The model represents a collection of documents in the database that you can search, while the model's instances represent individual documents that you can save and retrieve. We provide a brief overview below. For more information see: Models (Mongoose docs). Note: Creation, update, deletion and querying of records are asynchronous operations that return a promise. The examples below show just the use of the relevant methods and (i.e. the essential code for using the methods). The surrounding and block to catch errors are omitted for clarity. For more information on using see Database APIs are asynchronous above. To create a record you can define an instance of the model and then call on it. The examples below assume is a model (with a single field ) that we have created from our schema. // Create an instance of model SomeModel const awesome_instance = new SomeModel({ name: \"awesome\" }); // Save the new model instance asynchronously await awesome_instance.save(); You can also use to define the model instance at the same time as you save it. Below we create just one, but you can create multiple instances by passing in an array of objects. Every model has an associated connection (this will be the default connection when you use ). You create a new connection and call on it to create the documents on a different database. You can access the fields in this new record using the dot syntax, and change the values. You have to call or to store modified values back to the database. // Access model field values using dot notation console.log(awesome_instance.name); //should log 'also_awesome' // Change record by modifying the fields, then calling save(). awesome_instance.name = \"New cool name\"; await awesome_instance.save(); You can search for records using query methods, specifying the query conditions as a JSON document. The code fragment below shows how you might find all athletes in a database that play tennis, returning just the fields for athlete name and age. Here we just specify one matching field (sport) but you can add more criteria, specify regular expression criteria, or remove the conditions altogether to return all athletes. const Athlete = mongoose.model(\"Athlete\", yourSchema); // find all athletes who play tennis, returning the 'name' and 'age' fields const tennisPlayers = await Athlete.find( { sport: \"Tennis\" }, \"name age\", ).exec(); Note: It is important to remember that not finding any results is not an error for a search — but it may be a fail-case in the context of your application. If your application expects a search to find a value you can check the number of entries returned in the result. Query APIs, such as , return a variable of type Query. You can use a query object to build up a query in parts before executing it with the method. executes the query and returns a promise that you can on for the result. // find all athletes that play tennis const query = Athlete.find({ sport: \"Tennis\" }); // selecting the 'name' and 'age' fields query.select(\"name age\"); // limit our results to 5 items query.limit(5); // sort by age query.sort({ age: -1 }); // execute the query at a later time query.exec(); Above we've defined the query conditions in the method. We can also do this using a function, and we can chain all the parts of our query together using the dot operator (.) rather than adding them separately. The code fragment below is the same as our query above, with an additional condition for the age. The method gets all matching records, but often you just want to get one match. The following methods query for a single record:\n• : Finds the document with the specified (every document has a unique ).\n• : Finds a single document that matches the specified criteria.\n• , , , : Finds a single document by or criteria and either updates or removes it. These are useful convenience functions for updating and removing records. Note: There is also a method that you can use to get the number of items that match conditions. This is useful if you want to perform a count without actually fetching the records. There is a lot more you can do with queries. For more information see: Queries (Mongoose docs). You can create references from one document/model instance to another using the schema field, or from one document to many using an array of . The field stores the id of the related model. If you need the actual content of the associated document, you can use the method in a query to replace the id with the actual data. For example, the following schema defines authors and stories. Each author can have multiple stories, which we represent as an array of . Each story can have a single author. The property tells the schema which model can be assigned to this field. const mongoose = require(\"mongoose\"); const Schema = mongoose.Schema; const authorSchema = new Schema({ name: String, stories: [{ type: Schema.Types.ObjectId, ref: \"Story\" }], }); const storySchema = new Schema({ author: { type: Schema.Types.ObjectId, ref: \"Author\" }, title: String, }); const Story = mongoose.model(\"Story\", storySchema); const Author = mongoose.model(\"Author\", authorSchema); We can save our references to the related document by assigning the value. Below we create an author, then a story, and assign the author id to our story's author field. const bob = new Author({ name: \"Bob Smith\" }); await bob.save(); // Bob now exists, so lets create a story const story = new Story({ title: \"Bob goes sledding\", author: bob._id, // assign the _id from our author Bob. This ID is created by default! }); await story.save(); Note: One great benefit of this style of programming is that we don't have to complicate the main path of our code with error checking. If any of the operations fail, the promise will reject and an error will be thrown. Our error handling code deals with that separately (usually in a block), so the intent of our code is very clear. Our story document now has an author referenced by the author document's ID. In order to get the author information in the story results we use , as shown below. Story.findOne({ title: \"Bob goes sledding\" }) .populate(\"author\") // Replace the author id with actual author information in results .exec(); Note: Astute readers will have noted that we added an author to our story, but we didn't do anything to add our story to our author's array. How then can we get all stories by a particular author? One way would be to add our story to the stories array, but this would result in us having two places where the information relating authors and stories needs to be maintained. A better way is to get the of our author, then use to search for this in the author field across all stories. This is almost everything you need to know about working with related items for this tutorial. For more detailed information see Population (Mongoose docs).\n\nNow that we understand something of what Mongoose can do and how we want to design our models, it's time to start work on the LocalLibrary website. The very first thing we want to do is set up a MongoDB database that we can use to store our library data. For this tutorial, we're going to use the MongoDB Atlas cloud-hosted sandbox database. This database tier is not considered suitable for production websites because it has no redundancy, but it is great for development and prototyping. We're using it here because it is free and easy to set up, and because MongoDB Atlas is a popular database as a service vendor that you might reasonably choose for your production database (other popular choices at the time of writing include ScaleGrid and ObjectRocket). Note: If you prefer, you can set up a MongoDB database locally by downloading and installing the appropriate binaries for your system. The rest of the instructions in this article would be similar, except for the database URL you would specify when connecting. In the Express Tutorial Part 7: Deploying to Production tutorial we host both the application and database on Railway, but we could equally well have used a database on MongoDB Atlas. You will first need to create an account with MongoDB Atlas (this is free, and just requires that you enter basic contact details and acknowledge their terms of service). After logging in, you'll be taken to the home screen:\n• Click the + Create button in the Overview section.\n• This will open the Deploy your cluster screen. Click on the M0 FREE option template.\n• Scroll down the page to see the different options you can choose.\n• You can change the name of your Cluster under Cluster Name. We are keeping it as for this tutorial.\n• Deselect the Preload sample dataset checkbox, as we'll import our own sample data later on\n• Select any provider and region from the Provider and Region sections. Different regions offer different providers.\n• Tags are optional. We will not use them here.\n• Click the Create deployment button (creation of the cluster will take some minutes).\n• This will open the Security Quickstart section.\n• Enter a username and password for your application to use to access the database (above we have created a new login \"cooluser\"). Remember to copy and store the credentials safely as we will need them later on. Click the Create User button. Note: Avoid using special characters in your MongoDB user password as mongoose may not parse the connection string properly.\n• Select Add by current IP address to allow access from your current computer\n• Enter in the IP Address field and then click the Add Entry button. This tells MongoDB that we want to allow access from anywhere. Note: It is a best practice to limit the IP addresses that can connect to your database and other resources. Here we allow a connection from anywhere because we don't know where the request will come from after deployment.\n• This will open the following screen. Click on the Go to Overview button.\n• You will return to the Overview screen. Click on the Database section under the Deployment menu on the left. Click the Browse Collections button.\n• This will open the Collections section. Click the Add My Own Data button.\n• This will open the Create Database screen.\n• Enter the name for the new database as .\n• Enter the name of the collection as .\n• Click the Create button to create the database.\n• You will return to the Collections screen with your database created.\n• Click the Overview tab to return to the cluster overview.\n• From the Cluster0 Overview screen click the Connect button.\n• This will open the Connect to Cluster0 screen.\n• Select the Drivers category, then the Driver Node.js and Version as shown.\n• DO NOT install the driver as suggested.\n• Click the Copy icon to copy the connection string.\n• Paste this in your local text editor.\n• Replace placeholder in the connection string with your user's password.\n• Insert the database name \"local_library\" in the path before the options ( )\n• Save the file containing this string somewhere safe. You have now created the database, and have a URL (with username and password) that can be used to access it. This will look something like:"
    },
    {
        "link": "https://dvmhn07.medium.com/jwt-authentication-in-node-js-a-practical-guide-c8ab1b432a49",
        "document": "Implementing authentication for a web application using Node.js typically involves several steps. “Token-based authentication” is a common approach for securing web applications. It involves generating and validating tokens (usually JSON Web Tokens, JWTs) to authenticate users. Here’s how you can implement token-based authentication in a Node.js web application with an example and coding sample:\n\n1. Choose an Authentication Strategy:\n\n Decide on the type of authentication you want to implement. Common options include username/password, social media login (e.g., using OAuth), or token-based authentication (e.g., JWT).\n\n2. Set Up Your Node.js Project:\n\n Create a new Node.js project or use an existing one. You can initialize a new project using npm or yarn:\n\n3. Install Required Packages:\n\n Depending on your chosen authentication strategy, you may need to install relevant packages. For example, if you’re using JWT, you can install the ‘jsonwebtoken’ package:\n\n4. Create a User Model:\n\n Define a user model to store user data in your database (e.g., MongoDB, PostgreSQL, or MySQL). You can use an ORM like Mongoose (for MongoDB) or Sequelize (for SQL databases). Here’s a simplified example for MongoDB and Mongoose:\n\n5. Create Routes and Controllers:\n\n Set up routes and controllers for user registration, login, and authentication. Here’s a basic example using Express.js:\n\n6. Protect Routes:\n\n Implement middleware to protect routes that require authentication. For example, you can use a middleware function to verify JWT tokens:\n\n7. Use Authentication Middleware:\n\n Apply the authentication middleware to protect specific routes in your application:\n\n8. Start Your Express Application:\n\n Set up your main application file and start the Express server:\n\n9. Run Your Application:\n\n Start your Node.js application using `node app.js`.\n\nThis example demonstrates a basic implementation of authentication in a Node.js web application using Express.js, MongoDB for storing user data, and JWT for token-based authentication. Remember to replace `’your-secret-key’` with a strong, secret key and consider using environment variables for configuration and security. Additionally, in a production environment, you should use HTTPS to secure communication between the client and server."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/nodejs-jwt-expressjs",
        "document": "One common use case is for allowing clients to preserve their session information after logging in. By storing the session information locally and passing it to the server for authentication when making requests, the server can trust that the client is a registered user.\n\nIn this article, you will learn about the applications of JWTs in a server-client relationship using Node.js and vanilla JavaScript.\n\nTo follow along with this article, you will need the following installed on your machine:\n• Node.js installed locally, which you can do by following How to Install Node.js and Create a Local Development Environment.\n\nis an implementation of JSON Web Tokens.\n\nYou can add it to your JavaScript project by running the following command in your terminal:\n\nAnd import it into your files like so:\n\nTo sign a token, you will need to have 3 pieces of information:\n• The piece of data to hash in the token\n\nThe token secret is a long random string used to encrypt and decrypt the data.\n\nTo generate this secret, one option is to use Node.js’s built-in library, like so:\n\nNow, store this secret in your project’s file:\n\nTo bring this token into a Node.js file and to use it, you have to use :\n\nAnd import it into your files like so:\n\nThe piece of data that you hash in your token can be something either a user ID or username or a much more complex object. In either case, it should be an identifier for a specific user.\n\nThe token expire time is a string, such as 1800 seconds (30 minutes), that details how long until the token will be invalid.\n\nHere’s an example of a function for signing tokens:\n\nThis can be sent back from a request to sign in or log in a user:\n\nThis example takes the value from the (request). And provides the token as the (response).\n\nThat concludes how , , and can be used to generate a JWT.\n\nThere are many ways to go about implementing a JWT authentication system in an Express.js application.\n\nOne approach is to utilize the middleware functionality in Express.js.\n\nHow it works is when a request is made to a specific route, you can have the variables sent to an intermediary function before the one specified in the .\n\nThe middleware is a function that takes parameters of .\n• The is the sent request (GET, POST, DELETE, PUT, etc.).\n• The is the response that can be sent back to the user in a multitude of ways ( , , etc.).\n• The is a function that can be called to move the execution past the piece of middleware and into the actual server response.\n\nHere is an example middleware function for authentication:\n\nAn example request using this middleware function would resemble something like this:\n\nAnd an example of a request that would use that piece of middleware would resemble something like this:\n\nThis code will authenticate the token provided by the client. If it is valid, it can proceed to the request. If it is not valid, it can be handled as an error.\n\nWhen the client receives the token, they often want to store it for gathering user information in future requests.\n\nThe most popular manner for storing auth tokens is in an cookie.\n\nHere’s an implementation for storing a cookie using client-side JavaScript code:\n\nThis approach stores the response locally where they can be referenced for future requests to the server.\n\nThat concludes the flow of requesting a token, generating a token, receiving a token, passing a token with new requests, and verifying a token.\n\nIn this article, you were introduced to JWTs and one approach to applying them to a Node.js application. This approach relied upon a combination of , , , and .\n\nFor another approach to using JWTs, there is How To Implement API Authentication with JSON Web Tokens and Passport.\n\nFor more background on JWTs, there is the “Introduction” documentation.\n\nIf you’d like to learn more about Node.js, check out our Node.js topic page for exercises and programming projects."
    },
    {
        "link": "https://quicknode.com/guides/quicknode-products/endpoint-security/how-to-implement-json-web-tokens-jwt-authorization-with-quicknode",
        "document": "Security is a crucial factor when it comes to protecting web resources. One way to protect those resources is by integrating JSON Web Tokens (JWT) in your web applications. JWT is an open standard that defines a compact way for securely transmitting information between parties. In this guide, you will learn about the core concepts behind JWTs and how to enable JWT on your blockchain node with QuickNode. We will demonstrate this process by creating a React app that will fetch a JWT from our backend server (Express.js) and then use it to request and display the blockchain data on our frontend.\n• An Ethereum endpoint powered by QuickNode (create a free account here)\n• (Optional) Basic knowledge of React and Express.js to create the frontend and backend application\n• Create an API using Express.js to serve JWT tokens\n• Build a frontend with React that uses JWT authentication\n\nThe idea behind JSON Web Tokens (JWT), also referred to as JOT is to create a standard and secure way for two parties to communicate. JWTs can be beneficial because they allow for stateless session management (no session cookies) where a backend server does not need to communicate with an authorization server. JWTs can be sent through a URL, POST parameter, or inside an HTTP header. They are also efficient due to their size. A JWT is composed of three components: A Header, Payload, and Signature. Each part is separated by a period (\".\") and is derived from a JSON object, which is then encoded via BASE64 into a text string. All the components put together are represented in the following format:\n\nThe RFC-7519 has more details on how this standard is defined. To understand each component in depth and how to decode a JWT, visit JWT.io.\n\nThese components combined are what make up a JWT. An example of a JWT would look something like this:\n\nWith JWTs, the \"kid\" (key ID) header parameter identifies which key should be used to verify the JWT's signature. This optional case-sensitive string value (e.g., \"0123456789\") will be useful for us as we may have multiple JWTs under one blockchain node endpoint, and it allows the verifier to know which public key to use when multiple keys are available. More information on this parameter can be found here.\n\nUsers can now use the JWT authentication method to protect their blockchain nodes. QuickNode supports JWT stand-alone or integrated with our other security methods, such as authorization tokens, referral whitelisting, and domain masking. However, note that if multiple authentication services are enabled on a blockchain node, each method must pass its security check, or the user request will return an error.\n\nQuickNode supports JWTs created from key pairs using the RS256 or ECDSA256 algorithm, and there are no limits to how many JWTs you can activate on a blockchain node at once (you will just need to ensure you use your appropriate key ID). Now, we’re ready to create our React app!\n\nLet's start with a simple demonstration of JWT authentication using Node.js scripts and cURL. This will help understand the core concepts before building the full React web application.\n\nFirst, create a new directory and initialize it:\n\nCreate a file called generateKeys.js within your project's folder and input the following code (you can use the or version depending on your needs):\n\nRun the script with the following command:\n\nThis will create a keypair based on your configuration (e.g., , , and format) and the following files:\n• private_key.pem: Keep this secure and never share it\n• public_key.pem: You'll add this to your QuickNode dashboard\n\nFirst, create a QuickNode endpoint for Ethereum Mainnet. Then, navigate to your Node's Security tab and click the Disable JWTs toggle to enable the setting, then click the Add JWT button.\n\nEnter a name for your JWT and paste the public key previously generated in your file into the second field, titled \"Public Key.\"\n\nOnce added, the public key's , , and will be displayed in the JSON Web Token section. Important: the value in the field should match the value in your script (i.e., index.js), or you will run into an unauthorized error.\n\nNext, we'll create a JWT based off the keypair we just created.\n\nCreate another file called generateJWT.js and input the following code:\n\nRun the script to get the token:\n\nNow test the token with curl:\n\nIf successful, you'll see the latest block number returned as a hex value. This confirms your JWT setup is working correctly.\n\nThat's it! You just learned how to create a keypair, generate a JWT and verify the JWT works using cURL. In the next section, we'll walk you through a similar process but instead build a React app and backend server using Express.js.\n\nOur app will be created using Express.js for the backend, which will create a REST API that will serve JWT tokens through a specific endpoint. Our React front-end will fetch this JWT and then use it to make a request to our blockchain node. The following steps will show you how to create the required files in your terminal window but feel free to use a code editor such as VScode.\n\nOpen a terminal window in the directory you'd like to create the project in and run the following command:\n\nOnce our React app is initialized, let's install the required dependencies for this JWT implementation:\n\nThen we'll create the required files, one for our backend server in Express.js, and another for our key pair generation.\n\nWe'll also need to configure the package.json file to include a proxy field. The proxy field will allow for a gateway between our React app and our backend server running on Express.js. Include the following field in your package.json file:\n\nNext, in your terminal window, run the command nano generateKeys.js to open the file (or use a code editor like VSCode). Then include one of the following code snippets below (e.g., the RSA256 JavaScript or ES256 JavaScript example):\n\nSave the file by pressing CTRL + X, then click Enter on your keyboard. Once the file is saved, we’ll run the command node generateKeys.js to create a key pair (public_key.pem and private_key.pem) and store it in the same directory. Note that this file should only be ran once, or you will generate new key pairs each time the file is executed.\n\nThe next step is to create our server code. Run the command nano index.js and input the following code:\n\nRemember to save the file! Now, we are off to creating our frontend code.\n\nOpen the App.js file located within the directory and input the code below. Also, remember to replace the string - \"YOUR_QUICKNODE_HTTP ENDPOINT\" with your actual QuickNode Endpoint. If you don't have an endpoint already, you can sign up for a free QuickNode account here and easily set up an endpoint!\n\nWe're almost done! Before we can start our app, we’ll need to add our public key pair to our blockchain node. Let’s set up JWT authentication on QuickNode next.\n\nFirst, create a QuickNode endpoint for Ethereum Mainnet. Then, navigate to your Node's Security tab and click the Disable JWTs toggle to enable the setting, then click the Add JWT button.\n\nEnter a name for your JWT and paste the public key previously generated in your file into the second field, titled \"Public Key.\"\n\nOnce added, the public key's , , and will be displayed in the JSON Web Token section. Important: the value in the field should match the value in your script (i.e., index.js), or you will run into an unauthorized error.\n\nBefore starting the Express API and React app, let's summarize how they will work together.\n• The Express.js API will serve our endpoint, which, once invoked, will read the local private key, create and sign a JWT payload, then return the signed JWT.\n• The React app will call the endpoint and fetch the signed JWT (i.e., bearer token)\n• The React app then makes a call to the QuickNode endpoint to fetch the latest block number using the RPC method and includes the signed JWT in the header\n• The React app returns the latest block number if the call is successful and JWT is authorized\n\nNow, we'll need to open two terminal windows so we can run the backend server and React app simultaneously.\n\nTo start the backend server, run the command node index.js in one of your terminal windows. If the server is running, you should see the following output: \"Server listening on 3001\"\n\nThen, in the other terminal window, run the command npm start to start the React app. A browser window should automatically open to the port the app is running on, and you should see a result similar to the one below:\n\nIf you want to dive deeper, check out this awesome GitHub repository that shows you how to implement Cloudflare workers with JWT authorization on QuickNode.\n\nBelow are some answers to common questions a user might have when using JWT on QuickNode. If you have any further questions regarding this feature or any others, please don't hesitate to reach out to us!\n\nQ: Which chains are JWT supported on?\n\n A: JWT is supported on all chains\n\nQ: How do I discard a JWT before it expires?\n\n A: If your JWT might have been exposed and you want to prevent it from being used, you can remove the public key from the Node's security tab.\n\nQ: Can I add multiple JWTs to a blockchain node?\n\n A: There are no limits to how many JWTs you can activate on a blockchain node at once. If multiple JWTs are active, ensure you are using the proper ID value in the field, which corresponds to the public/private key you are using when signing the JWT. More information can be found here.\n\nQ: Which cipher does QuickNode support?\n\n A: RSA 256 (RS256) and ECDSA 256 (ES256), as specified in RFC7518 table 3.1, are only supported at this time.\n\nQ: How do I resolve 401 errors?\n\n A: You may have other forms of security methods enabled on your blockchain node. Check to ensure your requests meet all security checks.\n\nQ: What expiration date should I choose? A: You can set any expiration date in the future you'd like. Generally, the shorter the expiration time, the more secure your JWT is.\n\nCongratulations on completing this guide! We've learned about JWTs and how to enable it on your blockchain node with QuickNode. Subscribe to our newsletter for more articles and guides on Ethereum. If you have any feedback, feel free to reach out to us via Twitter. You can always chat with us on our Discord community server, featuring some of the coolest developers you'll ever meet 😃\n\nLet us know if you have any feedback or requests for new topics. We'd love to hear from you."
    },
    {
        "link": "https://stackoverflow.com/questions/65440337/sending-jwt-to-the-client-in-express",
        "document": "First, let me give you an overview of my app, it is fairly simple.\n\nThe basic idea is that a user enters his accountname and password into an html form on the /Login page like:\n\nThis works as expected, it makes a post request to /Login transferring username and password. When the data gets to the server, the server checks if the username and password are valid, if they are a new JSON web token will be created. I use the npm library \"bcrypt\" for the verification of the account and \"jsonwebtoken\" for the creation of the token. This looks like this:\n\nwhere the user is just an object, with an id key and a value whatever the name of the account is. If the username was admin it would look like this:\n\nSo now I want to deliver this token to the client and I do not know exactly how. I have tried:\n\nBut all this does is displaying the JSON on the screen. I have also tried a regular res.send() but it won't deliver the token correctly to the user. I want a webtoken authentication so I can use protected routes in my project. If I want to visit a protected route, I get an error, that there is no authentication header, which probably means that the browser didn't receive the token correctly. The route protection is just basic middleware:\n\nNext, I tried using Postman, where I made a POST request to /Login and got my token in the body of the response back. I pasted the token manually in a Bearer Authorization header and made a GET request to a protected route, which worked.\n\nSo how can I send the webtoken correctly to the client?"
    },
    {
        "link": "https://mattermost.com/blog/json-web-token-jwt-authentication-in-nodejs-applications",
        "document": "A JSON Web Token, popularly known as JWT, is an open standard that defines a compact way for securely sharing information between two parties: a client and a server.\n\nUnlike the traditional server-side sessions — which save a session id in memory and return it to the client — this standard creates a self-contained and digitally signed token that is verified each time a request is made.\n\nIn this article, you will learn how to add a layer of security to your application by using JWTs to authenticate requests made to your application.\n\nThe header contains metadata about the token type and the type of algorithm it is secured with. The type of token, which is a JWT, and the signing algorithm being used, which can either be a hash-based message authentication code (HMAC), a secure hash algorithm (SHA256), or a Rivest-Shamir-Adleman (RSA) algorithm.\n\nThe payload contains verifiable statements about users, such as their identity and access permissions, known as claims:\n\nThe signature is a string generated from the signing algorithm used to verify that the received JWT has not been tampered with. When working with JWTs, you must check its signature before storing and using them:\n\nThe three parts of the JWT are concatenated, separated by a dot ( ) and encoded in Base64Url to form the JWT:\n\nTo follow this tutorial, you will need to clone this GitHub repository, which contains boilerplate code for a simple user-authentication model.\n\nAfter cloning the repository, run the following command to install all the dependencies:\n\nNote: To follow along with this tutorial, you’ll need to connect your application to a MongoDB database. If you have Docker installed, you can use the docker-compose.yml included with docker compose up. Just be sure to change the left side of the volume path (i.e., ) to be something on your local drive. It will load a local database for you in Docker corresponding to in your .env file.\n\nFirst, open your file and import into it like so:\n\nNext, you need to create a JWT and assign it to a user when they successfully login into your application.\n\nYou can create and sign a JWT using the . () method. This method takes three arguments, a payload, a token secret, and a configuration object.\n\nThe payload can be user data, such as the username or email.\n\nThe token secret is a random string used to encrypt and decrypt data. This string should be as long and as random as possible to make the authorization process harder for malicious users.\n\nTo ensure the string is random and unique, use the inbuilt Node.js crypto module to generate it. To achieve this, open a new terminal and run the command below:\n\nThe command in the code block above allows you to write Node.js in your terminal.\n\nNext, run the following command in your node terminal:\n\nAfter that, copy the generated string and add it to a file like this:\n\nNext, in your route handler, call the ‘s method and pass in the payload (email), the secret, and the expiry. Store the result in a variable like so:\n\nNote: You can only set an expiry if the payload is an object literal.\n\nUsing Express’s middleware functionality, you can create a middleware that protects routes from unauthorized access by checking and authenticating a JWT.\n\nAdd the code block below to your file to create the authentication middleware:\n\nIn the middleware above, you first check for an authorization header. Then, you extract the token from the authorization headers if it exists by turning the authorization header to an array and taking the element at index 1. The authorization headers come in a “Bearer token“ format, i.e., the authorization header would be in this format: “Bearer eyxxx.tyxxxx.zyxxx”, which is why splitting it into an array and taking the element at index 1 gives you the token. Then, you check if the token exists and throw an error if it doesn’t.\n\nFinally, you verify the token’s authenticity using the method. The method takes the extracted token, your JWT secret, and a callback as arguments. Once the token is verified, save the user’s details to the request object to keep track of the user’s activities.\n\nYou can apply this middleware to all routes you want to protect from unauthorized access:\n\nTo test if your protected routes are actually only accessible to authorized users, you can use Postman or any other API client to make requests to the routes. This tutorial will feature the use of Postman. First, add the code block below to your file:\n\nThe route above is protected by the middleware you created earlier, which implies that the route cannot be accessed without an access token. Then bring your application online with the node app.js command.\n\nNext, on Postman, try to access the protected route (https://localhost:3000/test) without logging into your application to retrieve the token. You should get a 401 Unauthorized response, as shown in the image below:\n\nNext, create a new user by making a POST request to with the fake data below or any data of your choice:\n\nNow, log into your application using the details you created the user with. After you log in successfully, you will receive the access token as part of the response, as shown in the image below:\n\nCopy the access token, add it to the authorization header under Bearer Token, and make another request to your protected route (https://localhost/3000/test). If the token is verified, you’ll get a 200 OK response, as shown in the image below:\n\nWhen a user’s access token expires, the user has to be re-authenticated by the application to obtain a new access token. The re-authentication can be skipped using refresh tokens, which are tokens used to generate a new access token.\n\nTo generate a refresh token, you first have to generate a refresh token secret. You can follow the same steps used to generate a JWT secret to generate a refresh token secret:\n\nNext, copy the generated string and add it to your file:\n\nThen, in userRoutes.js, create an in-memory storage like an array for the refresh tokens:\n\nNext, update your route to generate a refresh token along with the JWT access token and save the generated refresh token to the array you created earlier:\n\nYour finished /sign-in route handler should look like this:\n\nNext, create a new route handler for that handles the new access token creation:\n\nIn the code block above, you first extract the refresh token from the body object. Then, check if the refresh token is null and send a status code if it is. After that, check if the refresh token is from your application by seeing if it’s stored in your array.\n\nFinally, check if the refresh token is valid using the verify method. If the token is valid, create a new access token and return it to the user, else you send a status code.\n\nThis tutorial covered how you can add an extra layer of security to your application using JWTs.\n\nAlthough JWTs are not easily exploitable, they can be exploited if the tokens are stored carelessly in local storage, which can be very hard to revoke. Be sure to be careful when working with these tokens.\n\nHappy coding! If you like content like this, browse the Mattermost Library for more tips and tricks on developing software using open source technologies.\n\nThis blog post was created as part of the Mattermost Community Writing Program and is published under the CC BY-NC-SA 4.0 license. To learn more about the Mattermost Community Writing Program, check this out."
    }
]