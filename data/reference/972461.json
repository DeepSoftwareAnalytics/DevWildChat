[
    {
        "link": "https://create-react-app.dev/docs/getting-started",
        "document": "Create React App is an officially supported way to create single-page React applications. It offers a modern build setup with no configuration.\n\nThen open http://localhost:3000/ to see your app.\n\nWhen you’re ready to deploy to production, create a minified bundle with .\n\nYou don’t need to install or configure tools like webpack or Babel. They are preconfigured and hidden so that you can focus on the code.\n\nCreate a project, and you’re good to go.\n\nYou’ll need to have Node >= 14 on your local development machine (but it’s not required on the server). You can use nvm (macOS/Linux) or nvm-windows to switch Node versions between different projects.\n\nTo create a new app, you may choose one of the following methods:\n\nis available in npm 6+\n\nis available in Yarn 0.25+\n\nYou can now optionally start a new app from a template by appending to the creation command.\n\nIf you don't select a template, we'll create your project with our base template.\n\nTemplates are always named in the format , however you only need to provide the to the creation command.\n\nOur Custom Templates documentation describes how you can build your own template.\n\nYou can start a new TypeScript app using templates. To use our provided TypeScript template, append to the creation command.\n\nIf you already have a project and would like to add TypeScript, see our Adding TypeScript documentation.\n\nWhen you create a new app, the CLI will use npm or Yarn to install dependencies, depending on which tool you use to run . For example:\n\nRunning any of these commands will create a directory called inside the current folder. Inside that directory, it will generate the initial project structure and install the transitive dependencies:\n\nNo configuration or complicated folder structures, only the files you need to build your app. Once the installation is done, you can open your project folder:\n\nInside the newly created project, you can run some built-in commands:\n\nRuns the app in development mode. Open http://localhost:3000 to view it in the browser.\n\nThe page will automatically reload if you make changes to the code. You will see the build errors and lint warnings in the console.\n\nRuns the test watcher in an interactive mode. By default, runs tests related to files changed since the last commit.\n\nBuilds the app for production to the folder. It correctly bundles React in production mode and optimizes the build for the best performance.\n\nThe build is minified and the filenames include the hashes.\n\nYour app is ready to be deployed."
    },
    {
        "link": "https://react.dev/learn/creating-a-react-app",
        "document": "If your app has constraints not well-served by existing frameworks, you prefer to build your own framework, or you just want to learn the basics of a React app, you can build a React app from scratch.\n\nThese recommended frameworks support all the features you need to deploy and scale your app in production. They have integrated the latest React features and take advantage of React’s architecture.\n\nAll the frameworks on this page support client-side rendering (CSR), single-page apps (SPA), and static-site generation (SSG). These apps can be deployed to a CDN or static hosting service without a server. Additionally, these frameworks allow you to add server-side rendering on a per-route basis, when it makes sense for your use case. This allows you to start with a client-only app, and if your needs change later, you can opt-in to using server features on individual routes without rewriting your app. See your framework’s documentation for configuring the rendering strategy.\n\nNext.js’s App Router is a React framework that takes full advantage of React’s architecture to enable full-stack React apps.\n\nNext.js is maintained by Vercel. You can deploy a Next.js app to any Node.js or serverless hosting, or to your own server. Next.js also supports static export which doesn’t require a server. Vercel additionally provides opt-in paid cloud services.\n\nReact Router is the most popular routing library for React and can be paired with Vite to create a full-stack React framework. It emphasizes standard Web APIs and has several ready to deploy templates for various JavaScript runtimes and platforms.\n\nExpo is a React framework that lets you create universal Android, iOS, and web apps with truly native UIs. It provides an SDK for React Native that makes the native parts easier to use. To create a new Expo project, run:\n\nIf you’re new to Expo, check out the Expo tutorial.\n\nExpo is maintained by Expo (the company). Building apps with Expo is free, and you can submit them to the Google and Apple app stores without restrictions. Expo additionally provides opt-in paid cloud services.\n\nThere are other up-and-coming frameworks that are working towards our full stack React vision:\n• TanStack Start (Beta): TanStack Start is a full-stack React framework powered by TanStack Router. It provides a full-document SSR, streaming, server functions, bundling, and more using tools like Nitro and Vite.\n• RedwoodJS: Redwood is a full stack React framework with lots of pre-installed packages and configuration that makes it easy to build full-stack web applications.\n\nWhich features make up the React team’s full-stack architecture vision? Next.js’s App Router bundler fully implements the official React Server Components specification. This lets you mix build-time, server-only, and interactive components in a single React tree. For example, you can write a server-only React component as an function that reads from a database or from a file. Then you can pass data down from it to your interactive components: Next.js’s App Router also integrates data fetching with Suspense. This lets you specify a loading state (like a skeleton placeholder) for different parts of your user interface directly in your React tree: Server Components and Suspense are React features rather than Next.js features. However, adopting them at the framework level requires buy-in and non-trivial implementation work. At the moment, the Next.js App Router is the most complete implementation. The React team is working with bundler developers to make these features easier to implement in the next generation of frameworks.\n\nIf your app has constraints not well-served by existing frameworks, you prefer to build your own framework, or you just want to learn the basics of a React app, there are other options available for starting a React project from scratch.\n\nStarting from scratch gives you more flexibility, but does require that you make choices on which tools to use for routing, data fetching, and other common usage patterns. It’s a lot like building your own framework, instead of using a framework that already exists. The frameworks we recommend have built-in solutions for these problems.\n\nIf you want to build your own solutions, see our guide to build a React app from Scratch for instructions on how to set up a new React project starting with a built tool like Vite, Parcel, or RSbuild.\n\nIf you’re a framework author interested in being included on this page, please let us know."
    },
    {
        "link": "https://create-react-app.dev/docs/deployment",
        "document": "creates a directory with a production build of your app. Set up your favorite HTTP server so that a visitor to your site is served , and requests to static paths like are served with the contents of the file. For more information see the production build section.\n\nFor environments using Node, the easiest way to handle this would be to install serve and let it handle the rest:\n\nThe last command shown above will serve your static site on the port 3000. Like many of serve’s internal settings, the port can be adjusted using the or flags:\n\nRun this command to get a full list of the options available:\n\nYou don’t necessarily need a static server in order to run a Create React App project in production. It also works well when integrated into an existing server side app.\n\nHere’s a programmatic example using Node and Express:\n\nThe choice of your server software isn’t important either. Since Create React App is completely platform-agnostic, there’s no need to explicitly use Node.\n\nThe folder with static assets is the only output produced by Create React App.\n\nHowever this is not quite enough if you use client-side routing. Read the next section if you want to support URLs like in your single-page app.\n\nIf you use routers that use the HTML5 history API under the hood (for example, React Router with ), many static file servers will fail. For example, if you used React Router with a route for , the development server will respond to properly, but an Express serving a production build as above will not.\n\nThis is because when there is a fresh page load for a , the server looks for the file and does not find it. The server needs to be configured to respond to a request to by serving . For example, we can amend our Express example above to serve for any unknown paths:\n\nIf you’re using Apache HTTP Server, you need to create a file in the folder that looks like this:\n\nIt will get copied to the folder when you run .\n\nIf you’re using Apache Tomcat, you need to follow this Stack Overflow answer.\n\nNow requests to will be handled correctly both in development and in production.\n\nOn a production build, and when you've opted-in, a service worker will automatically handle all navigation requests, like for , by serving the cached copy of your . This service worker navigation routing can be configured or disabled by ing and then modifying the and options of the configuration.\n\nWhen users install your app to the homescreen of their device the default configuration will make a shortcut to . This may not work for client-side routers which expect the app to be served from . Edit the web app manifest at and change to match the required URL scheme, for example:\n\nBy default, Create React App produces a build assuming your app is hosted at the server root.\n\nTo override this, specify the in your , for example:\n\nThis will let Create React App correctly infer the root path to use in the generated HTML file.\n\nNote: If you are using , you can root s using the prop on any .\n\nIf you are not using the HTML5 history API or not using client-side routing at all, it is unnecessary to specify the URL from which your app will be served. Instead, you can put this in your :\n\nThis will make sure that all the asset paths are relative to . You will then be able to move your app from to or even without having to rebuild it.\n\nYou can create an arbitrary build environment by creating a custom file and loading it using env-cmd.\n\nFor example, to create a build environment for a staging environment:\n• Set environment variables as you would any other file (e.g. )\n• Add a new script to your , building with your new environment:\n\nNow you can run to build with the staging environment config. You can specify other environments in the same way.\n\nVariables in will be used as fallback because will always be set to for a build.\n\nThe AWS Amplify Console provides continuous deployment and hosting for modern web apps (single page apps and static site generators) with serverless backends. The Amplify Console offers globally available CDNs, custom domain setup, feature branch deployments, and password protection.\n• Login to the Amplify Console here.\n• Connect your Create React App repo and pick a branch. If you're looking for a Create React App+Amplify starter, try the create-react-app-auth-amplify starter that demonstrates setting up auth in 10 minutes with Create React App.\n• The Amplify Console automatically detects the build settings. Choose Next.\n\nIf the build succeeds, the app is deployed and hosted on a global CDN with an amplifyapp.com domain. You can now continuously deploy changes to your frontend or backend. Continuous deployment allows developers to deploy updates to their frontend and backend on every code commit to their Git repository.\n\nAzure Static Web Apps creates an automated build and deploy pipeline for your React app powered by GitHub Actions. Applications are geo-distributed by default with multiple points of presence. PR's are built automatically for staging environment previews.\n• Add in the details and connect to your GitHub repo.\n• Make sure the build folder is set correctly on the \"build\" tab and create the resource.\n\nAzure Static Web Apps will automatically configure a GitHub Action in your repo and begin the deployment.\n\nSee the Azure Static Web Apps documentation for more information on routing, APIs, authentication and authorization, custom domains and more.\n\nInstall the Firebase CLI if you haven’t already by running . Sign up for a Firebase account and create a new project. Run and login with your previous created Firebase account.\n\nThen run the command from your project’s root. You need to choose the Hosting: Configure and deploy Firebase Hosting sites and choose the Firebase project you created in the previous step. You will need to agree with being created, choose as the public directory, and also agree to Configure as a single-page app by replying with .\n\nIMPORTANT: you need to set proper HTTP caching headers for file in file or you will not be able to see changes after first deployment (issue #2440). It should be added inside key like next:\n\nNow, after you create a production build with , you can deploy it by running .\n\nFor more information see Firebase Hosting.\n\nThe step below is important!\n\n\n\nIf you skip it, your app will not deploy correctly.\n\nOpen your and add a field for your project:\n\nCreate React App uses the field to determine the root URL in the built HTML file.\n\nNow, whenever you run , you will see a cheat sheet with instructions on how to deploy to GitHub Pages.\n\nTo publish it at https://myusername.github.io/my-app, run:\n\nAlternatively you may use :\n\nAdd the following scripts in your :\n\nThe script will run automatically before is run.\n\nIf you are deploying to a GitHub user page instead of a project page you'll need to make one additional modification:\n• Tweak your scripts to push deployments to main:\n\nFinally, make sure GitHub Pages option in your GitHub project settings is set to use the branch:\n\nYou can configure a custom domain with GitHub Pages by adding a file to the folder.\n\nYour CNAME file should look like this:\n\nGitHub Pages doesn’t support routers that use the HTML5 history API under the hood (for example, React Router using ). This is because when there is a fresh page load for a url like , where is a frontend route, the GitHub Pages server returns 404 because it knows nothing of . If you want to add a router to a project hosted on GitHub Pages, here are a couple of solutions:\n• You could switch from using HTML5 history API to routing with hashes. If you use React Router, you can switch to for this effect, but the URL will be longer and more verbose (for example, ). Read more about different history implementations in React Router.\n• Alternatively, you can use a trick to teach GitHub Pages to handle 404s by redirecting to your page with a custom redirect parameter. You would need to add a file with the redirection code to the folder before deploying your project, and you’ll need to add code handling the redirect parameter to . You can find a detailed explanation of this technique in this guide.\n\nIf, when deploying, you get /dev/tty: No such a device or address or a similar error, try the following:\n\nIf, when deploying, you get , try the following:\n\nUse the Heroku Buildpack for Create React App.\n\nYou can find instructions in Deploying React with Zero Configuration.\n\nSometimes works locally but fails during deploy via Heroku. Following are the most common cases.\n\nIf you get something like this:\n\nIt means you need to ensure that the lettercase of the file or directory you matches the one you see on your filesystem or on GitHub.\n\nThis is important because Linux (the operating system used by Heroku) is case sensitive. So and are two distinct directories and thus, even though the project builds locally, the difference in case breaks the statements on Heroku remotes.\n\nIf you exclude or ignore necessary files from the package you will see a error similar this one:\n\nIn this case, ensure that the file is there with the proper lettercase and that’s not ignored on your local or .\n\nTo do a manual deploy to Netlify’s CDN:\n\nChoose as the path to deploy.\n\nWith this setup Netlify will build and deploy when you push to git or open a pull request:\n• Pick your Git hosting service and select your repository\n\nTo support , make sure to create a file with the following rewrite rules:\n\nWhen you build the project, Create React App will place the folder contents into the build output.\n\nVercel is a cloud platform that enables developers to host Jamstack websites and web services that deploy instantly, scale automatically, and requires no supervision, all with zero configuration. They provide a global edge network, SSL encryption, asset compression, cache invalidation, and more.\n\nTo deploy your React project with a Vercel for Git Integration, make sure it has been pushed to a Git repository.\n\nImport the project into Vercel using the Import Flow. During the import, you will find all relevant options preconfigured for you with the ability to change as needed.\n\nAfter your project has been imported, all subsequent pushes to branches will generate Preview Deployments, and all changes made to the Production Branch (commonly \"master\" or \"main\") will result in a Production Deployment.\n\nOnce deployed, you will get a URL to see your app live, such as the following: https://create-react-app-example.vercel.app/.\n\nIf you want to use a Custom Domain with your Vercel deployment, you can Add or Transfer in your domain via your Vercel account Domain settings.\n\nTo add your domain to your project, navigate to your Project from the Vercel Dashboard. Once you have selected your project, click on the \"Settings\" tab, then select the Domains menu item. From your projects Domain page, enter the domain you wish to add to your project.\n\nOnce the domain has been added, you will be presented with different methods for configuring it.\n\nYou can deploy a fresh React project, with a Git repository set up for you, with the following Deploy Button:\n\nRender offers free static site hosting with fully managed SSL, a global CDN and continuous auto deploys from GitHub.\n\nDeploy your app in only a few minutes by following the Create React App deployment guide.\n\nUse invite code to sign up or use this link.\n\nSee this blog post on how to deploy your React app to Amazon Web Services S3 and CloudFront. If you are looking to add a custom domain, HTTPS and continuous deployment see this blog post.\n\nInstall the Surge CLI if you haven’t already by running . Run the command and log in you or create a new account.\n\nWhen asked about the project path, make sure to specify the folder, for example:\n\nNote that in order to support routers that use HTML5 API, you may want to rename the in your build folder to before deploying to Surge. This ensures that every URL falls back to that file.\n\nCreate React App doesn't provide any built-in functionality to publish a component to npm. If you're ready to extract a component from your project so other people can use it, we recommend moving it to a separate directory outside of your project and then using a tool like nwb to prepare it for publishing."
    },
    {
        "link": "https://react.dev/learn",
        "document": "Welcome to the React documentation! This page will give you an introduction to 80% of the React concepts that you will use on a daily basis.\n• How to create and nest components\n• How to add markup and styles\n• How to render conditions and lists\n• How to respond to events and update the screen\n• How to share data between components React apps are made out of components. A component is a piece of the UI (user interface) that has its own logic and appearance. A component can be as small as a button, or as large as an entire page. Now that you’ve declared , you can nest it into another component: Welcome to my app\n\n Notice that starts with a capital letter. That’s how you know it’s a React component. React component names must always start with a capital letter, while HTML tags must be lowercase. Have a look at the result:\n\nThe keywords specify the main component in the file. If you’re not familiar with some piece of JavaScript syntax, MDN and javascript.info have great references. The markup syntax you’ve seen above is called JSX. It is optional, but most React projects use JSX for its convenience. All of the tools we recommend for local development support JSX out of the box. JSX is stricter than HTML. You have to close tags like . Your component also can’t return multiple JSX tags. You have to wrap them into a shared parent, like a or an empty wrapper: Hello there. How do you do?\n\n If you have a lot of HTML to port to JSX, you can use an online converter. In React, you specify a CSS class with . It works the same way as the HTML attribute: Then you write the CSS rules for it in a separate CSS file: React does not prescribe how you add CSS files. In the simplest case, you’ll add a tag to your HTML. If you use a build tool or a framework, consult its documentation to learn how to add a CSS file to your project. JSX lets you put markup into JavaScript. Curly braces let you “escape back” into JavaScript so that you can embed some variable from your code and display it to the user. For example, this will display : You can also “escape into JavaScript” from JSX attributes, but you have to use curly braces instead of quotes. For example, passes the string as the CSS class, but reads the JavaScript variable value, and then passes that value as the attribute: You can put more complex expressions inside the JSX curly braces too, for example, string concatenation:\n\nIn the above example, is not a special syntax, but a regular object inside the JSX curly braces. You can use the attribute when your styles depend on JavaScript variables. In React, there is no special syntax for writing conditions. Instead, you’ll use the same techniques as you use when writing regular JavaScript code. For example, you can use an statement to conditionally include JSX: If you prefer more compact code, you can use the conditional operator. Unlike , it works inside JSX: When you don’t need the branch, you can also use a shorter logical syntax: All of these approaches also work for conditionally specifying attributes. If you’re unfamiliar with some of this JavaScript syntax, you can start by always using . You will rely on JavaScript features like loop and the array function to render lists of components. For example, let’s say you have an array of products: Inside your component, use the function to transform an array of products into an array of items: Notice how has a attribute. For each item in a list, you should pass a string or a number that uniquely identifies that item among its siblings. Usually, a key should be coming from your data, such as a database ID. React uses your keys to know what happened if you later insert, delete, or reorder the items.\n\nYou can respond to events by declaring event handler functions inside your components: Notice how has no parentheses at the end! Do not call the event handler function: you only need to pass it down. React will call your event handler when the user clicks the button. Often, you’ll want your component to “remember” some information and display it. For example, maybe you want to count the number of times a button is clicked. To do this, add state to your component. Now you can declare a state variable inside your component: You’ll get two things from : the current state ( ), and the function that lets you update it ( ). You can give them any names, but the convention is to write . The first time the button is displayed, will be because you passed to . When you want to change state, call and pass the new value to it. Clicking this button will increment the counter: React will call your component function again. This time, will be . Then it will be . And so on. If you render the same component multiple times, each will get its own state. Click each button separately:\n\nNotice how each button “remembers” its own state and doesn’t affect other buttons. Functions starting with are called Hooks. is a built-in Hook provided by React. You can find other built-in Hooks in the API reference. You can also write your own Hooks by combining the existing ones. Hooks are more restrictive than other functions. You can only call Hooks at the top of your components (or other Hooks). If you want to use in a condition or a loop, extract a new component and put it there. In the previous example, each had its own independent , and when each button was clicked, only the for the button clicked changed: The first updates its to However, often you’ll need components to share data and always update together. To make both components display the same and update together, you need to move the state from the individual buttons “upwards” to the closest component containing all of them. In this example, it is : Initially, ’s state is and is passed down to both children On click, updates its state to and passes it down to both children Now when you click either button, the in will change, which will change both of the counts in . Here’s how you can express this in code. First, move the state up from into : Then, pass the state down from to each , together with the shared click handler. You can pass information to using the JSX curly braces, just like you previously did with built-in tags like : The information you pass down like this is called props. Now the component contains the state and the event handler, and passes both of them down as props to each of the buttons. Finally, change to read the props you have passed from its parent component: When you click the button, the handler fires. Each button’s prop was set to the function inside , so the code inside of it runs. That code calls , incrementing the state variable. The new value is passed as a prop to each button, so they all show the new value. This is called “lifting state up”. By moving state up, you’ve shared it between components."
    },
    {
        "link": "https://reddit.com/r/react/comments/1al1zab/react_project_setup_best_practices_and_standards",
        "document": "I am a software developer with 2yrs experience and till now I haven't created the project from scratch now my current employer wants me to start a project from scratch and also keen towards following best practices and standards followed by big tech companies.\n\nCan you guys please help me with the project setup standards for react js which is followed by the big companies and how on the way it is updated and maintained, like if something new introduced to project how it is being handled?\n\nLike what necessary package needs to be installed which other frameworks need to check, etc."
    },
    {
        "link": "https://v2.tailwindcss.com/docs/optimizing-for-production",
        "document": "This basically matches any string separated by spaces, quotes or angle brackets, including HTML tags, attributes, classes, and even the actual written content in your markup.\n\nPurgeCSS (the library we use under the hood) is intentionally very naive in the way it looks for classes in your HTML. It doesn’t try to parse your HTML and look for class attributes or dynamically execute your JavaScript — it simply looks for any strings in the entire file that match this regular expression:\n\nBefore getting started with the purge feature, it’s important to understand how it works and build the correct mental model to make sure you never accidentally remove important styles when building for production.\n\nWhen building for production, you should always use Tailwind’s purge option to tree-shake unused styles and optimize your final build size. When removing unused styles with Tailwind, it’s very hard to end up with more than 10kb of compressed CSS.\n\nFor example, Tailwind generates margin utilities for every size in your spacing scale, for every side of an element you might want to apply margin to, at every breakpoint you are using in your project. This leads to hundreds of different combinations that are all important to have available, but not all likely to be needed.\n\nThink of Tailwind like a giant box of LEGO — you dump it all out on the floor and build what you want to build, then when you’re done you put all the pieces you didn’t use back into the box.\n\nTo make the development experience as productive as possible, Tailwind generates thousands of utility classes for you, most of which you probably won’t actually use.\n\nThis might sound enormous but the development build is large by design .\n\nUsing the default configuration, the development build of Tailwind CSS is 3645.2kB uncompressed, 294.2kB minified and compressed with Gzip , and 72.8kB when compressed with Brotli .\n\nGetting a new business off the ground is a lot of hard work. Here are five ideas you can use to find your first customers.\n\nThat means that it is important to avoid dynamically creating class strings in your templates with string concatenation , otherwise PurgeCSS won’t know to preserve those classes.\n\nAs long as a class name appears in your template in its entirety, PurgeCSS will not remove it.\n\nTo get started, provide an array of paths to all of your template files using the option:\n\nThis list should include any files in your project that reference any of your styles by name. For example, if you have a JS file in your project that dynamically toggles some classes in your HTML, you should make sure to include that file in this list.\n\nWhen using with the selector strategy, be sure that the template file that includes your root selector is included in your purge configuration, otherwise all of your CSS will be removed when building for production.\n\nNow whenever you compile your CSS with set to , Tailwind will automatically purge unused styles from your CSS.\n\nIf you want to manually control whether unused styles should be removed (instead of depending implicitly on the environment variable), you can use an object syntax and provide the option, specifying your templates using the option:\n\nWe recommend only removing unused styles in production, as removing them in development means you need to recompile any time you change your templates and compiling with PurgeCSS enabled is much slower.\n\nIf you need to safelist specific classes to make sure they are never accidentally removed from your CSS (perhaps because they are used in content that comes from a database or similar), you can use our purge option:\n\nSometimes you are authoring content in a format that compiles to HTML, and it would be better to compile that content to HTML before looking for potential classes. A great example of this is working with markdown files.\n\nYou can use the option to tell Tailwind to transform any file matching a specific extension before it looks for classes to guarantee the most accurate results:\n\nIf you need to override the logic Tailwind uses to detect classes in the content of a specific file type, you can use the option to provide a function that will be used to detect potential classes in matching files:\n\nThis is an advanced feature and most users won’t need it. The default extraction logic in Tailwind works extremely well for almost all projects.\n\nBy default, Tailwind will preserve all basic HTML element styles in your CSS, like styles for the , , , , etc. tags. This is to minimize accidentally over-purging in cases where you are using markdown source files for example (where there is no actual tag present), or using a framework that hides the document shell (containing the and tags) somewhere in a vendor directory (like Next.js does).\n\nIf you want to disable this behavior, you can set to false:\n\nWe generally do not recommend this and believe that the risks outweigh the benefits, but we’re not the cops, do whatever you want.\n\nBy default, Tailwind will purge all styles in the , , and layers. If you’d like to change this, use the option to manually specify the layers you’d like to purge:\n\nBy default, Tailwind will only remove unused classes that it generates itself, or has been explicitly wrapped in a directive. It will not remove unused styles from third-party CSS you pull in to your project, like a datepicker library you pull in for example.\n\nThis is to avoid accidentally removing styles that you might need but are not directly referenced in your templates, like classes that are only referenced deep in your folder that are part of some other dependency.\n\nIf you really want to remove all unused styles, set and and be very careful to provide the paths to all files that might reference any classes or HTML elements:\n\nWe do not recommend this, and generally find you get 99% of the file size benefits by sticking with the more conservative default approach.\n\nPurgeCSS does not remove unused rules by default, so you may notice some animation related styles left over in your stylesheet even if you aren’t using them. You can remove these using PurgeCSS’s option under :\n\nIf you need to pass any other options directly to PurgeCSS, you can do so using :\n\nA list of available options can be found in the PurgeCSS documentation.\n\nIf you can’t use PurgeCSS for one reason or another, you can also reduce Tailwind’s footprint by removing unused values from your configuration file.\n\nThe default theme provides a very generous set of colors, breakpoints, sizes, margins, etc. to make sure that when you pull Tailwind down to prototype something, create a CodePen demo, or just try out the workflow, the experience is as enjoyable and fluid as possible.\n\nWe don’t want you to have to go and write new CSS because we didn’t provide enough padding helpers out of the box, or because you wanted to use an orange color scheme for your demo and we only gave you blue.\n\nThis comes with a trade-off though: the default build is significantly heavier than it would be on a project with a purpose-built configuration file.\n\nHere are a few strategies you can use to keep your generated CSS small and performant.\n\nThe default theme includes a whopping 84 colors used for backgrounds, borders, text, and placeholders, all of which also have and variants, as well as responsive variants at the six default screen sizes.\n\nBy default, there are thousands of classes generated to accommodate these colors, and it makes up close to half of the final build size.\n\nVery few projects actually need this many colors, and removing colors you don’t need can have a huge impact on the overall file size.\n\nHere’s how using a smaller color palette affects the final size:\n\nSince almost every Tailwind utility is copied for every screen size, using fewer screen sizes can have a huge impact on the overall file size as well.\n\nIf you only need 3 screen sizes and 35 colors, you're down to 46.8kB compressed without changing anything else.\n\nIf you don’t expect to need a certain utility plugin in your project at all, you can disable it completely by setting it to in the section of your config file:\n\nIf you only need a handful of utilities, you can pass an array to with the utility plugins you want to keep.\n\nThe above would disable all utilities except margin and padding.\n\nIf you need a utility but don’t need the responsive versions, set its variants to an empty array to generate 83% fewer classes:\n\nThese are mostly small wins compared to limiting your color palette or using fewer breakpoints, but they can still add up."
    },
    {
        "link": "https://tailwindcss.com/docs/optimizing-for-production",
        "document": "Getting the most performance out of Tailwind CSS projects.\n\nTailwind CSS is incredibly performance focused and aims to produce the smallest CSS file possible by only generating the CSS you are actually using in your project.\n\nCombined with minification and network compression, this usually leads to CSS files that are less than 10kB, even for large projects. For example, Netflix uses Tailwind for Netflix Top 10 and the entire website delivers only 6.5kB of CSS over the network.\n\nWith CSS files this small, you don’t have to worry about complex solutions like code-splitting your CSS for each page, and can instead just ship a single small CSS file that’s downloaded once and cached until you redeploy your site.\n\nFor the smallest possible production build, we recommend minifying your CSS with a tool like cssnano, and compressing your CSS with Brotli.\n\nIf you’re using Tailwind CLI, you can minify your CSS by adding the flag:\n\nIf you’ve installed Tailwind as a PostCSS plugin, add to the end of your plugin list:\n\nIf you’re using a framework, check the documentation as this is often handled for you in production automatically and you don’t even need to configure it."
    },
    {
        "link": "https://stackoverflow.com/questions/65677201/tailwind-css-styles-getting-removed-in-production",
        "document": "My has the following scripts:\n\nI have the following CSS in (I am only using one CSS file):\n\nRunning the dev script works fine, and the generated code has all of my styles.\n\nRunning the build script runs without errors, however, it removes part of my styles, which I find mind-boggling. My styles are applied, but my styles are not.\n\nI figured this was due to the property getting cleaned by , but removing the cleancss part of the build script it still has the same problem. Removing solves the problem, but obviously I'd like to minify the file for production.\n\nIf your CSS file has the Tailwind references then it'll be running purge css as part of the build process. If that's happening you can avoid that by reordering the file as explained here\n\nAnd linked me here:\n\nHowever my tailwind.config.js should be fine:\n\nand here's my for posterity:"
    },
    {
        "link": "https://tailwindcss.com/docs/just-in-time-mode",
        "document": "This feature is currently in preview. Preview features are not covered by semantic versioning and some details may change as we continue to refine them.\n\nNote that you still need to write purgeable HTML when using arbitrary values, and your classes need to exist as complete strings for Tailwind to detect them correctly.\n\nWe’ll likely add some form of “strict mode” in the future for power-hungry team leads who don’t trust their colleagues to use this feature responsibly.\n\nThis is very useful for building pixel-perfect designs where there are a few elements that need hyper-specific styles, like a carefully positioned background image on a marketing site.\n\nMany utilities support arbitrary values using a new square bracket notation to indicate that you’re “breaking out” of your design system.\n\nAll variants can be combined together to easily target very specific situations without writing custom CSS.\n\nYou can use variants like focus-visible , active , disabled , even , and more in combination with any utility, without making any changes to your tailwind.config.js file.\n\nSince styles are generated on-demand, there’s no need to configure which variants are available for each core plugin.\n\nHaving issues? See the troubleshooting section to learn how to fix common problems.\n\nNow when you start your development server or build runner, Tailwind will generate your styles on-demand instead of generating everything in advance.\n\nSince JIT mode generates your CSS on-demand by scanning your template files, it’s crucial that you configure the purge option in your tailwind.config.js file with all of your template paths, otherwise your CSS will be empty:\n\nTo enable just-in-time mode, set the mode option to 'jit' in your tailwind.config.js file:\n\nTo see it in action, watch our announcement video .\n\nTailwind CSS v2.1 introduces a new just-in-time compiler for Tailwind CSS that generates your styles on-demand as you author your templates instead of generating everything in advance at initial build time.\n\nTailwind doesn’t include any sort of client-side runtime, so class names need to be statically extractable at build-time, and can’t depend on any sort of arbitrary dynamic values that change on the client. Use inline styles for these situations, or combine Tailwind with a CSS-in-JS library like Emotion if it makes sense for your project.\n\nArbitrary values cannot be computed from dynamic values\n\nUse inline styles for truly dynamic or user-defined values\n\nIt’s also important to note that CSS classes cannot contain spaces, which means you can’t use arbitrary values like calc(100px - 4rem) or 1fr 700px 2fr as-is. To use arbitrary values like this in your class names, you need to remove the spaces in things like calc calls, and replace the spaces with commas in lists like 1fr 700px 2fr . Tailwind will automatically re-introduce the spaces for you in calc calls and replace the commas with spaces in lists when generating the corresponding CSS.\n\nRemove spaces or replace with commas as appropriate\n\nIf you are using a CSS variable as an arbitrary value, it can sometimes lead to class names that are ambiguous to the engine, for example:\n\nIn these situations, you can provide a hint to the engine by prefixing the arbitrary value with the type name:\n\nYou can make any utility important by adding a character to the beginning:\n\nThe always goes at the beginning of the utility name, after any variants, but before any prefix:\n\nThis can be useful in rare situations where you need to increase specificity because you’re at war with some styles you don’t control.\n\nInstead of needing to use utilities like , , or , the JIT engine lets you just tack the opacity right on to the end of the color:\n\nThis means you can now change the opacity of colors anywhere in Tailwind, even where we previously didn’t have specific opacity utilities, like in gradients for example:\n\nThe opacity values are taken from your scale, but you can also use arbitrary opacity values using square bracket notation:\n\nRequested since like 2017 but left out due to file-size considerations, the JIT engine finally adds support for setting the border color for each side of an element independently:\n\nThe JIT engine adds support for styling pseudo-elements like , , , , , and .\n\nWhen you add any or variant, the property is automatically set to to make sure the element is actually visible. To change the content property, use the new content utilities.\n\nAs mentioned, we’ve also added support for other pseudo-elements like , which allows you to style selected text:\n\nOr the pseudo-element, which allows you to style list markers:\n\nWe’ve added new utilities for setting the property — super useful alongside the new and variants:\n\nThey even support stuff like the function, so you can reference a value stored in an attribute:\n\nOn top of the existing stuff like , , and others, we’ve added support for every pseudo-class we thought made any sense at all, like , , , and tons more.\n\nHere’s the complete list of new pseudo-class variants:\n\nYou can now set the color of the cursor in form fields using the new utilities:\n\nThese are customizable using the key in the section of your file.\n\nSimilar to the variants we’ve supported for years for styling an element based on the parent state, you can use the new variants to style an element based on the state of one of its previous siblings:\n\nSimply mark the previous sibling you’re interested in with the class, then use variants like , , , etc. to style your element based on the state of that sibling.\n\nThe , , and classes are no longer necessary to “enable” their respective set of composable utilities.\n\nNow those features are automatically enabled any time you use any of the relevant sub-utilities.\n\nWe see the JIT engine as a preview of what we plan to ship as Tailwind CSS v3.0, so there are a few small breaking changes to consider when opting in. We really don’t expect these to impact very many people but worth reading, especially if you notice any subtle differences in how your projects look.\n\nIn the classic engine, utility variants are grouped together in the generated CSS per utility like this:\n\nIn the JIT engine, variants are grouped together per variant:\n\nThis means that it’s not possible to specify the variant order per core plugin anymore — the variants will always be in the same order for all utilities. This could be a problem for you if previously you needed to defeat for a specific utility for example and had ensured came after in the variant list.\n\nTo handle these situations with the JIT engine, we recommend using stacked variants instead:\n\nStacked variants let you specify how something should be styled when multiple variants are active at the same time, so instead of trying to override styles with styles, you explicitly declare what an element should look like when both and are active simultaneously.\n\nIn the classic engine, all utility variants are injected as part of the directive.\n\nIn the JIT engine, variants are injected at the directive, which has been renamed from .\n\nThis directive is optional (just like always has been) and is only useful if you want explicit control over where utility variants are injected. By default, they are always injected at the very end of your stylesheet.\n\nIf you were using before, you should update your code to use :\n\nThe feature is considered an advanced escape hatch and we recommend omitting it by default. You should only use it if your project won’t work properly without it, which is only ever really true if you are introducing Tailwind to a legacy system with a very fragile existing CSS codebase that has styles that absolutely need to be at the very end of the stylesheet for things to work.\n\nTransforms and filters don't need to be explicitly enabled\n\nThe , , and classes aren’t necessary for “enabling” those features when using the JIT engine:\n\nThis means you can no longer expect transforms and filters to be dormant by default, and conditionally activated by adding , , or .\n\nInstead, you will want put any variants on the sub-utilities themselves:\n\nThis new engine supports almost every feature that exists in the classic engine, plus tons of new features that wouldn’t be possible if everything had to be pre-generated up front.\n\nDue to the nature of how the engine works however, there are a few things that aren’t currently possible:\n• The option does not support regular expressions. Because no CSS is generated by default, the safelist has to be a list of complete class names. It’s not possible to safelist a regular expression, because there is not a pre-generated list of class names to match against that regular expression.\n• The option cannot detect complete class names when configured as a function. Because we don’t generate class names in advance, we can only pass the utility “namespace” to custom prefix functions. See this comment for an example.\n• You can only classes that are part of core, generated by plugins, or defined within a rule. You can’t currently arbitrary CSS classes that aren’t defined within a rule, although we may add support for this in the future.\n\nWe are also still ironing out some compatibility issues with certain build tools, which you can follow in our issue tracker.\n\nIf you run into any other issues or find any bugs, please open an issue so we can fix it.\n\nWhen the JIT engine is running in watch mode, you might notice that when you add a class to your HTML then remove it, that the class is still present in your CSS.\n\nThis isn’t a bug and is rather a deliberate performance optimization that drastically increases the speed of incremental rebuilds, especially in large projects.\n\nWe recommend you always compile your CSS in a separate one-off build before deploying to production so that you can minify the output. For most modern tools (like Next.js for example), this sort of thing happens automatically because your compiled CSS is never committed to version control anyways.\n\nIf you want Tailwind to rebuild the CSS completely from scratch while in watch mode, saving your file or your CSS input file will invalidate all of the caches and trigger a fresh rebuild.\n\nAs of Tailwind CSS v2.2+, the JIT engine depends on PostCSS’s directory dependency messages to register your content files as CSS build dependencies with your build tool. These are a fairly new addition to PostCSS (added in May 2021), and not all build tools have been updated to support them yet.\n\nIf your CSS isn’t rebuilding when you change your content files, try setting as part of your watch script to tell Tailwind to use a legacy dependency tracking strategy instead, which works well with many build tools.\n\nFor example, if you are using , set in your dev/watch script:\n\nIf you’re using Windows, we recommend cross-env for setting environment variables in your scripts.\n\nNote that setting will start a long-running watch process in the background, so if you set that environment variable when trying to do a one-off build, it will look like the build is hanging.\n\nYou should only set when you are actually running a dev server/watch process, and only if your build tool doesn’t yet support PostCSS directory dependency messages. This flag is a temporary workaround for incompatible tooling, and will eventually be removed in a future version of Tailwind CSS.\n\nIf your CSS seems to be rebuilding in an infinite loop, there’s a good chance it’s because your build tool doesn’t support PostCSS’s option when registering dependencies.\n\nMany build tools (such as webpack) don’t support this option, and as a result we can only tell them to watch specific files or entire directories. We can’t tell webpack to only watch files in a directory for example.\n\nThat means that if building your CSS causes any files in those directories to change, a rebuild will be triggered, even if the changed file doesn’t match the extension in your glob.\n\nSo if you are watching for changes, but you are writing your CSS output file to , you will get an infinite rebuild loop in some tools.\n\nIdeally we could warn you about this in the console, but many tools support it perfectly fine (including our own CLI tool), and we have no reliable way to detect what build tool you are using.\n\nYou have a few options for solving this problem:\n• None Use more specific paths in your config. Make sure you only include directories that won’t change when your CSS builds. If necessary, adjust your actual project directory structure to make sure you can target your template files without accidentally catching your CSS file or other build artifacts like manifest files.\n• None Use a build tool with PostCSS glob support. If you absolutely can’t change your purge config or directory structure, your best bet is to compile your CSS separately with a tool that has complete glob support. We recommend using Tailwind CLI, which is a fast, simple, purpose-built tool for compiling your CSS with Tailwind.\n\nIt just doesn't seem to work properly\n\nIf you are experiencing weird, hard to describe issues with the output, or things just don’t seem like they are working at all, there’s a good chance it’s due to your build tool not supporting PostCSS dependency messages properly (or at all). One known example of this currently is Stencil.\n\nWhen you are having these sorts of issues, we recommend using the Tailwind CLI tool to compile your CSS separately instead of trying to integrate Tailwind into your existing tooling.\n\nYou can use packages like or to compile your CSS alongside your usual development command by adding some scripts to your project like this:\n\nEither way, please be sure to check for an existing issue or open a new one so we can figure out the problem and try to improve compatibility with whatever tool you are using.\n\nTools with known compatibility issues currently include:"
    },
    {
        "link": "https://dev.to/neeldev96/optimize-tailwind-for-a-production-ready-react-project-4fan",
        "document": "I have been working with tailwind for the past one year and it makes styling easier than ever. I am so spoiled by its flexibility that I cannot imagine working on a web application without using it. If you use tailwind for your projects, then you know how simple it is to work with it. You can make a div to look like a button with hover animation, shadow effects and every thing by throwing in just a few selectors.\n\nA CSS file with all the tailwind classes can be generated easily using the command.\n\nThe command will fill all the classes available in tailwind into the target file. This CSS file can be imported to the file of your react project to make it available globally for all the components.\n\nIf you take a look at the result of the command, then you cannot miss but notice that the total size of the index.css file is 3.75MB. This is reasonable considering the fact that tailwind bundles more than 10,000 selectors but the question here is, \"Do you really need all those classes in a production bundle?\".\n\nI have shipped 2 production ready react applications styled with tailwind and it hardly required more than 200 classes in total. Consider you are shipping a react application to production and if you import a complete tailwind CSS file, then it means that you are forcing the users to download 3.75MB of unnecessary data.\n\nThis is where the concept of comes into play. Instead of shipping your app with thousands of unwanted classes thereby increasing the application bundle's size, you can effectively leverage the tailwind purge feature to remove unused classes from the CSS file when bundling the final build of the application.\n\nLet's see how it is done.\n\nFor this demo, I bootstrapped a sample react app with . I have filled the default file created by CRA with tailwind classes using the command.\n\nI have created a new component named and this is going to hold just 3 divs in it, styled with tailwind selectors.\n\nIf you take a look at the above component, it uses only 25 tailwind classes in total. For these 25 classes, we obviously do not need a CSS file which weighs over 3.75MB in size. So let's trim it down to make it production ready.\n\nThe first step is to generate a file. This can be done easily by running from the root of the react project. The generated config file will have a few key-value pairs which can be configured based on project needs.\n\nFor this demo, we are going to concentrate only on the array. For a typical react project, I would recommend filling in the array with the following\n\nThis will look for the matching files within your project and will fill in only the required tailwind selectors into the file (or the target CSS file you choose).\n\nOne important thing to keep in mind is that, tailwind will initiate purging only if the environment is because in reality you will need the whole tailwind bundle during development. So the environment must be overridden to generate the optimized (or purged) CSS file.\n\nSetting the environment variable to will make tailwind to build the CSS file with only the required classes. After running the script, the following is the result I got,\n\nThe CSS file size has reduced significantly all the way from 3.75MB to 12.43KB and when you run after this, CRA will minify the CSS reducing the file size further.\n\n⚠️One important thing to keep in mind is that the module used by tailwind will look for complete strings within the files. So if you have a scenario where the selectors are dynamically filled with partial strings, then those have to be avoided or modified to include the complete selector strings.\n\nThis is not cool...\n\nRead this article from tailwind docs to know more\n\nThat's is all for today... That is how you generate an optimized tailwind CSS for your production build."
    }
]