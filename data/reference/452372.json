[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input",
        "document": "The element is so powerful because of its attributes; the attribute, described with examples above, being the most important. Since every element, regardless of type, is based on the interface, they technically share the exact same set of attributes. However, in reality, most attributes have an effect on only a specific subset of input types. In addition, the way some attributes impact an input depends on the input type, impacting different input types in different ways. This section provides a table listing all the attributes with a brief description. This table is followed by a list describing each attribute in greater detail, along with which input types they are associated with. Those that are common to most or all input types are defined in greater detail below. Attributes that are unique to particular input types—or attributes which are common to all input types but have special behaviors when used on a given input type—are instead documented on those types' pages. Attributes for the element include the global HTML attributes and additionally: alt attribute for the image type. Required for accessibility all except , , and all except , , and buttons Whether the command or control is checked Name of form field to use for sending the element's directionality in form submission Whether the form control is disabled URL to use for form submission Form data set encoding type to use for form submission HTTP method to use for form submission Same as height attribute for ; vertical dimension all except , , , , and buttons Value of the id attribute of the of autocomplete options Boolean. Whether to allow multiple values Name of the form control. Submitted with the form as part of a name/value pair Pattern the must match to be valid Text that appears in the form control when it has no value set Designates an as a control for a popover element Specifies the action that a popover control should perform all except , , , , , and buttons Boolean. The value is not editable all except , , , and buttons Boolean. A value is required or must be checked for the form to be submittable Same as attribute for ; address of image resource The value of the control. When specified in the HTML, corresponds to the initial value Same as attribute for A few additional non-standard attributes are listed following the descriptions of the standard attributes.\n\nLabels are needed to associate assistive text with an . The element provides explanatory information about a form field that is always appropriate (aside from any layout concerns you have). It's never a bad idea to use a to explain what should be entered into an or . The semantic pairing of and elements is useful for assistive technologies such as screen readers. By pairing them using the 's attribute, you bond the label to the input in a way that lets screen readers describe inputs to users more precisely. It does not suffice to have plain text adjacent to the element. Rather, usability and accessibility requires the inclusion of either implicit or explicit : <!-- inaccessible --> <p>Enter your name: <input id=\"name\" type=\"text\" size=\"30\" /></p> <!-- implicit label --> <p> <label>Enter your name: <input id=\"name\" type=\"text\" size=\"30\" /></label> </p> <!-- explicit label --> <p> <label for=\"name\">Enter your name: </label> <input id=\"name\" type=\"text\" size=\"30\" /> </p> The first example is inaccessible: no relationship exists between the prompt and the element. In addition to an accessible name, the label provides a larger 'hit' area for mouse and touch screen users to click on or touch. By pairing a with an , clicking on either one will focus the . If you use plain text to \"label\" your input, this won't happen. Having the prompt part of the activation area for the input is helpful for people with motor control conditions. As web developers, it's important that we never assume that people will know all the things that we know. The diversity of people using the web—and by extension your website—practically guarantees that some of your site's visitors will have some variation in thought processes and/or circumstances that leads them to interpret your forms very differently from you without clear and properly-presented labels. The attribute lets you specify text that appears within the element's content area itself when it is empty. The placeholder should never be required to understand your forms. It is not a label, and should not be used as a substitute, because it isn't. The placeholder is used to provide a hint as to what an inputted value should look like, not an explanation or prompt. Not only is the placeholder not accessible to screen readers, but once the user enters any text into the form control, or if the form control already has a value, the placeholder disappears. Browsers with automatic page translation features may skip over attributes when translating, meaning the may not get translated. Note: Don't use the attribute if you can avoid it. If you need to label an element, use the element.\n\nWarning: Client-side validation is useful, but it does not guarantee that the server will receive valid data. If the data must be in a specific format, always verify it also on the server-side, and return a HTTP response if the format is invalid. In addition to using CSS to style inputs based on the or UI states based on the current state of each input, as noted in the UI pseudo-classes section above, the browser provides for client-side validation on (attempted) form submission. On form submission, if there is a form control that fails constraint validation, supporting browsers will display an error message on the first invalid form control; displaying a default message based on the error type, or a message set by you. Some input types and other attributes place limits on what values are valid for a given input. For example, means only the number 2, 4, 6, 8, or 10 are valid. Several errors could occur, including a error if the value is less than 2, if greater than 10, if the value is a number between 2 and 10, but not an even integer (does not match the requirements of the attribute), or if the value is not a number. For the input types whose domain of possible values is periodic (that is, at the highest possible value, the values wrap back around to the beginning rather than ending), it's possible for the values of the and properties to be reversed, which indicates that the range of permitted values starts at , wraps around to the lowest possible value, then continues on until is reached. This is particularly useful for dates and times, such as when you want to allow the range to be from 8 PM to 8 AM: Specific attributes and their values can lead to a specific error : Validity object errors depend on the attributes and their values: Occurs when the value is greater than the maximum value as defined by the attribute Occurs when the number of characters is greater than the number allowed by the property Occurs when the value is less than the minimum value as defined by the attribute Occurs when the number of characters is less than the number required by the property Occurs when a pattern attribute is included with a valid regular expression and the does not match it. Occurs when the attribute is present but the value is or radio or checkbox is not checked. The value doesn't match the step increment. Increment default is , so only integers are valid on is step is not included. will never throw this error. Occurs when the value is not of the correct type, for example an email does not contain an or a url doesn't contain a protocol. If a form control doesn't have the attribute, no value, or an empty string, is not invalid. Even if the above attributes are present, with the exception of , an empty string will not lead to an error. We can set limits on what values we accept, and supporting browsers will natively validate these form values and alert the user if there is a mistake when the form is submitted. In addition to the errors described in the table above, the interface contains the , , and boolean readonly properties. The validity object includes: For each of these Boolean properties, a value of indicates that the specified reason validation may have failed is true, with the exception of the property, which is if the element's value obeys all constraints. If there is an error, supporting browsers will both alert the user and prevent the form from being submitted. A word of caution: if a custom error is set to a truthy value (anything other than the empty string or ), the form will be prevented from being submitted. If there is no custom error message, and none of the other properties return true, will be true, and the form can be submitted. function validate(input) { let validityState_object = input.validity; if (validityState_object.valueMissing) { input.setCustomValidity(\"A value is required\"); } else if (validityState_object.rangeUnderflow) { input.setCustomValidity(\"Your value is too low\"); } else if (validityState_object.rangeOverflow) { input.setCustomValidity(\"Your value is too high\"); } else { input.setCustomValidity(\"\"); } } The last line, setting the custom validity message to the empty string is vital. If the user makes an error, and the validity is set, it will fail to submit, even if all the values are valid, until the message is . If you want to present a custom error message when a field fails to validate, you need to use the Constraint Validation API available on (and related) elements. Take the following form: The basic HTML form validation features will cause this to produce a default error message if you try to submit the form with either no valid filled in, or a value that does not match the . If you wanted to instead display custom error messages, you could use JavaScript like the following: const nameInput = document.querySelector(\"input\"); nameInput.addEventListener(\"input\", () => { nameInput.setCustomValidity(\"\"); nameInput.checkValidity(); }); nameInput.addEventListener(\"invalid\", () => { if (nameInput.value === \"\") { nameInput.setCustomValidity(\"Enter your username!\"); } else { nameInput.setCustomValidity( \"Usernames can only contain upper and lowercase letters. Try again!\", ); } }); The example renders like so:\n• We check the valid state of the input element every time its value is changed by running the method via the event handler.\n• If the value is invalid, an event is raised, and the event handler function is run. Inside this function we work out whether the value is invalid because it is empty, or because it doesn't match the pattern, using an block, and set a custom validity error message.\n• As a result, if the input value is invalid when the submit button is pressed, one of the custom error messages will be shown.\n• If it is valid, it will submit as you'd expect. For this to happen, the custom validity has to be cancelled, by invoking with an empty string value. We therefore do this every time the event is raised. If you don't do this, and a custom validity was previously set, the input will register as invalid, even if it currently contains a valid value on submission. Note: Always validate input constraints both client side and server side. Constraint validation doesn't remove the need for validation on the server side. Invalid values can still be sent by older browsers or by bad actors. Note: Firefox supported a proprietary error attribute — — for many versions, which allowed you set custom error messages in a similar way. This has been removed as of version 66 (see Firefox bug 1513890)."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Forms/HTML5_input_types",
        "document": "In the previous article we looked at the element, covering the original values of the attribute available since the early days of HTML. Now we'll look in detail at the functionality of some input types that were added later. To understand the newer input type values available to create native form controls, and how to implement them using HTML. Because HTML form control appearance may be quite different from a designer's specifications, web developers sometimes build their own custom form controls. We cover this in an advanced tutorial: How to build custom form widgets.\n\nThis type of field is set using the value for the attribute: When this is used, the value must be an email address to be valid. Any other content causes the browser to display an error when the form is submitted. You can see this in action in the screenshot below. You can use the attribute in combination with the input type to allow several comma-separated email addresses to be entered in the same input: On some devices — notably, touch devices with dynamic keyboards like smartphones — a different virtual keypad might be presented that is more suitable for entering email addresses, including the key: Note: You can find examples of the basic text input types at basic input examples (see the source code also). This is another good reason for using these newer input types, improving the user experience for users of these devices.\n\nAs you can see above, — along with other newer types — provides built-in client-side error validation, performed by the browser before the data gets sent to the server. It is a helpful aid to guide users to fill out a form accurately, and it can save time: it is useful to know that your data is not correct immediately, rather than having to wait for a round trip to the server. But it should not be considered an exhaustive security measure! Your apps should always perform security checks on any form-submitted data on the server-side as well as the client-side, because client-side validation is too easy to turn off, so malicious users can still easily send bad data through to your server. Read Website security for an idea of what could happen; implementing server-side validation is somewhat beyond the scope of this module, but you should bear it in mind. Note that is a valid email address according to the default provided constraints. This is because the input type allows intranet email addresses by default. To implement different validation behavior, you can use the attribute. You can also customize the error messages. We'll talk about how to use these features in the Client-side form validation article later on. Note: If the data entered is not an email address, the pseudo-class will match, and the property will return .\n\nSearch fields are intended to be used to create search boxes on pages and apps. This type of field is set by using the value for the attribute: The main difference between a field and a field is how the browser styles its appearance. In some browsers, fields are rendered with rounded corners. In some browsers, an \"Ⓧ\" clear icon is displayed, which clears the field of any value when clicked. This clear icon only appears if the field has a value, and, apart from Safari, it is only displayed when the field is focused. Additionally, on devices with dynamic keyboards, the keyboard's enter key may read \"search\", or display a magnifying glass icon. Another worth-noting feature is that the values of a field can be automatically saved and re-used to offer auto-completion across multiple pages of the same website; this tends to happen automatically in most modern browsers.\n\nA special field for filling in phone numbers can be created using as the value of the attribute: When accessed via a touch device with a dynamic keyboard, most devices will display a numeric keypad when is encountered, meaning this type is useful whenever a numeric keypad is useful, and doesn't just have to be used for telephone numbers. Due to the wide variety of phone number formats around the world, this type of field does not enforce any constraints on the value entered by a user (this means it may include letters, etc.). As we mentioned earlier, the attribute can be used to enforce constraints, which you'll learn about in Client-side form validation.\n\nControls for entering numbers can be created with an of . This control looks like a text field but allows only floating-point numbers, and usually provides buttons in the form of a spinner to increase and decrease the value of the control. On devices with dynamic keyboards, the numeric keyboard is generally displayed. With the input type, you can constrain the minimum and maximum values allowed by setting the and attributes. You can also use the attribute to set the increment increase and decrease caused by pressing the spinner buttons. By default, the number input type only validates if the number is an integer, as the attribute defaults to . To allow float numbers, specify or a specific value, like to restrict the floating point. If omitted, as the value defaults to , only whole numbers are valid. Let's look at some examples: This example creates a number control whose valid value is restricted to an odd value between and . The increase and decrease buttons change the value by , starting with the value. <label for=\"number\">Enter an odd number between 1 and 10:</label><br /> This example creates a number control whose value is restricted to any value between and inclusive, and whose increase and decrease buttons change its value by . The input type makes sense when the range of valid values is limited, such as a person's age or height. If the range is too large for incremental increases to make sense (such as USA ZIP codes, which range from to ), the type might be a better option; it provides the numeric keypad while forgoing the number's spinner UI feature.\n\nAnother way to pick a number is to use a slider. You see these quite often on sites like shopping sites where you want to set a maximum property price to filter by. Let's look at a live example to illustrate this: Usage-wise, sliders are less accurate than text fields. Therefore, they are used to pick a number whose precise value is not necessarily important. A slider is created using the with its attribute set to the value . The slider-thumb can be moved via mouse or touch, or with the arrows of the keypad. It's important to properly configure your slider. To that end, it's highly recommended that you set the , , and attributes which set the minimum, maximum, and increment values, respectively. Let's look at the code behind the above example, so you can see how it's done. First of all, the basic HTML: This example creates a slider whose value may range between and , which increments/decrements by 1000 at a time. We've given it a default value of , using the attribute. One problem with sliders is that they don't offer any kind of visual feedback as to what the current value is. This is why we've included an element to contain the current value. You could display an input value or the output of a calculation inside any element, but is special — like — and it can take a attribute that allows you to associate it with the element or elements that the output value came from. To actually display the current value, and update it as it changes, you must use JavaScript, which can be accomplished with a few statements: Here we store references to the input and the in two variables. Then we immediately set the 's to the current of the input. Finally, an event listener is set to ensure that whenever the range slider is moved, the 's is updated to the new value.\n\nGenerally, for a good user experience when gathering date and time values, it is important to provide a calendar selection UI. These enable users to select dates without needing to context switch to a native calendar application or potentially entering them in differing formats that are hard to parse. The last minute of the previous millennium can be expressed in the following different ways: , , or . HTML date controls are available to handle this specific kind of data, providing calendar widgets and making the data uniform. A date and time control is created using the element and an appropriate value for the attribute, depending on whether you wish to collect dates, times, or both. Here's a live example: Let's look at the different available types in brief. Note that the usage of these types is quite complex, especially considering browser support (see below); to find out the full details, follow the links below to the reference pages for each type, including detailed examples."
    },
    {
        "link": "https://w3schools.com/tags/tag_input.asp",
        "document": "The tag specifies an input field where the user can enter data.\n\nThe element is the most important form element.\n\nThe element can be displayed in several ways, depending on the type attribute.\n\nThe different input types are as follows:\n\nLook at the type attribute to see examples for each input type!\n\nTip: Always use the <label> tag to define labels for , , , , and .\n\nThe tag also supports the Global Attributes in HTML.\n\nThe tag also supports the Event Attributes in HTML."
    },
    {
        "link": "https://w3schools.com/html/html_forms.asp",
        "document": "An HTML form is used to collect user input. The user input is most often sent to a server for processing.\n\nThe HTML element is used to create an HTML form for user input:\n\nThe element is a container for different types of input elements, such as: text fields, checkboxes, radio buttons, submit buttons, etc.\n\nAll the different form elements are covered in this chapter: HTML Form Elements.\n\nThe HTML element is the most used form element.\n\nAn element can be displayed in many ways, depending on the attribute.\n\nHere are some examples:\n\nAll the different input types are covered in this chapter: HTML Input Types.\n\nThis is how the HTML code above will be displayed in a browser:\n\nNotice the use of the element in the example above.\n\nThe tag defines a label for many form elements.\n\nThe element is useful for screen-reader users, because the screen-reader will read out loud the label when the user focuses on the input element.\n\nThe element also helps users who have difficulty clicking on very small regions (such as radio buttons or checkboxes) - because when the user clicks the text within the element, it toggles the radio button/checkbox.\n\nThe attribute of the tag should be equal to the attribute of the element to bind them together.\n\nRadio buttons let a user select ONE of a limited number of choices.\n\nThis is how the HTML code above will be displayed in a browser:\n\nCheckboxes let a user select ZERO or MORE options of a limited number of choices.\n\nThis is how the HTML code above will be displayed in a browser:\n\nThe defines a button for submitting the form data to a form-handler.\n\nThe form-handler is typically a file on the server with a script for processing input data.\n\nThe form-handler is specified in the form's attribute.\n\nThis is how the HTML code above will be displayed in a browser:\n\nThe Name Attribute for <input>\n\nNotice that each input field must have a attribute to be submitted.\n\nIf the attribute is omitted, the value of the input field will not be sent at all."
    },
    {
        "link": "https://geeksforgeeks.org/html-forms",
        "document": "HTML Forms use the <form> tag to collect user input through various interactive controls. These controls range from text fields, numeric inputs, and email fields to password fields, checkboxes, radio buttons, and submit buttons.\n\nThe HTML <form> comprises several elements, each serving a unique purpose. For instance, the <label> element defines labels for other <form> elements. On the other hand, the <input> element is versatile and can be used to capture various types of input data such as text, password, email, and more simply by altering its type attribute.\n\nIn HTML forms, various input types are used to collect different types of data from users. Here are some commonly used input types:\n\nExample: This HTML form collects user personal information such as username and password with a button to submit the form.\n\nThis HTML form collects user personal information, including name, email, password, gender, date of birth, and address. It features proper styling for input fields and submission buttons.\n\nHere are some of the key attributes that can be used with the element:\n• action: This attribute specifies where to send the form-data when a form is submitted. The value of this attribute is typically a URL.\n• method: This attribute defines the HTTP method used to send the form-data. The values can be “ get post\n• target: This attribute specifies where to display the response received after submitting the form. The values can be “ _blank _self _parent _top ”, or the name of an iframe.\n• enctype: This attribute is used when method=“post”. It specifies how the form-data should be encoded when submitting it to the server. The values can be “ application/x-www-form-urlencoded multipart/form-data text/plain\n• autocomplete: This attribute specifies whether a form should have autocomplete on or off. When autocomplete is on, the browser automatically completes values based on values that the user has entered before.\n• novalidate: This Boolean attribute specifies that the form-data should not be validated on submission.\n\nWhat is an HTML form?\n\nWhat is the action attribute in a form?\n\nWhat does the method attribute do?\n\nHow to use different input types?"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage",
        "document": "The keys and the values stored with are always in the UTF-16 string format, which uses two bytes per character. As with objects, integer keys are automatically converted to strings.\n\ndata is specific to the protocol of the document. In particular, for a site loaded over HTTP (e.g., ), returns a different object than for the corresponding site loaded over HTTPS (e.g., ).\n\nFor documents loaded from URLs (that is, files opened in the browser directly from the user's local filesystem, rather than being served from a web server) the requirements for behavior are undefined and may vary among different browsers.\n\nIn all current browsers, seems to return a different object for each URL. In other words, each URL seems to have its own unique local-storage area. But there are no guarantees about that behavior, so you shouldn't rely on it because, as mentioned above, the requirements for URLs remain undefined. So it's possible that browsers may change their URL handling for at any time. In fact some browsers have changed their handling for it over time."
    },
    {
        "link": "https://tiny.cloud/blog/javascript-localstorage",
        "document": "Your app needs a cloud service provider and a database. It's unavoidable. But sometimes, you need to let your customers save content without involving the database or cloud service provider. In this case, you can use JavaScript to access localStorage iny our browser. But you probably have questions: what is localStorage, when can you use it, and is it secure?\n\nIf you've already learned about localStorage, and you know what you're getting yourself into, check through the table of contents, or start with the JavaScript local storage demo. The demo makes use of the TinyMCE rich text editor as an example of a useful content builder.\n\nOtherwise, read on to find out more about JavaScript and localStorage, what it is, and how it works.\n\nWhat is localStorage in JavaScript\n\n Advantages and limitations of localStorage\n\n localStorage vs sessionStorage vs Cookie\n\n SessionStorage vs localStorage\n\n localStorage vs Cookie\n\n IndexedDB vs localStorage\n\nHow to use localStorage methods in JavaScript\n\nHow to clear localStorage\n\nlocalStorage JavaScript example\n\nlocalStorage next steps\n\nWhat is localStorage in JavaScript\n\nlocalStorage in JavaScript allows web applications to store data locally within the user's browser – with no expiration date. The data isn’t deleted when the browser is closed, and is available when the browser is opened again.\n\nData stored remains saved depending on if the browser is using a best-effort method, or a persistent method. When best-effort is in effect, the data persists as long as the stored data does note exceed the limits, and customers don't manually delete the localStorage saved data. When persistent is used, data is only deleted, or evicted, by the customer's choice.\n\nAll browsers support localStorage through the api.Window.localStorage method, and you can log any browser compatibility issues at the MDN browser compatibility GitHub repository.\n\nlocalStorage also allows your customers to access specific data quickly without the overhead of a database. There are other advantages and disadvantages to understand when working with localStorage.\n\n\n\n✏️NOTE: Other options for data storage are available, like Uploadcare for example.\n• It stores up to 5MiB of data in local storage\n• A maximum of 10MiB of data across bot localStorage and sessionStorage (data in sessionStorage is cleared when the page session ends)\n• Easy to use – no need for a web server or backend database\n• Great for getting an idea up and running and for testing purposes\n• It can only store strings, specifically UTF-16 string format, with two bytes per character. This can restrict you from using it for more complex scenarios although, HTML can be stored as a string\n• It’s local to the browser and specific to the origin (per domain and protocol), and there’s no guarantee that the data will persist even in that same context\n• It’s not secure. Don’t store any private or personal information in localStorage\n\nThe main difference between localStorage, sessionStorage, and cookie storage is size.\n\nOf these three types of storage, localStorage is the newest kind of in-browser storage.\n\nUnlike sessionStorage, data stored in localStorage persists, and is accessible even after the browser closes. On Stack Overflow, cssyphus put together a useful explanation that contrasts the different storage types along with a list of resources.\n\nSessionStorage is useful when you need browser storage that does not impact web application performance. Login credentials are held in sessionStorage as they are cleared once the open tab closes.\n\nCookies are the oldest kind of in-browser storage. With their small capacity, they can hold small amounts of data, and are not designed to hold sensitive data such as login credentials.\n\nTogether, these two kinds of storage are the main data storage objects available that the browser can access easily for storing and retrieving information for customers. The main difference between Session and Local kinds of storage is the lifespan of the stored data.\n\nSessionStorage is tied to a specific tab the browser may have open, whereas localStorage is accessible across any tab the browser has open. Once the tab closes, the sessionStorage is deleted, but localStorage persists.\n\nCompared to localStorage, Cookies are older, and can only fit small amounts of data. There are two kinds of Cookies: session, and persistent.\n• Session Cookies, like sessionStorage, expire when the browser closes.\n• A persistent Cookie has an expiry attribute, or a max-age attribute that designates when the browser deletes the data held in cookie storage.\n\nCookies are accessible by servers, as when browsers interact with a server, cookie data is sent along with requests and responses.\n\nA new kind of browser storage, IndexedDB appeared in an attempt to make an improved version of localStorage. Contrasting the two, IndexedDB has a more complex API syntax compared to localStorage. IndexedDB allows for the storage of structured data.\n\nUnlike localStorage, IndexedDB is described as a JavaScript-based object-oriented database. Its design is to provide database-like behavior without the need for an internet connection to a web-server.\n\nHow to use localStorage methods in JavaScript\n\nThere are four basic JavaScript localStorage methods you can use to access and work with localStorage:\n• setItem() - takes a key-value pair and adds it to localStorage\n• getItem() - takes a key and returns the corresponding value\n• removeItem() - takes a key and removes the corresponding key-value pair\n\nTo test out these methods, the following procedure uses the setItem() and getItem() methods. Feel free to try out the other methods in a similar way.\n• Open a browser, and then access the console. For example, in Google Chrome, open Developer Tools and click on the Console tab.\n• Enter the localStorage command, and the current stored data will be returned. For example (assuming it’s empty to begin with):\n• Enter localStorage.setItem('myKey', 'testValue') and the string testValue will be stored against the key myKey:\n• Enter localStorage.getItem('myKey') and the corresponding string will be returned:\n\nYou can run the command clear() to completely clear the localStorage data (for the domain):\n• Check if there is content stored in localStorage:\n• For the purpose of the test, add some content to clear:\n• Clear the localStorage data using the clear() method:\n• Check again to confirm the local storage is clear.\n\nThe following demo shows how you can store information from the TinyMCE text area in localStorage.\n\nCreate a simple index.html file with a single textarea, and two buttons as follows. The textarea id can be anything – in this example it's called myTextArea.\n\nOn the ADD_YOUR_TINYMCE_API_KEY_HERE string: TinyMCE requires a valid API key, otherwise error messages concerning read-only mode can appear in the TinyMCE text area. Your API key is free, and you can access it on the TinyMCE dashboard using Google or GitHub credentials.\n\nThe demo content has two JavaScript functions: saveContent() and loadContent(). The buttons are configured so that when clicked they trigger the relevant JavaScript function. Here’s how it works in more detail:\n• The saveContent() function accesses the current value of the textarea and assigns it to a variable myContent\n• getContent() retrieves the TinyMCE text area contents. You could also use document.getElementById() to access the textarea with id myTextArea\n• The loadContent() function operates in a similar way, only in reverse\n• setContent() then adds the retrieved data to the TinyMCE text area\n\nHere's how the localStorage demo works with TinyMCE:\n\nAnd the following image shows the demo with some custom CSS for the buttons to add more visual interest:\n\nTo test out the demo:\n• Type something in the textarea and click Save. (For example, the demo contains a snippet of prose from Frankenstein) The content then saves to localStorage.\n• Refresh the page, and the content will disappear.\n• Click the Load button, and the content is retrieved from localStorage, and appears in the text area.\n\nWhy not try taking this example one step further? Check out the article with more information on adding a rich text editor that works with JavaScript localStorage:\n\nIf you’d like to know more about Tiny, follow us on Twitter or send us a message if you have any questions on how your app could work with localStorage and TinyMCE."
    },
    {
        "link": "https://hansen-breanna.github.io/local-storage.html",
        "document": "An API allows you to pull data from another website to use in your own site or in an application. The following data is pulled from the NYT Books List API. It lists the first ten categories of books in the API. let books = new XMLHttpRequest(); books.open('GET', bestBooks); books.send(); books.onload = function () { let booksInfo = JSON.parse(books.responseText); var category = \"\"; for (var i = 0; i < booksInfo.results.length; i++) { category += booksInfo.results[i].display_name + \"<br>\"; } document.getElementById(\"bookCategories\") .innerHTML = category; }\n\nWeb Storage is where you store data on the a user's browser instead of on the server. The two types of storage are local and session storage. Local storage saves the data in the user's browser with no expiration date. Session storage saves the data until the current session is ended Data is stored using pairs. Data can only be saved as strings. Examples of where you might use it are to to remember a username, a term last searched, remember previous checkbox configurations, load HTML content onto page so it is faster to load if reloaded, There are several methods you can use for local storage: setItem, getItem, key, length, removeItem, and clear. Both session and local storage use the same methods.\n\nStoring and Retrieving Different Types of Data Single inputs can be added to or changed and saved into localStorage using or . These types of arrays are written like an object but referenced similar to an array, but with the key name instead of index number. Objects must be turned into strings in order to be viewed in localStorage in the inspect dashboard."
    },
    {
        "link": "https://blog.logrocket.com/localstorage-javascript-complete-guide",
        "document": "Editor’s note: This post was updated by Muhmmed Ali on 28 February 2024 to include advanced data management techniques in . Check out our guide to storing and retrieving JavaScript objects in for more information.\n\nIt can be infuriating to accidentally close a webpage while filling out a form. You lose all the data already filled and have to start over. In this article, you’ll learn how to use in JavaScript to save your data beyond a single browsing session. We’ll show you how to use this mechanism and the property, and review the basics of web storage in JavaScript.\n\nWhat is in JavaScript?\n\nis a property that allows JavaScript sites and apps to save key-value pairs in a web browser with no expiration date. This means the data stored persists even after the user closes the browser or restarts the computer.\n\nis a object property, which makes it a global object that can interact with and manipulate the browser window. It can also be used in combination with other properties and methods.\n\nThe mechanism is available via the property. is part of the interface in JavaScript, which represents a window containing a DOM document.\n\nThe interface features a wide range of functions, constructors, objects, and namespaces. is a read-only property that returns a reference to the local storage object used to store data that is only accessible to the origin that created it.\n\nWhen to use\n\nPut simply, is used for storing and retrieving data. While you can store small amounts of data with , it’s not suitable for large datasets. is accessible to anyone who uses the device, so you shouldn’t use it to store sensitive information. You can use it to store user preferences, like language or theme. You can also use it to cache data if you use it frequently. can store form data that won’t be lost if the user closes the browser.\n\nIf you have an application that requires you to log in, can be used to keep your session data. You can remain logged in even after closing and reopening the browser. We’ll demonstrate this later in this tutorial using a simple to-do app.\n\nIn the meantime, for a refresher on how to use in JavaScript, check out the video tutorial below:\n\nIn Google Chrome, web storage data is saved in an SQLite file in a subfolder in the user’s profile. The subfolder is located at on Windows machines and on macOS. Firefox saves storage objects in an SQLite file called , which is also located in the user’s profile folder.\n\nis one of two mechanisms for the Web Storage API, the other being . The Web Storage API is a set of mechanisms that enables browsers to store key-value pairs. It is designed to be much more intuitive than using cookies.\n\nThe key-value pairs represent storage objects, which are similar to objects, except they remain intact during page loads and are always strings. You can access these values like an object or using the method (more on that later).\n\nBoth and maintain a separate storage area for each available origin for the duration of the page session. The main difference between them is that only maintains a storage area. At the same time, the browser is open (including when the page reloads or restores) while continues to store data after the browser is closed.\n\nstores data that won’t expire, while only stores data for a single session. It’s important to note that data loaded in an incognito browsing session will be cleared once the last private tab is closed. ‘s method is useful when temporary data storage is required, and it should be used in situations where data persistence beyond the current session is not required.\n\nTypically, has a smaller storage limit compared to , often limited to a few megabytes per origin. This makes it suitable for storing temporary data during a user’s session without consuming excessive browser resources.\n\n, on the other hand, provides a larger storage capacity, often ranging from 5-10 MB per origin. It is suited for storing larger amounts of data that need to persist across multiple sessions.\n\nin JavaScript is an important tool for storing client-side data. However, it has several advantages and disadvantages you should consider.\n\nThe first advantage of is one we’ve mentioned a few times already, and it is that stored data doesn’t expire. You can still access the data offline, and caches data that can be used without an internet connection.\n\nStoring data with is more secure than storing with cookies, and you have more control of your data. Lastly, has a larger storage capacity compared to cookies. While cookies can only store four kilobytes of data, can store up to five megabytes of data.\n\nis synchronous, meaning each operation only executes one after the other. This poses minimal issues for smaller datasets but as your data grows, this can become a larger issue.\n\nAlthough is more secure than cookies, you still shouldn’t use it to store sensitive data. Anyone with access to the user’s device can access the data stored with . Additionally, can only store strings, so if you want to store other data types, you’ll have to convert them to strings. And finally, storing too much data with can slow down your application.\n\nYou’ve heard it repeatedly by now — stores data. And, if you’re storing data, it means you may need to retrieve it later. In this section, we’ll explore exactly how works. Here’s a rundown of how it works:\n• : Adds key and value to\n• : Passes a number to retrieve the key of a\n\nThe method allows you to store values in . It takes two parameters: a key and a value. The key can be referenced later to fetch the value attached to it. Here’s how it should look:\n\nIn the code above, you can see that is the key and is the value. As we’ve already noted, can only store strings. To store arrays or objects in , you would have to convert them to strings.\n\nTo do this, we use the method before passing to , like so:\n\nallows you to access the data stored in the browser’s object. This method accepts only one parameter, the , and returns the as a string:\n\nThis returns a string with a value of . If the specified key doesn’t exist in , it’ll return . In the case of the array, we make use of the method, which converts a JSON string into a JavaScript object:\n\nUsing the array we created above, here’s how to retrieve it from :\n\nThis method will return the array . You can inspect the webpage, and find it in the console, like this:\n\nThis image is from Firefox, so it’ll look a little different on other browsers. Let’s compare it with another array that’s not stored with :\n\nNow, we have two arrays on the console, as shown below:\n\nNormally, if you comment them out in your code editor, they should disappear from the console. But anything stored with will remain. Here’s an example:\n\nTo delete an item from , you’ll use the method. When passing a key , the method removes the existing key from the storage. If no item is associated with the given key, this method will do nothing. Here’s the code:\n\nHow to delete all items in :\n\nTo delete all items in , you will use the method. This method, when invoked, clears the entire storage of all records for that domain. It does not receive any parameters. Use the following code:\n\nHow to get the name of a key:\n\nThe method comes in handy when you need to loop through keys but still be able to pass a number or index to to retrieve the name of the . Here’s what that looks like:\n\nThe parameter represents the zero-based index of the you want to retrieve the name for.\n\nStoring data in the browser with\n\nWe’ve reviewed all the methods; now we’ll look at them more practically. Here’s a to-do app built with :\n\nSee the Pen \n\n To-do App by Oscar-Jite (@oscar-jite)\n\n on CodePen.\n\nThe app has a very simple HTML markup:\n\nIn the code above, we’ve added two functions, and , that we’ll use later in the JavaScript. The CSS is also simple; you can style it however you like. The important part is the JavaScript. You’ll start by selecting the list where the tasks will be added and the field, as shown below:\n\nNext, you load any pre-existing items in . If there aren’t any, you create an empty , as shown below:\n\nNow, we’ll create a function that adds a task, which would be a , into the empty :\n\nNow, we add functionality to the buttons. The button stores the items in , and the button deletes every item. Here’s the code:\n\nThe function gets the items from the field, . It then adds them to the and saves them to while simultaneously adding them to the list. The function clears all items from , removes them from the list, and resets the .\n\nBoth and cookies are used to store client-side data. As we mentioned before, cookies can only store a maximum of four kilobytes of data, which is significantly less than ‘s five megabytes of storage capacity.\n\nCookies are automatically sent to the server with every HTTP request, but stays local within the user’s device. This can improve web performance and doesn’t increase network traffic because it doesn’t share data with the server.\n\nAs we’ve seen, the data you store with doesn’t expire; it stays indefinitely until you delete it manually. On the other hand, cookies can be set to expire after some time or as soon as you close the browser. Cookies usually store data like user preferences and login/authentication information. This data is accessible across all tabs and windows of the browser. However, only stores data that is accessible within a specific protocol or domain.\n\n, as a type of web storage, is an HTML5 specification. It is supported by major browsers, including Internet Explorer v8. You can use the following snippet to check if the browser supports :\n\nNow, we’ll explore some advanced techniques for managing data in . We will work on how to efficiently remove keys, employ best practices for storing and setting objects, and use JSON parsing and stringification for complex data.\n\nEfficiently removing keys from objects stored in is necessary to optimize storage space, especially if you are building an application where data is frequently updated or deleted. Deleting unnecessary keys helps prevent from becoming clustered with useless data.\n\nTo effectively remove a key from an object in , you can retrieve the object using the key, remove the desired property, and then set the updated object back into . This minimizes unnecessary data manipulation and storage overhead:\n\nJSON parsing and stringification are powerful techniques for handling complex data structures when storing and retrieving data in . They allow for easy conversion between JavaScript objects and JSON strings, enabling efficient data management and manipulation.\n\nWhen storing complex data structures like objects or arrays in , it’s essential to stringify them using before setting them into . This converts the JavaScript object into a JSON string, which can then be stored as a key-value pair:\n\nWhen dealing with nested objects or arrays, ensure that all nested objects are also stringified and parsed to maintain the integrity of the data structure:\n\nIn this article, we explored the capabilities of in JavaScript as a simple and efficient way to store and retrieve data without relying on cookies. We covered how and when to use , as well as how to save, retrieve, and delete items in . Through the example of a to-do app, we demonstrated in action, comparing it to cookies.\n\nIn this post, you learned how and when to use . We covered how to save, retrieve, and delete items in . We also created a to-do app to see how works in a practical scenario. Finally, we compared it to cookies.\n\nSo, you’ve learned about a great tool that’s easy to use with broad browser support. How will you implement in your next project? Happy coding!"
    },
    {
        "link": "https://w3schools.com/html/html5_webstorage.asp",
        "document": "With web storage, applications can store data locally within the user's browser.\n\nBefore HTML5, application data had to be stored in cookies, included in every server request. Web storage is more secure, and large amounts of data can be stored locally, without affecting website performance.\n\nUnlike cookies, the storage limit is far larger (at least 5MB) and information is never transferred to the server.\n\nWeb storage is per origin (per domain and protocol). All pages, from one origin, can store and access the same data.\n\nWeb storage provides two objects for storing data in the browser:\n• - stores data with no expiration date (data is not lost when the browser tab is closed)\n• - stores data for one session (data is lost when the browser tab is closed)\n\nThe numbers in the table specify the first browser version that fully supports Web Storage.\n\nBefore using web storage, we can quickly check browser support for localStorage and sessionStorage:\n\nThe object stores the data with no expiration date. The data will not be lost when the browser is closed, and will be available the next day, week, or year.\n• Use the method to create name/value pairs\n• Use the method to retrieve the values set\n• Retrieve the value of \"lastname\" and insert it into an element with id=\"result\"\n• Retrieve the value of \"bgcolor\" and insert it into the style backgroundColor of the element with id=\"result\"\n\nThe syntax for removing the \"lastname\" localStorage item is as follows:\n\nNote: Name/value pairs are always stored as strings. Remember to convert them to another format when needed!\n\nThe following example counts the number of times a user has clicked a button. In this code the value string is converted to a number to be able to increase the counter:\n\nThe object is equal to the object, except that it stores the data for only one session! The data is deleted when the user closes the specific browser tab.\n\nThe following example counts the number of times a user has clicked a button, in the current session:\n\n<script>\n\nfunction clickCounter() {\n\n const x = document.getElementById(\"result\");\n\n if (typeof(Storage) !== \"undefined\") {\n\n if (sessionStorage.clickcount) {\n\n sessionStorage.clickcount = Number(sessionStorage.clickcount)+1;\n\n } else {\n\n sessionStorage.clickcount = 1;\n\n }\n\n x.innerHTML = \"You have clicked the button \" + sessionStorage.clickcount + \" time(s) in this session!\";\n\n } else {\n\n x.innerHTML = \"Sorry, no Web storage support!\";\n\n }\n\n}\n\n</script> Try it Yourself »"
    },
    {
        "link": "https://stackoverflow.com/questions/948227/should-i-use-window-navigate-or-document-location-in-javascript",
        "document": "In java script many ways are there for redirection, see the below code and explanation\n\nwindow.location.href loads page from browser's cache and does not always send the request to the server. So, if you have an old version of the page available in the cache then it will redirect to there instead of loading a fresh page from the server.\n\nwindow.location.assign() method for redirection if you want to allow the user to use the back button to go back to the original document.\n\nwindow.location.replace() method if you want to want to redirect to a new page and don't allow the user to navigate to the original page using the back button."
    },
    {
        "link": "https://medium.com/@worldgoit/window-location-enhancing-web-navigation-and-url-manipulation-16512f65990b",
        "document": "In the realm of web development, achieving smooth navigation and effective URL manipulation is crucial for delivering a seamless user experience. Among the many tools available to web developers, window.location stands out as a powerful and versatile feature. In this article, we will explore the ins and outs of window.location, understanding its properties, methods, and best practices to employ it efficiently.\n\nAt its core, window.location is a JavaScript object that represents the current URL of the web page. It allows developers to access various components of the URL and perform actions related to navigation and history.\n\n- Changing the URL with window.location.href.\n\n\n\n- Redirecting users with window.location.replace().\n\n\n\n- Reloading the page with window.location.reload().\n\nOne of the fundamental tasks of window.location is to enable navigation. By modifying the window.location.href property, developers can easily change the URL, effectively redirecting users to different pages. Additionally, we will learn how to use window.location.replace() to perform a redirection without adding a new entry to the browser’s history and how to reload the page using window.location.reload().\n\nParsing the URL’s components can be essential for capturing specific data from the address bar. We’ll see how to access individual parts of the URL, such as the protocol, hostname, pathname, and query parameters, using the properties of window.location. This can be particularly useful when building dynamic web applications that respond to varying URLs.\n\nControlling the browser’s history can be vital in certain scenarios, like creating custom back buttons or implementing complex navigation patterns. We’ll delve into how window.location can be used to manipulate the browser history, allowing developers to navigate users backward or forward within their browsing session.\n\nWhile window.location provides valuable functionality, it also comes with certain security implications. We will explore potential risks and vulnerabilities associated with its use, such as potential open-door for phishing attacks or misuse by malicious actors. Implementing best practices will help minimize these risks.\n\nAs with any web development tool, window.location is subject to potential errors and unexpected scenarios. We’ll discuss how to handle invalid URLs, unsupported features in various browsers, and other edge cases that developers may encounter while working with window.location.\n\nPerforming page reloads or URL changes can impact performance and user experience. We’ll share valuable tips for optimizing the use of window.location, ensuring that URL manipulation occurs efficiently and without unnecessary page reloads, particularly crucial for single-page applications (SPAs).\n\nAs technology and web standards continue to evolve, we’ll explore the potential future enhancements of window.location. Staying abreast of upcoming changes can be valuable for developers looking to adopt the latest and most efficient techniques.\n\nIn conclusion, window.location serves as an indispensable tool for web developers, offering a range of capabilities to enhance web navigation and URL manipulation. By leveraging its properties and methods responsibly, developers can create user-friendly and dynamic web applications that cater to their users’ needs effectively.\n\n- What is the purpose of window.location in JavaScript? window.location in JavaScript represents the URL of the current page and allows developers to manipulate the URL, perform page redirects, and access various components of the URL.\n\n\n\n- How can I change the URL without causing a page reload? You can change the URL without causing a page reload by modifying the window.location.href property or using window.location.replace() for a redirection without adding a new entry to the browser’s history.\n\n\n\n- Is it safe to manipulate the browser history with window.location? While manipulating the browser history with window.location can be useful, it’s essential to consider potential security risks, such as opening opportunities for phishing attacks. Following best practices and validation can help mitigate these risks.\n\n\n\n- Can I extract specific parts of the URL using window.location? Yes, you can extract specific parts of the URL, such as the protocol, hostname, pathname, and query parameters, using the properties of window.location.\n\n\n\n- Are there any limitations to using window.location in different browsers? Some older browsers may have limited support for certain features of window.location. However, with modern browsers, the majority of its functionality is well-supported."
    },
    {
        "link": "https://w3schools.com/js/js_window_location.asp",
        "document": "The object can be used to get the current page address (URL) and to redirect the browser to a new page.\n\nThe object can be written without the window prefix.\n• returns the href (URL) of the current page\n• returns the domain name of the web host\n• returns the path and filename of the current page\n• returns the web protocol used (http: or https:)\n\nThe property returns the URL of the current page.\n\nThe property returns the name of the internet host (of the current page).\n\nThe property returns the pathname of the current page.\n\nThe property returns the web protocol of the page.\n\nThe property returns the number of the internet host port (of the current page).\n\nMost browsers will not display default port numbers (80 for http and 443 for https)"
    },
    {
        "link": "https://stackoverflow.com/questions/50835321/best-practice-of-directly-go-to-an-url-when-using-window-history",
        "document": "I'm using to navigate between my Javascript pages. All works well, except when I want to go to a page by entering an url like https://www.myapp.com/Main (Main is an excisting page in my app). Offcourse it can't find the Main folder because it doesn't excist.\n\nMy approach would be:\n• Configure my .htaccess file to rewrite pathnames to $_GET parameters in PHP\n• In the or (before any other script is loaded), translate the $_GET parameters to Javascript by doing something like\n• Then navigate to the page in\n\nIs there any other or better way of doing this?"
    },
    {
        "link": "https://codedamn.com/news/javascript/window-location-explained",
        "document": "JavaScript is an essential programming language for web development, and one of its most powerful features is the ability to manipulate the browser’s window object. In this blog post, we’ll dive into the window.location object and examine how it can be used to navigate, manipulate, and gather information about the browser’s current URL. By the end of this post, you’ll have a complete understanding of the window.location object and its methods, properties, and use cases.\n\nThe object is a part of the window object and provides information about the current document’s URL. It also allows you to manipulate and navigate the browser’s history. The object has several properties and methods that can be used to access and modify the current URL.\n\nLet’s take a look at the properties of the object and what information they provide:\n• : The full URL of the current document, including the protocol, domain, port, path, and query string. For example, if the current URL is , the value of would be the same.\n• : The protocol used by the current URL, such as or .\n• : The full domain and port of the current URL, such as (where 80 is the default port number for HTTP).\n• : The domain name of the current URL, such as .\n• : The port number used by the current URL. If no port number is specified, this property will be an empty string.\n• : The path of the current URL, such as .\n• : The query string of the current URL, including the leading question mark (?), such as .\n• : The URL fragment identifier, including the leading hash symbol (#), such as .\n\nThe object also provides several methods to manipulate and navigate the browser’s history:\n• : Loads a new document at the specified URL.\n• : Replaces the current document with a new one at the specified URL without adding an entry to the browser’s history.\n• : Reloads the current document. If the parameter is set to , the browser will bypass the cache and request the document from the server.\n\nNow that we’ve explored the properties and methods of the object, let’s see how they can be used in practice.\n\nTo navigate to a new page, you can use the method or simply set the property to the desired URL. For example:\n\nBoth of these methods have the same effect: they load the specified URL in the current browser window.\n\nTo reload the current page, you can use the method:\n\nIf you want to navigate to a new page without adding an entry to the browser’s history, you can use the method:\n\n// Replace the current page with a new one \n\n\n\nThis method is useful when you want to prevent users from using the back button to return to the previous page.\n\nTo access and manipulate the query string of the current URL, you can use the property. For example, you can retrieve the query string and parse its key-value pairs:\n\nQ: Can I use window.location to navigate to a different domain?\n\nA: Yes, you can use or set to a URL from a different domain. However, due to the same-origin policy, you won’t be able to access or manipulate the content of the other domain’s pages.\n\nQ: How can I get only the domain and protocol of the current URL?\n\nA: You can concatenate the and properties to get the full domain and protocol of the current URL, like this:\n\nQ: How can I change only the hash part of the current URL?\n\nA: You can set the property to the desired value:\n\nThis will update the URL’s hash without reloading the page.\n\nQ: What is the difference between window.location.assign() and window.location.replace()?\n\nA: The method loads a new URL and adds it to the browser’s history, allowing the user to navigate back to the previous page using the back button. The method loads a new URL and replaces the current page in the browser’s history, preventing the user from navigating back to the previous page.\n\nWe hope this guide has provided you with a comprehensive understanding of the JavaScript window.location object and its various properties and methods. As you continue to develop your JavaScript skills and work on web projects, you’ll find that window.location is an essential tool for managing and navigating browser URLs."
    }
]