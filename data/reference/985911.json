[
    {
        "link": "https://stackoverflow.com/questions/54281174/how-to-make-django-model-choice-field-human-readable",
        "document": "To learn more, see our tips on writing great answers .\n\nThanks for contributing an answer to Stack Overflow!\n\nBy clicking “Post Your Answer”, you agree to our terms of service and acknowledge you have read our privacy policy."
    },
    {
        "link": "https://docs.djangoproject.com/en/5.1/ref/models/fields",
        "document": "This document contains all the API references of including the field options and field types Django offers.\n\nThe following arguments are available to all field types. All are optional. If , Django will store empty values as in the database. Default is . Avoid using on string-based fields such as and . If a string-based field has , that means it has two possible values for “no data”: , and the empty string. In most cases, it’s redundant to have two possible values for “no data;” the Django convention is to use the empty string, not . One exception is when a has both and set. In this situation, is required to avoid unique constraint violations when saving multiple objects with blank values. For both string-based and non-string-based fields, you will also need to set if you wish to permit empty values in forms, as the parameter only affects database storage (see ). When using the Oracle database backend, the value will be stored to denote the empty string regardless of this attribute. If , the field is allowed to be blank. Default is . Note that this is different than . is purely database-related, whereas is validation-related. If a field has , form validation will allow entry of an empty value. If a field has , the field will be required. can be used with fields having , but this will require implementing on the model in order to programmatically supply any missing values. A mapping or iterable in the format described below to use as choices for this field. If choices are given, they’re enforced by model validation and the default form widget will be a select box with these choices instead of the standard text field. If a mapping is given, the key element is the actual value to be set on the model, and the second element is the human readable name. For example: You can also pass a sequence consisting itself of iterables of exactly two items (e.g. ). The first element in each tuple is the actual value to be set on the model, and the second element is the human-readable name. For example: can also be defined as a callable that expects no arguments and returns any of the formats described above. For example: Passing a callable for can be particularly handy when, for example, the choices are:\n• None the result of I/O-bound operations (which could potentially be cached), such as querying a table in the same or an external database, or accessing the choices from a static file.\n• None a list that is mostly stable but could vary from time to time or from project to project. Examples in this category are using third-party apps that provide a well-known inventory of values, such as currencies, countries, languages, time zones, etc. Support for mappings and callables was added. Generally, it’s best to define choices inside a model class, and to define a suitably-named constant for each value: Though you can define a choices list outside of a model class and then refer to it, defining the choices and names for each choice inside the model class keeps all of that information with the class that uses it, and helps reference the choices (e.g, will work anywhere that the model has been imported). You can also collect your available choices into named groups that can be used for organizational purposes: The key of the mapping is the name to apply to the group and the value is the choices inside that group, consisting of the field value and a human-readable name for an option. Grouped options may be combined with ungrouped options within a single mapping (such as the option in this example). You can also use a sequence, e.g. a list of 2-tuples: Note that choices can be any sequence object – not necessarily a list or tuple. This lets you construct choices dynamically. But if you find yourself hacking to be dynamic, you’re probably better off using a proper database table with a . is meant for static data that doesn’t change much, if ever. A new migration is created each time the order of changes. For each model field that has set, Django will normalize the choices to a list of 2-tuples and add a method to retrieve the human-readable name for the field’s current value. See in the database API documentation. Unless is set on the field along with a then a label containing will be rendered with the select box. To override this behavior, add a tuple to containing ; e.g. . Alternatively, you can use an empty string instead of where this makes sense - such as on a . In addition, Django provides enumeration types that you can subclass to define choices in a concise way: These work similar to from Python’s standard library, but with some modifications:\n• None Enum member values are a tuple of arguments to use when constructing the concrete data type. Django supports adding an extra string value to the end of this tuple to be used as the human-readable name, or . The can be a lazy translatable string. Thus, in most cases, the member value will be a 2-tuple. See below for an example of subclassing choices using a more complex data type. If a tuple is not provided, or the last item is not a (lazy) string, the is automatically generated from the member name.\n• None A property is added on values, to return the human-readable name.\n• None A number of custom properties are added to the enumeration classes – , , , and – to make it easier to access lists of those separate parts of the enumeration. These property names cannot be used as member names as they would conflict.\n• None The use of is enforced to ensure that values cannot be defined multiple times. This is unlikely to be expected in choices for a field. Note that using , , or to access or lookup enum members work as expected, as do the and properties on the members. If you don’t need to have the human-readable names translated, you can have them inferred from the member name (replacing underscores with spaces and using title-case): Since the case where the enum values need to be integers is extremely common, Django provides an class. For example: It is also possible to make use of the Enum Functional API with the caveat that labels are automatically generated as highlighted above: [(1, 'First'), (2, 'Second'), (3, 'Third')] If you require support for a concrete data type other than or , you can subclass and the required concrete data type, e.g. for use with : There are some additional caveats to be aware of:\n• None Because an enumeration with a concrete data type requires all values to match the type, overriding the blank label cannot be achieved by creating a member with a value of . Instead, set the attribute on the class: Support for using enumeration types directly in the was added. The name of the database column to use for this field. If this isn’t given, Django will use the field’s name. If your database column name is an SQL reserved word, or contains characters that aren’t allowed in Python variable names – notably, the hyphen – that’s OK. Django quotes column and table names behind the scenes. The database-computed default value for this field. This can be a literal value or a database function, such as : More complex expressions can be used, as long as they are made from literals and database functions: Database defaults cannot reference other fields or models. For example, this is invalid: If both and are set, will take precedence when creating instances in Python code. will still be set at the database level and will be used when inserting rows outside of the ORM or when adding a new field in a migration. If a field has a without a set and no value is assigned to the field, a object is returned as the field value on unsaved model instances. The actual value for the field is determined by the database when the model instance is saved. If , a database index will be created for this field. Use the option instead. Where possible, use the option instead. In nearly all cases, provides more functionality than . may be deprecated in the future. The name of the database tablespace to use for this field’s index, if this field is indexed. The default is the project’s setting, if set, or the of the model, if any. If the backend doesn’t support tablespaces for indexes, this option is ignored. The default value for the field. This can be a value or a callable object. If callable it will be called every time a new object is created. The default can’t be a mutable object (model instance, , , etc.), as a reference to the same instance of that object would be used as the default value in all new model instances. Instead, wrap the desired default in a callable. For example, if you want to specify a default for , use a function: s can’t be used for field options like because they can’t be serialized by migrations. See that documentation for other caveats. For fields like that map to model instances, defaults should be the value of the field they reference ( unless is set) instead of model instances. The default value is used when new model instances are created and a value isn’t provided for the field. When the field is a primary key, the default is also used when the field is set to . The default value can also be set at the database level with . If , the field will not be displayed in the admin or any other . It will also be skipped during model validation. Default is . The argument lets you override the default messages that the field will raise. Pass in a dictionary with keys matching the error messages you want to override. Error message keys include , , , , , and . Additional error message keys are specified for each field in the Field types section below. These error messages often don’t propagate to forms. See Considerations regarding model’s error_messages. Extra “help” text to be displayed with the form widget. It’s useful for documentation even if your field isn’t used on a form. Note that this value is not HTML-escaped in automatically-generated forms. This lets you include HTML in if you so desire. For example: \"Please use the following format: <em>YYYY-MM-DD</em>.\" Alternatively you can use plain text and to escape any HTML special characters. Ensure that you escape any help text that may come from untrusted users to avoid a cross-site scripting attack. If , this field is the primary key for the model. If you don’t specify for any field in your model, Django will automatically add a field to hold the primary key, so you don’t need to set on any of your fields unless you want to override the default primary-key behavior. The type of auto-created primary key fields can be specified per app in or globally in the setting. For more, see Automatic primary key fields. implies and . Only one primary key is allowed on an object. The primary key field is read-only. If you change the value of the primary key on an existing object and then save it, a new object will be created alongside the old one. The primary key field is set to when an object. If , this field must be unique throughout the table. This is enforced at the database level and by model validation. If you try to save a model with a duplicate value in a field, a will be raised by the model’s method. This option is valid on all field types except and . Note that when is , you don’t need to specify , because implies the creation of an index. Like , but requires the field to be unique with respect to the month. A human-readable name for the field. If the verbose name isn’t given, Django will automatically create it using the field’s attribute name, converting underscores to spaces. See Verbose field names. A list of validators to run for this field. See the validators documentation for more information."
    },
    {
        "link": "https://stackoverflow.com/questions/54909925/get-the-actual-value-of-the-human-readable-name-from-choices-in-django-models",
        "document": "It ain't pretty, but you could reverse lookup via the models meta attribute:\n\nYou can modify it to be case insensitive (so that it would work in your example)\n• Human readable strings must not be unique!\n• If the human readable string can not be found in the choices, it returns a dummy ('NUL') - but this could be added at a later time and lead to confusion"
    },
    {
        "link": "https://django-model-utils.readthedocs.io/en/latest/utilities.html",
        "document": "Django 3.0 adds enumeration types. These provide most of the same features as . provides some conveniences for setting on a Django model field: A object is initialized with any number of choices. In the simplest case, each choice is a string; that string will be used both as the database representation of the choice, and the human-readable representation. Note that you can access options as attributes on the object: . But you may want your human-readable versions translated, in which case you need to separate the human-readable version from the DB representation. In this case you can provide choices as two-tuples: But what if your database representation of choices is constrained in a way that would hinder readability of your code? For instance, you may need to use an rather than a , or you may want the database to order the values in your field in some specific way. In this case, you can provide your choices as triples, where the first element is the database representation, the second is a valid Python identifier you will use in your code as a constant, and the third is the human-readable version: You can index into a instance to translate a database representation to its display name: Option groups can also be used with ; in that case each argument is a tuple consisting of the option group name and a list of options, where each option in the list is either a string, a two-tuple, or a triple as outlined above. For example: Choices can be concatenated with the operator, both to other Choices instances and other iterable objects that could be converted into Choices: Should you wish to provide a subset of choices for a field, for instance, you have a form class to set some model instance to a failed state, and only wish to show the user the failed outcomes from which to select, you can use the method: The attribute on the model field can then be set to , thus allowing the subset to be defined in close proximity to the definition of all the choices, and reused elsewhere as required.\n\nA can be added to a model to track changes in model fields. A allows querying for field changes since a model instance was last saved. An example of applying to a model: 1.3.0 introduced the object for tracking changes to model field values. Unfortunately suffered from some serious flaws in its handling of fields, potentially resulting in many extra database queries if a field was tracked. In order to avoid breaking API backwards-compatibility, retains the previous behavior but is deprecated, and has been introduced to provide better handling. All uses of should be replaced by . Summary of differences between and :\n• None The previous value returned for a tracked field will now be the raw ID rather than the full object (avoiding extra database queries). (GH-43)\n• None The method no longer returns the empty dictionary for all unsaved instances; rather, is considered to be the initial value of all fields if the model has never been saved, thus on an unsaved instance will return a dictionary containing all fields whose current value is not .\n• None The method no longer crashes after an object’s first save. (GH-53). There are multiple methods available for checking for changes in model fields. Returns the value of the given field during the last save: Returns when the model instance isn’t saved yet. If a field is deferred, calling will load the previous value from the database. Returns if the given field has changed since the last save. The method expects a single field: The method relies on to determine whether a field’s values has changed. If a field is deferred and has been assigned locally, calling will load the previous value from the database to perform the comparison. Returns a dictionary of all fields that have been changed since the last save and the values of the fields during the last save: The method relies on to determine which fields have changed. A fields parameter can be given to to limit tracking to specific fields: An example using the model specified above: It should be noted that a generic FieldTracker tracks Foreign Keys by db_column name, rather than model field name, and would be accessed as follows: To find the db_column names of your model (using the above example): The model field name may be used when tracking with a specific tracker: But according to issue #195 this is not recommended for accessing Foreign Key Fields. The field tracker methods may also be used in and signal handlers to identify field changes on model save. Due to the implementation of , signal handlers relying on field tracker methods should only be registered after model creation. This is how tracks field changes on call.\n• None In handler patches , and methods to reset initial state for tracked fields.\n• None In the patched method saves initial values for tracked fields.\n• None changes in order to store auto updated timestamp. Complete list of saved fields is now known.\n• None does nothing interesting except calling .\n• None Decorated method calls and all fields that have values different to initial are considered as changed.\n• None sends signal, saves instance to database and sends signal. All receivers can query for a set of changed fields etc.\n• None After return resets initial state for updated fields (if no passed - whole initial state is reset).\n• None call causes initial state reset like for .\n• None Field value is changed if it differs from current database value.\n• None Field value was changed if value has changed in database and field state didn’t reset. # name is not changed again Current implementation resets fields state after signals emitting. This is convenient for “outer” code like in example above, but does not help when model method is overridden. # changed state has been reset here, so we need to store previous state somewhere else provides a context manager interface to postpone fields state reset in complicate situations.\n• None By default, all fields are reset, but field list can be provided\n• None Fields are counted separately depending on field list passed to context managers\n• None Tracker can be used as decorator\n• None Different instances have their own context state\n• None Different trackers in same instance have separate context state # Restrict a set of fields to reset here"
    },
    {
        "link": "https://geeksforgeeks.org/how-to-use-django-field-choices",
        "document": "Django Field Choices. According to documentation Field Choices are a sequence consisting itself of iterables of exactly two items (e.g. [(A, B), (A, B) …]) to use as choices for some field. For example, consider a field semester which can have options as { 1, 2, 3, 4, 5, 6 } only. Choices limits the input from the user to the particular values specified in . If choices are given, they’re enforced by model validation and the default form widget will be a select box with these choices instead of the standard text field. Choices can be any sequence object – not necessarily a list or tuple.\n\nThe first element in each tuple is the actual value to be set on the model, and the second element is the human-readable name.\n\n For example,\n\nLet us create a choices field with above semester in our django project named geeksforgeeks.\n\nLet us check in admin panel how semester is created.\n\n \n\n One can also collect your available choices into named groups that can be used for organizational purposes:\n\nThe first element in each tuple is the name to apply to the group. The second element is an iterable of 2-tuples, with each 2-tuple containing a value and a human-readable name for an option. Grouped options may be combined with ungrouped options within a single list (such as the unknown option in this example).\n\n For each model field that has choices set, Django will add a method to retrieve the human-readable name for the field’s current value. See in the database API documentation."
    },
    {
        "link": "https://stackoverflow.com/questions/28945327/django-rest-framework-with-choicefield",
        "document": "I have a few fields in my user model that are choice fields and am trying to figure out how to best implement that into Django Rest Framework.\n\nBelow is some simplified code to show what I'm doing.\n\nEssentially what I'm trying to do is to have the get/post/put methods use the display value of the choice field instead of the code, looking something like the below JSON.\n\nHow would I go about doing that? The above code does not work. Before I had something like this working for GET, but for POST/PUT it was giving me errors. I'm looking for general advice on how to do this, it seems like it would be something common, but I can't find examples. Either that or I'm doing something terribly wrong."
    },
    {
        "link": "https://vindevs.com/blog/how-to-use-django-field-choices-with-code-examples-p60",
        "document": "Django provides a powerful framework for defining models and their associated fields. One of the useful features is the ability to define \"choices\" for a field, which limits the possible values that can be assigned to that field. This feature is particularly helpful for fields like status indicators, categories, or any field where you want to constrain the options to a predefined set.\n\nDjango models are the foundation of any Django project, allowing developers to define the structure of the database through Python code. Each field in a model represents a column in a database table.\n\nThe option in a Django model field restricts the set of allowed values for that field to a predefined list. Each choice is a tuple, where the first element is the actual value stored in the database, and the second element is the human-readable name displayed in forms and the Django admin.\n\nThe most common way to define choices in Django is by using tuples. Each choice is represented as a tuple where: - The first element is the value stored in the database. - The second element is the human-readable label.\n\nStarting from Django 3.0, you can also use Python classes to define choices. This method is more robust and readable.\n\nIn this example, the field will only accept the values , , or . When rendered in a form, these values will appear as \"Not Started\", \"In Progress\", and \"Done\" respectively.\n• Use meaningful constants for the choices to avoid magic numbers or strings.\n• Keep the choices tuples or enums well-organized and readable.\n• Consider using Django's for internationalization of choice labels.\n\nDjango provides a handy method called for model instances to retrieve the human-readable name of the choice.\n\nIn a Django template, you can use the method to display the choice's label:\n\nWhen you use choices in a model, Django automatically generates a select input in forms. Here's how it looks:\n\nIf you want more control over the form field, you can explicitly define a :\n\nIn the Django admin, choice fields automatically render as dropdowns, making it easy to select an option.\n\nYou can customize how the choices are displayed in the Django admin by using the attribute and methods like .\n\nYou can filter and query your models based on the choice field values.\n\nDjango's admin interface allows you to add filters for choice fields easily.\n\nIf needed, you can create custom validators to enforce additional rules on choice fields.\n\nCustom validation logic can be used to ensure that only specific choices are allowed under certain conditions.\n\nYou can dynamically extend choices based on some conditions or user input.\n\nYou can override the default choices by modifying the attribute at runtime.\n\nTo make your application multilingual, use Django’s translation utilities:\n• Always use for choice labels.\n• Ensure that your translations are accurate and culturally appropriate.\n\nWhen working with Django REST Framework (DRF), you can serialize choice fields easily:\n\ncan include the human-readable choice label in your API response by overriding the serializer methods.\n\nUnit tests are essential to ensure that your choice fields behave as expected:\n\nMake sure to test edge cases, such as invalid choices or dynamically added choices.\n\n13. Common Mistakes and How to Avoid Them\n• Hardcoding Choices: Avoid hardcoding choices outside of your models.\n• Invalid Choices: Ensure that the choice values stored in the database are valid.\n• Use Django's framework to validate your models.\n• Ensure that your migrations reflect the latest changes to choices.\n\nYou can generate choices dynamically based on external data or user input.\n\nChoices can be related to other model fields, providing more complex data relationships.\n\nDjango's field option is a powerful feature that ensures data integrity and provides an intuitive interface for users. Whether you're working with static or dynamic choices, it's essential to follow best practices for maintainability and scalability.\n• Use constants or enums for defining choices.\n• Integrate choices seamlessly into your forms, admin, and APIs.\n• Test thoroughly to ensure that all choice-related functionality works as expected."
    },
    {
        "link": "https://stackoverflow.com/questions/32018147/django-choice-field-best-practice-in-web-services",
        "document": "This is my model. What I want is how do/should I send response data, I mean format.(JSON)\n\nthe problem from 1st type is that I have to maintain this tuple/mapping in frontend as-well (for end user visualization) and id for internal mapping, api-DB interaction.\n\nfrom 2nd type I dont know how would I map if some api post/put some data to my system, I wont know which id this category belong to.\n\nI need suggestion from people like you who have rich experience in web service development and can guide me to develop APIs in best possible way and this could be helpful for future readers who are newbie or learning things."
    },
    {
        "link": "https://docs.djangoproject.com/en/5.1/howto/custom-model-fields",
        "document": "The model reference documentation explains how to use Django’s standard field classes – , , etc. For many purposes, those classes are all you’ll need. Sometimes, though, the Django version won’t meet your precise requirements, or you’ll want to use a field that is entirely different from those shipped with Django. Django’s built-in field types don’t cover every possible database column type – only the common types, such as and . For more obscure column types, such as geographic polygons or even user-created types such as PostgreSQL custom types, you can define your own Django subclasses. Alternatively, you may have a complex Python object that can somehow be serialized to fit into a standard database column type. This is another case where a subclass will help you use your object with your models. Creating custom fields requires a bit of attention to detail. To make things easier to follow, we’ll use a consistent example throughout this document: wrapping a Python object representing the deal of cards in a hand of Bridge. Don’t worry, you don’t have to know how to play Bridge to follow this example. You only need to know that 52 cards are dealt out equally to four players, who are traditionally called north, east, south and west. Our class looks something like this: # Input parameters are lists of cards ('Ah', '9s', etc.) This is an ordinary Python class, with nothing Django-specific about it. We’d like to be able to do things like this in our models (we assume the attribute on the model is an instance of ): We assign to and retrieve from the attribute in our model just like any other Python class. The trick is to tell Django how to handle saving and loading such an object. In order to use the class in our models, we do not have to change this class at all. This is ideal, because it means you can easily write model support for existing classes where you cannot change the source code. You might only be wanting to take advantage of custom database column types and deal with the data as standard Python types in your models; strings, or floats, for example. This case is similar to our example and we’ll note any differences as we go along.\n\nLet’s start with model fields. If you break it down, a model field provides a way to take a normal Python object – string, boolean, , or something more complex like – and convert it to and from a format that is useful when dealing with the database. (Such a format is also useful for serialization, but as we’ll see later, that is easier once you have the database side under control). Fields in a model must somehow be converted to fit into an existing database column type. Different databases provide different sets of valid column types, but the rule is still the same: those are the only types you have to work with. Anything you want to store in the database must fit into one of those types. Normally, you’re either writing a Django field to match a particular database column type, or you will need a way to convert your data to, say, a string. For our example, we could convert the card data to a string of 104 characters by concatenating all the cards together in a predetermined order – say, all the north cards first, then the east, south and west cards. So objects can be saved to text or character columns in the database. All of Django’s fields (and when we say fields in this document, we always mean model fields and not form fields) are subclasses of . Most of the information that Django records about a field is common to all fields – name, help text, uniqueness and so forth. Storing all that information is handled by . We’ll get into the precise details of what can do later on; for now, suffice it to say that everything descends from and then customizes key pieces of the class behavior. It’s important to realize that a Django field class is not what is stored in your model attributes. The model attributes contain normal Python objects. The field classes you define in a model are actually stored in the class when the model class is created (the precise details of how this is done are unimportant here). This is because the field classes aren’t necessary when you’re just creating and modifying attributes. Instead, they provide the machinery for converting between the attribute value and what is stored in the database or sent to the serializer. Keep this in mind when creating your own custom fields. The Django subclass you write provides the machinery for converting between your Python instances and the database/serializer values in various ways (there are differences between storing a value and using a value for lookups, for example). If this sounds a bit tricky, don’t worry – it will become clearer in the examples below. Just remember that you will often end up creating two classes when you want a custom field:\n• None The first class is the Python object that your users will manipulate. They will assign it to the model attribute, they will read from it for displaying purposes, things like that. This is the class in our example.\n• None The second class is the subclass. This is the class that knows how to convert your first class back and forth between its permanent storage form and the Python form.\n\nWhen planning your subclass, first give some thought to which existing class your new field is most similar to. Can you subclass an existing Django field and save yourself some work? If not, you should subclass the class, from which everything is descended. Initializing your new field is a matter of separating out any arguments that are specific to your case from the common arguments and passing the latter to the method of (or your parent class). In our example, we’ll call our field . (It’s a good idea to call your subclass , so it’s easily identifiable as a subclass.) It doesn’t behave like any existing field, so we’ll subclass directly from : Our accepts most of the standard field options (see the list below), but we ensure it has a fixed length, since it only needs to hold 52 card values plus their suits; 104 characters in total. Many of Django’s model fields accept options that they don’t do anything with. For example, you can pass both and to a and it will ignore the parameter ( being set implies ). No error is raised in this case. This behavior simplifies the field classes, because they don’t need to check for options that aren’t necessary. They pass all the options to the parent class and then don’t use them later on. It’s up to you whether you want your fields to be more strict about the options they select, or to use the more permissive behavior of the current fields. The method takes the following parameters:\n• None : Used for related fields (like ). For advanced use only.\n• None : If , the field will not be serialized when the model is passed to Django’s serializers. Defaults to .\n• None : Only for index creation, if the backend supports tablespaces. You can usually ignore this option.\n• None : if the field was automatically created, as for the used by model inheritance. For advanced use only. All of the options without an explanation in the above list have the same meaning they do for normal Django fields. See the field documentation for examples and details. The counterpoint to writing your method is writing the method. It’s used during model migrations to tell Django how to take an instance of your new field and reduce it to a serialized form - in particular, what arguments to pass to to recreate it. If you haven’t added any extra options on top of the field you inherited from, then there’s no need to write a new method. If, however, you’re changing the arguments passed in (like we are in ), you’ll need to supplement the values being passed. returns a tuple of four items: the field’s attribute name, the full import path of the field class, the positional arguments (as a list), and the keyword arguments (as a dict). Note this is different from the method for custom classes which returns a tuple of three things. As a custom field author, you don’t need to care about the first two values; the base class has all the code to work out the field’s attribute name and import path. You do, however, have to care about the positional and keyword arguments, as these are likely the things you are changing. For example, in our class we’re always forcibly setting max_length in . The method on the base class will see this and try to return it in the keyword arguments; thus, we can drop it from the keyword arguments for readability: If you add a new keyword argument, you need to write code in that puts its value into yourself. You should also omit the value from when it isn’t necessary to reconstruct the state of the field, such as when the default value is being used: # Only include kwarg if it's not the default More complex examples are beyond the scope of this document, but remember - for any configuration of your Field instance, must return arguments that you can pass to to reconstruct that state. Pay extra attention if you set new default values for arguments in the superclass; you want to make sure they’re always included, rather than disappearing if they take on the old default value. In addition, try to avoid returning values as positional arguments; where possible, return values as keyword arguments for maximum future compatibility. If you change the names of things more often than their position in the constructor’s argument list, you might prefer positional, but bear in mind that people will be reconstructing your field from the serialized version for quite a while (possibly years), depending how long your migrations live for. You can see the results of deconstruction by looking in migrations that include the field, and you can test deconstruction in unit tests by deconstructing and reconstructing the field: You can override to customize attributes of a field that don’t affect a column definition. It’s used during model migrations to detect no-op operations. You can’t change the base class of a custom field because Django won’t detect the change and make a migration for it. For example, if you start with: and then decide that you want to use instead, you can’t change the subclass like this: Instead, you must create a new custom field class and update your models to reference it: As discussed in removing fields, you must retain the original class as long as you have migrations that reference it. As always, you should document your field type, so users will know what it is. In addition to providing a docstring for it, which is useful for developers, you can also allow users of the admin app to see a short description of the field type via the django.contrib.admindocs application. To do this provide descriptive text in a class attribute of your custom field. In the above example, the description displayed by the application for a will be ‘A hand of cards (bridge style)’. In the display, the field description is interpolated with which allows the description to incorporate arguments of the field. For example, the description for is: Once you’ve created your subclass, you might consider overriding a few standard methods, depending on your field’s behavior. The list of methods below is in approximately decreasing order of importance, so start from the top. Say you’ve created a PostgreSQL custom type called . You can subclass and implement the method, like so: Once you have , you can use it in any model, just like any other type: If you aim to build a database-agnostic application, you should account for differences in database column types. For example, the date/time column type in PostgreSQL is called , while the same column in MySQL is called . You can handle this in a method by checking the attribute. Current built-in vendor names are: , , , and . The and methods are called by Django when the framework constructs the statements for your application – that is, when you first create your tables. The methods are also called when constructing a clause that includes the model field – that is, when you retrieve data using QuerySet methods like , , and and have the model field as an argument. Some database column types accept parameters, such as , where the parameter represents the maximum column length. In cases like these, it’s more flexible if the parameter is specified in the model rather than being hard-coded in the method. For example, it wouldn’t make much sense to have a , shown here: # This is a silly example of hard-coded parameters. The better way of doing this would be to make the parameter specifiable at run time – i.e., when the class is instantiated. To do that, implement , like so: # This is a much more flexible example. Finally, if your column requires truly complex SQL setup, return from . This will cause Django’s SQL creation code to skip over this field. You are then responsible for creating the column in the right table in some other way, but this gives you a way to tell Django to get out of the way. The method is called by fields such as and that point to another field to determine their database column data types. For example, if you have an , you also need the foreign keys that point to that field to use the same data type: If your custom class deals with data structures that are more complex than strings, dates, integers, or floats, then you may need to override and . If present for the field subclass, will be called in all circumstances when the data is loaded from the database, including in aggregates and calls. is called by deserialization and during the method used from forms. As a general rule, should deal gracefully with any of the following arguments:\n• None An instance of the correct type (e.g., in our ongoing example). In our class, we’re storing the data as a field in the database, so we need to be able to process strings and in the . In , we need to also handle instances: \"\"\"Takes a string of cards and splits into a full hand.\"\"\" Notice that we always return a instance from these methods. That’s the Python object type we want to store in the model’s attribute. For , if anything goes wrong during value conversion, you should raise a exception. Since using a database requires conversion in both ways, if you override you also have to override to convert Python objects back to query values. If your custom field uses the , or types for MySQL, you must make sure that always returns a string type. MySQL performs flexible and unexpected matching when a query is performed on these types and the provided value is an integer, which can cause queries to include unexpected objects in their results. This problem cannot occur if you always return a string type from . Some data types (for example, dates) need to be in a specific format before they can be used by a database backend. is the method where those conversions should be made. The specific connection that will be used for the query is passed as the parameter. This allows you to use backend-specific conversion logic if it is required. For example, Django uses the following method for its : In case your custom field needs a special conversion when being saved that is not the same as the conversion used for normal query parameters, you can override . If you want to preprocess the value just before saving, you can use . For example, Django’s uses this method to set the attribute correctly in the case of or . If you do override this method, you must return the value of the attribute at the end. You should also update the model’s attribute if you make any changes to the value so that code holding references to the model will always see the correct value. Specifying the form field for a model field¶ To customize the form field used by , you can override . The form field class can be specified via the and arguments; the latter is used if the field has choices specified, the former otherwise. If these arguments are not provided, or will be used. All of the dictionary is passed directly to the form field’s method. Normally, all you need to do is set up a good default for the (and maybe ) argument and then delegate further handling to the parent class. This might require you to write a custom form field (and even a form widget). See the forms documentation for information about this. Continuing our ongoing example, we can write the method as: # This is a fairly standard way to set up some defaults # while letting the caller override them. This assumes we’ve imported a field class (which has its own default widget). This document doesn’t cover the details of writing custom form fields. If you have created a method, you don’t need to worry about – it won’t be used much. Sometimes, though, your database storage is similar in type to some other field, so you can use that other field’s logic to create the right column. No matter which database backend we are using, this will mean that and other SQL commands create the right column type for storing a string. If returns a string that is not known to Django for the database backend you are using – that is, it doesn’t appear in – the string will still be used by the serializer, but the default method will return . See the documentation of for reasons why this might be useful. Putting a descriptive string in as the type of the field for the serializer is a useful idea if you’re ever going to be using the serializer output in some other place, outside of Django. To customize how the values are serialized by a serializer, you can override . Using is the best way to get the field’s value prior to serialization. For example, since uses strings for its data storage anyway, we can reuse some existing conversion code: Writing a custom field can be a tricky process, particularly if you’re doing complex conversions between your Python types and your database and serialization formats. Here are a couple of tips to make things go more smoothly:\n• None Look at the existing Django fields (in django/db/models/fields/__init__.py) for inspiration. Try to find a field that’s similar to what you want and extend it a little bit, instead of creating an entirely new field from scratch.\n• None Put a method on the class you’re wrapping up as a field. There are a lot of places where the default behavior of the field code is to call on the value. (In our examples in this document, would be a instance, not a ). So if your method automatically converts to the string form of your Python object, you can save yourself a lot of work.\n\nIn addition to the above methods, fields that deal with files have a few other special requirements which must be taken into account. The majority of the mechanics provided by , such as controlling database storage and retrieval, can remain unchanged, leaving subclasses to deal with the challenge of supporting a particular type of file. Django provides a class, which is used as a proxy to the file’s contents and operations. This can be subclassed to customize how the file is accessed, and what methods are available. It lives at , and its default behavior is explained in the file documentation. Once a subclass of is created, the new subclass must be told to use it. To do so, assign the new subclass to the special attribute of the subclass. In addition to the above details, there are a few guidelines which can greatly improve the efficiency and readability of the field’s code.\n• None The source for Django’s own (in django/db/models/fields/files.py) is a great example of how to subclass to support a particular type of file, as it incorporates all of the techniques described above.\n• None Cache file attributes wherever possible. Since files may be stored in remote storage systems, retrieving them may cost extra time, or even money, that isn’t always necessary. Once a file is retrieved to obtain some data about its content, cache as much of that data as possible to reduce the number of times the file must be retrieved on subsequent calls for that information."
    },
    {
        "link": "https://django-rest-framework.org/tutorial/1-serialization",
        "document": ""
    }
]