[
    {
        "link": "https://geeksforgeeks.org/python-itertools-product",
        "document": "In the terms of Mathematics Cartesian Product of two sets is defined as the set of all ordered pairs (a, b) where a belongs to A and b belongs to B. Consider the below example for better understanding.\n\nExamples:\n\n\n\nThe above solution can be done by looping but we will use a special Python library itertools.product() for finding the Cartesian Product. Let’s go through the working and use cases of this Python library.\n\n\n\nWhat are Itertools in Python?\n\n\n\nPython Itertools is a library in Python which consists of multiple methods that are used in various iterators to compute a fast and code efficient solution.\n\n\n\n\n\nNote: For more information, refer to Python Itertools\n\n\n\nWhat does itertools.product() do?\n\nitertools.product() is used to find the cartesian product from the given iterator, output is lexicographic ordered. The itertools.product() can used in two different ways:\n• itertools.product(*iterables, repeat=1):\n\n It returns the cartesian product of the provided iterable with itself for the number of times specified by the optional keyword “repeat”. For example, product(arr, repeat=3) means the same as product(arr, arr, arr).\n• itertools.product(*iterables):\n\n It returns the cartesian product of all the iterable provided as the argument. For example, product(arr1, arr2, arr3)."
    },
    {
        "link": "https://docs.python.org/3/library/itertools.html",
        "document": ""
    },
    {
        "link": "https://note.nkmk.me/en/python-itertools-product",
        "document": "In Python, you can generate a Cartesian product of multiple lists using .\n\nAll sample code in this article assumes that the and modules have been imported. The module is used to make the results easier to read.\n\nWhat is the Cartesian product?\n\nThe Cartesian product is the set of all combinations of elements from multiple sets.\n\nWhen you pass two lists as arguments, returns an object of type , which is an iterator. Therefore, the contents are not directly output by .\n\nYou can obtain the combination of elements from each list as a tuple using a loop. Note that if an iterator has reached the end and is iterated over again in the loop, nothing will be output.\n• Python for loop (with range, enumerate, zip, etc.)\n\nIt is also possible to get each element separately instead of a tuple.\n\nThe result is the same as when using nested loops (multiple loops).\n\nYou can also use to convert the result into a list of tuples.\n\nYou can pass multiple types of iterables (like , , , etc.) to .\n\nAs you can see from the result above, iterating over a dictionary returns the keys. If you need the values, use the method. See the following article for details.\n• Iterate dictionary (key and value) with for loop in Python\n\nSee the following article for more information about .\n• How to use range() in Python\n\nUse the same list (iterable) repeatedly:\n\nYou can specify the number of repetitions in the keyword argument, . The same iterable is used repeatedly to generate a Cartesian product.\n\nSame as the following example without .\n\nIf multiple iterables are specified:\n\nSame as the following example. Note that with , the order of arguments is instead of .\n\nAs mentioned above, multiple loops (nested loops) give the same result as .\n\nAs you can see below, is actually slower than nested loops.\n\nThe results may differ depending on the number of elements in the iterable and the number of loops, but following Q&A on Stack Overflow also answers that is slower.\n\nThe following examples use the Jupyter Notebook magic command . Note that these will not work if run as Python scripts.\n\nExample using a double loop with 1000 elements\n\nThe result of is faster to unpack.\n\nNested loops are about the same (slightly faster) as when unpacked.\n\nIt's faster not to unpack when using a generator expression, which is the generator version of list comprehension. However, it's still slower than using or nested loops.\n\nExample of calculating the sum of the products of each combination. Again, it's faster to use nested loops than .\n\nIn this example, passing the generator expression to is slightly faster.\n\nExample using a triple loop with 100 elements\n\nAgain, using nested loops is the fastest.\n\n# 31.6 ms ± 725 µs per loop (mean ± std. dev. of 7 runs, 10 loops each) # 26.2 ms ± 490 µs per loop (mean ± std. dev. of 7 runs, 10 loops each) # 12.9 ms ± 176 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) # 80.9 ms ± 1.27 ms per loop (mean ± std. dev. of 7 runs, 10 loops each) # 93.8 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\n\nAs mentioned above, the time difference between using a double loop with 1000 elements and a triple loop with 100 elements is just a few tens of milliseconds."
    },
    {
        "link": "https://stackoverflow.com/questions/61685177/how-to-get-cartesian-product-in-python-using-a-generator",
        "document": "Bottom line, is already an iterator. You don't need to write your own. (A generator is a kind of iterator.) For example:\n\nNow, to explain, it seems like you're misunderstanding something fundamental. A generator function returns a generator iterator. That's what you're seeing from the print:\n\nUse to cast an iterator to a list.\n\nNote how it's a nested list. That's because your yields one list then nothing else. On that note, that part makes no sense because casting to a list defeats the whole purpose of an iterator - lazy evaluation. If you actually wanted to yield the values from an iterator, you would use :\n\nIn this case is pointless, but if your actual is more complex, this might be what you actually want.\n• what's the difference between yield from and yield in python 3.3.2+\n• How to Use Generators and yield in Python - Real Python\n\nThis answer is partly based on juanpa.arrivillaga's comment"
    },
    {
        "link": "https://geeksforgeeks.org/python-construct-cartesian-product-tuple-list",
        "document": "The task of constructing the Cartesian product of tuple lists in Python involves iterating through multiple tuples and generating all possible ordered combinations of their elements. For example, given a list of tuples a = [(1, 2), (‘A’, ‘B’), (‘X’, ‘Y’)], the goal is to produce a list of all possible combinations, such as (1, ‘A’, ‘X’), (1, ‘A’, ‘Y’) and so on, covering every possible pairing of elements across the tuples.\n\nitertools.product() is the most efficient way to compute the Cartesian product of tuple lists. It works by expanding the input tuples into all possible combinations using an iterator, making it highly efficient for large datasets. This approach avoids excessive memory usage and performs significantly faster than other methods.\n\nExplanation: list(product(*a)) computes the Cartesian product of the unpacked tuples in a using itertools.product() and converts the result res into a list.\n\nList comprehension provides a concise and readable way to generate the Cartesian product of tuple lists. It constructs combinations using multiple nested loops in a single compact expression, making it an elegant but slightly less efficient solution compared to itertools.product(). It is best suited for smaller datasets due to its memory consumption.\n\nExplanation: list comprehension generate all possible combinations of elements from the tuples a[0], a[1] and a[2], storing them as tuples in the list res.\n\nfunctools.reduce() allows a functional programming approach to computing the Cartesian product. It recursively applies a lambda function to generate combinations, reducing the need for explicit loops. While this method can be concise, it is generally less efficient than itertools.product() and harder to read for larger datasets.\n\nExplanation: lambda function takes an accumulator acc and each tuple x from a and combines each element of acc with elements from x to form a new list of tuples.\n\nA traditional approach using nested loops can be used to generate the Cartesian product manually. This method is explicit and easy to understand, but it becomes impractical for a larger number of tuples since it requires manually handling multiple levels of iteration. It is less scalable and computationally expensive, making it the least efficient method.\n\nExplanation: For loop iterates over each element in the first tuple a[0], the second tuple a[1] and the third tuple a[2] , creating a tuple (i, j, k) for every combination of elements. Each resulting tuple is then appended to the list res."
    },
    {
        "link": "https://realpython.com/python-recursion",
        "document": "If you’re familiar with functions in Python, then you know that it’s quite common for one function to call another. In Python, it’s also possible for a function to call itself! A function that calls itself is said to be recursive, and the technique of employing a recursive function is called recursion.\n\nIt may seem peculiar for a function to call itself, but many types of programming problems are best expressed recursively. When you bump up against such a problem, recursion is an indispensable tool for you to have in your toolkit.\n\nBy the end of this tutorial, you’ll understand:\n• What it means for a function to call itself recursively\n• How the design of Python functions supports recursion\n• What factors to consider when choosing whether or not to solve a problem recursively\n• How to implement a recursive function in Python\n\nThen you’ll study several Python programming problems that use recursion and contrast the recursive solution with a comparable non-recursive one.\n\nThe word recursion comes from the Latin word recurrere, meaning to run or hasten back, return, revert, or recur. Here are some online definitions of recursion:\n• Dictionary.com: The act or process of returning or running back\n• Wiktionary: The act of defining an object (usually a function) in terms of that object itself\n• The Free Dictionary: A method of defining a sequence of objects, such as an expression, function, or set, where some number of initial objects are given and each successive object is defined in terms of the preceding objects A recursive definition is one in which the defined term appears in the definition itself. Self-referential situations often crop up in real life, even if they aren’t immediately recognizable as such. For example, suppose you wanted to describe the set of people that make up your ancestors. You could describe them this way: Notice how the concept that is being defined, ancestors, shows up in its own definition. This is a recursive definition. In programming, recursion has a very precise meaning. It refers to a coding technique in which a function calls itself.\n\nMost programming problems are solvable without recursion. So, strictly speaking, recursion usually isn’t necessary. However, some situations particularly lend themselves to a self-referential definition—for example, the definition of ancestors shown above. If you were devising an algorithm to handle such a case programmatically, a recursive solution would likely be cleaner and more concise. Traversal of tree-like data structures is another good example. Because these are nested structures, they readily fit a recursive definition. A non-recursive algorithm to walk through a nested structure is likely to be somewhat clunky, while a recursive solution will be relatively elegant. An example of this appears later in this tutorial. On the other hand, recursion isn’t for every situation. Here are some other factors to consider:\n• For some problems, a recursive solution, though possible, will be awkward rather than elegant.\n• Recursive implementations often consume more memory than non-recursive ones.\n• In some cases, using recursion may result in slower execution time. Typically, the readability of the code will be the biggest determining factor. But it depends on the circumstances. The examples presented below should help you get a feel for when you should choose recursion.\n\nWhen you call a function in Python, the interpreter creates a new local namespace so that names defined within that function don’t collide with identical names defined elsewhere. One function can call another, and even if they both define objects with the same name, it all works out fine because those objects exist in separate namespaces. The same holds true if multiple instances of the same function are running concurrently. For example, consider the following definition: When executes the first time, Python creates a namespace and assigns the value in that namespace. Then calls itself recursively. The second time runs, the interpreter creates a second namespace and assigns to there as well. These two instances of the name are distinct from each another and can coexist without clashing because they are in separate namespaces. Unfortunately, running as it stands produces a result that is less than inspiring, as the following traceback shows: File , line , in File , line , in File , line , in File , line , in As written, would in theory go on forever, calling itself over and over without any of the calls ever returning. In practice, of course, nothing is truly forever. Your computer only has so much memory, and it would run out eventually. Python doesn’t allow that to happen. The interpreter limits the maximum number of times a function can call itself recursively, and when it reaches that limit, it raises a exception, as you see above. Technical note: You can find out what Python’s recursion limit is with a function from the module called : You can change it, too, with : You can set it to be pretty large, but you can’t make it infinite. There isn’t much use for a function to indiscriminately call itself recursively without end. It’s reminiscent of the instructions that you sometimes find on shampoo bottles: “Lather, rinse, repeat.” If you were to follow these instructions literally, you’d shampoo your hair forever! This logical flaw has evidently occurred to some shampoo manufacturers, because some shampoo bottles instead say “Lather, rinse, repeat as necessary.” That provides a termination condition to the instructions. Presumably, you’ll eventually feel your hair is sufficiently clean to consider additional repetitions unnecessary. Shampooing can then stop. Similarly, a function that calls itself recursively must have a plan to eventually stop. Recursive functions typically follow this pattern:\n• There are one or more base cases that are directly solvable without the need for further recursion.\n• Each recursive call moves the solution progressively closer to a base case. You’re now ready to see how this works with some examples.\n\nThe next example involves the mathematical concept of factorial. The factorial of a positive integer n, denoted as n!, is defined as follows: In other words, n! is the product of all integers from 1 to n, inclusive. Factorial so lends itself to recursive definition that programming texts nearly always include it as one of the first examples. You can express the definition of n! recursively like this: As with the example shown above, there are base cases that are solvable without recursion. The more complicated cases are reductive, meaning that they reduce to one of the base cases:\n• The base cases (n = 0 or n = 1) are solvable without recursion.\n• For values of n greater than 1, n! is defined in terms of (n - 1)!, so the recursive solution progressively approaches the base case. For example, recursive computation of 4! looks like this: The calculations of 4!, 3!, and 2! suspend until the algorithm reaches the base case where n = 1. At that point, 1! is computable without further recursion, and the deferred calculations run to completion. Here’s a recursive Python function to calculate factorial. Note how concise it is and how well it mirrors the definition shown above: A little embellishment of this function with some statements gives a clearer idea of the call and return sequence: Notice how all the recursive calls stack up. The function gets called with = , , , and in succession before any of the calls return. Finally, when is , the problem can be solved without any more recursion. Then each of the stacked-up recursive calls unwinds back out, returning , , , and finally from the outermost call. Recursion isn’t necessary here. You could implement iteratively using a loop: You can also implement factorial using Python’s , which you can import from the module: Again, this shows that if a problem is solvable with recursion, there will also likely be several viable non-recursive solutions as well. You’ll typically choose based on which one results in the most readable and intuitive code. Another factor to take into consideration is execution speed. There can be significant performance differences between recursive and non-recursive solutions. In the next section, you’ll explore these differences a little further. To evaluate execution time, you can use a function called from a module that is also called . This function supports a number of different formats, but you’ll use the following format in this tutorial: first executes the commands contained in the specified . Then it executes the given number of and reports the cumulative execution time in seconds: Here, the parameter assigns the value . Then prints one hundred times. The total execution time is just over 3/100 of a second. The examples shown below use to compare the recursive, iterative, and implementations of factorial from above. In each case, contains a setup string that defines the relevant function. then executes a total of ten million times and reports the aggregate execution. Next up is the iterative implementation: Last, here’s the version that uses : In this case, the iterative implementation is the fastest, although the recursive solution isn’t far behind. The method using is the slowest. Your mileage will probably vary if you try these examples on your own machine. You certainly won’t get the same times, and you may not even get the same ranking. Does it matter? There’s a difference of almost four seconds in execution time between the iterative implementation and the one that uses , but it took ten million calls to see it. If you’ll be calling a function many times, you might need to take execution speed into account when choosing an implementation. On the other hand, if the function will run relatively infrequently, then the difference in execution times will probably be negligible. In that case, you’d be better off choosing the implementation that seems to express the solution to the problem most clearly. For factorial, the timings recorded above suggest a recursive implementation is a reasonable choice. Frankly, if you’re coding in Python, you don’t need to implement a factorial function at all. It’s already available in the standard module: Perhaps it might interest you to know how this performs in the timing test: Wow! performs better than the best of the other three implementations shown above by roughly a factor of 10. Technical note: The fact that is so much speedier probably has nothing to do with whether it’s implemented recursively. More likely it’s because the function is implemented in C rather than Python. For more reading on Python and C, see these resources:\n• Python Bindings: Calling C or C++ From Python\n• Your Guide to the CPython Source Code A function implemented in C will virtually always be faster than a corresponding function implemented in pure Python.\n\nThe next example involves visiting each item in a nested list structure. Consider the following Python list: As the following diagram shows, contains two sublists. The first of these sublists itself contains another sublist: Suppose you wanted to count the number of leaf elements in this list—the lowest-level objects—as though you’d flattened out the list. The leaf elements are , , , , , , , , , and , so the answer should be . Just calling on the list doesn’t give the correct answer: counts the objects at the top level of , which are the three leaf elements , , and and two sublists and : What you need here is a function that traverses the entire list structure, sublists included. The algorithm goes something like this:\n• Walk through the list, examining each item in turn.\n• If you find a leaf element, then add it to the accumulated count.\n• If you encounter a sublist, then do the following:\n• Drop down into that sublist and similarly walk through it.\n• Once you’ve exhausted the sublist, go back up, add the elements from the sublist to the accumulated count, and resume the walk through the parent list where you left off. Note the self-referential nature of this description: Walk through the list. If you encounter a sublist, then similarly walk through that list. This situation begs for recursion! Recursion fits this problem very nicely. To solve it, you need to be able to determine whether a given list item is leaf item or not. For that, you can use the built-in Python function . In the case of the list, if an item is an instance of type , then it’s a sublist. Otherwise, it’s a leaf item: Now you have the tools in place to implement a function that counts leaf elements in a list, accounting for sublists recursively: If you run on several lists, including the list defined above, you get this: As with the factorial example, adding some statements helps to demonstrate the sequence of recursive calls and return values: Here’s a synopsis of what’s happening in the example above:\n• Line 9: is , so has found a sublist.\n• Line 11: The function calls itself recursively to count the items in the sublist, then adds the result to the accumulating total.\n• Line 12: is , so has encountered a leaf item.\n• Line 14: The function increments the accumulating total by one to account for the leaf item. Note: To keep things simple, this implementation assumes the list passed to contains only leaf items or sublists, not any other type of composite object like a dictionary or tuple. The output from when it’s executed on the list now looks like this: Each time a call to terminates, it returns the count of leaf elements it tallied in the list passed to it. The top-level call returns , as it should. Like the other examples shown so far, this list traversal doesn’t require recursion. You can also accomplish it iteratively. Here’s one possibility: If you run this non-recursive version of on the same lists as shown previously, you get the same results: The strategy employed here uses a stack to handle the nested sublists. When this version of encounters a sublist, it pushes the list that is currently in progress and the current index in that list onto a stack. Once it has counted the sublist, the function pops the parent list and index from the stack so it can resume counting where it left off. In fact, essentially the same thing happens in the recursive implementation as well. When you call a function recursively, Python saves the state of the executing instance on a stack so the recursive call can run. When the recursive call finishes, the state is popped from the stack so that the interrupted instance can resume. It’s the same concept, but with the recursive solution, Python is doing the state-saving work for you. Notice how concise and readable the recursive code is when compared to the non-recursive version: This is a case where using recursion is definitely an advantage.\n\nThe choice of whether to use recursion to solve a problem depends in large part on the nature of the problem. Factorial, for example, naturally translates to a recursive implementation, but the iterative solution is quite straightforward as well. In that case, it’s arguably a toss-up. The list traversal problem is a different story. In that case, the recursive solution is very elegant, while the non-recursive one is cumbersome at best. For the next problem, using recursion is arguably silly. A palindrome is a word that reads the same backward as it does forward. Examples include the following words: If asked to devise an algorithm to determine whether a string is palindromic, you would probably come up with something like “Reverse the string and see if it’s the same as the original.” You can’t get much plainer than that. Even more helpfully, Python’s slicing syntax for reversing a string provides a convenient way to code it: \"\"\"Return True if word is a palindrome, False if not.\"\"\" This is clear and concise. There’s hardly any need to look for an alternative. But just for fun, consider this recursive definition of a palindrome:\n• Base cases: An empty string and a string consisting of a single character are inherently palindromic.\n• Reductive recursion: A string of length two or greater is a palindrome if it satisfies both of these criteria:\n• The first and last characters are the same.\n• The substring between the first and last characters is a palindrome. Slicing is your friend here as well. For a string , indexing and slicing give the following substrings:\n• The first character is .\n• The last character is .\n• The substring between the first and last characters is . So you can define recursively like this: \"\"\"Return True if word is a palindrome, False if not.\"\"\" It’s an interesting exercise to think recursively, even when it isn’t especially necessary.\n\nThe final example presented, like the nested list traversal, is a good example of a problem that very naturally suggests a recursive approach. The Quicksort algorithm is an efficient sorting algorithm developed by British computer scientist Tony Hoare in 1959. Quicksort is a divide-and-conquer algorithm. Suppose you have a list of objects to sort. You start by choosing an item in the list, called the pivot item. This can be any item in the list. You then partition the list into two sublists based on the pivot item and recursively sort the sublists. The steps of the algorithm are as follows:\n• Partition the list into two sublists:\n• Those items that are less than the pivot item\n• Those items that are greater than the pivot item Each partitioning produces smaller sublists, so the algorithm is reductive. The base cases occur when the sublists are either empty or have one element, as these are inherently sorted. The Quicksort algorithm will work no matter what item in the list is the pivot item. But some choices are better than others. Remember that when partitioning, two sublists that are created: one with items that are less than the pivot item and one with items that are greater than the pivot item. Ideally, the two sublists are of roughly equal length. Imagine that your initial list to sort contains eight items. If each partitioning results in sublists of roughly equal length, then you can reach the base cases in three steps: At the other end of the spectrum, if your choice of pivot item is especially unlucky, each partition results in one sublist that contains all the original items except the pivot item and another sublist that is empty. In that case, it takes seven steps to reduce the list to the base cases: The Quicksort algorithm will be more efficient in the first case. But you’d need to know something in advance about the nature of the data you’re sorting in order to systematically choose optimal pivot items. In any case, there isn’t any one choice that will be the best for all cases. So if you’re writing a Quicksort function to handle the general case, the choice of pivot item is somewhat arbitrary. The first item in the list is a common choice, as is the last item. These will work fine if the data in the list is fairly randomly distributed. However, if the data is already sorted, or even nearly so, then these will result in suboptimal partitioning like that shown above. To avoid this, some Quicksort algorithms choose the middle item in the list as the pivot item. Another option is to find the median of the first, last, and middle items in the list and use that as the pivot item. This is the strategy used in the sample code below. Once you’ve chosen the pivot item, the next step is to partition the list. Again, the goal is to create two sublists, one containing the items that are less than the pivot item and the other containing those that are greater. You could accomplish this directly in place. In other words, by swapping items, you could shuffle the items in the list around until the pivot item is in the middle, all the lesser items are to its left, and all the greater items are to its right. Then, when you Quicksort the sublists recursively, you’d pass the slices of the list to the left and right of the pivot item. Alternately, you can use Python’s list manipulation capability to create new lists instead of operating on the original list in place. This is the approach taken in the code below. The algorithm is as follows:\n• Choose the pivot item using the median-of-three method described above.\n• Using the pivot item, create three sublists:\n• The items in the original list that are less than the pivot item\n• The items in the original list that are greater than the pivot item\n• Concatenate all three lists back together. Note that this involves creating a third sublist that contains the pivot item itself. One advantage to this approach is that it smoothly handles the case where the pivot item appears in the list more than once. In that case, list 2 will have more than one element. Now that the groundwork is in place, you are ready to move on to the Quicksort algorithm. Here’s the Python code: This is what each section of is doing:\n• Line 4: The base cases where the list is either empty or has only a single element\n• Lines 7 to 13: Calculation of the pivot item by the median-of-three method\n• Lines 14 to 18: Creation of the three partition lists\n• Lines 20 to 24: Recursive sorting and reassembly of the partition lists Note: This example has the advantage of being succinct and relatively readable. However, it isn’t the most efficient implementation. In particular, the creation of the partition lists on lines 14 to 18 involves iterating through the list three separate times, which isn’t optimal from the standpoint of execution time. Here are some examples of in action: For testing purposes, you can define a short function that generates a list of random numbers between and : Now you can use to test : To further understand how works, see the diagram below. This shows the recursion sequence when sorting a twelve-element list: In the first step, the first, middle, and last list values are , , and , respectively. The median is , so that becomes the pivot item. The first partition then consists of the following sublists: The items less than the pivot item The items greater than the pivot item Each sublist is subsequently partitioned recursively in the same manner until all the sublists either contain a single element or are empty. As the recursive calls return, the lists are reassembled in sorted order. Note that in the second-to-last step on the left, the pivot item appears in the list twice, so the pivot item list has two elements."
    },
    {
        "link": "https://geeksforgeeks.org/recursion-in-python",
        "document": "Recursion involves a function calling itself directly or indirectly to solve a problem by breaking it down into simpler and more manageable parts. In Python, recursion is widely used for tasks that can be divided into identical subtasks.\n\nIn Python, a recursive function is defined like any other function, but it includes a call to itself. The syntax and structure of a recursive function follow the typical function definition in Python, with the addition of one or more conditions that lead to the function calling itself.\n\nExplanation: The factorial of a number n (denoted as n!) is the product of all positive integers less than or equal to n. The recursive approach involves the function calling itself with a decremented value of n until it reaches the base case of 1.\n• Base Case: This is the condition under which the recursion stops. It is crucial to prevent infinite loops and to ensure that each recursive call reduces the problem in some manner. In the factorial example, the base case is\n• Recursive Case: This is the part of the function that includes the call to itself. It must eventually lead to the base case. In the factorial example, the recursive case is\n• Base Cases: If n == 0, the function returns 0. If n == 1, the function returns 1. These two cases are necessary to stop the recursion.\n• Recursive Case: The function calls itself twice with the decrements of n (i.e., fibonacci(n-1) and fibonacci(n-2)), summing the results of these calls. This division into smaller subproblems continues until the base cases are reached.\n\nRecursion can be broadly classified into two types: tail recursion and non-tail recursion. The main difference between them is related to what happens after the recursive call.\n• Tail Recursion : This occurs when the recursive call is the last operation executed in the function, with no additional work or calculation following the recursive call. In many programming languages, tail recursion can be optimized by the compiler into iterative loops to improve performance and prevent stack overflow.\n• Non-Tail Recursion : This occurs when there are operations or calculations that follow the recursive call. This type prevents the compiler or interpreter from optimizing the recursion into an iteration.\n\nHere is a Python example that demonstrates both tail recursion and non-tail recursion:\n• None Recursion is often more intuitive and easier to implement when the problem is naturally recursive, like tree traversals.\n• None It can lead to solutions that are easier to understand compared to iterative ones.\n• None ) to repeat the execution of a block of code.\n• None It is generally more memory-efficient as it does not involve multiple stack frames like recursion.\n• Simplicity: Recursive code is generally simpler and cleaner, especially for problems inherently recursive in nature (e.g., tree traversals, dynamic programming problems).\n• Reduced Code Length: Recursion can reduce the length of the code since the repetitive tasks are handled through repeated function calls.\n• Memory Overhead: Each recursive call adds a new layer to the stack, which can result in significant memory use, especially for deep recursion.\n• Performance Issues: Recursive functions may lead to slower responses due to overheads like function calls and returns.\n• Risk of Stack Overflow: Excessive recursion can lead to a stack overflow error if the recursion depth exceeds the stack limit.\n\nWhat is Recursion in Python?\n\nWhat is Factorial Recursion in Python?\n\nFactorial recursion in Python involves writing a function that computes the factorial of a number by recursively multiplying the number by the factorial of the number minus one. The factorial function is defined as the product of all positive integers up to a specified number, n, and is denoted as n!. The base case in factorial recursion is when n equals 0 or 1, where the factorial is defined as 1.\n\nWhy is Factorial Zero One?"
    },
    {
        "link": "https://stackoverflow.com/questions/248830/python-using-a-recursive-algorithm-as-a-generator",
        "document": "Recently I wrote a function to generate certain sequences with nontrivial constraints. The problem came with a natural recursive solution. Now it happens that, even for relatively small input, the sequences are several thousands, thus I would prefer to use my algorithm as a generator instead of using it to fill a list with all the sequences.\n\nHere is an example. Suppose we want to compute all the permutations of a string with a recursive function. The following naive algorithm takes an extra argument 'storage' and appends a permutation to it whenever it finds one:\n\nNow I want to turn my function into a generator, i.e. to yield a permutation instead of appending it to the storage list:\n\nThis code does not work (the function behaves like an empty generator).\n\nAm I missing something? Is there a way to turn the above recursive algorithm into a generator without replacing it with an iterative one?"
    },
    {
        "link": "https://inventwithpython.com/recursion/chapter3.html",
        "document": "If you take a computer science course, the unit on recursion is sure to cover some of the classic algorithms presented in this chapter. Coding interviews (which, for lack of suitable ways to evaluate candidates, often crib notes from freshman computer science curricula) can touch upon them too. This chapter covers six classic problems in recursion, along with their solutions.\n\nWe begin with three simple algorithms: summing the numbers in an array, reversing a text string, and detecting whether a string is a palindrome. Then we explore an algorithm for solving the Tower of Hanoi puzzle, implement the flood fill drawing algorithm, and tackle the absurdly recursive Ackermann function.\n\nIn the process, you’ll learn about the head-tail technique for splitting up the data in the recursive function arguments. We’ll also ask ourselves three questions when trying to come up with recursive solutions: What is the base case? What argument is passed to the recursive function call? And how do the arguments passed to the recursive function calls become closer to the base case? As you gain more experience, answering these questions should come more naturally.\n\nOur first example is simple: given a list (in Python) or an array (in JavaScript) of integers, return the total sum of all the integers. For example, a call such as should return .\n\nThis is easy to solve with a loop, but solving it with recursion requires more thought. After reading Chapter 2, you might also notice that this algorithm doesn’t map well enough to recursion’s capabilities to justify recursion’s added complexity. Still, summing numbers in an array (or some other calculation based on processing data in a linear data structure) is a common enough recursion problem in coding interviews that it deserves our attention.\n\nTo solve this problem, let’s examine the head-tail technique for implementing recursive functions. This technique splits the recursive function’s array argument into two parts: the head (the first element of the array) and the tail (a new array including everything after the first element). We define the recursive function to find the sum of the array argument’s integers by adding the head to the sum of the tail array. To find out the sum of the tail array, we recursively pass it as the array argument to .\n\nBecause the tail array is one element smaller than the original array argument, we’ll eventually end up calling the recursive function and passing it an empty array. An empty array argument is trivial to sum and doesn’t require more recursive calls; it is merely . From these facts, our answers to the three questions are as follows:\n• None What is the base case? An empty array, which has the sum of .\n• None What argument is passed to the recursive function call? The tail of the original number array, which has one less number than the original array argument.\n• None How does this argument become closer to the base case? The array argument shrinks by one element for each recursive call until it becomes a zero-length, or empty, array.\n\nHere is sumHeadTail.py, a Python program to sum a list of numbers:\n\nAnd here is the equivalent JavaScript program, sumHeadTail.html:\n\nThe output of these programs is shown here:\n\nWhen called with an empty array argument, the base case of our function simply returns ❶. In the recursive case, we form the head ❷ and the tail ❸ from the original argument. Keep in mind that the data type of is an array of numbers, just like the argument. But the data type of is just a single number value, and not an array with one number value. The return value of the function is also a single number value and not an array of numbers; this is why we can add and together in the recursive case ❹.\n\nEach recursive call passes a smaller and smaller array to , bringing it closer to the base case of an empty array. For example, Figure 3-1 shows the state of the call stack for .\n\nIn this figure, each card in the stack represents a function call. At the top of each card is the function name with the argument it was passed when called. Beneath that are the local variables: the parameter, and the and local variables created during the call. At the bottom of the card is the expression that the function call returns. When a new recursive function is made, a new card is pushed to the stack. When the function call returns, the top card is popped from the stack.\n\nWe can use the function as a template for applying the head-tail technique to other recursive functions. For example, you can change the function from one that sums an array of numbers to a function that concatenates an array of strings together. The base case would return an empty string for an empty array argument, while the recursive case would return the head string joined with the return value of the recursive call that is passed the tail.\n\nRecall from Chapter 2 that recursion is especially suited for problems that involve a tree-like structure and backtracking. An array, string, or other linear data structure can be considered a tree-like structure, albeit a tree that has only one branch at each node, as in Figure 3-2.\n\nThe key “tell” that our recursive function is unnecessary is that it never does any backtracking over the data it processes. It makes a single pass over each element in the array from beginning to end, which is something a basic loop can accomplish. Additionally, the Python recursive summation function is about 100 times slower than a straightforward iterative algorithm. Even if performance weren’t an issue, the recursive function would cause a stack overflow if passed a list with tens of thousands of numbers to sum. Recursion is an advanced technique, but it isn’t always the best approach.\n\nIn Chapter 5, we’ll examine a recursive summation function that uses a divide-and-conquer strategy, and in Chapter 8 we’ll examine one that uses tail call optimization. These alternate recursive approaches work around some of the problems in the summation function in this chapter.\n\nLike summing the numbers in an array, reversing a string is another frequently cited recursive algorithm even though the iterative solution is straightforward. Because a string is essentially an array of single characters, we’ll employ the head and tail approach for our function just as we did for the summation algorithm.\n\nLet’s start with the smallest strings possible. A blank string and a single-character string are already the reverse of themselves. These naturally form our base cases: if the string argument is a string such as or , our function should simply return the string argument.\n\nFor larger strings, let’s try splitting the string into a head (just the first character) and tail (all characters after the first). For a two-character string like , is the head and is the tail. To reverse the string, we need to place the head behind the tail: .\n\nDoes this algorithm hold for longer strings? To reverse a string like , we would break it into the head and the tail . But placing the head behind the tail alone doesn’t reverse the string; it gives us . What we actually want to do is put the head behind the reverse of the tail. In other words, would reverse to , and then adding the head to the end of that would produce the reversed string, .\n\nHow can we reverse the tail? Well, we can recursively call and pass it the tail. Forget about the implementation of our function for a moment and focus on its input and output: takes one string argument and returns a string with the argument’s characters reversed.\n\nThinking about how to implement a recursive function like can be difficult because it involves a chicken-and-egg problem. In order to write ’s recursive case, we need to call a function that reverses a string—that is, . As long as we have a solid understanding of what our recursive function’s arguments and return value will be, we can use the leap-of-faith technique to get around this chicken-and-egg problem by writing our recursive case assuming the function call returns the correct value even though we haven’t finished writing it yet.\n\nTaking a leap of faith in recursion is not a magical technique that guarantees your code works bug free. It is merely a perspective to hold to break past the mental programmer’s block you can have when thinking about how to implement your recursive function. The leap of faith requires you to have a firm understanding of your recursive function’s arguments and return value.\n\nNote that the leap-of-faith technique only helps you write the recursive case. You must pass to the recursive call an argument that is closer to the base case. You can’t simply pass the same argument that the recursive function received, like this:\n\nTo continue our example, when we pass the tail to , the head is and the tail is in that function call. We already know that the reverse of a single-character string like is simply ; that’s our base case. So this second call to will reverse to , which is precisely what the previous call to needs. Figure 3-3 shows the state of the call stack during all the recursive calls to .\n\nLet’s ask our three recursive algorithm questions about the function:\n• None What is the base case? A zero- or one-character string.\n• None What argument is passed to the recursive function call? The tail of the original string argument, which has one less character than the original string argument.\n• None How does this argument become closer to the base case? The array argument shrinks by one element for each recursive call until it becomes a one- or zero-length array.\n\nHere is reverseString.py, a Python program to reverse a string:\n\nAnd here is the equivalent JavaScript code in reverseString.html:\n\nHere is the output of these programs:\n\nOur recursive function returns the string that is the reverse of the argument, . Let’s consider the simplest strings to reverse: the empty string and a single-character string would “reverse” to themselves. These are the two base cases with which we’ll start (though we combine them with an or Boolean operator ❶). For the recursive case, we form from the first character in ❷, and from every character after the first ❸. The recursive case then returns the reverse of followed by the character ❹.\n\nA palindrome is a word or phrase that is spelled the same when written forward and backward. Level, race car, taco cat, and a man, a plan, a canal . . . Panama are all examples of palindromes. If you would like to detect whether a string is a palindrome, you can write a recursive function.\n\nThe base case is a zero- or one-character string, which by its nature is always the same, whether forward or backward. We’ll use an approach similar to the head-tail technique, except that we’ll split the string argument into head, middle, and last strings instead. If the head and last characters are the same and the middle characters also form a palindrome, the string is a palindrome. The recursion comes from passing the middle string to .\n\nLet’s ask the three recursive algorithm questions about the function:\n• None What is the base case? A zero- or one-character string, which returns because it is always a palindrome.\n• None What argument is passed to the recursive function call? The middle characters of the string argument.\n• None How does this argument become closer to the base case? The string argument shrinks by two characters for each recursive call until it becomes a zero- or one-character string.\n\nHere is palindrome.py, a Python program to detect palindromes:\n\nHere is the equivalent JavaScript code in palindrome.html:\n\nHere is the output of these programs:\n\nThe base case returns because a zero- or one-character string is always a palindrome. Otherwise, the string argument is broken into three pieces: the first character ❶, the last character ❸, and the middle characters between them ❷.\n\nThe statement in the recursive case ❹ makes use of Boolean short-circuiting, a feature of almost every programming language. In an expression joined with the or Boolean operators, if the left-side expression is , it doesn’t matter if the right-side expression is or because the entire expression will be . Boolean short-circuiting is an optimization that skips the evaluation of the right-side expression of an operator if the left side is . So, in the expression , if is , the recursive call to is skipped. This means that as soon as the head and last strings don’t match, the recursion stops and simply returns .\n\nThis recursive algorithm is still sequential, like the summation and reverse-string functions in the previous sections, except that instead of going from the start of the data to the end, it goes from both ends of the data toward the middle. The iterative version of this algorithm that uses a simple loop is more straightforward. We cover the recursive version in this book because it’s a common coding interview problem.\n\nThe Tower of Hanoi is a puzzle involving a tower of stacked disks. The puzzle begins with the largest disk on the bottom, and the disk sizes decrease going up. Each disk has a hole in its center so that the disks can be stacked on top of one another on a pole. Figure 3-4 shows a wooden Tower of Hanoi puzzle.\n\nTo solve the puzzle, the player must move the stack of disks from one pole to another while following three rules:\n• The player can move only one disk at a time.\n• The player can move disks only to and from the top of a tower.\n• The player can never place a larger disk on top of a smaller disk.\n\nPython’s built-in module has a Tower of Hanoi demonstration that you can see by running on Windows or on macOS/Linux, and then selecting minimum_hanoi from the Examples menu. Tower of Hanoi animations are readily found through an internet search as well.\n\nThe recursive algorithm for solving the Tower of Hanoi puzzle is not intuitive. Let’s start with the smallest case: a Tower of Hanoi with one disk. The solution is trivial: move the disk to another pole and you’re finished. Solving for two disks is slightly more complicated: move the smaller disk to one pole (we’ll call it the temporary pole) and the larger disk to the other pole (we’ll call it the end pole), and then finally move the smaller disk from the temporary pole to the end pole. Both disks are now on the end pole in the correct order.\n\nOnce you solve the three-disk tower, you’ll notice that a pattern emerges. To solve a tower of n disks from the start pole to the end pole, you must do the following:\n• Solve the n – 1 disks puzzle by moving those disks from the start pole to the temporary pole.\n• Move the nth disk from the start pole to the end pole.\n• Solve the n – 1 disks puzzle by moving those disks from the temporary pole to the end pole.\n\nLike the Fibonacci algorithm, the recursive case for the Tower of Hanoi algorithm makes two recursive calls instead of just one. If we draw a tree diagram of the operations for solving a four-disk Tower of Hanoi, it looks like Figure 3-5. Solving the four-disk puzzle requires the same steps as solving the three-disk puzzle, as well as moving the fourth disk and performing the steps of solving the three-disk puzzle again. Likewise, solving the three-disk puzzle requires the same steps as the two-disk puzzle plus moving the third disk, and so on. Solving the one-disk puzzle is the trivial base case: it involves only moving the disk.\n\nThe tree-like structure in Figure 3-5 hints that a recursive approach is ideal for solving the Tower of Hanoi puzzle. In this tree, the execution moves from top to bottom and from left to right.\n\nWhile a three-disk or four-disk Tower of Hanoi is easy for a human to solve, increasing numbers of disks require an exponentially increasing number of operations to complete. For n disks, it takes a minimum of 2^n – 1 moves to solve. This means a 30-disk tower requires over a billion moves to complete!\n\nLet’s ask ourselves the three questions for creating a recursive solution:\n• None What is the base case? Solving a tower of one disk.\n• None What argument is passed to the recursive function call? Solving a tower of size one less than the current size.\n• None How does this argument become closer to the base case? The size of the tower to solve decreases by one disk for each recursive call until it is a one-disk tower.\n\nThe following towerOfHanoiSolver.py program solves the Tower of Hanoi puzzle and displays a visualization of each step:\n\nThis towerOfHanoiSolver.html program contains the equivalent JavaScript code:\n\nWhen you run this code, the output shows each move of the disks until the entire tower has moved from Tower A to Tower B:\n\nThe Python version has an interactive mode too, where you can solve the puzzle yourself. Uncomment the lines of code at the end of towerOfHanoiSolver.py to play the interactive version.\n\nYou can start by running the program with the smaller cases by setting the constant ❶ at the top of the program to or . In our program, a list of integers in Python and an array of integers in JavaScript represent a pole. The integer represents a disk, with larger integers representing larger disks. The integer at the start of the list or array is at the bottom of the pole, and the integer at the end is at the pole’s top. For example, represents the starting pole with six disks with the largest on the bottom, while represents a pole with no disks. The variable contains three of these lists ❷.\n\nThe base case merely moves the smallest disk from the start pole to the end pole ❸. The recursive case for a tower of n disks carries out three steps: solving the n – 1 case ❹, moving the nth disk ❺, and then solving the n – 1 case again ❻.\n\nGraphics programs commonly use the flood fill algorithm to fill an arbitrarily shaped area of the same color with another color. Figure 3-6 shows one such shape at the top left. The subsequent panels show three different sections of the shape flood-filled with a gray color. The flood fill begins on a white pixel and spreads until it meets a non-white pixel, filling the enclosed space.\n\nThe flood fill algorithm is recursive: it begins by changing a single pixel to a new color. The recursive function is then called on any neighbors of the pixel with its same old color. It then moves on to the neighbors of the neighbors, and so on, converting each pixel to the new color until the enclosed space is filled in.\n\nThe base case is a pixel whose color is the edge of the image or is not the old color. Since reaching the base case is the only way to stop the “spread” of recursive calls for every pixel in the image, this algorithm has the emergent behavior of changing all the contiguous pixels from the old color to the new color.\n\nLet’s ask the three recursive algorithm questions about our function:\n• None What is the base case? When the x- and y-coordinates are for a pixel that is not the old color, or are at the edge of the image.\n• None What arguments are passed to the recursive function call? The x- and y-coordinates of the four neighboring pixels of the current pixel are the arguments to four recursive calls.\n• None How do these arguments become closer to the base case? The neighboring pixels run up to a different color than the old color or the edge of the image. Either way, eventually the algorithm runs out of pixels to check.\n\nInstead of an image for our sample program, we’ll use a list of single-character strings to form a 2D grid of text characters to represent an “image.” Each string represents a “pixel,” and the specific character represents the “color.” The floodfill.py Python program implements the flood fill algorithm, the image data, and a function to print the image on the screen:\n\nThe floodfill.html program contains the equivalent JavaScript code:\n\nWhen you run this code, the program fills the interior of the shape drawn by the characters ❶ starting at coordinates 3, 3. It replaces all the period characters ( ) with characters. The following output shows the before and after images:\n\nIf you want to see every step of the flood fill algorithm as it fills in the new character, uncomment the line in the function and run the program again.\n\nThe image is represented by a 2D array of string characters. We can pass this data structure, an coordinate and a coordinate, and a new character to the function. The function notes the character currently at the and coordinates and saves it to the variable ❷.\n\nIf the current characters at coordinates and in are not the same as , this is our base case, and the function simply returns. Otherwise, the function continues on to its four recursive cases: passing the x- and y-coordinates of the bottom ❸, top ❹, right ❺, and left ❻ neighbors of the current coordinates. After these four potential recursive calls are made, the end of the function is an implicit base case, made explicit in our program with a statement ❼.\n\nThe flood fill algorithm doesn’t have to be recursive. For large images, a recursive function could cause stack overflows. If we were to implement flood fill with a loop and a stack instead, the stack would begin with the x- and y-coordinates of the starting pixel. The code in the loop would pop the coordinates off the top of the stack, and if that coordinate’s pixel matches , it would push the coordinates of the four neighboring pixels. When the stack is empty because the base case is no longer pushing neighbors to the stack, the loop is finished.\n\nHowever, the flood fill algorithm doesn’t necessarily have to use a stack. The pushing and popping of a first-in, last-out stack is effective for backtracking behavior, but the order that the pixels are processed in the flood fill algorithm can be arbitrary. This means we could equally effectively use a set data structure that removes elements randomly. You can find these iterative flood fill algorithms implemented in floodFillIterative.py and floodFillIterative.html in the downloadable resources at https://nostarch.com/recursive-book-recursion.\n\nThe Ackermann function is named after its discoverer, Wilhelm Ackermann. A student of mathematician David Hilbert (whose Hilbert curve fractal we discuss in Chapter 9), Ackermann published his function in 1928. Mathematicians Rózsa Péter and Raphael Robinson later developed the version of the function featured in this section.\n\nWhile the Ackermann function has some application in advanced mathematics, it is mostly known for being an example of a highly recursive function. Even slight increases to its two integer arguments cause a large increase in the number of recursive calls it makes.\n\nThe Ackermann function takes two arguments, and , and has a base case of returning when is . There are two recursive cases: when is , the function returns , and when is greater than , the function returns . These cases likely aren’t meaningful to you, but suffice it to say, the number of recursive calls the Ackermann function makes grows quickly. Calling results in three recursive function calls. Calling results in 43 recursive function calls. Calling results in 42,437 recursive function calls. And calling results in . . . well, actually I don’t know how many recursive function calls, because it would take several times the age of the universe to calculate.\n\nLet’s answer the three questions we ask when constructing recursive algorithms:\n• None What is the base case? When is .\n• None What arguments are passed to the recursive function call? Either or is passed for the next parameter; and , , or the return value of is passed for the next parameter.\n• None How do these arguments become closer to the base case? The argument is always either decreasing or staying the same size, so it will eventually reach .\n\nHere is an ackermann.py Python program:\n\nAnd here is the equivalent ackermann.html JavaScript program:\n\nWhen you run this code, the output’s indentation (set by the argument) tells you how deep on the call stack the given recursive function call is:\n\nYou can also try , but anything with larger arguments will probably take far too long to calculate. To speed up the calculation, try commenting out all and calls except the ones that print the final return value of .\n\nRemember, even a recursive algorithm like the Ackermann function can be implemented as an iterative function. The iterative Ackermann algorithms are implemented in ackermannIterative.py and ackermannIterative.html in the downloadable resources at https://nostarch.com/recursive-book-recursion.\n\nThis chapter covered some classic recursive algorithms. For each, we asked the three important questions you should always ask when designing your own recursive functions: What is the base case? What arguments are passed to the recursive function call? How do these arguments become closer to the base case? If they don’t, your function will continue to recurse until it causes a stack overflow.\n\nThe summation, string reversing, and palindrome detection recursive functions could have easily been implemented with a simple loop. The key giveaway is that they all make a single pass through the data given to them with no backtracking. As explained in Chapter 2, recursive algorithms are especially suited to problems that involve a tree-like structure and require backtracking.\n\nThe tree-like structures for solving the Tower of Hanoi puzzle suggest that it involves backtracking, as the program execution runs from top to bottom, left to right, in the tree. This makes it a prime candidate for recursion, especially since the solution requires two recursive calls of smaller towers.\n\nThe flood fill algorithm is directly applicable to graphics and drawing programs, as well as other algorithms to detect the shape of contiguous areas. If you’ve used the paint-bucket tool in a graphics program, you’ve likely used a version of the flood fill algorithm.\n\nThe Ackermann function is an excellent example of how quickly a recursive function can grow as its inputs increase. While it doesn’t have many practical applications in day-to-day programming, no discussion about recursion would be complete without it. But as recursive as it is, like all recursive functions it can be implemented iteratively with a loop and a stack.\n\nWikipedia has more information on the Tower of Hanoi problem at https://en.wikipedia.org/wiki/Tower_of_Hanoi, and the Computerphile video “Recursion ‘Super Power’ (in Python)” covers solving the Tower of Hanoi in Python at https://youtu.be/8lhxIOAfDss. The 3Blue1Brown two-part video series, “Binary, Hanoi, and Sierpiński,” goes into even more detail by exploring the relationships among the Tower of Hanoi, binary numbers, and the Sierpiński Triangle fractal starting at https://youtu.be/2SUvWfNJSsM.\n\nWikipedia has an animation of the flood fill algorithm working on a small image at https://en.wikipedia.org/wiki/Flood_fill.\n\nThe Computerphile video “The Most Difficult Program to Compute?” discusses the Ackermann function at https://youtu.be/i7sm9dzFtEI. If you’d like to learn more about the Ackermann function’s place in computability theory, the Hackers in Cambridge channel has a five-part video series on primitive recursive and partial recursive functions at https://youtu.be/yaDQrOUK-KY. The series requires a lot of mathematical thinking on the part of the viewer, but you don’t need a lot of prior mathematical knowledge.\n\nTest your comprehension by answering the following questions:\n• What is the head of an array or string?\n• What is the tail of an array or string?\n• What are the three questions this chapter presents for each recursive algorithm?\n• What is the leap of faith in recursion?\n• What do you need to understand about the recursive function you are writing before you can take a leap of faith?\n• How does a linear data structure such as an array or string resemble a tree-like structure?\n• Does the recursive function involve any backtracking over the data it works on?\n• In the flood fill program, try changing the variable’s strings to create a C shape that is not fully enclosed. What happens when you attempt to flood-fill the image from the middle of the C?\n• Answer the three questions about recursive solutions for each of the recursive algorithms presented in this chapter:\n• What is the base case?\n• What argument is passed to the recursive function call?\n• How does this argument become closer to the base case? Then re-create the recursive algorithms from this chapter without looking at the original code.\n\nFor practice, write a function for each of the following tasks:\n• Using the head-tail technique, create a recursive function that is passed an array of strings and returns these strings concatenated together into a single string. For example, should return .\n• Using the head-tail technique, create a recursive function that is passed an array of integers and returns the total multiplied product of them. This code will be almost identical to the function in this chapter. However, note that the base case of an array with just one integer returns the integer, and the base case of an empty array returns .\n• Using the flood fill algorithm, count the number of “rooms,” or enclosed spaces, in a 2D grid. You can do this by creating nested loops that call the flood fill function on each character in the grid if it is a period, in order to change the periods into hash characters. For example, the following data would result in the program finding six places in the grid with periods, meaning there are five rooms (and the space outside all the rooms)."
    },
    {
        "link": "https://stackoverflow.com/questions/23116911/all-permutations-of-a-string-in-python-recursive",
        "document": "I need a kick in the head on this one. I have the following recursive function defined:\n\nWhere am I going wrong here? How can I think about this differently to come up with the solution?\n\nNote: I am aware of the itertools function. I am trying to understand how to implement permutations recursively for my own learning. That is why I would prefer someone to point out what is wrong with my code, and how to think differently to solve it. Thanks!"
    }
]