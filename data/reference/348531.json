[
    {
        "link": "https://docs.oracle.com/javase/tutorial/deployment/jar/build.html",
        "document": "Trail: Deployment \n\nLesson: Packaging Programs in JAR Files \n\nSection: Using JAR Files: The Basics\n\nThe Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nThe basic format of the command for creating a JAR file is:\n\nThe options and arguments used in this command are:\n• The option indicates that you want to create a JAR file.\n• The option indicates that you want the output to go to a file rather than to .\n• is the name that you want the resulting JAR file to have. You can use any filename for a JAR file. By convention, JAR filenames are given a extension, though this is not required.\n• The argument is a space-separated list of one or more files that you want to include in your JAR file. The argument can contain the wildcard symbol. If any of the \"input-files\" are directories, the contents of those directories are added to the JAR archive recursively.\n\nThe and options can appear in either order, but there must not be any space between them.\n\nThis command will generate a compressed JAR file and place it in the current directory. The command will also generate a default manifest file for the JAR archive.\n\nYou can add any of these additional options to the options of the basic command:\n\nNote: When you create a JAR file, the time of creation is stored in the JAR file. Therefore, even if the contents of the JAR file do not change, when you create a JAR file multiple times, the resulting files are not exactly identical. You should be aware of this when you are using JAR files in a build environment. It is recommended that you use versioning information in the manifest file, rather than creation time, to control versions of a JAR file. See the Setting Package Version Information section.\n\nLet us look at an example. A simple applet. You can see the source code of this applet by downloading the JDK Demos and Samples bundle from Java SE Downloads. This demo contains class files, audio files, and images having this structure:\n\nThe and subdirectories contain sound files and GIF images used by the applet.\n\nYou can obtain all these files from jar/examples directory when you download the entire Tutorial online. To package this demo into a single JAR file named , you would run this command from inside the directory:\n\nThe and arguments represent directories, so the Jar tool will recursively place them and their contents in the JAR file. The generated JAR file will be placed in the current directory. Because the command used the option for verbose output, you would see something similar to this output when you run the command:\n\nYou can see from this output that the JAR file is compressed. The Jar tool compresses files by default. You can turn off the compression feature by using the (zero) option, so that the command would look like:\n\nYou might want to avoid compression, for example, to increase the speed with which a JAR file could be loaded by a browser. Uncompressed JAR files can generally be loaded more quickly than compressed files because the need to decompress the files during loading is eliminated. However, there is a tradeoff in that download time over a network may be longer for larger, uncompressed files.\n\nThe Jar tool will accept arguments that use the wildcard symbol. As long as there weren't any unwanted files in the directory, you could have used this alternative command to construct the JAR file:\n\nThough the verbose output doesn't indicate it, the Jar tool automatically adds a manifest file to the JAR archive with path name . See the Working with Manifest Files: The Basics section for information about manifest files.\n\nIn the above example, the files in the archive retained their relative path names and directory structure. The Jar tool provides the option that you can use to create a JAR file in which the relative paths of the archived files are not preserved. It's modeled after TAR's option.\n\nAs an example, suppose you wanted to put audio files and gif images used by the TicTacToe demo into a JAR file, and that you wanted all the files to be on the top level, with no directory hierarchy. You could accomplish that by issuing this command from the parent directory of the and directories:\n\nThe part of this command directs the Jar tool to go to the directory, and the following directs the Jar tool to archive all the contents of that directory. The part of the command then does the same with the directory. The resulting JAR file would have this table of contents:\n\nBy contrast, suppose that you used a command that did not employ the option:\n\nThe resulting JAR file would have this table of contents:"
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/deployment/jar/basicsindex.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nJAR files are packaged with the ZIP file format, so you can use them for tasks such as lossless data compression, archiving, decompression, and archive unpacking. These tasks are among the most common uses of JAR files, and you can realize many JAR file benefits using only these basic features.\n\nEven if you want to take advantage of advanced functionality provided by the JAR file format such as electronic signing, you'll first need to become familiar with the fundamental operations.\n\nTo perform basic tasks with JAR files, you use the Java Archive Tool provided as part of the Java Development Kit (JDK). Because the Java Archive tool is invoked by using the command, this tutorial refers to it as 'the Jar tool'.\n\nAs a synopsis and preview of some of the topics to be covered in this section, the following table summarizes common JAR file operations:\n\nThis section shows you how to perform the most common JAR-file operations, with examples for each of the basic features:\n\nThis section shows you how to use the Jar tool to package files and directories into a JAR file.\n\nYou can display a JAR file's table of contents to see what it contains without actually unpacking the JAR file.\n\nYou can use the Jar tool to unpack a JAR file. When extracting files, the Jar tool makes copies of the desired files and writes them to the current directory, reproducing the directory structure that the files have in the archive.\n\nThis section shows you how to update the contents of an existing JAR file by modifying its manifest or by adding files.\n\nThis section shows you how to invoke and run applets and applications that are packaged in JAR files.\n\nThe documentation for the JDK includes reference pages for the Jar tool:"
    },
    {
        "link": "https://stackoverflow.com/questions/3115335/how-to-generate-javadoc-documentation-for-classes-in-a-jar-file-that-i-dont-ha",
        "document": "You can use the command on any class in your classpath. This will not produce Javadoc files, but it will allow you to see what the class provides.\n\n...and after a bunch of constructors there are other methods...\n\nAnd you can have it show you other things too, but this is probably the most helpful.\n\nNot exactly what you are looking for, but if you just have a jar with a bunch of classes this might be your best option."
    },
    {
        "link": "https://stackoverflow.com/questions/19650711/how-to-create-a-java-jar-file-with-source-code-java-files",
        "document": "In Eclipse Help contents, expand \"Java development user guide\" ==> \"Tasks\" ==> \"Creating JAR files.\" Follow the instructions for \"Creating a new JAR file\" or \"Creating a new runnable JAR file.\"\n\nThe JAR File and Runnable JAR File commands are for some reason located under the File menu: click on Export... and expand the Java node."
    },
    {
        "link": "https://baeldung.com/java-create-jar",
        "document": "Usually, it’s convenient to bundle many Java class files into a single archive file.\n\nIn this tutorial, we’re going to cover the ins and outs of working with jar – or Java ARchive – files in Java.\n\nSpecifically, we’ll take a simple application and explore different ways to package and run it as a jar. We’ll also answer some curiosities like how to easily read a jar’s manifest file along the way.\n\nBefore we can create a runnable jar file, our application needs to have a class with a main method. This class provides our entry point into the application:\n\nNow that we’re all set up let’s compile our code and create our jar file.\n\nWe can do this with javac from the command line:\n\nThe javac command creates JarExample.class in the com/baeldung/jar directory. We can now package that into a jar file.\n\nTo create the jar file, we are going to use the jar command.\n\nTo use the jar command to create a jar file, we need to use the c option to indicate that we’re creating a file and the f option to specify the file:\n\nIt’s helpful for the jar file manifest to include the main class.\n\nThe manifest is a special file in a jar located the META-INF directory and named MANIFEST.MF. The manifest file contains special meta information about files within the jar file.\n\nSome examples of what we can use a manifest file for include setting the entry point, setting version information and configuring the classpath.\n\nBy using the e option, we can specify our entry point, and the jar command will add it to the generated manifest file.\n\nLet’s run jar with an entry point specified:\n\nLet’s say we’ve made a change to one of our classes and recompiled it. Now, we need to update our jar file.\n\nLet’s use the jar command with the u option to update its contents:\n\nIn some cases, we may need to have more control over what goes in our manifest file. The jar command provides functionality for providing our own manifest information.\n\nLet’s add a partial manifest file named example_manifest.txt to our application to set our entry point:\n\nThe manifest information we provide we’ll be added to what the jar command generates, so it’s the only line we need in the file.\n\nIt’s important that we end our manifest file with a newline. Without the newline, our manifest file will be silently ignored.\n\nWith that setup, let’s create our jar again using our manifest information and the m option:\n\nIf we want more information out of the jar command, we can simply add the v option for verbose.\n\nLet’s run our jar command with the v option:\n\nWe can also use Maven to create our jar. Since Maven favors convention over configuration, we can just run package to create our jar file.\n\nBy default, our jar file will be added to the target folder in our project.\n\nWe can also configure Maven to specify the main class and create an executable jar file.\n\nIf we’re using Spring Boot with Maven, we should first confirm that our packaging setting is set to jar rather than war in our pom.xml file.\n\nOnce we know that’s configured, we can run the package goal:\n\nSetting our main class is where we find differences between creating a jar with a regular Java application and a fat jar for a Spring Boot application. In a Spring Boot application, the main class is actually org.springframework.boot.loader.JarLauncher.\n\nAlthough our example isn’t a Spring Boot application, we could easily set it up to be a Spring Boot console application.\n\nOur main class should be specified as the start class:\n\nWe can also use Gradle to create a Spring Boot fat jar.\n\nNow that we’ve got our jar file, we can run it. We run jar files using the java command.\n\nSince we’ve gone ahead and made sure our main class is specified in the manifest, we can use the -jar option of the java command to run our application without specifying the main class:\n\nWe can also specify the main class when we’re running our application. We can use the -cp option to ensure that our jar file is in the classpath and then provide our main class in the package.className format:\n\nUsing path separators instead of package format also works:\n\nWe can use the jar command to list the contents of our jar file:\n\nSince it can be important to know what’s in our MANIFEST.MF file, let’s look at a quick and easy way we can peek at the contents without leaving the command line.\n\nLet’s use the unzip command with the -p option:\n\nIn this tutorial, we set up a simple Java application with a main class.\n\nThen we looked at three ways of creating jar files: using the jar command, with Maven and with a Maven Spring Boot application.\n\nAfter we created our jar files, we returned to the command line and ran them with an inferred and a specified main class.\n\nWe also learned how to display the contents of a file and how to display the contents of a single file within a jar."
    },
    {
        "link": "https://codejava.net/java-core/tools/using-jar-command-examples",
        "document": "In this Java tools tutorial, I will help you understand how to use the jar command provided in the Java Development Kit (JDK) with various useful examples.\n\nYou know, jar is Java archive tool that packages (and compresses) a set of files into a single archive. The archive format is ZIP but the file name usually has .jar extension. This tool is used for creating, updating, extracting and viewing content of jar files.\n\nThe executable file of this tool can be located under the JDK_HOME\\bin directory (jar.exe on Windows), so make sure you include this path in the PATH environment variable in order to run this tool anywhere from the command line prompt.\n\nThe general syntax of jar command is as follows:\n\nType jar command without any arguments to see its syntax and options, or see the online documentation here. In this tutorial, we summarize the most common usages of the jar command for your quick reference. Suppose that we have a project with the following directory structure:\n\nThe following examples demonstrate how to use the jar tool to create a library jar file, create an executable one and view, update, and extract content of the generated jar file. In most cases, the current directory is SwingEmailSender.\n\nA normal jar file is the non-executable one, such as a library jar file or an applet jar file. The following command put all files under the build\\classesdirectory into a new jar file called SwingEmailSender.jar:\n\nNote that there is a dot (.) at the end which denotes all files. The c option is to create, the f is to specify jar file name, the v is to generate verbose output, and the -C is to specify the directory containing the files to be added. Here’s the output (some entries are removed for brevity):\n\nIn case the current directory is build\\classes, the -C option can be omitted (but the jar file needs to be moved upward two levels). For example:\n\nIf we want to add only files in a specific package:\n\nThat takes only files in the package net.codejava.swing.mail (recursively).\n\nThe following command adds only one class (SwingEmailSender.class) to the jar file:\n\nIf we want to add multiple classes, separate them by spaces (with full path). Suppose that the current directory is build\\classes, the following command adds two classes (SwingEmailSender.class and JFilePicker.class) to the jar file:\n\nBy default, the jar tool automatically creates a manifest file when generating a new jar file. If we don’t want to have the manifest created, use the M option as in the following example:\n\nIn case we want to manually add an external manifest file, use the m option as in the following example:\n\nHere, content of the manifest.txt is copied to the generated manifest file inside the jar file.\n\nAn executable jar file (stand-alone desktop application) must have information about the application entry point (main class) defined in its manifest file. The entry point can be specified either directly on the command line (using the e option), or in an external manifest file.\n\nThe following command creates an executable jar file with the main class is net.codejava.swing.mail.SwingEmailSender:\n\nIf using an external manifest file, remember to specify the main class by adding the following entry to the manifest file. For example:\n\nAnd the following command creates an executable jar file with the main class is specified in the external manifest file (manifest.txt):\n\nThe t option is used in conjunction with the f and v to list table of contents of a jar file. For example:\n\nAdding the v option will include file size and date time for each entry. For example:\n\nIt’s also possible to list only files under a specific package. The following command lists only files under the package net.codejava.swing.mail:\n\nThe u option is used to update an existing jar file, e.g. adding new classes and removing/updating manifest file.\n\nThe following example adds/updates the classes under the package net.codejava.swing.download to the existing archive:\n\nThe following command updates everything but removes the manifest file:\n\nAnd the following command updates everything including the manifest file:\n\nTo extract a jar file, use the x option in conjunction with the f and v. The following command extracts all content of the SwingEmailSender.jar file to the current directory:\n\nAdd the v option if we want verbose output:\n\nIf we want to extract only files under a specific package, pass the package path after the jar file name. For example:\n\nThat extracts only files in the package net.codejava.swing.mail. Here’s the verbose output:\n\nBy default, the generated jar file is compressed as ZIP/ZLIB compression format. However, it’s possible to disable the default compression by specifying the 0 option. For example:\n\nThe i option allows us to generate an INDEX.LIST file that contains information about the specified jar file, such as the dependent jar files and location of all packages. For example:\n\nThe INDEX.LIST file is generated under the META-INF directory. Here’s a sample content of this file:\n\nThis is a useful feature that shortens and simplifies a lengthy jar command line. Just create a text file that contains jar options and arguments (separated by spaces or new lines), and then execute the jar command in the following form:\n\nFor example, create a classes.txt file containing the classes to be included as follows:\n\nThen execute the following command:\n\nCreate an options.txt file that contains all the options as follows:\n\nThen execute the following command:\n\nThe -J option allows us to pass options to the underlying Java Runtime Environment (JRE) when needed. For example:\n\nThat passes the option -Xmx128M (maximum memory size is 128MB) to the runtime environment. Note that there must be no space between -J and the options.\n• Understanding the triad tools javac, java and jar in JDK\n• How to compile, package and run a Java program using command-line tools (javac, jar and java)"
    },
    {
        "link": "https://stackoverflow.com/questions/9395207/how-to-include-jar-files-with-java-file-and-compile-in-command-prompt",
        "document": "You can include your jar files in the \"javac\" command using the \"-cp\" option.\n\nInstead of \"-cp\" you could also use \"-classpath\"\n\nYou could including the jars every time you compile by setting the environment variable \"CLASSPATH\" correctly. The environment variable will store the path where the jars and classes that needs to be used for compiling/executing any java file. You will not have to include the jars individually every time you compile you file.\n\nDifferent machines have different methods to set the classpath as an environment variable. The commands for Windows, Linux, etc are different.\n\nYou can find more details in this blog."
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/deployment/jar/build.html",
        "document": "Trail: Deployment \n\nLesson: Packaging Programs in JAR Files \n\nSection: Using JAR Files: The Basics\n\nThe Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nThe basic format of the command for creating a JAR file is:\n\nThe options and arguments used in this command are:\n• The option indicates that you want to create a JAR file.\n• The option indicates that you want the output to go to a file rather than to .\n• is the name that you want the resulting JAR file to have. You can use any filename for a JAR file. By convention, JAR filenames are given a extension, though this is not required.\n• The argument is a space-separated list of one or more files that you want to include in your JAR file. The argument can contain the wildcard symbol. If any of the \"input-files\" are directories, the contents of those directories are added to the JAR archive recursively.\n\nThe and options can appear in either order, but there must not be any space between them.\n\nThis command will generate a compressed JAR file and place it in the current directory. The command will also generate a default manifest file for the JAR archive.\n\nYou can add any of these additional options to the options of the basic command:\n\nNote: When you create a JAR file, the time of creation is stored in the JAR file. Therefore, even if the contents of the JAR file do not change, when you create a JAR file multiple times, the resulting files are not exactly identical. You should be aware of this when you are using JAR files in a build environment. It is recommended that you use versioning information in the manifest file, rather than creation time, to control versions of a JAR file. See the Setting Package Version Information section.\n\nLet us look at an example. A simple applet. You can see the source code of this applet by downloading the JDK Demos and Samples bundle from Java SE Downloads. This demo contains class files, audio files, and images having this structure:\n\nThe and subdirectories contain sound files and GIF images used by the applet.\n\nYou can obtain all these files from jar/examples directory when you download the entire Tutorial online. To package this demo into a single JAR file named , you would run this command from inside the directory:\n\nThe and arguments represent directories, so the Jar tool will recursively place them and their contents in the JAR file. The generated JAR file will be placed in the current directory. Because the command used the option for verbose output, you would see something similar to this output when you run the command:\n\nYou can see from this output that the JAR file is compressed. The Jar tool compresses files by default. You can turn off the compression feature by using the (zero) option, so that the command would look like:\n\nYou might want to avoid compression, for example, to increase the speed with which a JAR file could be loaded by a browser. Uncompressed JAR files can generally be loaded more quickly than compressed files because the need to decompress the files during loading is eliminated. However, there is a tradeoff in that download time over a network may be longer for larger, uncompressed files.\n\nThe Jar tool will accept arguments that use the wildcard symbol. As long as there weren't any unwanted files in the directory, you could have used this alternative command to construct the JAR file:\n\nThough the verbose output doesn't indicate it, the Jar tool automatically adds a manifest file to the JAR archive with path name . See the Working with Manifest Files: The Basics section for information about manifest files.\n\nIn the above example, the files in the archive retained their relative path names and directory structure. The Jar tool provides the option that you can use to create a JAR file in which the relative paths of the archived files are not preserved. It's modeled after TAR's option.\n\nAs an example, suppose you wanted to put audio files and gif images used by the TicTacToe demo into a JAR file, and that you wanted all the files to be on the top level, with no directory hierarchy. You could accomplish that by issuing this command from the parent directory of the and directories:\n\nThe part of this command directs the Jar tool to go to the directory, and the following directs the Jar tool to archive all the contents of that directory. The part of the command then does the same with the directory. The resulting JAR file would have this table of contents:\n\nBy contrast, suppose that you used a command that did not employ the option:\n\nThe resulting JAR file would have this table of contents:"
    },
    {
        "link": "https://stackoverflow.com/questions/9941296/how-do-i-make-a-jar-from-a-java-file",
        "document": "Ok this is the solution I would have liked to find, instead here I write it:\n\nFirst create the directory structure corresponding to the package defined for the .java file, if it is create the directory and inside it and inside it the .java file\n\nNotice the above will include multiple libraries, if under windows use \",\" to separate multiple files otherwise under GNU/Linux use \":\" To create a jar file\n\nthe above will create the application with its corresponding Manifest indicating the App as the main class.\n\nIncluding the required libraries inside the jar file is not possible using java or jar command line parameters.\n\nYou can instead:\n• manually extract libraries to the root folder of the jar file\n• use an IDE such as Netbeans and insert a rule inside post-jar section of to extract the libraries inside the jar. See below.\n\nthe names are found inside file after you added the libraries to the Netbeans IDE."
    },
    {
        "link": "https://baeldung.com/java-create-jar",
        "document": "Usually, it’s convenient to bundle many Java class files into a single archive file.\n\nIn this tutorial, we’re going to cover the ins and outs of working with jar – or Java ARchive – files in Java.\n\nSpecifically, we’ll take a simple application and explore different ways to package and run it as a jar. We’ll also answer some curiosities like how to easily read a jar’s manifest file along the way.\n\nBefore we can create a runnable jar file, our application needs to have a class with a main method. This class provides our entry point into the application:\n\nNow that we’re all set up let’s compile our code and create our jar file.\n\nWe can do this with javac from the command line:\n\nThe javac command creates JarExample.class in the com/baeldung/jar directory. We can now package that into a jar file.\n\nTo create the jar file, we are going to use the jar command.\n\nTo use the jar command to create a jar file, we need to use the c option to indicate that we’re creating a file and the f option to specify the file:\n\nIt’s helpful for the jar file manifest to include the main class.\n\nThe manifest is a special file in a jar located the META-INF directory and named MANIFEST.MF. The manifest file contains special meta information about files within the jar file.\n\nSome examples of what we can use a manifest file for include setting the entry point, setting version information and configuring the classpath.\n\nBy using the e option, we can specify our entry point, and the jar command will add it to the generated manifest file.\n\nLet’s run jar with an entry point specified:\n\nLet’s say we’ve made a change to one of our classes and recompiled it. Now, we need to update our jar file.\n\nLet’s use the jar command with the u option to update its contents:\n\nIn some cases, we may need to have more control over what goes in our manifest file. The jar command provides functionality for providing our own manifest information.\n\nLet’s add a partial manifest file named example_manifest.txt to our application to set our entry point:\n\nThe manifest information we provide we’ll be added to what the jar command generates, so it’s the only line we need in the file.\n\nIt’s important that we end our manifest file with a newline. Without the newline, our manifest file will be silently ignored.\n\nWith that setup, let’s create our jar again using our manifest information and the m option:\n\nIf we want more information out of the jar command, we can simply add the v option for verbose.\n\nLet’s run our jar command with the v option:\n\nWe can also use Maven to create our jar. Since Maven favors convention over configuration, we can just run package to create our jar file.\n\nBy default, our jar file will be added to the target folder in our project.\n\nWe can also configure Maven to specify the main class and create an executable jar file.\n\nIf we’re using Spring Boot with Maven, we should first confirm that our packaging setting is set to jar rather than war in our pom.xml file.\n\nOnce we know that’s configured, we can run the package goal:\n\nSetting our main class is where we find differences between creating a jar with a regular Java application and a fat jar for a Spring Boot application. In a Spring Boot application, the main class is actually org.springframework.boot.loader.JarLauncher.\n\nAlthough our example isn’t a Spring Boot application, we could easily set it up to be a Spring Boot console application.\n\nOur main class should be specified as the start class:\n\nWe can also use Gradle to create a Spring Boot fat jar.\n\nNow that we’ve got our jar file, we can run it. We run jar files using the java command.\n\nSince we’ve gone ahead and made sure our main class is specified in the manifest, we can use the -jar option of the java command to run our application without specifying the main class:\n\nWe can also specify the main class when we’re running our application. We can use the -cp option to ensure that our jar file is in the classpath and then provide our main class in the package.className format:\n\nUsing path separators instead of package format also works:\n\nWe can use the jar command to list the contents of our jar file:\n\nSince it can be important to know what’s in our MANIFEST.MF file, let’s look at a quick and easy way we can peek at the contents without leaving the command line.\n\nLet’s use the unzip command with the -p option:\n\nIn this tutorial, we set up a simple Java application with a main class.\n\nThen we looked at three ways of creating jar files: using the jar command, with Maven and with a Maven Spring Boot application.\n\nAfter we created our jar files, we returned to the command line and ran them with an inferred and a specified main class.\n\nWe also learned how to display the contents of a file and how to display the contents of a single file within a jar."
    }
]