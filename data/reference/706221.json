[
    {
        "link": "https://vuejs.org/about/faq",
        "document": "Vue is an independent, community-driven project. It was created by Evan You in 2014 as a personal side project. Today, Vue is actively maintained by a team of both full-time and volunteer members from all around the world, where Evan serves as the project lead. You can learn more about the story of Vue in this documentary.\n\nVue's development is primarily funded through sponsorships and we have been financially sustainable since 2016. If you or your business benefit from Vue, consider sponsoring us to support Vue's development!\n\nWhat's the difference between Vue 2 and Vue 3? ​\n\nVue 3 is the current, latest major version of Vue. It contains new features that are not present in Vue 2, such as Teleport, Suspense, and multiple root elements per template. It also contains breaking changes that make it incompatible with Vue 2. Full details are documented in the Vue 3 Migration Guide.\n\nDespite the differences, the majority of Vue APIs are shared between the two major versions, so most of your Vue 2 knowledge will continue to work in Vue 3. Notably, Composition API was originally a Vue-3-only feature, but has now been backported to Vue 2 and is available in Vue 2.7.\n\nIn general, Vue 3 provides smaller bundle sizes, better performance, better scalability, and better TypeScript / IDE support. If you are starting a new project today, Vue 3 is the recommended choice. There are only a few reasons for you to consider Vue 2 as of now:\n• You need to support IE11. Vue 3 leverages modern JavaScript features and does not support IE11.\n\nIf you intend to migrate an existing Vue 2 app to Vue 3, consult the migration guide.\n\nVue 2.7, which was shipped in July 2022, is the final minor release of the Vue 2 version range. Vue 2 has now entered maintenance mode: it will no longer ship new features, but will continue to receive critical bug fixes and security updates for 18 months starting from the 2.7 release date. This means Vue 2 will reach End of Life on December 31st, 2023.\n\nWe believe this should provide plenty of time for most of the ecosystem to migrate over to Vue 3. However, we also understand that there could be teams or projects that cannot upgrade by this timeline while still needing to fulfill security and compliance requirements. We are partnering with industry experts to provide extended support for Vue 2 for teams with such needs - if your team expects to be using Vue 2 beyond the end of 2023, make sure to plan ahead and learn more about Vue 2 Extended LTS.\n\nWhat license does Vue use? ​\n\nVue is a free and open source project released under the MIT License.\n\nThe latest version of Vue (3.x) only supports browsers with native ES2016 support. This excludes IE11. Vue 3.x uses ES2016 features that cannot be polyfilled in legacy browsers, so if you need to support legacy browsers, you will need to use Vue 2.x instead.\n\nVue is a mature and battle-tested framework. It is one of the most widely used JavaScript frameworks in production today, with over 1.5 million users worldwide, and is downloaded close to 10 million times a month on npm.\n\nVue is used in production by renowned organizations in varying capacities all around the world, including Wikimedia Foundation, NASA, Apple, Google, Microsoft, GitLab, Zoom, Tencent, Weibo, Bilibili, Kuaishou, and many more.\n\nVue 3 is one of the most performant mainstream frontend frameworks, and handles most web application use cases with ease, without the need for manual optimizations.\n\nIn stress-testing scenarios, Vue outperforms React and Angular by a decent margin in the js-framework-benchmark. It also goes neck-and-neck against some of the fastest production-level non-Virtual-DOM frameworks in the benchmark.\n\nDo note that synthetic benchmarks like the above focus on raw rendering performance with dedicated optimizations and may not be fully representative of real-world performance results. If you care more about page load performance, you are welcome to audit this very website using WebPageTest or PageSpeed Insights. This website is powered by Vue itself, with SSG pre-rendering, full page hydration and SPA client-side navigation. It scores 100 in performance on an emulated Moto G4 with 4x CPU throttling over slow 4G networks.\n\nYou can learn more about how Vue automatically optimizes runtime performance in the Rendering Mechanism section, and how to optimize a Vue app in particularly demanding cases in the Performance Optimization Guide.\n\nWhen you use a build tool, many of Vue's APIs are \"tree-shakable\". For example, if you don't use the built-in component, it won't be included in the final production bundle.\n\nA hello world Vue app that only uses the absolutely minimal APIs has a baseline size of only around 16kb, with minification and brotli compression. The actual size of the application will depend on how many optional features you use from the framework. In the unlikely case where an app uses every single feature that Vue provides, the total runtime size is around 27kb.\n\nWhen using Vue without a build tool, we not only lose tree-shaking, but also have to ship the template compiler to the browser. This bloats up the size to around 41kb. Therefore, if you are using Vue primarily for progressive enhancement without a build step, consider using petite-vue (only 6kb) instead.\n\nSome frameworks, such as Svelte, use a compilation strategy that produces extremely lightweight output in single-component scenarios. However, our research shows that the size difference heavily depends on the number of components in the application. While Vue has a heavier baseline size, it generates less code per component. In real-world scenarios, a Vue app may very well end up being lighter.\n\nYes. Despite a common misconception that Vue is only suitable for simple use cases, Vue is perfectly capable of handling large scale applications:\n• None Single-File Components provide a modularized development model that allows different parts of an application to be developed in isolation.\n• None Composition API provides first-class TypeScript integration and enables clean patterns for organizing, extracting and reusing complex logic.\n• None Lower barrier to entry and excellent documentation translate to lower onboarding and training costs for new developers.\n\nHow do I contribute to Vue? ​\n\nWe appreciate your interest! Please check out our Community Guide.\n\nShould I use Options API or Composition API? ​\n\nIf you are new to Vue, we provide a high-level comparison between the two styles here.\n\nIf you have previously used Options API and are currently evaluating Composition API, check out this FAQ.\n\nShould I use JavaScript or TypeScript with Vue? ​\n\nWhile Vue itself is implemented in TypeScript and provides first-class TypeScript support, it does not enforce an opinion on whether you should use TypeScript as a user.\n\nTypeScript support is an important consideration when new features are added to Vue. APIs that are designed with TypeScript in mind are typically easier for IDEs and linters to understand, even if you aren't using TypeScript yourself. Everybody wins. Vue APIs are also designed to work the same way in both JavaScript and TypeScript as much as possible.\n\nAdopting TypeScript involves a trade-off between onboarding complexity and long-term maintainability gains. Whether such a trade-off can be justified can vary depending on your team's background and project scale, but Vue isn't really an influencing factor in making that decision.\n\nHow does Vue compare to Web Components? ​\n\nVue was created before Web Components were natively available, and some aspects of Vue's design (e.g. slots) were inspired by the Web Components model.\n\nThe Web Components specs are relatively low-level, as they are centered around defining custom elements. As a framework, Vue addresses additional higher-level concerns such as efficient DOM rendering, reactive state management, tooling, client-side routing, and server-side rendering.\n\nVue also fully supports consuming or exporting to native custom elements - check out the Vue and Web Components Guide for more details."
    },
    {
        "link": "https://dev.to/xm__/vue-2-vs-vue-3-a-comprehensive-analysis-of-key-differences-improvements-and-performance-43ep",
        "document": "Vue.js is one of the most popular front-end frameworks, and with the release of Vue 3, many significant changes were introduced to improve performance, flexibility, and development experience. This blog will delve into the key differences between Vue 2 and Vue 3, highlighting the improvements and optimizations that come with Vue 3.\n• None Vue 2: Vue 2 uses to implement its reactivity system. This approach works well for most cases but faces performance issues when handling large data or deeply nested objects. Particularly, when new properties are dynamically added to an object, has limitations.\n• None Vue 3: Vue 3 introduces the use of to replace , offering a more efficient and flexible reactivity system. With , Vue 3 can intercept access to any property of an object without the need to define each property separately. This not only boosts performance but also resolves the limitations Vue 2 faced with dynamic property additions.\n• None Vue 2: Vue 2 uses the Options API, where components organize state and logic using options like , , and . While this is simple for small applications, in larger projects, as the logic in components grows, the code can become bloated and hard to manage or reuse.\n• None Vue 3: Vue 3 introduces the Composition API, which provides a new way to organize component logic. With the function, developers can more flexibly organize and reuse logic within components. The Composition API allows developers to group code by feature rather than sticking to traditional options like , , etc. This is especially helpful for large applications and promotes better maintainability and reusability of code.\n• None Vue 2: In Vue 2, lifecycle hooks such as , , and are used in the options-based approach.\n• None Vue 3: Vue 3 provides the same lifecycle hooks but within the function when using the Composition API. This tighter integration of lifecycle hooks with the rest of the component logic leads to cleaner and more organized code.\n• None Vue 2: Vue 2's support for TypeScript is somewhat limited. While it's possible to use TypeScript with Vue 2, the experience is not as seamless and requires additional configuration.\n• None Vue 3: Vue 3 has full TypeScript support, with type declarations for all core features and official documentation for using TypeScript. The enhanced TypeScript support in Vue 3 improves the developer experience, offering better maintainability and scalability for larger projects.\n• None Vue 2: While Vue 2 performs well in most cases, it can encounter performance bottlenecks when rendering complex templates or managing reactivity in large applications.\n• \n• Faster Virtual DOM: Vue 3’s virtual DOM is more efficient than Vue 2, resulting in faster rendering and updates, especially for large components.\n• More Efficient Reactivity System: Thanks to , Vue 3's reactivity system is more flexible and efficient, especially when handling large data sets.\n• Tree-shaking: Vue 3 uses modern build tools that support tree-shaking, reducing the size of the final bundle by removing unused code.\n• None Vue 2: In Vue 2, components were required to have a single root element, which posed limitations for certain complex layouts.\n• None Vue 3: Vue 3 introduces Fragment, allowing components to return multiple root nodes. It also adds Teleport (to move child components' DOM to different parts of the page) and Suspense (for handling asynchronous loading and lazy-loaded components).\n• None Vue 2: Vue 2's routing and state management libraries (Vue Router and Vuex) are similar to Vue 3, but Vue 3 introduces optimizations to better integrate with its new features.\n• None Vue 3: Vue Router and Vuex have been updated for Vue 3, offering better TypeScript support and improved compatibility with the Composition API. Vuex has also been optimized for better performance.\n• Improved Performance: Significant performance improvements in virtual DOM handling and reactivity, making rendering and updates faster.\n• Composition API: A more flexible and modular way to organize code, especially for large applications, making it easier to maintain and reuse logic.\n• Smaller Bundle Size: Vue 3 has a smaller footprint and supports tree-shaking, resulting in more optimized builds.\n• New Features: New capabilities like Fragment, Teleport, and Suspense enhance component flexibility, especially for handling asynchronous tasks and complex layouts.\n\nVue 3 brings many groundbreaking improvements and optimizations over Vue 2, particularly in terms of performance, flexibility, and developer experience. For large projects, Vue 3's Composition API, TypeScript support, and performance optimizations make it a significant upgrade. While Vue 2 is still a great choice for smaller projects due to its simplicity, Vue 3 is rapidly becoming the standard for modern Vue development. Choosing between Vue 2 and Vue 3 depends on the project's needs, but as Vue 3 continues to evolve, it is expected to dominate the Vue ecosystem."
    },
    {
        "link": "https://medium.com/simform-engineering/a-comprehensive-vue-2-to-vue-3-migration-guide-a00501bbc3f0",
        "document": "Composition API provides a flexible way to organize component logic. This makes it easier to reuse code across components with better type checking. The Composition API is easier to maintain than the Options API.\n\nWhile the Composition API was already available in Vue 2.7 through the officially maintained plugin. In Vue 3, it is primarily used in conjunction with the\n\nVue 3’s codebase is entirely written in TypeScript with auto-generated type definitions. It has better type inference and support for TypeScript’s optional chaining and null coalescing operators.\n\nVirtual DOM has been completely redesigned in Vue 3. It utilizes a new diffing algorithm with compiler-based optimizations to speed up rendering.\n\nIn Vue 3, we can create multiple roots for a single component which was not feasible in Vue 2.\n\nVue 3 Syntax: Components now can have multiple root nodes! However, this does require developers to explicitly define where attributes should be distributed.\n\nis a built-in component that allows us to \"teleport\" a part of a component's template into a DOM node that exists outside the DOM hierarchy of that component.\n\nThe target of expects a CSS selector string or an actual DOM node. The teleport the target must be already in the DOM when the component is mounted.\n\nIn Vue 3, style tags support linking CSS values to dynamic component state using the CSS function.\n\nIn Vue 3, filters are removed. Instead, we can use methods or computed properties. You can refer below example.\n• BREAKING: 's modifier and component option is removed and replaced with an argument on\n• NEW: Multiple bindings on the same component are possible now\n• NEW: Added the ability to create custom modifiers.\n\nIn Vue 2, the attribute allowed child components to use their inner content as a template instead of distributing it.\n\nHowever, Vue 3 no longer supports this feature. If you were using in Vue 2, you can refactor the component using the default slot instead. This approach provides explicit data scoping while still allowing you to write child content inline for added convenience.\n\nIn Vue 3, named and scoped slots have different syntaxes. To identify the slot name, use the v-slot directive or its # shorthand.\n\nTechnically, Vue 2 doesn’t have a concept of an “app”. What we define as an app is simply a root Vue instance created via . Every root instance created from the same Vue constructor shares the same global configuration.\n\nThis global configuration poses challenges when using the same Vue instance for multiple “apps” on the same page with different global configurations.\n\nTo avoid these problems, Vue 3 introduces a new way to create Vue app — createApp.\n\nNEW: is no longer necessary on / / branches since Vue now automatically generates unique .\n\nBREAKING: If you manually provide , each branch must use a unique . \n\nBREAKING: should be placed on the tag (rather than on its children).\n\nIn Vue 2: When using and on the same element, would take precedence.\n\nIn Vue 3: will always have higher precedence than\n\nWe’ll use one sample Vue 2 app to illustrate the migration procedure. You may clone this repository if you would like to practice with it as well.\n\nBefore installing the migration build, you need to check a few things:\n\n1. Update any deprecated named/scoped slot syntax to the latest version. Click here for the ref link.\n\n2. If you are using a custom webpack, update the vue-loader to the latest version.\n\n3. For vue-cli users, upgrade @vue/cli-service to the latest version.\n• Install also known as Vue’s migration build, with the same version as the updated one\n\nThen, configure the alias to and compiler options in as shown below.\n\nAfter switching to the migration build, you’ll encounter runtime warnings (in the browser console) and compiler warnings (in the command line). It’s best to address compiler warnings first, as some may break the application, such as the use of filters.\n\nThe Migration Build may not be fully compatible with Vue 3, so starting your application might not work. First, fix the deprecations.\n\nMany packages are now compatible with Vue 3. Update them to their latest versions. If you can’t find a Vue 3 compatible version for some packages, find suitable replacements.\n\nYou may be able to execute your app now, but hold off on celebrating just yet. There’s still work to be done. When you run your application, you’ll encounter console warnings like the ones below.\n\nThese warnings need to be fixed.\n\nEach warning has an identifier (e.g., GLOBAL_MOUNT, OPTIONS_DATA_FN, etc.). You can find a complete list of all the different warnings here.\n\nThis step is not necessary but recommended.\n\nStep 7: Test and Assure Your App Performance and Stability\n\nThoroughly test your migrated components to ensure their functionality in the Vue 3 environment. Leverage the Vue Devtools extension to debug and inspect your application during migration.\n\nOnce testing is complete and your application runs perfectly in Vue 3, it’s time to wrap things up!\n• Remove the changes we made at the beginning of the article to vue.config.js."
    },
    {
        "link": "https://dev.to/jacobandrewsky/understanding-vues-virtual-dom-108p",
        "document": "How to Use Provide/Inject in Vue\n\nTop 10 Vue.js libraries you should be using in 2025\n\nVue.js is a progressive JavaScript framework that offers a reactive and efficient way to build user interfaces. One of the key components that contribute to its performance and responsiveness is the Virtual DOM.\n\nIn this article, we'll explore how Vue’s Virtual DOM works can help optimize your applications and write more efficient code.\n\n🤔 What is the Virtual DOM?\n\nThe Virtual DOM (VDOM) is an abstraction of the real DOM. Instead of directly manipulating the actual DOM, Vue creates a lightweight copy of it in memory. This virtual representation allows Vue to perform efficient updates by determining the minimal number of changes needed before applying them to the real DOM.\n• Rendering: When a Vue component renders, a Virtual DOM tree is created using JavaScript objects that describe the UI structure.\n• Diffing Algorithm: When a component’s state changes, Vue creates a new Virtual DOM tree and compares it with the previous version. The framework uses a diffing algorithm to identify the differences between the two trees.\n• Patching Process: After identifying the changes, Vue applies only the necessary updates to the real DOM through a process called patching. This minimizes re-renders and improves performance.\n\n🟢 Benefits of Using Vue’s Virtual DOM and how we can optimize it?\n\nUsing Vue's Virtual DOM comes with many benefits such as:\n• Performance Optimization: Since updates are calculated in memory before applying changes to the actual DOM, Vue minimizes unnecessary reflows and repaints, making applications more efficient.\n• Improved Developer Experience: The declarative nature of Vue’s rendering process allows developers to focus on state management and UI logic without worrying about manual DOM manipulation.\n• Cross-Platform Compatibility: The Virtual DOM enables Vue to work seamlessly across different environments, including mobile frameworks like Weex and NativeScript.\n\nAlthough Vue’s Virtual DOM is optimized by default, developers can take additional steps to ensure their applications run efficiently:\n• Use Keyed v-for Lists: Adding a unique key when rendering lists helps Vue track changes more efficiently.\n• Lazy Loading and Code Splitting: Load components only when needed to reduce initial load time.\n• Avoid Unnecessary Component Re-renders: Use computed properties and watchers strategically to prevent excessive reactivity updates.\n• Use Functional Components: For stateless components, functional components offer improved performance as they don’t have an instance of their own.\n\nIf you would like to learn more about Vue, Nuxt, JavaScript or other useful technologies, checkout VueSchool by clicking this link or by clicking the image below:\n\nIt covers most important concepts while building modern Vue or Nuxt applications that can help you in your daily work or side projects 😉\n\nVue’s Virtual DOM is a powerful mechanism that improves performance and optimizes UI updates. By understanding how it works and implementing best practices, you can build efficient, high-performing Vue applications.\n\nTake care and see you next time!\n\nAnd happy coding as always 🖥️"
    },
    {
        "link": "https://albiorixtech.com/blog/vue2-vs-vue3-with-top-differences",
        "document": "Often there exists many leading front-end frameworks like , React, and Vue.JS that make the work easy for the developers to build robust web applications. Among all such frameworks, Vue.js is solely responsible for building rich user interfaces.\n\nIf you’re completely new to working with VueJS, the first question that might hit your mind is: which stable versions you should go for? Right. If we talk about Vue2, it’s currently hitting the market and is used globally by almost all companies to create a responsive web application.\n\nWith the launch of Vue 3, developers are curious to know the technical concepts introduced in the latest version of Vue. Vue 3 has come up with innovative features that make your application faster and include capable libraries to make your web app more responsive.\n\nBefore, we start to understand the concept of the difference between Vue 2 and Vue 3, we need to start with the framework journey. Vue.js started its journey as a simple runtime library. As time evolved, it evolved to convert from a library to a framework. And yes, today, Vue.js is popularly known as an approachable, performant and versatile framework that plays a vital role to build web user interfaces.\n\nVue.js 2 is a widely used JavaScript framework for building user interfaces. It is known for its simplicity and flexibility, allowing web developers to create interactive web app easily. Vue.js 2 provides a reactive and component-based architecture, where the application’s UI is divided into reusable components.\n\nVue.js 3 is the Current version of the Vue.js JavaScript framework, designed for building modern and performant web applications. It introduces several significant improvements and optimizations compared to its predecessor, Vue 2. Vue 3 focuses on improved performance, smaller bundle sizes, enhanced TypeScript support.\n\nVue 3 is the Composition API, It offers a more flexible and modular approach to organizing code within components.\n\nAdditionally, Vue.js 3 enhances the virtual DOM algorithm for more efficient rendering and updates, resulting in faster application performance.”\n\nVue 2 is still being used by multiple companies around the globe, owing both to its diffrent benefits and the short time for which Vue 3 has been out and Vue 2 will set to the end of 2023.\n\nNow, it’s high time to see the technical difference between Vue2 vs Vue3 by understanding the demonstration of every aspect.\n• The first difference between Vue 2 VS Vue 3 is creating an app from scratch. You must do the standard application process, including installing Vue CLI (Command Line Interface). To make it easy for you, please enter the following command to install CLI:\n\nnpm i -g @vue/cli\n• To install Vue 2, you need to enter the command: npm install vue@2.x.x\n• To install the latest version (for this case Vue 3), type the command: npm install vue There exists a minor syntax distinction and also some basic structural and major changes. Example of main.js file for Vue 2 Example of main.js file for Vue 3\n• In Vue 2, you are allowed only to implement a single root element; else an error will be thrown for multiple roots. It’s not the case with Vue 3, you can add multiple root elements in the same template. As you can see there are two elements included in the template, it will not proceed further in the Vue2 app. If we give the element inside the in the Vue2 app, you receive the following error message. But in the case of Vue 3, such a message never appears. As you can see the below figure that there are two web components (HelloWorld and AppForm) included in the file. Example of HelloWorld and AppForm components <script> import HelloWorld from './components/HelloWorld.vue' import AppForm from './components/AppForm.vue' export default { name: 'App', components: { HelloWorld, AppForm } } </script> And if we run the application, the outcome is\n• Before we start to understand creating methods in Vue2 and Vue3 applications, we need to create a template and prepare a well-defined data structure for the app. Let’s start with creating component options with the Vue2 application. As defined earlier, Vue 3 typically supports Fragments. In simple words, components can have more than one root node. We have created a root node as Form components in Vue2 as well as the Vue3 app.\n• Now, it’s time to set up the data for the Vue app. If we talk about Vue 2 VS Vue 3, Options API and Composition API are responsible for handling the data. With the help of Options API, the Vue.JS Developers can easily separate the cleaner code into different properties in Vue: data, computed properties, methods, etc. And if we talk about the Composition API, unlike the Options API, it allows the developers to group code by function rather than the specific property type. For our form component, let’s say we just have two different properties: emp.username and emp.password. The Vue2 code in Composition API would look like this – we have entered two values in the data property. Vue 2 Code with two values in the data property In Vue 3, the developers need to work with the new setup() method in Composition API where the entire same component initialization takes place. Moreover, the developers can quickly have more control over what is reactive, we have direct access to Vue’s reactivity API. The process for creating reactive datas using Composition API includes three easy steps:\n• Data declaration using the reactive and Ref() method\n• Setup() method returns the reactive datas with the aim that the template can access it The code looks like this:\n• After setting up the data using Composition API, it’s time to create a setup () method for your Vue app. First of all, we’ll see the process for vue2 vs vue3 and we’ll start by creating a method in the Vue2 app. How to create a method in the Vue 2 application? How to create a method in the Vue 3 application? In Vue3, Composition API typically handles methods. In simple words, it is like declaring data – we have to first declare our setup method and then return it so that other parts of our component can access it. <script> import {reactive} from \"vue\";export default { props: { title: String, }, setup() { const state = reactive({ empusername: \"\", emppassword: \"\", }); const login = () => { //login method goes here }; return { state, login}; }, }; </script> Albiorix is a one-stop solution having a team of talented Vue.js developers that always strive to upscale the applications as per your business.\n• In Vue 2, the developers can access lifecycle hooks directly from the component options. As we know, for Vue 3 Composition API, the setup method includes the mounted lifecycle hook. Remember that lifecycle hooks are not included by default. The Vue.js developers available on hire need to import the onMounted() method to initiate the lifecycle hooks. Then, inside our setup method of lifecycle hooks, we can use the onMounted method by passing it our function. <script> import {reactive} from \"vue\";export default { props: { title: String, }, setup() { const state = reactive({ empusername: \"\", emppassword: \"\", }); onMounted (() => { console.log(\"component mounted\"); }); const login = () => { //login method goes here }; return { state, login}; }, }; </script>\n• Vue2 app has a separate section for computed properties but you can define a function in the setup method. We will highlight a simple example to demonstrate the implementation of computed in the setup method. We will return ‘Yes’ or ‘No’, by passing the condition to check whether author’s name length is greater than 0. In the case of the Vue3 app, the developers need to mandatorily import the essential packages they need in the app. Essentially, they didn’t want developers to have to include things they never used, which was becoming a growing problem in Vue2. Related Post: Angular Vs React Vs Vue: Which is the Best Framework To Use So to use computed properties in Vue 3, the developers will have to import computed into our component. Then, similarly to how we created our reactive data earlier, we can make a piece of reactive data a computed value like this: export default { data() { return { author: { name: 'Oliver Smith', books: [ 'Book 1', 'Book 2', 'Book 3' ] } } }, computed: { publishedBooksMessage() { return this.author.books.length > 0 ? 'Yes' : 'No' } } }<template> <p>Has published books:</p> <span>{{ publishedBooksMessage }}</span> </template> When we check the browser, the outcome is:\n\n On the other hand, if we go for Composition API, the code will be something like this: <template> <div> <p>Has published books:</p> <span>{{ publishedBooksMessage }}</span> </div> </template> <script setup> import { reactive, computed } from \"vue\"; const author = reactive({ name: 'Oliver Smith', books: [ 'Book 1', 'Book 2', 'Book 3' ] }) const publishedBooksMessage = computed(() => { return author.books.length > 0 ? 'Yes' : 'No' }) </script>\n• Accessing props is an essential thing that differentiates between Vue 2 VS Vue 3. In Vue 2, this would almost always refer to the component, not a specific property. While this made things easy on the surface, it made type support a pain. However, we could easily access props – let’s just add a trivial example like printing out our title prop during the mounted hook: However, in Vue 3, we no longer use this to access props, emit events, and get properties. Instead, the setup() method takes two arguments: Using the props argument, the above code would look like this.\n• Similarly, emitting events in Vue 2 is very straightforward, but Vue 3 gives you more control over how properties/methods are accessed. Let’s say, in our case, that we want to emit a login event to a parent component when the “Submit” button is pressed. The Vue 2 code would just have to call this.$emit and pass in our payload object. However, in Vue 3, we now know that this no longer means the same thing, so we have to deal with that particular parent component differently. Luckily, the context object exposes emit that gives us the same thing as this.$emit All we have to do is add context as the second parameter to our setup method. We’re going to be destructuring the context object to make our code more concise. Then, we just call emit as a second parameter to send our event. Then, just like before, the emit method takes two arguments:\n• The name of our event\n• A payload object to pass with our event\n• Portal is a feature where we can render a part of the code in one component into a different component in another DOM tree. There was a third-party plugin called portal-vue that achieved this in Vue 2 to deal with the same component functionality. In Vue 3, you’ll find it easy to use an in-built portal and very easy to use. Vue 3 will have a unique tag called <Teleport>, and any code enclosed within this tag will be ready to be teleported anywhere. The Teleport tag takes a to an argument.\n\nLet’s take a simple example to understand the concept of portals. <Teleport to=\"#modal-layer\"> <div class=\"modal\"> Hey, Everyone!!! </div> </Teleport> Any code inside <Portal></Portal> will be displayed in the target location mentioned. <div id=\"modal-target\"></div> At the time of writing this article, <Teleport> doesn’t work in the Alpha version mentioned above.\n• In the difference between Vue 3 Vs Vue 2, createApp is the setup method, that is introduced to initialize the app. This initialization code method returns a new instance of a Vue app. Each instance can have its own functionalities without affecting the other instances.\n\nAlthough creating multiple apps for multiple roots in the same app is not common, this might come in handy when the project grows in size. With Vue3, compared to Vue 2, it is possible to configure each Vue app as an independent object. It is also possible to share some functionalities among several instances.\n\nWhat Are the Most Important Improvements From Vue 2 to Vue 3?\n\nVue 3 introduces several important improvements compared to Vue 2. Some of the key enhancements are:\n• Composition API: Vue 3 introduces the Composition API, which provides a more flexible and modular way to organize code within components.\n• Improved Performance: Vue 3 brings significant performance improvements. The new reactivity system in Vue 3 utilizes a proxy-based approach, resulting in faster updates to the user interface.\n• Smaller Bundle Sizes: Vue 3 comes with a more efficient template compiler that generates smaller bundle sizes. This reduces the overall size of the application, resulting in faster loading times and better performance.\n• Better TypeScript Support: Vue 3 offers improved TypeScript integration and support out of the box. The new version provides enhanced TypeScript typings, making it easier for developers to use TypeScript in their Vue projects and benefit from static type checking and IDE tooling.\n• Easier Error Handling and Debugging: Vue 3 introduces better error handling and debugging capabilities. It provides more informative error messages and warnings, helping developers identify and resolve issues more efficiently during the development process.\n• Vue Router and Vuex Integration: Vue 3 provides enhanced integration with Vue Router and Vuex, the official routing and state management libraries for Vue.js. The updated versions of Vue Router and Vuex are optimized for Vue 3 and offer improved performance and features.\n\nThese improvements make Vue 3 a more powerful and efficient framework for building modern web applications, providing developers with enhanced flexibility and performance.\n\nAfter analysing major new changes with vue2 vs vue3, we can say that:\n• Vue 3 is said to be faster, smaller, more maintainable and easier to target natives compared to Vue 2.\n• Vue 3 is more or less a rewritten version of Vue 2 and comes with some new and significant changes and features.\n• The basic syntax of vue2 vs vue3 are very similar.\n\nStill, if you find any queries regarding creating a new web app using the VueJS framework or want to migrate to Vue 3, feel free to contact us. Albiorix is a leading Vue.js development company having a team of talented developers to provide the best optimum IT solutions."
    },
    {
        "link": "https://vuejs.org/guide/extras/rendering-mechanism",
        "document": "How does Vue take a template and turn it into actual DOM nodes? How does Vue update those DOM nodes efficiently? We will attempt to shed some light on these questions here by diving into Vue's internal rendering mechanism.\n\nYou have probably heard about the term \"virtual DOM\", which Vue's rendering system is based upon.\n\nThe virtual DOM (VDOM) is a programming concept where an ideal, or “virtual”, representation of a UI is kept in memory and synced with the “real” DOM. The concept was pioneered by React, and has been adopted in many other frameworks with different implementations, including Vue.\n\nVirtual DOM is more of a pattern than a specific technology, so there is no one canonical implementation. We can illustrate the idea using a simple example:\n\nHere, is a plain JavaScript object (a \"virtual node\") representing a element. It contains all the information that we need to create the actual element. It also contains more children vnodes, which makes it the root of a virtual DOM tree.\n\nA runtime renderer can walk a virtual DOM tree and construct a real DOM tree from it. This process is called mount.\n\nIf we have two copies of virtual DOM trees, the renderer can also walk and compare the two trees, figuring out the differences, and apply those changes to the actual DOM. This process is called patch, also known as \"diffing\" or \"reconciliation\".\n\nThe main benefit of virtual DOM is that it gives the developer the ability to programmatically create, inspect and compose desired UI structures in a declarative way, while leaving the direct DOM manipulation to the renderer.\n\nAt the high level, this is what happens when a Vue component is mounted:\n• None Compile: Vue templates are compiled into render functions: functions that return virtual DOM trees. This step can be done either ahead-of-time via a build step, or on-the-fly by using the runtime compiler.\n• None Mount: The runtime renderer invokes the render functions, walks the returned virtual DOM tree, and creates actual DOM nodes based on it. This step is performed as a reactive effect, so it keeps track of all reactive dependencies that were used.\n• None Patch: When a dependency used during mount changes, the effect re-runs. This time, a new, updated Virtual DOM tree is created. The runtime renderer walks the new tree, compares it with the old one, and applies necessary updates to the actual DOM.\n\nVue templates are compiled into virtual DOM render functions. Vue also provides APIs that allow us to skip the template compilation step and directly author render functions. Render functions are more flexible than templates when dealing with highly dynamic logic, because you can work with vnodes using the full power of JavaScript.\n\nSo why does Vue recommend templates by default? There are a number of reasons:\n• None Templates are closer to actual HTML. This makes it easier to reuse existing HTML snippets, apply accessibility best practices, style with CSS, and for designers to understand and modify.\n• None Templates are easier to statically analyze due to their more deterministic syntax. This allows Vue's template compiler to apply many compile-time optimizations to improve the performance of the virtual DOM (which we will discuss below).\n\nIn practice, templates are sufficient for most use cases in applications. Render functions are typically only used in reusable components that need to deal with highly dynamic rendering logic. Render function usage is discussed in more detail in Render Functions & JSX.\n\nThe virtual DOM implementation in React and most other virtual-DOM implementations are purely runtime: the reconciliation algorithm cannot make any assumptions about the incoming virtual DOM tree, so it has to fully traverse the tree and diff the props of every vnode in order to ensure correctness. In addition, even if a part of the tree never changes, new vnodes are always created for them on each re-render, resulting in unnecessary memory pressure. This is one of the most criticized aspect of virtual DOM: the somewhat brute-force reconciliation process sacrifices efficiency in return for declarativeness and correctness.\n\nBut it doesn't have to be that way. In Vue, the framework controls both the compiler and the runtime. This allows us to implement many compile-time optimizations that only a tightly-coupled renderer can take advantage of. The compiler can statically analyze the template and leave hints in the generated code so that the runtime can take shortcuts whenever possible. At the same time, we still preserve the capability for the user to drop down to the render function layer for more direct control in edge cases. We call this hybrid approach Compiler-Informed Virtual DOM.\n\nBelow, we will discuss a few major optimizations done by the Vue template compiler to improve the virtual DOM's runtime performance.\n\nQuite often there will be parts in a template that do not contain any dynamic bindings:\n\nThe and divs are static - re-creating vnodes and diffing them on each re-render is unnecessary. The renderer creates these vnodes during the initial render, caches them, and reuses the same vnodes for every subsequent re-render. The renderer is also able to completely skip diffing them when it notices the old vnode and the new vnode are the same one.\n\nIn addition, when there are enough consecutive static elements, they will be condensed into a single \"static vnode\" that contains the plain HTML string for all these nodes (Example). These static vnodes are mounted by directly setting .\n\nFor a single element with dynamic bindings, we can also infer a lot of information from it at compile time:\n\nWhen generating the render function code for these elements, Vue encodes the type of update each of them needs directly in the vnode creation call:\n\nThe last argument, , is a patch flag. An element can have multiple patch flags, which will be merged into a single number. The runtime renderer can then check against the flags using bitwise operations to determine whether it needs to do certain work:\n\nBitwise checks are extremely fast. With the patch flags, Vue is able to do the least amount of work necessary when updating elements with dynamic bindings.\n\nVue also encodes the type of children a vnode has. For example, a template that has multiple root nodes is represented as a fragment. In most cases, we know for sure that the order of these root nodes will never change, so this information can also be provided to the runtime as a patch flag:\n\nThe runtime can thus completely skip child-order reconciliation for the root fragment.\n\nTaking another look at the generated code from the previous example, you'll notice the root of the returned virtual DOM tree is created using a special call:\n\nConceptually, a \"block\" is a part of the template that has stable inner structure. In this case, the entire template has a single block because it does not contain any structural directives like and .\n\nEach block tracks any descendant nodes (not just direct children) that have patch flags. For example:\n\nThe result is a flattened array that contains only the dynamic descendant nodes:\n\nWhen this component needs to re-render, it only needs to traverse the flattened tree instead of the full tree. This is called Tree Flattening, and it greatly reduces the number of nodes that need to be traversed during virtual DOM reconciliation. Any static parts of the template are effectively skipped.\n\nand directives will create new block nodes:\n\nA child block is tracked inside the parent block's array of dynamic descendants. This retains a stable structure for the parent block.\n\nBoth patch flags and tree flattening also greatly improve Vue's SSR Hydration performance:\n• None Single element hydration can take fast paths based on the corresponding vnode's patch flag.\n• None Only block nodes and their dynamic descendants need to be traversed during hydration, effectively achieving partial hydration at the template level."
    },
    {
        "link": "https://vuejs.org/guide/extras/render-function",
        "document": "Vue recommends using templates to build applications in the vast majority of cases. However, there are situations where we need the full programmatic power of JavaScript. That's where we can use the render function.\n\nVue provides an function for creating vnodes:\n\nis short for hyperscript - which means \"JavaScript that produces HTML (hypertext markup language)\". This name is inherited from conventions shared by many virtual DOM implementations. A more descriptive name could be , but a shorter name helps when you have to call this function many times in a render function.\n\nThe function is designed to be very flexible:\n\n// all arguments except the type are optional // both attributes and properties can be used in props // Vue automatically picks the right way to assign it // props modifiers such as `.prop` and `.attr` can be added // with `.` and `^` prefixes respectively // class and style have the same object / array // value support that they have in templates // event listeners should be passed as onXxx // props can be omitted when there are no props // children array can contain mixed vnodes and strings\n\nThe resulting vnode has the following shape:\n\nIf a render function component doesn't need any instance state, they can also be declared directly as a function for brevity:\n\nThat's right, this is a valid Vue component! See Functional Components for more details on this syntax.\n\nAll vnodes in the component tree must be unique. That means the following render function is invalid:\n\nIf you really want to duplicate the same element/component many times, you can do so with a factory function. For example, the following render function is a perfectly valid way of rendering 20 identical paragraphs:\n\nJSX is an XML-like extension to JavaScript that allows us to write code like this:\n\nand Vue CLI both have options for scaffolding projects with pre-configured JSX support. If you are configuring JSX manually, please refer to the documentation of for details.\n\nAlthough first introduced by React, JSX actually has no defined runtime semantics and can be compiled into various different outputs. If you have worked with JSX before, do note that Vue JSX transform is different from React's JSX transform, so you can't use React's JSX transform in Vue applications. Some notable differences from React JSX include:\n• You can use HTML attributes such as and as props - no need to use or .\n\nVue's type definition also provides type inference for TSX usage. When using TSX, make sure to specify in so that TypeScript leaves the JSX syntax intact for Vue JSX transform to process.\n\nSimilar to the transform, Vue's JSX also needs different type definitions.\n\nStarting in Vue 3.4, Vue no longer implicitly registers the global namespace. To instruct TypeScript to use Vue's JSX type definitions, make sure to include the following in your :\n\nYou can also opt-in per file by adding a comment at the top of the file.\n\nIf there is code that depends on the presence of the global namespace, you can retain the exact pre-3.4 global behavior by explicitly importing or referencing in your project, which registers the global namespace.\n\nBelow we will provide some common recipes for implementing template features as their equivalent render functions / JSX.\n\nProps with names that start with followed by an uppercase letter are treated as event listeners. For example, is the equivalent of in templates.\n\nFor the , , and event modifiers, they can be concatenated after the event name using camelCase.\n\nFor other event and key modifiers, the helper can be used:\n\nTo create a vnode for a component, the first argument passed to should be the component definition. This means when using render functions, it is unnecessary to register components - you can just use the imported components directly:\n\nAs we can see, can work with components imported from any file format as long as it's a valid Vue component.\n\nIf a component is registered by name and cannot be imported directly (for example, globally registered by a library), it can be programmatically resolved by using the helper.\n\nPassing children to components works a bit differently from passing children to elements. Instead of an array, we need to pass either a slot function, or an object of slot functions. Slot functions can return anything a normal render function can return - which will always be normalized to arrays of vnodes when accessed in the child component.\n\nPassing slots as functions allows them to be invoked lazily by the child component. This leads to the slot's dependencies being tracked by the child instead of the parent, which results in more accurate and efficient updates.\n\nTo render a scoped slot in the parent component, a slot is passed to the child. Notice how the slot now has a parameter . The slot will be called in the child component and the data from the child component will be passed up to the parent component.\n\nRemember to pass so the slots will not be treated as props.\n\nBuilt-in components such as , , , and must be imported for use in render functions:\n\nThe directive is expanded to and props during template compilation—we will have to provide these props ourselves:\n\nCustom directives can be applied to a vnode using :\n\nIf the directive is registered by name and cannot be imported directly, it can be resolved using the helper.\n\nFunctional components are an alternative form of component that don't have any state of their own. They act like pure functions: props in, vnodes out. They are rendered without creating a component instance (i.e. no ), and without the usual component lifecycle hooks.\n\nTo create a functional component we use a plain function, rather than an options object. The function is effectively the function for the component.\n\nMost of the usual configuration options for components are not available for functional components. However, it is possible to define and by adding them as properties:\n\nIf the option is not specified, then the object passed to the function will contain all attributes, the same as . The prop names will not be normalized to camelCase unless the option is specified.\n\nFor functional components with explicit , attribute fallthrough works much the same as with normal components. However, for functional components that don't explicitly specify their , only the , , and event listeners will be inherited from the by default. In either case, can be set to to disable attribute inheritance:\n\nFunctional components can be registered and consumed just like normal components. If you pass a function as the first argument to , it will be treated as a functional component.\n\nFunctional Components can be typed based on whether they are named or anonymous. Vue - Official extension also supports type checking properly typed functional components when consuming them in SFC templates."
    },
    {
        "link": "https://medium.com/js-dojo/diving-into-the-vue-3s-virtual-dom-a6b4744032ec",
        "document": "In this article, we do a dive into the virtual dom in Vue.js 3, and how we can traverse it with the goal of finding a specific component (or what we will call a - more on this soon).\n\nMost of the time, you don’t need to think about how Vue internally represents your components. Some libraries do make sure of this though — one such library is Vue Test Utils and it’s function. Another such use case is the Vue DevTools, which show you the component hierarchy for your application, seen on the left hand side of this screenshot.\n\nNote: this is a technical article. While I will do my best to explain how everything works, the only real way to fully grasp this is to write your own code and a lot, to see what's really happening. This is often the nature of the type of recursive algorithm we will be writing.\n\nAn alternative would be to watch the accompanying screencast, will I will make free indefinitely. You can find the source code for this example here.\n\nFor various reasons, one of which is performance, Vue keeps an internal representation of the component hierarchy. This is called a Virtual DOM (VDOM). When something changes (for example a prop) Vue will figure out if something needs to be updated, calculate the new representation, and finally, update the DOM. A trivial example might be:\n\nIt could be represented like this:\n\nSo it would be . If becomes , Vue would update it’s Virtual DOM:\n\nThen, finally, Vue would update the DOM, removing the .\n\nOur goal will be to implement a subset of , part of the Vue Test Utils API. We will write something like this:\n\nTo have a working function, we need to traverse the Virtual DOM, a tree like structure of arbitrary depth. Let's get started.\n\nIf you would like to follow along, you can grab the source code here. We will just use Node.js (v14, so we can use the or \"optional chaining\" operator). You will need Vue, jsdom and jsdom-global installed.\n\nStart with setting up a simple app with some components:\n\nSome of the components have and - this will be useful as we investigate the Virtual DOM Vue creates for our app.\n\nIf you go ahead and do either or , you don't see anything - just . will only show enumerable properties - ones that show up in a loop. There are some hidden non enumerable properties, though, which we can . Try doing . You get a whole bunch of information:\n\nYou can do to have a summary of what's available:\n\nIt’s obvious what some of the properties do — and for example. is used for the new feature. is something every Vue dev knows, same as . , , etc are lifecycle hooks - is , is . There are some internal only lifecycle hooks, like - it's , used for updates after something changes and causes a re-render, like or changing.\n\nWe are interested in , , , and .\n\nLet’s take a look at . Again it has many properties, the two we will look at are and :\n\nis of interest! It matches the component we defined earlier. You can see it has a function (we defined one with a variable). In fact, if we compare this to :\n\nIt matches! We can also do the same comparison with : . I am not entirely clear on why there is two properties pointing to the same object. I am still learning. Anyway, we identified a way to match components.\n\nAfter a little trial and error, you can eventually find like this:\n\nIn this case, the node would have a array with a length of 2.\n\nNow we know the recursive nature of the Virtual DOM, we can write a recursive solution! It goes and so on.\n\nI am using Node.js v14, which supports optional chaining: for example. Before we write a recursive find function, we need some way to know if we have found the component: :\n\nYou could write but I like the verbose one a little more.\n\nWe will write two functions. , which will be the public API that users call, and , an internal, recursive function.\n\nThe third argument is an empty array — because are writing a recursive function, we need some place to keep the components we have found that match the target. We will store them in this array, passing it to each recursive call of . This way we avoid mutating an array - I find less mutation leads to less bugs (your mileage may vary).\n\nWhen writing a recursive function, you need to have some way to exit, or you will get stuck in an endless loop. Let’s start with that:\n\nIf we have recursed all the way to the bottom of the Virtual DOM (and checked all vnodes in the process) we just return. This will ensure we do not get stuck in a loop. If we run this now:\n\nWhile traversing the vnodes, if we find a matching component, we will just return it. If we did not find a matching component, we may need to dive deeper by checking if is defined. Finally, if it's not, we return the accumulator.\n\nIf you do a inside of the block, you will see we are now at the component subTree. Remember, the path to is as follows:\n\nBy calling again: , the first argument to on the next iteration will be , which is an array of . That means we need to do on the next iteration of - but we are only checking . We need a check for as well:\n\nAnd somewhat surprisingly, that’s it. now returns a reference to . You can see it working like this:\n\nIf you have used Vue Test Utils before, you may recognise this in a slightly different syntax: , which is actually accessing the internally (for Vue 3) and the for Vue 2. If you are using TypeScript, you may notice does not show up as a valid type - that's because it is internal, not generally intended for use in regular applications, although some internal tools still use it, like Vue Test Utils and Vue DevTools.\n\nThis implementation is far from perfect — there are more checks that need to be implemented. For example, this does not work with components using instead of , or . A more complete implementation can be found here in the Vue Test Utils source code.\n\nAt the time of this article, the implementation there mutates an array instead of passing a new copy to each recursive call. You can see it here — the functions you want to look at are and .\n\nYou can find the source code for this example here."
    },
    {
        "link": "https://kxming.medium.com/usage-of-h-in-vue3-2b6f6fbc748b",
        "document": "According to Vue’s official documentation, it is a rendering function used to create virtual DOM nodes. When building a page with HTML tags in a Vue project, the final result will be converted into a vnode. The function creates a vnode directly, allowing for more flexibility in constructing component rendering logic and improving performance.\n\nThe rendering function has three parameters, of which the second and third are optional:\n• : The type of node to create, which can be an HTML tag, component, or function (functional component).\n• (optional): An object containing properties for the node, passed as a prop.\n• (optional): Child nodes that can be strings, arrays, or other vnode objects.\n• HTML tag: If there is a string, it will be parsed as an HTML tag.\n• Component: If the is an object or function, it will be parsed as a Vue component."
    },
    {
        "link": "https://gitnation.com/contents/building-the-vue-3-vdom-on-stage",
        "document": "We love easily created and deployed web applications! So, let’s see what a very current tech stack like Nuxt 3, Motion UI and Azure Static Web Apps can do for us. It could very well be a golden trio in modern day web development. Or it could be a fire pit of bugs and errors. Either way it will be a learning adventure for us all. Nuxt 3 has been released just a few months ago, and we cannot wait any longer to explore its new features like its acceptance of Vue 3 and the Nitro Engine. We add a bit of pizzazz to our application with the Sass library Motion UI, because static design is out, and animations are in again.Our driving power of the stack will be Azure. Azure static web apps are new, close to production and a nifty and quick way for developers to deploy their websites. So of course, we must try this out.With some sprinkled Azure Functions on top, we will explore what web development in 2022 can do."
    }
]