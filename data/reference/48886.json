[
    {
        "link": "https://w3schools.com/js/js_htmldom_animate.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://vladbatushkov.medium.com/react-native-animated-in-javascript-game-1a9859f49b10",
        "document": "React Native Animated library is a simple, but powerful tool to manage animation. I highly recommend you to read the official documentation to catch the basics. Not right now, but definitely a must-read. In this post, we will discuss easy and cute transformation examples based on one small piece from my hobby-programming indie game. From time to time I do some primitive games in JS and Elm because it is fun and I can learn something new. Let’s begin! For such a small topic, I don’t think, it’s really necessary to talk about the game itself. Just know, that in the game there are such elements as planets. Planets flying in the space, surround the main character and compose the game world: Stone planet, Ice planet, Electro planet, Lava planet, Cloud planet and finally Water planet. Before this tropical style, I have been thinking about something more dark, dangerous and silent like the ocean of Lem’s Solaris (highly recommend reading this novel as well). But the concept was changed and finally, I end up with mini-Hawaii. Hard world of indie game dev. ¯\\_(ツ)_/¯ Without movements, Water planet just a boring, static image. The game should be as much fun as possible, so I definitely need to breathe life into game objects. Actually, breathing is a good idea for Water planet animation, is not it? Let’s do it! “Breathing” is quite an easy thing. All we need is to change the size of the object from the original value to something a bit bigger and get back to the original size. We should do this again and again in an infinite loop. The simplest implementation of “breathing” is:\n\n1) Transform size from 1 to 1.X in some period of time\n\n2) Transform size from 1.X back to 1 in the same period of time\n\n3) Loop these steps\n\nI hope example looks very easy to understand. But anyway, let me repeat how animation works. The top-level Animated.sequence build a composition of 2 animations and declares that they going to be executed sequentially (the second animation will be executed right after the first one). First Animated.timing manage a scaleValue from the state with a duration of 1.5 seconds in an Easing.linear manner changes the value from the initial 1 to 1.2 (toValue). Second Animated.timing animation change scaleValue from planned 1.2 back to 1. As a callback of the start method, we do a call of waterAnimation to start the animation again (this is how we do the loop). We can change the current implementation with the usage of interpolation. Interpolation gives us the ability to segregate animated value (scaleValue) and map it before component uses this value. Interpolation is a very simple but powerful concept. With interpolation, we can project real scaleValue to some another value we want to set for the component. For example, we can let scaleValue changes from 0 to 1 but set to component scale property values as we want: 1 and 1.2 instead. Catch the idea? Here is the full implementation.\n\nYou can also notice, that now first animation is playing the whole breathing (up and down in 3 seconds), while the second animation is just an immediate reset of scaleValue to original zero. Animation works, it is a good starting point, but… it looks a bit cheap and fake. Why fake? From the point of Physics, we have a problem! Let’s think for a moment, when the planet getting bigger, for example, trees on it or clouds in the sky, also become bigger? Of course, not :-) Let’s try to make animation more realistic. To be honest, we should scale only the planet’s globe and let islands and clouds drift on top of the surface. I am not sure, but I also think that clouds should move a bit less, than islands. They are not in the water, but in the atmosphere, so they less affected from the planet breathing. Maybe it’s too aggressive requirements for such a small game object, but we want to have some fun! Instead of one single image, I need seven now: 1 for planet globe, 3 for each island and 3 for each cloud. It is important to think in advance about every significant object’s element. If you plan to move, hide, swap, scale or whatever — you better to have separate images. It will allow you to disassemble objects on pieces and even try new animation ideas in the future. Each image is a separate layer. In my real game, I have even extra layers for islands: sand, water glow, and jungle — all separated. Who knows what I will need to do in the future? I have many images for my game objects and I can merge layers into one file picture any time I want. Once again: the globe is still scaling as before, but islands and clouds are only moving without scaling. Clouds move less than islands. We will change the position of islands and clouds via transform TranslateX and TranslateY configurations. We can reuse the first implementation with a mapping of animationValue (renamed from scaleValue) as a single animation value source for different outputs for each of our layers. Seven projections in each image to scale globe, moving islands and clouds. When I said “projection”, as you understand, I mean React Native interpolation."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Games/Anatomy",
        "document": "The goal of every video game is to present the user(s) with a situation, accept their input, interpret those signals into actions, and calculate a new situation resulting from those acts. Games are constantly looping through these stages, over and over, until some end condition occurs (such as winning, losing, or exiting to go to bed). Not surprisingly, this pattern corresponds to how a game engine is programmed. The specifics depend on the game. Some games drive this cycle by user input. Imagine that you are developing a \"find the differences between these two similar pictures\"-type game. These games present two images to the user; they accept their click (or touch); they interpret the input as a success, failure, pause, menu interaction, etc.; finally, they calculate an updated scene resulting from that input. The game loop is advanced by the user's input and sleeps until they provide it. This is more of a turn-based approach that doesn't demand a constant update every frame, only when the player reacts. Other games demand control over each of the smallest possible individual timeslices. The same principles as above apply with a slight twist: each frame of animation progresses the cycle and any change in user input is caught at the first available turn. This once-per-frame model is implemented in something called a main loop. If your game loops based on time then this will be its authority that your simulations will adhere to. But it might not need per-frame control. Your game loop might be similar to the find the differences example and base itself on input events. It might require both input and simulated time. It might even loop based on something else entirely. Modern JavaScript — as described in the next sections — thankfully makes it easy to develop an efficient, execute-once-per-frame main loop. Of course, your game will only be as optimized as you make it. If something looks like it should be attached to a more infrequent event then it is often a good idea to break it out of the main loop (but not always).\n\nJavaScript works best with events and callback functions. Modern browsers strive to call methods right as they are needed and idle (or do their other tasks) in the gaps. It is an excellent idea to attach your code to the moments that are appropriate for them. Think about whether your function really needs to be called on a strict interval of time, every frame, or only after something else happens. Being more specific with the browser about when your function needs to be called allows the browser to optimize when it is called. Also, it will probably make your job easier. Some code needs to be run frame-by-frame so why attach that function to anything other than the browser's redraw schedule? On the Web, will be the foundation of most well-programmed per-frame main loops. A callback function must be passed in to it when it is called. That callback function will be executed at a suitable time before the next repaint. Here is an example of a simple main loop: window.main = () => { window.requestAnimationFrame(main); // Whatever your main loop needs to do }; main(); // Start the cycle Note: In each of the methods discussed here, we schedule a new before performing our loop contents. That is not by accident and it is considered best practice. Calling the next early ensures the browser receives it on time to plan accordingly even if your current frame misses its VSync window. The above chunk of code has two statements. The first statement creates a function as a global variable called . This function does some work and also tells the browser to call itself next frame with . The second statement calls the function, defined in the first statement. Because is called once in the second statement and every call of it places itself in the queue of things to do next frame, is synchronized to your frame rate. Of course this loop is not perfect. Before we discuss ways to change it, let us discuss what it already does well. Timing the main loop to when the browser paints to the display allows you to run your loop as frequently as the browser wants to paint. You are given control over each frame of animation. It is also very simple because is the only function getting looped. A First-Person Shooter (or a similar game) presents a new scene once every frame. You cannot really get more smooth and responsive than that. But do not immediately assume animations require frame-by-frame control. Simple animations can be easily performed, even GPU-accelerated, with CSS animations and other tools included in the browser. There are a lot of them and they will make your life easier.\n\nThere are two obvious issues with our previous main loop: pollutes the object (where all global variables are stored) and the example code did not leave us with a way to stop the loop unless the whole tab is closed or refreshed. For the first issue, if you want the main loop to just run and you do not need easy (direct) access to it, you could create it as an Immediately-Invoked Function Expression (IIFE). /* * Starting with the semicolon is in case whatever line of code above this example * relied on automatic semicolon insertion (ASI). The browser could accidentally * think this whole example continues from the previous line. The leading semicolon * marks the beginning of our new line if the previous one was not empty or terminated. */ ;(() => { function main() { window.requestAnimationFrame(main); // Your main loop contents } main(); // Start the cycle })(); When the browser comes across this IIFE, it will define your main loop and immediately queue it for the next frame. It will not be attached to any object and (or for methods) will be a valid unused name in the rest of the application, free to be defined as something else. Note: In practice, it is more common to prevent the next with an if-statement, rather than calling . For the second issue, stopping the main loop, you will need to cancel the call to with . You will need to pass the ID token given by when it was last called. Let us assume that your game's functions and variables are built on a namespace that you called . Expanding our last example, the main loop would now look like: /* * Starting with the semicolon is in case whatever line of code above this example * relied on automatic semicolon insertion (ASI). The browser could accidentally * think this whole example continues from the previous line. The leading semicolon * marks the beginning of our new line if the previous one was not empty or terminated. * * Let us also assume that MyGame is previously defined. */ ;(() => { function main() { MyGame.stopMain = window.requestAnimationFrame(main); // Your main loop contents } main(); // Start the cycle })(); We now have a variable declared in our namespace, which we call , that contains the ID returned from our main loop's most recent call to . At any point, we can stop the main loop by telling the browser to cancel the request that corresponds to our token. The key to programming a main loop, in JavaScript, is to attach it to whatever event should be driving your action and pay attention to how the different systems involved interplay. You may have multiple components driven by multiple different types of events. This feels like unnecessary complexity but it might just be good optimization (not necessarily, of course). The problem is that you are not programming a typical main loop. In JavaScript, you are using the browser's main loop and you are trying to do so effectively.\n\nUltimately, in JavaScript, the browser is running its own main loop and your code exists in some of its stages. The above sections describe main loops which try not to wrestle away control from the browser. These main methods attach themselves to , which asks the browser for control over the upcoming frame. It is up to the browser how to relate these requests to their main loop. The W3C spec for requestAnimationFrame does not really define exactly when the browsers must perform the requestAnimationFrame callbacks. This can be a benefit because it leaves browser vendors free to experiment with the solutions that they feel are best and tweak it over time. Modern versions of Firefox and Google Chrome (and probably others) attempt to connect callbacks to their main thread at the very beginning of a frame's timeslice. The browser's main thread thus tries to look like the following:\n• Start a new frame (while the previous frame is handled by the display).\n• Go through the list of callbacks and invoke them.\n• Perform garbage collection and other per-frame tasks when the above callbacks stop controlling the main thread.\n• Sleep (unless an event interrupts the browser's nap) until the monitor is ready for your image (VSync) and repeat. You can think about developing realtime applications as having a budget of time to do work. All of the above steps must take place every 16-and-a-half milliseconds to keep up with a 60 Hz display. Browsers invoke your code as early as possible to give it maximum computation time. Your main thread will often start workloads that are not even on the main thread (such as rasterization or shaders in WebGL). Long calculations can be performed on a Web Worker or a GPU at the same time as the browser uses its main thread to manage garbage collection, its other tasks, or handle asynchronous events. While we are on the topic of budgeting time, many web browsers have a tool called High Resolution Time. The object is no longer the recognized method for timing events because it is very imprecise and can be modified by the system clock. High Resolution Time, on the other hand, counts the number of milliseconds since (when the previous document is unloaded). This value is returned as a decimal number accurate to a thousandth of a millisecond. It is known as a but, for all intents and purposes, consider it a floating point number. Note: Systems (hardware or software) that are not capable of microsecond accuracy are allowed to provide millisecond accuracy as a minimum. They should provide 0.001ms accuracy if they are capable of it, however. This value is not too useful alone, since it is relative to a fairly uninteresting event, but it can be subtracted from another timestamp to accurately and precisely determine how much time elapsed between those two points. To acquire one of these timestamps, you can call and store the result as a variable. Back to the topic of the main loop. You will often want to know when your main function was invoked. Because this is common, always provides a to callbacks as an argument when they are executed. This leads to another enhancement to our previous main loops. /* * Starting with the semicolon is in case whatever line of code above this example * relied on automatic semicolon insertion (ASI). The browser could accidentally * think this whole example continues from the previous line. The leading semicolon * marks the beginning of our new line if the previous one was not empty or terminated. * * Let us also assume that MyGame is previously defined. */ ;(() => { function main(tFrame) { MyGame.stopMain = window.requestAnimationFrame(main); // Your main loop contents // tFrame, from \"function main(tFrame)\", is now a DOMHighResTimeStamp provided by rAF. } main(); // Start the cycle })(); Several other optimizations are possible and it really depends on what your game attempts to accomplish. Your game genre will obviously make a difference but it could even be more subtle than that. You could draw every pixel individually on a canvas or you could layer DOM elements (including multiple WebGL canvases with transparent backgrounds if you want) into a complex hierarchy. Each of these paths will lead to different opportunities and constraints.\n\nOther ways to handle variable refresh rate needs Other methods of tackling the problem exist. One common technique is to update the simulation at a constant frequency and then draw as much (or as little) of the actual frames as possible. The update method can continue looping without care about what the user sees. The draw method can view the last update and when it happened. Since draw knows when it represents, and the simulation time for the last update, it can predict a plausible frame to draw for the user. It does not matter whether this is more frequent than the official update loop (or even less frequent). The update method sets checkpoints and, as frequently as the system allows, the render method draws instants of time around them. There are many ways to separate the update method in web standards:\n• Draw on and update on a or .\n• This uses processor time even when unfocused or minimized, hogs the main thread, and is probably an artifact of traditional game loops (but it is simple.)\n• Draw on and update on a or in a Web Worker.\n• This is the same as above, except update does not hog the main thread (nor does the main thread hog it). This is a more complex solution, and might be too much overhead for simple updates.\n• Draw on and use it to poke a Web Worker containing the update method with the number of ticks to compute, if any.\n• This sleeps until is called and does not pollute the main thread, plus you are not relying on old-fashioned methods. Again, this is a bit more complex than the previous two options, and starting each update will be blocked until the browser decides to fire rAF callbacks. Each of these methods have similar tradeoffs:\n• Users can skip rendering frames or interpolate extra ones depending on their performance.\n• You can count on all users updating non-cosmetic variables at the same constant frequency minus hiccups.\n• Much more complicated to program than the basic loops we saw earlier.\n• User input is completely ignored until the next update (even if the user has a fast device). A separate update and draw method could look like the following example. For the sake of demonstration, the example is based on the third bullet point, just without using Web Workers for readability (and, let's be honest, writability). Warning: This example, specifically, is in need of technical review. /* * Starting with the semicolon is in case whatever line of code above this example * relied on automatic semicolon insertion (ASI). The browser could accidentally * think this whole example continues from the previous line. The leading semicolon * marks the beginning of our new line if the previous one was not empty or terminated. * * Let us also assume that MyGame is previously defined. * * MyGame.lastRender keeps track of the last provided requestAnimationFrame timestamp. * MyGame.lastTick keeps track of the last update time. Always increments by tickLength. * MyGame.tickLength is how frequently the game state updates. It is 20 Hz (50ms) here. * * timeSinceTick is the time between requestAnimationFrame callback and last update. * numTicks is how many updates should have happened between these two rendered frames. * * render() is passed tFrame because it is assumed that the render method will calculate * how long it has been since the most recently passed update tick for * extrapolation (purely cosmetic for fast devices). It draws the scene. * * update() calculates the game state as of a given point in time. It should always * increment by tickLength. It is the authority for game state. It is passed * the DOMHighResTimeStamp for the time it represents (which, again, is always * last update + MyGame.tickLength unless a pause feature is added, etc.) * * setInitialState() Performs whatever tasks are leftover before the main loop must run. * It is just a generic example function that you might have added. */ ;(() => { function main(tFrame) { MyGame.stopMain = window.requestAnimationFrame(main); const nextTick = MyGame.lastTick + MyGame.tickLength; let numTicks = 0; // If tFrame < nextTick then 0 ticks need to be updated (0 is default for numTicks). // If tFrame = nextTick then 1 tick needs to be updated (and so forth). // Note: As we mention in summary, you should keep track of how large numTicks is. // If it is large, then either your game was asleep, or the machine cannot keep up. if (tFrame > nextTick) { const timeSinceTick = tFrame - MyGame.lastTick; numTicks = Math.floor(timeSinceTick / MyGame.tickLength); } queueUpdates(numTicks); render(tFrame); MyGame.lastRender = tFrame; } function queueUpdates(numTicks) { for (let i = 0; i < numTicks; i++) { MyGame.lastTick += MyGame.tickLength; // Now lastTick is this tick. update(MyGame.lastTick); } } MyGame.lastTick = performance.now(); MyGame.lastRender = MyGame.lastTick; // Pretend the first draw was on first update. MyGame.tickLength = 50; // This sets your simulation to run at 20Hz (50ms) setInitialState(); main(performance.now()); // Start the cycle })(); Another alternative is to do certain things less often. If a portion of your update loop is difficult to compute but insensitive to time, you might consider scaling back its frequency and, ideally, spreading it out into chunks throughout that lengthened period. An implicit example of this was found over at The Artillery Blog for Artillery Games, where they adjust their rate of garbage generation to optimize garbage collection. Obviously, cleaning up resources is not time sensitive (especially if tidying is more disruptive than the garbage itself). This may also apply to some of your own tasks. Those are good candidates to throttle when available resources become a concern."
    },
    {
        "link": "https://xaeyr.typepad.com/files/physics-for-javascript-games-animation-and-simulations.pdf",
        "document": ""
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Basic_animations",
        "document": "Since we're using JavaScript to control elements, it's also very easy to make (interactive) animations. In this chapter we will take a look at how to do some basic animations. Probably the biggest limitation is, that once a shape gets drawn, it stays that way. If we need to move it we have to redraw it and everything that was drawn before it. It takes a lot of time to redraw complex frames and the performance depends highly on the speed of the computer it's running on.\n\nShapes are drawn to the canvas by using the canvas methods directly or by calling custom functions. In normal circumstances, we only see these results appear on the canvas when the script finishes executing. For instance, it isn't possible to do an animation from within a loop. That means we need a way to execute our drawing functions over a period of time. There are two ways to control an animation like this.\n\nFirst there's the , , and functions, which can be used to call a specific function over a set period of time. Starts repeatedly executing the function specified by every milliseconds. Executes the function specified by in milliseconds. Tells the browser that you wish to perform an animation and requests that the browser call a specified function to update an animation before the next repaint. If you don't want any user interaction you can use the function, which repeatedly executes the supplied code. If we wanted to make a game, we could use keyboard or mouse events to control the animation and use . By setting listeners using , we catch any user interaction and execute our animation functions. Note: In the examples below, we'll use the method to control the animation. The method provides a smoother and more efficient way for animating by calling the animation frame when the system is ready to paint the frame. The number of callbacks is usually 60 times per second and may be reduced to a lower rate when running in background tabs. For more information about the animation loop, especially for games, see the article Anatomy of a video game in our Game development zone."
    },
    {
        "link": "https://shopify.github.io/draggable",
        "document": "Let’s face it, it’s annoying when plugins get in the way of your personal design touch. Draggable isn’t going to try and steal the show by forcing any unruly animation styles on you. Simply take your pick from our healthy serving of CSS selectors and style to your heart’s desire."
    },
    {
        "link": "https://geeksforgeeks.org/draggable-element-using-javascript",
        "document": "Creating a draggable element and moving it to another place within the page is a very interactive and user-friendly concept that makes it easier for the user. This feature allows the user to click and hold the mouse button over a div, drag it to another location, and release the mouse button to drop the element.\n\nLet us have a look at what the final feature will look like:\n\nWe will make this draggable feature to drag any element. Here is the step-by-step approach to creating a draggable element.\n• HTML Section: The HTML section of the page will be inside the index.html file, and we are only creating a div for this project. You can take any element to make it draggable.\n• CSS Section: This section will contain all the code related to the styling of the page or the div that we have taken for this project. The code of this file is given below.\n\nExample: Write the below code in the respective files.\n\nIn this example\n• None The script selects all elements with the class .draggable using document.querySelectorAll(“.draggable”).\n• None When you click on any .draggable element (mousedown event), the script begins tracking the mouse movement.\n• None As you drag, the mousemove event updates the position of the dragged element by adjusting its left and top styles.\n• None When you release the mouse button (mouseup event), the script stops moving the element by removing the mousemove event listener.\n• None Each .draggable element is independently draggable, so clicking and dragging one element won’t affect others."
    },
    {
        "link": "https://stackoverflow.com/questions/13152578/create-a-draggable-div-in-native-javascript",
        "document": "OK, here's my personal code that I use for lightweight deployments (projects where using a library is either not allowed or overkill for some reason). First thing first, I always use this convenience function so that I can pass either an id or the actual dom element:\n\nAs a bonus, is shorter to type than and my code ends up shorter.\n\nSecond realize that what most libraries are doing is cross-browser compatibility. If all browsers behave the same the code is fairly trivial. So lets write some cross-browser functions to get mouse position:\n\nOK, the two functions above are identical. There're certainly better ways to write them but I'm keeping it (relatively) simple for now.\n\nNow we can write the drag and drop code. The thing I like about this code is that everything's captured in a single closure so there are no global variables or helper functions littering the browser. Also, the code separates the drag handle from the object being dragged. This is useful for creating dialog boxes etc. But if not needed, you can always assign them the same object. Anyway, here's the code:\n\nThere is a reason for the slightly convoluted calculations. If you notice, it's just taking the difference between mouse positions and adding them back to the position of the div being dragged. Why not just use the mouse positions? Well, if you do that the div will jump to the mouse pointer when you click on it. Which is a behavior I did not want."
    },
    {
        "link": "https://reddit.com/r/webdev/comments/9d5xze/using_draggablejs",
        "document": "I am new to Javascript, and new to using javascript libraries. Although this example is exactly what I need for my webapp project.\n\nAlthough the documentation found here seems to be pretty complete I cannot figure out how to get the example to work...\n\nWhen I go to the example page I dont understand what the HTML code does. It uses these {% import 'components/Block/Block.html' as Block %} argumnents. When I run the index.html file it just shows some gibberish in the browser.\n\nI might be missing a crucial part in installing the library, I've used some js libraries with succes but this one I cant get to work.\n\nThanks for reading, I hope there is someone who can help me get the example running :)\n\nedit: So, I played around with the answers given, since I am very new to js, the js hasn't changed much.\n\nfor anyone interested in the result: here's my pen :)"
    },
    {
        "link": "https://srivastavayushmaan1347.medium.com/blog-title-creating-a-draggable-div-element-with-javascript-88f3be51bbf9",
        "document": "In this blog, we will learn how to create a simple drag-and-drop feature using JavaScript. We will implement functionality that allows users to drag a element around the screen using their mouse. This can be particularly useful in web applications for interactive features such as dashboards, games, and design tools.\n\nLet’s start with the basic HTML structure. We will create a element that users can drag around.\n\nNow, let’s add the JavaScript code that will enable the drag-and-drop functionality.\n• HTML Structure: We created a simple with an ID of , styled to look visually appealing.\n• The event captures the initial click on the , calculates the offset from the mouse position to the top-left corner of the , and sets up event listeners for and .\n• The event updates the position of the as the mouse moves, allowing it to follow the cursor.\n• The event removes the event listeners once the mouse button is released, stopping the dragging action.\n• Move your mouse to see the follow the cursor.\n• Release the mouse button to drop the .\n\nIn this blog, we’ve successfully implemented a draggable element using plain JavaScript. This simple feature can be expanded upon for more complex applications such as creating draggable lists, building custom UI elements, or even implementing interactive games.\n\nFeel free to explore and enhance this code further. You could add boundaries for dragging, enable touch events for mobile devices, or even save the position of the for persistence."
    }
]