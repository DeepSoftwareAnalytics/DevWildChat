[
    {
        "link": "https://trac.ffmpeg.org/wiki/Encode/H.264",
        "document": "This guide focuses on the encoder x264. It assumes you have compiled with . If you need help compiling and installing see one of our compiling guides. See HWAccelIntro for information on supported hardware H.264 encoders.\n\nThere are two rate control modes that are usually suggested for general use: Constant Rate Factor (CRF) or Two-Pass ABR. Rate control decides how many bits will be used for each frame. This will determine the file size and also how quality is distributed. To know more about what the different rate control modes do see ​this post.\n\nUse this rate control mode if you want to keep the best quality and care less about the file size. This is the recommended rate control mode for most uses.\n\nThis method allows the encoder to attempt to achieve a certain output quality for the whole file when output file size is of less importance. This provides maximum compression efficiency with a single pass. By adjusting the so-called quantizer for each frame, it gets the bitrate it needs to keep the requested quality level. The downside is that you can't tell it to get a specific filesize or not go over a specific size or bitrate, which means that this method is not recommended for encoding videos for streaming.\n\nThe range of the CRF scale is 0–51, where 0 is lossless (for 8 bit only, for 10 bit use -qp 0), 23 is the default, and 51 is worst quality possible. A lower value generally leads to higher quality, and a subjectively sane range is 17–28. Consider 17 or 18 to be visually lossless or nearly so; it should look the same or nearly the same as the input but it isn't technically lossless.\n\nThe range is exponential, so increasing the CRF value +6 results in roughly half the bitrate / file size, while -6 leads to roughly twice the bitrate.\n\nChoose the highest CRF value that still provides an acceptable quality. If the output looks good, then try a higher value. If it looks bad, choose a lower value.\n\nA preset is a collection of options that will provide a certain encoding speed to compression ratio. A slower preset will provide better compression (compression is quality per filesize). This means that, for example, if you target a certain file size or constant bit rate, you will achieve better quality with a slower preset. Similarly, for constant quality encoding, you will simply save bitrate by choosing a slower preset.\n\nUse the slowest preset that you have patience for. The available presets in descending order of speed are:\n• – ignore this as it is not useful (see FAQ)\n\nYou can see a list of current presets with (see example below). If you have the binary installed, you can also see the exact settings these presets apply by running .\n\nYou can optionally use to change settings based upon the specifics of your input. Current tunings include:\n• – good for cartoons; uses higher deblocking and more reference frames\n• – preserves the grain structure in old, grainy film material\n• – allows faster decoding by disabling certain filters\n• – ignore this as it is only used for codec development\n• – ignore this as it is only used for codec development\n\nFor example, if your input is animation then use the tuning, or if you want to preserve grain in a film then use the tuning. If you are unsure of what to use or your input does not match any of tunings then omit the option. You can see a list of current tunings with , and what settings they apply with .\n\nThe option limits the output to a specific H.264 profile. You usually do not need to use this option and the recommendation is to omit setting the profile which will allow x264 to automatically select the appropriate profile.\n\nSome devices (mostly very old or obsolete) only support the more limited Constrained Baseline or Main profiles. You can set these profiles with or . Most modern devices support the more advanced High profile.\n\nAnother reason to use this option is to match other video profiles if you want to concatenate them with the concat demuxer.\n\nNote that usage of is incompatible with lossless encoding and setting -profile:v high444 does not work.\n\nTo list all possible internal presets and tunes:\n\nThis command encodes a video with good quality, using slower preset to achieve better compression:\n\nNote that in this example the audio stream of the input file is simply stream copied over to the output and not re-encoded.\n\nIf you are encoding a set of videos that are similar, apply the same settings to all the videos: this will ensure that they will all have similar quality.\n\nUse this rate control mode if you are targeting a specific output file size, and if output quality from frame to frame is of less importance. This is best explained with an example. Your video is 10 minutes (600 seconds) long and an output of 200 MiB is desired. Since :\n\nYou can also forgo the bitrate calculation if you already know what final (average) bitrate you need.\n\nFor two-pass, you need to run twice, with almost the same settings, except for:\n• In pass 1 and 2, use the and options, respectively.\n• In pass 1, output to a null file descriptor, not an actual file. (This will generate a logfile that ffmpeg needs for the second pass.)\n• In pass 1, you may leave audio out by specifying .\n\nAs with CRF, choose the slowest you can tolerate, and optionally apply a setting and .\n\nIf the profile is High 4:4:4 Predictive you can use to create a lossless video, otherwise use -qp 0 (High 10 profile does not support lossless, ​https://code.videolan.org/videolan/x264/-/blob/master/x264.c#L579). Two useful presets for this are or since either a fast encoding speed or best compression are usually the most important factors.\n\nNote that lossless output files will likely be huge, and most non-FFmpeg based players will not be able to decode lossless. Therefore, if compatibility or file size are an issue, you should not use lossless.\n\nWhile chooses the best possible settings for you, you can overwrite these with the option, or by using the libx264 private options (see ). This is not recommended unless you know what you are doing. The presets were created by the x264 developers and tweaking values to get a better output is usually a waste of time.\n\nThere is no native or true CBR mode, but you can \"simulate\" a constant bit rate setting by tuning the parameters of a one-pass average bitrate encode:\n\nIn the above example, is the \"rate control buffer\", so it will enforce your requested \"average\" (1 MBit/s in this case) across each 2 MBit worth of video. Here it is assumed that the receiver / player will buffer that much data, meaning that a fluctuation within that range is acceptable.\n\nCBR encodes are usually inefficient if the video is easy to encode (e.g., empty or black frames).\n\nUse this mode if you want to constrain the maximum bitrate used, or keep the stream's bitrate within certain bounds. This is particularly useful for online streaming, where the client expects a certain average bitrate, but you still want the encoder to adjust the bitrate per-frame.\n\nYou can use or with a maximum bit rate by specifying both and :\n\nThis will effectively \"target\" , but if the output were to exceed 1 MBit/s, the encoder would increase the CRF to prevent bitrate spikes. However, be aware that does not strictly control the maximum bit rate as you specified (the maximum bit rate may be well over 1M for the above file). To reach a perfect maximum bit rate, use two-pass.\n\nIn another example, instead of using constant quality (CRF) as a target, the average bitrate is set. A two-pass approach is preferred here:\n\nEncode a random section instead of the whole video with the and / options to quickly get a general idea of what the output will look like.\n• : Offset time from beginning. Value can be in seconds or HH:MM:SS format.\n• : Duration. Value can be in seconds or HH:MM:SS format.\n• : Stop writing the output at specified position. Value can be in seconds or HH:MM:SS format.\n\nYou can add as an output option if your videos are going to be viewed in a browser. This will move some information to the beginning of your file and allow the video to begin playing before it is completely downloaded by the viewer. It is not required if you are going to use a video service such as YouTube. YouTube ​recommends using faststart, so they can begin re-encoding before uploads complete.\n\nSee also How to check if Fast Start is enabled for playback\n\nRefer to the output option in the documentation.\n\nTo enable OpenCL lookahead add or to your command line. It will give a slight encoding speed boost using GPU, without hurting quality.\n\nYou will see or , also file will be created, which can deleted safely after encoding.\n\nIf you have access to the Nvidia NvEnc hardware (ffmpeg -encoders shows h264_nvenc) then you can use ffmpeg -h encoder=h264_nvenc to see the specific options it provides.\n\nWill two-pass provide a better quality than CRF?\n\n​No, though it does allow you to target a file size more accurately.\n\nWhy is a waste of time?\n\nIt helps at most ~1% in terms of quality, compared to the preset at the cost of a much higher encoding time. It's diminishing returns: helps about 3% compared to the preset, helps about 5% compared to the preset, and helps about 5-10% compared to the preset.\n\nHow do the different presets influence encoding time?\n\nThis depends on the source material, the target bitrate, and your hardware configuration. In general, the higher the bitrate, the more time needed for encoding.\n\nHere is an example that shows the (normalized) encoding time for a two-pass encode of a 1080p video:\n\nGoing from to , the time needed increases by about 40%. Going to instead would result in about 100% more time needed (i.e. it will take twice as long). Compared to , requires 280% of the original encoding time, with only minimal improvements over in terms of quality.\n\nUsing saves about 10% encoding time, 25%. will save 55% at the expense of much lower quality.\n\nWhy doesn't my lossless output look lossless?\n\nIf your input files are RGB, it's the RGB to YUV color space conversion. Use instead.\n\nSee HWAccelIntro for information on supported hardware H.264 encoders and decoders.\n\nYou may need to use (or the alias ) for your output to work in QuickTime and most other players. These players only support the YUV planar color space with 4:2:0 chroma subsampling for H.264 video. Otherwise, depending on your source, may output to a pixel format that may be incompatible with these players."
    },
    {
        "link": "https://ffmpeg.org/ffmpeg.html",
        "document": "is a universal media converter. It can read a wide variety of inputs - including live grabbing/recording devices - filter, and transcode them into a plethora of output formats.\n\nreads from an arbitrary number of inputs (which can be regular files, pipes, network streams, grabbing devices, etc.), specified by the option, and writes to an arbitrary number of outputs, which are specified by a plain output url. Anything found on the command line which cannot be interpreted as an option is considered to be an output url.\n\nEach input or output can, in principle, contain any number of elementary streams of different types (video/audio/subtitle/attachment/data), though the allowed stream counts and/or types may be limited by the container format. Selecting which streams from which inputs will go into which output is either done automatically or with the option (see the Stream selection chapter).\n\nTo refer to inputs/outputs in options, you must use their indices (0-based). E.g. the first input is , the second is , etc. Similarly, streams within an input/output are referred to by their indices. E.g. refers to the fourth stream in the third input or output. Also see the Stream specifiers chapter.\n\nAs a general rule, options are applied to the next specified file. Therefore, order is important, and you can have the same option on the command line multiple times. Each occurrence is then applied to the next input or output file. Exceptions from this rule are the global options (e.g. verbosity level), which should be specified first.\n\nDo not mix input and output files – first specify all input files, then all output files. Also do not mix options which belong to different files. All options apply ONLY to the next input or output file and are reset between files.\n• Convert an input media file to a different format, by re-encoding media streams:\n• Set the video bitrate of the output file to 64 kbit/s:\n• Force the frame rate of the output file to 24 fps:\n• Force the frame rate of the input file (valid for raw formats only) to 1 fps and the frame rate of the output file to 24 fps:\n\nThe format option may be needed for raw input files.\n\nbuilds a transcoding pipeline out of the components listed below. The program’s operation then consists of input data chunks flowing from the sources down the pipes towards the sinks, while being transformed by the components they encounter along the way.\n\nThe following kinds of components are available:\n• Demuxers (short for \"demultiplexers\") read an input source in order to extract\n• global properties such as metadata or chapters;\n• list of input elementary streams and their properties One demuxer instance is created for each option, and sends encoded packets to decoders or muxers. In other literature, demuxers are sometimes called splitters, because their main function is splitting a file into elementary streams (though some files only contain one elementary stream). A schematic representation of a demuxer looks like this: ┌──────────┬───────────────────────┐ │ demuxer │ │ packets for stream 0 ╞══════════╡ elementary stream 0 ├──────────────────────► │ │ │ │ global ├───────────────────────┤ │properties│ │ packets for stream 1 │ and │ elementary stream 1 ├──────────────────────► │ metadata │ │ │ ├───────────────────────┤ │ │ │ │ │ ........... │ │ │ │ │ ├───────────────────────┤ │ │ │ packets for stream N │ │ elementary stream N ├──────────────────────► │ │ │ └──────────┴───────────────────────┘ ▲ │ │ read from file, network stream, │ grabbing device, etc. │\n• Decoders receive encoded (compressed) packets for an audio, video, or subtitle elementary stream, and decode them into raw frames (arrays of pixels for video, PCM for audio). A decoder is typically associated with (and receives its input from) an elementary stream in a demuxer, but sometimes may also exist on its own (see Loopback decoders). A schematic representation of a decoder looks like this:\n• Filtergraphs process and transform raw audio or video frames. A filtergraph consists of one or more individual filters linked into a graph. Filtergraphs come in two flavors - simple and complex, configured with the and options, respectively. A simple filtergraph is associated with an output elementary stream; it receives the input to be filtered from a decoder and sends filtered output to that output stream’s encoder. A simple video filtergraph that performs deinterlacing (using the deinterlacer) followed by resizing (using the filter) can look like this: ┌────────────────────────┐ │ simple filtergraph │ frames from ╞════════════════════════╡ frames for a decoder │ ┌───────┐ ┌───────┐ │ an encoder ────────────►├─►│ yadif ├─►│ scale ├─►│────────────► │ └───────┘ └───────┘ │ └────────────────────────┘ A complex filtergraph is standalone and not associated with any specific stream. It may have multiple (or zero) inputs, potentially of different types (audio or video), each of which receiving data either from a decoder or another complex filtergraph’s output. It also has one or more outputs that feed either an encoder or another complex filtergraph’s input. The following example diagram represents a complex filtergraph with 3 inputs and 2 outputs (all video): Frames from second input are overlaid over those from the first. Frames from the third input are rescaled, then the duplicated into two identical streams. One of them is overlaid over the combined first two inputs, with the result exposed as the filtergraph’s first output. The other duplicate ends up being the filtergraph’s second output.\n• Encoders receive raw audio, video, or subtitle frames and encode them into encoded packets. The encoding (compression) process is typically lossy - it degrades stream quality to make the output smaller; some encoders are lossless, but at the cost of much higher output size. A video or audio encoder receives its input from some filtergraph’s output, subtitle encoders receive input from a decoder (since subtitle filtering is not supported yet). Every encoder is associated with some muxer’s output elementary stream and sends its output to that muxer. A schematic representation of an encoder looks like this:\n• Muxers (short for \"multiplexers\") receive encoded packets for their elementary streams from encoders (the transcoding path) or directly from demuxers (the streamcopy path), interleave them (when there is more than one elementary stream), and write the resulting bytes into the output file (or pipe, network stream, etc.). A schematic representation of a muxer looks like this: ┌──────────────────────┬───────────┐ packets for stream 0 │ │ muxer │ ──────────────────────►│ elementary stream 0 ╞═══════════╡ │ │ │ ├──────────────────────┤ global │ packets for stream 1 │ │properties │ ──────────────────────►│ elementary stream 1 │ and │ │ │ metadata │ ├──────────────────────┤ │ │ │ │ │ ........... │ │ │ │ │ ├──────────────────────┤ │ packets for stream N │ │ │ ──────────────────────►│ elementary stream N │ │ │ │ │ └──────────────────────┴─────┬─────┘ │ write to file, network stream, │ grabbing device, etc. │ │ ▼\n\nThe simplest pipeline in is single-stream streamcopy, that is copying one input elementary stream’s packets without decoding, filtering, or encoding them. As an example, consider an input file called with 3 elementary streams, from which we take the second and write it to file . A schematic representation of such a pipeline looks like this:\n\nThe above pipeline can be constructed with the following commandline:\n• there are no input options for this input;\n• there are two output options for this output:\n• selects the input stream to be used - from input with index 0 (i.e. the first one) the stream with index 1 (i.e. the second one);\n• selects the encoder, i.e. streamcopy with no decoding or encoding.\n\nStreamcopy is useful for changing the elementary stream count, container format, or modifying container-level metadata. Since there is no decoding or encoding, it is very fast and there is no quality loss. However, it might not work in some cases because of a variety of factors (e.g. certain information required by the target container is not available in the source). Applying filters is obviously also impossible, since filters work on decoded frames.\n\nMore complex streamcopy scenarios can be constructed - e.g. combining streams from two input files into a single output:\n\nthat can be built by the commandline\n\nThe output option is used twice here, creating two streams in the output file - one fed by the first input and one by the second. The single instance of the option selects streamcopy for both of those streams. You could also use multiple instances of this option together with Stream specifiers to apply different values to each stream, as will be demonstrated in following sections.\n\nA converse scenario is splitting multiple streams from a single input into multiple outputs:\n\nNote how a separate instance of the option is needed for every output file even though their values are the same. This is because non-global options (which is most of them) only apply in the context of the file before which they are placed.\n\nThese examples can of course be further generalized into arbitrary remappings of any number of inputs into any number of outputs.\n\nTranscoding is the process of decoding a stream and then encoding it again. Since encoding tends to be computationally expensive and in most cases degrades the stream quality (i.e. it is lossy), you should only transcode when you need to and perform streamcopy otherwise. Typical reasons to transcode are:\n• you want to feed the stream to something that cannot decode the original codec.\n\nNote that will transcode all audio, video, and subtitle streams unless you specify for them.\n\nConsider an example pipeline that reads an input file with one audio and one video stream, transcodes the video and copies the audio into a single output file. This can be schematically represented as follows\n\nand implemented with the following commandline:\n\nNote how it uses stream specifiers and to select input streams and apply different values of the option to them; see the Stream specifiers section for more details.\n\nWhen transcoding, audio and video streams can be filtered before encoding, with either a simple or complex filtergraph.\n\nSimple filtergraphs are those that have exactly one input and output, both of the same type (audio or video). They are configured with the per-stream option (with and aliases for (video) and (audio) respectively). Note that simple filtergraphs are tied to their output stream, so e.g. if you have multiple audio streams, will create a separate filtergraph for each one.\n\nTaking the trancoding example from above, adding filtering (and omitting audio, for clarity) makes it look like this:\n\nComplex filtergraphs are those which cannot be described as simply a linear processing chain applied to one stream. This is the case, for example, when the graph has more than one input and/or output, or when output stream type is different from input. Complex filtergraphs are configured with the option. Note that this option is global, since a complex filtergraph, by its nature, cannot be unambiguously associated with a single stream or file. Each instance of creates a new complex filtergraph, and there can be any number of them.\n\nA trivial example of a complex filtergraph is the filter, which has two video inputs and one video output, containing one video overlaid on top of the other. Its audio counterpart is the filter.\n\nWhile decoders are normally associated with demuxer streams, it is also possible to create \"loopback\" decoders that decode the output from some encoder and allow it to be fed back to complex filtergraphs. This is done with the directive, which takes as a parameter the index of the output stream that should be decoded. Every such directive creates a new loopback decoder, indexed with successive integers starting at zero. These indices should then be used to refer to loopback decoders in complex filtergraph link labels, as described in the documentation for .\n\nDecoding AVOptions can be passed to loopback decoders by placing them before , analogously to input/output options.\n\nE.g. the following example:\n• (line 2) encodes it with at low quality;\n• (line 4) places decoded video side by side with the original input video;\n• (line 5) combined video is then losslessly encoded and written into .\n\nSuch a transcoding pipeline can be represented with the following diagram:\n\nprovides the option for manual control of stream selection in each output file. Users can skip and let ffmpeg perform automatic stream selection as described below. The options can be used to skip inclusion of video, audio, subtitle and data streams respectively, whether manually mapped or automatically selected, except for those streams which are outputs of complex filtergraphs.\n\nThe sub-sections that follow describe the various rules that are involved in stream selection. The examples that follow next show how these rules are applied in practice.\n\nWhile every effort is made to accurately reflect the behavior of the program, FFmpeg is under continuous development and the code may have changed since the time of this writing.\n\nIn the absence of any map options for a particular output file, ffmpeg inspects the output format to check which type of streams can be included in it, viz. video, audio and/or subtitles. For each acceptable stream type, ffmpeg will pick one stream, when available, from among all the inputs.\n\nIt will select that stream based upon the following criteria:\n• for video, it is the stream with the highest resolution,\n• for audio, it is the stream with the most channels,\n• for subtitles, it is the first subtitle stream found but there’s a caveat. The output format’s default subtitle encoder can be either text-based or image-based, and only a subtitle stream of the same type will be chosen.\n\nIn the case where several streams of the same type rate equally, the stream with the lowest index is chosen.\n\nData or attachment streams are not automatically selected and can only be included using .\n\nWhen is used, only user-mapped streams are included in that output file, with one possible exception for filtergraph outputs described below.\n\nIf there are any complex filtergraph output streams with unlabeled pads, they will be added to the first output file. This will lead to a fatal error if the stream type is not supported by the output format. In the absence of the map option, the inclusion of these streams leads to the automatic stream selection of their types being skipped. If map options are present, these filtergraph streams are included in addition to the mapped streams.\n\nComplex filtergraph output streams with labeled pads must be mapped once and exactly once.\n\nStream handling is independent of stream selection, with an exception for subtitles described below. Stream handling is set via the option addressed to streams within a specific output file. In particular, codec options are applied by ffmpeg after the stream selection process and thus do not influence the latter. If no option is specified for a stream type, ffmpeg will select the default encoder registered by the output file muxer.\n\nAn exception exists for subtitles. If a subtitle encoder is specified for an output file, the first subtitle stream found of any type, text or image, will be included. ffmpeg does not validate if the specified encoder can convert the selected stream or if the converted stream is acceptable within the output format. This applies generally as well: when the user sets an encoder manually, the stream selection process cannot check if the encoded stream can be muxed into the output file. If it cannot, ffmpeg will abort and all output files will fail to be processed.\n\nThe following examples illustrate the behavior, quirks and limitations of ffmpeg’s stream selection methods.\n\nThey assume the following three input files.\n\nThere are three output files specified, and for the first two, no options are set, so ffmpeg will select streams for these two files automatically.\n\nis a Matroska container file and accepts video, audio and subtitle streams, so ffmpeg will try to select one of each type.\n\n For video, it will select from , which has the highest resolution among all the input video streams.\n\n For audio, it will select from , since it has the greatest number of channels.\n\n For subtitles, it will select from , which is the first subtitle stream from among and .\n\naccepts only audio streams, so only from is selected.\n\nFor , since a option is set, no automatic stream selection will occur. The option will select all audio streams from the second input . No other streams will be included in this output file.\n\nFor the first two outputs, all included streams will be transcoded. The encoders chosen will be the default ones registered by each output format, which may not match the codec of the selected input streams.\n\nFor the third output, codec option for audio streams has been set to , so no decoding-filtering-encoding operations will occur, or can occur. Packets of selected streams shall be conveyed from the input file and muxed within the output file.\n\nAlthough is a Matroska container file which accepts subtitle streams, only a video and audio stream shall be selected. The subtitle stream of is image-based and the default subtitle encoder of the Matroska muxer is text-based, so a transcode operation for the subtitles is expected to fail and hence the stream isn’t selected. However, in , a subtitle encoder is specified in the command and so, the subtitle stream is selected, in addition to the video stream. The presence of disables audio stream selection for .\n\nA filtergraph is setup here using the option and consists of a single video filter. The filter requires exactly two video inputs, but none are specified, so the first two available video streams are used, those of and . The output pad of the filter has no label and so is sent to the first output file . Due to this, automatic selection of the video stream is skipped, which would have selected the stream in . The audio stream with most channels viz. in , is chosen automatically. No subtitle stream is chosen however, since the MP4 format has no default subtitle encoder registered, and the user hasn’t specified a subtitle encoder.\n\nThe 2nd output file, , only accepts text-based subtitle streams. So, even though the first subtitle stream available belongs to , it is image-based and hence skipped. The selected stream, in , is the first text-based subtitle stream.\n\nThe above command will fail, as the output pad labelled has been mapped twice. None of the output files shall be processed.\n\nThis command above will also fail as the hue filter output has a label, , and hasn’t been mapped anywhere.\n\nThe command should be modified as follows,\n\nThe video stream from is sent to the hue filter, whose output is cloned once using the split filter, and both outputs labelled. Then a copy each is mapped to the first and third output files.\n\nThe overlay filter, requiring two video inputs, uses the first two unused video streams. Those are the streams from and . The overlay output isn’t labelled, so it is sent to the first output file , regardless of the presence of the option.\n\nThe aresample filter is sent the first unused audio stream, that of . Since this filter output is also unlabelled, it too is mapped to the first output file. The presence of only suppresses automatic or manual stream selection of audio streams, not outputs sent from filtergraphs. Both these mapped streams shall be ordered before the mapped stream in .\n\nThe video, audio and subtitle streams mapped to are entirely determined by automatic stream selection.\n\nconsists of the cloned video output from the hue filter and the first audio stream from . \n\n\n\nAll the numerical options, if not specified otherwise, accept a string representing a number as input, which may be followed by one of the SI unit prefixes, for example: ’K’, ’M’, or ’G’.\n\nIf ’i’ is appended to the SI unit prefix, the complete prefix will be interpreted as a unit prefix for binary multiples, which are based on powers of 1024 instead of powers of 1000. Appending ’B’ to the SI unit prefix multiplies the value by 8. This allows using, for example: ’KB’, ’MiB’, ’G’ and ’B’ as number suffixes.\n\nOptions which do not take arguments are boolean options, and set the corresponding value to true. They can be set to false by prefixing the option name with \"no\". For example using \"-nofoo\" will set the boolean option with name \"foo\" to false.\n\nOptions that take arguments support a special syntax where the argument given on the command line is interpreted as a path to the file from which the actual argument value is loaded. To use this feature, add a forward slash ’/’ immediately before the option name (after the leading dash). E.g.\n\nwill load a filtergraph description from the file named .\n\nSome options are applied per-stream, e.g. bitrate or codec. Stream specifiers are used to precisely specify which stream(s) a given option belongs to.\n\nA stream specifier is a string generally appended to the option name and separated from it by a colon. E.g. contains the stream specifier, which matches the second audio stream. Therefore, it would select the ac3 codec for the second audio stream.\n\nA stream specifier can match several streams, so that the option is applied to all of them. E.g. the stream specifier in matches all audio streams.\n\nAn empty stream specifier matches all streams. For example, or would copy all the streams without reencoding.\n\nPossible forms of stream specifiers are:\n\nThese options are shared amongst the ff* tools.\n\nThese options are provided directly by the libavformat, libavdevice and libavcodec libraries. To see the list of available AVOptions, use the option. They are separated into two categories:\n\nFor example to write an ID3v2.3 header instead of a default ID3v2.4 to an MP3 file, use the private option of the MP3 muxer:\n\nAll codec AVOptions are per-stream, and thus a stream specifier should be attached to them:\n\nIn the above example, a multichannel audio stream is mapped twice for output. The first instance is encoded with codec ac3 and bitrate 640k. The second instance is downmixed to 2 channels and encoded with codec aac. A bitrate of 128k is specified for it using absolute index of the output stream.\n\nNote: the syntax cannot be used for boolean AVOptions, use / .\n\nNote: the old undocumented way of specifying per-stream AVOptions by prepending v/a/s to the options name is now obsolete and will be removed soon.\n\nForce input or output file format. The format is normally auto detected for input files and guessed from the file extension for output files, so this option is not needed in most cases. Do not overwrite output files, and exit immediately if a specified output file already exists. Set number of times input stream shall be looped. Loop 0 means no loop, loop -1 means infinite loop. Allow forcing a decoder of a different media type than the one detected or designated by the demuxer. Useful for decoding media data muxed as data streams. Select an encoder (when used before an output file) or a decoder (when used before an input file) for one or more streams. is the name of a decoder/encoder or a special value (output only) to indicate that the stream is not to be re-encoded. encodes all video streams with libx264 and copies all audio streams. For each stream, the last matching option is applied, so will copy all the streams except the second video, which will be encoded with libx264, and the 138th audio, which will be encoded with libvorbis. When used as an input option (before ), limit the of data read from the input file. When used as an output option (before an output url), stop writing the output after its duration reaches . must be a time duration specification, see (ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual. -to and -t are mutually exclusive and -t has priority. Stop writing the output or reading the input at . must be a time duration specification, see (ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual. -to and -t are mutually exclusive and -t has priority. Set the file size limit, expressed in bytes. No further chunk of bytes is written after the limit is exceeded. The size of the output file is slightly more than the requested file size. When used as an input option (before ), seeks in this input file to . Note that in most formats it is not possible to seek exactly, so will seek to the closest seek point before . When transcoding and is enabled (the default), this extra segment between the seek point and will be decoded and discarded. When doing stream copy or when is used, it will be preserved. When used as an output option (before an output url), decodes but discards input until the timestamps reach . must be a time duration specification, see (ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual. Like the option but relative to the \"end of file\". That is negative values are earlier in the file, 0 is at EOF. This will take the difference between the start times of the target and reference inputs and offset the timestamps of the target file by that difference. The source timestamps of the two inputs should derive from the same clock source for expected results. If is set then must also be set. If either of the inputs has no starting timestamp then no sync adjustment is made. Acceptable values are those that refer to a valid ffmpeg input index. If the sync reference is the target index itself or , then no adjustment is made to target timestamps. A sync reference may not itself be synced to any other input. must be a time duration specification, see (ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual. The offset is added to the timestamps of the input files. Specifying a positive offset means that the corresponding streams are delayed by the time duration specified in . Set the recording timestamp in the container. must be a date specification, see (ffmpeg-utils)the Date section in the ffmpeg-utils(1) manual. An optional may be given to set metadata on streams, chapters or programs. See documentation for details. This option overrides metadata set with . It is also possible to delete metadata by using an empty value. For example, for setting the title in the output file: To set the language of the first audio stream: Default value: by default, all disposition flags are copied from the input stream, unless the output stream this option applies to is fed by a complex filtergraph - in that case no disposition flags are set by default. is a sequence of disposition flags separated by ’+’ or ’-’. A ’+’ prefix adds the given disposition, ’-’ removes it. If the first flag is also prefixed with ’+’ or ’-’, the resulting disposition is the default value updated by . If the first flag is not prefixed, the resulting disposition is . It is also possible to clear the disposition by setting it to 0. If no options were specified for an output file, ffmpeg will automatically set the ’default’ disposition flag on the first stream of each type, when there are multiple streams of this type in the output file and no stream of that type is already marked as default. The option lists the known disposition flags. For example, to make the second audio stream the default stream: To make the second subtitle stream the default stream and remove the default disposition from the first subtitle stream: To add the ’original’ and remove the ’comment’ disposition flag from the first audio stream without removing its other disposition flags: To remove the ’original’ and add the ’comment’ disposition flag to the first audio stream without removing its other disposition flags: To set only the ’original’ and ’comment’ disposition flags on the first audio stream (and remove its other disposition flags): To remove all disposition flags from the first audio stream: Not all muxers support embedded thumbnails, and those who do, only support a few formats, like JPEG or PNG. Creates a program with the specified , and adds the specified (s) to it. Creates a stream group of the specified and , or by ping an input group, adding the specified (s) and/or previously defined (s) to it. can be one of the following: Groups s that belong to the same IAMF Audio Element For this group , the following options are available The Audio Element type. The following values are supported: Demixing information used to reconstruct a scalable channel audio representation. This option must be separated from the rest with a ’,’, and takes the following key=value options An identifier parameters blocks in frames may refer to Recon gain information used to reconstruct a scalable channel audio representation. This option must be separated from the rest with a ’,’, and takes the following key=value options An identifier parameters blocks in frames may refer to A layer defining a Channel Layout in the Audio Element. This option must be separated from the rest with a ’,’. Several ’,’ separated entries can be defined, and at least one must be set. It takes the following \":\"-separated key=value options The following flags are available: Wether to signal if recon_gain is present as metadata in parameter blocks within frames Which channels output_gain applies to. The following flags are available: The ambisonics mode. This has no effect if audio_element_type is set to channel. The following values are supported: Each ambisonics channel is coded as an individual mono stream in the group Groups s that belong to all IAMF Audio Element the same IAMF Mix Presentation references For this group , the following options are available A sub-mix within the Mix Presentation. This option must be separated from the rest with a ’,’. Several ’,’ separated entries can be defined, and at least one must be set. It takes the following \":\"-separated key=value options An identifier parameters blocks in frames may refer to, for post-processing the mixed audio signal to generate the audio signal for playback The sample rate duration fields in parameters blocks in frames that refer to this are expressed as Default mix gain value to apply when there are no parameter blocks sharing the same for a given frame References an Audio Element used in this Mix Presentation to generate the final output audio signal for playback. This option must be separated from the rest with a ’|’. Several ’|’ separated entries can be defined, and at least one must be set. It takes the following \":\"-separated key=value options: The for an Audio Element which this sub-mix refers to An identifier parameters blocks in frames may refer to, for applying any processing to the referenced and rendered Audio Element before being summed with other processed Audio Elements The sample rate duration fields in parameters blocks in frames that refer to this are expressed as Default mix gain value to apply when there are no parameter blocks sharing the same for a given frame A key=value string describing the sub-mix element where \"key\" is a string conforming to BCP-47 that specifies the language for the \"value\" string. \"key\" must be the same as the one in the mix’s Indicates whether the input channel-based Audio Element is rendered to stereo loudspeakers or spatialized with a binaural renderer when played back on headphones. This has no effect if the referenced Audio Element’s is set to channel. The following values are supported: Specifies the layouts for this sub-mix on which the loudness information was measured. This option must be separated from the rest with a ’|’. Several ’|’ separated entries can be defined, and at least one must be set. It takes the following \":\"-separated key=value options: The layout follows the loudspeaker sound system convention of ITU-2051-3. Channel layout matching one of Sound Systems A to J of ITU-2051-3, plus 7.1.2 and 3.1.2 This has no effect if is set to binaural. The program integrated loudness information, as defined in ITU-1770-4. The digital (sampled) peak value of the audio signal, as defined in ITU-1770-4. The true peak of the audio signal, as defined in ITU-1770-4. The Dialogue loudness information, as defined in ITU-1770-4. The Album loudness information, as defined in ITU-1770-4. A key=value string string describing the mix where \"key\" is a string conforming to BCP-47 that specifies the language for the \"value\" string. \"key\" must be the same as the ones in all sub-mix element’s s E.g. to create an scalable 5.1 IAMF file from several WAV input files To copy the two stream groups (Audio Element and Mix Presentation) from an input IAMF file with four streams into an mp4 output Specify target file type ( , , , , ). may be prefixed with , or to use the corresponding standard. All the format options (bitrate, codecs, buffer sizes) are then set automatically. You can just type: Nevertheless you can specify additional options as long as you know they do not conflict with the standard, as in: The parameters set for each target are as follows. The target is identical to the target except that the pixel format set is for all three standards. Any user-set value for a parameter above will override the target preset value. In that case, the output may not comply with the target standard. As an input option, blocks all data streams of a file from being filtered or being automatically selected or mapped for any output. See option to disable streams individually. As an output option, disables data recording i.e. automatic selection or mapping of any data stream. For full manual control see the option. Set the number of data frames to output. This is an obsolete alias for , which you should use instead. Stop writing to the stream after frames. Use fixed quality scale (VBR). The meaning of / is codec-dependent. If is used without a then it applies only to the video stream, this is to maintain compatibility with previous behavior and as specifying the same codec specific value to 2 different codecs that is audio and video generally is not what is intended when no stream_specifier is used. Create the filtergraph specified by and use it to filter the stream. is a description of the filtergraph to apply to the stream, and must have a single input and a single output of the same type of the stream. In the filtergraph, the input is associated to the label , and the output to the label . See the ffmpeg-filters manual for more information about the filtergraph syntax. See the -filter_complex option if you want to create filtergraphs with multiple inputs and/or outputs. This boolean option determines if the filtergraph(s) to which this stream is fed gets reinitialized when input frame parameters change mid-stream. This option is enabled by default as most video and all audio filters cannot handle deviation in input frame properties. Upon reinitialization, existing filter state is lost, like e.g. the frame count reference available in some filters. Any frames buffered at time of reinitialization are lost. The properties where a change triggers reinitialization are, for video, frame resolution or pixel format; for audio, sample format, sample rate, channel count or channel layout. Defines how many threads are used to process a filter pipeline. Each pipeline will produce a thread pool with this many threads available for parallel processing. The default is the number of available CPUs. Specify the preset for matching stream(s). Log encoding progress/statistics as \"info\"-level log (see ). It is on by default, to explicitly disable it you need to specify . Set period at which encoding progress/statistics are updated. Default is 0.5 seconds. Progress information is written periodically and at the end of the encoding process. It is made of \" = \" lines. consists of only alphanumeric characters. The last key of a sequence of progress information is always \"progress\" with the value \"continue\" or \"end\". The update period is set using . For example, log progress information to stdout: Enable interaction on standard input. On by default unless standard input is used as an input. To explicitly disable interaction you need to specify . Disabling interaction on standard input is useful, for example, if ffmpeg is in the background process group. Roughly the same result can be achieved with but it requires a shell. Print timestamp/latency information. It is off by default. This option is mostly useful for testing and debugging purposes, and the output format may change from one version to another, so it should not be employed by portable scripts. See also the option . Add an attachment to the output file. This is supported by a few formats like Matroska for e.g. fonts used in rendering subtitles. Attachments are implemented as a specific type of stream, so this option will add a new stream to the file. It is then possible to use per-stream options on this stream in the usual way. Attachment streams created with this option will be created after all the other streams (i.e. those created with or automatic mappings). Note that for Matroska you also have to set the mimetype metadata tag: (assuming that the attachment stream will be third in the output file). Extract the matching attachment stream into a file named . If is empty, then the value of the metadata tag will be used. E.g. to extract the first attachment to a file named ’out.ttf’: To extract all attachments to files determined by the tag: Technical note – attachments are implemented as codec extradata, so this option can actually be used to extract extradata from any stream, not just attachments.\n\nSet pixel format. Use to show all the supported pixel formats. If the selected pixel format can not be selected, ffmpeg will print a warning and select the best pixel format supported by the encoder. If is prefixed by a , ffmpeg will exit with an error if the requested pixel format can not be selected, and automatic conversions inside filtergraphs are disabled. If is a single , ffmpeg selects the same pixel format as the input (or graph output) and automatic conversions are disabled. Set default flags for the libswscale library. These flags are used by automatically inserted filters and those within simple filtergraphs, if not overridden within the filtergraph definition. See the (ffmpeg-scaler)ffmpeg-scaler manual for a list of scaler options. Rate control override for specific intervals, formatted as \"int,int,int\" list separated with slashes. Two first values are the beginning and end frame numbers, last one is quantizer to use if positive, or quality factor if negative. Dump video coding statistics to . See the vstats file format section for the format description. Dump video coding statistics to . See the vstats file format section for the format description. Specify which version of the vstats format to use. Default is . See the vstats file format section for the format description. Force video tag/fourcc. This is an alias for . can take arguments of the following form: If the argument consists of timestamps, ffmpeg will round the specified times to the nearest output timestamp as per the encoder time base and force a keyframe at the first frame having timestamp equal or greater than the computed timestamp. Note that if the encoder time base is too coarse, then the keyframes may be forced on frames with timestamps lower than the specified time. The default encoder time base is the inverse of the output framerate but may be set otherwise via . If one of the times is \" [ ]\", it is expanded into the time of the beginning of all chapters in the file, shifted by , expressed as a time in seconds. This option can be useful to ensure that a seek point is present at a chapter mark or any other designated place in the output file. For example, to insert a key frame at 5 minutes, plus key frames 0.1 second before the beginning of every chapter: If the argument is prefixed with , the string is interpreted like an expression and is evaluated for each frame. A key frame is forced in case the evaluation is non-zero. The expression in can contain the following constants: the number of current processed frame, starting from 0 the number of the previous forced frame, it is when no keyframe was forced yet the time of the previous forced frame, it is when no keyframe was forced yet the time of the current processed frame For example to force a key frame every 5 seconds, you can specify: To force a key frame 5 seconds after the time of the last forced one, starting from second 13: If the argument is , ffmpeg will force a key frame if the current frame being encoded is marked as a key frame in its source. In cases where this particular source frame has to be dropped, enforce the next available frame to become a key frame instead. Note that forcing too many keyframes is very harmful for the lookahead algorithms of certain encoders: using fixed-GOP options or similar would be more efficient. Automatically crop the video after decoding according to file metadata. Default is all. Apply both codec and container level croppping. This is the default mode. When doing stream copy, copy also non-key frames found at the beginning. Initialise a new hardware device of type called , using the given device parameters. If no name is specified it will receive a default name of the form \" %d\". The meaning of and the following arguments depends on the device type: is the number of the CUDA device. The following options are recognized: If set to 1, uses the primary device context instead of creating a new one. Choose the second device on the system. Choose the first device and use the primary device context. is the number of the Direct3D 9 display adapter. is the number of the Direct3D 11 display adapter. If not specified, it will attempt to use the default Direct3D 11 display adapter or the first Direct3D 11 display adapter whose hardware VendorId is specified by ‘ ’. Create a d3d11va device on the Direct3D 11 display adapter specified by index 1. Create a d3d11va device on the first Direct3D 11 display adapter whose hardware VendorId is 0x8086. is either an X11 display name, a DRM render node or a DirectX adapter index. If not specified, it will attempt to open the default X11 display ($DISPLAY) and then the first DRM render node (/dev/dri/renderD128), or the default DirectX adapter on Windows. The following options are recognized: When is not specified, use this option to specify the name of the kernel driver associated with the desired device. This option is available only when the hardware acceleration method drm and vaapi are enabled. When and are not specified, use this option to specify the vendor id associated with the desired device. This option is available only when the hardware acceleration method drm and vaapi are enabled and kernel_driver is not specified. Create a vaapi device on a device associated with kernel driver ‘ ’. Create a vaapi device on a device associated with vendor id ‘ ’. is an X11 display name. If not specified, it will attempt to open the default X11 display ($DISPLAY). selects a value in ‘ ’. Allowed values are: If not specified, ‘ ’ is used. (Note that it may be easier to achieve the desired result for QSV by creating the platform-appropriate subdevice (‘ ’ or ‘ ’ or ‘ ’) and then deriving a QSV device from that.) The following options are recognized: Specify a DRM render node on Linux or DirectX adapter on Windows. Choose platform-appropriate subdevice type. On Windows ‘ ’ is used as default subdevice type when is specified at configuration time, ‘ ’ is used as default subdevice type when is specified at configuration time. On Linux user can use ‘ ’ only as subdevice type. Choose the GPU subdevice with type ‘ ’ and create QSV device with ‘ ’. Choose the GPU subdevice with type ‘ ’ and create QSV device with ‘ ’. Create a QSV device with ‘ ’ on DirectX adapter 1 with subdevice type ‘ ’. Create a VAAPI device called ‘ ’ on , then derive a QSV device called ‘ ’ from device ‘ ’. selects the platform and device as platform_index.device_index. The set of devices can also be filtered using the key-value pairs to find only devices matching particular platform or device strings. The strings usable as filters are: The indices and filters must together uniquely select a device. Choose the second device on the first platform. Choose the device with a name containing the string Foo9000. Choose the GPU device on the second platform supporting the cl_khr_fp16 extension. If is an integer, it selects the device by its index in a system-dependent list of devices. If is any other string, it selects the first device with a name containing that string as a substring. The following options are recognized: If set to 1, enables the validation layer, if installed. If set to 1, images allocated by the hwcontext will be linear and locally mappable. A plus separated list of additional instance extensions to enable. A plus separated list of additional device extensions to enable. Choose the second device on the system. Choose the first device with a name containing the string RADV. Choose the first device and enable the Wayland and XCB instance extensions. Initialise a new hardware device of type called , deriving it from the existing device with the name . List all hardware device types supported in this build of ffmpeg. Pass the hardware device called to all filters in any filter graph. This can be used to set the device to upload to with the filter, or the device to map to with the filter. Other filters may also make use of this parameter when they require a hardware device. Note that this is typically only required when the input is not already in hardware frames - when it is, filters will derive the device they require from the context of the frames they receive as input. This is a global setting, so all filters will receive the same device. Use hardware acceleration to decode the matching stream(s). The allowed values of are: Do not use any hardware acceleration (the default). Use VDPAU (Video Decode and Presentation API for Unix) hardware acceleration. Use the Intel QuickSync Video acceleration for video transcoding. Unlike most other values, this option does not enable accelerated decoding (that is used automatically whenever a qsv decoder is selected), but accelerated transcoding, without copying the frames into the system memory. For it to work, both the decoder and the encoder must support QSV acceleration and no filters must be used. This option has no effect if the selected hwaccel is not available or not supported by the chosen decoder. Note that most acceleration methods are intended for playback and will not be faster than software decoding on modern CPUs. Additionally, will usually need to copy the decoded frames from the GPU memory into the system memory, resulting in further performance loss. This option is thus mainly useful for testing. Select a device to use for hardware acceleration. This option only makes sense when the option is also specified. It can either refer to an existing device created with by name, or it can create a new device as if ‘ ’ : were called immediately before. List all hardware acceleration components enabled in this build of ffmpeg. Actual runtime availability depends on the hardware and its suitable driver being installed. Set a specific output video stream as the heartbeat stream according to which to split and push through currently in-progress subtitle upon receipt of a random access packet. This lowers the latency of subtitles for which the end packet or the following subtitle has not yet been received. As a drawback, this will most likely lead to duplication of subtitle events in order to cover the full duration, so when dealing with use cases where latency of when the subtitle event is passed on to output is not relevant this option should not be utilized. Requires to be set for the relevant input subtitle stream for this to have any effect, as well as for the input subtitle stream having to be directly mapped to the same output in which the heartbeat stream resides.\n\nCreate one or more streams in the output file. This option has two forms for specifying the data source(s): the first selects one or more streams from some input file (specified with ), the second takes an output from some complex filtergraph (specified with ). In the first form, an output stream is created for every stream from the input file with the index . If is given, only those streams that match the specifier are used (see the Stream specifiers section for the syntax). A character before the stream identifier creates a \"negative\" mapping. It disables matching streams from already created mappings. An optional may be given after the stream specifier, which for multiview video specifies the view to be used. The view specifier may have one of the following formats: select a view by its ID; may be set to ’all’ to use all the views interleaved into one stream; select a view by its index; i.e. 0 is the base view, 1 is the first non-base view, etc. select a view by its display position; may be or The default for transcoding is to only use the base view, i.e. the equivalent of . For streamcopy, view specifiers are not supported and all views are always copied. A trailing after the stream index will allow the map to be optional: if the map matches no streams the map will be ignored instead of failing. Note the map will still fail if an invalid input file index is used; such as if the map refers to a non-existent input. An alternative form will map outputs from complex filter graphs (see the option) to the output file. must correspond to a defined output link label in the graph. This option may be specified multiple times, each adding more streams to the output file. Any given input stream may also be mapped any number of times as a source for different output streams, e.g. in order to use different encoding options and/or filters. The streams are created in the output in the same order in which the options are given on the commandline. Using this option disables the default mappings for this output file. To map ALL streams from the first input file to output If you have two audio streams in the first input file, these streams are identified by and . You can use to select which streams to place in an output file. For example: will map the second input stream in to the (single) output stream in . To select the stream with index 2 from input file (specified by the identifier ), and stream with index 6 from input (specified by the identifier ), and copy them to the output file : To select all video and the third audio stream from an input file: To map all the streams except the second audio, use negative mappings To map the video and audio streams from the first input, and using the trailing , ignore the audio mapping if no audio streams exist in the first input: Ignore input streams with unknown type instead of failing if copying such streams is attempted. Allow input streams with unknown type to be copied instead of failing if copying such streams is attempted. Set metadata information of the next output file from . Note that those are file indices (zero-based), not filenames. Optional parameters specify, which metadata to copy. A metadata specifier can have the following forms: global metadata, i.e. metadata that applies to the whole file per-stream metadata. is a stream specifier as described in the Stream specifiers chapter. In an input metadata specifier, the first matching stream is copied from. In an output metadata specifier, all matching streams are copied to. If metadata specifier is omitted, it defaults to global. By default, global metadata is copied from the first input file, per-stream and per-chapter metadata is copied along with streams/chapters. These default mappings are disabled by creating any mapping of the relevant type. A negative file index can be used to create a dummy mapping that just disables automatic copying. For example to copy metadata from the first stream of the input file to global metadata of the output file: To do the reverse, i.e. copy global metadata to all audio streams: Note that simple would work as well in this example, since global metadata is assumed by default. Copy chapters from input file with index to the next output file. If no chapter mapping is specified, then chapters are copied from the first input file with at least one chapter. Use a negative file index to disable any chapter copying. Show benchmarking information at the end of an encode. Shows real, system and user time used and maximum memory consumption. Maximum memory consumption is not supported on all systems, it will usually display as 0 if not supported. Show benchmarking information during the encode. Shows real, system and user time used in various steps (audio/video encode/decode). Exit after ffmpeg has been running for seconds in CPU user time. When dumping packets, also dump the payload. Its value is a floating-point positive number which represents the maximum duration of media, in seconds, that should be ingested in one second of wallclock time. Default value is zero and represents no imposed limitation on speed of ingestion. Value represents real-time speed and is equivalent to . Mainly used to simulate a capture device or live input stream (e.g. when reading from a file). Should not be used with a low value when input is an actual capture device or live stream as it may cause packet loss. It is useful for when flow speed of output packets is important, such as live streaming. Read input at native frame rate. This is equivalent to setting . Set an initial read burst time, in seconds, after which will be enforced. If either the input or output is blocked leading to actual read speed falling behind the specified readrate, then this rate takes effect till the input catches up with the specified readrate. Must not be lower than the primary readrate. Set video sync method / framerate mode. vsync is applied to all output video streams but can be overridden for a stream by setting fps_mode. vsync is deprecated and will be removed in the future. For compatibility reasons some of the values for vsync can be specified as numbers (shown in parentheses in the following table). Each frame is passed with its timestamp from the demuxer to the muxer. Frames will be duplicated and dropped to achieve exactly the requested constant frame rate. Frames are passed through with their timestamp or dropped so as to prevent 2 frames from having the same timestamp. Chooses between cfr and vfr depending on muxer capabilities. This is the default method. Note that the timestamps may be further modified by the muxer, after this. For example, in the case that the format option is enabled. With -map you can select from which stream the timestamps should be taken. You can leave either video or audio unchanged and sync the remaining stream(s) to the unchanged one. Frame drop threshold, which specifies how much behind video frames can be before they are dropped. In frame rate units, so 1.0 is one frame. The default is -1.1. One possible usecase is to avoid framedrops in case of noisy timestamps or to increase frame drop precision in case of exact timestamps. Pad the output audio stream(s). This is the same as applying . Argument is a string of filter parameters composed the same as with the filter. must be set for this output for the option to take effect. Do not process input timestamps, but keep their values without trying to sanitize them. In particular, do not remove the initial start time offset value. Note that, depending on the option or on specific muxer processing (e.g. in case the format option is enabled) the output timestamps may mismatch with the input timestamps even when this option is selected. When used with , shift input timestamps so they start at zero. This means that using e.g. will make output timestamps start at 50 seconds, regardless of what timestamp the input file started at. Specify how to set the encoder timebase when stream copying. is an integer numeric value, and can assume one of the following values: The time base is copied to the output encoder from the corresponding input demuxer. This is sometimes required to avoid non monotonically increasing timestamps when copying video streams with variable frame rate. The time base is copied to the output encoder from the corresponding input decoder. Try to make the choice automatically, in order to generate a sane output. Set the encoder timebase. can assume one of the following values: Assign a default value according to the media type. For video - use 1/framerate, for audio - use 1/samplerate. Use the timebase from the demuxer. Use the timebase from the filtergraph. Use the provided number as the timebase. This field can be provided as a ratio of two integers (e.g. 1:24, 1:48000) or as a decimal number (e.g. 0.04166, 2.0833e-5) Note that this option may require buffering frames, which introduces extra latency. The maximum amount of this latency may be controlled with the option. The option may require buffering potentially large amounts of data when at least one of the streams is \"sparse\" (i.e. has large gaps between frames – this is typically the case for subtitles). This option controls the maximum duration of buffered frames in seconds. Larger values may allow the option to produce more accurate results, but increase memory use and latency. The default value is 10 seconds. The timestamp discontinuity correction enabled by this option is only applied to input formats accepting timestamp discontinuity (for which the flag is enabled), e.g. MPEG-TS and HLS, and is automatically disabled when employing the option (unless wrapping is detected). If a timestamp discontinuity is detected whose absolute value is greater than , ffmpeg will remove the discontinuity by decreasing/increasing the current DTS and PTS by the corresponding delta value. The timestamp correction enabled by this option is only applied to input formats not accepting timestamp discontinuity (for which the flag is not enabled). If a timestamp discontinuity is detected whose absolute value is greater than , ffmpeg will drop the PTS/DTS timestamp value. The default value is (30 hours), which is arbitrarily picked and quite conservative. Assign a new stream-id value to an output stream. This option should be specified prior to the output filename to which it applies. For the situation where multiple output files exist, a streamid may be reassigned to a different value. For example, to set the stream 0 PID to 33 and the stream 1 PID to 36 for an output mpegts file: Apply bitstream filters to matching streams. The filters are applied to each packet as it is received from the demuxer (when used as an input option) or before it is sent to the muxer (when used as an output option). is a comma-separated list of bitstream filter specifications, each of the form Any of the ’,=:’ characters that are to be a part of an option value need to be escaped with a backslash. Use the option to get the list of bitstream filters. applies the bitstream filter (which converts MP4-encapsulated H.264 stream to Annex B) to the input video stream. applies the bitstream filter (which extracts text from MOV subtitles) to the output subtitle stream. Note, however, that since both examples use , it matters little whether the filters are applied on input or output - that would change if transcoding was happening. Specify Timecode for writing. is ’:’ for non drop timecode and ’;’ (or ’.’) for drop. Define a complex filtergraph, i.e. one with arbitrary number of inputs and/or outputs. For simple graphs – those with one input and one output of the same type – see the options. is a description of the filtergraph, as described in the “Filtergraph syntax” section of the ffmpeg-filters manual. This option may be specified multiple times - each use creates a new complex filtergraph. Inputs to a complex filtergraph may come from different source types, distinguished by the format of the corresponding link label:\n• To connect an input stream, use (i.e. the same syntax as ). If matches multiple streams, the first one will be used. For multiview video, the stream specifier may be followed by the view specifier, see documentation for the option for its syntax.\n• To connect a loopback decoder use [dec: ], where is the index of the loopback decoder to be connected to given input. For multiview video, the decoder index may be followed by the view specifier, see documentation for the option for its syntax.\n• To connect an output from another complex filtergraph, use its link label. E.g the following example:\n• (line 2) uses a complex filtergraph with one input and two outputs to scale the video to 1920x1080 and duplicate the result to both outputs;\n• (line 3) encodes one scaled output with and writes the result to ;\n• (line 5) places the output of the loopback decoder (i.e. the -encoded video) side by side with the scaled original input;\n• (line 6) combined video is then losslessly encoded and written into . Note that the two filtergraphs cannot be combined into one, because then there would be a cycle in the transcoding pipeline (filtergraph output goes to encoding, from there to decoding, then back to the same graph), and such cycles are not allowed. An unlabeled input will be connected to the first unused input stream of the matching type. Output link labels are referred to with . Unlabeled outputs are added to the first output file. Note that with this option it is possible to use only lavfi sources without normal input files. For example, to overlay an image over video Here refers to the first video stream in the first input file, which is linked to the first (main) input of the overlay filter. Similarly the first video stream in the second input is linked to the second (overlay) input of overlay. Assuming there is only one video stream in each input file, we can omit input labels, so the above is equivalent to Furthermore we can omit the output label and the single output from the filter graph will be added to the output file automatically, so we can simply write As a special exception, you can use a bitmap subtitle stream as input: it will be converted into a video with the same size as the largest video in the file, or 720x576 if no video is present. Note that this is an experimental and temporary solution. It will be removed once libavfilter has proper support for subtitles. For example, to hardcode subtitles on top of a DVB-T recording stored in MPEG-TS format, delaying the subtitles by 1 second: To generate 5 seconds of pure red video using lavfi source: Defines how many threads are used to process a filter_complex graph. Similar to filter_threads but used for graphs only. The default is the number of available CPUs. Define a complex filtergraph, i.e. one with arbitrary number of inputs and/or outputs. Equivalent to . This option enables or disables accurate seeking in input files with the option. It is enabled by default, so seeking is accurate when transcoding. Use to disable it, which may be useful e.g. when copying some streams and transcoding the others. This option enables or disables seeking by timestamp in input files with the option. It is disabled by default. If enabled, the argument to the option is considered an actual timestamp, and is not offset by the start time of the file. This matters only for files which do not start from timestamp 0, such as transport streams. For input, this option sets the maximum number of queued packets when reading from the file or device. With low latency / high rate live streams, packets may be discarded if they are not read in a timely manner; setting this value can force ffmpeg to use a separate input thread and read packets as soon as they arrive. By default ffmpeg only does this if multiple inputs are specified. For output, this option specified the maximum number of packets that may be queued to each muxing thread. Print sdp information for an output stream to . This allows dumping sdp information when at least one output isn’t an rtp stream. (Requires at least one of the output formats to be rtp). Allows discarding specific streams or frames from streams. Any input stream can be fully discarded, using value whereas selective discarding of frames from a stream occurs at the demuxer and is not supported by all demuxers. Stop and abort on various conditions. The following flags are available: No packets were passed to the muxer, the output is empty. No packets were passed to the muxer in some of the output streams. Set fraction of decoding frame failures across all inputs which when crossed ffmpeg will return exit code 69. Crossing this threshold does not terminate processing. Range is a floating-point number between 0 to 1. Default is 2/3. When transcoding audio and/or video streams, ffmpeg will not begin writing into the output until it has one packet for each such stream. While waiting for that to happen, packets for other streams are buffered. This option sets the size of this buffer, in packets, for the matching output stream. The default value of this option should be high enough for most uses, so only touch this option if you are sure that you need it. This is a minimum threshold until which the muxing queue size is not taken into account. Defaults to 50 megabytes per stream, and is based on the overall size of packets passed to the muxer. Enable automatically inserting format conversion filters in all filter graphs, including those defined by , , and . If filter format negotiation requires a conversion, the initialization of the filters will fail. Conversions can still be performed by inserting the relevant conversion filter (scale, aresample) in the graph. On by default, to explicitly disable it you need to specify . Declare the number of bits per raw sample in the given output stream to be . Note that this option sets the information provided to the encoder/muxer, it does not change the stream to conform to this value. Setting values that do not match the stream properties may result in encoding failures or invalid output files. Write per-frame encoding information about the matching streams into the file given by . writes information about raw video or audio frames right before they are sent for encoding, while writes information about encoded packets as they are received from the encoder. writes information about packets just as they are about to be sent to the muxer. Every frame or packet produces one line in the specified file. The format of this line is controlled by / / . When stats for multiple streams are written into a single file, the lines corresponding to different streams will be interleaved. The precise order of this interleaving is not specified and not guaranteed to remain stable between different invocations of the program, even with the same options. Specify the format for the lines written with / / . is a string that may contain directives of the form . is backslash-escaped — use \\{, \\}, and \\\\ to write a literal {, }, or \\, respectively, into the output. The directives given with may be one of the following: Index of the output stream in the file. Frame number. Pre-encoding: number of frames sent to the encoder so far. Post-encoding: number of packets received from the encoder so far. Muxing: number of packets submitted to the muxer for this stream so far. Input frame number. Index of the input frame (i.e. output by a decoder) that corresponds to this output frame or packet. -1 if unavailable. Timebase in which this frame/packet’s timestamps are expressed, as a rational number . Note that encoder and muxer may use different timebases. Timebase for , as a rational number . Available when is available, otherwise. Presentation timestamp of the frame or packet, as an integer. Should be multiplied by the timebase to compute presentation time. Presentation timestamp of the input frame (see ), as an integer. Should be multiplied by to compute presentation time. Printed as (2^63 - 1 = 9223372036854775807) when not available. Presentation time of the frame or packet, as a decimal number. Equal to multiplied by . Presentation time of the input frame (see ), as a decimal number. Equal to multiplied by . Printed as inf when not available. Decoding timestamp of the packet, as an integer. Should be multiplied by the timebase to compute presentation time. Decoding time of the frame or packet, as a decimal number. Equal to multiplied by . Number of audio samples sent to the encoder so far. Number of audio samples in the frame. Size of the encoded packet in bytes. Current bitrate in bits per second. Average bitrate for the whole stream so far, in bits per second, -1 if it cannot be determined at this point. Character ’K’ if the packet contains a keyframe, character ’N’ otherwise. Directives tagged with packet may only be used with and . Directives tagged with frame may only be used with . Directives tagged with audio may only be used with audio streams. In the future, new items may be added to the end of the default formatting strings. Users who depend on the format staying exactly the same, should prescribe it manually. Note that stats for different streams written into the same file may have different formats.\n\nA preset file contains a sequence of = pairs, one for each line, specifying a sequence of options which would be awkward to specify on the command line. Lines starting with the hash (’#’) character are ignored and are used to provide comments. Check the directory in the FFmpeg source tree for examples.\n\nThere are two types of preset files: ffpreset and avpreset files.\n\nffpreset files are specified with the , , , and options. The option takes the filename of the preset instead of a preset name as input and can be used for any kind of codec. For the , , and options, the options specified in a preset file are applied to the currently selected codec of the same type as the preset option.\n\nThe argument passed to the , , and preset options identifies the preset file to use according to the following rules:\n\nFirst ffmpeg searches for a file named .ffpreset in the directories (if set), and , and in the datadir defined at configuration time (usually ) or in a folder along the executable on win32, in that order. For example, if the argument is , it will search for the file .\n\nIf no such file is found, then ffmpeg will search for a file named - .ffpreset in the above-mentioned directories, where is the name of the codec to which the preset file options will be applied. For example, if you select the video codec with and use , then it will search for the file .\n\navpreset files are specified with the option. They work similar to ffpreset files, but they only allow encoder- specific options. Therefore, an = pair specifying an encoder cannot be used.\n\nWhen the option is specified, ffmpeg will look for files with the suffix .avpreset in the directories (if set), and , and in the datadir defined at configuration time (usually ), in that order.\n\nFirst ffmpeg searches for a file named - .avpreset in the above-mentioned directories, where is the name of the codec to which the preset file options will be applied. For example, if you select the video codec with and use , then it will search for the file .\n\nIf no such file is found, then ffmpeg will search for a file named .avpreset in the same directories.\n\nThe and options enable generation of a file containing statistics about the generated video outputs.\n\nThe option controls the format version of the generated file.\n\nWith version the format is:\n\nWith version the format is:\n\nThe value corresponding to each key is described below:\n\nSee also the -stats_enc options for an alternative way to show encoding statistics.\n\nIf you specify the input format and device then ffmpeg can grab video and audio directly.\n\nOr with an ALSA audio source (mono input, card id 1) instead of OSS:\n\nNote that you must activate the right video source and channel before launching ffmpeg with any TV viewer such as xawtv by Gerd Knorr. You also have to set the audio recording levels correctly with a standard mixer.\n\nGrab the X11 display with ffmpeg via\n\n0.0 is display.screen number of your X11 server, same as the DISPLAY environment variable.\n\n0.0 is display.screen number of your X11 server, same as the DISPLAY environment variable. 10 is the x-offset and 20 the y-offset for the grabbing.\n\nAny supported file format and protocol can serve as input to ffmpeg:\n• You can use YUV files as input: It will use the files: The Y files use twice the resolution of the U and V files. They are raw files, without header. They can be generated by all decent video decoders. You must specify the size of the image with the option if ffmpeg cannot guess it.\n• You can input from a raw YUV420P file: test.yuv is a file containing raw YUV planar data. Each frame is composed of the Y plane followed by the U and V planes at half vertical and horizontal resolution.\n• You can output to a raw YUV420P file:\n• You can set several input files and output files: Converts the audio file a.wav and the raw YUV video file a.yuv to MPEG file a.mpg.\n• You can also do audio and video conversions at the same time:\n• You can encode to several formats at the same time and define a mapping from input stream to output streams: Converts a.wav to a.mp2 at 64 kbits and to b.mp2 at 128 kbits. ’-map file:index’ specifies which input stream is used for each output stream, in the order of the definition of output streams.\n• You can transcode decrypted VOBs: This is a typical DVD ripping example; the input is a VOB file, the output an AVI file with MPEG-4 video and MP3 audio. Note that in this command we use B-frames so the MPEG-4 stream is DivX5 compatible, and GOP size is 300 which means one intra frame every 10 seconds for 29.97fps input video. Furthermore, the audio stream is MP3-encoded so you need to enable LAME support by passing to configure. The mapping is particularly useful for DVD transcoding to get the desired audio language. NOTE: To see the supported input formats, use .\n• You can extract images from a video, or create a video from many images: This will extract one video frame per second from the video and will output them in files named , , etc. Images will be rescaled to fit the new WxH values. If you want to extract just a limited number of frames, you can use the above command in combination with the or option, or in combination with -ss to start extracting from a certain point in time. For creating a video from many images: The syntax specifies to use a decimal number composed of three digits padded with zeroes to express the sequence number. It is the same syntax supported by the C printf function, but only formats accepting a normal integer are suitable. When importing an image sequence, -i also supports expanding shell-like wildcard patterns (globbing) internally, by selecting the image2-specific option. For example, for creating a video from filenames matching the glob pattern :\n• You can put many streams of the same type in the output: The resulting output file will contain the first four streams from the input files in reverse order.\n• The four options lmin, lmax, mblmin and mblmax use ’lambda’ units, but you may use the QP2LAMBDA constant to easily convert from ’q’ units:\n\nFor details about the authorship, see the Git history of the project (https://git.ffmpeg.org/ffmpeg), e.g. by typing the command in the FFmpeg source directory, or browsing the online repository at https://git.ffmpeg.org/ffmpeg.\n\nMaintainers for the specific components are listed in the file in the source code tree.\n\nThis document was generated on March 22, 2025 using makeinfo."
    },
    {
        "link": "https://stackoverflow.com/questions/5678695/ffmpeg-usage-to-encode-a-video-to-h264-codec-format",
        "document": "I have a *.mp4 video file(MPEG4 video codec) and I am trying to convert this to a H264 video codec format(raw h.264 format) using ffmpeg on Linux(Version - FFmpeg version SVN-r0.5.1-4:0.5.1-1ubuntu1, Copyright (c) 2000-2009 Fabrice Bellard,) using command line as shown below,\n\nbut I get an error saying -\n\nThen when i try this option:\n\nit still does not work, and gives -\n\nAnd then it prints out help on the formats which we get when we do\n\nWhen I checked the help, , I see below information related to H264 file format and codec:\n• None How can I convert the video to a H264 encoded video (raw H264 video format)\n• None When I do , I see many acronyms for the codecs supported, I see many acronyms before the codec name/type such as - D V D S E A, what do they stand for?\n• None How to use the ffmpeg options and ?"
    },
    {
        "link": "https://shotstack.io/learn/how-to-use-ffmpeg",
        "document": "Have you ever had a video file that you needed to modify or optimise? You might have a video that is taking up too much space on your hard drive, or you just need to trim a small section from a long video or reduce the resolution. The go-to tool in these situations is FFmpeg, a software utility used by professionals and home users. In this article, we'll explain what FFmpeg is, how to install it, and look at some of the most common and useful commands using FFmpeg.\n\nFFmpeg is a free and open-source video and audio processing tool that you run from the command-line.\n\nFFmpeg is the tool of choice choice for multiple reasons:\n• Open-source: It has an active and dedicated open-source community continually deploying fixes, improvements, and new features.\n• Platform compatibility: FFmpeg is available for Windows, Mac, and Linux.\n• Command-line interface: It is a lightweight solution offering a vast array of options through a command-line interface.\n\nSome operating systems, such as Ubuntu, install FFmpeg by default, so you might already have it on your computer.\n\nCheck if it's installed with the following command:\n\nIf it gives you a version number and build information, you already have it installed.\n\nIf not, or you are using Windows or a Mac then you will need to download a static or compiled binary executable from a third party vendor. Unfortunately FFmpeg only provide the source code and not the ready to run software.\n\nHere are the key steps you'll need to follow:\n• Under Get packages & executable files, select your operating system to display a list of vendors.\n• Visit the most suitable vendor and follow the instructions on their web site. Typically you will either need to run a set of commands or you will need to download a zipped file (.zip, .7z, .tar.gz, etc.) containing the FFmpeg executable.\n• If downloading, extract the contents of the zipped file to your chosen location. If you browse the extracted files you should find a file called ffmpeg or ffmpeg.exe in a bin folder.\n\nTo run FFmpeg you will need to use the command-line; open a new terminal and navigate to the directory where you extracted the ffmpeg file, then type and run the following command again:\n\nIf installed correctly, you should see an output similar to below:\n\nOne last step to make FFMpeg more useful and available from any folder is to add it to your system PATH. This is different for each operating system, but typically involves adding the directory where the ffmpeg executable is located to the PATH environment variable.\n\nNow that FFmpeg is successfully installed, let's look at how to use FFmpeg, with examples!\n\nLet's look at some of the most common and useful commands in FFmpeg.\n\nYou will need a sample video file to test the commands with. You can use any video file you have on your computer, or you can download this test file, which is names scott-ko.mp4.\n\nOne of the simplest and easiest commands to get started with is converting one video format to another. This is a common task when you need to make a video compatible with a specific device, player or platform.\n\nA basic command to convert a video from one format to another, using our scott-ko.mp4 sample file is:\n\nThis simple command will convert the video from the MP4 format to WEBM. FFmpeg is smart enough to know that the video and audio codec should be converted to be compatible with the new file type. For example, from h264 (MP4) to vp9 (WEBM) for video and aac (MP4) to opus (WEBM) for audio.\n\nIt is also possible to convert from one video format to another and have full control over the encoding options. The command to do that uses the following template:\n\nHere are the options and the placeholders you can replace with your own values:\n• : Replace input.mp4 with the path to your input video file.\n• : Specify the video codec for the output. Replace video_codec with the desired video codec (e.g., libx265 for H.265).\n• : Specify the audio codec for the output. Replace audio_codec with the desired audio codec (e.g., aac for AAC audio).\n• : Replace this with the desired output file name and extension (e.g., output.mp4).\n\nHere's an example of converting an MP4 video to an MKV video using H.264 codec for video and AAC codec for audio:\n\nIf you have a long video and want to extract a small portion, you can trim the video using FFmpeg. You use the (start time) and (duration) options.\n\nUse the following options and replace the placeholders with your specific values:\n• : Replace start_time with the start time to trim from. You can use various time formats like HH:MM:SS or seconds. For example, if you want to start trimming from 1 minute and 30 seconds, you can use or drop the hour and use .\n• : Specify the duration of the trim. Again, you can use various time formats. For example, if you want to trim 20 seconds, you can use .\n• : This option copies the video and audio codecs without re-encoding, which is faster and preserves the original quality. If you need to re-encode, you can specify different codecs or omit this option.\n\nHere's an example command trimming a video from 1 minute and 30 seconds to 20 seconds:\n\nFor more information and examples, see how to trim a video using FFmpeg.\n\nIn the age of smartphones and social networks, cropping videos to different sizes and aspect rations has become an essential requirement when working with video. To crop a video using FFmpeg, use the filter.\n\nThe options and placeholders are described below:\n• : Replace this with the name of your filename or the path to your input video.\n• Use the crop video filter and specify the cropping parameters w (width), h (height), x (cropping x coordinate), and y (cropping y coordinate) according to your requirements.\n• : Replace this with the desired filename or path for the output video.\n\nHere's an example command cropping a video to a width of 640 pixels, a height of 640 pixels, and starting the crop from coordinates 900 pixels across and 50 pixels down:\n\nIf you run this command using the provided test file, you'll see it is creates a square video cropped to the speakers face.\n\nFor more information and examples, see how to crop and resize videos using FFmpeg.\n\nExtract or remove the audio from a video using FFmpeg\n\nThere are two common scenarios where you might want to work with a videos audio - extracting the audio so there is no video, or removing the audio from a video so it is silent, or muted.\n\nTo extract and save the audio from a video file using FFmpeg, use this command template:\n\nThe following options are used and you can replace the following placeholders with your own preferences:\n• : Replace this with the path to your input video file.\n• : Replace this with the desired output audio file name and extension. In this example, the output is saved as an MP3 file.\n\nHere is an example command using our test file:\n\nTo remove audio (or mute) a video file using FFmpeg, you can use the -an option, which disables audio processing. Here's an example command:\n\nHere is an explanation of the options used:\n• : This option copies the video stream without re-encoding, which is faster and preserves the original video quality. If you want to re-encode the video, you can specify a different video codec.\n\nHere is an example using the test file:\n\nConcatenating videos is the technical term FFmpeg uses to describe joining, merging or stitching multiple video clips together. To concatenate (or join) multiple video files together in FFmpeg, you can use the concat demuxer.\n\nFirst, create a text file containing the list of video files you want to concatenate. Each line should contain the file path of a video file.\n\nFor example, create a file named filelist.txt and include a list of video files on your hard drive:\n\nThen, use the following FFmpeg command to concatenate the videos:\n\nHere is a summary of the options used:\n• : This specifies the format (concat) to be used.\n• : This allows using absolute paths in the file list.\n• : This copies the streams (video, audio) without re-encoding, preserving the original quality. If you need to re-encode, you can specify different codecs or omit this option.\n• : Replace this with the desired output file name and extension.\n\nAdjust the file paths in filelist.txt according to your specific file names and paths. The order in which you list the files in the text file determines the order of concatenation.\n\nFor more information and examples, see merge videos using FFmpeg concat.\n\nYou might need to resize a video if the resolution is very high, for example - you have a 4K video but you player only supports 1080p. To resize a video using FFmpeg, you can use the scale filter set using the (video filter) option.\n\nReplace the placeholders with your specific values:\n• : Replace this with the path to your input video file.\n• : Replace w and h with the desired width and height of the output video. You can also set a single dimension, such as to maintain the original aspect ratio.\n• : Replace this with the desired output video file name and extension.\n\nHere's an example command resizing our test video to 720p resolution and maintaining the aspect ratio:\n\nFor more information and examples, see how to crop and resize videos using FFmpeg.\n\nVideo files are typically large and can take up a lot of space on your hard drive, cloud storage or take a long time to download. To compress a video using FFmpeg, you typically need to re-encode it using a more efficient video codec or by adjusting other encoding parameters.\n\nThere are many different ways to do this but here's an example template to get you started:\n\nHere's the options and placeholders you can replace:\n• : Replace this with the path to your input video file.\n• : This option sets the video codec to H.264 (libx264). H.264 is a widely used and efficient video codec.\n• : This controls the video quality. A lower CRF (constant rate factor) value results in higher quality but larger file size. Typical values range from 18 to 28, with 23 being a reasonable default.\n• : These options set the audio codec to AAC with a bitrate of 128 kbps. Adjust the bitrate according to your preferences.\n• : Replace this with the desired output file name and extension.\n\nFor more information and examples, see how to compress video using FFmpeg.\n\nUsing our test file, we can compress the video from 31.9MB to 6.99MB using this command:\n\nConvert a series of images to a video using FFmpeg\n\nWho doesn't love a video montage? With FFmpeg it's easy to create a video from a series of images, simply use wildcard input glob pattern along with the option.\n\nReplace the placeholders with your specific values:\n• : This sets the frame rate of the output video. Adjust the value according to your preference (e.g., 1 picture per second). Omitting the framerate will default to a framerate of 25.\n• : This specifies the input images using a glob pattern. Adjust the pattern and path to the location of your image files.\n• : These options specify the video codec (libx264) and pixel format. Adjust these options based on your preferences and compatibility requirements.\n• : Replace this with the desired output file name and extension.\n\nFor more information and examples, see How to use FFmpeg to convert images to video.\n\nGIFs are a popular animation format used for memes in messaging applications like WhatsApp or Facebook Messenger and a great way to send animations in emails among other use cases. There are a number of ways to convert and optimise a video to a GIF using FFmpeg, but here is a simple command template to get started with:\n\nHere's a breakdown of the options used and what to replace:\n• : Replace this with the path to your input video file.\n• : This sets the video filters for the GIF conversion. The option sets the frames per second (adjust the value as needed), and specifies the output dimensions. The part is for quality optimization.\n• : This specifies the video codec for the output, in this case, GIF.\n• : Replace this with the desired output file name and extension.\n\nHere is an example using the test file:\n\nFor more information and examples, see how to convert video to animated GIF using FFmpeg.\n\nSpeed up and slow down videos using FFmpeg\n\nTo speed up or slow down a video in FFmpeg, you can use the setpts filter. The filter adjusts the presentation timestamp of video frames, effectively changing the speed of the video. Here are examples of both speeding up and slowing down a video.\n\nTo double the speed of a video, use a value of 0.5:\n\nTo slow down a video by a factor (e.g., 2x slower), you can use a setpts value greater than 1:\n\nThese commands adjust the video speed by manipulating the presentation timestamps (PTS). The values 0.5 and 2.0 in the examples represent the speed factor. You can experiment with different speed factors to achieve the desired result.\n\nHere is an example command that doubles the speed of our test file:\n\nNote that only the video is sped up, but not the audio.\n\nGo forth and explore\n\nThis guide provides a quick primer on how to get started and use FFmpeg for various video processing tasks, along with some simple examples. The number of options and possibilities with FFmpeg is vast, and it's worth exploring the FFmpeg documentation and FFmpeg wiki to learn more about the tool and its capabilities.\n\nFFmpeg's major strength is its versatility. However, it has a steep learning curve, with cryptic commands and an intimidating array of options. If you want to run FFmpeg commercially as part of a workflow, pipeline or application you'll also need to consider hosting the software, managing updates and security, and scaling the infrastructure to meet demand.\n\nShotstack was created to streamline automated video editing and video processing without having to learn complicated commands or worry about scaling infrastructure. Shotstack is an FFmpeg alternative offered as a collection of API's and SDK's that allow you to programmatically create, edit and render videos in the cloud. It's a great way to get started with video processing without having to worry about the complexities of FFmpeg."
    },
    {
        "link": "https://ffmpeg.org/ffmpeg-codecs.html",
        "document": "This document describes the codecs (decoders and encoders) provided by the libavcodec library.\n\nlibavcodec provides some generic global options, which can be set on all the encoders and decoders. In addition, each codec may support so-called private options, which are specific for a given codec.\n\nSometimes, a global option may only affect a specific kind of codec, and may be nonsensical or ignored by another, so you need to be aware of the meaning of the specified options. Also some options are meant only for decoding or encoding.\n\nOptions may be set by specifying - in the FFmpeg tools, or by setting the value explicitly in the options or using the API for programmatic use.\n\nDecoders are configured elements in FFmpeg which allow the decoding of multimedia streams.\n\nWhen you configure your FFmpeg build, all the supported native decoders are enabled by default. Decoders requiring an external library must be enabled manually via the corresponding option. You can list all available decoders using the configure option .\n\nYou can disable all the decoders with the configure option and selectively enable / disable single decoders with the options / .\n\nThe option of the ff* tools will display the list of enabled decoders.\n\nA description of some of the currently available video decoders follows.\n\nThe decoder supports MV-HEVC multiview streams with at most two views. Views to be output are selected by supplying a list of view IDs to the decoder (the option). This option may be set either statically before decoder init, or from the callback - useful for the case when the view count or IDs change dynamically during decoding.\n\nOnly the base layer is decoded by default.\n\nNote that if you are using the CLI tool, you should be using view specifiers as documented in its manual, rather than the options documented here.\n\nlibdav1d allows libavcodec to decode the AOMedia Video 1 (AV1) codec. Requires the presence of the libdav1d headers and library during configuration. You need to explicitly configure the build with .\n\nThe following options are supported by the libdav1d wrapper.\n\nThis decoder allows libavcodec to decode AVS2 streams with davs2 library.\n\nlibuavs3d allows libavcodec to decode AVS3 streams. Requires the presence of the libuavs3d headers and library during configuration. You need to explicitly configure the build with .\n\nThe following option is supported by the libuavs3d wrapper.\n\nThis decoder requires the presence of the libxevd headers and library during configuration. You need to explicitly configure the build with .\n\nThe xevd project website is at https://github.com/mpeg5/xevd.\n\nThe following options are supported by the libxevd wrapper. The xevd-equivalent options or values are listed in parentheses for easy migration.\n\nTo get a more accurate and extensive documentation of the libxevd options, invoke the command or consult the libxevd documentation.\n\nThe following options are supported by all qsv decoders.\n\nA description of some of the currently available audio decoders follows.\n\nThis decoder implements part of ATSC A/52:2010 and ETSI TS 102 366, as well as the undocumented RealAudio 3 (a.k.a. dnet).\n\nThis decoder aims to implement the complete FLAC specification from Xiph.\n\nThis decoder generates wave patterns according to predefined sequences. Its use is purely internal and the format of the data it accepts is not publicly documented.\n\nlibcelt allows libavcodec to decode the Xiph CELT ultra-low delay audio codec. Requires the presence of the libcelt headers and library during configuration. You need to explicitly configure the build with .\n\nlibgsm allows libavcodec to decode the GSM full rate audio codec. Requires the presence of the libgsm headers and library during configuration. You need to explicitly configure the build with .\n\nThis decoder supports both the ordinary GSM and the Microsoft variant.\n\nlibilbc allows libavcodec to decode the Internet Low Bitrate Codec (iLBC) audio codec. Requires the presence of the libilbc headers and library during configuration. You need to explicitly configure the build with .\n\nThe following option is supported by the libilbc wrapper.\n\nlibopencore-amrnb allows libavcodec to decode the Adaptive Multi-Rate Narrowband audio codec. Using it requires the presence of the libopencore-amrnb headers and library during configuration. You need to explicitly configure the build with .\n\nAn FFmpeg native decoder for AMR-NB exists, so users can decode AMR-NB without this library.\n\nlibopencore-amrwb allows libavcodec to decode the Adaptive Multi-Rate Wideband audio codec. Using it requires the presence of the libopencore-amrwb headers and library during configuration. You need to explicitly configure the build with .\n\nAn FFmpeg native decoder for AMR-WB exists, so users can decode AMR-WB without this library.\n\nlibopus allows libavcodec to decode the Opus Interactive Audio Codec. Requires the presence of the libopus headers and library during configuration. You need to explicitly configure the build with .\n\nAn FFmpeg native decoder for Opus exists, so users can decode Opus without this library.\n\nImplements profiles A and C of the ARIB STD-B24 standard.\n\nYet another ARIB STD-B24 caption decoder using external libaribcaption library.\n\nImplements profiles A and C of the Japanse ARIB STD-B24 standard, Brazilian ABNT NBR 15606-1, and Philippines version of ISDB-T.\n\nRequires the presence of the libaribcaption headers and library (https://github.com/xqq/libaribcaption) during configuration. You need to explicitly configure the build with . If both libaribb24 and libaribcaption are enabled, libaribcaption decoder precedes.\n\nThis codec decodes the bitmap subtitles used in DVDs; the same subtitles can also be found in VobSub file pairs and in some Matroska files.\n\nLibzvbi allows libavcodec to decode DVB teletext pages and DVB teletext subtitles. Requires the presence of the libzvbi headers and library during configuration. You need to explicitly configure the build with .\n\nEncoders are configured elements in FFmpeg which allow the encoding of multimedia streams.\n\nWhen you configure your FFmpeg build, all the supported native encoders are enabled by default. Encoders requiring an external library must be enabled manually via the corresponding option. You can list all available encoders using the configure option .\n\nYou can disable all the encoders with the configure option and selectively enable / disable single encoders with the options / .\n\nThe option of the ff* tools will display the list of enabled encoders.\n\nA description of some of the currently available audio encoders follows.\n\nThis encoder is the default AAC encoder, natively implemented into FFmpeg.\n\nThese encoders implement part of ATSC A/52:2010 and ETSI TS 102 366.\n\nThe encoder uses floating-point math, while the encoder only uses fixed-point integer math. This does not mean that one is always faster, just that one or the other may be better suited to a particular system. The encoder is not the default codec for any of the output formats, so it must be specified explicitly using the option in order to use it.\n\nThe AC-3 metadata options are used to set parameters that describe the audio, but in most cases do not affect the audio encoding itself. Some of the options do directly affect or influence the decoding and playback of the resulting bitstream, while others are just for informational purposes. A few of the options will add bits to the output stream that could otherwise be used for audio data, and will thus affect the quality of the output. Those will be indicated accordingly with a note in the option list below.\n\nThese parameters are described in detail in several publicly-available documents.\n• A/54 - Guide to the Use of the ATSC Digital Television Standard\n\nAudio Production Information is optional information describing the mixing environment. Either none or both of the fields are written to the bitstream.\n\nThe extended bitstream options are part of the Alternate Bit Stream Syntax as specified in Annex D of the A/52:2010 standard. It is grouped into 2 parts. If any one parameter in a group is specified, all values in that group will be written to the bitstream. Default values are used for those that are written but have not been specified. If the mixing levels are written, the decoder will use these values instead of the ones specified in the and options if it supports the Alternate Bit Stream Syntax.\n\nThese options are only valid for the floating-point encoder and do not exist for the fixed-point encoder due to the corresponding features not being implemented in fixed-point.\n\nThe following options are supported by FFmpeg’s FFv1 encoder.\n\nThe following options are supported by FFmpeg’s flac encoder.\n\nThis is a native FFmpeg encoder for the Opus format. Currently, it’s in development and only implements the CELT part of the codec. Its quality is usually worse and at best is equal to the libopus encoder.\n\nThe libfdk-aac library is based on the Fraunhofer FDK AAC code from the Android project.\n\nRequires the presence of the libfdk-aac headers and library during configuration. You need to explicitly configure the build with . The library is also incompatible with GPL, so if you allow the use of GPL, you should configure with .\n\nThis encoder has support for the AAC-HE profiles.\n\nVBR encoding, enabled through the or options, is experimental and only works with some combinations of parameters.\n\nSupport for encoding 7.1 audio is only available with libfdk-aac 0.1.3 or higher.\n\nFor more information see the fdk-aac project at http://sourceforge.net/p/opencore-amr/fdk-aac/.\n\nThe following options are mapped on the shared FFmpeg codec options.\n\nThe following are private options of the libfdk_aac encoder.\n• Use to convert an audio file to VBR AAC in an M4A (MP4) container:\n• Use to convert an audio file to CBR 64k kbps AAC, using the High-Efficiency AAC profile:\n\nRequires the presence of the liblc3 headers and library during configuration. You need to explicitly configure the build with .\n\nThis encoder has support for the Bluetooth SIG LC3 codec for the LE Audio protocol, and the following features of LC3plus:\n\nFor more information see the liblc3 project at https://github.com/google/liblc3.\n\nThe following options are mapped on the shared FFmpeg codec options.\n\nRequires the presence of the libmp3lame headers and library during configuration. You need to explicitly configure the build with .\n\nSee libshine for a fixed-point MP3 encoder, although with a lower quality.\n\nThe following options are supported by the libmp3lame wrapper. The -equivalent of the options are listed in parentheses.\n\nRequires the presence of the libopencore-amrnb headers and library during configuration. You need to explicitly configure the build with .\n\nThis is a mono-only encoder. Officially it only supports 8000Hz sample rate, but you can override it by setting to ‘ ’ or lower.\n\nRequires the presence of the libopus headers and library during configuration. You need to explicitly configure the build with .\n\nMost libopus options are modelled after the utility from opus-tools. The following is an option mapping chart describing options supported by the libopus wrapper, and their -equivalent in parentheses.\n\nShine is a fixed-point MP3 encoder. It has a far better performance on platforms without an FPU, e.g. armel CPUs, and some phones and tablets. However, as it is more targeted on performance than quality, it is not on par with LAME and other production-grade encoders quality-wise. Also, according to the project’s homepage, this encoder may not be free of bugs as the code was written a long time ago and the project was dead for at least 5 years.\n\nThis encoder only supports stereo and mono input. This is also CBR-only.\n\nThe original project (last updated in early 2007) is at http://sourceforge.net/projects/libshine-fxp/. We only support the updated fork by the Savonet/Liquidsoap project at https://github.com/savonet/shine.\n\nRequires the presence of the libshine headers and library during configuration. You need to explicitly configure the build with .\n\nThe following options are supported by the libshine wrapper. The -equivalent of the options are listed in parentheses.\n\nRequires the presence of the libtwolame headers and library during configuration. You need to explicitly configure the build with .\n\nThe following options are supported by the libtwolame wrapper. The -equivalent options follow the FFmpeg ones and are in parentheses.\n\nRequires the presence of the libvo-amrwbenc headers and library during configuration. You need to explicitly configure the build with .\n\nThis is a mono-only encoder. Officially it only supports 16000Hz sample rate, but you can override it by setting to ‘ ’ or lower.\n\nRequires the presence of the libvorbisenc headers and library during configuration. You need to explicitly configure the build with .\n\nThe following options are supported by the libvorbis wrapper. The -equivalent of the options are listed in parentheses.\n\nTo get a more accurate and extensive documentation of the libvorbis options, consult the libvorbisenc’s and ’s documentations. See http://xiph.org/vorbis/, http://wiki.xiph.org/Vorbis-tools, and oggenc(1).\n\nThe equivalent options for command line utility are listed in parentheses.\n\nThe following shared options are effective for this encoder. Only special notes about this particular encoder will be documented here. For the general meaning of the options, see the Codec Options chapter.\n\nA description of some of the currently available video encoders follows.\n\nThe native jpeg 2000 encoder is lossy by default, the option can be used to set the encoding quality. Lossless encoding can be selected with .\n\nRequires the presence of the rav1e headers and library during configuration. You need to explicitly configure the build with .\n\nRequires the presence of the libaom headers and library during configuration. You need to explicitly configure the build with .\n\nThe wrapper supports the following standard libavcodec options:\n\nThe wrapper also has some specific options:\n\nRequires the presence of the SVT-AV1 headers and library during configuration. You need to explicitly configure the build with .\n\nRequires the presence of the libjxl headers and library during configuration. You need to explicitly configure the build with .\n\nThe libjxl wrapper supports the following options:\n\nRequires the presence of the libkvazaar headers and library during configuration. You need to explicitly configure the build with .\n\nThis encoder requires the presence of the libopenh264 headers and library during configuration. You need to explicitly configure the build with . The library is detected using .\n\nFor more information about the library see http://www.openh264.org.\n\nThe following FFmpeg global options affect the configurations of the libopenh264 encoder.\n\nRequires the presence of the libtheora headers and library during configuration. You need to explicitly configure the build with .\n\nFor more information about the libtheora project see http://www.theora.org/.\n\nThe following global options are mapped to internal libtheora options which affect the quality and the bitrate of the encoded stream.\n\nRequires the presence of the libvpx headers and library during configuration. You need to explicitly configure the build with .\n\nThe following options are supported by the libvpx wrapper. The -equivalent options or values are listed in parentheses for easy migration.\n\nTo reduce the duplication of documentation, only the private options and some others requiring special attention are documented here. For the documentation of the undocumented generic options, see the Codec Options chapter.\n\nTo get more documentation of the libvpx options, invoke the command , or . Further information is available in the libvpx API documentation.\n\nFor more information about libvpx see: http://www.webmproject.org/\n\nThis encoder requires the presence of the libvvenc headers and library during configuration. You need to explicitly configure the build with .\n\nThe VVenC project website is at https://github.com/fraunhoferhhi/vvenc.\n\nVVenC supports only 10-bit color spaces as input. But the internal (encoded) bit depth can be set to 8-bit or 10-bit at runtime.\n\nlibwebp is Google’s official encoder for WebP images. It can encode in either lossy or lossless mode. Lossy images are essentially a wrapper around a VP8 frame. Lossless images are a separate codec developed by Google.\n\nCurrently, libwebp only supports YUV420 for lossy and RGB for lossless due to limitations of the format and libwebp. Alpha is supported for either mode. Because of API limitations, if RGB is passed in when encoding lossy or YUV is passed in for encoding lossless, the pixel format will automatically be converted using functions from libwebp. This is not ideal and is done only for convenience.\n\nThis encoder requires the presence of the libx264 headers and library during configuration. You need to explicitly configure the build with .\n\nlibx264 supports an impressive number of features, including 8x8 and 4x4 adaptive spatial transform, adaptive B-frame placement, CAVLC/CABAC entropy coding, interlacing (MBAFF), lossless mode, psy optimizations for detail retention (adaptive quantization, psy-RD, psy-trellis).\n\nMany libx264 encoder options are mapped to FFmpeg global codec options, while unique encoder options are provided through private options. Additionally the and private options allows one to pass a list of key=value tuples as accepted by the libx264 function.\n\nThe x264 project website is at http://www.videolan.org/developers/x264.html.\n\nThe libx264rgb encoder is the same as libx264, except it accepts packed RGB pixel formats as input instead of YUV.\n\nx264 supports 8- to 10-bit color spaces. The exact bit depth is controlled at x264’s configure time.\n\nThe following options are supported by the libx264 wrapper. The -equivalent options or values are listed in parentheses for easy migration.\n\nTo reduce the duplication of documentation, only the private options and some others requiring special attention are documented here. For the documentation of the undocumented generic options, see the Codec Options chapter.\n\nTo get a more accurate and extensive documentation of the libx264 options, invoke the command or consult the libx264 documentation.\n\nIn the list below, note that the option name is shown in parentheses after the libavcodec corresponding name, in case there is a direct mapping.\n\nEncoding ffpresets for common usages are provided so they can be used with the general presets system (e.g. passing the option).\n\nThis encoder requires the presence of the libx265 headers and library during configuration. You need to explicitly configure the build with .\n\nThis encoder requires the presence of the libxavs2 headers and library during configuration. You need to explicitly configure the build with .\n\nThe following standard libavcodec options are used:\n\nThe encoder also has its own specific options:\n\neXtra-fast Essential Video Encoder (XEVE) MPEG-5 EVC encoder wrapper. The xeve-equivalent options or values are listed in parentheses for easy migration.\n\nThis encoder requires the presence of the libxeve headers and library during configuration. You need to explicitly configure the build with .\n\nThe xeve project website is at https://github.com/mpeg5/xeve.\n\nThe following options are supported by the libxeve wrapper. The xeve-equivalent options or values are listed in parentheses for easy migration.\n\nThis encoder requires the presence of the libxvidcore headers and library during configuration. You need to explicitly configure the build with .\n\nThe native encoder supports the MPEG-4 Part 2 format, so users can encode to this format without this library.\n\nThe following options are supported by the libxvid wrapper. Some of the following options are listed but are not documented, and correspond to shared codec options. See the Codec Options chapter for their documentation. The other shared options which are not listed have no effect for the libxvid encoder.\n\nThis provides wrappers to encoders (both audio and video) in the MediaFoundation framework. It can access both SW and HW encoders. Video encoders can take input in either of nv12 or yuv420p form (some encoders support both, some support only either - in practice, nv12 is the safer choice, especially among HW encoders).\n\nMicrosoft RLE aka MSRLE encoder. Only 8-bit palette mode supported. Compatible with Windows 3.1 and Windows 95.\n\nFFmpeg contains 2 ProRes encoders, the prores-aw and prores-ks encoder. The used encoder can be chosen with the option.\n\nIn the default mode of operation the encoder has to honor frame constraints (i.e. not produce frames with size bigger than requested) while still making output picture as good as possible. A frame containing a lot of small details is harder to compress and the encoder would spend more time searching for appropriate quantizers for each slice.\n\nFor the fastest encoding speed set the parameter (4 is the recommended value) and do not set a size constraint.\n\nThe ratecontrol method is selected as follows:\n• When is specified, a quality-based mode is used. Specifically this means either\n• - - constant quantizer scale, when the codec flag is also set (the ffmpeg option).\n• - - intelligent constant quality with lookahead, when the option is also set.\n• - – intelligent constant quality otherwise. For the ICQ modes, global quality range is 1 to 51, with 1 being the best quality.\n• Otherwise when the desired average bitrate is specified with the option, a bitrate-based mode is used.\n• - - VBR with lookahead, when the option is specified.\n• - - video conferencing mode, when the option is set.\n• - - constant bitrate, when is specified and equal to the average bitrate.\n• - - variable bitrate, when is specified, but is higher than the average bitrate.\n• - - average VBR mode, when is not specified, both and are set to non-zero. This mode is available for H264 and HEVC on Windows.\n• Otherwise the default ratecontrol method is used.\n\nNote that depending on your system, a different mode than the one you specified may be selected by the encoder. Set the verbosity level to or higher to see the actual settings used by the QSV runtime.\n\nAdditional libavcodec global options are mapped to MSDK options as follows:\n• For the mode, the and set the difference between and , and and respectively.\n• Setting the option to the value will make the H.264 encoder use CAVLC instead of CABAC.\n\nFollowing options are used by all qsv encoders.\n\nFollowing options can be used durning qsv encoding.\n\nThese options are used by h264_qsv\n\nThese options are used by hevc_qsv\n\nThese options are used by mpeg2_qsv\n\nThese options are used by vp9_qsv\n\nThese options are used by av1_qsv (requires libvpl).\n\nThese encoders only accept input in VAAPI hardware surfaces. If you have input in software frames, use the filter to upload them to the GPU.\n\nThe following standard libavcodec options are used:\n• If not set, this will be determined automatically from the format of the input frames and the profiles supported by the driver.\n\nAll encoders support the following options:\n\nEach encoder also has its own specific options:\n\nThis format is used by the broadcast vendor Vizrt for quick texture streaming. Advanced features of the format such as LZW compression of texture data or generation of mipmaps are not supported.\n\nSMPTE VC-2 (previously BBC Dirac Pro). This codec was primarily aimed at professional broadcasting but since it supports yuv420, yuv422 and yuv444 at 8 (limited range or full range), 10 or 12 bits, this makes it suitable for other tasks which require low overhead and low compression (like screen recording).\n\nThis codec encodes the bitmap subtitle format that is used in DVDs. Typically they are stored in VOBSUB file pairs (*.idx + *.sub), and they can also be used in Matroska files.\n\nFor details about the authorship, see the Git history of the project (https://git.ffmpeg.org/ffmpeg), e.g. by typing the command in the FFmpeg source directory, or browsing the online repository at https://git.ffmpeg.org/ffmpeg.\n\nMaintainers for the specific components are listed in the file in the source code tree.\n\nThis document was generated on March 22, 2025 using makeinfo."
    },
    {
        "link": "https://trac.ffmpeg.org/wiki/Encode/H.264",
        "document": "This guide focuses on the encoder x264. It assumes you have compiled with . If you need help compiling and installing see one of our compiling guides. See HWAccelIntro for information on supported hardware H.264 encoders.\n\nThere are two rate control modes that are usually suggested for general use: Constant Rate Factor (CRF) or Two-Pass ABR. Rate control decides how many bits will be used for each frame. This will determine the file size and also how quality is distributed. To know more about what the different rate control modes do see ​this post.\n\nUse this rate control mode if you want to keep the best quality and care less about the file size. This is the recommended rate control mode for most uses.\n\nThis method allows the encoder to attempt to achieve a certain output quality for the whole file when output file size is of less importance. This provides maximum compression efficiency with a single pass. By adjusting the so-called quantizer for each frame, it gets the bitrate it needs to keep the requested quality level. The downside is that you can't tell it to get a specific filesize or not go over a specific size or bitrate, which means that this method is not recommended for encoding videos for streaming.\n\nThe range of the CRF scale is 0–51, where 0 is lossless (for 8 bit only, for 10 bit use -qp 0), 23 is the default, and 51 is worst quality possible. A lower value generally leads to higher quality, and a subjectively sane range is 17–28. Consider 17 or 18 to be visually lossless or nearly so; it should look the same or nearly the same as the input but it isn't technically lossless.\n\nThe range is exponential, so increasing the CRF value +6 results in roughly half the bitrate / file size, while -6 leads to roughly twice the bitrate.\n\nChoose the highest CRF value that still provides an acceptable quality. If the output looks good, then try a higher value. If it looks bad, choose a lower value.\n\nA preset is a collection of options that will provide a certain encoding speed to compression ratio. A slower preset will provide better compression (compression is quality per filesize). This means that, for example, if you target a certain file size or constant bit rate, you will achieve better quality with a slower preset. Similarly, for constant quality encoding, you will simply save bitrate by choosing a slower preset.\n\nUse the slowest preset that you have patience for. The available presets in descending order of speed are:\n• – ignore this as it is not useful (see FAQ)\n\nYou can see a list of current presets with (see example below). If you have the binary installed, you can also see the exact settings these presets apply by running .\n\nYou can optionally use to change settings based upon the specifics of your input. Current tunings include:\n• – good for cartoons; uses higher deblocking and more reference frames\n• – preserves the grain structure in old, grainy film material\n• – allows faster decoding by disabling certain filters\n• – ignore this as it is only used for codec development\n• – ignore this as it is only used for codec development\n\nFor example, if your input is animation then use the tuning, or if you want to preserve grain in a film then use the tuning. If you are unsure of what to use or your input does not match any of tunings then omit the option. You can see a list of current tunings with , and what settings they apply with .\n\nThe option limits the output to a specific H.264 profile. You usually do not need to use this option and the recommendation is to omit setting the profile which will allow x264 to automatically select the appropriate profile.\n\nSome devices (mostly very old or obsolete) only support the more limited Constrained Baseline or Main profiles. You can set these profiles with or . Most modern devices support the more advanced High profile.\n\nAnother reason to use this option is to match other video profiles if you want to concatenate them with the concat demuxer.\n\nNote that usage of is incompatible with lossless encoding and setting -profile:v high444 does not work.\n\nTo list all possible internal presets and tunes:\n\nThis command encodes a video with good quality, using slower preset to achieve better compression:\n\nNote that in this example the audio stream of the input file is simply stream copied over to the output and not re-encoded.\n\nIf you are encoding a set of videos that are similar, apply the same settings to all the videos: this will ensure that they will all have similar quality.\n\nUse this rate control mode if you are targeting a specific output file size, and if output quality from frame to frame is of less importance. This is best explained with an example. Your video is 10 minutes (600 seconds) long and an output of 200 MiB is desired. Since :\n\nYou can also forgo the bitrate calculation if you already know what final (average) bitrate you need.\n\nFor two-pass, you need to run twice, with almost the same settings, except for:\n• In pass 1 and 2, use the and options, respectively.\n• In pass 1, output to a null file descriptor, not an actual file. (This will generate a logfile that ffmpeg needs for the second pass.)\n• In pass 1, you may leave audio out by specifying .\n\nAs with CRF, choose the slowest you can tolerate, and optionally apply a setting and .\n\nIf the profile is High 4:4:4 Predictive you can use to create a lossless video, otherwise use -qp 0 (High 10 profile does not support lossless, ​https://code.videolan.org/videolan/x264/-/blob/master/x264.c#L579). Two useful presets for this are or since either a fast encoding speed or best compression are usually the most important factors.\n\nNote that lossless output files will likely be huge, and most non-FFmpeg based players will not be able to decode lossless. Therefore, if compatibility or file size are an issue, you should not use lossless.\n\nWhile chooses the best possible settings for you, you can overwrite these with the option, or by using the libx264 private options (see ). This is not recommended unless you know what you are doing. The presets were created by the x264 developers and tweaking values to get a better output is usually a waste of time.\n\nThere is no native or true CBR mode, but you can \"simulate\" a constant bit rate setting by tuning the parameters of a one-pass average bitrate encode:\n\nIn the above example, is the \"rate control buffer\", so it will enforce your requested \"average\" (1 MBit/s in this case) across each 2 MBit worth of video. Here it is assumed that the receiver / player will buffer that much data, meaning that a fluctuation within that range is acceptable.\n\nCBR encodes are usually inefficient if the video is easy to encode (e.g., empty or black frames).\n\nUse this mode if you want to constrain the maximum bitrate used, or keep the stream's bitrate within certain bounds. This is particularly useful for online streaming, where the client expects a certain average bitrate, but you still want the encoder to adjust the bitrate per-frame.\n\nYou can use or with a maximum bit rate by specifying both and :\n\nThis will effectively \"target\" , but if the output were to exceed 1 MBit/s, the encoder would increase the CRF to prevent bitrate spikes. However, be aware that does not strictly control the maximum bit rate as you specified (the maximum bit rate may be well over 1M for the above file). To reach a perfect maximum bit rate, use two-pass.\n\nIn another example, instead of using constant quality (CRF) as a target, the average bitrate is set. A two-pass approach is preferred here:\n\nEncode a random section instead of the whole video with the and / options to quickly get a general idea of what the output will look like.\n• : Offset time from beginning. Value can be in seconds or HH:MM:SS format.\n• : Duration. Value can be in seconds or HH:MM:SS format.\n• : Stop writing the output at specified position. Value can be in seconds or HH:MM:SS format.\n\nYou can add as an output option if your videos are going to be viewed in a browser. This will move some information to the beginning of your file and allow the video to begin playing before it is completely downloaded by the viewer. It is not required if you are going to use a video service such as YouTube. YouTube ​recommends using faststart, so they can begin re-encoding before uploads complete.\n\nSee also How to check if Fast Start is enabled for playback\n\nRefer to the output option in the documentation.\n\nTo enable OpenCL lookahead add or to your command line. It will give a slight encoding speed boost using GPU, without hurting quality.\n\nYou will see or , also file will be created, which can deleted safely after encoding.\n\nIf you have access to the Nvidia NvEnc hardware (ffmpeg -encoders shows h264_nvenc) then you can use ffmpeg -h encoder=h264_nvenc to see the specific options it provides.\n\nWill two-pass provide a better quality than CRF?\n\n​No, though it does allow you to target a file size more accurately.\n\nWhy is a waste of time?\n\nIt helps at most ~1% in terms of quality, compared to the preset at the cost of a much higher encoding time. It's diminishing returns: helps about 3% compared to the preset, helps about 5% compared to the preset, and helps about 5-10% compared to the preset.\n\nHow do the different presets influence encoding time?\n\nThis depends on the source material, the target bitrate, and your hardware configuration. In general, the higher the bitrate, the more time needed for encoding.\n\nHere is an example that shows the (normalized) encoding time for a two-pass encode of a 1080p video:\n\nGoing from to , the time needed increases by about 40%. Going to instead would result in about 100% more time needed (i.e. it will take twice as long). Compared to , requires 280% of the original encoding time, with only minimal improvements over in terms of quality.\n\nUsing saves about 10% encoding time, 25%. will save 55% at the expense of much lower quality.\n\nWhy doesn't my lossless output look lossless?\n\nIf your input files are RGB, it's the RGB to YUV color space conversion. Use instead.\n\nSee HWAccelIntro for information on supported hardware H.264 encoders and decoders.\n\nYou may need to use (or the alias ) for your output to work in QuickTime and most other players. These players only support the YUV planar color space with 4:2:0 chroma subsampling for H.264 video. Otherwise, depending on your source, may output to a pixel format that may be incompatible with these players."
    },
    {
        "link": "https://ffmpeg.org/ffmpeg.html",
        "document": "is a universal media converter. It can read a wide variety of inputs - including live grabbing/recording devices - filter, and transcode them into a plethora of output formats.\n\nreads from an arbitrary number of inputs (which can be regular files, pipes, network streams, grabbing devices, etc.), specified by the option, and writes to an arbitrary number of outputs, which are specified by a plain output url. Anything found on the command line which cannot be interpreted as an option is considered to be an output url.\n\nEach input or output can, in principle, contain any number of elementary streams of different types (video/audio/subtitle/attachment/data), though the allowed stream counts and/or types may be limited by the container format. Selecting which streams from which inputs will go into which output is either done automatically or with the option (see the Stream selection chapter).\n\nTo refer to inputs/outputs in options, you must use their indices (0-based). E.g. the first input is , the second is , etc. Similarly, streams within an input/output are referred to by their indices. E.g. refers to the fourth stream in the third input or output. Also see the Stream specifiers chapter.\n\nAs a general rule, options are applied to the next specified file. Therefore, order is important, and you can have the same option on the command line multiple times. Each occurrence is then applied to the next input or output file. Exceptions from this rule are the global options (e.g. verbosity level), which should be specified first.\n\nDo not mix input and output files – first specify all input files, then all output files. Also do not mix options which belong to different files. All options apply ONLY to the next input or output file and are reset between files.\n• Convert an input media file to a different format, by re-encoding media streams:\n• Set the video bitrate of the output file to 64 kbit/s:\n• Force the frame rate of the output file to 24 fps:\n• Force the frame rate of the input file (valid for raw formats only) to 1 fps and the frame rate of the output file to 24 fps:\n\nThe format option may be needed for raw input files.\n\nbuilds a transcoding pipeline out of the components listed below. The program’s operation then consists of input data chunks flowing from the sources down the pipes towards the sinks, while being transformed by the components they encounter along the way.\n\nThe following kinds of components are available:\n• Demuxers (short for \"demultiplexers\") read an input source in order to extract\n• global properties such as metadata or chapters;\n• list of input elementary streams and their properties One demuxer instance is created for each option, and sends encoded packets to decoders or muxers. In other literature, demuxers are sometimes called splitters, because their main function is splitting a file into elementary streams (though some files only contain one elementary stream). A schematic representation of a demuxer looks like this: ┌──────────┬───────────────────────┐ │ demuxer │ │ packets for stream 0 ╞══════════╡ elementary stream 0 ├──────────────────────► │ │ │ │ global ├───────────────────────┤ │properties│ │ packets for stream 1 │ and │ elementary stream 1 ├──────────────────────► │ metadata │ │ │ ├───────────────────────┤ │ │ │ │ │ ........... │ │ │ │ │ ├───────────────────────┤ │ │ │ packets for stream N │ │ elementary stream N ├──────────────────────► │ │ │ └──────────┴───────────────────────┘ ▲ │ │ read from file, network stream, │ grabbing device, etc. │\n• Decoders receive encoded (compressed) packets for an audio, video, or subtitle elementary stream, and decode them into raw frames (arrays of pixels for video, PCM for audio). A decoder is typically associated with (and receives its input from) an elementary stream in a demuxer, but sometimes may also exist on its own (see Loopback decoders). A schematic representation of a decoder looks like this:\n• Filtergraphs process and transform raw audio or video frames. A filtergraph consists of one or more individual filters linked into a graph. Filtergraphs come in two flavors - simple and complex, configured with the and options, respectively. A simple filtergraph is associated with an output elementary stream; it receives the input to be filtered from a decoder and sends filtered output to that output stream’s encoder. A simple video filtergraph that performs deinterlacing (using the deinterlacer) followed by resizing (using the filter) can look like this: ┌────────────────────────┐ │ simple filtergraph │ frames from ╞════════════════════════╡ frames for a decoder │ ┌───────┐ ┌───────┐ │ an encoder ────────────►├─►│ yadif ├─►│ scale ├─►│────────────► │ └───────┘ └───────┘ │ └────────────────────────┘ A complex filtergraph is standalone and not associated with any specific stream. It may have multiple (or zero) inputs, potentially of different types (audio or video), each of which receiving data either from a decoder or another complex filtergraph’s output. It also has one or more outputs that feed either an encoder or another complex filtergraph’s input. The following example diagram represents a complex filtergraph with 3 inputs and 2 outputs (all video): Frames from second input are overlaid over those from the first. Frames from the third input are rescaled, then the duplicated into two identical streams. One of them is overlaid over the combined first two inputs, with the result exposed as the filtergraph’s first output. The other duplicate ends up being the filtergraph’s second output.\n• Encoders receive raw audio, video, or subtitle frames and encode them into encoded packets. The encoding (compression) process is typically lossy - it degrades stream quality to make the output smaller; some encoders are lossless, but at the cost of much higher output size. A video or audio encoder receives its input from some filtergraph’s output, subtitle encoders receive input from a decoder (since subtitle filtering is not supported yet). Every encoder is associated with some muxer’s output elementary stream and sends its output to that muxer. A schematic representation of an encoder looks like this:\n• Muxers (short for \"multiplexers\") receive encoded packets for their elementary streams from encoders (the transcoding path) or directly from demuxers (the streamcopy path), interleave them (when there is more than one elementary stream), and write the resulting bytes into the output file (or pipe, network stream, etc.). A schematic representation of a muxer looks like this: ┌──────────────────────┬───────────┐ packets for stream 0 │ │ muxer │ ──────────────────────►│ elementary stream 0 ╞═══════════╡ │ │ │ ├──────────────────────┤ global │ packets for stream 1 │ │properties │ ──────────────────────►│ elementary stream 1 │ and │ │ │ metadata │ ├──────────────────────┤ │ │ │ │ │ ........... │ │ │ │ │ ├──────────────────────┤ │ packets for stream N │ │ │ ──────────────────────►│ elementary stream N │ │ │ │ │ └──────────────────────┴─────┬─────┘ │ write to file, network stream, │ grabbing device, etc. │ │ ▼\n\nThe simplest pipeline in is single-stream streamcopy, that is copying one input elementary stream’s packets without decoding, filtering, or encoding them. As an example, consider an input file called with 3 elementary streams, from which we take the second and write it to file . A schematic representation of such a pipeline looks like this:\n\nThe above pipeline can be constructed with the following commandline:\n• there are no input options for this input;\n• there are two output options for this output:\n• selects the input stream to be used - from input with index 0 (i.e. the first one) the stream with index 1 (i.e. the second one);\n• selects the encoder, i.e. streamcopy with no decoding or encoding.\n\nStreamcopy is useful for changing the elementary stream count, container format, or modifying container-level metadata. Since there is no decoding or encoding, it is very fast and there is no quality loss. However, it might not work in some cases because of a variety of factors (e.g. certain information required by the target container is not available in the source). Applying filters is obviously also impossible, since filters work on decoded frames.\n\nMore complex streamcopy scenarios can be constructed - e.g. combining streams from two input files into a single output:\n\nthat can be built by the commandline\n\nThe output option is used twice here, creating two streams in the output file - one fed by the first input and one by the second. The single instance of the option selects streamcopy for both of those streams. You could also use multiple instances of this option together with Stream specifiers to apply different values to each stream, as will be demonstrated in following sections.\n\nA converse scenario is splitting multiple streams from a single input into multiple outputs:\n\nNote how a separate instance of the option is needed for every output file even though their values are the same. This is because non-global options (which is most of them) only apply in the context of the file before which they are placed.\n\nThese examples can of course be further generalized into arbitrary remappings of any number of inputs into any number of outputs.\n\nTranscoding is the process of decoding a stream and then encoding it again. Since encoding tends to be computationally expensive and in most cases degrades the stream quality (i.e. it is lossy), you should only transcode when you need to and perform streamcopy otherwise. Typical reasons to transcode are:\n• you want to feed the stream to something that cannot decode the original codec.\n\nNote that will transcode all audio, video, and subtitle streams unless you specify for them.\n\nConsider an example pipeline that reads an input file with one audio and one video stream, transcodes the video and copies the audio into a single output file. This can be schematically represented as follows\n\nand implemented with the following commandline:\n\nNote how it uses stream specifiers and to select input streams and apply different values of the option to them; see the Stream specifiers section for more details.\n\nWhen transcoding, audio and video streams can be filtered before encoding, with either a simple or complex filtergraph.\n\nSimple filtergraphs are those that have exactly one input and output, both of the same type (audio or video). They are configured with the per-stream option (with and aliases for (video) and (audio) respectively). Note that simple filtergraphs are tied to their output stream, so e.g. if you have multiple audio streams, will create a separate filtergraph for each one.\n\nTaking the trancoding example from above, adding filtering (and omitting audio, for clarity) makes it look like this:\n\nComplex filtergraphs are those which cannot be described as simply a linear processing chain applied to one stream. This is the case, for example, when the graph has more than one input and/or output, or when output stream type is different from input. Complex filtergraphs are configured with the option. Note that this option is global, since a complex filtergraph, by its nature, cannot be unambiguously associated with a single stream or file. Each instance of creates a new complex filtergraph, and there can be any number of them.\n\nA trivial example of a complex filtergraph is the filter, which has two video inputs and one video output, containing one video overlaid on top of the other. Its audio counterpart is the filter.\n\nWhile decoders are normally associated with demuxer streams, it is also possible to create \"loopback\" decoders that decode the output from some encoder and allow it to be fed back to complex filtergraphs. This is done with the directive, which takes as a parameter the index of the output stream that should be decoded. Every such directive creates a new loopback decoder, indexed with successive integers starting at zero. These indices should then be used to refer to loopback decoders in complex filtergraph link labels, as described in the documentation for .\n\nDecoding AVOptions can be passed to loopback decoders by placing them before , analogously to input/output options.\n\nE.g. the following example:\n• (line 2) encodes it with at low quality;\n• (line 4) places decoded video side by side with the original input video;\n• (line 5) combined video is then losslessly encoded and written into .\n\nSuch a transcoding pipeline can be represented with the following diagram:\n\nprovides the option for manual control of stream selection in each output file. Users can skip and let ffmpeg perform automatic stream selection as described below. The options can be used to skip inclusion of video, audio, subtitle and data streams respectively, whether manually mapped or automatically selected, except for those streams which are outputs of complex filtergraphs.\n\nThe sub-sections that follow describe the various rules that are involved in stream selection. The examples that follow next show how these rules are applied in practice.\n\nWhile every effort is made to accurately reflect the behavior of the program, FFmpeg is under continuous development and the code may have changed since the time of this writing.\n\nIn the absence of any map options for a particular output file, ffmpeg inspects the output format to check which type of streams can be included in it, viz. video, audio and/or subtitles. For each acceptable stream type, ffmpeg will pick one stream, when available, from among all the inputs.\n\nIt will select that stream based upon the following criteria:\n• for video, it is the stream with the highest resolution,\n• for audio, it is the stream with the most channels,\n• for subtitles, it is the first subtitle stream found but there’s a caveat. The output format’s default subtitle encoder can be either text-based or image-based, and only a subtitle stream of the same type will be chosen.\n\nIn the case where several streams of the same type rate equally, the stream with the lowest index is chosen.\n\nData or attachment streams are not automatically selected and can only be included using .\n\nWhen is used, only user-mapped streams are included in that output file, with one possible exception for filtergraph outputs described below.\n\nIf there are any complex filtergraph output streams with unlabeled pads, they will be added to the first output file. This will lead to a fatal error if the stream type is not supported by the output format. In the absence of the map option, the inclusion of these streams leads to the automatic stream selection of their types being skipped. If map options are present, these filtergraph streams are included in addition to the mapped streams.\n\nComplex filtergraph output streams with labeled pads must be mapped once and exactly once.\n\nStream handling is independent of stream selection, with an exception for subtitles described below. Stream handling is set via the option addressed to streams within a specific output file. In particular, codec options are applied by ffmpeg after the stream selection process and thus do not influence the latter. If no option is specified for a stream type, ffmpeg will select the default encoder registered by the output file muxer.\n\nAn exception exists for subtitles. If a subtitle encoder is specified for an output file, the first subtitle stream found of any type, text or image, will be included. ffmpeg does not validate if the specified encoder can convert the selected stream or if the converted stream is acceptable within the output format. This applies generally as well: when the user sets an encoder manually, the stream selection process cannot check if the encoded stream can be muxed into the output file. If it cannot, ffmpeg will abort and all output files will fail to be processed.\n\nThe following examples illustrate the behavior, quirks and limitations of ffmpeg’s stream selection methods.\n\nThey assume the following three input files.\n\nThere are three output files specified, and for the first two, no options are set, so ffmpeg will select streams for these two files automatically.\n\nis a Matroska container file and accepts video, audio and subtitle streams, so ffmpeg will try to select one of each type.\n\n For video, it will select from , which has the highest resolution among all the input video streams.\n\n For audio, it will select from , since it has the greatest number of channels.\n\n For subtitles, it will select from , which is the first subtitle stream from among and .\n\naccepts only audio streams, so only from is selected.\n\nFor , since a option is set, no automatic stream selection will occur. The option will select all audio streams from the second input . No other streams will be included in this output file.\n\nFor the first two outputs, all included streams will be transcoded. The encoders chosen will be the default ones registered by each output format, which may not match the codec of the selected input streams.\n\nFor the third output, codec option for audio streams has been set to , so no decoding-filtering-encoding operations will occur, or can occur. Packets of selected streams shall be conveyed from the input file and muxed within the output file.\n\nAlthough is a Matroska container file which accepts subtitle streams, only a video and audio stream shall be selected. The subtitle stream of is image-based and the default subtitle encoder of the Matroska muxer is text-based, so a transcode operation for the subtitles is expected to fail and hence the stream isn’t selected. However, in , a subtitle encoder is specified in the command and so, the subtitle stream is selected, in addition to the video stream. The presence of disables audio stream selection for .\n\nA filtergraph is setup here using the option and consists of a single video filter. The filter requires exactly two video inputs, but none are specified, so the first two available video streams are used, those of and . The output pad of the filter has no label and so is sent to the first output file . Due to this, automatic selection of the video stream is skipped, which would have selected the stream in . The audio stream with most channels viz. in , is chosen automatically. No subtitle stream is chosen however, since the MP4 format has no default subtitle encoder registered, and the user hasn’t specified a subtitle encoder.\n\nThe 2nd output file, , only accepts text-based subtitle streams. So, even though the first subtitle stream available belongs to , it is image-based and hence skipped. The selected stream, in , is the first text-based subtitle stream.\n\nThe above command will fail, as the output pad labelled has been mapped twice. None of the output files shall be processed.\n\nThis command above will also fail as the hue filter output has a label, , and hasn’t been mapped anywhere.\n\nThe command should be modified as follows,\n\nThe video stream from is sent to the hue filter, whose output is cloned once using the split filter, and both outputs labelled. Then a copy each is mapped to the first and third output files.\n\nThe overlay filter, requiring two video inputs, uses the first two unused video streams. Those are the streams from and . The overlay output isn’t labelled, so it is sent to the first output file , regardless of the presence of the option.\n\nThe aresample filter is sent the first unused audio stream, that of . Since this filter output is also unlabelled, it too is mapped to the first output file. The presence of only suppresses automatic or manual stream selection of audio streams, not outputs sent from filtergraphs. Both these mapped streams shall be ordered before the mapped stream in .\n\nThe video, audio and subtitle streams mapped to are entirely determined by automatic stream selection.\n\nconsists of the cloned video output from the hue filter and the first audio stream from . \n\n\n\nAll the numerical options, if not specified otherwise, accept a string representing a number as input, which may be followed by one of the SI unit prefixes, for example: ’K’, ’M’, or ’G’.\n\nIf ’i’ is appended to the SI unit prefix, the complete prefix will be interpreted as a unit prefix for binary multiples, which are based on powers of 1024 instead of powers of 1000. Appending ’B’ to the SI unit prefix multiplies the value by 8. This allows using, for example: ’KB’, ’MiB’, ’G’ and ’B’ as number suffixes.\n\nOptions which do not take arguments are boolean options, and set the corresponding value to true. They can be set to false by prefixing the option name with \"no\". For example using \"-nofoo\" will set the boolean option with name \"foo\" to false.\n\nOptions that take arguments support a special syntax where the argument given on the command line is interpreted as a path to the file from which the actual argument value is loaded. To use this feature, add a forward slash ’/’ immediately before the option name (after the leading dash). E.g.\n\nwill load a filtergraph description from the file named .\n\nSome options are applied per-stream, e.g. bitrate or codec. Stream specifiers are used to precisely specify which stream(s) a given option belongs to.\n\nA stream specifier is a string generally appended to the option name and separated from it by a colon. E.g. contains the stream specifier, which matches the second audio stream. Therefore, it would select the ac3 codec for the second audio stream.\n\nA stream specifier can match several streams, so that the option is applied to all of them. E.g. the stream specifier in matches all audio streams.\n\nAn empty stream specifier matches all streams. For example, or would copy all the streams without reencoding.\n\nPossible forms of stream specifiers are:\n\nThese options are shared amongst the ff* tools.\n\nThese options are provided directly by the libavformat, libavdevice and libavcodec libraries. To see the list of available AVOptions, use the option. They are separated into two categories:\n\nFor example to write an ID3v2.3 header instead of a default ID3v2.4 to an MP3 file, use the private option of the MP3 muxer:\n\nAll codec AVOptions are per-stream, and thus a stream specifier should be attached to them:\n\nIn the above example, a multichannel audio stream is mapped twice for output. The first instance is encoded with codec ac3 and bitrate 640k. The second instance is downmixed to 2 channels and encoded with codec aac. A bitrate of 128k is specified for it using absolute index of the output stream.\n\nNote: the syntax cannot be used for boolean AVOptions, use / .\n\nNote: the old undocumented way of specifying per-stream AVOptions by prepending v/a/s to the options name is now obsolete and will be removed soon.\n\nForce input or output file format. The format is normally auto detected for input files and guessed from the file extension for output files, so this option is not needed in most cases. Do not overwrite output files, and exit immediately if a specified output file already exists. Set number of times input stream shall be looped. Loop 0 means no loop, loop -1 means infinite loop. Allow forcing a decoder of a different media type than the one detected or designated by the demuxer. Useful for decoding media data muxed as data streams. Select an encoder (when used before an output file) or a decoder (when used before an input file) for one or more streams. is the name of a decoder/encoder or a special value (output only) to indicate that the stream is not to be re-encoded. encodes all video streams with libx264 and copies all audio streams. For each stream, the last matching option is applied, so will copy all the streams except the second video, which will be encoded with libx264, and the 138th audio, which will be encoded with libvorbis. When used as an input option (before ), limit the of data read from the input file. When used as an output option (before an output url), stop writing the output after its duration reaches . must be a time duration specification, see (ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual. -to and -t are mutually exclusive and -t has priority. Stop writing the output or reading the input at . must be a time duration specification, see (ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual. -to and -t are mutually exclusive and -t has priority. Set the file size limit, expressed in bytes. No further chunk of bytes is written after the limit is exceeded. The size of the output file is slightly more than the requested file size. When used as an input option (before ), seeks in this input file to . Note that in most formats it is not possible to seek exactly, so will seek to the closest seek point before . When transcoding and is enabled (the default), this extra segment between the seek point and will be decoded and discarded. When doing stream copy or when is used, it will be preserved. When used as an output option (before an output url), decodes but discards input until the timestamps reach . must be a time duration specification, see (ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual. Like the option but relative to the \"end of file\". That is negative values are earlier in the file, 0 is at EOF. This will take the difference between the start times of the target and reference inputs and offset the timestamps of the target file by that difference. The source timestamps of the two inputs should derive from the same clock source for expected results. If is set then must also be set. If either of the inputs has no starting timestamp then no sync adjustment is made. Acceptable values are those that refer to a valid ffmpeg input index. If the sync reference is the target index itself or , then no adjustment is made to target timestamps. A sync reference may not itself be synced to any other input. must be a time duration specification, see (ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual. The offset is added to the timestamps of the input files. Specifying a positive offset means that the corresponding streams are delayed by the time duration specified in . Set the recording timestamp in the container. must be a date specification, see (ffmpeg-utils)the Date section in the ffmpeg-utils(1) manual. An optional may be given to set metadata on streams, chapters or programs. See documentation for details. This option overrides metadata set with . It is also possible to delete metadata by using an empty value. For example, for setting the title in the output file: To set the language of the first audio stream: Default value: by default, all disposition flags are copied from the input stream, unless the output stream this option applies to is fed by a complex filtergraph - in that case no disposition flags are set by default. is a sequence of disposition flags separated by ’+’ or ’-’. A ’+’ prefix adds the given disposition, ’-’ removes it. If the first flag is also prefixed with ’+’ or ’-’, the resulting disposition is the default value updated by . If the first flag is not prefixed, the resulting disposition is . It is also possible to clear the disposition by setting it to 0. If no options were specified for an output file, ffmpeg will automatically set the ’default’ disposition flag on the first stream of each type, when there are multiple streams of this type in the output file and no stream of that type is already marked as default. The option lists the known disposition flags. For example, to make the second audio stream the default stream: To make the second subtitle stream the default stream and remove the default disposition from the first subtitle stream: To add the ’original’ and remove the ’comment’ disposition flag from the first audio stream without removing its other disposition flags: To remove the ’original’ and add the ’comment’ disposition flag to the first audio stream without removing its other disposition flags: To set only the ’original’ and ’comment’ disposition flags on the first audio stream (and remove its other disposition flags): To remove all disposition flags from the first audio stream: Not all muxers support embedded thumbnails, and those who do, only support a few formats, like JPEG or PNG. Creates a program with the specified , and adds the specified (s) to it. Creates a stream group of the specified and , or by ping an input group, adding the specified (s) and/or previously defined (s) to it. can be one of the following: Groups s that belong to the same IAMF Audio Element For this group , the following options are available The Audio Element type. The following values are supported: Demixing information used to reconstruct a scalable channel audio representation. This option must be separated from the rest with a ’,’, and takes the following key=value options An identifier parameters blocks in frames may refer to Recon gain information used to reconstruct a scalable channel audio representation. This option must be separated from the rest with a ’,’, and takes the following key=value options An identifier parameters blocks in frames may refer to A layer defining a Channel Layout in the Audio Element. This option must be separated from the rest with a ’,’. Several ’,’ separated entries can be defined, and at least one must be set. It takes the following \":\"-separated key=value options The following flags are available: Wether to signal if recon_gain is present as metadata in parameter blocks within frames Which channels output_gain applies to. The following flags are available: The ambisonics mode. This has no effect if audio_element_type is set to channel. The following values are supported: Each ambisonics channel is coded as an individual mono stream in the group Groups s that belong to all IAMF Audio Element the same IAMF Mix Presentation references For this group , the following options are available A sub-mix within the Mix Presentation. This option must be separated from the rest with a ’,’. Several ’,’ separated entries can be defined, and at least one must be set. It takes the following \":\"-separated key=value options An identifier parameters blocks in frames may refer to, for post-processing the mixed audio signal to generate the audio signal for playback The sample rate duration fields in parameters blocks in frames that refer to this are expressed as Default mix gain value to apply when there are no parameter blocks sharing the same for a given frame References an Audio Element used in this Mix Presentation to generate the final output audio signal for playback. This option must be separated from the rest with a ’|’. Several ’|’ separated entries can be defined, and at least one must be set. It takes the following \":\"-separated key=value options: The for an Audio Element which this sub-mix refers to An identifier parameters blocks in frames may refer to, for applying any processing to the referenced and rendered Audio Element before being summed with other processed Audio Elements The sample rate duration fields in parameters blocks in frames that refer to this are expressed as Default mix gain value to apply when there are no parameter blocks sharing the same for a given frame A key=value string describing the sub-mix element where \"key\" is a string conforming to BCP-47 that specifies the language for the \"value\" string. \"key\" must be the same as the one in the mix’s Indicates whether the input channel-based Audio Element is rendered to stereo loudspeakers or spatialized with a binaural renderer when played back on headphones. This has no effect if the referenced Audio Element’s is set to channel. The following values are supported: Specifies the layouts for this sub-mix on which the loudness information was measured. This option must be separated from the rest with a ’|’. Several ’|’ separated entries can be defined, and at least one must be set. It takes the following \":\"-separated key=value options: The layout follows the loudspeaker sound system convention of ITU-2051-3. Channel layout matching one of Sound Systems A to J of ITU-2051-3, plus 7.1.2 and 3.1.2 This has no effect if is set to binaural. The program integrated loudness information, as defined in ITU-1770-4. The digital (sampled) peak value of the audio signal, as defined in ITU-1770-4. The true peak of the audio signal, as defined in ITU-1770-4. The Dialogue loudness information, as defined in ITU-1770-4. The Album loudness information, as defined in ITU-1770-4. A key=value string string describing the mix where \"key\" is a string conforming to BCP-47 that specifies the language for the \"value\" string. \"key\" must be the same as the ones in all sub-mix element’s s E.g. to create an scalable 5.1 IAMF file from several WAV input files To copy the two stream groups (Audio Element and Mix Presentation) from an input IAMF file with four streams into an mp4 output Specify target file type ( , , , , ). may be prefixed with , or to use the corresponding standard. All the format options (bitrate, codecs, buffer sizes) are then set automatically. You can just type: Nevertheless you can specify additional options as long as you know they do not conflict with the standard, as in: The parameters set for each target are as follows. The target is identical to the target except that the pixel format set is for all three standards. Any user-set value for a parameter above will override the target preset value. In that case, the output may not comply with the target standard. As an input option, blocks all data streams of a file from being filtered or being automatically selected or mapped for any output. See option to disable streams individually. As an output option, disables data recording i.e. automatic selection or mapping of any data stream. For full manual control see the option. Set the number of data frames to output. This is an obsolete alias for , which you should use instead. Stop writing to the stream after frames. Use fixed quality scale (VBR). The meaning of / is codec-dependent. If is used without a then it applies only to the video stream, this is to maintain compatibility with previous behavior and as specifying the same codec specific value to 2 different codecs that is audio and video generally is not what is intended when no stream_specifier is used. Create the filtergraph specified by and use it to filter the stream. is a description of the filtergraph to apply to the stream, and must have a single input and a single output of the same type of the stream. In the filtergraph, the input is associated to the label , and the output to the label . See the ffmpeg-filters manual for more information about the filtergraph syntax. See the -filter_complex option if you want to create filtergraphs with multiple inputs and/or outputs. This boolean option determines if the filtergraph(s) to which this stream is fed gets reinitialized when input frame parameters change mid-stream. This option is enabled by default as most video and all audio filters cannot handle deviation in input frame properties. Upon reinitialization, existing filter state is lost, like e.g. the frame count reference available in some filters. Any frames buffered at time of reinitialization are lost. The properties where a change triggers reinitialization are, for video, frame resolution or pixel format; for audio, sample format, sample rate, channel count or channel layout. Defines how many threads are used to process a filter pipeline. Each pipeline will produce a thread pool with this many threads available for parallel processing. The default is the number of available CPUs. Specify the preset for matching stream(s). Log encoding progress/statistics as \"info\"-level log (see ). It is on by default, to explicitly disable it you need to specify . Set period at which encoding progress/statistics are updated. Default is 0.5 seconds. Progress information is written periodically and at the end of the encoding process. It is made of \" = \" lines. consists of only alphanumeric characters. The last key of a sequence of progress information is always \"progress\" with the value \"continue\" or \"end\". The update period is set using . For example, log progress information to stdout: Enable interaction on standard input. On by default unless standard input is used as an input. To explicitly disable interaction you need to specify . Disabling interaction on standard input is useful, for example, if ffmpeg is in the background process group. Roughly the same result can be achieved with but it requires a shell. Print timestamp/latency information. It is off by default. This option is mostly useful for testing and debugging purposes, and the output format may change from one version to another, so it should not be employed by portable scripts. See also the option . Add an attachment to the output file. This is supported by a few formats like Matroska for e.g. fonts used in rendering subtitles. Attachments are implemented as a specific type of stream, so this option will add a new stream to the file. It is then possible to use per-stream options on this stream in the usual way. Attachment streams created with this option will be created after all the other streams (i.e. those created with or automatic mappings). Note that for Matroska you also have to set the mimetype metadata tag: (assuming that the attachment stream will be third in the output file). Extract the matching attachment stream into a file named . If is empty, then the value of the metadata tag will be used. E.g. to extract the first attachment to a file named ’out.ttf’: To extract all attachments to files determined by the tag: Technical note – attachments are implemented as codec extradata, so this option can actually be used to extract extradata from any stream, not just attachments.\n\nSet pixel format. Use to show all the supported pixel formats. If the selected pixel format can not be selected, ffmpeg will print a warning and select the best pixel format supported by the encoder. If is prefixed by a , ffmpeg will exit with an error if the requested pixel format can not be selected, and automatic conversions inside filtergraphs are disabled. If is a single , ffmpeg selects the same pixel format as the input (or graph output) and automatic conversions are disabled. Set default flags for the libswscale library. These flags are used by automatically inserted filters and those within simple filtergraphs, if not overridden within the filtergraph definition. See the (ffmpeg-scaler)ffmpeg-scaler manual for a list of scaler options. Rate control override for specific intervals, formatted as \"int,int,int\" list separated with slashes. Two first values are the beginning and end frame numbers, last one is quantizer to use if positive, or quality factor if negative. Dump video coding statistics to . See the vstats file format section for the format description. Dump video coding statistics to . See the vstats file format section for the format description. Specify which version of the vstats format to use. Default is . See the vstats file format section for the format description. Force video tag/fourcc. This is an alias for . can take arguments of the following form: If the argument consists of timestamps, ffmpeg will round the specified times to the nearest output timestamp as per the encoder time base and force a keyframe at the first frame having timestamp equal or greater than the computed timestamp. Note that if the encoder time base is too coarse, then the keyframes may be forced on frames with timestamps lower than the specified time. The default encoder time base is the inverse of the output framerate but may be set otherwise via . If one of the times is \" [ ]\", it is expanded into the time of the beginning of all chapters in the file, shifted by , expressed as a time in seconds. This option can be useful to ensure that a seek point is present at a chapter mark or any other designated place in the output file. For example, to insert a key frame at 5 minutes, plus key frames 0.1 second before the beginning of every chapter: If the argument is prefixed with , the string is interpreted like an expression and is evaluated for each frame. A key frame is forced in case the evaluation is non-zero. The expression in can contain the following constants: the number of current processed frame, starting from 0 the number of the previous forced frame, it is when no keyframe was forced yet the time of the previous forced frame, it is when no keyframe was forced yet the time of the current processed frame For example to force a key frame every 5 seconds, you can specify: To force a key frame 5 seconds after the time of the last forced one, starting from second 13: If the argument is , ffmpeg will force a key frame if the current frame being encoded is marked as a key frame in its source. In cases where this particular source frame has to be dropped, enforce the next available frame to become a key frame instead. Note that forcing too many keyframes is very harmful for the lookahead algorithms of certain encoders: using fixed-GOP options or similar would be more efficient. Automatically crop the video after decoding according to file metadata. Default is all. Apply both codec and container level croppping. This is the default mode. When doing stream copy, copy also non-key frames found at the beginning. Initialise a new hardware device of type called , using the given device parameters. If no name is specified it will receive a default name of the form \" %d\". The meaning of and the following arguments depends on the device type: is the number of the CUDA device. The following options are recognized: If set to 1, uses the primary device context instead of creating a new one. Choose the second device on the system. Choose the first device and use the primary device context. is the number of the Direct3D 9 display adapter. is the number of the Direct3D 11 display adapter. If not specified, it will attempt to use the default Direct3D 11 display adapter or the first Direct3D 11 display adapter whose hardware VendorId is specified by ‘ ’. Create a d3d11va device on the Direct3D 11 display adapter specified by index 1. Create a d3d11va device on the first Direct3D 11 display adapter whose hardware VendorId is 0x8086. is either an X11 display name, a DRM render node or a DirectX adapter index. If not specified, it will attempt to open the default X11 display ($DISPLAY) and then the first DRM render node (/dev/dri/renderD128), or the default DirectX adapter on Windows. The following options are recognized: When is not specified, use this option to specify the name of the kernel driver associated with the desired device. This option is available only when the hardware acceleration method drm and vaapi are enabled. When and are not specified, use this option to specify the vendor id associated with the desired device. This option is available only when the hardware acceleration method drm and vaapi are enabled and kernel_driver is not specified. Create a vaapi device on a device associated with kernel driver ‘ ’. Create a vaapi device on a device associated with vendor id ‘ ’. is an X11 display name. If not specified, it will attempt to open the default X11 display ($DISPLAY). selects a value in ‘ ’. Allowed values are: If not specified, ‘ ’ is used. (Note that it may be easier to achieve the desired result for QSV by creating the platform-appropriate subdevice (‘ ’ or ‘ ’ or ‘ ’) and then deriving a QSV device from that.) The following options are recognized: Specify a DRM render node on Linux or DirectX adapter on Windows. Choose platform-appropriate subdevice type. On Windows ‘ ’ is used as default subdevice type when is specified at configuration time, ‘ ’ is used as default subdevice type when is specified at configuration time. On Linux user can use ‘ ’ only as subdevice type. Choose the GPU subdevice with type ‘ ’ and create QSV device with ‘ ’. Choose the GPU subdevice with type ‘ ’ and create QSV device with ‘ ’. Create a QSV device with ‘ ’ on DirectX adapter 1 with subdevice type ‘ ’. Create a VAAPI device called ‘ ’ on , then derive a QSV device called ‘ ’ from device ‘ ’. selects the platform and device as platform_index.device_index. The set of devices can also be filtered using the key-value pairs to find only devices matching particular platform or device strings. The strings usable as filters are: The indices and filters must together uniquely select a device. Choose the second device on the first platform. Choose the device with a name containing the string Foo9000. Choose the GPU device on the second platform supporting the cl_khr_fp16 extension. If is an integer, it selects the device by its index in a system-dependent list of devices. If is any other string, it selects the first device with a name containing that string as a substring. The following options are recognized: If set to 1, enables the validation layer, if installed. If set to 1, images allocated by the hwcontext will be linear and locally mappable. A plus separated list of additional instance extensions to enable. A plus separated list of additional device extensions to enable. Choose the second device on the system. Choose the first device with a name containing the string RADV. Choose the first device and enable the Wayland and XCB instance extensions. Initialise a new hardware device of type called , deriving it from the existing device with the name . List all hardware device types supported in this build of ffmpeg. Pass the hardware device called to all filters in any filter graph. This can be used to set the device to upload to with the filter, or the device to map to with the filter. Other filters may also make use of this parameter when they require a hardware device. Note that this is typically only required when the input is not already in hardware frames - when it is, filters will derive the device they require from the context of the frames they receive as input. This is a global setting, so all filters will receive the same device. Use hardware acceleration to decode the matching stream(s). The allowed values of are: Do not use any hardware acceleration (the default). Use VDPAU (Video Decode and Presentation API for Unix) hardware acceleration. Use the Intel QuickSync Video acceleration for video transcoding. Unlike most other values, this option does not enable accelerated decoding (that is used automatically whenever a qsv decoder is selected), but accelerated transcoding, without copying the frames into the system memory. For it to work, both the decoder and the encoder must support QSV acceleration and no filters must be used. This option has no effect if the selected hwaccel is not available or not supported by the chosen decoder. Note that most acceleration methods are intended for playback and will not be faster than software decoding on modern CPUs. Additionally, will usually need to copy the decoded frames from the GPU memory into the system memory, resulting in further performance loss. This option is thus mainly useful for testing. Select a device to use for hardware acceleration. This option only makes sense when the option is also specified. It can either refer to an existing device created with by name, or it can create a new device as if ‘ ’ : were called immediately before. List all hardware acceleration components enabled in this build of ffmpeg. Actual runtime availability depends on the hardware and its suitable driver being installed. Set a specific output video stream as the heartbeat stream according to which to split and push through currently in-progress subtitle upon receipt of a random access packet. This lowers the latency of subtitles for which the end packet or the following subtitle has not yet been received. As a drawback, this will most likely lead to duplication of subtitle events in order to cover the full duration, so when dealing with use cases where latency of when the subtitle event is passed on to output is not relevant this option should not be utilized. Requires to be set for the relevant input subtitle stream for this to have any effect, as well as for the input subtitle stream having to be directly mapped to the same output in which the heartbeat stream resides.\n\nCreate one or more streams in the output file. This option has two forms for specifying the data source(s): the first selects one or more streams from some input file (specified with ), the second takes an output from some complex filtergraph (specified with ). In the first form, an output stream is created for every stream from the input file with the index . If is given, only those streams that match the specifier are used (see the Stream specifiers section for the syntax). A character before the stream identifier creates a \"negative\" mapping. It disables matching streams from already created mappings. An optional may be given after the stream specifier, which for multiview video specifies the view to be used. The view specifier may have one of the following formats: select a view by its ID; may be set to ’all’ to use all the views interleaved into one stream; select a view by its index; i.e. 0 is the base view, 1 is the first non-base view, etc. select a view by its display position; may be or The default for transcoding is to only use the base view, i.e. the equivalent of . For streamcopy, view specifiers are not supported and all views are always copied. A trailing after the stream index will allow the map to be optional: if the map matches no streams the map will be ignored instead of failing. Note the map will still fail if an invalid input file index is used; such as if the map refers to a non-existent input. An alternative form will map outputs from complex filter graphs (see the option) to the output file. must correspond to a defined output link label in the graph. This option may be specified multiple times, each adding more streams to the output file. Any given input stream may also be mapped any number of times as a source for different output streams, e.g. in order to use different encoding options and/or filters. The streams are created in the output in the same order in which the options are given on the commandline. Using this option disables the default mappings for this output file. To map ALL streams from the first input file to output If you have two audio streams in the first input file, these streams are identified by and . You can use to select which streams to place in an output file. For example: will map the second input stream in to the (single) output stream in . To select the stream with index 2 from input file (specified by the identifier ), and stream with index 6 from input (specified by the identifier ), and copy them to the output file : To select all video and the third audio stream from an input file: To map all the streams except the second audio, use negative mappings To map the video and audio streams from the first input, and using the trailing , ignore the audio mapping if no audio streams exist in the first input: Ignore input streams with unknown type instead of failing if copying such streams is attempted. Allow input streams with unknown type to be copied instead of failing if copying such streams is attempted. Set metadata information of the next output file from . Note that those are file indices (zero-based), not filenames. Optional parameters specify, which metadata to copy. A metadata specifier can have the following forms: global metadata, i.e. metadata that applies to the whole file per-stream metadata. is a stream specifier as described in the Stream specifiers chapter. In an input metadata specifier, the first matching stream is copied from. In an output metadata specifier, all matching streams are copied to. If metadata specifier is omitted, it defaults to global. By default, global metadata is copied from the first input file, per-stream and per-chapter metadata is copied along with streams/chapters. These default mappings are disabled by creating any mapping of the relevant type. A negative file index can be used to create a dummy mapping that just disables automatic copying. For example to copy metadata from the first stream of the input file to global metadata of the output file: To do the reverse, i.e. copy global metadata to all audio streams: Note that simple would work as well in this example, since global metadata is assumed by default. Copy chapters from input file with index to the next output file. If no chapter mapping is specified, then chapters are copied from the first input file with at least one chapter. Use a negative file index to disable any chapter copying. Show benchmarking information at the end of an encode. Shows real, system and user time used and maximum memory consumption. Maximum memory consumption is not supported on all systems, it will usually display as 0 if not supported. Show benchmarking information during the encode. Shows real, system and user time used in various steps (audio/video encode/decode). Exit after ffmpeg has been running for seconds in CPU user time. When dumping packets, also dump the payload. Its value is a floating-point positive number which represents the maximum duration of media, in seconds, that should be ingested in one second of wallclock time. Default value is zero and represents no imposed limitation on speed of ingestion. Value represents real-time speed and is equivalent to . Mainly used to simulate a capture device or live input stream (e.g. when reading from a file). Should not be used with a low value when input is an actual capture device or live stream as it may cause packet loss. It is useful for when flow speed of output packets is important, such as live streaming. Read input at native frame rate. This is equivalent to setting . Set an initial read burst time, in seconds, after which will be enforced. If either the input or output is blocked leading to actual read speed falling behind the specified readrate, then this rate takes effect till the input catches up with the specified readrate. Must not be lower than the primary readrate. Set video sync method / framerate mode. vsync is applied to all output video streams but can be overridden for a stream by setting fps_mode. vsync is deprecated and will be removed in the future. For compatibility reasons some of the values for vsync can be specified as numbers (shown in parentheses in the following table). Each frame is passed with its timestamp from the demuxer to the muxer. Frames will be duplicated and dropped to achieve exactly the requested constant frame rate. Frames are passed through with their timestamp or dropped so as to prevent 2 frames from having the same timestamp. Chooses between cfr and vfr depending on muxer capabilities. This is the default method. Note that the timestamps may be further modified by the muxer, after this. For example, in the case that the format option is enabled. With -map you can select from which stream the timestamps should be taken. You can leave either video or audio unchanged and sync the remaining stream(s) to the unchanged one. Frame drop threshold, which specifies how much behind video frames can be before they are dropped. In frame rate units, so 1.0 is one frame. The default is -1.1. One possible usecase is to avoid framedrops in case of noisy timestamps or to increase frame drop precision in case of exact timestamps. Pad the output audio stream(s). This is the same as applying . Argument is a string of filter parameters composed the same as with the filter. must be set for this output for the option to take effect. Do not process input timestamps, but keep their values without trying to sanitize them. In particular, do not remove the initial start time offset value. Note that, depending on the option or on specific muxer processing (e.g. in case the format option is enabled) the output timestamps may mismatch with the input timestamps even when this option is selected. When used with , shift input timestamps so they start at zero. This means that using e.g. will make output timestamps start at 50 seconds, regardless of what timestamp the input file started at. Specify how to set the encoder timebase when stream copying. is an integer numeric value, and can assume one of the following values: The time base is copied to the output encoder from the corresponding input demuxer. This is sometimes required to avoid non monotonically increasing timestamps when copying video streams with variable frame rate. The time base is copied to the output encoder from the corresponding input decoder. Try to make the choice automatically, in order to generate a sane output. Set the encoder timebase. can assume one of the following values: Assign a default value according to the media type. For video - use 1/framerate, for audio - use 1/samplerate. Use the timebase from the demuxer. Use the timebase from the filtergraph. Use the provided number as the timebase. This field can be provided as a ratio of two integers (e.g. 1:24, 1:48000) or as a decimal number (e.g. 0.04166, 2.0833e-5) Note that this option may require buffering frames, which introduces extra latency. The maximum amount of this latency may be controlled with the option. The option may require buffering potentially large amounts of data when at least one of the streams is \"sparse\" (i.e. has large gaps between frames – this is typically the case for subtitles). This option controls the maximum duration of buffered frames in seconds. Larger values may allow the option to produce more accurate results, but increase memory use and latency. The default value is 10 seconds. The timestamp discontinuity correction enabled by this option is only applied to input formats accepting timestamp discontinuity (for which the flag is enabled), e.g. MPEG-TS and HLS, and is automatically disabled when employing the option (unless wrapping is detected). If a timestamp discontinuity is detected whose absolute value is greater than , ffmpeg will remove the discontinuity by decreasing/increasing the current DTS and PTS by the corresponding delta value. The timestamp correction enabled by this option is only applied to input formats not accepting timestamp discontinuity (for which the flag is not enabled). If a timestamp discontinuity is detected whose absolute value is greater than , ffmpeg will drop the PTS/DTS timestamp value. The default value is (30 hours), which is arbitrarily picked and quite conservative. Assign a new stream-id value to an output stream. This option should be specified prior to the output filename to which it applies. For the situation where multiple output files exist, a streamid may be reassigned to a different value. For example, to set the stream 0 PID to 33 and the stream 1 PID to 36 for an output mpegts file: Apply bitstream filters to matching streams. The filters are applied to each packet as it is received from the demuxer (when used as an input option) or before it is sent to the muxer (when used as an output option). is a comma-separated list of bitstream filter specifications, each of the form Any of the ’,=:’ characters that are to be a part of an option value need to be escaped with a backslash. Use the option to get the list of bitstream filters. applies the bitstream filter (which converts MP4-encapsulated H.264 stream to Annex B) to the input video stream. applies the bitstream filter (which extracts text from MOV subtitles) to the output subtitle stream. Note, however, that since both examples use , it matters little whether the filters are applied on input or output - that would change if transcoding was happening. Specify Timecode for writing. is ’:’ for non drop timecode and ’;’ (or ’.’) for drop. Define a complex filtergraph, i.e. one with arbitrary number of inputs and/or outputs. For simple graphs – those with one input and one output of the same type – see the options. is a description of the filtergraph, as described in the “Filtergraph syntax” section of the ffmpeg-filters manual. This option may be specified multiple times - each use creates a new complex filtergraph. Inputs to a complex filtergraph may come from different source types, distinguished by the format of the corresponding link label:\n• To connect an input stream, use (i.e. the same syntax as ). If matches multiple streams, the first one will be used. For multiview video, the stream specifier may be followed by the view specifier, see documentation for the option for its syntax.\n• To connect a loopback decoder use [dec: ], where is the index of the loopback decoder to be connected to given input. For multiview video, the decoder index may be followed by the view specifier, see documentation for the option for its syntax.\n• To connect an output from another complex filtergraph, use its link label. E.g the following example:\n• (line 2) uses a complex filtergraph with one input and two outputs to scale the video to 1920x1080 and duplicate the result to both outputs;\n• (line 3) encodes one scaled output with and writes the result to ;\n• (line 5) places the output of the loopback decoder (i.e. the -encoded video) side by side with the scaled original input;\n• (line 6) combined video is then losslessly encoded and written into . Note that the two filtergraphs cannot be combined into one, because then there would be a cycle in the transcoding pipeline (filtergraph output goes to encoding, from there to decoding, then back to the same graph), and such cycles are not allowed. An unlabeled input will be connected to the first unused input stream of the matching type. Output link labels are referred to with . Unlabeled outputs are added to the first output file. Note that with this option it is possible to use only lavfi sources without normal input files. For example, to overlay an image over video Here refers to the first video stream in the first input file, which is linked to the first (main) input of the overlay filter. Similarly the first video stream in the second input is linked to the second (overlay) input of overlay. Assuming there is only one video stream in each input file, we can omit input labels, so the above is equivalent to Furthermore we can omit the output label and the single output from the filter graph will be added to the output file automatically, so we can simply write As a special exception, you can use a bitmap subtitle stream as input: it will be converted into a video with the same size as the largest video in the file, or 720x576 if no video is present. Note that this is an experimental and temporary solution. It will be removed once libavfilter has proper support for subtitles. For example, to hardcode subtitles on top of a DVB-T recording stored in MPEG-TS format, delaying the subtitles by 1 second: To generate 5 seconds of pure red video using lavfi source: Defines how many threads are used to process a filter_complex graph. Similar to filter_threads but used for graphs only. The default is the number of available CPUs. Define a complex filtergraph, i.e. one with arbitrary number of inputs and/or outputs. Equivalent to . This option enables or disables accurate seeking in input files with the option. It is enabled by default, so seeking is accurate when transcoding. Use to disable it, which may be useful e.g. when copying some streams and transcoding the others. This option enables or disables seeking by timestamp in input files with the option. It is disabled by default. If enabled, the argument to the option is considered an actual timestamp, and is not offset by the start time of the file. This matters only for files which do not start from timestamp 0, such as transport streams. For input, this option sets the maximum number of queued packets when reading from the file or device. With low latency / high rate live streams, packets may be discarded if they are not read in a timely manner; setting this value can force ffmpeg to use a separate input thread and read packets as soon as they arrive. By default ffmpeg only does this if multiple inputs are specified. For output, this option specified the maximum number of packets that may be queued to each muxing thread. Print sdp information for an output stream to . This allows dumping sdp information when at least one output isn’t an rtp stream. (Requires at least one of the output formats to be rtp). Allows discarding specific streams or frames from streams. Any input stream can be fully discarded, using value whereas selective discarding of frames from a stream occurs at the demuxer and is not supported by all demuxers. Stop and abort on various conditions. The following flags are available: No packets were passed to the muxer, the output is empty. No packets were passed to the muxer in some of the output streams. Set fraction of decoding frame failures across all inputs which when crossed ffmpeg will return exit code 69. Crossing this threshold does not terminate processing. Range is a floating-point number between 0 to 1. Default is 2/3. When transcoding audio and/or video streams, ffmpeg will not begin writing into the output until it has one packet for each such stream. While waiting for that to happen, packets for other streams are buffered. This option sets the size of this buffer, in packets, for the matching output stream. The default value of this option should be high enough for most uses, so only touch this option if you are sure that you need it. This is a minimum threshold until which the muxing queue size is not taken into account. Defaults to 50 megabytes per stream, and is based on the overall size of packets passed to the muxer. Enable automatically inserting format conversion filters in all filter graphs, including those defined by , , and . If filter format negotiation requires a conversion, the initialization of the filters will fail. Conversions can still be performed by inserting the relevant conversion filter (scale, aresample) in the graph. On by default, to explicitly disable it you need to specify . Declare the number of bits per raw sample in the given output stream to be . Note that this option sets the information provided to the encoder/muxer, it does not change the stream to conform to this value. Setting values that do not match the stream properties may result in encoding failures or invalid output files. Write per-frame encoding information about the matching streams into the file given by . writes information about raw video or audio frames right before they are sent for encoding, while writes information about encoded packets as they are received from the encoder. writes information about packets just as they are about to be sent to the muxer. Every frame or packet produces one line in the specified file. The format of this line is controlled by / / . When stats for multiple streams are written into a single file, the lines corresponding to different streams will be interleaved. The precise order of this interleaving is not specified and not guaranteed to remain stable between different invocations of the program, even with the same options. Specify the format for the lines written with / / . is a string that may contain directives of the form . is backslash-escaped — use \\{, \\}, and \\\\ to write a literal {, }, or \\, respectively, into the output. The directives given with may be one of the following: Index of the output stream in the file. Frame number. Pre-encoding: number of frames sent to the encoder so far. Post-encoding: number of packets received from the encoder so far. Muxing: number of packets submitted to the muxer for this stream so far. Input frame number. Index of the input frame (i.e. output by a decoder) that corresponds to this output frame or packet. -1 if unavailable. Timebase in which this frame/packet’s timestamps are expressed, as a rational number . Note that encoder and muxer may use different timebases. Timebase for , as a rational number . Available when is available, otherwise. Presentation timestamp of the frame or packet, as an integer. Should be multiplied by the timebase to compute presentation time. Presentation timestamp of the input frame (see ), as an integer. Should be multiplied by to compute presentation time. Printed as (2^63 - 1 = 9223372036854775807) when not available. Presentation time of the frame or packet, as a decimal number. Equal to multiplied by . Presentation time of the input frame (see ), as a decimal number. Equal to multiplied by . Printed as inf when not available. Decoding timestamp of the packet, as an integer. Should be multiplied by the timebase to compute presentation time. Decoding time of the frame or packet, as a decimal number. Equal to multiplied by . Number of audio samples sent to the encoder so far. Number of audio samples in the frame. Size of the encoded packet in bytes. Current bitrate in bits per second. Average bitrate for the whole stream so far, in bits per second, -1 if it cannot be determined at this point. Character ’K’ if the packet contains a keyframe, character ’N’ otherwise. Directives tagged with packet may only be used with and . Directives tagged with frame may only be used with . Directives tagged with audio may only be used with audio streams. In the future, new items may be added to the end of the default formatting strings. Users who depend on the format staying exactly the same, should prescribe it manually. Note that stats for different streams written into the same file may have different formats.\n\nA preset file contains a sequence of = pairs, one for each line, specifying a sequence of options which would be awkward to specify on the command line. Lines starting with the hash (’#’) character are ignored and are used to provide comments. Check the directory in the FFmpeg source tree for examples.\n\nThere are two types of preset files: ffpreset and avpreset files.\n\nffpreset files are specified with the , , , and options. The option takes the filename of the preset instead of a preset name as input and can be used for any kind of codec. For the , , and options, the options specified in a preset file are applied to the currently selected codec of the same type as the preset option.\n\nThe argument passed to the , , and preset options identifies the preset file to use according to the following rules:\n\nFirst ffmpeg searches for a file named .ffpreset in the directories (if set), and , and in the datadir defined at configuration time (usually ) or in a folder along the executable on win32, in that order. For example, if the argument is , it will search for the file .\n\nIf no such file is found, then ffmpeg will search for a file named - .ffpreset in the above-mentioned directories, where is the name of the codec to which the preset file options will be applied. For example, if you select the video codec with and use , then it will search for the file .\n\navpreset files are specified with the option. They work similar to ffpreset files, but they only allow encoder- specific options. Therefore, an = pair specifying an encoder cannot be used.\n\nWhen the option is specified, ffmpeg will look for files with the suffix .avpreset in the directories (if set), and , and in the datadir defined at configuration time (usually ), in that order.\n\nFirst ffmpeg searches for a file named - .avpreset in the above-mentioned directories, where is the name of the codec to which the preset file options will be applied. For example, if you select the video codec with and use , then it will search for the file .\n\nIf no such file is found, then ffmpeg will search for a file named .avpreset in the same directories.\n\nThe and options enable generation of a file containing statistics about the generated video outputs.\n\nThe option controls the format version of the generated file.\n\nWith version the format is:\n\nWith version the format is:\n\nThe value corresponding to each key is described below:\n\nSee also the -stats_enc options for an alternative way to show encoding statistics.\n\nIf you specify the input format and device then ffmpeg can grab video and audio directly.\n\nOr with an ALSA audio source (mono input, card id 1) instead of OSS:\n\nNote that you must activate the right video source and channel before launching ffmpeg with any TV viewer such as xawtv by Gerd Knorr. You also have to set the audio recording levels correctly with a standard mixer.\n\nGrab the X11 display with ffmpeg via\n\n0.0 is display.screen number of your X11 server, same as the DISPLAY environment variable.\n\n0.0 is display.screen number of your X11 server, same as the DISPLAY environment variable. 10 is the x-offset and 20 the y-offset for the grabbing.\n\nAny supported file format and protocol can serve as input to ffmpeg:\n• You can use YUV files as input: It will use the files: The Y files use twice the resolution of the U and V files. They are raw files, without header. They can be generated by all decent video decoders. You must specify the size of the image with the option if ffmpeg cannot guess it.\n• You can input from a raw YUV420P file: test.yuv is a file containing raw YUV planar data. Each frame is composed of the Y plane followed by the U and V planes at half vertical and horizontal resolution.\n• You can output to a raw YUV420P file:\n• You can set several input files and output files: Converts the audio file a.wav and the raw YUV video file a.yuv to MPEG file a.mpg.\n• You can also do audio and video conversions at the same time:\n• You can encode to several formats at the same time and define a mapping from input stream to output streams: Converts a.wav to a.mp2 at 64 kbits and to b.mp2 at 128 kbits. ’-map file:index’ specifies which input stream is used for each output stream, in the order of the definition of output streams.\n• You can transcode decrypted VOBs: This is a typical DVD ripping example; the input is a VOB file, the output an AVI file with MPEG-4 video and MP3 audio. Note that in this command we use B-frames so the MPEG-4 stream is DivX5 compatible, and GOP size is 300 which means one intra frame every 10 seconds for 29.97fps input video. Furthermore, the audio stream is MP3-encoded so you need to enable LAME support by passing to configure. The mapping is particularly useful for DVD transcoding to get the desired audio language. NOTE: To see the supported input formats, use .\n• You can extract images from a video, or create a video from many images: This will extract one video frame per second from the video and will output them in files named , , etc. Images will be rescaled to fit the new WxH values. If you want to extract just a limited number of frames, you can use the above command in combination with the or option, or in combination with -ss to start extracting from a certain point in time. For creating a video from many images: The syntax specifies to use a decimal number composed of three digits padded with zeroes to express the sequence number. It is the same syntax supported by the C printf function, but only formats accepting a normal integer are suitable. When importing an image sequence, -i also supports expanding shell-like wildcard patterns (globbing) internally, by selecting the image2-specific option. For example, for creating a video from filenames matching the glob pattern :\n• You can put many streams of the same type in the output: The resulting output file will contain the first four streams from the input files in reverse order.\n• The four options lmin, lmax, mblmin and mblmax use ’lambda’ units, but you may use the QP2LAMBDA constant to easily convert from ’q’ units:\n\nFor details about the authorship, see the Git history of the project (https://git.ffmpeg.org/ffmpeg), e.g. by typing the command in the FFmpeg source directory, or browsing the online repository at https://git.ffmpeg.org/ffmpeg.\n\nMaintainers for the specific components are listed in the file in the source code tree.\n\nThis document was generated on March 22, 2025 using makeinfo."
    },
    {
        "link": "https://superuser.com/questions/1641434/how-to-enable-libx264-in-ffmpeg",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://stackoverflow.com/questions/5678695/ffmpeg-usage-to-encode-a-video-to-h264-codec-format",
        "document": "I have a *.mp4 video file(MPEG4 video codec) and I am trying to convert this to a H264 video codec format(raw h.264 format) using ffmpeg on Linux(Version - FFmpeg version SVN-r0.5.1-4:0.5.1-1ubuntu1, Copyright (c) 2000-2009 Fabrice Bellard,) using command line as shown below,\n\nbut I get an error saying -\n\nThen when i try this option:\n\nit still does not work, and gives -\n\nAnd then it prints out help on the formats which we get when we do\n\nWhen I checked the help, , I see below information related to H264 file format and codec:\n• None How can I convert the video to a H264 encoded video (raw H264 video format)\n• None When I do , I see many acronyms for the codecs supported, I see many acronyms before the codec name/type such as - D V D S E A, what do they stand for?\n• None How to use the ffmpeg options and ?"
    },
    {
        "link": "https://streamingmedia.com/Articles/Editorial/Featured-Articles/How-to-Encode-with-FFmpeg-5.0-152090.aspx",
        "document": "How to Encode with FFmpeg 5.0\n\nOn January 17, 2022, FFmpeg released FFmpeg 5.0, called Lorentz. To celebrate and to help introduce new users to the power and ease of FFmpeg, I created this entry-level tutorial for single and two-pass encoding with FFmpeg.\n\nFor the record, many of the major changes to FFmpeg were at the application programming interface level, so if you're driving the program from the command line, you'll see little difference. Thankfully, Lorenz didn't \"break\" any of the command strings that I tested from my FFmpeg book, Learn to Produce Video With FFmpeg: In Thirty Minutes or Less, or courses, so hopefully, it won't break existing command strings for other users. Most of the new additions fall into the advanced category and won't affect what's shown in this tutorial.\n\nLet's start with a brief look at FFmpeg. Note that you can download the scripts shown in this article.\n\nAccording to FFmpeg's About page, \"FFmpeg is the leading multimedia framework, able to decode, encode, transcode, mux, demux, stream, filter and play pretty much anything that humans and machines have created.\" FFmpeg runs on Windows, Mac OS X, Linux, and a wide variety of other build environments and is incredibly useful for a broad range of activities.\n\nFor example, I learned FFmpeg to support the experimentation that went into my book, Video Encoding by the Numbers: Eliminate the Guesswork From Your Streaming Video, which involved thousands of encodes to identify the optimal encoding parameters for H.264, HEVC, and VP9. Trying to perform this testing, as well as the associated quality measurements, with one or more applications would have been impossibly cumbersome.\n\nBeyond encoding, FFmpeg also provides a useful range of functionality, like changing container formats without re-encoding, extracting file sections without re-encoding, and scaling files to different resolutions, all of which made my article, \"Discover the Six FFmpeg Commands You Can't Live Without,\" one of the most popular articles on Streaming Media. Rather than focusing on random tasks, this tutorial will walk you through the fundamentals of encoding with FFmpeg, essentially retracing my learning journey for Encoding by the Numbers.\n\nThere are plenty of tutorials available for getting FFmpeg installed on the platform of your choice. Here are links to installing for Windows, Mac, and Linux.\n\nAll of these tutorials were written for previous versions of FFmpeg, but they should still work if you download FFmpeg 5.0. So, install FFmpeg on your operating system of choice, and let's get started.\n\nWhen you first start using FFmpeg, you'll probably be working via the command line. You'll build a command-line \"argument\" or \"script\" that comprises different configuration options or \"switches\" that tell FFmpeg how to encode. You can feed these arguments to FFmpeg directly in the Command or Terminal window or via batch files, which are text-based files that contain one or more command-line arguments that you can run from the Command window or Windows Explorer.\n\nWhen you're experimenting with your configuration options, you'll typically feed commands directly into the Command window. Once the configuration is set, you'll likely create a batch file to encode multiple files.\n\nIn most, but not all, instances, FFmpeg command-line arguments work the same for all operating systems. One notable exception is the command syntax for two-pass encoding, which differs for Windows and Mac/Linux. I'll cover that later.\n\nHowever, there are multiple minor differences between Windows and Mac/Linux batch files that you'll need to learn. I'll cover the command strings in this article, but not how to create batch files for any operating system.\n\nFigure 1. The most basic FFmpeg encoding script (click for larger image)\n\nFigure 1 shows the most basic FFmpeg encoding script, where you specify the input file, name the output file, and choose the video codec.\n\nWhen you deploy this script, FFmpeg applies many default settings to the encode, as partially shown in Figure 2. I say \"partially\" because there are a lot more defaults applied than those shown, although Figure 2 contains the configuration options we'll consider in this tutorial.\n\nWhen you don't specify a data rate, as I did not in Figure 1, FFmpeg employs the constant rate factor (CRF) encoding technique using a value of 23, which should deliver very good quality at the minimum possible bitrate. In the absence of other direction, FFmpeg sets the keyframe interval at 250, or about 10 seconds for this 24 fps file, and keeps the resolution and frame rate the same as the source. Unless you specify otherwise in the command string, FFmpeg encodes using the H.264's High H.264 profile and the Medium preset.\n\nBy way of background, presets control a number of encoding parameters and enable a producer to choose the desired balance of encoding speed and encoding quality. In Figure 2, you can see that the Medium preset uses three B-frames and three reference frames, but there are many more parameters not shown that are controlled by the preset. Check out go2sm.com/x264 to see all of the configuration options controlled with x264 presets.\n\nIf you change presets, you'll likely change some of these options. Or, you can override the preset-controlled value by specifying a different value for that configuration option in the command string. So, if you added to your command string, FFmpeg would use the Medium preset with one reference frame rather than three. I'm not suggesting that you need to adjust these settings. However, typically in my encodes, I accept most, if not all, of the preset values.\n\nGoing forward to audio, when you select the x264 codec, FFmpeg uses AAC audio compression, which is the default for x264 video encoding. FFmpeg maintains the same audio channels and samples as the source file and applies a bitrate of 128Kbps.\n\nThe key thing to remember is that these defaults simplify encoding. So, if you want to encode at the source resolution and frame rate, and you're OK with the High profile and Medium preset, you don't need to include switches for any of these configuration options in the command line. If the default audio parameters are OK as is, you don't have to include any audio switches in the command line, and most of my command-line arguments don't.\n\nIn most instances, you'll insert a switch into the command string only when you don't need to use the default. This is the case when you're encoding for adaptive bitrate (ABR) streaming because a keyframe (or I-frame) interval of 250 just won't work. To change this and to achieve the desired settings, you'll need to insert switches into every command string created for a file that's produced for ABR delivery.\n\nThe x264 codec uses three different frame types during encoding: I-frame, B-frame, and P-frame. I-frames are self-contained frames that must appear at the start of a file or file segment; otherwise, they might not play correctly. During ABR playback, the player retrieves multiple file segments and plays them back in sequence. So, one key requirement during encoding is to ensure that the first frame in every segment is an I-frame.\n\nTo accomplish this, you must have regular I-frames, and the I-frame interval must divide evenly into the segment size. So, if your segments are 6 seconds long, your I-frame interval must be either 1, 2, 3, or 6, with 2 being the most frequently used.\n\nTo insert I-frames at 2-second intervals, use the switches shown in Figure 3. The first switch, , sets the I-frame interval to 48 frames, or 2 seconds for this 24 fps source file.\n\nHowever, by default, FFmpeg will insert I-frames at scene changes, which can interrupt the placement of I-frames every 48 frames. To prevent this, I set the to 48 and the (scene change threshold) to 0.\n\nFigure 4 shows the GOP view of the file I just encoded in Telestream's Switch, with I-frames in white, P-frames in purple, and B-frames in blue. You can see that the I-frame interval is 48 with no intermediate I-frames, so we've accomplished our goal.\n\nFigure 4. Here’s the encoded file with an I-frame interval of 48 shown in Telestream’s Switch (click for larger image)\n\nNote that FFmpeg almost always presents multiple ways to accomplish any task or goal. For example, there are command sequences that insert I-frames at scene changes and maintain an I-frame at the desired interval. I just never found the qualitative difference worth the trouble and believe that in most instances, simple is better.\n\nLet's tackle a few switches at once as you might do for lower rungs on the encoding ladder. If, for example, you were targeting very old iPhones connecting via 3G, you might want to reduce the resolution to 270 and the frame rate to 12 fps (half the 24-second rate)and use the Baseline profile for playback compatibility. To do all of this, you would add the switches shown in Figure 5 to the command string shown on the bottom.\n\nFigure 5. Creating lower rungs on the encoding ladder (click for larger image)\n\nYou can see in Media­Info on the right that we've achieved the targeted parameters, although the da­ta rate is a bit too high. It's time to tackle bitrate control and two-pass encoding.\n\nSo far, the bitrate for each file has been set by the default switch used when there's no data-rate configuration in the command line. Let's fix that. Figure 6 shows the three switches that impact the video bitrate.\n\nYou can see that sets the video bitrate. If you don't care how the data is distributed in the file, you can just use this switch; you don't need the other two.\n\nAs the name suggests, sets the maximum video bitrate for the file. As shown in Figure 6, if you're attempting to produce a constant bitrate (CBR)-encoded file, you set the maximum at the same rate as the target. For 200% constrained variable bit­rate (VBR) encoding, you set the maximum at twice the target.\n\nThe switch sets the size of the video buffering verifier (VBV), which you can read about at go2sm.com/vbv. As a general rule, larger VBV sizes deliver slightly higher quality, but also greater bitrate variability. If you care about controlling the bitrate, as you would for a CBR encode, you should keep the VBV buffer small, with 1 second a good rule of thumb. If bit­rate variability isn't a concern, and it usually isn't for 200% constrained VBR, you can double that number.\n\nVBR encoding works best when you use two passes: one to scan and gauge the encoding complexity of different sections of the file and the other to perform the actual encoding. Figure 7 shows the command sequence for implementing this and the difference in the first pass between Windows and Mac/Linux.\n\nYou can see the explanations for the new switches in the slide. In the first line, you add a to tell FFmpeg to overwrite any existing log files. Otherwise, if you performed a two-pass encode in that folder before and a log file exists, or if you're encoding multiple files in batch mode, FFmpeg will pause and ask if you want to overwrite the existing log file. If you've left the office thinking you had scheduled a productive night of encoding, you'll be awfully disappointed in the morning.\n\nThen you add to tell FFmpeg that it's the first pass, to identify the output format you'll be producing in the second pass, and to tell FFmpeg to create the Null file, which contains the first pass information. The two ampersands and slash tell FFmpeg to run the second pass if the first pass is successful.\n\nThe second pass contains the to tell FFmpeg to find the NUL file and use that information and the output file name.\n\nSharp-eyed readers will note that the first pass command string contains only the control, while the second pass includes all three data-rate-related commands, thus begging the question, which commands need to go in each pass? This is a complicated issue beyond the scope of this tutorial. For now, assume that it's safe to deploy the data-rate parameters as shown, but for other configuration options, it's safest to include them in both passes.\n\nIf you need to specify the audio parameters in a file, say to change stereo to mono or to set the data rate below 128Kbps, you can use the controls shown in Figure 8. Use these to choose the codec, bitrate, channels, and sample rate.\n\nHere are a couple of points about FFmpeg. First, the configuration options previously shown work well for most codecs, but each codec has different commands. Also, FFmpeg is very resilient, and if a configuration option is incorrect, it will typically finish the process even if the process doesn't accomplish what you want it to. If you check the Command window, however, you may notice errors in yellow or red.\n\nThis is what you see in Figure 9, where I changed the codec to VP9, which doesn't recognize the command. FFmpeg completed the first pass and would complete the second, but it may insert I-frames at scene changes unless you find the right command for VP9 (there is none). In this case, there's no harm done, but that may not always be the case. So pay attention to the Command or Terminal window while you're experimenting.\n\nFigure 9. Watch the Command window for errors that may mean you’re not achieving your goals (click for larger image)\n\nThe second point is to check your results after each encode. Telestream's Switch, shown in Figure 4, is a fabulous tool for viewing the frame structure; Zond 265 is another.\n\nStill another useful tool is MediaInfo, which can display the compression-related metadata that's stored in the FFmpeg-encoded file (see Figure 10. You can see this data in all MediaInfo views, although the HTML view is the best. This information lets you verify the parameters that you've applied—or tried to apply—and allows you to explore video files from other developers to check their encoding parameters.\n\nFigure 10. Checking your encode in MediaInfo (click for larger image)\n\nFor example, in Figure 10, you can see that is set to 25 even though the command string requested 48. While this doesn't have any practical impact because the scene change threshold is set to 0, it shows that you always need to verify your encoding parameters before you take them into production.\n\nThe bottom line with FFmpeg (and all encoders, really) is that you can't assume your command string is correct simply because the encoder creates a file. You have to verify that your encoding parameters are as you expected.\n\n[Editor's note: This article first appeared in the 2022 Streaming Media Industry Sourcebook.]"
    }
]