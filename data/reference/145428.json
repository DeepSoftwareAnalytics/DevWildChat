[
    {
        "link": "https://stackoverflow.com/questions/53787687/using-a-struct-to-determine-a-point-in-a-plane-c",
        "document": "ISSUE: Trying to figure out a point in a place and , then represent the point in a place as a structure having two fields.\n\nSo depending on the function that accepts the structure, it will return either 1, 2, 3, or 4. (Those are the 4 quadrants)\n\nIf x and y are positive, quadrant 1, if x is negative and y is positive, 2 If x is negative and y is negative, quadrant 3, and if x is positive and y is negative, quadrant 4.\n\nMost of my issue is not completely understanding the question, do I take in 2 values for x and y using the struct and return the number?\n\nAlso, how do I interact with my struct? Hope I provided enough info, that's pretty much all I have."
    },
    {
        "link": "https://w3schools.com/cpp/cpp_structs.asp",
        "document": "Structures (also called structs) are a way to group several related variables into one place. Each variable in the structure is known as a member of the structure.\n\nUnlike an array, a structure can contain many different data types (int, string, bool, etc.).\n\nTo create a structure, use the keyword and declare each of its members inside curly braces.\n\nAfter the declaration, specify the name of the structure variable (myStructure in the example below):\n\nTo access members of a structure, use the dot syntax ( ):\n\nYou can use a comma ( ) to use one structure in many variables:\n\nThis example shows how to use a structure in two different variables:\n\nBy giving a name to the structure, you can treat it as a data type. This means that you can create variables with this structure anywhere in the program at any time.\n\nTo create a named structure, put the name of the structure right after the keyword:\n\nTo declare a variable that uses the structure, use the name of the structure as the data type of the variable:\n\nUse one structure to represent two cars: // Declare a structure named \"car\"\n\n struct car {\n\n string brand;\n\n string model;\n\n int year;\n\n };\n\n \n\n int main() {\n\n // Create a car structure and store it in myCar1;\n\n car myCar1; \n\n myCar1.brand = \"BMW\";\n\n myCar1.model = \"X5\";\n\n myCar1.year = 1999;\n\n \n\n // Create another car structure and store it in myCar2;\n\n car myCar2;\n\n myCar2.brand = \"Ford\";\n\n myCar2.model = \"Mustang\";\n\n myCar2.year = 1969;\n\n \n\n // Print the structure members\n\n cout << myCar1.brand << \" \" << myCar1.model << \" \" << myCar1.year << \"\n\n\";\n\n cout << myCar2.brand << \" \" << myCar2.model << \" \" << myCar2.year << \"\n\n\";\n\n \n\n return 0;\n\n } Try it Yourself »"
    },
    {
        "link": "https://digitalocean.com/community/tutorials/2d-vectors-in-c-plus-plus",
        "document": "Also referred to as vector of vectors, 2D vectors in C++ form the basis of creating matrices, tables, or any other structures, dynamically. Before arriving on the topic of 2D vectors in C++, it is advised to go through the tutorial of using single-dimensional vectors in C++.\n\nIt would be impossible for us to use vectors in C++, if not for the header files that are included at the beginning of the program. To make use of 2D vectors, we include:\n\nInstead of including numerous kinds of Standard Template Libraries (STL) one by one, we can include all of them by:\n\nFirstly, we will learn certain ways of initializing a 2-D vector. The following code snippet explains the initialization of a 2-D vector when all the elements are already known.\n\nAfter running the above code, we get the following output:\n\nThe use of symbolizes that we are working on a vector of vectors. Each value inside the first set of braces, like and are vectors independently.\n\nSince we are working on a two-dimensional data structure, we require two loops for traversing the complete data structure, efficiently. The outer loop moves along the rows, whereas the inner loop traverses the columns.\n\nSpecifying the size for 2D Vector Initialization\n\n2D vectors can be of large sizes. We can not expect the programmer to feed-in every single value. Therefore, we can initialize a 2-D vector on the basis of the number of rows and columns.\n\nThe output would be:\n\nAccording to the standard initialization of a vector, , the first argument denotes the size of the vector whereas the second denotes the default value every cell holds.\n\nIn the above code snippet, we follow two steps of standard initialization:\n• - In this statement, we create a single-dimensional vector called , which has length defined by and default values as . It basically forms each row of our two-dimensional vector.\n• - In this statement, we create our complete two-dimensional vector, by defining every value of the 2-D vector as the created in the last statement.\n\nAfter understanding the above procedure, we can improve our initialization of 2D vectors in C++ by:\n\nThe above code, will provide the similar output as before, since we are doing the exact same thing, but in a single line of code.\n\nIf we remember correctly, the standard initialization looks somewhat like the above one. Creating a two-dimensional vector requires us to set the default value for every element as a single-dimensional vector.\n\nThe last method involves creating a 2-D vector without the knowledge of rows or columns. It is done by:\n\nThe above declaration creates an empty container capable of storing elements in the form of vectors.\n\nInstead of traversing a 2D vector using indices, C++ has a provision of iterators for every specific STL data structure.\n\nThe iterators come in handy when we use certain operations that require an argument for positioning. The two most used functions returning iterator values are:\n• - It returns an iterator to the first vector in a 2-D vector.\n• - It returns an iterator to the end of the 2-D vector.\n\nLet us look at some operations possible on a 2-D vector.\n\nTo add elements at the end of a two-dimensional vector, we use function.\n\nSince our container is a vector of vectors, it would only make sense to push complete vectors inside it. Therefore, the argument passed inside the function must be a vector.\n\nTo add a complete vector at a specific location, we use the function.\n\nThe function requires a positional argument as an iterator not as an integral index. It is followed by a vector that is supposed to be inserted at the specified location.\n\nRemoving elements from 2D vectors in C++\n\nOpposite to the , C++ provides function with the duty of removing the last element from the given vector.\n\nIn the context of this article, function would be responsible for removing the last vector from a 2-D vector.\n\nIn addition to the function, we have an function using which we can remove elements from a specified index.\n\nSimilar to the function, it requires a positional argument as an iterator. To remove all the vectors from the 2-D vector, function can be used.\n\nThe above functions might be enough to get comfortable while using 2-D vectors in C++.\n\nTwo-dimensional vectors in C++ are very easy to use, provided that the programmer is aware of the syntax involved. This kind of vector comes in handy when we solve problems related to matrices, graphs, and other two-dimensional objects.\n\nWe hope that this tutorial enlightened the reader on the topic of using 2-D vectors. Feel free to comment below for any queries related to the topic."
    },
    {
        "link": "https://cs.cmu.edu/~guna/15-123S11/Lectures/Lecture09.pdf",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/structures-in-cpp",
        "document": "C++ Structures are user defined data types which are used to store group of items of different data types. A structure creates a data type that can be used to group items of possibly different types into a single type.\n\nBefore using structure, we have to first define the structure. The struct keyword is used to define a structure as shown:\n\nwhere structure name is name and mem1, mem2 and mem3 are the items it groups. They are also called its members or fields.\n\nThe above is also called Structure Definition. It is not allocated any memory and cannot be used in the program directly. We have to create its variables to use it.\n\nOnce the structure is defined, its variable can be created in a similar way as basic data type variables.\n\nwhere struct_name is the name of the structure and var_name is the name of the variable.\n\nA variable can also be declared with the definition of the structure:\n\nStructure members cannot be initialized with declaration. For example, the following C++ program fails in compilation.\n\nStructure members can be initialized to values provided in the curly braces ‘{}’. For example,\n\nThe values provided in the curly braces {} are sequentially assigned to the members of the structure. In the above example, 0 is assigned to member x, and 1 is assigned to member y.\n\nSince C++ 20, we can also use Designated Initializers to initialize the structure members.\n\nStructure members are accessed using dot operator (.) as shown:\n\nwhere var_name is structure variable and member_name is the name of the structure member. A new value to this member can also be assigned using assignment operator.\n\nThe new value should be of the same type to avoid type mismatch error.\n\nIn C structures, functions were not allowed inside the structure but in C++, we can declare the function inside the structure. They are called member functions while the variables are called data members. C++ structure is way more similar to C++ classes as compared to C structures.\n\nC++ structures also support other class components such as constructor, destructor, access specifiers, etc.\n\nThe size of a structure is determined by the sum of the sizes of its individual data members, with additional padding added by the compiler to ensure proper memory alignment.\n\nIdeally, the size should be the size of all data members i.e. sizeof(char) + 2 * sizeof(int) = 1 + 8 = 9 bytes. But the size comes out to be 12 bytes. This is due to the mentioned structure padding.\n\nIn C++, typedef is used to create an alias for an existing variable. Similarly, with structures, typedef creates an alias for the original name of the structure.\n\nNested structure in C++ refers to a structure that is defined inside another structure. Just as structure members are declared within a structure, one structure can be declared as a member inside another structure.\n\nNotice how there are one more curly braces added in the initialization. This is to initialize the inner structure.\n\nThe inner structure can also be defined directly inside the outer structure even without naming the structure and just by creating a variable name.\n\nIn C++, a pointer to a structure is also known as a structure pointer. It is a pointer that holds the address of the memory location where the structure is stored. The normal way to access structure members is to first dereference the pointer and then use dot operator, but C++ provides –> arrow operator to directly access structure members using pointer to it.\n\nSelf-referential structures are those structures that contains the pointer to the same type as a member. For example,\n\nSuch kind of structures are used in data structures such as linked list, trees, etc.\n\nStructures work similarly like other variables with functions. We can pass a structure to a function or return a structure from a function, just like with other variables. Additionally, we can pass a structure either by value or by reference. However, the recommended approach is to pass a structure by reference, as making a copy of a structure is a costly operation.\n\nStructures are also used return multiple values from the function. Refer to the article to know more – Structure with Functions\n\nBit fields in structures allows us to define the number of bits that a particular data member will occupy. Basically, it specifies the manual size of the structure member in bits. It is useful in memory critical applications such as embedded systems.\n\nIn C++, a structure works similarly to a class, but there are some key differences in between of them. The important difference is how implementation details are handled.\n\nHow is a structure different from a class in C++?\n\nCan a structure have functions in C++?\n\nCan we assign one structure variable to another in C++?\n\nWhat is a structure tag in C++?\n\nHow do you access members of a structure in C++?"
    },
    {
        "link": "https://stackoverflow.com/questions/17333/how-do-you-compare-float-and-double-while-accounting-for-precision-loss",
        "document": "What would be the most efficient way to compare two double or two float values?\n\nBe extremely careful using any of the other suggestions. It all depends on context. I have spent a long time tracing bugs in a system that presumed if . The underlying problems were:\n• None The implicit presumption in an algorithm that if and then .\n• None Using the same epsilon for lines measured in inches and lines measured in mils (.001 inch). That is but . (This is why asks for the epsilon or max ULPS).\n• None The use of the same epsilon for both the cosine of angles and the length of lines!\n• None Using such a compare function to sort items in a collection. (In this case using the builtin C++ operator for doubles produced correct results.) Like I said: it all depends on context and the expected size of and . By the way, is the \"machine epsilon\". It is the difference between and the next value representable by a double. I guess that it could be used in the compare function but only if the expected values are less than 1. (This is in response to @cdv's answer...) Also, if you basically have arithmetic in (here we use doubles to hold int values in certain cases) your arithmetic will be correct. For example will be the same as . This is as long as you do not do things that result in fractions ( ) or do not go outside of the size of an int.\n\nI found that the Google C++ Testing Framework contains a nice cross-platform template-based implementation of AlmostEqual2sComplement which works on both doubles and floats. Given that it is released under the BSD license, using it in your own code should be no problem, as long as you retain the license. I extracted the below code from https://github.com/google/googletest/blob/master/googletest/include/gtest/internal/gtest-internal.h and added the license on top. Be sure to #define GTEST_OS_WINDOWS to some value (or to change the code where it's used to something that fits your codebase - it's BSD licensed after all). double left = // something double right = // something const FloatingPoint<double> lhs(left), rhs(right); if (lhs.AlmostEquals(rhs)) { //they're equal! } // Copyright 2005, Google Inc. // All rights reserved. // // Redistribution and use in source and binary forms, with or without // modification, are permitted provided that the following conditions are // met: // // * Redistributions of source code must retain the above copyright // notice, this list of conditions and the following disclaimer. // * Redistributions in binary form must reproduce the above // copyright notice, this list of conditions and the following disclaimer // in the documentation and/or other materials provided with the // distribution. // * Neither the name of Google Inc. nor the names of its // contributors may be used to endorse or promote products derived from // this software without specific prior written permission. // // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. // // Authors: [email protected] (Zhanyong Wan), [email protected] (Sean Mcafee) // // The Google C++ Testing Framework (Google Test) // This template class serves as a compile-time function from size to // type. It maps a size in bytes to a primitive type with that // size. e.g. // // TypeWithSize<4>::UInt // // is typedef-ed to be unsigned int (unsigned integer made up of 4 // bytes). // // Such functionality should belong to STL, but I cannot find it // there. // // Google Test uses this class in the implementation of floating-point // comparison. // // For now it only handles UInt (unsigned int) as that's all Google Test // needs. Other types can be easily added in the future if need // arises. template <size_t size> class TypeWithSize { public: // This prevents the user from using TypeWithSize<N> with incorrect // values of N. typedef void UInt; }; // The specialization for size 4. template <> class TypeWithSize<4> { public: // unsigned int has size 4 in both gcc and MSVC. // // As base/basictypes.h doesn't compile on Windows, we cannot use // uint32, uint64, and etc here. typedef int Int; typedef unsigned int UInt; }; // The specialization for size 8. template <> class TypeWithSize<8> { public: #if GTEST_OS_WINDOWS typedef __int64 Int; typedef unsigned __int64 UInt; #else typedef long long Int; // NOLINT typedef unsigned long long UInt; // NOLINT #endif // GTEST_OS_WINDOWS }; // This template class represents an IEEE floating-point number // (either single-precision or double-precision, depending on the // template parameters). // // The purpose of this class is to do more sophisticated number // comparison. (Due to round-off error, etc, it's very unlikely that // two floating-points will be equal exactly. Hence a naive // comparison by the == operation often doesn't work.) // // Format of IEEE floating-point: // // The most-significant bit being the leftmost, an IEEE // floating-point looks like // // sign_bit exponent_bits fraction_bits // // Here, sign_bit is a single bit that designates the sign of the // number. // // For float, there are 8 exponent bits and 23 fraction bits. // // For double, there are 11 exponent bits and 52 fraction bits. // // More details can be found at // http://en.wikipedia.org/wiki/IEEE_floating-point_standard. // // Template parameter: // // RawType: the raw floating-point type (either float or double) template <typename RawType> class FloatingPoint { public: // Defines the unsigned integer type that has the same size as the // floating point number. typedef typename TypeWithSize<sizeof(RawType)>::UInt Bits; // Constants. // # of bits in a number. static const size_t kBitCount = 8*sizeof(RawType); // # of fraction bits in a number. static const size_t kFractionBitCount = std::numeric_limits<RawType>::digits - 1; // # of exponent bits in a number. static const size_t kExponentBitCount = kBitCount - 1 - kFractionBitCount; // The mask for the sign bit. static const Bits kSignBitMask = static_cast<Bits>(1) << (kBitCount - 1); // The mask for the fraction bits. static const Bits kFractionBitMask = ~static_cast<Bits>(0) >> (kExponentBitCount + 1); // The mask for the exponent bits. static const Bits kExponentBitMask = ~(kSignBitMask | kFractionBitMask); // How many ULP's (Units in the Last Place) we want to tolerate when // comparing two numbers. The larger the value, the more error we // allow. A 0 value means that two numbers must be exactly the same // to be considered equal. // // The maximum error of a single floating-point operation is 0.5 // units in the last place. On Intel CPU's, all floating-point // calculations are done with 80-bit precision, while double has 64 // bits. Therefore, 4 should be enough for ordinary use. // // See the following article for more details on ULP: // http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm. static const size_t kMaxUlps = 4; // Constructs a FloatingPoint from a raw floating-point number. // // On an Intel CPU, passing a non-normalized NAN (Not a Number) // around may change its bits, although the new value is guaranteed // to be also a NAN. Therefore, don't expect this constructor to // preserve the bits in x when x is a NAN. explicit FloatingPoint(const RawType& x) { u_.value_ = x; } // Static methods // Reinterprets a bit pattern as a floating-point number. // // This function is needed to test the AlmostEquals() method. static RawType ReinterpretBits(const Bits bits) { FloatingPoint fp(0); fp.u_.bits_ = bits; return fp.u_.value_; } // Returns the floating-point number that represent positive infinity. static RawType Infinity() { return ReinterpretBits(kExponentBitMask); } // Non-static methods // Returns the bits that represents this number. const Bits &bits() const { return u_.bits_; } // Returns the exponent bits of this number. Bits exponent_bits() const { return kExponentBitMask & u_.bits_; } // Returns the fraction bits of this number. Bits fraction_bits() const { return kFractionBitMask & u_.bits_; } // Returns the sign bit of this number. Bits sign_bit() const { return kSignBitMask & u_.bits_; } // Returns true iff this is NAN (not a number). bool is_nan() const { // It's a NAN if the exponent bits are all ones and the fraction // bits are not entirely zeros. return (exponent_bits() == kExponentBitMask) && (fraction_bits() != 0); } // Returns true iff this number is at most kMaxUlps ULP's away from // rhs. In particular, this function: // // - returns false if either number is (or both are) NAN. // - treats really large numbers as almost equal to infinity. // - thinks +0.0 and -0.0 are 0 DLP's apart. bool AlmostEquals(const FloatingPoint& rhs) const { // The IEEE standard says that any comparison operation involving // a NAN must return false. if (is_nan() || rhs.is_nan()) return false; return DistanceBetweenSignAndMagnitudeNumbers(u_.bits_, rhs.u_.bits_) <= kMaxUlps; } private: // The data type used to store the actual floating-point number. union FloatingPointUnion { RawType value_; // The raw floating-point number. Bits bits_; // The bits that represent the number. }; // Converts an integer from the sign-and-magnitude representation to // the biased representation. More precisely, let N be 2 to the // power of (kBitCount - 1), an integer x is represented by the // unsigned number x + N. // // For instance, // // -N + 1 (the most negative number representable using // sign-and-magnitude) is represented by 1; // 0 is represented by N; and // N - 1 (the biggest number representable using // sign-and-magnitude) is represented by 2N - 1. // // Read http://en.wikipedia.org/wiki/Signed_number_representations // for more details on signed number representations. static Bits SignAndMagnitudeToBiased(const Bits &sam) { if (kSignBitMask & sam) { // sam represents a negative number. return ~sam + 1; } else { // sam represents a positive number. return kSignBitMask | sam; } } // Given two numbers in the sign-and-magnitude representation, // returns the distance between them as an unsigned number. static Bits DistanceBetweenSignAndMagnitudeNumbers(const Bits &sam1, const Bits &sam2) { const Bits biased1 = SignAndMagnitudeToBiased(sam1); const Bits biased2 = SignAndMagnitudeToBiased(sam2); return (biased1 >= biased2) ? (biased1 - biased2) : (biased2 - biased1); } FloatingPointUnion u_; }; EDIT: This post is 4 years old. It's probably still valid, and the code is nice, but some people found improvements. Best go get the latest version of right from the Google Test source code, and not the one I pasted up here.\n\nYou have to do this processing for floating point comparison, since float's can't be perfectly compared like integer types. Here are functions for the various comparison operators. I also prefer the subtraction technique rather than relying on or , but I'd have to speed profile it on various architectures from 64-bit PC to ATMega328 microcontroller (Arduino) to really see if it makes much of a performance difference. So, let's forget about all this absolute value stuff and just do some subtraction and comparison! Modified from Microsoft's example here: /// @brief See if two floating point numbers are approximately equal. /// @param[in] a number 1 /// @param[in] b number 2 /// @param[in] epsilon A small value such that if the difference between the two numbers is /// smaller than this they can safely be considered to be equal. /// @return true if the two numbers are approximately equal, and false otherwise bool is_float_eq(float a, float b, float epsilon) { return ((a - b) < epsilon) && ((b - a) < epsilon); } bool is_double_eq(double a, double b, double epsilon) { return ((a - b) < epsilon) && ((b - a) < epsilon); } I'm not entirely sure, but it seems to me some of the criticisms of the epsilon-based approach, as described in the comments below this highly-upvoted answer, can be resolved by using a variable epsilon, scaled according to the floating point values being compared, like this: This way, the epsilon value scales with the floating point values and is therefore never so small of a value that it becomes insignificant. Greater than ( ), and less than ( ): /// @brief See if floating point number `a` is > `b` /// @param[in] a number 1 /// @param[in] b number 2 /// @param[in] epsilon a small value such that if `a` is > `b` by this amount, `a` is considered /// to be definitively > `b` /// @return true if `a` is definitively > `b`, and false otherwise bool is_float_gt(float a, float b, float epsilon) { return a > b + epsilon; } bool is_double_gt(double a, double b, double epsilon) { return a > b + epsilon; } /// @brief See if floating point number `a` is < `b` /// @param[in] a number 1 /// @param[in] b number 2 /// @param[in] epsilon a small value such that if `a` is < `b` by this amount, `a` is considered /// to be definitively < `b` /// @return true if `a` is definitively < `b`, and false otherwise bool is_float_lt(float a, float b, float epsilon) { return a < b - epsilon; } bool is_double_lt(double a, double b, double epsilon) { return a < b - epsilon; } Greater than or equal to ( ), and less than or equal to ( ) /// @brief Returns true if `a` is definitively >= `b`, and false otherwise bool is_float_ge(float a, float b, float epsilon) { return a > b - epsilon; } bool is_double_ge(double a, double b, double epsilon) { return a > b - epsilon; } /// @brief Returns true if `a` is definitively <= `b`, and false otherwise bool is_float_le(float a, float b, float epsilon) { return a < b + epsilon; } bool is_double_le(double a, double b, double epsilon) { return a < b + epsilon; }\n• A good default value for in C++ is , which evaluates to either or , , or . See here: https://en.cppreference.com/w/cpp/types/numeric_limits/epsilon. You can also see the header for , , and .\n• You could template the functions instead, to handle all floating point types: , , and , with type checks for these types via a inside the template.\n• Scaling the value is a good idea to ensure it works for really large and really small and values. This article recommends and explains it: http://realtimecollisiondetection.net/blog/?p=89. So, you should scale epsilon by a scaling value equal to , as that article explains. Otherwise, as and/or increase in magnitude, the epsilon would eventually become so small relative to those values that it becomes lost in the floating point error. So, we scale it to become larger in magnitude like they are. However, using as the smallest allowed scaling factor for epsilon also ensures that for really small-magnitude and values, epsilon itself doesn't get scaled so small that it also becomes lost in the floating point error. So, we limit the minimum scaling factor to . This means that for an epsilon value of , for instance, the resulting value would be .\n• If you want to \"encapsulate\" the above functions into a class, don't. Instead, wrap them up in a namespace if you like in order to namespace them. Ex: if you put all of the stand-alone functions into a namespace called , then you could access the function like this, for instance: .\n• It might also be nice to add comparisons against zero, not just comparisons between two values.\n• So, here is a better type of solution with the above improvements in place: namespace float_comparison { /// Scale the epsilon value to become large for large-magnitude a or b, /// but no smaller than 1.0, per the explanation above, to ensure that /// epsilon doesn't ever fall out in floating point error as a and/or b /// increase in magnitude. template<typename T> static constexpr T scale_epsilon(T a, T b, T epsilon = std::numeric_limits<T>::epsilon()) noexcept { static_assert(std::is_floating_point_v<T>, \"Floating point comparisons \" \"require type float, double, or long double.\"); T scaling_factor; // Special case for when a or b is infinity if (std::isinf(a) || std::isinf(b)) { scaling_factor = 0; } else { scaling_factor = std::max({(T)1.0, std::abs(a), std::abs(b)}); } T epsilon_scaled = scaling_factor * std::abs(epsilon); return epsilon_scaled; } // Compare two values /// Equal: returns true if a is approximately == b, and false otherwise template<typename T> static constexpr bool is_eq(T a, T b, T epsilon = std::numeric_limits<T>::epsilon()) noexcept { static_assert(std::is_floating_point_v<T>, \"Floating point comparisons \" \"require type float, double, or long double.\"); // test `a == b` first to see if both a and b are either infinity // or -infinity return a == b || std::abs(a - b) <= scale_epsilon(a, b, epsilon); } /* etc. etc.: is_eq() is_ne() is_lt() is_le() is_gt() is_ge() */ // Compare against zero /// Equal: returns true if a is approximately == 0, and false otherwise template<typename T> static constexpr bool is_eq_zero(T a, T epsilon = std::numeric_limits<T>::epsilon()) noexcept { static_assert(std::is_floating_point_v<T>, \"Floating point comparisons \" \"require type float, double, or long double.\"); return is_eq(a, (T)0.0, epsilon); } /* etc. etc.: is_eq_zero() is_ne_zero() is_lt_zero() is_le_zero() is_gt_zero() is_ge_zero() */ } // namespace float_comparison\n• The macro forms of some of the functions above in my repo here: utilities.h.\n• UPDATE 29 NOV 2020: it's a work-in-progress, and I'm going to make it a separate answer when ready, but I've produced a better, scaled-epsilon version of all of the functions in C in this file here: utilities.c. Take a look.\n• ADDITIONAL READING I need to do now have done: Floating-point tolerances revisited, by Christer Ericson. VERY USEFUL ARTICLE! It talks about scaling epsilon in order to ensure it never falls out in floating point error, even for really large-magnitude and/or values!"
    },
    {
        "link": "https://stackoverflow.com/questions/63189893/comparing-floats-in-c",
        "document": "I'm learning c++ from a tutorial and there, I was told that comparing floats in c++ can be very comfusing. For example, in the below code:\n\nI would get \"not equal\". I agree on this point. The tutor told that If we need to compare floats, we can use > to the nearest number. (that would not be very precise). I searched for different ways to compare floats in google and I got many complex ways of doing that.\n\nAfter type-casting like above, I got \"Equal\".\n\nThe thing I want to know is that should I use the above way to compare floats in all of my programs? Does this have some cons?\n\nNote : I know how a number is represented exactly in the memory and how 0.1 + 0.2 !- 0.3 as described in another SO Question. I just want to know that can I check the equality of two floats in the above way?"
    },
    {
        "link": "https://geeksforgeeks.org/problem-in-comparing-floating-point-numbers-and-how-to-compare-them-correctly",
        "document": "Problem in comparing Floating point numbers and how to compare them correctly?\n\nIn this article, we will see what is the problem in comparing floating-point numbers and we will discuss the correct way to compare two floating-point numbers. \n\n What is the problem in comparing Floating-Point Numbers usually? \n\nLet us first compare two floating-point numbers with the help of relational operator (==).\n\nExample: Using “==” for comparison\n\n\n\nTime complexity of this program is O(1), as it only performs a comparison between two floating point numbers.\n\nThe space complexity is also O(1), as the program uses only a constant amount of memory for storing the two floating point numbers and a few local variables used for the comparison.\n\nWhy does this problem occur? \n\nIn the case of floating-point numbers, the relational operator (==) does not produce correct output, this is due to the internal precision errors in rounding up floating-point numbers.\n\nIn the above example, we can see the inaccuracy in comparing two floating-point numbers using “==” operator. The two numbers ‘a’ and ‘b’ are equal ( as (0.3 * 3) + 0.1 = 1 ) but the program results in an incorrect output.\n\nLet’s take a closer look at the numbers in the next snippet.\n\n\n\nTime complexity:\n\nThe program has a constant time complexity, as it only performs a fixed set of operations and does not depend on the input size. Therefore, the time complexity is O(1).\n\nSpace complexity:\n\nThe program uses a fixed amount of memory for the double variables a and b, as well as for the output printed to the console. Therefore, the space complexity is also O(1).\n\nNow we can see the internal rounding error in floating-point numbers. Number ‘a’ is not correctly rounded up to 1, \n\nthere is an internal error in rounding up, a very small error but makes a huge difference when we are comparing the numbers.\n\n \n\nIf we do have to compare two floating-point numbers then rather than using “==” operator we will find the absolute difference between the numbers (which if were correctly represented, the difference would have been 0) and compare it with a very small number 1e-9 (i.e 10^-9, this number is very small) and if the difference is less than this number, we can safely say that the two floating-point numbers are equal.\n\nExample: \n\n\n\nThis code results in the correct output, so whenever two floating point numbers are two be compared then rather than using “==” operator, we will use the above technique."
    },
    {
        "link": "https://reddit.com/r/cpp/comments/tavh14/comparing_floatingpoint_numbers_is_tricky",
        "document": "Create your account and connect with a world of communities.\n\nBy continuing, you agree to our\n\nand acknowledge that you understand the"
    },
    {
        "link": "https://quora.com/What-is-the-best-way-to-tackle-floating-point-precision-issues-in-C",
        "document": "Something went wrong. Wait a moment and try again."
    }
]