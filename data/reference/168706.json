[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions",
        "document": "Functions are one of the fundamental building blocks in JavaScript. A function in JavaScript is similar to a procedure—a set of statements that performs a task or calculates a value, but for a procedure to qualify as a function, it should take some input and return an output where there is some obvious relationship between the input and the output. To use a function, you must define it somewhere in the scope from which you wish to call it. See also the exhaustive reference chapter about JavaScript functions to get to know the details.\n\nA function definition (also called a function declaration, or function statement) consists of the keyword, followed by:\n• The name of the function.\n• A list of parameters to the function, enclosed in parentheses and separated by commas.\n• The JavaScript statements that define the function, enclosed in curly braces, . For example, the following code defines a function named : The function takes one parameter, called . The function consists of one statement that says to return the parameter of the function (that is, ) multiplied by itself. The statement specifies the value returned by the function, which is . Parameters are essentially passed to functions by value — so if the code within the body of a function assigns a completely new value to a parameter that was passed to the function, the change is not reflected globally or in the code which called that function. When you pass an object as a parameter, if the function changes the object's properties, that change is visible outside the function, as shown in the following example: When you pass an array as a parameter, if the function changes any of the array's values, that change is visible outside the function, as shown in the following example: Function declarations and expressions can be nested, which forms a scope chain. For example: See function scopes and closures for more information.\n\nWhile the function declaration above is syntactically a statement, functions can also be created by a function expression. Such a function can be anonymous; it does not have to have a name. For example, the function could have been defined as: However, a name can be provided with a function expression. Providing a name allows the function to refer to itself, and also makes it easier to identify the function in a debugger's stack traces: Function expressions are convenient when passing a function as an argument to another function. The following example defines a function that should receive a function as first argument and an array as second argument. Then, it is called with a function defined by a function expression: function map(f, a) { const result = new Array(a.length); for (let i = 0; i < a.length; i++) { result[i] = f(a[i]); } return result; } const numbers = [0, 1, 2, 5, 10]; const cubedNumbers = map(function (x) { return x * x * x; }, numbers); console.log(cubedNumbers); // [0, 1, 8, 125, 1000] In JavaScript, a function can be defined based on a condition. For example, the following function definition defines only if equals : In addition to defining functions as described here, you can also use the constructor to create functions from a string at runtime, much like . A method is a function that is a property of an object. Read more about objects and methods in Working with objects.\n\nDefining a function does not execute it. Defining it names the function and specifies what to do when the function is called. Calling the function actually performs the specified actions with the indicated parameters. For example, if you define the function , you could call it as follows: The preceding statement calls the function with an argument of . The function executes its statements and returns the value . Functions must be in scope when they are called, but the function declaration can be hoisted (appear below the call in the code). The scope of a function declaration is the function in which it is declared (or the entire program, if it is declared at the top level). The arguments of a function are not limited to strings and numbers. You can pass whole objects to a function. The function (defined in Working with objects) is an example of a function that takes an object as an argument. A function can call itself. For example, here is a function that computes factorials recursively: You could then compute the factorials of through as follows: There are other ways to call functions. There are often cases where a function needs to be called dynamically, or the number of arguments to a function vary, or in which the context of the function call needs to be set to a specific object determined at runtime. It turns out that functions are themselves objects — and in turn, these objects have methods. (See the object.) The and methods can be used to achieve this goal.\n\nA function can refer to and call itself. It can be referred to either by the function expression or declaration's name, or via any in-scope variable that refers to the function object. For example, consider the following function definition: Within the function body, you can refer to the function itself either as or , and call itself using or . A function that calls itself is called a recursive function. In some ways, recursion is analogous to a loop. Both execute the same code multiple times, and both require a condition (to avoid an infinite loop, or rather, infinite recursion in this case). For example, consider the following loop: let x = 0; // \"x < 10\" is the loop condition while (x < 10) { // do stuff x++; } It can be converted into a recursive function declaration, followed by a call to that function: function loop(x) { // \"x >= 10\" is the exit condition (equivalent to \"!(x < 10)\") if (x >= 10) { return; } // do stuff loop(x + 1); // the recursive call } loop(0); However, some algorithms cannot be simple iterative loops. For example, getting all the nodes of a tree structure (such as the DOM) is easier via recursion: function walkTree(node) { if (node === null) { return; } // do something with node for (let i = 0; i < node.childNodes.length; i++) { walkTree(node.childNodes[i]); } } Compared to the function , each recursive call itself makes many recursive calls here. It is possible to convert any recursive algorithm to a non-recursive one, but the logic is often much more complex, and doing so requires the use of a stack. In fact, recursion itself uses a stack: the function stack. The stack-like behavior can be seen in the following example:\n\nWe also refer to the function body as a closure. A closure is any piece of source code (most commonly, a function) that refers to some variables, and the closure \"remembers\" these variables even when the scope in which these variables were declared has exited. Closures are usually illustrated with nested functions to show that they remember variables beyond the lifetime of its parent scope; but in fact, nested functions are unnecessary. Technically speaking, all functions in JavaScript form closures—some just don't capture anything, and closures don't even have to be functions. The key ingredients for a useful closure are the following:\n• A parent scope that defines some variables or functions. It should have a clear lifetime, which means it should finish execution at some point. Any scope that's not the global scope satisfies this requirement; this includes blocks, functions, modules, and more.\n• An inner scope defined within the parent scope, which refers to some variables or functions defined in the parent scope.\n• The inner scope manages to survive beyond the lifetime of the parent scope. For example, it is saved to a variable that's defined outside the parent scope, or it's returned from the parent scope (if the parent scope is a function).\n• Then, when you call the function outside of the parent scope, you can still access the variables or functions that were defined in the parent scope, even though the parent scope has finished execution. The following is a typical example of a closure: // The outer function defines a variable called \"name\" const pet = function (name) { const getName = function () { // The inner function has access to the \"name\" variable of the outer function return name; }; return getName; // Return the inner function, thereby exposing it to outer scopes }; const myPet = pet(\"Vivie\"); console.log(myPet()); // \"Vivie\" It can be much more complex than the code above. An object containing methods for manipulating the inner variables of the outer function can be returned. const createPet = function (name) { let sex; const pet = { // setName(newName) is equivalent to setName: function (newName) // in this context setName(newName) { name = newName; }, getName() { return name; }, getSex() { return sex; }, setSex(newSex) { if ( typeof newSex === \"string\" && (newSex.toLowerCase() === \"male\" || newSex.toLowerCase() === \"female\") ) { sex = newSex; } }, }; return pet; }; const pet = createPet(\"Vivie\"); console.log(pet.getName()); // Vivie pet.setName(\"Oliver\"); pet.setSex(\"male\"); console.log(pet.getSex()); // male console.log(pet.getName()); // Oliver In the code above, the variable of the outer function is accessible to the inner functions, and there is no other way to access the inner variables except through the inner functions. The inner variables of the inner functions act as safe stores for the outer arguments and variables. They hold \"persistent\" and \"encapsulated\" data for the inner functions to work with. The functions do not even have to be assigned to a variable, or have a name. const getCode = (function () { const apiCode = \"0]Eal(eh&2\"; // A code we do not want outsiders to be able to modify… return function () { return apiCode; }; })(); console.log(getCode()); // \"0]Eal(eh&2\" In the code above, we use the IIFE pattern. Within this IIFE scope, two values exist: a variable and an unnamed function that gets returned and gets assigned to the variable . is in the scope of the returned unnamed function but not in the scope of any other part of the program, so there is no way for reading the value of apart from via the function.\n\nThe arguments of a function are maintained in an array-like object. Within a function, you can address the arguments passed to it as follows: where is the ordinal number of the argument, starting at . So, the first argument passed to a function would be . The total number of arguments is indicated by . Using the object, you can call a function with more arguments than it is formally declared to accept. This is often useful if you don't know in advance how many arguments will be passed to the function. You can use to determine the number of arguments actually passed to the function, and then access each argument using the object. For example, consider a function that concatenates several strings. The only formal argument for the function is a string that specifies the characters that separate the items to concatenate. The function is defined as follows: function myConcat(separator) { let result = \"\"; // initialize list // iterate through arguments for (let i = 1; i < arguments.length; i++) { result += arguments[i] + separator; } return result; } You can pass any number of arguments to this function, and it concatenates each argument into a string \"list\": Note: The variable is \"array-like\", but not an array. It is array-like in that it has a numbered index and a property. However, it does not possess all of the array-manipulation methods. See the object in the JavaScript reference for more information."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions",
        "document": "Generally speaking, a function is a \"subprogram\" that can be called by code external (or internal, in the case of recursion) to the function. Like the program itself, a function is composed of a sequence of statements called the function body. Values can be passed to a function as parameters, and the function will return a value. In JavaScript, functions are first-class objects, because they can be passed to other functions, returned from functions, and assigned to variables and properties. They can also have properties and methods just like any other object. What distinguishes them from other objects is that functions can be called. For more examples and explanations, see the JavaScript guide about functions.\n\nParameters and arguments have slightly different meanings, but in MDN web docs, we often use them interchangeably. For a quick reference: In this example, the variable is called the function's parameter: it's declared in the parenthesis-enclosed list of the function's definition. The function expects the parameter to be a number — although this is not enforceable in JavaScript without writing runtime validation code. In the call, the number is the function's argument: it's the value that is actually passed to the function in the function call. The argument value can be accessed inside the function body through the corresponding parameter name or the object. Arguments are always passed by value and never passed by reference. This means that if a function reassigns a parameter, the value won't change outside the function. More precisely, object arguments are passed by sharing, which means if the object's properties are mutated, the change will impact the outside of the function. For example: function updateBrand(obj) { // Mutating the object is visible outside the function obj.brand = \"Toyota\"; // Try to reassign the parameter, but this won't affect // the variable's value outside the function obj = null; } const car = { brand: \"Honda\", model: \"Accord\", year: 1998, }; console.log(car.brand); // Honda // Pass object reference to the function updateBrand(car); // updateBrand mutates car console.log(car.brand); // Toyota The keyword refers to the object that the function is accessed on — it does not refer to the currently executing function, so you must refer to the function value by name, even within the function body.\n\nBroadly speaking, JavaScript has four kinds of functions:\n• Regular function: can return anything; always runs to completion after invocation\n• Generator function: returns a object; can be paused and resumed with the operator\n• Async function: returns a ; can be paused and resumed with the operator\n• Async generator function: returns an object; both the and operators can be used For every kind of function, there are multiple ways to define it: In addition, there are special syntaxes for defining arrow functions and methods, which provide more precise semantics for their usage. Classes are conceptually not functions (because they throw an error when called without ), but they also inherit from and have . // Constructor const multiply = new Function(\"x\", \"y\", \"return x * y\"); // Declaration function multiply(x, y) { return x * y; } // No need for semicolon here // Expression; the function is anonymous but assigned to a variable const multiply = function (x, y) { return x * y; }; // Expression; the function has its own name const multiply = function funcName(x, y) { return x * y; }; // Arrow function const multiply = (x, y) => x * y; // Method const obj = { multiply(x, y) { return x * y; }, }; All syntaxes do approximately the same thing, but there are some subtle behavior differences.\n• The constructor, expression, and declaration syntaxes create full-fledged function objects, which can be constructed with . However, arrow functions and methods cannot be constructed. Async functions, generator functions, and async generator functions are not constructible regardless of syntax.\n• The declaration creates functions that are hoisted. Other syntaxes do not hoist the function and the function value is only visible after the definition.\n• The arrow function and constructor always create anonymous functions, which means they can't easily call themselves recursively. One way to call an arrow function recursively is by assigning it to a variable.\n• The arrow function syntax does not have access to or .\n• The constructor cannot access any local variables — it only has access to the global scope.\n• The constructor causes runtime compilation and is often slower than other syntaxes. For expressions, there is a distinction between the function name and the variable the function is assigned to. The function name cannot be changed, while the variable the function is assigned to can be reassigned. The function name can be different from the variable the function is assigned to — they have no relation to each other. The function name can be used only within the function's body. Attempting to use it outside the function's body results in an error (or gets another value, if the same name is declared elsewhere). For example: On the other hand, the variable the function is assigned to is limited only by its scope, which is guaranteed to include the scope in which the function is declared. A function declaration also creates a variable with the same name as the function name. Thus, unlike those defined by function expressions, functions defined by function declarations can be accessed by their name in the scope they were defined in, as well as in their own body. A function defined by will dynamically have its source assembled, which is observable when you serialize it. For example, gives: This is the actual source used to compile the function. However, although the constructor will create the function with name , this name is not added to the scope of the body. The body only ever has access to global variables. For example, the following would result in an error: A function defined by a function expression or by a function declaration inherits the current scope. That is, the function forms a closure. On the other hand, a function defined by a constructor does not inherit any scope other than the global scope (which all functions inherit). // p is a global variable globalThis.p = 5; function myFunc() { // p is a local variable const p = 9; function decl() { console.log(p); } const expr = function () { console.log(p); }; const cons = new Function(\"\\tconsole.log(p);\"); decl(); expr(); cons(); } myFunc(); // Logs: // 9 (for 'decl' by function declaration (current scope)) // 9 (for 'expr' by function expression (current scope)) // 5 (for 'cons' by Function constructor (global scope)) Functions defined by function expressions and function declarations are parsed only once, while a function defined by the constructor parses the string passed to it each and every time the constructor is called. Although a function expression creates a closure every time, the function body is not reparsed, so function expressions are still faster than . Therefore the constructor should generally be avoided whenever possible. A function declaration may be unintentionally turned into a function expression when it appears in an expression context. On the other hand, a function expression may also be turned into a function declaration. An expression statement cannot begin with the or keywords, which is a common mistake when implementing IIFEs (Immediately Invoked Function Expressions). Instead, start the expression statement with something else, so that the keyword unambiguously starts a function expression. Common options include grouping and using .\n\nIn non-strict code, function declarations inside blocks behave strangely. For example: if (shouldDefineZero) { function zero() { // DANGER: compatibility risk console.log(\"This is zero.\"); } } The semantics of this in strict mode are well-specified — only ever exists within that scope of the block. If is false, then should never be defined, since the block never executes. However, historically, this was left unspecified, so different browsers implemented it differently in non-strict mode. For more information, see the declaration reference. A safer way to define functions conditionally is to assign a function expression to a variable: // Using a var makes it available as a global variable, // with closer behavior to a top-level function declaration var zero; if (shouldDefineZero) { zero = function () { console.log(\"This is zero.\"); }; }"
    },
    {
        "link": "https://geeksforgeeks.org/pure-functions-in-javascript",
        "document": "A Pure Function is a function (a block of code) that always returns the same result if the same arguments are passed.\n• None They do not modify external states or depend on mutable data.\n• None Often used with immutable data structures to ensure reliability.\n• None Their independence from external states makes them highly reusable.\n• None It always returns the same result for the same input.\n• None It does not modify any external variables or state.\n• Deterministic Output: For a given set of inputs, the output is always the same.\n• No Side Effects: The function does not:\n• None Interact with external systems like APIs, databases, or DOM manipulation.\n• Immutability: Pure functions do not change the input values; instead, they return a new value or object.\n\nExample of a Function with Side Effects\n\nHere, increment is not a pure function because it modifies the external variable count.\n\nImpure functions produce unpredictable results or affect external states, which can lead to bugs and make your code harder to test.\n• Data Transformation: Use pure functions in map, filter, and reduce operations for processing data.\n• Unit Testing: Pure functions are ideal for unit tests because they have predictable outputs.\n• Performance Optimization: Pure functions are easily memoized, as their outputs depend solely on inputs."
    },
    {
        "link": "https://syncfusion.com/blogs/post/pure-impure-functions-javascript",
        "document": "Pure functions and impure functions are two common terms used in JavaScript. On the surface level, both functions look identical.\n\nHowever, if we look closer, there are some major differences between them. As developers, it is essential to understand the similarities and differences of these functions to get the most out of them.\n\nIn this article, I will discuss pure and impure JavaScript functions in depth and highlight their uses, advantages, and differences.\n\nIn simple terms, pure functions do not have an internal state. Therefore, all operations performed in pure functions are not affected by their state. As a result, the same input parameters will give the same deterministic output regardless of how many times you run the function.\n\nTo get a better understanding, let’s consider the following example.\n\nThis example contains a simple add() function, which gives 9 as the output. It is a very predictable output, and it does not depend on any external code. This makes the add() function a pure function.\n\nIf a function is declared pure and does not have a state, it can share many instances inside a class. Also, it is advised to avoid mutations inside pure functions.\n• A pure function works as an independent function that gives the same output for the same inputs.\n• Pure functions are readable because of independent behavior. Moreover, they are straightforward to debug.\n• You can clone an external state into a pure function, but it does not change the purity of the function.\n\nAn impure function is a function that contains one or more side effects. It mutates data outside of its lexical scope and does not predictably produce the same output for the same input.\n\nFor example, consider the following code snippet:\n\nIn the above example, there is a variable named addNew, and it is declared outside of the add() function. But the state of that variable is changed inside the add() function. So, the add() function has a side effect on a variable outside of its scope and is therefore considered an impure function.\n\nJavaScript doesn’t adhere to rigorous notions of function purity and immutability. Any program you develop will need impure functions to modify the state of JavaScript variables (named memory locations).\n\nIn general, it’s ideal to keep the impure elements of your programs distinct from the data processing, which is usually pure. Also, updating and maintaining your applications will be much easier if you confine impure elements to their particular functions.\n\nThe following JavaScript functions are inherently impure:\n• Math.random()\n\n Math.random() is an impure function since it modifies the internal state of the Math object and provides different results with each call. So Math.random() can contain side effects. In the above code snippet, no arguments pass into any of the Math.random() function calls, but still they all produce a different result.\n• console.log() and alert() are also impure functions (although they generate the same behavior and always return the same value for identical calls).\n• JavaScript is synchronous by its nature. Therefore, asynchronous functions such as fetch and promise are impure.\n• Impure functions can use an in-place solution to reduce the space complexity.\n• In impure functions, the state can be modified to use the parent variable and call for the function compiling.\n\nAs mentioned, the main difference between pure and impure functions in JavaScript is side effects. So, let’s discuss some specifics about the side effects.\n\nSide effects can occur in your program when it uses an external code block inside a function. As a result, there can be performance issues in your application.\n\nLet’s consider the following example and discuss the side effects in detail.\n\nIn the above example, the variable preNumber is used inside the addValue() function. This behavior can result in the following side effects.\n\nThe addValue() method depends on the preNumber variable. If preNumber is not defined or not available, the method will throw an error.\n\nWhen the addValue() function executes, it changes the state of the preNumber variable. It shows that the addValue() method has a side effect of modifying external code.\n\nThe addValue() function uses external code. It makes the function non-deterministic, which means you cannot determine the output by looking.\n\nLet’s compare and contrast the differences between pure and impure functions:\n• Pure functions do not have side effects. Impure functions can cause side effects.\n• Pure functions return the same output if we use the same input parameters. However, impure functions give different outcomes when we pass the same arguments multiple times.\n• Pure functions always return some results. Impure functions can execute without producing anything.\n• Debugging pure functions is relatively easier than debugging impure functions.\n• Impure functions aren’t inherently wrong. They merely can cause some confusion in more extensive systems in the form of spaghetti code.\n\nIn this article, I discussed the pure and impure functions in JavaScript and compared the differences between them.\n\nOverall, using pure functions will avoid unnecessary issues in your code. However, we can’t always stick to pure functions. There are situations where we need to use impure functions. We must be mindful of the side effects and minimize unnecessary issues in such situations.\n\nSyncfusion has 80+ JavaScript UI controls to improve developer productivity. Using the Syncfusion JavaScript UI controls in your application can reduce development time exponentially. The main controls in the JavaScript suite are DataGrid, Charts, and Scheduler.\n\nI hope you found this article useful. Thank you for reading."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript",
        "document": "JavaScript (JS) is a lightweight interpreted (or just-in-time compiled) programming language with first-class functions. While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js, Apache CouchDB and Adobe Acrobat. JavaScript is a prototype-based, multi-paradigm, single-threaded, dynamic language, supporting object-oriented, imperative, and declarative (e.g. functional programming) styles.\n\nJavaScript's dynamic capabilities include runtime object construction, variable parameter lists, function variables, dynamic script creation (via ), object introspection (via and utilities), and source-code recovery (JavaScript functions store their source text and can be retrieved through ).\n\nThis section is dedicated to the JavaScript language itself, and not the parts that are specific to Web pages or other host environments. For information about APIs that are specific to Web pages, please see Web APIs and DOM.\n\nThe standards for JavaScript are the ECMAScript Language Specification (ECMA-262) and the ECMAScript Internationalization API specification (ECMA-402). As soon as one browser implements a feature, we try to document it. This means that cases where some proposals for new ECMAScript features have already been implemented in browsers, documentation and examples in MDN articles may use some of those new features. Most of the time, this happens between the stages 3 and 4, and is usually before the spec is officially published.\n\nDo not confuse JavaScript with the Java programming language — JavaScript is not \"Interpreted Java\". Both \"Java\" and \"JavaScript\" are trademarks or registered trademarks of Oracle in the U.S. and other countries. However, the two programming languages have very different syntax, semantics, and use.\n\nJavaScript documentation of core language features (pure ECMAScript, for the most part) includes the following:\n\nFor more information about JavaScript specifications and related technologies, see JavaScript technologies overview."
    },
    {
        "link": "https://blog.logrocket.com/axios-vs-fetch-best-http-requests",
        "document": "Editor’s note: This Axios vs. article was last reviewed and updated by Rosario De Chiara on 21 November 2024.\n\nIs Axios better than ?\n\nIn the article “How to make HTTP requests like a pro with Axios,” I discussed the benefits of using the Axios library.\n\nHowever, Axios isn’t always the ideal solution for making HTTP requests. A popular alternative to Axios for handling HTTP/GET/POST/etc. requests in JavaScript is the native API. Understanding these technologies’ strengths, differences, and use cases is crucial for modern web development.\n\nHere are some differences worth noting between the two solutions:\n\nSome developers prefer Axios over built-in APIs for their ease of use. But many overestimate the need for such a library. The API is perfectly capable of reproducing the key features of Axios, and it has the added advantage of being readily available in all modern browsers.\n\nIn this article, we’ll compare and Axios to see how they can be used to perform different tasks. At the end of the article, you should have a better understanding of both APIs.\n\nUnderstanding the basic syntax of Axios and\n\nBefore we delve into more advanced features of Axios, let’s compare its basic syntax to .\n\n Here’s how you can use Axios to send a request with custom headers to a URL. Axios automatically converts the data to JSON, so you don’t have to:\n\nNow compare this code to the version, which produces the same result:\n• To send data, uses the property for a post request to send data to the endpoint, while Axios uses the property\n• The data in is transformed into a string using the method\n• Axios automatically transforms the data returned from the server, but with you have to call the method to parse the data to a JavaScript object\n• With Axios, the data response provided by the server can be accessed within the data object, while for the method, the final data can be named any variable\n• Axios and handle headers in the same way\n\nOne of the main selling points of Axios is its wide browser support. Even old browsers like IE11 can run Axios without any issues. This is because it uses under the hood. , on the other hand, only supports Chrome 42+, Firefox 39+, Edge 14+, and Safari 10.1+ (you can see the full compatibility table on CanIUse.com).\n\nIf your only reason for using Axios is backward compatibility, you don’t need an HTTP library. Instead, you can use with a polyfill to implement similar functionality on web browsers that don’t support .\n\nTo use the polyfill, install it via the npm command like so:\n\nThen, you can make requests like this:\n\nKeep in mind that you might also need a promise polyfill in some old browsers.\n\nThe simplicity of setting a timeout in Axios is one of the reasons some developers prefer it to . In Axios, you can use the optional property in the config object to set the number of milliseconds before the request is aborted.\n\nprovides similar functionality through the interface. However, it’s not as simple as the Axios version:\n\nHere, we created an object using the constructor, which allows us to abort the request later. is a read-only property of , providing a means to communicate with a request or abort it. If the server doesn’t respond in less than four seconds, is called, and the operation is terminated.\n\nAs we saw earlier, Axios automatically stringifies the data when sending requests (though you can override the default behavior and define a different transformation mechanism). When using , however, you’d have to do it manually.\n\nCompare the two below:\n\nAutomatic data transformation is a nice feature, but again, it’s not something you can’t do with .\n\nOne of Axios’s key features is its ability to intercept HTTP requests. HTTP interceptors come in handy when you need to examine or change HTTP requests from your application to the server or vice versa (e.g., logging, authentication, or retrying a failed HTTP request).\n\nWith interceptors, you won’t have to write separate code for each HTTP request. HTTP interceptors are helpful when you want to set a global strategy for how you handle requests and responses.\n\nHere’s how you can declare a request interceptor in Axios:\n\nIn this code, the method is used to define code to be run before an HTTP request is sent. Also, can be used to intercept the response from the server. Let’s say there is a network error; using the response interceptors, you can retry that same request using interceptors.\n\nBy default, doesn’t provide a way to intercept requests, but it’s not hard to come up with a workaround. You can overwrite the global method and define your interceptor, like this:\n\nProgress indicators are very useful when loading large assets, especially for users with slow internet. Previously, JavaScript programmers used the callback handler to implement progress indicators.\n\nThe Fetch API doesn’t have an handler. Instead, it provides an instance of via the body property of the response object.\n\nThe following example illustrates the use of to provide users with immediate feedback during image download:\n\nImplementing a progress indicator in Axios is simpler, especially if you use the Axios Progress Bar module. First, you need to include the following style and scripts:\n\nThen you can implement the progress bar like this:\n\nThis code uses the API to asynchronously read the downloaded image. The method returns the image’s data as a Base64-encoded string, which is then inserted into the attribute of the tag to display the image.\n\nTo make multiple, simultaneous requests, Axios provides the method. Simply pass an array of requests to this method, then use to assign the properties of the response array to separate variables:\n\nYou can achieve the same result by using the built-in method. Pass all fetch requests as an array to . Next, handle the response by using an function, like this:\n\nCross-Origin Resource Sharing (CORS) is a mechanism available in HTTP to enable a server to permit the loading of its resources from any origins other than itself. For example, you need CORS when you want to pull data from external APIs that are public or authorized.\n\nIf the CORS mechanism is not properly enabled on the server, any request from a different server — regardless of whether or not it is made with Axios or — will receive the error.\n\nTo properly handle CORS, the first step is to configure the server, which depends on your environment/server. Once the server has been properly configured, it will automatically include the header in response to all requests (see the documentation for more information).\n\nA common error, in both Axios and , is to add the to the request — this is a response parameter and is used by the server to specify the permitted access control for the origin.\n\nAnother aspect to be aware of, when you add the headers to your Axios request, is that the request is handled differently: the browser performs a preflight request before the actual request and this preflight request is an request that verifies if CORS is honored and if the actual request is safe to send the real request.\n\nResponse management is a critical part of every application invoking an API. In this section, we will briefly look at the two aspects of it: getting the error code and manipulating response data.\n\nError management is different in Axios and . Specifically, doesn’t automatically reject the in the event of server-side errors, such as HTTP 404 or 500 status codes. This means that these errors don’t trigger the block, unlike in Axios where such responses would typically be considered exceptions.\n\nInstead, will resolve the normally with the status in the response set to . The call to will only fail on network failures or if anything has prevented the request from completing.\n\nIn the following code, you can see how to handle errors in :\n\nMeanwhile, in Axios, you can discriminate all errors in a proper block as shown in the following example:\n\nOnce the request has been served with a proper response without any errors, you can handle the response payload that will be accessible by using two different mechanisms.\n\nIn , the request/response payload is accessible in the field and must be stringified, while in Axios it is in the field as a proper JavaScript object. This difference is captured in the following, stripped-down examples:\n\nThe key difference in lies in the use of the method. Despite the name, this method does not produce JSON but instead, it will take JSON as an input and parse it to produce a JavaScript object.\n\nAxios provides an easy-to-use API in a compact package for most HTTP communication needs. However, if you prefer to stick with native APIs, nothing is stopping you from implementing Axios features.\n\nAs discussed in this article, it’s possible to reproduce the key features of the Axios library using the method provided by web browsers. Whether it’s worth loading a client HTTP API depends on whether you’re comfortable working with built-in APIs."
    },
    {
        "link": "https://medium.com/@thejasonfile/fetch-vs-axios-js-for-making-http-requests-2b261cdd3af5",
        "document": "One of the final sections of Stephen Grider’s excellent ‘ES6 Javascript: The Complete Developer’s Guide’ course on Udemy.com discusses the .fetch() method and some if its shortcomings. He points out that there are some things with .fetch() that aren’t ideal and suggests that there are other options out there for making HTTP requests. One of those options is axios.js. I had not heard of Axios before so this seemed like a great opportunity to do a little digging and see what I could come up with. (Since this is referencing material from Stephen’s course, I am using examples and conventions similar to his.)\n\nAxios is a Javascript library used to make http requests from node.js or XMLHttpRequests from the browser and it supports the Promise API that is native to JS ES6. Another feature that it has over .fetch() is that it performs automatic transforms of JSON data.\n\nIf you use .fetch() there is a two-step process when handing JSON data. The first is to make the actual request and then the second is to call the .json() method on the response.\n\nUpdate 06/27/17: As of May 29th, Spotify now requires authentication for all requests to their API, so the below examples will not work as written.\n\nHere is a simple example using the Spotify API. I set the url as a variable and then pass it to fetch and set the .then() callback to console the data that gets returned from the request.\n\nThat’s great, but this is not the data you are looking for. That is the response from the server letting you know that your request went through just fine. Great, but you can’t do much with that.\n\nTo get to that data, you have to pass it to .json() first and then you can see it.\n\nNow, this is the data from Spotify that we wanted.\n\nLet’s see how this is handled with Axios.\n\nThe first step in using Axios is installing Axios. You can use npm if you want to run axios in node or a cdn if you want to run it in your browser.\n\nThen, in my console, I assign the variable and then pass it to the method.\n\nSo by using axios you can cut out the middle step of passing the results of the http request to the .json() method. Axios just returns the data object you would expect.\n\nThe second issue that Stephen brings up is how .fetch() handles error responses. Logically you would think that if .fetch() gets an error it would enter the .catch() block and return anything there, right? Not necessarily. Here is an example.\n\nI have altered my variable from the previous examples so that it is now incorrect. I would expect a 400 error at this point and for my .fetch() to go into the .catch() block but this is what happens instead.\n\nI’ve added the ‘BAD’ and ‘GOOD’ strings in the responses to clarify what is happening here.\n\nI get the 400 response code but, as you can see by the ‘GOOD’ string in the console, the .then() block was executed. How does Axios handle this? The way you would probably expect. You get any kind of error with the http request and the .catch() block is executed.\n\nThe ‘BAD’ string is there and the error is logged to the console.\n\nThe .fetch() method is a great step in the right direction of getting http requests native in ES6, but just know that if you use it there are a couple of gotchas that might be better handled by third-party libraries like Axios."
    },
    {
        "link": "https://stackoverflow.com/questions/50277504/is-there-any-reasons-to-use-axios-instead-es6-fetch",
        "document": "A few reasons for using Axios over Fetch:\n\nThis is more of a question between XMLHttpRequest (which powers axios) or Fetch API.\n\nFetch API currently does not provide any way to get notified of the request progress, a feature which powers feedback mechanism for large file uploads for example.\n\nAxios, on the other hand, has this functionality built in:\n\nWhen your backend returns response code, will not treat it any different from .\n\nThis is an inconvenience in most cases since all your previous assumptions of what a response would look like are no longer valid.\n\nMost often, when receiving an erroneous response from the server you'd want to abort the processing pipeline as soon as possible, and switch to an error handling case.\n\nThis is not hard to accomplish, but you'd probably want to capture this logic under some abstraction to avoid repetition, and this brings us one step closer to Web API abstraction which is Axios.\n\nAxios does a sane thing and rejects the promise if the response returns erroneous status. This behavior is customizable as are most of the things with axios.\n\nBoth of those libraries are great but in my experience, required additional setup to get Jest to use mocked fetch over polyfilled one.\n\nI also like that returns a promise which will be resolved after matching the request.\n\nFor example, you can configure an interceptor which will add api key to all request parameters, or monitor active requests to show a loading screen.\n\nReasons for using one option over the other may vary from actual requirements to convenience.\n\nIf you need to monitor progress, use Axios (or XMLHttpRequest).\n\nIf you are writing a service worker, use Fetch.\n\nOtherwise, use what's more convenient to you."
    },
    {
        "link": "https://geeksforgeeks.org/difference-between-fetch-and-axios-js-for-making-http-requests",
        "document": "For web applications to communicate with servers using the HTTP protocol, developers commonly use Fetch or Axios. Both are similar, but some prefer Axios for their simplicity. However, Fetch, a built-in API, is also powerful and can do what Axios does.\n\nThe Fetch API provides a fetch() method defined on the window object. It also provides a JavaScript interface for accessing and manipulating parts of the HTTP pipeline (requests and responses). The fetch method has one mandatory argument- the URL of the resource to be fetched. This method returns a Promise that can be used to retrieve the response to the request.\n\nAxios is a Javascript library used to make HTTP requests from node.js or XMLHttpRequests from the browser and it supports the Promise API that is native to JS ES6. It can be used intercept HTTP requests and responses and enables client-side protection against XSRF. It also has the ability to cancel requests.\n\nFetch and Axios both handle HTTP requests.Axios offers more features like cancellation, progress tracking and JSON handling while Fetch being inbuild require no installation and has wide compatibilty accross the browsers."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch",
        "document": "The Fetch API provides a JavaScript interface for making HTTP requests and processing the responses. Fetch is the modern replacement for : unlike , which uses callbacks, Fetch is promise-based and is integrated with features of the modern web such as service workers and Cross-Origin Resource Sharing (CORS). With the Fetch API, you make a request by calling , which is available as a global function in both and contexts. You pass it a object or a string containing the URL to fetch, along with an optional argument to configure the request. The function returns a which is fulfilled with a object representing the server's response. You can then check the request status and extract the body of the response in various formats, including text and JSON, by calling the appropriate method on the response. Here's a minimal function that uses to retrieve some JSON data from a server: async function getData() { const url = \"https://example.org/products.json\"; try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const json = await response.json(); console.log(json); } catch (error) { console.error(error.message); } } We declare a string containing the URL and then call , passing the URL with no extra options. The function will reject the promise on some errors, but not if the server responds with an error status like : so we also check the response status and throw if it is not OK. Otherwise, we fetch the response body content as JSON by calling the method of , and log one of its values. Note that like itself, is asynchronous, as are all the other methods to access the response body content. In the rest of this page we'll look in more detail at the different stages of this process.\n\nThe request body is the payload of the request: it's the thing the client is sending to the server. You cannot include a body with requests, but it's useful for requests that send content to the server, such as or requests. For example, if you want to upload a file to the server, you might make a request and include the file as the request body. To set a request body, pass it as the option: You can supply the body as an instance of any of the following types: Other objects are converted to strings using their method. For example, you can use a object to encode form data (see setting headers for more information): const response = await fetch(\"https://example.org/post\", { method: \"POST\", headers: { \"Content-Type\": \"application/x-www-form-urlencoded\", }, // Automatically converted to \"username=example&password=password\" body: new URLSearchParams({ username: \"example\", password: \"password\" }), // ... }); Note that just like response bodies, request bodies are streams, and making the request reads the stream, so if a request contains a body, you can't make it twice: const request = new Request(\"https://example.org/post\", { method: \"POST\", body: JSON.stringify({ username: \"example\" }), }); const response1 = await fetch(request); console.log(response1.status); // Will throw: \"Body has already been consumed.\" const response2 = await fetch(request); console.log(response2.status); Instead, you would need to create a clone of the request before sending it: See Locked and disturbed streams for more information.\n\nCredentials are cookies, TLS client certificates, or authentication headers containing a username and password. To control whether or not the browser sends credentials, as well as whether the browser respects any response headers, set the option, which can take one of the following three values:\n• : never send credentials in the request or include credentials in the response.\n• (the default): only send and include credentials for same-origin requests. Note that if a cookie's attribute is set to or , then the cookie will not be sent cross-site, even if is set to . Including credentials in cross-origin requests can make a site vulnerable to CSRF attacks, so even if is set to , the server must also agree to their inclusion by including the header in its response. Additionally, in this situation the server must explicitly specify the client's origin in the response header (that is, is not allowed). This means that if is set to and the request is cross-origin, then:\n• If the request is a simple request, then the request will be sent with credentials, but the server must set the and response headers, or the browser will return a network error to the caller. If the server does set the correct headers, then the response, including credentials, will be delivered to the caller.\n• If the request is not a simple request, then the browser will send a preflighted request without credentials, and the server must set the and response headers, or the browser will return a network error to the caller. If the server does set the correct headers, then the browser will follow up with the real request, including credentials, and will deliver the real response, including credentials, to the caller.\n\nRequest and response bodies are actually objects, and whenever you read them, you're streaming the content. This is good for memory efficiency, because the browser doesn't have to buffer the entire response in memory before the caller retrieves it using a method like . This also means that the caller can process the content incrementally as it is received. For example, consider a request that fetches a large text file and processes it in some way, or displays it to the user: const url = \"https://www.example.org/a-large-file.txt\"; async function fetchText(url) { try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const text = await response.text(); console.log(text); } catch (e) { console.error(e); } } If we use , as above, we must wait until the whole file has been received before we can process any of it. If we stream the response instead, we can process chunks of the body as they are received from the network: const url = \"https://www.example.org/a-large-file.txt\"; async function fetchTextAsStream(url) { try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const stream = response.body.pipeThrough(new TextDecoderStream()); for await (const value of stream) { console.log(value); } } catch (e) { console.error(e); } } In this example, we iterate asynchronously over the stream, processing each chunk as it arrives. Note that when you access the body directly like this, you get the raw bytes of the response and must transform it yourself. In this case we call to pipe the response through a , which decodes the UTF-8-encoded body data as text."
    }
]