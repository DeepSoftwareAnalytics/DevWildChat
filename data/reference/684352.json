[
    {
        "link": "https://bukkit.org/threads/tutorial-scoreboards-teams-with-the-bukkit-api.139655",
        "document": "\n• None //Adding prefixes (shows up in player list before the player's name, supports ChatColors)\n• None //Adding suffixes (shows up in player list after the player's name, supports ChatColors)\n• None //Making invisible players on the same team have a transparent body\n• None //Making it so players can't hurt others on the same team\n• None //Setting where to display the scoreboard/objective (either SIDEBAR, PLAYER_LIST or BELOW_NAME)\n• None //Setting the display name of the scoreboard/objective\n• None //If you are using custom player names (as shown above), then you have to do this:\n• None board. ChatColor. //Same as what I used above, case/color sensitive"
    },
    {
        "link": "https://dev.bukkit.org/projects/scoreboardapi",
        "document": "This project is abandoned and its default file will likely not work with the most recent version of Minecraft. Whether this project is out of date or its author has marked it as abandoned, this project is no longer maintained."
    },
    {
        "link": "https://hub.spigotmc.org/javadocs/spigot/index.html?overview-summary.html",
        "document": "The documentation is for developing plugins and is split into the respective packages for each subject matter. This documentation does not cover running a server, contributing code back to the project, or setting up a workspace. Working knowledge of the Java language is a prerequisite for developing plugins.\n\nFor basic plugin development, see the . It covers the basic requirements of a plugin jar.\n\nFor handling events and triggered code, see the .\n\nNote: While the Bukkit API makes every effort to ensure stability, this is not guaranteed, especially across major versions. In particular the following is a (incomplete) list of things that are not API.\n• Implementing interfaces or extending classes. The Bukkit API is designed to only be implemented by server software. Unless a class/interface is obviously designed for extension (eg ), or explicitly marked as such, it should not be implemented or extended by plugins. Although this can sometimes work, it is not guaranteed to do so and resulting bugs will be disregarded.\n• Constructing inbuilt events. Although backwards compatibility is attempted where possible, it is sometimes not possible to add new fields to events without breaking existing constructors. To ensure that the API continues to evolve, event constructors are therefore not plugin API.\n• Implementation classes. Concrete implementation classes packaged with Bukkit (eg those beginning with Simple) are not API. You should access them via their interfaces instead.\n• The \"enumness\" of enums which implement . Such enums are liable to conversion to regular classes and therefore usages deriving from their status as an enum (including, but not limited to, use in switch statements and classes such as ) should be avoided."
    },
    {
        "link": "https://spigotmc.org/threads/create-scoreboards-in-a-simple-way.272337",
        "document": ""
    },
    {
        "link": "https://bukkit.org/threads/scoreboard-api.312954",
        "document": ""
    },
    {
        "link": "https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/plugin/java/JavaPlugin.html",
        "document": "\n• Saves the raw contents of the default config.yml file to the location retrievable by This should fail silently if the config.yml already exists.\n• Saves the raw contents of any resource embedded with a plugin's .jar file assuming it can be found using The resource is saved into the plugin's data folder using the same hierarchy as the .jar file (subdirectories are preserved). - the embedded resource path to look for within the plugin's .jar file. (No preceding slash). - if true, the embedded resource will overwrite the contents of an existing file.\n• Executes the given command, returning its success. \n\n If false is returned, then the \"usage\" plugin.yml entry for this command (if defined) will be sent to the player. - Alias of the command which was used\n• Simple boolean if we can still nag to the logs about things boolean whether we can nag\n• Returns the plugin logger associated with this server's logger. The returned logger automatically tags all log messages with the plugin's name. Logger associated with this plugin\n• This method provides fast access to the plugin that has the given plugin class, which is usually the plugin that implemented it. An exception to this would be if plugin's jar that contained the class does not extend the class, where the intended plugin would have resided in a different jar / classloader. the plugin that provides and implements said class - if clazz does not extend - if clazz was not provided by a plugin, for example, if called with - if called from the static initializer for given JavaPlugin - if plugin that provided the class does not extend the class\n• This method provides fast access to the plugin that has provided the given class. the plugin that provided the class - if the class is not provided by a JavaPlugin - if called from the static initializer for given JavaPlugin"
    },
    {
        "link": "https://jd.papermc.io/paper/1.21.4/org/bukkit/plugin/java/JavaPlugin.html",
        "document": "\n• Saves the raw contents of the default config.yml file to the location retrievable by This should fail silently if the config.yml already exists.\n• Saves the raw contents of any resource embedded with a plugin's .jar file assuming it can be found using The resource is saved into the plugin's data folder using the same hierarchy as the .jar file (subdirectories are preserved). - the embedded resource path to look for within the plugin's .jar file. (No preceding slash). - if true, the embedded resource will overwrite the contents of an existing file.\n• Executes the given command, returning its success. \n\n If false is returned, then the \"usage\" plugin.yml entry for this command (if defined) will be sent to the player. - Alias of the command which was used\n• Called after a plugin is loaded but before it has been enabled. When multiple plugins are loaded, the onLoad() for all plugins is called before any onEnable() is called.\n• This method provides fast access to the plugin that has the given plugin class, which is usually the plugin that implemented it. An exception to this would be if plugin's jar that contained the class does not extend the class, where the intended plugin would have resided in a different jar / classloader. the plugin that provides and implements said class - if clazz does not extend - if clazz was not provided by a plugin, for example, if called with - if called from the static initializer for given JavaPlugin - if plugin that provided the class does not extend the class"
    },
    {
        "link": "https://stackoverflow.com/questions/65634824/how-do-i-use-an-api-for-my-bukkit-plugins",
        "document": "As the title says I try to make a Bukkit Plugin for my Minecraft 1.16.1 Spigot Server which uses a API. My plan was to make a plugin (in Eclipse) which analyses some statistic of the server such as playercount and TPS and so on and send it via email to my email-address. To achieve that I need to implement Java-EE because Java SE does not have the ability to send emails. Furthermore I need to implement the java-mail-api. In total there are 4 .jar files which work perfectly fine when I am running it as a normal jar file with the 4 .jars set in the buildpath as \"use external jars\". It also workes perfectly fine when I use maven to implement the APIs as dependencies into the pom.xml. No problem. But things start to go wrong when I implement the working code into a bukkit plugin.\n\nAt first I setup a simple onEnable method which looks like that\n\nIt enables the plugin and the command executor which looks like that\n\nThe problem occurs when I reload my server. The exception is\n\nAll I know about this exception is that the class from the API I am using could not be loaded in this case javax/mail/MessagingException. That means that my plugin does not use the APIs I set into the buildpath right? I tried export the plugin with the APIs implemented but that does not work. I also tried using maven for this Bukkit plugin buth that also does not work. I always gete this exception and I have literally no idea how to fix this. But as I said I guess that my plugin is not getting exported the right way with the APIs included or the link to the APIs (I also made a folder called \"lib\" where I put the APIs in, did not work..). I also tried to add the classpaths into the MANIFEST file which is generated in the plugin but that does not work either..\n\nI am personally making a plugin with the usage of APIs the first time and I really have no idea how to do this the right way. If someone could give me simple instructions on how to solve this problem, it would be really really great!"
    },
    {
        "link": "https://docs.papermc.io/paper/dev/how-do-plugins-work",
        "document": "Plugins are a way to extend the functionality of a Minecraft server. They are written in JVM-based languages such as Java, Kotlin, Groovy or Scala. Plugins are loaded from the folder in the server directory. Plugins will be loaded from a file. Each plugin has a main class that is specified in the plugin's file. This class must extend JavaPlugin, and is the entry point for the plugin and is where the plugin's lifecycle methods are defined.\n\nPlugins are loaded and unloaded at runtime. When a plugin is loaded, it is initialized and enabled. When a plugin is unloaded, it is disabled and finalized.\n\nWhen a plugin is loaded, it is initialized. This means that the plugin is loaded into memory and its method is called. This method is used to initialize the plugin and set up any resources that it needs. Most of the Bukkit API is not available at this point, so it is not safe to interact with it.\n\nWhen a plugin is enabled, its method is called. This method is used to set up any resources that the plugin needs to run. This method is called when the plugin is initialized but before the server has started ticking, so it is safe to register event listeners and other resources that the plugin needs to run, however often not safe to interact with a lot of APIs.\n\nThis is when you can also open database connections, start threads, and other things that are not safe to do in the method.\n\nWhen a plugin is disabled, its method is called. This method is used to clean up any resources that the plugin has allocated. This method is called before all plugins are unloaded, and is meant for any cleanup that needs to be done before the plugin is unloaded. This may include saving data to disk or closing connections to databases.\n\nEvents are a way for plugins to listen to things that happen in the server and run code when they are fired. For example, is fired when a player joins the server. This is a more performant way to run code when something happens, as opposed to constantly checking. See our event listener page for more.\n\nSome events are cancellable. This means that when the event is fired, it can be cancelled which negates or stops the effect of the event. For example, is cancellable. This means that when it is cancelled, the player will not move. This is useful for things like anti-cheat, where you want to cancel the event if the player is moving too fast.\n\nIt is important to think about how \"hot\" an event is when writing event listeners. A \"hot\" event is an event that is fired very often. For example, is fired every time a player moves. This means that if you have a lot of expensive code in your event listener, it will be run every time a player moves. This can cause a lot of lag. It is important to keep event listeners as lightweight as possible. One possible way is to quickly check if the event should be handled, and if not, return. For example, if you only want to handle the event if the player is moving from one block to another, you can check if the player's location has changed blocks. If it hasn't, you can return from the listener.\n\nCommands are a way for players, the console, RCON and command blocks to run code on the server. Commands are registered by plugins and can be run by command senders. For example, the command is registered by the server and can be run by players. Commands can be run by players by typing them in the chat or by running them from a command block.\n\nCommands can have arguments. For example, the command takes an argument for the player to give the item to and an argument for the item to give. Arguments are separated by spaces. For example, the command will give the player named Notch a diamond. Note here that the arguments are .\n\nPermissions are a way to control who can run commands and who can listen to events. Permissions are registered by plugins and can be checked by other plugins. Permissions can be granted to players and groups. Permissions can have a hierarchical nature, if defined so by the plugin in their . For example, a plugin can define as a sub-permission of . This means that if a player has the permission, they will also have the permission.\n\nPlugins can have configuration files. These files are used to store data that the plugin needs to run. For example, a plugin that adds a new block to the game might have a configuration file that stores the block's ID. Configuration files should be stored in the plugin's data folder, within the folder. The server offers a YAML configuration API that can be used to read and write configuration files. See here for more information.\n\nPlugins can schedule tasks to run at a later time. This is useful for things like running code after a certain amount of time has passed. For example, a plugin might want to run code after 5 seconds. This can be done by scheduling a task to run after 100 ticks - one second is 20 ticks during normal operation. It is important to note that tasks might be delayed if the server is lagging. For example, if the server is only running at 10 ticks per second, a task that is scheduled to run after 100 ticks will take 10 seconds.\n\nIn Java, typically you could use to delay the execution of code. However, if the code is running on the main thread, this will cause the server to pause for the delay. Instead, you should use the API to schedule tasks to run later. Learn more about the API here.\n\nSince Minecraft 1.7 and the introduction of \"components\", plugins can now send messages to players that contain rich text. This means that plugins can send messages that contain things like colors, bold text, and clickable links. Colors were always possible, but only through the use of legacy color codes.\n\nPaper implements a library called that makes it easy to create and send messages to players. Learn more about the API here from their docs or our docs here."
    },
    {
        "link": "https://purpurmc.org/javadoc/org/bukkit/plugin/java/JavaPlugin.html",
        "document": "\n• Saves the raw contents of the default config.yml file to the location retrievable by This should fail silently if the config.yml already exists.\n• Saves the raw contents of any resource embedded with a plugin's .jar file assuming it can be found using The resource is saved into the plugin's data folder using the same hierarchy as the .jar file (subdirectories are preserved). - the embedded resource path to look for within the plugin's .jar file. (No preceding slash). - if true, the embedded resource will overwrite the contents of an existing file.\n• Executes the given command, returning its success. \n\n If false is returned, then the \"usage\" plugin.yml entry for this command (if defined) will be sent to the player. - Alias of the command which was used\n• Called after a plugin is loaded but before it has been enabled. When multiple plugins are loaded, the onLoad() for all plugins is called before any onEnable() is called.\n• This method provides fast access to the plugin that has the given plugin class, which is usually the plugin that implemented it. An exception to this would be if plugin's jar that contained the class does not extend the class, where the intended plugin would have resided in a different jar / classloader. the plugin that provides and implements said class - if clazz does not extend - if clazz was not provided by a plugin, for example, if called with - if called from the static initializer for given JavaPlugin - if plugin that provided the class does not extend the class"
    }
]