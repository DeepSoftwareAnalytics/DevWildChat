[
    {
        "link": "https://php.net/releases/8.0/en.php",
        "document": "PHP 8.0 is a major update of the PHP language.\n\n It contains many new features and optimizations including named arguments, union types, attributes, constructor property promotion, match expression, nullsafe operator, JIT, and improvements in the type system, error handling, and consistency.\n• Specify only required parameters, skipping optional ones. Instead of PHPDoc annotations, you can now use structured metadata with PHP's native syntax. Less boilerplate code to define and initialize properties. Instead of PHPDoc annotations for a combination of types, you can use native union type declarations that are validated at runtime. \"This is what I expected\" \"This is what I expected\" The new match is similar to switch and has the following features:\n• Match is an expression, meaning its result can be stored in a variable or returned.\n• Match branches only support single-line expressions and do not need a break; statement. Instead of null check conditions, you can now use a chain of calls with the new nullsafe operator. When the evaluation of one element in the chain fails, the execution of the entire chain aborts and the entire chain evaluates to null. When comparing to a numeric string, PHP 8 uses a number comparison. Otherwise, it converts the number to a string and uses a string comparison. Most of the internal functions now throw an Error exception if the validation of the parameters fails."
    },
    {
        "link": "https://stitcher.io/blog/new-in-php-8",
        "document": "PHP 8 was released on November 26, 2020. You can download it here. It's a new major version, which means that there are some breaking changes, as well as lots of new features and performance improvements.\n\nBecause of the breaking changes, there's a higher chance you'll need to make some changes in your code to get it running on PHP 8. If you've kept up to date with the latest releases though, the upgrade shouldn't be too hard, since most breaking changes were deprecated before in the 7.* versions. And don't worry, all these deprecations are listed in this post.\n\nBesides breaking changes, PHP 8 also brings a nice set of new features such as the JIT compiler, union types, attributes, and more.\n\nLet's start with all new features, it's quite a list!\n\nGiven the dynamically typed nature of PHP, there are lots of cases where union types can be useful. Union types are a collection of two or more types which indicate that either one of those can be used.\n\nNote that can never be part of a union type, since it indicates \"no return value at all\". Furthermore, unions can be written using , or by using the existing notation:\n\nThe JIT — just in time — compiler promises significant performance improvements, albeit not always within the context of web requests. I've done my own benchmarks on real-life web applications, and it seems like the JIT doesn't make that much of a difference, if any, on those kinds of PHP projects.\n\nIf you want to know more about what the JIT can do for PHP, you can read another post I wrote about it here.\n\nIf you're familiar with the null coalescing operator you're already familiar with its shortcomings: it doesn't work on method calls. Instead you need intermediate checks, or rely on helpers provided by some frameworks:\n\nWith the addition of the nullsafe operator, we can now have null coalescing-like behaviour on methods!\n\nYou can read all about the nullsafe operator here.\n\nNamed arguments allow you to pass in values to a function, by specifying the value name, so that you don't have to take their order into consideration, and you can also skip optional parameters!\n\nYou can read about them in-depth in this post.\n\nAttributes, commonly known as annotations in other languages, offers a way to add meta data to classes, without having to parse docblocks.\n\nAs for a quick look, here's an example of what attributes look like, from the RFC:\n\nNote that this base used to be called in the original RFC, but was changed with another RFC afterwards. If you want to take a deep dive in how attributes work, and how you can build your own; you can read about attributes in depth on this blog.\n\nYou could call it the big brother of the expression: can return values, doesn't require statements, can combine conditions, uses strict type comparisons and doesn't do any type coercion.\n\nIt looks like this:\n\nYou can read up on the match expression in detail, over here.\n\nThis RFC adds syntactic sugar to create value objects or data transfer objects. Instead of specifying class properties and a constructor for them, PHP can now combine them into one.\n\nInstead of doing this:\n\nYou can now do this:\n\nThere's a lot more to tell about property promotion, you can read about them in this dedicated post.\n\nWhile it was already possible to return , wasn't a valid return type until PHP 8. Given PHP's dynamically typed nature, it's a feature that will be useful to many developers.\n\nSome might call it a necessary evil: the type causes many to have mixed feelings. There's a very good argument to make for it though: a missing type can mean lots of things in PHP:\n• We're expecting one of several types\n• We're expecting a type that can't be type hinted in PHP\n\nBecause of the reasons above, it's a good thing the type is added. itself means one of these types:\n\nNote that can also be used as a parameter or property type, not just as a return type.\n\nAlso note that since already includes , it's not allowed to make it nullable. The following will trigger an error:\n\nThis RFC changes from being a statement to being an expression, which makes it possible to throw exception in many new places:\n\nPreviously, PHP used to apply the same inheritance checks on public, protected and private methods. In other words: private methods should follow the same method signature rules as protected and public methods. This doesn't make sense, since private methods won't be accessible by child classes.\n\nThis RFC changed that behaviour, so that these inheritance checks are not performed on private methods anymore. Furthermore, the use of also didn't make sense, so doing so will now trigger a warning:\n\nBuilt upon the weakrefs RFC that was added in PHP 7.4, a implementation is added in PHP 8. holds references to objects, which don't prevent those objects from being garbage collected.\n\nTake the example of ORMs, they often implement caches which hold references to entity classes to improve the performance of relations between entities. These entity objects can not be garbage collected, as long as this cache has a reference to them, even if the cache is the only thing referencing them.\n\nIf this caching layer uses weak references and maps instead, PHP will garbage collect these objects when nothing else references them anymore. Especially in the case of ORMs, which can manage several hundreds, if not thousands of entities within a request; weak maps can offer a better, more resource friendly way of dealing with these objects.\n\nHere's what weak maps look like, an example from the RFC:\n\nA small, yet useful, new feature: it's now possible to use on objects, instead of having to use on them. It works the same way as .\n\nWhenever you wanted to catch an exception before PHP 8, you had to store it in a variable, regardless whether you used that variable or not. With non-capturing catches, you can omit the variable, so instead of this:\n\nYou can now do this:\n\nNote that it's required to always specify the type, you're not allowed to have an empty . If you want to catch all exceptions and errors, you can use as the catching type.\n\nAlready possible when calling a function, trailing comma support was still lacking in parameter lists. It's now allowed in PHP 8, meaning you can do the following:\n\nAs a sidenote: trailing commas are also supported in the list of closures, this was an oversight and now added via a separate RFC.\n\nYou can already create a object from a object using , but the other way around was tricky. By adding and there's now a generalised way to convert and objects to each other.\n\nThe interface can be used to type hint anything that implements . Whenever a class implements , it automatically implements the interface behind the scenes and there's no need to manually implement it.\n\nSome might say it's long overdue, but we finally don't have to rely on anymore to know whether a string contains another string.\n\nInstead of doing this:\n\nYou can now do this\n\nTwo other ones long overdue, these two functions are now added in the core.\n\nThe new function does something similar as the and functions, which allows for division by 0. Instead of errors you'll get , or , depending on the case.\n\nreturns the type of a variable. Sounds like something would do? returns more useful output for arrays, strings, anonymous classes and objects.\n\nFor example, calling on a class would return . Using will return the class name.\n\nA full list of differences between and can be found in the RFC.\n\nResources are special variables in PHP, referring to external resources. One example is a MySQL connection, another one a file handle.\n\nEach one of those resources gets assigned an ID, though previously the only way to know that id was to cast the resource to :\n\nPHP 8 adds the functions, making this operation more obvious and type-safe:\n\nTraits can specify abstract methods which must be implemented by the classes using them. There's a caveat though: before PHP 8 the signature of these method implementations weren't validated. The following was valid:\n\nPHP 8 will perform proper method signature validation when using a trait and implementing its abstract methods. This means you'll need to write this instead:\n\nThe function returns an array of values. This RFC adds a class with a method. This implementation works with objects instead of plain values. It consumes less memory and is easier to read.\n\nFrom the RFC: \"the Uniform Variable Syntax RFC resolved a number of inconsistencies in PHP's variable syntax. This RFC intends to address a small handful of cases that were overlooked.\"\n\nLots of people pitched in to add proper type annotations to all internal functions. This was a long standing issue, and finally solvable with all the changes made to PHP in previous versions. This means that internal functions and methods will have complete type information in reflection.\n\nPreviously it was possible to compile PHP without the JSON extension enabled, this is not possible anymore. Since JSON is so widely used, it's best developers can always rely on it being there, instead of having to ensure the extension exist first.\n\nAs mentioned before: this is a major update and thus there will be breaking changes. The best thing to do is take a look at the full list of breaking changes over at the UPGRADING document.\n\nMany of these breaking changes have been deprecated in previous 7.* versions though, so if you've been staying up-to-date over the years, it shouldn't be all that hard to upgrade to PHP 8.\n\nUser-defined functions in PHP will already throw , but internal functions did not, they rather emitted warnings and returned . As of PHP 8 the behaviour of internal functions have been made consistent.\n\nLots of errors that previously only triggered warnings or notices, have been converted to proper errors. The following warnings were changed.\n• Division by zero: exception instead of warning\n• Attempt to increment/decrement property '%s' of non-object: exception instead of warning\n• Attempt to modify property '%s' of non-object: exception instead of warning\n• Attempt to assign property '%s' of non-object: exception instead of warning\n• Creating default object from empty value: exception instead of warning\n• Trying to get property '%s' of non-object: warning instead of notice\n• Cannot add element to the array as the next element is already occupied: exception instead of warning\n• Cannot unset offset in a non-array variable: exception instead of warning\n• Cannot use a scalar value as an array: exception instead of warning\n• Only arrays and can be unpacked: exception instead of warning\n• Invalid argument supplied for foreach(): exception instead of warning\n• Illegal offset type in isset or empty: exception instead of warning\n• Illegal offset type in unset: exception instead of warning\n• Array to string conversion: warning instead of notice\n• Resource ID#%d used as offset, casting to integer (%d): warning instead of notice\n• Cannot assign an empty string to a string offset: exception instead of warning\n• Supplied resource is not a valid stream resource: exception instead of warning\n\nIt's possible that this change might reveal errors that again were hidden before PHP 8. Make sure to set on your production servers!\n\nIt's now instead of everything but and . This means that many errors might pop up which were previously silently ignored, though probably already existent before PHP 8.\n\nFrom the RFC: The current default error mode for PDO is silent. This means that when an SQL error occurs, no errors or warnings may be emitted and no exceptions thrown unless the developer implements their own explicit error handling.\n\nThis RFC changes the default error will change to in PHP 8.\n\nWhile already deprecated in PHP 7.4, this change is now taken into effect. If you'd write something like this:\n\nPHP would previously interpret it like this:\n\nPHP 8 will make it so that it's interpreted like this:\n\nBefore PHP 8, it was possible to apply arithmetic or bitwise operators on arrays, resources or objects. This isn't possible anymore, and will throw a :\n\nPHP used to interpret each part of a namespace (separated by a backslash ) as a sequence of tokens. This RFC changed that behaviour, meaning reserved names can now be used in namespaces.\n\nPHP's type system tries to do a lot of smart things when it encounters numbers in strings. This RFC makes that behaviour more consistent and clear.\n\nThis RFC fixes the very strange case in PHP where results in . There are some other edge cases like that one, and this RFC fixes them.\n\nA few reflection methods have been deprecated:\n\nYou should now use to get information about a parameter's type:\n\nIf the type is a single type, returns an instance of , which you can get its name from and whether it's built-in:\n\nIf the type is a union type however, you'll get an instance of , which can give you an array of like so:\n\nChecking whether a type is a union or not can be done with an check:\n\nNext up, three method signatures of reflection classes have been changed:\n\nHave now become:\n\nThe upgrading guide specifies that if you extend these classes, and still want to support both PHP 7 and PHP 8, the following signatures are allowed:\n\nBefore PHP 8, sorting algorithms were unstable. This means that the order of equal elements wasn't guaranteed. PHP 8 changes the behaviour of all sorting functions to stable sorting.\n\nFrom the RFC: Inheritance errors due to incompatible method signatures currently either throw a fatal error or a warning depending on the cause of the error and the inheritance hierarchy.\n\n# Other deprecations and changes\n\nDuring the PHP 7.* development, several deprecations were added that are now finalised in PHP 8."
    },
    {
        "link": "https://kinsta.com/blog/php-8",
        "document": "PHP 8 has been officially released to the General Availability on November 26, 2020!\n\nThis new major update brings many optimizations and powerful features to the language. We’re excited to drive you through the most interesting changes that will allow us to write better code and build more robust applications.\n\nAre you ready? Let’s dive in!\n\nThe most acclaimed feature coming with PHP 8 is the Just-in-time (JIT) compiler. What is JIT all about?\n\nThe RFC proposal describes JIT as follows:\n\nSo, how did we get to JIT, and what is the difference between JIT vs OPcache?\n\nTo better understand what JIT is for PHP, let’s take a quick look at how PHP executes the source code to the final result.\n• Lexing/Tokenizing: First, the interpreter reads the PHP code and builds a set of tokens.\n• Parsing: The interpreter checks if the script matches the syntax rules and uses tokens to build an Abstract Syntax Tree (AST), a hierarchical representation of the structure of source code.\n• Compilation: The interpreter traverses the tree and translates AST nodes into low-level Zend opcodes, which are numeric identifiers determining the type of instruction performed by the Zend VM.\n• Interpretation: Opcodes are interpreted and run on the Zend VM.\n\nThe following image shows a visual representation of the basic PHP execution process.\n\nSo, how does OPcache make PHP faster? And what changes in the execution process with JIT?\n\nPHP is an interpreted language. This means, when a PHP script runs, the interpreter parses, compiles, and executes the code over and over again on each request. This may result in wasting CPU resources and additional time.\n\nThis is where the OPcache extension comes in to play:\n\nWith OPcache enabled, the PHP interpreter goes through the 4 stage process mentioned above only when the script runs for the first time. Since PHP bytecodes are stored in shared memory, they are immediately available as low-level intermediate representation and can be executed on the Zend VM right away.\n\nAs of PHP 5.5, the Zend OPcache extension is available by default, and you can check if you have it correctly configured by simply calling from a script on your server or checking out your php.ini file (see OPcache configuration settings).\n\nSuggested reading: How to Improve PHP Memory Limit in WordPress.\n\nOPcache has been recently improved with the implementation of preloading, a new OPcache feature added with PHP 7.4. Preloading provides a way to store a specified set of scripts into OPcache memory “before any application code is run.” Still, it doesn’t bring tangible performance improvement for typical web-based applications.\n\nYou can read more about preloading in our introduction to PHP 7.4.\n\nJIT — The Just in Time Compiler\n\nEven if opcodes are low-level intermediate representation, they still have to be compiled into machine code. JIT “doesn’t introduce any additional IR (Intermediate Representation) form,” but uses DynASM (Dynamic Assembler for code generation engines) to generate native code directly from PHP byte-code.\n\nIn short, JIT translates the hot parts of the intermediate code into machine code. Bypassing compilation, it’d be able to bring considerable improvements in performance and memory usage.\n\nZeev Surasky, co-author of the PHP JIT proposal, shows how much calculations would be faster with JIT:\n\nAccording to the JIT RFC, the just in time compiler implementation should improve PHP performance. But would we really experience such improvements in real-life apps like WordPress?\n\nThe early tests show that JIT would make CPU-intensive workloads run significantly faster. However, the RFC warns:\n\nWith JIT enabled, the code wouldn’t be run by the Zend VM, but by the CPU itself, which would improve the calculation speed. Web apps like WordPress also rely on other factors like TTFB, database optimization, HTTP requests, etc.\n\nSo, we shouldn’t expect a significant boost in PHP execution speed when it comes to WordPress and similar apps. Nevertheless, JIT could bring several benefits for developers.\n\nSo, while JIT will hardly bring huge improvements to WordPress performance, it’ll be upgrading PHP to the next level, making it a language many functions could now be written directly in.\n\nThe downside would be the greater complexity that can increase maintenance, stability, and debugging costs. According to Dmitry Stogov:\n\nThe proposal to include JIT in PHP 8 passed with 50 to 2 votes.\n\nApart from JIT, we can expect many features and improvements with PHP 8. The following list is our handpicked selection of the upcoming additions and changes that should make PHP more reliable and efficient.\n\nAs a result of an ongoing discussion about improving object ergonomics in PHP, the Constructor Property Promotion RFC proposes a new and more concise syntax that will simplify the property declaration, making it shorter and less redundant.\n\nThis proposal only relates to promoted parameters, i.e. those method parameters prefixed with public, protected, and private visibility keywords.\n\nCurrently, all properties have to be repeated several times (at least four times) before we can use them with objects. Consider the following example from the RFC:\n\nAccording to Nikita Popov, the RFC author, we have to write the property name at least four times in three different places: the property declaration, the constructor parameters, and the property assignment. This syntax is not particularly usable, especially in classes with many properties and more descriptive names.\n\nThis RFC proposes to merge the constructor and the parameter definition. So, as of PHP 8, we have a more usable way of declaring parameters. The code seen above can change as shown below:\n\nAnd that’s it. So we have a new way to promote properties that are shorter, more readable, and less prone to errors. According to Nikita:\n\nThe property declaration is transformed as we’d explicitly declared those properties, and we can use the Reflection API to introspect property definitions before the execution (see Desugaring):\n\nWe don’t have any limitations in using inheritance in conjunction with promoted parameters. Anyway, there’s not a particular relation between parent and child class constructors. According to Nikita:\n\nHere is an example:\n\nPromoted properties are allowed in non-abstract constructors and traits, but there are several limitations worth mentioning here.\n\nPromoted properties are not allowed in abstract classes and interfaces:\n\nOne of the most notable constraints is related to nullability. Previously, we used a type that wasn’t explicitly nullable. But with a null default value, the type was implicitly nullable. But with property types, we don’t have this implicit behavior because promoted parameters require a property declaration, and the nullable type must be explicitly declared. See the following example from the RFC:\n\nAs callable is not a supported type for properties, we are not allowed to use the callable type in promoted properties:\n\nThe var Keyword Is Not Allowed\n\nOnly a visibility keyword can be used with promoted parameters, so declaring constructor properties with the keyword is not allowed (see the following example from the RFC):\n\nWe can combine promoted properties and explicit properties in the same class, but properties cannot be declared twice:\n\nThe reason here is that the declared type is different from the variadic parameter, which is actually an array:\n\nFor a closer view at Costructor Property Promotion, listen to this interview with Nikita Popov. For an in-depth overview of object ergonomics in PHP, see this post and the following interview with Larry Garfield.\n\nTraits are defined as “a mechanism for code reuse in single inheritance languages such as PHP.” Typically, they are used to declare methods that can be used in multiple classes.\n\nA trait can also contain abstract methods. These methods simply declare the method’s signature, but the method’s implementation must be done within the class using the trait.\n\nAccording to the PHP manual,\n\nThis also means that the signatures of the methods must match. In other words, the type and the number of required arguments need to be the same.\n\nAnyway, according to Nikita Popov, author of the RFC, signature validation is currently enforced only spottily:\n\nThe following example from Nikita relates to the first case (not enforced signature):\n\nWith that being said, this RFC proposes to always throw a fatal error if the implementing method is not compatible with the abstract trait method, regardless of its origin:\n\nThis RFC has been unanimously approved.\n\nIn PHP, inheritance errors due to incompatible method signatures throw either a fatal error or a warning depending on what is causing the error.\n\nIf a class is implementing an interface, incompatible method signatures throw a fatal error. According to Object Interfaces documentation:\n\nHere is an example of an inheritance error with an interface:\n\nIn PHP 7.4, the code above would throw the following error:\n\nA function in a child class with an incompatible signature would throw a warning. See the following code from the RFC:\n\nIn PHP 7.4, the code above would simply throw a warning:\n\nNow, this RFC proposes to always throw a fatal error for incompatible method signatures. With PHP 8, the code we saw earlier above would prompt the following:\n\nIn PHP, if an array starts with a negative index ( ), the following indices will start from 0 (more on this in documentation). Look at the following example:\n\nIn PHP 7.4 the result would be the following:\n\nNow, this RFC proposes to change things so that the second index would be , whichever the value of .\n\nIn PHP 8, the code above would result in the following array:\n\nWith PHP 8, arrays starting with a negative index change their behavior. Read more about backward incompatibilities in the RFC.\n\nUnion types accept values that can be of different types. Currently, PHP doesn’t provide support for union types, except for the syntax and the special type.\n\nBefore PHP 8, union types could only be specified in phpdoc annotations, as shown in the following example from the RFC:\n\nNow, the Union types 2.0 RFC proposes to add support for union types in function signatures, so that we won’t rely on inline documentation anymore, but would define union types with a syntax instead:\n\nAs explained by Nikita Popov in the RFC,\n\nUnion types support all available types, with some limitations:\n• The type could not be part of a union, as means that a function does not return any value.\n• The type is only supported in union types but it’s usage as a standalone type is not allowed.\n• The nullable type notation ( ) is also allowed, meaning , but we are not allowed to include the notation in union types ( is not allowed and we should use instead).\n• As many functions (i.e. , , , etc.) include among the possible return types, the pseudo-type is also supported.\n\nYou can read more about Union Types V2 in the RFC.\n\nWhen passing a parameter of illegal type, internal and user-defined functions behave differently.\n\nUser-defined functions throw a , but internal functions behave in various ways, depending on several conditions. Anyway, the typical behavior is to throw a warning and return . See the following example in PHP 7.4:\n\nThis would result in the following warning:\n\nIf is enabled, or argument information specifies types, the behavior would be different. In such scenarios, the type error is detected and results in a .\n\nThis situation would lead to a number of problems well explained in the RFC’s issues section.\n\nTo remove these inconsistencies, this RFC proposes to make the internal parameter parsing APIs to always generate a in case of a parameter type mismatch.\n\nIn PHP 8, the code above throws the following error:\n\nIn PHP, is a statement, so it’s not possible to use it in places where only an expression is allowed.\n\nThis RFC proposes to convert the statement into an expression so that it can be used in any context where expressions are allowed. For example, arrow functions, null coalesce operator, ternary and elvis operators, etc.\n\nSee the following examples from the RFC:\n\nA weak map is a collection of data (objects) in which keys are weakly referenced, meaning that they are not prevented from being garbage collected.\n\nPHP 7.4 added support for weak references as a way to retain a reference to an object that doesn’t prevent the object itself from being destroyed. As pointed out by Nikita Popov,\n\nThat’s why this RFC introduces a class to create objects to be used as weak map keys that can be destroyed and removed from the weak map if there aren’t any further references to the key object.\n\nIn long-running processes, this would prevent memory leaks and improve performance. See the following example from the RFC:\n\nWith PHP 8, the code above would produce the following result (see the code in action here):\n\nIf you unset the object, the key is automatically removed from the weak map:\n\nNow the result would be the following:\n\nFor a closer look at Weak maps, see the RFC. The proposal was unanimously approved.\n\nTrailing commas are commas appended to lists of items in different contexts. PHP 7.2 introduced trailing commas in list syntax, PHP 7.3 introduced trailing commas in function calls.\n\nPHP 8 now introduces trailing commas in parameter lists with functions, methods, and closures, as shown in the following example:\n\nThis proposal passed with 58 to 1 votes.\n\nTo fetch the name of a class, we can use the syntax. This RFC proposes to extend the same syntax to objects so that it’s now possible to fetch the name of the class of a given object, as shown in the example below:\n\nWith PHP 8, provides the same result as . If is not an object, it throws a exception.\n\nAttributes, also known as annotations, are structured metadata that can be used to specify properties for objects, elements, or files.\n\nUntil PHP 7.4, doc-comments were the only way to add metadata to declarations of classes, functions, etc. The Attributes v2 RFC introduces PHP attributes, defining them as a form of structured, syntactic metadata that can be added to declarations of classes, properties, functions, methods, parameters, and constants.\n\nAttributes are added before the declarations they refer to. See the following examples from the RFC:\n\nAttributes can be added before or after a doc-block comment:\n\nEach declaration may have one or more attributes, and each attribute may have one or more associated values:\n\nSee the RFC for a more in-depth overview of PHP attributes, use cases, and alternative syntax.\n\nNamed arguments provide a new way of passing arguments to a function in PHP:\n\nWe can pass named arguments to a function by simply adding the parameter name before its value:\n\nWe are also allowed to use reserved keywords, as shown in the example below:\n\nBut we are not allowed to pass a parameter name dynamically. The parameter must be an identifier, and the following syntax is not allowed:\n\nAccording to Nikita Popov, the author of this RFC, named arguments offer several advantages.\n\nFirst off, named arguments will help us write more understandable code because their meaning is self-documenting. The example below from the RFC is self-explanatory:\n\nNamed arguments are order-independent. This means that we are not forced to pass arguments to a function in the same order as the function signature:\n\nIt’s also possible to combine named arguments with positional arguments:\n\nAnother great advantage of named arguments is that they allow specifying only those arguments we want to change. We don’t have to specify default arguments if we don’t want to overwrite default values. The following example from the RFC makes it clear:\n\nNamed arguments can be used with PHP attributes, as shown in the following example from the RFC:\n\nHowever, passing positional arguments after named arguments is not allowed and will result in a compile-time error. The same happens when you pass the same parameter name twice.\n\nNamed arguments are handy with class declarations because constructors usually have many parameters, and named arguments provide a more “ergonomic” way to declare a class.\n\nFor a closer view at Named Arguments, with constraints, backward incompatibilities, and several examples, see the Named Arguments RFC.\n\nThis RFC introduces the nullsafe operator with full short-circuit evaluation.\n\nIn short-circuit evaluation, the second operator is evaluated only if the first operator does not evaluate to . If an operator in a chain evaluates to , the execution of the entire chain stops and evaluates to .\n\nConsider the following examples from the RFC:\n\nIf is null, method isn’t called and is set to .\n\nSee the nullsafe operator RFC for additional examples, exceptions, and future scope.\n\nIn previous PHP versions, when making a non-strict comparison between strings and numbers, PHP first casts the string to a number, then performs the comparison between integers or floats. Even if this behavior is quite useful in several scenarios, it may produce wrong results that may also lead to bugs and/or security issues.\n\nConsider the following example from the RFC:\n\nPHP 8 introduces Saner string to number comparisons, aiming to make string to number comparisons more reasonable. In the words of Nikita Popov,\n\nThe following table compares the behavior of string to number comparison earlier PHP versions and in PHP 8:\n\nRead more about the many implications of this change and how string to number comparisons change in PHP 8 in the official RFC from Nikita Popov.\n\nIn PHP, strings containing numbers fall into three categories:\n• Leading-numeric string: strings whose initial characters are numeric strings and trailing characters are non-numeric.\n• Non-numeric string: strings not falling in neither of the previous categories.\n\nNumeric strings and leading-numeric strings are treated differently depending on the operation performed. For example:\n• Explicit string to number conversions (i.e. and type casts) convert numeric and leading-numeric strings numbers. Explicitly converting a non-numeric string to a number produces 0.\n• Implicit string to number conversions (i.e. no declaration) lead to different results for numeric and non-numeric strings. Non-numeric string to number conversions throw a .\n\nString offsets, arithmetic operations, increment and decrement operations, string-to-string comparisons, and bitwise operations also lead to different results.\n\nFor a more in-depth overview of numeric strings in PHP 8, with code examples, exceptions, and backward compatibility issues, see the RFC.\n\nThe new expression is pretty similar to but with safer semantics and allowing to return values.\n\nTo understand the difference between the two control structures, consider the following example from the RFC:\n\nWe can now get the same result as the code above with the following expression:\n\nA significant advantage of using the new expression is that while compares values loosely ( ) potentially leading to unexpected results, with the comparison is an identity check ( ).\n\nThe expression may also contain multiple comma-separated expressions allowing for more concise syntax (source):\n\nFor additional examples and cases of use, see the Match expression v2 RFC and the PHP documentation.\n\nIn previous PHP versions, applying arithmetic and bitwise operators to an array, resource, or non-overloaded object was allowed. Anyway, the behavior was sometimes inconsistent.\n\nIn this RFC, Nikita Popov shows how unreasonable that behavior could be with a simple example:\n\nNikita explains how applying arithmetic or bitwise operator to arrays, resources, or non-overloaded objects led to different results:\n\nWith PHP 8, things change, and the behavior is the same for all arithmetic and bitwise operators:\n\nPHP 8 brings several new functions to the language:\n\nBefore PHP 8, strstr and strpos were the typical options for developers to search for a needle inside a given string. The problem is that both functions aren’t considered very intuitive, and their usage can be confusing for new PHP developers. See the following example:\n\nIn the example above, we used the comparison operator, which checks if two values are of the same type. This prevents us from getting an error if the position of the needle is 0:\n\nFurthermore, several frameworks provide helper functions to search for a value inside a given string (see Laravel Helpers documentation as an example).\n\nNow, this RFC proposes the introduction of a new function allowing to search inside a string: .\n\nIts usage is pretty straightforward. checks if is found in and returns or accordingly.\n\nSo, thanks to , we can write the following code:\n\nWhich is more readable and less prone to errors (see this code in action here).\n\n At the time of this writing, is case-sensitive, but this could change in the future.\n\nThe proposal passed with 43 to 9 votes.\n\nIn addition to the function, two new functions allow to search for a needle inside a given string: and .\n\nThese new functions check if a given string starts or ends with another string:\n\nBoth functions return if is longer than .\n\nAccording to Will Hudgins, the author of this RFC,\n\nThanks to them, we could now avoid using sub-optimal and less intuitive functions like , . Both functions are case sensitive:\n\nYou can see this code in action here.\n\nThis RFC has been approved with 51 to 4 votes.\n\nis a new PHP function that returns the type of a variable. The new function works in quite a similar way as the function, but returns native type names and resolves class names.\n\nThat’s a good improvement for the language, as is not useful for type checking.\n\nThe RFC provides two useful examples to understand the difference between the new function and . The first example shows at work:\n\nWith PHP 8, we could use , instead:\n\nThe following table shows returning values of and :\n\nHere is a quick list of additional approved improvements coming with PHP 8:\n• Stringable interface: this RFC introduces a Stringable interface that is automatically added to classes implementing the method. The main goal here is to use the union type.\n• New DOM Living Standard APIs in ext/dom: this RFC proposes to implement the current DOM Living Standard to the PHP DOM extension by introducing new interfaces and public properties.\n• Static return type: PHP 8 introduces the usage of as return type next to and types.\n• Variable Syntax Tweaks: this RFC resolves some residual inconsistencies in PHP’s variable syntax.\n\nIf you’re wondering how fast PHP 8 is, we have the answer. We benchmarked 20 PHP platforms/configurations on 7 different PHP versions (5.6, 7.0, 7.1, 7.2, 7.3, and 8.0).\n\nPHP 8.0 emerged as the winner in most platforms that support it, including WordPress and Laravel.\n\nFor instance, WordPress on PHP 8.0 can handle 18.4% more requests per second than PHP 7.4. Likewise, Laravel on PHP 8.0 can run 8.5% more requests per second than PHP 7.3.\n\nIf your website or app is fully compatible with PHP 8.0, you should plan to update your server’s environment to PHP 8.0 as soon as possible. You (and your users) will definitely appreciate its performance benefits. However, please test your site thoroughly before updating.\n\nYou can read our PHP benchmarks article for more information, such as detailed performance data, insights, and pretty graphs!\n\nWhat a ride! In this post, we covered the most interesting optimizations and features coming with PHP 8. The most awaited of which is surely the Just in Time compiler, but there’s so much more with PHP 8.\n\nMake sure to bookmark this blog post for your future reference. 🤓\n\nNow it’s your turn: are you ready to test the new PHP features? Which one is your favorite? Drop a line in the comments section below."
    },
    {
        "link": "https://php.watch/versions/8.0",
        "document": "PHP 8.0 is a major version update and a remarkable milestone in PHP, as it brings several new features to type system, syntax, error handling, strings, object-oriented programming, and more.\n\nIt is the efforts of hundreds of people coming together to shape the future of a programming language that powers a significant portion of the Internet web sites and applications.\n\nPHP tries to be conservative with changes that can break a majority of the applications, and yet, it brings several new major features to PHP 8.0.\n\nFeatures such as Named Parameters, JIT, Attributes, and Constructor Properties bring major improvements and syntax changes, while several minor improvements such as to object migrations, improved error handling, and changes and improvements in operators and engine comparisons help seamlessly reduce the chances of overlooked bugs.\n\nThank you for all the contributors, of whom there are hundreds, for all your efforts, in PHP core, documentation, libraries, testing tools, extensions, authors, package maintainers, PHP developers, and everyone else including you ❤.\n\nPHP 8.0 allows named parameters in function/method calls in addition to traditional positional parameters.\n\nThis makes the function/method parameter names part of the public API. The non-standardized DocBlock expresses that the library does not provide backwards-compatibility for named parameters.\n\nAttributes allows declaring meta-data for functions, classes, properties, and parameters. Attributes map to PHP class names (declared with an Attribute itself), and they can be fetched programmatically with PHP Reflection API.\n\nAttributes makes it easy and performant to declare Attributes/annotations that previously required storing them in DocBlock comments, and parsing the string to infer them.\n\nA new syntax to declare class properties right from the class constructor ( magic method).\n\nIn the constructor, PHP 8.0 supports declaring the visibility ( , , or ) and type. Those properties will be registered as class properties with same visibility and type they are declared in the constructor.\n\nThis backwards-incompatible feature can help reduce boilerplate code when declaring value-object classes.\n\nPHP Opcache supports JIT. It's disabled by default, and if enabled, JIT compiles and caches native instructions. It does not make a noticeable difference in IO-bound web applications, but provides a performance boost for CPU-heavy applications.\n\nNote that JIT is still new, and had bug fixes as late as a day before PHP 8.0.0 release. It makes debugging and profiling more difficult with the added extra layer.\n\nUnion Types extend type declarations (return types, parameters, and class properties) to declare more than one type.\n\nIt also supports as a special type (for Boolean ), a trait that's prevalent in legacy code that did not use Exceptions.\n\nNull-safe operator provides safety in method/property chaining when the return value or property can be .\n\nThe null-safe operator short-circuits the rest of the expression if it encounters a value, and immediately returns without causing any errors.\n\nMatch expressions are similar to blocks, but blocks provide type-safe comparisons, supports a return value, does not require statements to break-out, and supports multiple matching values. it also guarantees that at least one branch is matched, ensuring all cases are accounted for.\n\nNot all blocks might convert well to blocks. Code that requires backwards-compatibility, blocks with multiple statements (as opposed to single-line expressions), or expects fall-through functionality still fits the statements.\n\nA WeakMap allows to store and associate arbitrary values for object keys, but without preventing the garbage collector from clearing it the object falls out of scope in everywhere else.\n\nA is similar to , as in both and use s as the key, and allows storage of arbitrary values. However, a does not prevent the object from being garbage collected.\n\nPHP 8.0 introduces a few new functions to ease string inspections (contains, starts with sub-string, or ends with sub-string) to replace the meticulous calls that are less readable, and error-prone due to weak type comparisons.\n\nPHP 8.0 also brings functions such as , , , and\n\nThe new interface is automatically added to all classes that implement method, and those explicitly declare that they .\n\nWith the interface, it is now easy to declare types as for on functions that can accept/return strings or objects with a method.\n\nThe new class provides a more fluent Object-Oriented interface as an alternative to the legacy array-based to function.\n\nPHP 8.0 improves typing system with the addition of Union Types and the type.\n\nUnion Types extend type declarations (return types, parameters, and class properties) to declare more than one type.\n\nIt also supports as a special type (for Boolean ), a trait that's prevalent in legacy code that did not use Exceptions.\n\nPHP 8.0 brings type, that was already being widely used in DocBlock comments.\n\ntype can be used to indicate that it accepts any type, or can return any type. In a class/interface context, type plays by the same rules of Liskov Substitution Principle.\n\nreturn type, already support as a DocBlock return type, is now supported in PHP 8.0. The return type declares an object of the called class will be returned.\n\nA major and backwards-incompatible change in PHP is that internal functions now throw exceptions on type errors or value errors.\n\nThis corrects PHP's historical behavior of emitting a warning, and returning when it encounters a value that it cannot use. This behavior is often undesired because PHP warnings does not halt the execution of the remaining block.\n\nAlmost entirety of PHP internal functions now enforce type checking, and instead of warnings, PHP now throws or ValueError exceptions. On legacy code bases, this change can cause issues, now that the errors are more boldly and unforgivably handled.\n\nPrior to PHP 8.0, it was not possible to exceptions from an expression (e.g a ternary statement). This is now allowed in PHP 8.0.\n\nIt is possible to exceptions by their type, without capturing the exception object.\n\nPHP 8.0 default configuration is to show all error messages by default. It was configured to hide deprecation and strict warnings in older versions.\n\nPHP now displays startup-errors (failure to load dynamic extensions, invalid INI configurations, etc) by default.\n\nPHP assertions ( ) now throw exceptions on assertion failures. Prior to PHP 8.0, it required an explicit configuration that was disabled by default.\n\nPHP 8.0 corrects the behavior of error suppression operator, where it silenced fatal errors, which lead to a script failure, because the operator does not prevent fatal errors, but rather hide the error message display.\n\nOne of the long-term efforts in PHP development was to move away from the types. They were difficult to deal with, and even in PHP 8.0, does not offer typing support.\n\nPHP objects do not play well with garbage-collector well either, which resulted in memory leaks in objects such as .\n\nIn PHP 8.0, some of the most used extensions changes moves away from the traditional objects to standard PHP classes.\n\nIn PHP 8.0, they are work as value-objects as opposed to fully-features classes with methods in them. Majority of these classes do not allow instantiating with the construct either, and must be instantiated with the existing functions that returned objects in prior versions.\n\nPHP 8.0's to object migration is quite seamless, as in all functions return and accept the new objects, and behave by the same semantics of the previous objects.\n\nPHP 8.0 is the first major version to be strict on Liskov Substitution Principle violations. Prior to PHP 8.0, PHP was not consistent on how it handled incompatible method signatures.\n\nIn PHP 8.0, all signature mismatches, including abstract traits, result in a fatal error. Further, it enforces signatures for PHP magic methods.\n\nPHP 8.0 throws fatal errors when Liskov Substitution Principle is not followed when classes are extended, or interfaces are implemented.\n\nFrom PHP 8.0 and later, magic methods (e.g , , etc), if they declare types, must implement the signature PHP expects. This is to avoid the smallest chance of the user declaring a magic method that doesn't follow the semantic meaning.\n\nDeclarations like was allowed in previous PHP versions, but PHP 8.0 and throws an exception if the signature does not meet the requirements.\n\nPHP 8.0 no longer allows calling class methods as a static method.\n\nPrevious versions emitted a deprecation notice, but from PHP 8.0 and later, this results in a fatal error.\n\nInheritance rules are not applied to class methods\n\nPHP 8.0 relaxes the signature, , and flag enforcement for class methods. This change comes from the rationale that methods are just that: Private.\n\nFrom PHP 8.0, it is now allowed for the child classes to declare abstract methods, and change static/flags for methods.\n\nmagic constant is now supported on objects\n\nThe magic constant returns the fully-qualified class name. This was only allowed on class names (such as ), but in PHP 8.0, the magic constant works on instantiated objects too.\n\nIn PHP 8.0, there are several subtle changes that might be not obvious at first, but can result in quite unexpected results.\n\nA major difference in PHP 8.0 is that, PHP now considers there is an empty string between every character in a given string.\n\nPrior to PHP 8.0, checking for an empty string needle ( ) was not allowed, but in PHP 8.0, PHP will happily accept it, and return that there is indeed an empty string between each character.\n\nThe multi-byte handling, or functions like still returns same values as the older versions, but all functions that check for a substring in a given string are changed.\n\nIn addition, PHP 8.0 changes how the string concatenation operator priorities, and supports new modifiers in functions such as and modifiers and width and precision modifier.\n\nThese functions clamp the needle and offset parameters to the string length, and returns an empty string instead of returning .\n\n/ operators take higher precedence when used with concat ( ) operator\n\nWhen the mathematical + and - operators are used in the same expression with the concatenation operator ( ), the + and - operators take higher precedence. This resulted in a deprecation notice in PHP versions prior to 8.0, but now it happens silently and as per the warning.\n\nWhen a value is coerced to , PHP no longer uses the locale. Prior to PHP 8.0, PHP considered the current locale (which is not thread-safe) or system locale when doing so. This resulted in inconsistent string outputs because certain locales, specially European ones, swap the thousand separator and decimal sign from the US locale. For locale-aware to cast, the modifier in class of functions can be used.\n\nIn addition, the new and modifiers for class of functions provide locale-indepdent variants of and modifiers.\n\nPHP 8.0 is an amazing effort from hundreds of awesome people. It's a major milesone in PHP's history. Thank you to everyone who helped from code, to documentation, to conferences, to articles to all of the developers."
    },
    {
        "link": "https://php.net/manual/en/migration80.new-features.php",
        "document": "Support for Named Arguments has been added. Support for Attributes has been added. Support for constructor property promotion (declaring properties in the constructor signature) has been added. Support for union types has been added. Support for expressions has been added. Support for the nullsafe operator ( ) has been added.\n• The WeakMap class has been added.\n• The ValueError class has been added.\n• Any number of function parameters may now be replaced by a variadic argument, as long as the types are compatible. For example, the following code is now allowed:\n• static (as in \"late static binding\") can now be used as a return type:\n• It is now possible to fetch the class name of an object using . The result is the same as .\n• and can now be used with arbitrary expressions, using and .\n• Some consistency fixes to variable syntax have been applied, for example writing is now allowed.\n• Added Stringable interface, which is automatically implemented if a class defines a __toString() method.\n• Traits can now define abstract private methods. Such methods must be implemented by the class using the trait.\n• can now be used as an expression. That allows usages like:\n• An optional trailing comma is now allowed in parameter lists. // <-- This comma is now allowed.\n• It is now possible to write to catch an exception without storing it in a variable.\n• Support for mixed type has been added.\n• Private methods declared on a parent class no longer enforce any inheritance rules on the methods of a child class (with the exception of final private constructors). The following example illustrates which restrictions have been removed: // Throws a warning, as \"final\" no longer has an effect:\n\n // All of the following are now allowed, even though the modifiers aren't\n\n // the same as for the private methods in the parent class.\n• get_resource_id() has been added, which returns the same value as . It provides the same functionality under a clearer API.\n• The InternalIterator has been added.\n\nhas been added as an alias for . The new name is preferred, as it uses the canonical type name.\n\nAdded a new option that allows getting the status from different endpoint (e.g. port or UDS file) which is useful for getting the status when all children are busy with serving long running requests.\n\nIf the opcache.record_warnings ini setting is enabled, OPcache will record compile-time warnings and replay them on the next include, even if it is served from cache.\n\nAdded Cryptographic Message Syntax (CMS) (» RFC 5652) support composed of functions for encryption, decryption, signing, verifying and reading. The API is similar to the API for #7 functions with an addition of new encoding constants: , and :\n• encrypts the message in the file with the certificates and outputs the result to the supplied file.\n• that decrypts the S/MIME message in the file and outputs the results to the supplied file.\n• that exports the CMS file to an array of certificates.\n• that signs the MIME message in the file with a cert and key and output the result to the supplied file.\n• that verifies that the data block is intact, the signer is who they say they are, and returns the certs of the signers.\n\nSQLite3::setAuthorizer() and respective class constants have been added to set a userland callback that will be used to authorize or not an action on the database.\n• str_contains(), str_starts_with() and str_ends_with() have been added, which check whether contains, starts with or ends with , respectively.\n• fdiv() has been added, which performs a floating-point division under IEEE 754 semantics. Division by zero is considered well-defined and will return one of , or .\n• get_debug_type() has been added, which returns a type useful for error messages. Unlike gettype(), it uses canonical type names, returns class names for objects, and indicates the resource type for resources.\n• printf() and friends now support the and format specifiers. These are the same as and , but always use as the decimal separator, rather than determining it through the locale.\n• printf() and friends now support using as width or precision, in which case the width/precision is passed as an argument to printf. This also allows using precision with , , and . For example, the following code can be used to reproduce PHP's default floating point formatting:\n• proc_open() now supports pseudo-terminal (PTY) descriptors. The following attaches , and to the same PTY:\n• proc_open() now supports socket pair descriptors. The following attaches a distinct socket pair to , and : Unlike pipes, sockets do not suffer from blocking I/O issues on Windows. However, not all programs may work correctly with stdio sockets.\n• Sorting functions are now stable, which means that equal-comparing elements will retain their original order.\n• array_diff(), array_intersect() and their variations can now be used with a single array as argument. This means that usages like the following are now possible: // OK even if $excludes is empty:\n\n // OK even if $arrays only contains a single array:\n• The parameter of ob_implicit_flush() was changed to accept a bool rather than an int.\n• The Zip extension has been updated to version 1.19.1.\n• New ZipArchive::setMtimeName() and ZipArchive::setMtimeIndex() to set the modification time of an entry.\n• New ZipArchive::registerProgressCallback() to provide updates during archive close.\n• New ZipArchive::registerCancelCallback() to allow cancellation during archive close.\n• New ZipArchive::replaceFile() to replace an entry content.\n• The property to get the index value of the last added entry has been added.\n• Errors can now be checked after an archive has been closed using the and properties, or the ZipArchive::getStatusString() method.\n• The option of ZipArchive::addGlob() and ZipArchive::addPattern() is now treated as an arbitrary string prefix (for consistency with the option), whereas formerly it was treated as a directory name.\n• Optional compression / encryption features are now listed in phpinfo."
    },
    {
        "link": "https://php.net/manual/en/language.oop5.basic.php",
        "document": "Basic class definitions begin with the keyword , followed by a class name, followed by a pair of curly braces which enclose the definitions of the properties and methods belonging to the class. The class name can be any valid label, provided it is not a PHP reserved word. As of PHP 8.4.0, using a single underscore as a class name is deprecated. A valid class name starts with a letter or underscore, followed by any number of letters, numbers, or underscores. As a regular expression, it would be expressed thus: . A class may contain its own constants, variables (called \"properties\"), and functions (called \"methods\"). The pseudo-variable is available when a method is called from within an object context. is the value of the calling object. Warning Calling a non-static method statically throws an Error. Prior to PHP 8.0.0, this would generate a deprecation notice, and would be undefined. Example #2 Some examples of the pseudo-variable \"\\$this is not defined.\n\n\" Output of the above example in PHP 7: $this is defined (A) Deprecated: Non-static method A::foo() should not be called statically in %s on line 27 $this is not defined. Deprecated: Non-static method A::foo() should not be called statically in %s on line 20 $this is not defined. Deprecated: Non-static method B::bar() should not be called statically in %s on line 32 Deprecated: Non-static method A::foo() should not be called statically in %s on line 20 $this is not defined. Output of the above example in PHP 8: $this is defined (A) Fatal error: Uncaught Error: Non-static method A::foo() cannot be called statically in %s :27 Stack trace: #0 {main} thrown in %s on line 27 As of PHP 8.2.0, a class can be marked with the readonly modifier. Marking a class as readonly will add the readonly modifier to every declared property, and prevent the creation of dynamic properties. Moreover, it is impossible to add support for them by using the AllowDynamicProperties attribute. Attempting to do so will trigger a compile-time error. As neither untyped nor static properties can be marked with the modifier, readonly classes cannot declare them either: A readonly class can be extended if, and only if, the child class is also a readonly class. To create an instance of a class, the keyword must be used. An object will always be created unless the object has a constructor defined that throws an exception on error. Classes should be defined before instantiation (and in some cases this is a requirement). If a variable containing a string with the name of a class is used with , a new instance of that class will be created. If the class is in a namespace, its fully qualified name must be used when doing this. If there are no arguments to be passed to the class's constructor, parentheses after the class name may be omitted. // This can also be done with a variable:\n\n As of PHP 8.0.0, using with arbitrary expressions is supported. This allows more complex instantiation if the expression produces a string. The expressions must be wrapped in parentheses. Example #4 Creating an instance using an arbitrary expression In the given example we show multiple examples of valid arbitrary expressions that produce a class name. This shows a call to a function, string concatenation, and the constant. Output of the above example in PHP 8: In the class context, it is possible to create a new object by and . When assigning an already created instance of a class to a new variable, the new variable will access the same instance as the object that was assigned. This behaviour is the same when passing instances to a function. A copy of an already created object can be made by cloning it. '$assigned will have this value' The above example will output: NULL NULL object(SimpleClass)#1 (1) { [\"var\"]=> string(30) \"$assigned will have this value\" } It's possible to create instances of an object in a couple of ways: // Through the variable containing an object\n\n The above example will output: It is possible to access a member of a newly created object in a single expression: // surrounding parentheses are optional as of PHP 8.4.0\n\n The above example will output something similar to: Note: Prior to PHP 7.1, the arguments are not evaluated if there is no constructor function defined. Class properties and methods live in separate \"namespaces\", so it is possible to have a property and a method with the same name. Referring to both a property and a method has the same notation, and whether a property will be accessed or a method will be called, solely depends on the context, i.e. whether the usage is a variable access or a function call. The above example will output: That means that calling an anonymous function which has been assigned to a property is not directly possible. Instead the property has to be assigned to a variable first, for instance. It is possible to call such a property directly by enclosing it in parentheses. Example #9 Calling an anonymous function stored in a property The above example will output: A class can inherit the constants, methods, and properties of another class by using the keyword in the class declaration. It is not possible to extend multiple classes; a class can only inherit from one base class. The inherited constants, methods, and properties can be overridden by redeclaring them with the same name defined in the parent class. However, if the parent class has defined a method or constant as final, they may not be overridden. It is possible to access the overridden methods or static properties by referencing them with parent::. Note: As of PHP 8.1.0, constants may be declared as final. The above example will output: When overriding a method, its signature must be compatible with the parent method. Otherwise, a fatal error is emitted, or, prior to PHP 8.0.0, an level error is generated. A signature is compatible if it respects the variance rules, makes a mandatory parameter optional, adds only optional new parameters and doesn't restrict but only relaxes the visibility. This is known as the Liskov Substitution Principle, or LSP for short. The constructor, and methods are exempt from these signature compatibility rules, and thus won't emit a fatal error in case of a signature mismatch. The above example will output: The following examples demonstrate that a child method which removes a parameter, or makes an optional parameter mandatory, is not compatible with the parent method. Output of the above example in PHP 8 is similar to: Fatal error: Declaration of Extend::foo() must be compatible with Base::foo(int $a = 5) in /in/evtlq on line 13 Example #13 Fatal error when a child method makes an optional parameter mandatory Output of the above example in PHP 8 is similar to: Fatal error: Declaration of Extend::foo(int $a) must be compatible with Base::foo(int $a = 5) in /in/qJXVC on line 13 Warning Renaming a method's parameter in a child class is not a signature incompatibility. However, this is discouraged as it will result in a runtime Error if named arguments are used. Example #14 Error when using named arguments and parameters were renamed in a child class The above example will output something similar to: Fatal error: Uncaught Error: Unknown named parameter $foo in /in/XaaeN:14 Stack trace: #0 {main} thrown in /in/XaaeN on line 14 The keyword is also used for class name resolution. To obtain the fully qualified name of a class use . This is particularly useful with namespaced classes. The above example will output: The class name resolution using is a compile time transformation. That means at the time the class name string is created no autoloading has happened yet. As a consequence, class names are expanded even if the class does not exist. No error is issued in that case. The above example will output: As of PHP 8.0.0, may also be used on objects. This resolution happens at runtime, not compile time. Its effect is the same as calling get_class() on the object. The above example will output: As of PHP 8.0.0, properties and methods may also be accessed with the \"nullsafe\" operator instead: . The nullsafe operator works the same as property or method access as above, except that if the object being dereferenced is then will be returned rather than an exception thrown. If the dereference is part of a chain, the rest of the chain is skipped. The effect is similar to wrapping each access in an is_null() check first, but more compact. // As of PHP 8.0.0, this line:\n\n // Is equivalent to the following code block:\n\n The nullsafe operator is best used when null is considered a valid and expected possible value for a property or method return. For indicating an error, a thrown exception is preferable.\n\naaron at thatone dot com ¶ I was confused at first about object assignment, because it's not quite the same as normal assignment or assignment by reference. But I think I've figured out what's going on.\n\n\n\nFirst, think of variables in PHP as data slots. Each one is a name that points to a data slot that can hold a value that is one of the basic data types: a number, a string, a boolean, etc. When you create a reference, you are making a second name that points at the same data slot. When you assign one variable to another, you are copying the contents of one data slot to another data slot.\n\n\n\nNow, the trick is that object instances are not like the basic data types. They cannot be held in the data slots directly. Instead, an object's \"handle\" goes in the data slot. This is an identifier that points at one particular instance of an obect. So, the object handle, although not directly visible to the programmer, is one of the basic datatypes. \n\n\n\nWhat makes this tricky is that when you take a variable which holds an object handle, and you assign it to another variable, that other variable gets a copy of the same object handle. This means that both variables can change the state of the same object instance. But they are not references, so if one of the variables is assigned a new value, it does not affect the other variable.\n\n\n\n\n\n$assignment has a different data slot from $objectVar, but its data slot holds a handle to the same object. This makes it behave in some ways like a reference. If you use the variable $objectVar to change the state of the Object instance, those changes also show up under $assignment, because it is pointing at that same Object instance.\n\n\n\n\n\nBut it is not exactly the same as a reference. If you null out $objectVar, you replace the handle in its data slot with NULL. This means that $reference, which points at the same data slot, will also be NULL. But $assignment, which is a different data slot, will still hold its copy of the handle to the Object instance, so it will not be NULL.\n\n\n\n kStarbe at gmail point com ¶ You start using :: in second example although the static concept has not been explained. This is not easy to discover when you are starting from the basics. Doug ¶ What is the difference between $this and self ?\n\n\n\nInside a class definition, $this refers to the current object, while self refers to the current class.\n\n\n\nIt is necessary to refer to a class element using self ,\n\nand refer to an object element using $this .\n\nNote also how an object variable must be preceded by a keyword in its definition.\n\n\n\nThe following example illustrates a few cases:\n\n\n\n Hayley Watson ¶ Class names are case-insensitive:\n\n\n\nAny casing can be used to refer to the class\n\n\n\nBut the case used when the class was defined is preserved as \"canonical\":\n\n\n\nAnd, as always, \"case-insensitivity\" only applies to ASCII.\n\n pawel dot zimnowodzki at gmail dot com ¶ Although there is no null-safe operator for not existed array keys I found workaround for it: ($array['not_existed_key'] ?? null)?->methodName() wbcarts at juno dot com ¶ CLASSES and OBJECTS that represent the \"Ideal World\"\n\n\n\nWouldn't it be great to get the lawn mowed by saying $son->mowLawn()? Assuming the function mowLawn() is defined, and you have a son that doesn't throw errors, the lawn will be mowed. \n\n\n\nIn the following example; let objects of type Line3D measure their own length in 3-dimensional space. Why should I or PHP have to provide another method from outside this class to calculate length, when the class itself holds all the neccessary data and has the education to make the calculation for itself?\n\n\n\n\n\n <-- The results look like this -->\n\n\n\nLine3D[start=Point3D(x=0, y=0, z=0), end=Point3D(x=1, y=1, z=1), length=1.73205080757]\n\n\n\nLine3D[start=Point3D(x=0, y=0, z=0), end=Point3D(x=100, y=100, z=0), length=141.421356237]\n\n\n\nLine3D[start=Point3D(x=0, y=0, z=0), end=Point3D(x=100, y=100, z=100), length=173.205080757]\n\n\n\nMy absolute favorite thing about OOP is that \"good\" objects keep themselves in check. I mean really, it's the exact same thing in reality... like, if you hire a plumber to fix your kitchen sink, wouldn't you expect him to figure out the best plan of attack? Wouldn't he dislike the fact that you want to control the whole job? Wouldn't you expect him to not give you additional problems? And for god's sake, it is too much to ask that he cleans up before he leaves?\n\n\n\nI say, design your classes well, so they can do their jobs uninterrupted... who like bad news? And, if your classes and objects are well defined, educated, and have all the necessary data to work on (like the examples above do), you won't have to micro-manage the whole program from outside of the class. In other words... create an object, and LET IT RIP! johannes dot kingma at gmail dot com ¶ BEWARE! \n\n\n\nLike Hayley Watson pointed out class names are not case sensitive. \n\n\n\n As well as\n\n \n\n\n\nIs perfectly fine and will return 'BAR'.\n\n\n\nThis has implications on autoloading classes though. The standard spl_autoload function will strtolower the class name to cope with case in-sensitiveness and thus the class BAR can only be found if the file name is bar.php (or another variety if an extension was registered with spl_autoload_extensions(); ) not BAR.php for a case sensitive file and operating system like linux. Windows file system is case sensitive but the OS is not and there for autoloading BAR.php will work. moty66 at gmail dot com ¶ I hope that this will help to understand how to work with static variables inside a class\n\n\n\n \n\nRegards\n\nMotaz Abuthiab Notes on stdClass ¶ stdClass is the default PHP object. stdClass has no properties, methods or parent. It does not support magic methods, and implements no interfaces.\n\n\n\nWhen you cast a scalar or array as Object, you get an instance of stdClass. You can use stdClass whenever you need a generic object instance.\n\n\n\nstdClass is NOT a base class! PHP classes do not automatically inherit from any class. All classes are standalone, unless they explicitly extend another class. PHP differs from many object-oriented languages in this respect.\n\n\n\nYou cannot define a class named 'stdClass' in your code. That name is already used by the system. You can define a class named 'Object'.\n\n\n\nYou could define a class that extends stdClass, but you would get no benefit, as stdClass does nothing.\n\n\n\n(tested on PHP 5.2.8) Jeffrey ¶ A PHP Class can be used for several things, but at the most basic level, you'll use classes to \"organize and deal with like-minded data\". Here's what I mean by \"organizing like-minded data\". First, start with unorganized data.\n\n\n\n\n\nNow to organize the data into PHP classes:\n\n\n\n\n\nNow here's what I mean by \"dealing\" with the data. Note: The data is already organized, so that in itself makes writing new functions extremely easy.\n\n\n\n\n\nImagination that each function you write only calls the bits of data in that class. Some functions may access all the data, while other functions may only access one piece of data. If each function revolves around the data inside, then you have created a good class. Anonymous ¶ At first I was also confused by the assignment vs referencing but here's how I was finally able to get my head around it. This is another example which is somewhat similar to one of the comments but can be helpful to those who did not understand the first example. Imagine object instances as rooms where you can store and manipulate your properties and functions. The variable that contains the object simply holds 'a key' to this room and thus access to the object. When you assign this variable to another new variable, what you are doing is you're making a copy of the key and giving it to this new variable. That means these two variable now have access to the same 'room' (object) and can thus get in and manipulate the values. However, when you create a reference, what you doing is you're making the variables SHARE the same key. They both have access to the room. If one of the variable is given a new key, then the key that they are sharing is replaced and they now share a new different key. This does not affect the other variable with a copy of the old key...that variable still has access to the first room"
    },
    {
        "link": "https://w3schools.com/php/php_oop_classes_objects.asp",
        "document": "A class is a template for objects, and an object is an instance of class.\n\nLet's assume we have a class named Fruit. A Fruit can have properties like name, color, weight, etc. We can define variables like $name, $color, and $weight to hold the values of these properties.\n\nWhen the individual objects (apple, banana, etc.) are created, they inherit all the properties and behaviors from the class, but each object will have different values for the properties.\n\nA class is defined by using the keyword, followed by the name of the class and a pair of curly braces ({}). All its properties and methods go inside the braces:\n\nBelow we declare a class named Fruit consisting of two properties ($name and $color) and two methods set_name() and get_name() for setting and getting the $name property:\n\nClasses are nothing without objects! We can create multiple objects from a class. Each object has all the properties and methods defined in the class, but they will have different property values.\n\nObjects of a class are created using the keyword.\n\nIn the example below, $apple and $banana are instances of the class Fruit:\n\nIn the example below, we add two more methods to class Fruit, for setting and getting the $color property:\n\nThe $this keyword refers to the current object, and is only available inside methods.\n\nLook at the following example:\n\nSo, where can we change the value of the $name property? There are two ways:\n\n1. Inside the class (by adding a set_name() method and use $this):\n\n2. Outside the class (by directly changing the property value):\n\nYou can use the keyword to check if an object belongs to a specific class:"
    },
    {
        "link": "https://specbee.com/blogs/introduction-php-standard-recommendation-psr",
        "document": "Once upon a time, at a conference, the lead developers from a selection of frameworks sat down in the same room and agreed on some standards for all their projects to use. The aim was to make PHP frameworks and libraries easier to combine for users. That is when php-fig: the PHP Framework Interop Group was born. This group of awesome individuals oversees the PHP Standards Recommendations (PSRs).\n\nThe PHP Standard Recommendation (PSR) is a PHP specification published by the PHP Framework Interoperability Group (PHP-FIG). It serves the standardization of programming concepts in PHP. The aim is to enable interoperability of components. The PHP-FIG is formed by several PHP frameworks founders. Dive into this article to learn about different PSRs and how you can adhere to them.\n\nThese describe a specification for auto loading classes from file paths. PSR-0 and PSR-4 are both standards concerning namespaces, class names and file paths. This PSR also describes where to place files that will be autoloaded according to the specification.\n\nAutoloading is a functionality to help developers including PHP classes automatically without writing cluttered include/require statements everywhere.\n\nIn PHP, class's definition is loaded with require or include statements in the files they are being called i.e., prior to using it as shown below.\n\nThe above approach raises some issues as if we have tens of external classes to be used in a file and we start writing lines of require/include statements right at the beginning of a source file.\n\nTo overcome this issue PHP 5 introduced the magic function __autoload() which is automatically called when your code references a class or interface that hasn’t been loaded yet.\n\nHere’s an example of a basic __autoload() implementation:\n\nThe major drawback to the __autoload() function is that you can only provide one autoloader with it. PHP 5.1.2 introduced another autoloading function (spl_autoload_register) for coping with __autoload 's limitation.\n\nThe introduction of spl_autoload_register() gave programmers the ability to create an autoload chain, a series of functions that can be called to try and load a class or interface.\n\nAutoloading was such a great idea that every project started to use it. Inevitably everyone created their own version of autoloader as uniform standards were lacking. Clearly, PHP desperately needed a standard for autoloader, which is how PSR-0 was born. The latest accepted autoloader standard is PSR-4.\n• A fully-qualified namespace and class must have the following structure \n\n\\<Vendor Name>\\(<Namespace>\\)*<Class Name>\n• Each namespace must have a top-level namespace (“Vendor Name”).\n• Each namespace can have as many sub-namespaces as it wishes.\n• Each namespace separator is converted to a DIRECTORY_SEPARATOR when loading from the file system.\n• Each _ character in the CLASS NAME is converted to a DIRECTORY_SEPARATOR. The _ character has no special meaning in the namespace.\n• The fully-qualified namespace and class are suffixed with .php when loading from the file system.\n• Alphabetic characters in vendor names, namespaces, and class names may be of any combination of lowercase and uppercase.\n• The term “class” refers to classes, interfaces, traits, and other similar structures.\n• A fully qualified class name has the following form:\n\n\\<NamespaceName>(\\<SubNamespaceNames>)*\\<ClassName>\n• The fully qualified class name MUST have a top-level namespace name, also known as a “vendor namespace”.\n• The fully qualified class name MAY have one or more sub-namespace names.\n• The fully qualified class name MUST have a terminating class name.\n• Underscores have no special meaning in any portion of the fully qualified class name.\n• Alphabetic characters in the fully qualified class name MAY be any combination of lowercase and uppercase.\n• All class names MUST be referenced in a case-sensitive fashion.\n\nExample for PSR-4 based Autoloading using Composer:\n• Consider the following directory structure to achieve PSR-4 based autoloading using composer.\n• Create a composer.json file using composer init. If not, you can create one manually now in your project’s root.\n• Set up PSR4 autoloading by editing the composer.json file as shown below:\n• Here, CodeCourse is a vendor name of your application, you can use this name while namespacing files inside of your src directory ,such as:\n• And src is your application’s directory that you want to autoload.\n• Next, open up your terminal and type in the following command to install autoloading files in your project.This will generate the vendor directory and autoload.php file inside of it.\n• Let’s first create a couple of classes inside of the CodeCourse directory.\n• Finally, create an index.php file to test it out and need to require once the autoload.php file once into your index.php file.\n\nPSR-1 and PSR-2 are useful for PHP coding standards. PSR-1 mainly focuses on the basic coding standard for PHP whereas PSR-2 is more like an expanded version of PSR-1. PSR-1 lists a set of simple rules for naming conventions and PSR-2 provides a more comprehensive coding style guide.\n• Only <?php or <?= are allowed for PHP tags.\n• Class names must be defined in UpperCamelCase.\n• Class variables must be defined in camelCase.\n• Class constants must be defined in UPPER_SNAKE_CASE.\n• Method names must be defined in camelCase.\n• Files SHOULD either declare symbols (classes, functions, constants, etc.) or cause side effects(e.g. generate output, change .ini settings, etc.) but SHOULD NOT do both. I.e.,\n\nThe above example causes a side effect, i.e., loading a file named “file.php”.\n• Files must be in UTF-8 without BOM(Byte Order Mark).\n• Namespaces and class names must follow the standards in PSR-0 and PSR-4.\n\nHere is an example that illustrates the basic naming conventions for properties, classes, and methods.\n• You must follow the PSR-1 coding standards.\n• 4 spaces must be used for indents. Using tabs is not allowed.\n• There is no limit to line length, but it should be under 120 characters, and best if under 80.\n• There must be one blank line after namespace declaration and there must be one blank line after the block of use declaration.\n• Opening curly braces for classes and methods must go on the next line and closing curly braces must go on the line after the body.\n• Methods and properties must be defined with abstract/final first, followed with public/protected, and finally static keyword.\n• You must not put a newline before curly braces in conditional statements.\n• You must not put any spaces before ( and ) in conditional statements.\n• An example for defining classes:\n• You must open the curly braces on the new line and the extends and the implements keyword must be used in a single line.\n\nIf there are multiple interfaces to implement, then you can write the interface names in the new line as shown below:\n\nExample to show how methods are defined in PHP:\n\nWhile defining the methods, the arguments should be written in the same line. Also, you must not put any whitespaces before commas in arguments, and you must put one whitespace after them.\n\nIf there are many number of arguments, then they can be written in newline one after the other:\n\nWhen defining methods, you must have either one of public/protected/private and abstract/final. The visibility modes come after the abstract/final keyword, if used. static is the last modifier.\n• You must put one whitespace before (\n• You must not put any whitespaces after (\n• You must not put any whitespaces before )\n• You must put one whitespace after )\n• use elseif rather than else if.\n\nExample to show the difference between elseif and else if:\n\nInterpretation of elseif:\n\nInterpretation of else if:\n• The curly braces must be opened in the same line where the switch statement is written.\n• The case body must be indented once from the case and the case must be indented once from the switch.\n• Use no break when break is not needed.\n• You can also use return instead of break.\n\nHuge shoutout to Samvada Jain for her contributions to this article.\n\nIn a project that is incorporated with various packages, it can be a mess if each individual uses a different coding standards. This is the reason why PSR was designed. In total, there are over 20 PSRs that are designed and each PSR is suggested by members and voted according to an established protocol to act consistently and in line with their agreed upon processes.\n\nOur expertise in PHP stems from our focus on Drupal - An enterprise CMS built using PHP. If you are looking to develop a custom module for Drupal or any other Drupal development services, talk to an expert Drupal development agency!"
    },
    {
        "link": "https://php.net/manual/en/language.types.callable.php",
        "document": "Callbacks can be denoted by the callable type declaration. Some functions like call_user_func() or usort() accept user-defined callback functions as a parameter. Callback functions can not only be simple functions, but also object methods, including static class methods. A PHP function is passed by its name as a string. Any built-in or user-defined function can be used, except language constructs such as: array(), echo, empty(), eval(), exit(), isset(), list(), print or unset(). A method of an instantiated object is passed as an array containing an object at index 0 and the method name at index 1. Accessing protected and private methods from within a class is allowed. Static class methods can also be passed without instantiating an object of that class by either, passing the class name instead of an object at index 0, or passing . Apart from common user-defined function, anonymous functions and arrow functions can also be passed to a callback parameter. As of PHP 8.1.0, anonymous functions can also be created using the first class callable syntax. Generally, any object implementing __invoke() can also be passed to a callback parameter. // A, deprecated as of PHP 8.2.0\n\n\n\n// Type 6: Objects implementing __invoke can be used as callables\n\n Example #2 Callback example using a Closure // This is our range of numbers\n\n // Use the closure as a callback here to\n\n// double the size of each element in our\n\n// range\n\n The above example will output: Callbacks registered with functions such as call_user_func() and call_user_func_array() will not be called if there is an uncaught exception thrown in a previous callback."
    },
    {
        "link": "https://php.net/manual/en/function.get-class.php",
        "document": "dodgie74 at NOSPAM dot yahoo dot NOSPAM dot co dot uk ¶ As noted in bug #30934 (which is not actually a bug but a consequence of a design decision), the \"self\" keyword is bound at compile time. Amongst other things, this means that in base class methods, any use of the \"self\" keyword will refer to that base class regardless of the actual (derived) class on which the method was invoked. This becomes problematic when attempting to call an overridden static method from within an inherited method in a derived class. For example:\n\n\n\n \n\nIn the above example, assuming runtime binding (where the keyword \"self\" refers to the actual class on which the method was invoked rather than the class in which the method is defined) would produce the output:\n\n\n\nMy Instance - Derived Class\n\n\n\nHowever, assuming compile-time binding (where the keyword \"self\" refers to the class in which the method is defined), which is how php works, the output would be:\n\n\n\nMy Instance - Base Class\n\n\n\nThe oddity here is that \"$this\" is bound at runtime to the actual class of the object (obviously) but \"self\" is bound at compile-time, which seems counter-intuitive to me. \"self\" is ALWAYS a synonym for the name of the class in which it is written, which the programmer knows so s/he can just use the class name; what the programmer cannot know is the name of the actual class on which the method was invoked (because the method could be invoked on a derived class), which it seems to me is something for which \"self\" ought to be useful.\n\n\n\nHowever, questions about design decisions aside, the problem still exists of how to achieve behaviour similar to \"self\" being bound at runtime, so that both static and non-static methods invoked on or from within a derived class act on that derived class. The get_class() function can be used to emulate the functionality of runtime binding for the \"self\" keyword for static methods:\n\n\n\n \n\nOutput:\n\nMy Instance - Derived Class\n\n\n\nI realise that some people might respond \"why don't use just just the class name with ' Class' appended instead of the classDisplayName() method\", which is to miss the point. The point is not the actual strings returned but the concept of wanting to use the real class for an overridden static method from within an inherited non-static method. The above is just a simplified version of a real-world problem that was too complex to use as an example.\n\n\n\nApologies if this has been mentioned before.\n\nyicheng zero-four at gmail dot com ¶ This a response to luke at liveoakinteractive dot com and davidc at php dot net. Static methods and variables, by definition, are bound to class types not object instances. You should not need to dynamically find out what class a static method belongs to, since the context of your code should make it quite obvious. Your questions reveals that you probably don't quite understand OOP quite yet (it took me a while as well).\n\n\n\nLuke, the observed behavior from your particular code snippet makes perfect sense when you think about it. The method getclass() is defined in BooBoof, so the __CLASS__ macro would be bound to BooBoof and defined in relation to the BooBoof class. The fact that CooCoof is a subclass of BooBoof just means that it gains a shortcut to BooBoof::getclass(). So, in effect, you are really asking (in a convoluted way): \"What is the class to which belongs the method call BooBoof::getclass()?\" The correct solution (if you actually want/need to do this) is to simply implement CooCoof::getclass() { return __CLASS__; } inside of the CooCoof definition, and any childclasses that you want to mimic this behavior. CooCoof::getclass() will have the expected behavior.\n\nFrederik Krautwald ¶ Due to PHP 5 engine that permits to get final class in a static called function, and this is a modified version of examples published below.\n\n\n\n \n\nI don't know about if performance would increase if debug_backtrace() is skipped and instead have getInstance() to accept a passed class retrieved by get_class() method as parameter as described in a post below.\n\n\n\nBy having set getInstance() to protected in the Singleton class, the function is required to be overridden (good OOP practice).\n\n\n\nOne thing to mention is, that there is no error checking in case $class is null or undefined, which would result in a fatal error. At the moment, though, I can't see how it could happen when the getInstance() is protected, i.e. has to be overridden in a subclass -- but with good coding practice you should always error check.\n\nmightye at gmail dot com ¶ To: Bryan\n\n\n\nIn this model it is still workable if your singleton variable is actually an array. Consider:\n\n This would output:\n\n$a is a A\n\n$b is a B\n\n\n\nThe only alternative as described elsewhere is to make getInstance() protected abstract, accept the class name as an argument, and extend this call with a public final method for every sub-class which uses get_class() in its local object scope and passes it to the superclass.\n\n\n\nOr else create a singleton factory like this:\n\n The downside to this of course to this latter model is that the class itself doesn't get to decide if it is a singleton, the calling code gets to decide this instead, and a class that really wants or *needs* to be a singleton has no way to enforce this, not even by making its constructor protected.\n\n\n\nBasically these design patterns, and various other meta manipulations (things which operate on the nature of the object, not on the data the object holds) could benefit greatly from knowing exactly what the final type of this object is, and not having native access to this information obligates work-arounds.\n\njanci ¶ To yicheng zero-four at gmail dot com: Another, maybe better example where finding out the real class (not the class we are in) in static method should be quite usefull is the Singleton pattern. \n\n\n\nThere is currently no way how to create an abstract Singleton class that could be used just by extending it without the need to change the extended class. Consider this example:\n\n This piece of code will result in a fatal error saying: Cannot instantiate abstract class Singleton in ... on line 11\n\n\n\nThe best way I figured out how to avoid this requires simple but still a change of the extended (Foo) class:\n\n \n\nThis is of course nothing horrible, you will propably need to change something in the extended class anyway (at least the constructor access), but still... it is just not as nice as it possibly could be ;)"
    }
]