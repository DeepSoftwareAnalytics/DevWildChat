[
    {
        "link": "https://python.plainenglish.io/draw-a-random-playing-card-in-python-848393d6d868",
        "document": "Welcome back! This is a beginner’s course in Python and Part 2 in a series. If you missed Part 1, check it out here.\n\nEver needed a random playing card but didn’t have a deck nearby? Me neither! However, there have been apps popping up with games or workout routines that are based on random card generators, so why not replicate one?\n\nIn order to do this, we will be learning the following:\n\nFirst thing’s first, head on over to Programmiz so you have your own environment to work in.\n\nTake a look at this code. Let’s start at the bottom, with the statement: In Python terms, it means “if I start the program in this file, run this code.” This is important because it helps us organize our code. And for clarity, answers “are these equal?” with True/False, which is what statements need.\n\nNow let’s talk about the statement itself, which is a conditional statement or a piece of logic that determines whether or not to execute some logic. We will talk more about statements a bit later but it’s important to note that all logic you want within the statement has to be indented, or have 4 spaces from the beginning of the if statement. Underneath that statement is , the function we see declared just above. Main is universal for “start here” and it will be where we execute most of our other functions and logic.\n\nJust above the function are our constants, or variables that won’t change throughout the program and are used primarily for reference. Variables are primarily split into 3 different types: local, class, and global. Local variables are accessed within functions and can’t be used outside those functions, class variables are declared within classes (ignore for now), and global variables can be referenced anywhere in the file. Local and class variables are always lowercase, with underscores used to separate the words used to describe them, and global variables or constants are always uppercase. There’s a long winded reason why constants are best practice involving run times and reusability outside our current file BUT we will leave that for another article.\n\nAs you can see, we have a constant for the suits of playing cards, and we have a constant for the ranks of the playing cards. Notice the brackets surrounding the strings? This indicates that the data type is a list. All of the comma separated strings within are the contents of the lists. Three important facts to note about lists in Python: len(list) returns the size of the list, the index for the first item in a list is 0, and python doesn’t care if the list contains different data types. If I wanted to print the “Diamonds” suite from , I would execute . Remove the double quotes around one of the numbers in . If you run the code, it won’t throw an error. Plus, since we are only printing out the values, we won’t have any code that expects a certain data type. Best Practice: Don’t mix data types in collections like lists. Just because we can doesn’t mean we should.\n\nNow, in order to get a random suite and rank, we just need to again, get one value from each constant, and print both to the console. Easy peasy!\n\nFortunately, Python has made this incredibly easy for us, as has a function made just for container data types like our lists: . Write the code below and hit run!\n\nThe code prints out two items, the suite and the rank, but that’s not how we read playing cards! Let’s combine our variables into one easy to read sentence using string formatting.\n\nThere are many ways to format strings to create what we want but I’m going to use my favorite: f-strings. Normal strings are indicated by placing double quotes around the text, like the contents of our SUITS and RANKS lists. However, if we place an before the string, we indicate we want it to be a formatted string, which allows us to insert variables and logic within the string. Let’s see it in action:\n\nBy wrapping our variables in , we can tell the formatter to execute the logic within, like getting the value of a variable. Now when we click run, the program will print out a random card in a human readable format, check it out! Side note: any valid logic can be run in , so the statement could have looked like and would have been executed just the same. However, using functions as arguments for other functions or in formatting can hurt the readability of the code. Personal Best Practice: Readability is King.\n\nWhat? You want to play Poker with this? Because the cards outputted are too random, duplicate cards will appear where there shouldn’t be. In order to play any card game, we need a full deck to draw from. If I were to build a poker card drawing program it would look like this:\n\nInstead of a list, I use a set collection for easy drawing using and use “list comprehension” to quickly construct the deck. After that, it’s just a matter of seeing how many players want to play poker and drawing their cards using a loop. The only problem? All the players would see each other’s cards!"
    },
    {
        "link": "https://stackoverflow.com/questions/17128748/dealing-cards-in-python",
        "document": "A number of problems, so I suggest the real fix would be to throw this away and start over.\n\nFirst thing to do: strings are for people, not computers, so don't represent cards as strings until you have to print something. Everywhere else, they should be numbers. Either a single number for each card, or a \"card\" object with numbers for rank and suit. Both player hands and decks are then just simple arrays (or in Python, lists).\n\nCreate a single global \"deck\" list from which to deal all the cards, initialize it with one of each, then deal to the player hands. There are two ways to deal random cards from a deck--your method is neither of them. Either (1) \"shuffle\" the deck using an algorithm called Fisher-Yates (Python's does this) and pop cards off the end of the deck array as you append them to hand arrays, or (2) To deal each card, select a card randomly from the remaining cards deck, append it to the hand, and remove it from the deck. This is also easy in Python with and .\n\nA minor pythonism: don't use \"str\" as a variable name, it's already a built-in type."
    },
    {
        "link": "https://medium.com/@haseebzeeshan2010/card-game-in-python-818261acdd2c",
        "document": "Welcome to the tutorial. In this tutorial, we are going to be making a card game in python.\n\nYou have 30 cards in a deck, 10 cards are black, 10 are yellow and 10 are red, note that each card has a number from 0–10, this makes them unique from all the other cards in the set. First, shuffle all the cards in the deck. Then each player must take 1 card each from the top of the deck and compare the colours to see which player wins the round. When you win a round, you take the other person’s card as well as keeping your card.\n\nAnd if the colours are the same, then check the number to see which player has the higher number, there cannot be a tie, because the number cannot be the same if it’s the same colour.\n\nThe Flowchart for the program:\n\nThe Pseudocode for the program:\n\nThe actual code for the program:\n\nAs you can see you have made your own card game, whenever I finally finish a program, I feel a sense of accomplishment, and hopefully, you do also. The point of this tutorial is to not only help you learn but to let you enjoy learning while you do it, as well as making a game to play whenever you’re bored."
    },
    {
        "link": "https://python-forum.io/thread-983.html",
        "document": "import random #Simulate the process of dealing of 1000 cards print \"Card dealing simulator\" print \"By:\" Club = 0 Dia = 0 Heart = 0 Spade = 0 ClubC = 0 DiaC = 0 HeartC = 0 SpadeC = 0 Count = 0 while True: Cards = (random.random() * 52) + 1 Count = Count + 1 if 0 < Cards < 14: ClubC = ClubC + 1 elif 14 < Cards < 27: DiaC = DiaC + 1 elif 26 < Cards < 40: HeartC = HeartC + 1 elif 39 < Cards < 53: SpadeC = SpadeC + 1 elif Count == 1000: print \"1000 cards have been dealt\" break print \"There were \" + str(ClubC) + \" clubs cards dealt\" print \"There were \" + str(DiaC) + \" diamonds cards dealt\" print \"There were \" + str(HeartC) + \" heart cards dealt\" print \"There were \" + str(SpadeC) + \" spade cards dealt\" raw_input() I'm having trouble with this code and i wanted to see if anyone can see a problem with the code. It runs occasionally but most of the time it only inputs the print type and doesn't do anything else.\n\n Part of my belief is that my computer may just not be able to handle the proccessing of 1000 runs through. I'm having trouble with this code and i wanted to see if anyone can see a problem with the code. It runs occasionally but most of the time it only inputs the print type and doesn't do anything else.Part of my belief is that my computer may just not be able to handle the proccessing of 1000 runs through. \n\n \n\n Also, what exactly are you trying to do here? randrange() is probably better to use, and for that matter, you really just want to select from four possibilities (such as with random.choice()), you don't need the range checking you have going on. Could you elaborate? What do you mean it \"only inputs the print type\"? Your computer probably isn't the problem.Also, what exactly are you trying to do here? randrange() is probably better to use, and for that matter, you really just want to select from four possibilities (such as with random.choice()), you don't need the range checking you have going on. Part of my belief is that my computer may just not be able to handle the proccessing of 1000 runs through. 1000 is nothing. The var Count was over a million by the time i got to ctrl + C to kill your program.\n\n \n\n your whole code reeks of C style. I would suggest a complete change, but to answer why you code does not work....\n\n \n\n you pretty much created an infinite loop by not allowing the exit clause to ever execute. \n\n this never executes because the var Cards is always between 0-53, and the if conditions before it checks for all these, never allowing the last elif to execute because one before it always does.\n\n \n\n what you are looking for is to create a second if structure by doing this instead\n\n or make the condition in the while loop 1000 is nothing. The var Count was over a million by the time i got to ctrl + C to kill your program.your whole code reeks of C style. I would suggest a complete change, but to answer why you code does not work....you pretty much created an infinite loop by not allowing the exit clause to ever execute.this never executes because the var Cards is always between 0-53, and the if conditions before it checks for all these, never allowing the last elif to execute because one before it always does.what you are looking for is to create a second if structure by doing this insteador make the condition in the while loop \n\n This is for illustration purposes of other ways to create a deck:\n\n \n\n Fluent Python is one of my favorite python books:\n\n \n\n # attribution: # “Fluent Python by Luciano Ramalho (O’Reilly). # Copyright 2015 Luciano Ramalho, 978-1-491-94600-8. import collections from random import shuffle Card = collections.namedtuple('Card', ['rank', 'suit']) class FrenchDeck(collections.MutableSequence): ranks = [str(n) for n in range(2, 11)] + list('JQKA') suits = 'spades diamonds clubs hearts'.split() def __init__(self): self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks] def __len__(self): return len(self._cards) def __getitem__(self, position): return self._cards[position] def __setitem__(self, position, value): # <1> self._cards[position] = value def __delitem__(self, position): # <2> del self._cards[position] def insert(self, position, value): # <3> self._cards.insert(position, value) def main(): deck = FrenchDeck() shuffle(deck) for card in deck: print(card) if __name__ == '__main__': main() I Wasn't too sure if I should add two cents or not.This is for illustration purposes of other ways to create a deck:Fluent Python is one of my favorite python books:"
    },
    {
        "link": "https://reddit.com/r/Python/comments/uwchvb/simple_poker_card_dealer",
        "document": "This project deals cards to 3 players, then displays the flop, turn, and river.\n\nEvery time a card is dealt it is removed from the deck.\n\nFor those unfamiliar with written poker hands, the s/c/h/d in lowercase refers to the suit of the card (spade/club/heart/diamond), so As Ts is Ace Ten of spades, for example.\n\nThis is my first project on my own applying what I've learned and wanted to share!\n\nAny constructive criticism on how to make the code more efficient is always appreciated."
    },
    {
        "link": "https://medium.com/@blakeeh723/how-to-build-a-card-game-with-object-oriented-programming-c43cd2cadb3a",
        "document": "Before we jump into any code, let’s brainstorm the pieces that make up a card game and break them down into smaller chunks (these will later represent our JavaScript objects). So, we have a card game, and this game will consist of:\n\nTo make things simple, let’s start with a bottom-up approach. What do you think is the smallest piece in our game? If you answered “card”, give yourself a pat on the back — you are starting to think like an object oriented programmer! The card is the smallest piece, or object, in our game. Let’s make our project structure now so we can create and test a card object:\n• In your text editor, create a new folder named “game”\n• Paste this code into your “index.html” file and save:\n\n5. Paste this into your “main.js” file and save:\n\nWe now have a project folder (game), and inside that folder a HTML file (index.html) that will automatically run the other file in our folder (main.js), and inside that main.js file, we are creating a JavaScript object (card) and logging it to the browser console. For the rest of this post, we will only need to edit our JavaScript file (main.js).\n\nIf you open “index.html” in Google Chrome, then open the Chrome Developer Tools, and click on “Console”, you should see your card object with its three properties: rank, suit, and value:\n\nThere are many different ways to open HTML files and developer tools in your web browser, so if you don’t know how please refer to Google as it depends on your web browser and text editor.\n\nNow that we have a card, we could continue implementing our game by creating 51 more cards, functions for those cards, and declare everything in our global scope, but we would end up writing a lot of duplicate code and it may become hard to organize and keep track of…\n\nJavaScript classes are a great way to make clean, reusable code and easily track the relationship between one object’s properties & functions and another object’s properties & functions. Follow along as I show you how we can use classes to write modular/organized programs.\n\nIn your “main.js” file, replace your current code with the following class:\n\nIf this looks foreign to you, don’t be afraid! The lines underneath of the “constructor” are actually very similar to the lines in our previous card object [we’ll talk about those soon]. For now, think of our card class as a factory that produces cards and our constructor as the template we will use to create a card. Before, we were creating one card with a suit of “clubs”, a rank of “2”, and a value of 2, but now we have the ability to produce as many cards as we want with whatever suit, rank, or value we provide in our template! 😃 Allow me to show you how we can use our constructor “template” to create a new card object:\n\nWasn’t that easy (and less lines of code)?! I named our card “awesomeCard” and used the keyword new to create a new card instance (also referred to as an object), passing in the 3 arguments we defined in our Card class’ constructor! See how our constructor is just like a template? If we log our awesomeCard to the console, we can see it, as well as, see that it’s an instance of our Card class:\n\nIf you’re still confused about what is going on inside the constructor, we use the keyword this to refer to any new card instance we make. The code below is stating that every card we make in our factory will have a “suit” property, which will be set to whatever we passed in when we created it (in this case, we passed in “an awesome suit”):\n\nWe are also stating that every card we produce will have a “rank” and “value” property, which we passed in as “Joker” and 100, respectively.\n\n🎉🎉🎉🎉🎉 CONGRATULATIONS!!! 🎉🎉🎉🎉🎉 You just created your first class and instance. Let’s use our Card class to start building out our deck!\n\nJust below your card class, add the following code:\n\nWe are creating our deck class (a factory that makes card decks) and stating in our constructor that every deck instance will have a “cards” property set to an empty array. We will use this array to hold our cards.\n\ncreateDeck() and shuffleDeck() are functions of our deck class and can be used on any deck instance we create. Some card games may require multiple decks, but we’ll just be creating one. Let’s build our createDeck() function to fill our cards array with 52 cards:\n\nI defined 3 arrays to hold all the possible suits, ranks, and values. The values array is needed for face cards (i.e. ace = 1 and king = 13) so we can compare the strength of two different cards. I then loop through each of the 4 suits and loop again through all 13 cards for each suit, pushing a new Card into our this.cards array each time (4 * 13 = 52 cards). Since the createDeck() function is inside our Deck class, we must use “this.cards” to access our cards array. Now, if we create a deck instance, call the createDeck() function on it, and log its cards array, we will see all 52 cards in the browser console:\n\nAs for the shuffleDeck() function, I will include the code at the end of this post. There are many different ways to shuffle an array, but for now, let’s move on to creating our Player class!\n\nOur player class will look similar to our card class and will only have 2 properties (playerName & playerCards):\n\nthis.playerName will equal a string that we pass into a new Player instance and this.playerCards will be an empty array. We can create players and deal them cards in our next class!\n\nOur Board class will be short and sweet so that you can implement whatever card game you wish to create. Adding a bunch of logic to your Board class is for you to research and exceeds the scope of this post. For now, let’s create an empty array for the cards that will be going in the middle of the board and name it cardsInMiddle. Then, let’s create another empty array to hold our Players and lastly, let’s create a function to start() the game. In our start function, we will push 2 new players to our this.players array, create a deck of cards, shuffle it, and assign each player half of the deck:\n\nIf we create a new game board instance and run the start() function while passing in our 2 player names, we can log our players array to see each player and their 26 shuffled cards:\n\nYou may want to add functions for playing a round or a property for keeping track of a winner, depending on the game logic you create. The best part is, your game and its logic is entirely UP TO YOU!"
    },
    {
        "link": "https://stackoverflow.com/questions/6728363/architecting-a-collectable-card-game",
        "document": "I'm trying to learn how to program a (virtual) Trading Card Game game (similar to Magic the Gathering) in Javascript. I've read a little about MVC architecture and controllers, but it's all over my head (I don't have any formal CS education) and I'm wondering if anyone has any good links or tips about how I might learn more about code architecture at a beginner's level.\n\nWould each \"card\" be represented as an object, and all the logic of the cards' rules be wrapped inside one large game engine function, or many small functions that are connected to each other?\n\nHere's an example question: Imagine there's a card which says, \"When this card comes into play, draw a card.\" How should I architect the game to prepare for this situation, and how is it triggered (most efficiently)? Does the card trigger the game engine, or does the game engine parse each card that's played?\n\nHere's another example: Imagine there's a card which says, \"All your cards cost 1 less to play.\" and it stays in play permanently. How does the game understand that it needs to alter its rules in this case? Is this a function which listens for card to be played and interrupts the cost? As each turn resolves, where is this rule stored? Are there variables which store the base rules of the game (global card cost modifier: 0; your card cost modifier: 0) and other variables which store those new rules which cards introduce (your card cost modifier: -1), or are these variables dynamically created by the game engine as cards alter the rules (your elf cost modifier: -2)? And how do the rules know to change when a card has been destroyed, thus removing the card's rule modification?\n\nIs what I need a primer on listeners and events? (I don't really know anything about them, but I've seen references to them from time to time.) Could you point me in the direction of a good resource?\n\nTo be clear, I'm not trying to make a long-winded request for folks to manually Google for me; I'm blindly fumbling in the dark and asking if someone would point me to the right words or phrases to search. Thank you!"
    },
    {
        "link": "https://geeksforgeeks.org/build-a-memory-card-game-using-html-css-and-javascript",
        "document": "A memory game is a type of game that can be used to test or check the memory of a human being. It is a very famous game. In this game, the player has some cards in front of him and all of them facing down initially. The player has to choose a pair of cards at one time and check whether the faces of both cards are matching or not. If the faces of both cards are the same, then the player can keep those cards face up and continue. Otherwise, the player needs to put the picked cards back face down and continue by selecting other cards. In this article, we are going to build a memory game with the help of HTML, CSS, and JavaScript.\n• None Create a basic structure for you games using the HTML tags like div, heading, paragraph, img etc. with the particular Classes and Ids associated with each one of them.\n• None Now, select the elements with the help of class and id CSS selectors to style the elements and make the UI attractive and interactive.\n• None After HTML and CSS, its time to get all the required elements inside the JavaScript code and apply logic on them.\n• None In JavaScript, we will create an array of objects with the image link, respective alt value and ID for each item of the array.\n• None In the next part, a callback function will be created to handle the click event of the cards. This function will handle the card flips whether the flipped card is same or different by removing and ading the classes to the elements.\n• None Next, another callback function will be created to handle the Restart Game button click, it will shuffle all the cards and flip them backward again to restart the game.\n• None At the end, we will check for the condition where game ends and show the result to the user by using the window.alert() method of JavaScript.\n\nExample: The below example will explain how you can create an memory card game using HTML, CSS and JavaScript:\n\nOutput: The below output will show you a demo of the above card game:"
    },
    {
        "link": "https://bomberbot.com/javascript/improve-your-javascript-skills-by-coding-a-card-game",
        "document": "As a full-stack developer, one of the best ways to sharpen your front-end development skills is by building interactive projects with JavaScript. Implementing common UI patterns like games provides an opportunity to practice key programming concepts in a fun, engaging way.\n\nIn this article, we‘ll walk through the process of building a card matching game using vanilla JavaScript, HTML, and CSS. Along the way, you‘ll level up your JS abilities in areas like:\n\nBut the learning doesn‘t stop there! Styling the game will flex your CSS muscles as you dive into responsive layouts with Grid and Flexbox, CSS animations and transitions, and more.\n\nBy the end, you‘ll not only have a fully functional game to play or add to your portfolio, but you‘ll also walk away with a handful of transferable, real-world programming techniques you can apply to any front-end development project. Let‘s get started!\n\nBefore diving into the code, let‘s make sure you have the tools needed.\n• Code Editor – Any text editor will work, but I highly recommend using Visual Studio Code. It‘s free, runs everywhere, and has a massive extensions library to supercharge your coding. I use it for all my web development.\n• Local Server – To properly load assets and test features like local storage, you‘ll need to run the project on a web server instead of opening the files directly in your browser. If you‘re using VS Code, the Live Server extension makes this a breeze. It starts up a development server and automatically reloads the page whenever you save changes.\n• Starter Files – Create a new folder for the project with three files:\n\nWith that, you‘re ready to start building! I encourage you to follow along and type out the code samples to get hands-on practice. If you get stuck, you can always refer to the [complete source code]().\n\nLet‘s begin by scaffolding out the game‘s HTML in index.html. We‘ll need:\n• A to display the game title and some controls\n\nEach card will need to display an icon or image and maybe some text. We‘ll also use data attributes to track its state (face-up or face-down) and its matched pair.\n\nSince the number of cards is variable based on the game options, we‘ll generate the cards dynamically with JavaScript in a bit. For now, just include one \"dummy\" card element as a reference for styling.\n\nWith the HTML skeleton in place, let‘s turn our attention to the JavaScript needed to power the game engine. We‘ll use an object to track the game state:\n\nThe array will hold objects representing each card and its state. We‘ll populate this when starting a new game based on the chosen difficulty level.\n\nTo kick things off, let‘s flesh out the function attached to the \"New Game\" button click:\n\nThis prompts the player to choose a deck size, generates an array of unique cards and their duplicates, shuffles them, and renders the cards to the page. It also kicks off a timer to track how long the game takes.\n\nThe meat of the gameplay happens in the event listener callback:\n\nWhen a card is clicked, it‘s flipped over (if valid) and added to the array. If two cards are flipped, the move count is incremented and we check for a match.\n\nFor matches, both cards are marked as \"matched\" and a check is done to see if the game has been won (all cards matched). For mismatches, the cards are flipped face-down again after a slight delay.\n\nThe helper function can flip a card in either direction based on an optional second argument:\n\nThe rest of the logic is filled out with small helper functions like , , , and so on. Breaking the code into small, focused functions like this makes it more readable and maintainable.\n\nNow for the fun part – making the game look great! In styles.css, we can set up some basic styles for the page layout and the cards themselves.\n\nThe game board is a perfect use case for CSS Grid:\n\nThe and on the game board, plus and the transforms on the card faces set up the \"flip\" effect. The class is toggled by the helper function.\n\nMedia queries make it easy to adjust the card and font sizes for different screen widths:\n\nTo jazz it up further, add a celebratory animation when the game is won:\n\nWith the core game complete, it‘s time to think about some extra features and enhancements:\n• Difficulty levels – Add buttons to choose between easy, medium, and hard difficulties. The harder the mode, the more cards to match.\n• High scores – Use to save the player‘s best times for each difficulty. Display a leaderboard on the page.\n• Accessibility – Ensure the game is playable with keyboard navigation and assistive technologies like screen readers. The ARIA spec has many techniques for this.\n• Sound effects – Add satisfying sounds when cards are flipped, matched, and when the game is won. Libraries like Howler.js make working with audio in JS a breeze.\n• Multiplayer – Allow two players to compete head-to-head using WebSockets.\n• PWA functionality – Make the game installable and playable offline by adding a web app manifest and service worker.\n\nBuilding this card matching game covers a wide swath of front-end web development skills. But the learning doesn‘t stop there!\n\nPracticing these techniques consistently is the key to internalizing them. Seek out coding challenges and tutorials to continue honing your craft. You can find a ton of free resources on sites like freeCodeCamp and Frontend Mentor.\n\nMost importantly, build more projects! Create a Minesweeper clone, a Wordle-inspired word guessing game, or a virtual pet simulator. The more you stretch your skills, the more confident and capable you‘ll become.\n\nIf you‘re looking to level-up your back-end development skills next, try implementing this game using a JS framework like React, Angular, or Vue. You can even hook it up to a backend API using Node and Express or Firebase.\n\nCongratulations on making it to the end! Take a moment to appreciate the working game you‘ve built from scratch. Developing a project like this is no small achievement.\n\nI hope this deep dive has given you not only a fun game to play and share, but also a newfound confidence in your JavaScript and front-end development skills. You‘re well on your way to becoming a JS ninja!\n\nRemember, the road to mastery is paved with consistent practice and a dedication to continuous learning. Keep coding, keep building, and most importantly, keep having fun! Happy coding!"
    },
    {
        "link": "https://dev.to/victormagarlamov/simple-card-game-with-js-30ci",
        "document": "Hi folks! I want to show you a game I made with React. It’s a popular russian card-game - Fool (or Durak). I created this project for fun and some practice with React and CSS. You can see the source code and result here.\n\nAnd also I want to tell you how I organized a game logic and which design patterns I used in this.\n\nIn this game, the game process can be divided into several basic steps.\n• take cards if you cannot beat\n• remove cards from the table if the attack is over\n\nAs you can see, each of these steps is an action - ‘to deal...’, ‘to choose...’, ‘to discard...’ And these actions are ordered. And the game process dependents on the result of this actions. Also some actions have options (for example, ‘discard a card’).\n\nThis pattern is ideal in this case. With this pattern we implement the logic of the actions in different classes, instead of different functions as usual. These classes will share the same \"public\" interface. As usually it is the ‘apply’ (or ‘execute’) method, which returns a result of the command.\n\nOur next step will be creating instances of these command. Then we will call the apply method, which calls the ‘setByTrump’ и ‘moveCardsToPlayer’, which contain all main logic for our commands.\n\nThis is one of my favorite pattern)\n\nI used a queue (FIFO) as the command container. When a new command is added, a new queue node is created and a link to that node is stored in the current last node. Then at the beginning of each frame we check if there are any commands in the queue. If there are, we apply the first command. If its result has completed status, then this command will be removed.\n\nThis pattern is excellent for actions like ‘discard a card’, when behavior depends on some factor. In our case the factor is the player.\n\nIf the current player is an attacker, we need to check if there are open cards on the table and the like.\n\nIf the current player is a defender, the result of the command will depend on the rank of the card.\n\nHere is an example strategy:\n\n\n\nOne of my favorite pattern too)\n\nYou know, I had fun when I was making this game. I think it's important sometimes to do something just like that - for the soul. In my case, it reminds me why I decided to become a programmer )))"
    }
]