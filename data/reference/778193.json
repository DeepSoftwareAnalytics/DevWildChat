[
    {
        "link": "https://stackoverflow.com/questions/17232013/how-to-set-the-pandas-dataframe-data-left-right-alignment",
        "document": "I use to set the column header. But I can't find the option for data by . How to set the data within a dataframe display left or right alignment for each column? Or, is it possible to define a format template for the whole row data display?"
    },
    {
        "link": "https://geeksforgeeks.org/ways-to-apply-left-right-mid-in-pandas",
        "document": "Many times we need to extract specific characters present within a string in Pandas data frame. In order to solve this issue, we have concept of Left, Right, and Mid in pandas.\n\nExample 1: Extract Characters From the Left\n\nExample 2: Extract Characters From the Right\n\nExample 3: Extract Characters From the Middle\n\nExample 4 : Before a symbol using str.split() function\n\nExample 5 : Between identical symbols using str.split() function"
    },
    {
        "link": "https://pandas.pydata.org/docs/user_guide/style.html",
        "document": "This section demonstrates visualization of tabular data using the Styler class. For information on visualization with charting please see Chart Visualization. This document is written as a Jupyter Notebook, and can be viewed or downloaded here.\n\nStyling and output display customisation should be performed after the data in a DataFrame has been processed. The Styler is not dynamically updated if further changes to the DataFrame are made. The attribute is a property that returns a Styler object. It has a method defined on it so it is rendered automatically in Jupyter Notebook. The Styler, which can be used for large data but is primarily designed for small data, currently has the ability to output to these formats: The first three of these have display customisation methods designed to format and customise the output. These include:\n• None Formatting values, the index and columns headers, using .format() and .format_index(),\n• None Renaming the index or column header labels, using .relabel_index()\n• None Hiding certain columns, the index and/or column headers, or index names, using .hide()\n\nThe Styler distinguishes the display value from the actual value, in both data values and index or columns headers. To control the display value, the text is printed in each cell as a string, and we can use the .format() and .format_index() methods to manipulate this according to a format spec string or a callable that takes a single value and returns a string. It is possible to define this for the whole table, or index, or for individual columns, or MultiIndex levels. We can also overwrite index names. Additionally, the format function has a precision argument to specifically help format floats, as well as decimal and thousands separators to support other locales, an na_rep argument to display missing data, and an escape and hyperlinks arguments to help displaying safe-HTML or safe-LaTeX. The default formatter is configured to adopt pandas’ global options such as option, controllable using Using Styler to manipulate the display is a useful feature because maintaining the indexing and data values for other purposes gives greater control. You do not have to overwrite your DataFrame to display it how you like. Here is a more comprehensive example of using the formatting functions whilst still relying on the underlying data for indexing and calculations. The index and column headers can be completely hidden, as well subselecting rows or columns that one wishes to exclude. Both these options are performed using the same methods. The index can be hidden from rendering by calling .hide() without any arguments, which might be useful if your index is integer based. Similarly column headers can be hidden by calling .hide(axis=”columns”) without any further arguments. Specific rows or columns can be hidden from rendering by calling the same .hide() method and passing in a row/column label, a list-like or a slice of row/column labels to for the argument. Hiding does not change the integer arrangement of CSS classes, e.g. hiding the first two columns of a DataFrame means the column class indexing will still start at , since and are simply ignored. To invert the function to a show functionality it is best practice to compose a list of hidden items. Two or more Stylers can be concatenated together provided they share the same columns. This is very useful for showing summary statistics for a DataFrame, and is often used in combination with DataFrame.agg. Since the objects concatenated are Stylers they can independently be styled as will be shown below and their concatenation preserves those styles.\n\nThe Styler was originally constructed to support the wide array of HTML formatting options. Its HTML output creates an HTML and leverages CSS styling language to manipulate many parameters including colors, fonts, borders, background, etc. See here for more information on styling HTML tables. This allows a lot of flexibility out of the box, and even enables web developers to integrate DataFrames into their exiting user interface designs. Below we demonstrate the default output, which looks very similar to the standard DataFrame HTML representation. But the HTML here has already attached some CSS classes to each cell, even if we haven’t yet created any styles. We can view these by calling the .to_html() method, which returns the raw HTML as string, which is useful for further processing or adding to a file - read on in More about CSS and HTML. This section will also provide a walkthrough for how to convert this default output to represent a DataFrame output that is more communicative. For example how we can build : The first step we have taken is the create the Styler object from the DataFrame and then select the range of interest by hiding unwanted columns with .hide().\n\nTable styles are flexible enough to control all individual parts of the table, including column headers and indexes. However, they can be unwieldy to type for individual data cells or for any kind of conditional formatting, so we recommend that table styles are used for broad styling, such as entire rows or columns at a time. Table styles are also used to control features which can apply to the whole table at once such as creating a generic hover functionality. The pseudo-selector, as well as other pseudo-selectors, can only be used this way. To replicate the normal format of CSS selectors and properties (attribute value pairs), e.g. the necessary format to pass styles to .set_table_styles() is as a list of dicts, each with a CSS-selector tag and CSS-properties. Properties can either be a list of 2-tuples, or a regular CSS-string, for example: # for row hover use <tr> instead of <td> Next we just add a couple more styling artifacts targeting specific parts of the table. Be careful here, since we are chaining methods we need to explicitly instruct the method not to the existing styles. As a convenience method (since version 1.2.0) we can also pass a dict to .set_table_styles() which contains row or column keys. Behind the scenes Styler just indexes the keys and adds relevant or classes as necessary to the given CSS selectors.\n\nWe use the following methods to pass your style functions. Both of those methods take a function (and some other keyword arguments) and apply it to the DataFrame in a certain way, rendering CSS styles.\n• None .map() (elementwise): accepts a function that takes a single value and returns a string with the CSS attribute-value pair.\n• None .apply() (column-/row-/table-wise): accepts a function that takes a Series or DataFrame and returns a Series, DataFrame, or numpy array with an identical shape where each element is a string with a CSS attribute-value pair. This method passes each column or row of your DataFrame one-at-a-time or the entire table at once, depending on the keyword argument. For columnwise use , rowwise use , and for the entire table at once use . This method is powerful for applying multiple, complex logic to data cells. We create a new DataFrame to demonstrate this. For example we can build a function that colors text if it is negative, and chain this with a function that partially fades cells of negligible value. Since this looks at each element in turn we use . We can also build a function that highlights the maximum value across rows, cols, and the DataFrame all at once. In this case we use . Below we highlight the maximum in a column. We can use the same function across the different axes, highlighting here the DataFrame maximum in purple, and row maximums in pink. This last example shows how some styles have been overwritten by others. In general the most recent style applied is active but you can read more in the section on CSS hierarchies. You can also apply these styles to more granular parts of the DataFrame - read more in section on subset slicing. It is possible to replicate some of this functionality using just classes but it can be more cumbersome. See item 3) of Optimization Debugging Tip: If you’re having trouble writing your style function, try just passing it into . Internally, uses so the result should be the same, and with you will be able to inspect the CSS string output of your intended function in each cell. Acting on the Index and Column Headers# Similar application is achieved for headers by using:\n• None .map_index() (elementwise): accepts a function that takes a single value and returns a string with the CSS attribute-value pair.\n• None .apply_index() (level-wise): accepts a function that takes a Series and returns a Series, or numpy array with an identical shape where each element is a string with a CSS attribute-value pair. This method passes each level of your Index one-at-a-time. To style the index use and to style the column headers use . You can select a of a but currently no similar application is available for these methods.\n\nTable captions can be added with the .set_caption() method. You can use table styles to control the CSS relevant to the caption. Adding tooltips (since version 1.3.0) can be done using the .set_tooltips() method in the same way you can add CSS classes to data cells by providing a string based DataFrame with intersecting indices and columns. You don’t have to specify a name or any css for the tooltips, since there are standard defaults, but the option is there if you want more visual control. 'This model has a very strong true positive rate' \"This model's total number of false negatives is too high\" The only thing left to do for our table is to add the highlighting borders to draw the audience attention to the tooltips. We will create internal CSS classes as before using table styles. Setting classes always overwrites so we need to make sure we add the previous classes.\n\nThe examples we have shown so far for the and functions have not demonstrated the use of the argument. This is a useful argument which permits a lot of flexibility: it allows you to apply styles to specific rows or columns, without having to code that logic into your function. The value passed to behaves similar to slicing a DataFrame;\n• None A list (or Series or NumPy array) is treated as multiple column labels Consider using to construct the tuple for the last one. We will create a MultiIndexed DataFrame to demonstrate the functionality. We will use subset to highlight the maximum in the third and fourth columns with red text. We will highlight the subset sliced region in yellow. If combined with the as suggested then it can index across both dimensions with greater flexibility. This also provides the flexibility to sub select rows when used with the . There is also scope to provide conditional filtering. Suppose we want to highlight the maximum across columns 2 and 4 only in the case that the sum of columns 1 and 3 is less than -2.0 (essentially excluding rows ). Only label-based slicing is supported right now, not positional, and not callables. If your style function uses a or keyword argument, consider wrapping your function in a , partialing out that keyword.\n\nSome styling functions are common enough that we’ve “built them in” to the , so you don’t have to write them and apply them yourself. The current list of such functions is:\n• None .highlight_null: for use with identifying missing data.\n• None .highlight_min and .highlight_max: for use with identifying extremeties in data.\n• None .highlight_between and .highlight_quantile: for use with identifying classes within data.\n• None .background_gradient: a flexible method for highlighting cells based on their, or other, values on a numeric scale.\n• None .text_gradient: similar method for highlighting text based on their, or other, values on a numeric scale. The individual documentation on each function often gives more examples of their arguments. This method accepts ranges as float, or NumPy arrays or Series provided the indexes match. Useful for detecting the highest or lowest percentile values You can create “heatmaps” with the and methods. These require matplotlib, and we’ll use Seaborn to get a nice colormap. .background_gradient and .text_gradient have a number of keyword arguments to customise the gradients and colors. See the documentation. Use when the style doesn’t actually depend on the values. This is just a simple wrapper for where the function returns the same properties for all cells. You can include “bar charts” in your DataFrame. Additional keyword arguments give more control on centering and positioning, and you can pass a list of to highlight lower and higher values or a matplotlib colormap. To showcase an example here’s how you can change the above with the new option, combined with setting and limits, the of the figure, and underlying css of cells, leaving space to display the text and the bars. We also use to color the text the same as the bars using a matplotlib colormap (although in this case the visualization is probably better without this additional effect). The following example aims to give a highlight of the behavior of the new align options:\n\nMore About CSS and HTML# Cascading Style Sheet (CSS) language, which is designed to influence how a browser renders HTML elements, has its own peculiarities. It never reports errors: it just silently ignores them and doesn’t render your objects how you intend so can sometimes be frustrating. Here is a very brief primer on how creates HTML and interacts with CSS, with advice on common pitfalls to avoid. The precise structure of the CSS attached to each cell is as follows.\n• None Cells with Index and Column names include and where is its level in a MultiIndex\n• \n• None where is the level in a MultiIndex\n• None where is the numeric position of the row\n• \n• None where is the level in a MultiIndex\n• None where is the numeric position of the column\n• \n• None , where is the numeric position of the cell.\n• None , where is the numeric position of the cell. The structure of the is where is used only on headings, and headings will only have either or whichever is needed. By default we’ve also prepended each row/column identifier with a UUID unique to each DataFrame so that the style from one doesn’t collide with the styling from another within the same notebook or page. You can read more about the use of UUIDs in Optimization. We can see example of the HTML by calling the .to_html() method. The examples have shown that when CSS styles overlap, the one that comes last in the HTML render, takes precedence. So the following yield different results: This is only true for CSS rules that are equivalent in hierarchy, or importance. You can read more about CSS specificity here but for our purposes it suffices to summarize the key points: A CSS importance score for each HTML element is derived by starting at zero and adding:\n• None 10 for each attribute, class or pseudo-class\n• None 1 for each element name or pseudo-element Let’s use this to describe the action of the following configurations This text is red because the generated selector is worth 101 (ID plus element), whereas is only worth 100 (ID), so is considered inferior even though in the HTML it comes after the previous. In the above case the text is blue because the selector is worth 110 (ID plus class), which takes precedence. Now we have created another table style this time the selector (ID plus element plus class) gets bumped up to 111. If your style fails to be applied, and its really frustrating, try the trump card. Finally got that green text after all!\n\nThe core of pandas is, and will remain, its “high-performance, easy-to-use data structures”. With that in mind, we hope that accomplishes two goals\n• None Provide an API that is pleasing to use interactively and is “good enough” for many tasks\n• None Provide the foundations for dedicated libraries to build on If you build a great library on top of this, let us know and we’ll link to it. If the default template doesn’t quite suit your needs, you can subclass Styler and extend or override the template. We’ll show an example of extending the default template to insert a custom header before each table. We’ll use the following template: Now that we’ve created a template, we need to set up a subclass of that knows about it. Notice that we include the original loader in our environment’s loader. That’s because we extend the original template, so the Jinja environment needs to be able to find it. Now we can use that custom styler. It’s takes a DataFrame. Our custom template accepts a keyword. We can provide the value in the method. For convenience, we provide the method that does the same as the custom subclass. Here’s the template structure for the both the style generation template and the table generation template: See the template in the GitHub repo for more details."
    },
    {
        "link": "https://stackoverflow.com/questions/20970279/how-to-do-a-left-right-and-mid-of-a-string-in-a-pandas-dataframe",
        "document": "in a pandas dataframe how can I apply a sort of excel left('state',2) to only take the first two letters. Ideally I want to learn how to use left,right and mid in a dataframe too. So need an equivalent and not a \"trick\" for this specific example.\n\nI want to get this:"
    },
    {
        "link": "https://geeksforgeeks.org/align-columns-to-left-in-pandas-python",
        "document": "Pandas library is useful for performing exploratory data analysis in Python. A pandas dataframe represents data in a tabular format. We can perform operations on the data and display it. In this article, we are going to align columns to the Left in Pandas. When we display the Dataframe, we can align the data in the columns as left, right, or center.\n\nIn order to align columns to the left in Pandas Dataframe, we use the dataframe.style.set_properties() function.\n\nThe default is right alignment as we can see in the below example.\n\nAlign Columns to Left in Pandas in Python\n\nBelow are the ways by which we can align columns to left in Pandas in Python:\n\nIn this example, the Pandas DataFrame is styled to left-align its columns using the method. The resulting styled DataFrame is then displayed using the function.\n\nIf we want the column headers aligned left, we use the set_table_styles() function. Here, both the column headers and the content of all the columns are left-aligned.\n\nIn this example, the DataFrame is converted to a string representation with left-aligned columns using the method. The resulting string is then printed, followed by a newline for separation.\n\nIn this example, each cell of the DataFrame is formatted to a fixed width of 15 characters with left alignment using the method and a lambda function. The resulting DataFrame is then displayed.\n\nIn this example, the attribute of the DataFrame is modified using the method with a lambda function. The lambda function applies a left-aligned text style to each cell in the specified columns. The resulting styled DataFrame is then displayed."
    },
    {
        "link": "https://pandas.pydata.org/docs/user_guide/style.html",
        "document": "This section demonstrates visualization of tabular data using the Styler class. For information on visualization with charting please see Chart Visualization. This document is written as a Jupyter Notebook, and can be viewed or downloaded here.\n\nStyling and output display customisation should be performed after the data in a DataFrame has been processed. The Styler is not dynamically updated if further changes to the DataFrame are made. The attribute is a property that returns a Styler object. It has a method defined on it so it is rendered automatically in Jupyter Notebook. The Styler, which can be used for large data but is primarily designed for small data, currently has the ability to output to these formats: The first three of these have display customisation methods designed to format and customise the output. These include:\n• None Formatting values, the index and columns headers, using .format() and .format_index(),\n• None Renaming the index or column header labels, using .relabel_index()\n• None Hiding certain columns, the index and/or column headers, or index names, using .hide()\n\nThe Styler distinguishes the display value from the actual value, in both data values and index or columns headers. To control the display value, the text is printed in each cell as a string, and we can use the .format() and .format_index() methods to manipulate this according to a format spec string or a callable that takes a single value and returns a string. It is possible to define this for the whole table, or index, or for individual columns, or MultiIndex levels. We can also overwrite index names. Additionally, the format function has a precision argument to specifically help format floats, as well as decimal and thousands separators to support other locales, an na_rep argument to display missing data, and an escape and hyperlinks arguments to help displaying safe-HTML or safe-LaTeX. The default formatter is configured to adopt pandas’ global options such as option, controllable using Using Styler to manipulate the display is a useful feature because maintaining the indexing and data values for other purposes gives greater control. You do not have to overwrite your DataFrame to display it how you like. Here is a more comprehensive example of using the formatting functions whilst still relying on the underlying data for indexing and calculations. The index and column headers can be completely hidden, as well subselecting rows or columns that one wishes to exclude. Both these options are performed using the same methods. The index can be hidden from rendering by calling .hide() without any arguments, which might be useful if your index is integer based. Similarly column headers can be hidden by calling .hide(axis=”columns”) without any further arguments. Specific rows or columns can be hidden from rendering by calling the same .hide() method and passing in a row/column label, a list-like or a slice of row/column labels to for the argument. Hiding does not change the integer arrangement of CSS classes, e.g. hiding the first two columns of a DataFrame means the column class indexing will still start at , since and are simply ignored. To invert the function to a show functionality it is best practice to compose a list of hidden items. Two or more Stylers can be concatenated together provided they share the same columns. This is very useful for showing summary statistics for a DataFrame, and is often used in combination with DataFrame.agg. Since the objects concatenated are Stylers they can independently be styled as will be shown below and their concatenation preserves those styles.\n\nThe Styler was originally constructed to support the wide array of HTML formatting options. Its HTML output creates an HTML and leverages CSS styling language to manipulate many parameters including colors, fonts, borders, background, etc. See here for more information on styling HTML tables. This allows a lot of flexibility out of the box, and even enables web developers to integrate DataFrames into their exiting user interface designs. Below we demonstrate the default output, which looks very similar to the standard DataFrame HTML representation. But the HTML here has already attached some CSS classes to each cell, even if we haven’t yet created any styles. We can view these by calling the .to_html() method, which returns the raw HTML as string, which is useful for further processing or adding to a file - read on in More about CSS and HTML. This section will also provide a walkthrough for how to convert this default output to represent a DataFrame output that is more communicative. For example how we can build : The first step we have taken is the create the Styler object from the DataFrame and then select the range of interest by hiding unwanted columns with .hide().\n\nTable styles are flexible enough to control all individual parts of the table, including column headers and indexes. However, they can be unwieldy to type for individual data cells or for any kind of conditional formatting, so we recommend that table styles are used for broad styling, such as entire rows or columns at a time. Table styles are also used to control features which can apply to the whole table at once such as creating a generic hover functionality. The pseudo-selector, as well as other pseudo-selectors, can only be used this way. To replicate the normal format of CSS selectors and properties (attribute value pairs), e.g. the necessary format to pass styles to .set_table_styles() is as a list of dicts, each with a CSS-selector tag and CSS-properties. Properties can either be a list of 2-tuples, or a regular CSS-string, for example: # for row hover use <tr> instead of <td> Next we just add a couple more styling artifacts targeting specific parts of the table. Be careful here, since we are chaining methods we need to explicitly instruct the method not to the existing styles. As a convenience method (since version 1.2.0) we can also pass a dict to .set_table_styles() which contains row or column keys. Behind the scenes Styler just indexes the keys and adds relevant or classes as necessary to the given CSS selectors.\n\nWe use the following methods to pass your style functions. Both of those methods take a function (and some other keyword arguments) and apply it to the DataFrame in a certain way, rendering CSS styles.\n• None .map() (elementwise): accepts a function that takes a single value and returns a string with the CSS attribute-value pair.\n• None .apply() (column-/row-/table-wise): accepts a function that takes a Series or DataFrame and returns a Series, DataFrame, or numpy array with an identical shape where each element is a string with a CSS attribute-value pair. This method passes each column or row of your DataFrame one-at-a-time or the entire table at once, depending on the keyword argument. For columnwise use , rowwise use , and for the entire table at once use . This method is powerful for applying multiple, complex logic to data cells. We create a new DataFrame to demonstrate this. For example we can build a function that colors text if it is negative, and chain this with a function that partially fades cells of negligible value. Since this looks at each element in turn we use . We can also build a function that highlights the maximum value across rows, cols, and the DataFrame all at once. In this case we use . Below we highlight the maximum in a column. We can use the same function across the different axes, highlighting here the DataFrame maximum in purple, and row maximums in pink. This last example shows how some styles have been overwritten by others. In general the most recent style applied is active but you can read more in the section on CSS hierarchies. You can also apply these styles to more granular parts of the DataFrame - read more in section on subset slicing. It is possible to replicate some of this functionality using just classes but it can be more cumbersome. See item 3) of Optimization Debugging Tip: If you’re having trouble writing your style function, try just passing it into . Internally, uses so the result should be the same, and with you will be able to inspect the CSS string output of your intended function in each cell. Acting on the Index and Column Headers# Similar application is achieved for headers by using:\n• None .map_index() (elementwise): accepts a function that takes a single value and returns a string with the CSS attribute-value pair.\n• None .apply_index() (level-wise): accepts a function that takes a Series and returns a Series, or numpy array with an identical shape where each element is a string with a CSS attribute-value pair. This method passes each level of your Index one-at-a-time. To style the index use and to style the column headers use . You can select a of a but currently no similar application is available for these methods.\n\nTable captions can be added with the .set_caption() method. You can use table styles to control the CSS relevant to the caption. Adding tooltips (since version 1.3.0) can be done using the .set_tooltips() method in the same way you can add CSS classes to data cells by providing a string based DataFrame with intersecting indices and columns. You don’t have to specify a name or any css for the tooltips, since there are standard defaults, but the option is there if you want more visual control. 'This model has a very strong true positive rate' \"This model's total number of false negatives is too high\" The only thing left to do for our table is to add the highlighting borders to draw the audience attention to the tooltips. We will create internal CSS classes as before using table styles. Setting classes always overwrites so we need to make sure we add the previous classes.\n\nThe examples we have shown so far for the and functions have not demonstrated the use of the argument. This is a useful argument which permits a lot of flexibility: it allows you to apply styles to specific rows or columns, without having to code that logic into your function. The value passed to behaves similar to slicing a DataFrame;\n• None A list (or Series or NumPy array) is treated as multiple column labels Consider using to construct the tuple for the last one. We will create a MultiIndexed DataFrame to demonstrate the functionality. We will use subset to highlight the maximum in the third and fourth columns with red text. We will highlight the subset sliced region in yellow. If combined with the as suggested then it can index across both dimensions with greater flexibility. This also provides the flexibility to sub select rows when used with the . There is also scope to provide conditional filtering. Suppose we want to highlight the maximum across columns 2 and 4 only in the case that the sum of columns 1 and 3 is less than -2.0 (essentially excluding rows ). Only label-based slicing is supported right now, not positional, and not callables. If your style function uses a or keyword argument, consider wrapping your function in a , partialing out that keyword.\n\nSome styling functions are common enough that we’ve “built them in” to the , so you don’t have to write them and apply them yourself. The current list of such functions is:\n• None .highlight_null: for use with identifying missing data.\n• None .highlight_min and .highlight_max: for use with identifying extremeties in data.\n• None .highlight_between and .highlight_quantile: for use with identifying classes within data.\n• None .background_gradient: a flexible method for highlighting cells based on their, or other, values on a numeric scale.\n• None .text_gradient: similar method for highlighting text based on their, or other, values on a numeric scale. The individual documentation on each function often gives more examples of their arguments. This method accepts ranges as float, or NumPy arrays or Series provided the indexes match. Useful for detecting the highest or lowest percentile values You can create “heatmaps” with the and methods. These require matplotlib, and we’ll use Seaborn to get a nice colormap. .background_gradient and .text_gradient have a number of keyword arguments to customise the gradients and colors. See the documentation. Use when the style doesn’t actually depend on the values. This is just a simple wrapper for where the function returns the same properties for all cells. You can include “bar charts” in your DataFrame. Additional keyword arguments give more control on centering and positioning, and you can pass a list of to highlight lower and higher values or a matplotlib colormap. To showcase an example here’s how you can change the above with the new option, combined with setting and limits, the of the figure, and underlying css of cells, leaving space to display the text and the bars. We also use to color the text the same as the bars using a matplotlib colormap (although in this case the visualization is probably better without this additional effect). The following example aims to give a highlight of the behavior of the new align options:\n\nMore About CSS and HTML# Cascading Style Sheet (CSS) language, which is designed to influence how a browser renders HTML elements, has its own peculiarities. It never reports errors: it just silently ignores them and doesn’t render your objects how you intend so can sometimes be frustrating. Here is a very brief primer on how creates HTML and interacts with CSS, with advice on common pitfalls to avoid. The precise structure of the CSS attached to each cell is as follows.\n• None Cells with Index and Column names include and where is its level in a MultiIndex\n• \n• None where is the level in a MultiIndex\n• None where is the numeric position of the row\n• \n• None where is the level in a MultiIndex\n• None where is the numeric position of the column\n• \n• None , where is the numeric position of the cell.\n• None , where is the numeric position of the cell. The structure of the is where is used only on headings, and headings will only have either or whichever is needed. By default we’ve also prepended each row/column identifier with a UUID unique to each DataFrame so that the style from one doesn’t collide with the styling from another within the same notebook or page. You can read more about the use of UUIDs in Optimization. We can see example of the HTML by calling the .to_html() method. The examples have shown that when CSS styles overlap, the one that comes last in the HTML render, takes precedence. So the following yield different results: This is only true for CSS rules that are equivalent in hierarchy, or importance. You can read more about CSS specificity here but for our purposes it suffices to summarize the key points: A CSS importance score for each HTML element is derived by starting at zero and adding:\n• None 10 for each attribute, class or pseudo-class\n• None 1 for each element name or pseudo-element Let’s use this to describe the action of the following configurations This text is red because the generated selector is worth 101 (ID plus element), whereas is only worth 100 (ID), so is considered inferior even though in the HTML it comes after the previous. In the above case the text is blue because the selector is worth 110 (ID plus class), which takes precedence. Now we have created another table style this time the selector (ID plus element plus class) gets bumped up to 111. If your style fails to be applied, and its really frustrating, try the trump card. Finally got that green text after all!\n\nThe core of pandas is, and will remain, its “high-performance, easy-to-use data structures”. With that in mind, we hope that accomplishes two goals\n• None Provide an API that is pleasing to use interactively and is “good enough” for many tasks\n• None Provide the foundations for dedicated libraries to build on If you build a great library on top of this, let us know and we’ll link to it. If the default template doesn’t quite suit your needs, you can subclass Styler and extend or override the template. We’ll show an example of extending the default template to insert a custom header before each table. We’ll use the following template: Now that we’ve created a template, we need to set up a subclass of that knows about it. Notice that we include the original loader in our environment’s loader. That’s because we extend the original template, so the Jinja environment needs to be able to find it. Now we can use that custom styler. It’s takes a DataFrame. Our custom template accepts a keyword. We can provide the value in the method. For convenience, we provide the method that does the same as the custom subclass. Here’s the template structure for the both the style generation template and the table generation template: See the template in the GitHub repo for more details."
    },
    {
        "link": "https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html",
        "document": ""
    },
    {
        "link": "https://medium.com/data-science/make-your-tables-look-glorious-2a5ddbfcc0e5",
        "document": "With 2023 delivering everything we all hope for and dream of, the new year also brings with it something else: year end reports and presentations. Whether we like it or not, visual impressions count. And while graphics are generally easier to understand and better convey a message than an array of numbers, we sometimes can’t get away from using a table of figures. But that doesn’t mean that the table can’t be pretty! Now, fair is fair — Jupyter notebooks do make a decent-looking table, but using just , we can do a fair bit of customisation to really make the table our own, and — more importantly — get our message across. In this article, we’ll see how to: Let’s get to it, imagining for a moment that we’re at the Widget Company, presenting sales data for two types of widget to an internal sales team. Aside: of course, you won’t only have to report results, projections and summaries in January, so the tips I’ll summarise here will hopefully be more perennial.\n\nWe’ll start with creating a dummy data set. Nothing fancy here — just a bit of simulation using and . import pandas as pd\n\nimport numpy as np\n\n\n\n# simulated data for widget A\n\ndf_a = pd.DataFrame(\n\n {\n\n 'Month':pd.date_range(\n\n start = '01-01-2012',\n\n end = '31-12-2022',\n\n freq = 'MS'\n\n ),\n\n 'Quotes':np.random.randint(\n\n low = 1_000_000,\n\n high = 2_500_000,\n\n size = 132\n\n ),\n\n 'Numbers':np.random.randint(\n\n low = 300_000,\n\n high = 500_000,\n\n size = 132\n\n ),\n\n 'Amounts':np.random.randint(\n\n low = 750_000,\n\n high = 1_250_000,\n\n size = 132\n\n )\n\n }\n\n)\n\n\n\ndf_a['Product'] = 'A'\n\n\n\n# simulated data for widget B\n\ndf_b = pd.DataFrame(\n\n {\n\n 'Month':pd.date_range(\n\n start = '01-01-2012',\n\n end = '31-12-2022',\n\n freq = 'MS'\n\n ),\n\n 'Quotes':np.random.randint(\n\n low = 100_000,\n\n high = 800_000,\n\n size = 132\n\n ),\n\n 'Numbers':np.random.randint(\n\n low = 10_000,\n\n high = 95_000,\n\n size = 132\n\n ),\n\n 'Amounts':np.random.randint(\n\n low = 450_000,\n\n high = 750_000,\n\n size = 132\n\n )\n\n }\n\n)\n\n\n\ndf_b['Product'] = 'B'\n\n\n\n# put it together & sort\n\ndf = pd.concat([df_a,df_b],axis = 0)\n\ndf.sort_values(by = 'Month',inplace = True)\n\ndf.reset_index(drop = True,inplace = True) So far, so simple. Let’s calculate a few “interesting” statistics — average sale amounts and product conversion: … which gives us the following (abbreviated) DataFrame: Here we have quite a typical summary table that we might want to present to stakeholders: numbers, currency amounts, and a few ratios all expressed across time. Let’s work our way through the data set, formatting elements as we go. For brevity’s sake, forthcoming images of the DataFrame will only show the first six rows of the data, but any code snippets apply to the DataFrame in its entirety.\n\nFirst up, the date column. There’s arguably nothing wrong with the formatting, but it could be better. For instance, since all of the monthly data is reflected as at the first of each month, there’s probably little sense in keeping the day element of each entry as it tells the reader very little. Eagle-eyed readers will note that I am not using the date format common in the US; I would of course recommend using formats which are generally acceptable in your locale. Let’s show only the year and the month number: A small change, but already much better! Now, we can improve readability even further by using the name of each month rather than the month number and we can do this without having to alter the underlying data. # use full name of month\n\ndf.style.format({'Month':'{:%B %Y}'}) Maybe a little too wordy now — let’s use abbreviations instead (e.g. “Jan” instead of “January”). Short and snappy. I’d like to take another stab at year and month number, aiming for something more readable than the but stopping short of using names (abbreviated or not). So let’s re-format the data, but rather than use a format, let’s switch to using the year and month number, separated by the letter “M”. Not too shabby, but I prefer the abbreviated name, so we’ll proceed with that. Aside: if you are interested in using the format I’ve used above, but don’t like the look of leading zeroes, the format string will remove that pesky zero.\n\nHighlighting certain elements in our data is a great way of getting a message across, or drawing the audience’s attention to a certain aspect of the data. We’ll start with highlighting rows if an element of the row meets a given condition — in this case, highlight all rows containing information relating to product A.\n• Define the function which returns a string if the given condition is met (that is, if the row relates to the specified product). The string contains a format command that we will pass through to the .\n• The resulting format command is fed through using the command. # function to conditionally highlight rows based on product\n\ndef highlight_product(s,product,colour = 'yellow'):\n\n r = pd.Series(data = False,index = s.index)\n\n r['Product'] = s.loc['Product'] == product\n\n \n\n return [f'background-color: {colour}' if r.any() else '' for v in r]\n\n\n\n# apply the formatting\n\ndf.style\\\n\n.apply(highlight_product,product = 'A',colour = '#DDEBF7', axis = 1)\\\n\n.format(\n\n {\n\n 'Month':'{:%b %Y}',\n\n 'Quotes':'{:,.0f}',\n\n 'Numbers':'{:,.0f}',\n\n 'Amounts':'£{:,.0f}',\n\n 'Average sale':'£{:,.2f}',\n\n 'Product conversion':'{:.2%}'\n\n }\n\n).hide_index() And so rows relating to product A highlighted. Easy peasy. As it so happens, this also makes the table more readable as it’s now easier to distinguish between the two product types. Pro tip: we can provide colour hex codes to , making bespoke formatting more accessible — this particular shade of blue is actually one of my favourite Microsoft Excel colours. Tailoring highlighting colours to match a company’s colour palette is a really neat touch. We can of course use different conditional tests. Here’s an example of applying a conditional threshold to : # function to highlight rows based on average sale\n\ndef highlight_average_sale(s,sale_threshold = 5):\n\n r = pd.Series(data = False,index = s.index)\n\n r['Product'] = s.loc['Average sale'] > sale_threshold\n\n \n\n return ['background-color: yellow' if r.any() else '' for v in r]\n\n\n\n# apply the formatting\n\ndf.iloc[:6,:].style\\\n\n.apply(highlight_average_sale,sale_threshold = 20, axis = 1)\\\n\n.format(\n\n {\n\n 'Month':'{:%b %Y}',\n\n 'Quotes':'{:,.0f}',\n\n 'Numbers':'{:,.0f}',\n\n 'Amounts':'£{:,.0f}',\n\n 'Average sale':'£{:,.2f}',\n\n 'Product conversion':'{:.2%}'\n\n }\n\n).hide_index() … and we see rows with very starkly highlighted in yellow. Instead of applying the highlighting to an entire row, we could limit format changes to a subset of the DataFrame. As an example, we’ll apply two threshold tests to , changing the font colour and weight if the condition is met. As usual, we need a to specify some formatting functions first: # functions to change font colour based on a threshold\n\ndef colour_threshold_lessthan(value,threshold,colour = 'red'):\n\n if value < threshold:\n\n return f'color: {colour}'\n\n else:\n\n return ''\n\n \n\ndef colour_threshold_morethan(value,threshold,colour = 'green'):\n\n if value > threshold:\n\n return f'color: {colour}'\n\n else:\n\n return ''\n\n\n\n# functions to change font weight based on a threshold \n\ndef weight_threshold_lessthan(value,threshold):\n\n if value < threshold:\n\n return f'font-weight: bold'\n\n else:\n\n return ''\n\n\n\ndef weight_threshold_morethan(value,threshold):\n\n if value > threshold:\n\n return f'font-weight: bold'\n\n else:\n\n return ''\n\n\n\n# apply the formatting\n\ndf.style\\\n\n.apply(highlight_product,product = 'A',colour = '#DDEBF7', axis = 1)\\\n\n.applymap(colour_threshold_lessthan,threshold = 0.05,subset = ['Product conversion'])\\\n\n.applymap(weight_threshold_lessthan,threshold = 0.05,subset = ['Product conversion'])\\\n\n.applymap(colour_threshold_morethan,threshold = 0.2,subset = ['Product conversion'])\\\n\n.applymap(weight_threshold_morethan,threshold = 0.2,subset = ['Product conversion'])\\\n\n.format(\n\n {\n\n 'Month':'{:%b %Y}',\n\n 'Quotes':'{:,.0f}',\n\n 'Numbers':'{:,.0f}',\n\n 'Amounts':'£{:,.0f}',\n\n 'Average sale':'£{:,.2f}',\n\n 'Product conversion':'{:.2%}'\n\n }\n\n)\\\n\n.hide_index() Notice how we use here rather than , and use the argument to restrict the formatting to a subset of the DataFrame. I think I’d make two changes here:\n• Code-wise, I’d use lambda functions rather than defining so many similar helper functions. That would make for much cleaner code.\n• I would hesitate to present a table where certain cells have different font formats, unless the formatting is applied to row or column totals.\n\nThis one has been a bit of an image-heavy article, but it’s been necessary to demonstrate how we can use to format dates, absolute numbers, currencies, and ratios. We’ve also used to export our fancy tables to image format. We’ve covered quite a bit of ground here, but this is by no means an exhaustive discussion. Using some more advanced functionality and a bit of HTML can deliver some awesome-looking tables; I unfortunately am a bit of an HTML-newbie, so have quite quickly reached the limit of my capabilities. I’d recommend checking out the official documentation³ to get a flavour of what’s actually possible; you’ll also find a better explanation of the and the difference between and there. Lastly, whilst I'm new to , I found it really simple to use and it does — indeed — do what it says on the tin. users may never need to use it, but it’s a great tool to have in the back pocket. Hopefully this article has set you up for a year of great-looking data tables. Let me know how you get your (tabular) points across— I’m always keen to hear of better ways to communicate ideas!"
    },
    {
        "link": "https://datacamp.com/tutorial/pandas-tutorial-dataframe-python",
        "document": "Learn to import data into Python from various sources, such as Excel, SQL, SAS and right from the web."
    },
    {
        "link": "https://pandas.pydata.org/docs/user_guide/10min.html",
        "document": "This is a short introduction to pandas, geared mainly for new users. You can see more complex recipes in the Cookbook.\n\nCustomarily, we import as follows:\n\nSee the Intro to data structures section. Creating a by passing a NumPy array with a datetime index using and labeled columns: Creating a by passing a dictionary of objects where the keys are the column labels and the values are the column values. The columns of the resulting have different dtypes: If you’re using IPython, tab completion for column names (as well as public attributes) is automatically enabled. Here’s a subset of the attributes that will be completed: As you can see, the columns , , , and are automatically tab completed. and are there as well; the rest of the attributes have been truncated for brevity.\n\nUse and to view the top and bottom rows of the frame respectively: Return a NumPy representation of the underlying data with without the index or column labels: NumPy arrays have one dtype for the entire array while pandas DataFrames have one dtype per column. When you call , pandas will find the NumPy dtype that can hold all of the dtypes in the DataFrame. If the common data type is , will require copying data.\n\nWhile standard Python / NumPy expressions for selecting and setting are intuitive and come in handy for interactive work, for production code, we recommend the optimized pandas data access methods, , , and . See the indexing documentation Indexing and Selecting Data and MultiIndex / Advanced Indexing. For a , passing a single label selects a columns and yields a equivalent to : See more in Selection by Label using or . For label slicing, both endpoints are included: For getting fast access to a scalar (equivalent to the prior method): See more in Selection by Position using or . Select via the position of the passed integers: For getting a value explicitly: For getting fast access to a scalar (equivalent to the prior method): Select rows where is greater than . Selecting values from a where a boolean condition is met: Setting a new column automatically aligns the data by the indexes: The result of the prior setting operations:\n\nFor NumPy data types, represents missing data. It is by default not included in computations. See the Missing Data section. Reindexing allows you to change/add/delete the index on a specified axis. This returns a copy of the data: drops any rows that have missing data: gets the boolean mask where values are :\n\nSee the Basic section on Binary Ops. Calculate the mean value for each column: Calculate the mean value for each row: Operating with another or with a different index or column will align the result with the union of the index or column labels. In addition, pandas automatically broadcasts along the specified dimension and will fill unaligned labels with . and applies a user defined function that reduces or broadcasts its result respectively. See more at Histogramming and Discretization. is equipped with a set of string processing methods in the attribute that make it easy to operate on each element of the array, as in the code snippet below. See more at Vectorized String Methods.\n\nBy “group by” we are referring to a process involving one or more of the following steps:\n• None Splitting the data into groups based on some criteria Grouping by a column label, selecting column labels, and then applying the function to the resulting groups:\n\nSee the sections on Hierarchical Indexing and Reshaping. The method “compresses” a level in the DataFrame’s columns: With a “stacked” DataFrame or Series (having a as the ), the inverse operation of is , which by default unstacks the last level: See the section on Pivot Tables. pivots a specifying the , and\n\npandas can include categorical data in a . For full docs, see the categorical introduction and the API documentation. Rename the categories to more meaningful names: Reorder the categories and simultaneously add the missing categories (methods under return a new by default): Sorting is per order in the categories, not lexical order: Grouping by a categorical column with also shows empty categories:\n\nIf you are attempting to perform a boolean operation on a or you might see an exception like: Traceback (most recent call last) in in : The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all(). See Comparisons and Gotchas for an explanation and what to do."
    }
]