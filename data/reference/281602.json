[
    {
        "link": "https://doc.qt.io/qt-6/signalsandslots.html",
        "document": "In GUI programming, when we change one widget, we often want another widget to be notified. More generally, we want objects of any kind to be able to communicate with one another. For example, if a user clicks a Close button, we probably want the window's close() function to be called.\n\nOther toolkits achieve this kind of communication using callbacks. A callback is a pointer to a function, so if you want a processing function to notify you about some event you pass a pointer to another function (the callback) to the processing function. The processing function then calls the callback when appropriate. While successful frameworks using this method do exist, callbacks can be unintuitive and may suffer from problems in ensuring the type-correctness of callback arguments.\n\nIn Qt, we have an alternative to the callback technique: We use signals and slots. A signal is emitted when a particular event occurs. Qt's widgets have many predefined signals, but we can always subclass widgets to add our own signals to them. A slot is a function that is called in response to a particular signal. Qt's widgets have many pre-defined slots, but it is common practice to subclass widgets and add your own slots so that you can handle the signals that you are interested in.\n\nThe signals and slots mechanism is type safe: The signature of a signal must match the signature of the receiving slot. (In fact a slot may have a shorter signature than the signal it receives because it can ignore extra arguments.) Since the signatures are compatible, the compiler can help us detect type mismatches when using the function pointer-based syntax. The string-based SIGNAL and SLOT syntax will detect type mismatches at runtime. Signals and slots are loosely coupled: A class which emits a signal neither knows nor cares which slots receive the signal. Qt's signals and slots mechanism ensures that if you connect a signal to a slot, the slot will be called with the signal's parameters at the right time. Signals and slots can take any number of arguments of any type. They are completely type safe.\n\nAll classes that inherit from QObject or one of its subclasses (e.g., QWidget) can contain signals and slots. Signals are emitted by objects when they change their state in a way that may be interesting to other objects. This is all the object does to communicate. It does not know or care whether anything is receiving the signals it emits. This is true information encapsulation, and ensures that the object can be used as a software component.\n\nSlots can be used for receiving signals, but they are also normal member functions. Just as an object does not know if anything receives its signals, a slot does not know if it has any signals connected to it. This ensures that truly independent components can be created with Qt.\n\nYou can connect as many signals as you want to a single slot, and a signal can be connected to as many slots as you need. It is even possible to connect a signal directly to another signal. (This will emit the second signal immediately whenever the first is emitted.)\n\nTogether, signals and slots make up a powerful component programming mechanism.\n\nSignals are emitted by an object when its internal state has changed in some way that might be interesting to the object's client or owner. Signals are public access functions and can be emitted from anywhere, but we recommend to only emit them from the class that defines the signal and its subclasses.\n\nWhen a signal is emitted, the slots connected to it are usually executed immediately, just like a normal function call. When this happens, the signals and slots mechanism is totally independent of any GUI event loop. Execution of the code following the statement will occur once all slots have returned. The situation is slightly different when using queued connections; in such a case, the code following the keyword will continue immediately, and the slots will be executed later.\n\nIf several slots are connected to one signal, the slots will be executed one after the other, in the order they have been connected, when the signal is emitted.\n\nSignals are automatically generated by the moc and must not be implemented in the file.\n\nA note about arguments: Our experience shows that signals and slots are more reusable if they do not use special types. If QScrollBar::valueChanged() were to use a special type such as the hypothetical QScrollBar::Range, it could only be connected to slots designed specifically for QScrollBar. Connecting different input widgets together would be impossible.\n\nA slot is called when a signal connected to it is emitted. Slots are normal C++ functions and can be called normally; their only special feature is that signals can be connected to them.\n\nSince slots are normal member functions, they follow the normal C++ rules when called directly. However, as slots, they can be invoked by any component, regardless of its access level, via a signal-slot connection. This means that a signal emitted from an instance of an arbitrary class can cause a private slot to be invoked in an instance of an unrelated class.\n\nYou can also define slots to be virtual, which we have found quite useful in practice.\n\nCompared to callbacks, signals and slots are slightly slower because of the increased flexibility they provide, although the difference for real applications is insignificant. In general, emitting a signal that is connected to some slots, is approximately ten times slower than calling the receivers directly, with non-virtual function calls. This is the overhead required to locate the connection object, to safely iterate over all connections (i.e. checking that subsequent receivers have not been destroyed during the emission), and to marshall any parameters in a generic fashion. While ten non-virtual function calls may sound like a lot, it's much less overhead than any or operation, for example. As soon as you perform a string, vector or list operation that behind the scene requires or , the signals and slots overhead is only responsible for a very small proportion of the complete function call costs. The same is true whenever you do a system call in a slot; or indirectly call more than ten functions. The simplicity and flexibility of the signals and slots mechanism is well worth the overhead, which your users won't even notice.\n\nNote that other libraries that define variables called or may cause compiler warnings and errors when compiled alongside a Qt-based application. To solve this problem, the offending preprocessor symbol.\n\nThe QObject-based version has the same internal state, and provides public methods to access the state, but in addition it has support for component programming using signals and slots. This class can tell the outside world that its state has changed by emitting a signal, , and it has a slot which other objects can send signals to.\n\nAll classes that contain signals or slots must mention Q_OBJECT at the top of their declaration. They must also derive (directly or indirectly) from QObject.\n\nSlots are implemented by the application programmer. Here is a possible implementation of the slot:\n\nThe line emits the signal from the object, with the new value as argument.\n\nIn the following code snippet, we create two objects and connect the first object's signal to the second object's slot using QObject::connect():\n\nCalling makes emit a signal, which will receive in its slot, i.e. is called. Then emits the same signal, but since no slot has been connected to 's signal, the signal is ignored.\n\nNote that the function sets the value and emits the signal only if . This prevents infinite looping in the case of cyclic connections (e.g., if were connected to ).\n\nBy default, for every connection you make, a signal is emitted; two signals are emitted for duplicate connections. You can break all of these connections with a single disconnect() call. If you pass the Qt::UniqueConnection type, the connection will only be made if it is not a duplicate. If there is already a duplicate (exact same signal to the exact same slot on the same objects), the connection will fail and connect will return .\n\nThis example illustrates that objects can work together without needing to know any information about each other. To enable this, the objects only need to be connected together, and this can be achieved with some simple QObject::connect() function calls, or with uic's automatic connections feature.\n\nThe following is an example of the header of a simple widget class without member functions. The purpose is to show how you can utilize signals and slots in your own applications.\n\ninherits QObject, which has most of the signal-slot knowledge, via QFrame and QWidget. It is somewhat similar to the built-in QLCDNumber widget.\n\nThe Q_OBJECT macro is expanded by the preprocessor to declare several member functions that are implemented by the ; if you get compiler errors along the lines of \"undefined reference to vtable for \", you have probably forgotten to run the moc or to include the moc output in the link command.\n\nAfter the class constructor and members, we declare the class . The class emits a signal, , when it is asked to show an impossible value.\n\nIf you don't care about overflow, or you know that overflow cannot occur, you can ignore the signal, i.e. don't connect it to any slot.\n\nIf on the other hand you want to call two different error functions when the number overflows, simply connect the signal to two different slots. Qt will call both (in the order they were connected).\n\nA slot is a receiving function used to get information about state changes in other widgets. uses it, as the code above indicates, to set the displayed number. Since is part of the class's interface with the rest of the program, the slot is public.\n\nSeveral of the example programs connect the valueChanged() signal of a QScrollBar to the slot, so the LCD number continuously shows the value of the scroll bar.\n\nNote that is overloaded; Qt will select the appropriate version when you connect a signal to the slot. With callbacks, you'd have to find five different names and keep track of the types yourself.\n\nThe signatures of signals and slots may contain arguments, and the arguments can have default values. Consider QObject::destroyed():\n\nWhen a QObject is deleted, it emits this QObject::destroyed() signal. We want to catch this signal, wherever we might have a dangling reference to the deleted QObject, so we can clean it up. A suitable slot signature might be:\n\nTo connect the signal to the slot, we use QObject::connect(). There are several ways to connect signal and slots. The first is to use function pointers:\n\nThere are several advantages to using QObject::connect() with function pointers. First, it allows the compiler to check that the signal's arguments are compatible with the slot's arguments. Arguments can also be implicitly converted by the compiler, if needed.\n\nYou can also connect to functors or C++11 lambdas:\n\nIn both these cases, we provide this as context in the call to connect(). The context object provides information about in which thread the receiver should be executed. This is important, as providing the context ensures that the receiver is executed in the context thread.\n\nThe lambda will be disconnected when the sender or context is destroyed. You should take care that any objects used inside the functor are still alive when the signal is emitted.\n\nThe other way to connect a signal to a slot is to use QObject::connect() and the and macros. The rule about whether to include arguments or not in the and macros, if the arguments have default values, is that the signature passed to the macro must not have fewer arguments than the signature passed to the macro.\n\nAll of these would work:\n\nBut this one won't work:\n\n...because the slot will be expecting a QObject that the signal will not send. This connection will report a runtime error.\n\nNote that signal and slot arguments are not checked by the compiler when using this QObject::connect() overload.\n\nFor cases where you may require information on the sender of the signal, Qt provides the QObject::sender() function, which returns a pointer to the object that sent the signal.\n\nLambda expressions are a convenient way to pass custom arguments to a slot:\n\nUsing Qt with 3rd Party Signals and Slots\n\nIt is possible to use Qt with a 3rd party signal/slot mechanism. You can even use both mechanisms in the same project. To do that, write the following into your CMake project file:\n\nIn a qmake project (.pro) file, you need to write:\n\nIt tells Qt not to define the moc keywords , , and , because these names will be used by a 3rd party library, e.g. Boost. Then to continue using Qt signals and slots with the flag, simply replace all uses of the Qt moc keywords in your sources with the corresponding Qt macros Q_SIGNALS (or Q_SIGNAL), Q_SLOTS (or Q_SLOT), and Q_EMIT.\n\nThe public API of Qt-based libraries should use the keywords and instead of and . Otherwise it is hard to use such a library in a project that defines .\n\nTo enforce this restriction, the library creator may set the preprocessor define when building the library.\n\nThis define excludes signals and slots without affecting whether other Qt-specific keywords can be used in the library implementation."
    },
    {
        "link": "https://felgo.com/doc/qt/signalsandslots",
        "document": "Signals and slots are used for communication between objects. The signals and slots mechanism is a central feature of Qt and probably the part that differs most from the features provided by other frameworks. Signals and slots are made possible by Qt's meta-object system.\n\nIn GUI programming, when we change one widget, we often want another widget to be notified. More generally, we want objects of any kind to be able to communicate with one another. For example, if a user clicks a Close button, we probably want the window's close() function to be called.\n\nOther toolkits achieve this kind of communication using callbacks. A callback is a pointer to a function, so if you want a processing function to notify you about some event you pass a pointer to another function (the callback) to the processing function. The processing function then calls the callback when appropriate. While successful frameworks using this method do exist, callbacks can be unintuitive and may suffer from problems in ensuring the type-correctness of callback arguments.\n\nIn Qt, we have an alternative to the callback technique: We use signals and slots. A signal is emitted when a particular event occurs. Qt's widgets have many predefined signals, but we can always subclass widgets to add our own signals to them. A slot is a function that is called in response to a particular signal. Qt's widgets have many pre-defined slots, but it is common practice to subclass widgets and add your own slots so that you can handle the signals that you are interested in.\n\nThe signals and slots mechanism is type safe: The signature of a signal must match the signature of the receiving slot. (In fact a slot may have a shorter signature than the signal it receives because it can ignore extra arguments.) Since the signatures are compatible, the compiler can help us detect type mismatches when using the function pointer-based syntax. The string-based SIGNAL and SLOT syntax will detect type mismatches at runtime. Signals and slots are loosely coupled: A class which emits a signal neither knows nor cares which slots receive the signal. Qt's signals and slots mechanism ensures that if you connect a signal to a slot, the slot will be called with the signal's parameters at the right time. Signals and slots can take any number of arguments of any type. They are completely type safe.\n\nAll classes that inherit from QObject or one of its subclasses (e.g., QWidget) can contain signals and slots. Signals are emitted by objects when they change their state in a way that may be interesting to other objects. This is all the object does to communicate. It does not know or care whether anything is receiving the signals it emits. This is true information encapsulation, and ensures that the object can be used as a software component.\n\nSlots can be used for receiving signals, but they are also normal member functions. Just as an object does not know if anything receives its signals, a slot does not know if it has any signals connected to it. This ensures that truly independent components can be created with Qt.\n\nYou can connect as many signals as you want to a single slot, and a signal can be connected to as many slots as you need. It is even possible to connect a signal directly to another signal. (This will emit the second signal immediately whenever the first is emitted.)\n\nTogether, signals and slots make up a powerful component programming mechanism.\n\nSignals are emitted by an object when its internal state has changed in some way that might be interesting to the object's client or owner. Signals are public access functions and can be emitted from anywhere, but we recommend to only emit them from the class that defines the signal and its subclasses.\n\nWhen a signal is emitted, the slots connected to it are usually executed immediately, just like a normal function call. When this happens, the signals and slots mechanism is totally independent of any GUI event loop. Execution of the code following the statement will occur once all slots have returned. The situation is slightly different when using queued connections; in such a case, the code following the keyword will continue immediately, and the slots will be executed later.\n\nIf several slots are connected to one signal, the slots will be executed one after the other, in the order they have been connected, when the signal is emitted.\n\nSignals are automatically generated by the moc and must not be implemented in the file. They can never have return types (i.e. use ).\n\nA note about arguments: Our experience shows that signals and slots are more reusable if they do not use special types. If QScrollBar::valueChanged() were to use a special type such as the hypothetical QScrollBar::Range, it could only be connected to slots designed specifically for QScrollBar. Connecting different input widgets together would be impossible.\n\nA slot is called when a signal connected to it is emitted. Slots are normal C++ functions and can be called normally; their only special feature is that signals can be connected to them.\n\nSince slots are normal member functions, they follow the normal C++ rules when called directly. However, as slots, they can be invoked by any component, regardless of its access level, via a signal-slot connection. This means that a signal emitted from an instance of an arbitrary class can cause a private slot to be invoked in an instance of an unrelated class.\n\nYou can also define slots to be virtual, which we have found quite useful in practice.\n\nCompared to callbacks, signals and slots are slightly slower because of the increased flexibility they provide, although the difference for real applications is insignificant. In general, emitting a signal that is connected to some slots, is approximately ten times slower than calling the receivers directly, with non-virtual function calls. This is the overhead required to locate the connection object, to safely iterate over all connections (i.e. checking that subsequent receivers have not been destroyed during the emission), and to marshall any parameters in a generic fashion. While ten non-virtual function calls may sound like a lot, it's much less overhead than any or operation, for example. As soon as you perform a string, vector or list operation that behind the scene requires or , the signals and slots overhead is only responsible for a very small proportion of the complete function call costs. The same is true whenever you do a system call in a slot; or indirectly call more than ten functions. The simplicity and flexibility of the signals and slots mechanism is well worth the overhead, which your users won't even notice.\n\nNote that other libraries that define variables called or may cause compiler warnings and errors when compiled alongside a Qt-based application. To solve this problem, the offending preprocessor symbol.\n\nThe QObject-based version has the same internal state, and provides public methods to access the state, but in addition it has support for component programming using signals and slots. This class can tell the outside world that its state has changed by emitting a signal, , and it has a slot which other objects can send signals to.\n\nAll classes that contain signals or slots must mention Q_OBJECT at the top of their declaration. They must also derive (directly or indirectly) from QObject.\n\nSlots are implemented by the application programmer. Here is a possible implementation of the slot:\n\nThe line emits the signal from the object, with the new value as argument.\n\nIn the following code snippet, we create two objects and connect the first object's signal to the second object's slot using QObject::connect():\n\nCalling makes emit a signal, which will receive in its slot, i.e. is called. Then emits the same signal, but since no slot has been connected to 's signal, the signal is ignored.\n\nNote that the function sets the value and emits the signal only if . This prevents infinite looping in the case of cyclic connections (e.g., if were connected to ).\n\nBy default, for every connection you make, a signal is emitted; two signals are emitted for duplicate connections. You can break all of these connections with a single disconnect() call. If you pass the Qt::UniqueConnection type, the connection will only be made if it is not a duplicate. If there is already a duplicate (exact same signal to the exact same slot on the same objects), the connection will fail and connect will return .\n\nThis example illustrates that objects can work together without needing to know any information about each other. To enable this, the objects only need to be connected together, and this can be achieved with some simple QObject::connect() function calls, or with uic's automatic connections feature.\n\nThe following is an example of the header of a simple widget class without member functions. The purpose is to show how you can utilize signals and slots in your own applications.\n\ninherits QObject, which has most of the signal-slot knowledge, via QFrame and QWidget. It is somewhat similar to the built-in QLCDNumber widget.\n\nThe Q_OBJECT macro is expanded by the preprocessor to declare several member functions that are implemented by the ; if you get compiler errors along the lines of \"undefined reference to vtable for \", you have probably forgotten to run the moc or to include the moc output in the link command.\n\nAfter the class constructor and members, we declare the class . The class emits a signal, , when it is asked to show an impossible value.\n\nIf you don't care about overflow, or you know that overflow cannot occur, you can ignore the signal, i.e. don't connect it to any slot.\n\nIf on the other hand you want to call two different error functions when the number overflows, simply connect the signal to two different slots. Qt will call both (in the order they were connected).\n\nA slot is a receiving function used to get information about state changes in other widgets. uses it, as the code above indicates, to set the displayed number. Since is part of the class's interface with the rest of the program, the slot is public.\n\nSeveral of the example programs connect the valueChanged() signal of a QScrollBar to the slot, so the LCD number continuously shows the value of the scroll bar.\n\nNote that is overloaded; Qt will select the appropriate version when you connect a signal to the slot. With callbacks, you'd have to find five different names and keep track of the types yourself.\n\nThe signatures of signals and slots may contain arguments, and the arguments can have default values. Consider QObject::destroyed():\n\nWhen a QObject is deleted, it emits this QObject::destroyed() signal. We want to catch this signal, wherever we might have a dangling reference to the deleted QObject, so we can clean it up. A suitable slot signature might be:\n\nTo connect the signal to the slot, we use QObject::connect(). There are several ways to connect signal and slots. The first is to use function pointers:\n\nThere are several advantages to using QObject::connect() with function pointers. First, it allows the compiler to check that the signal's arguments are compatible with the slot's arguments. Arguments can also be implicitly converted by the compiler, if needed.\n\nYou can also connect to functors or C++11 lambdas:\n\nIn both these cases, we provide this as context in the call to connect(). The context object provides information about in which thread the receiver should be executed. This is important, as providing the context ensures that the receiver is executed in the context thread.\n\nThe lambda will be disconnected when the sender or context is destroyed. You should take care that any objects used inside the functor are still alive when the signal is emitted.\n\nThe other way to connect a signal to a slot is to use QObject::connect() and the and macros. The rule about whether to include arguments or not in the and macros, if the arguments have default values, is that the signature passed to the macro must not have fewer arguments than the signature passed to the macro.\n\nAll of these would work:\n\nBut this one won't work:\n\n...because the slot will be expecting a QObject that the signal will not send. This connection will report a runtime error.\n\nNote that signal and slot arguments are not checked by the compiler when using this QObject::connect() overload.\n\nFor cases where you may require information on the sender of the signal, Qt provides the QObject::sender() function, which returns a pointer to the object that sent the signal.\n\nLambda expressions are a convenient way to pass custom arguments to a slot:\n\nUsing Qt with 3rd Party Signals and Slots\n\nIt is possible to use Qt with a 3rd party signal/slot mechanism. You can even use both mechanisms in the same project. To do that, write the following into your CMake project file:\n\nIn a qmake project (.pro) file, you need to write:\n\nIt tells Qt not to define the moc keywords , , and , because these names will be used by a 3rd party library, e.g. Boost. Then to continue using Qt signals and slots with the flag, simply replace all uses of the Qt moc keywords in your sources with the corresponding Qt macros Q_SIGNALS (or Q_SIGNAL), Q_SLOTS (or Q_SLOT), and Q_EMIT.\n\nThe public API of Qt-based libraries should use the keywords and instead of and . Otherwise it is hard to use such a library in a project that defines .\n\nTo enforce this restriction, the library creator may set the preprocessor define when building the library.\n\nThis define excludes signals and slots without affecting whether other Qt-specific keywords can be used in the library implementation."
    },
    {
        "link": "https://forum.qt.io/topic/1485/plugins-and-signal-slot-mechanism",
        "document": "\n• I'm currently developing an application with plugins. These plugins should extend the functionality of the MainWinow, such as adding some Buttons in the ToolBar and so on.\n\n I'd like to connect the Signals/Slots of the plugins to the MainWindow an also among each other. Plugin gets loaded by QPluginLoader and its signal gets connected with:\n\n @\n\n connect(toolbar_plugin->getObject(), SIGNAL(buttonClicked()),\n\n mainWindow, SLOT(close()));\n\n @ This works, but doesn't seem to be the best solution.\n\n I'd like to have signals and slots in my interface, but inheriting QObject in the interface and in the implementation of the interface doesn't work, moc is complaining.\n\n How can this be achieved, unfortunately this seems to be an infrequent task, haven't found examples.\n• I can't see why that's not a good solution? If you provide us with your implementation for getToolbar() and getObject() we probably can help further. Do both functions return the same object? Also: It is definitely NOT possible to declare signals and slots in an interface, as the inheritance from QObjet is forbidden there. If you declare your interfaces with the proper macros you can use qobject_cast and test if a plugin implements a certain interface. See the Docs on \"qobject_cast\":http://doc.qt.nokia.com/4.7/qobject.html#qobject_cast and the \"Plug & Paint Example\":http://doc.qt.nokia.com/4.7/tools-plugandpaint.html for this.\n• [quote author=\"Volker\" date=\"1288282846\"]\n\n If you provide us with your implementation for getToolbar() and getObject() we probably can help further. Do both functions return the same object?\n\n [/quote]\n\n No, one returns a member, the other the whole class.\n\n @\n\n QWidget* plugin_Toolbar::getToolbar()\n\n {\n\n return(m_toolbar);\n\n } [quote author=\"Volker\" date=\"1288282846\"]\n\n Also: It is definitely NOT possible to declare signals and slots in an interface, as the inheritance from QObjet is forbidden there.\n\n [/quote]\n\n Allright, I've tried to do this for quite a while, because I thought of having the signals/slots in the interface would be a nice thing. Knowing this prevents me from further failure.\n\n W/o, the interface isn't fat, so good thing. [quote author=\"Franzk\" date=\"1288329878\"]Besides that, the plugin will always be seen as or even has to be a QObject, so you can connect to those signals anyway. The only downside is that the signal and slot names aren't clear from the interface...[/quote]\n\n Okay, I can live with that.\n• You can shorten your connect a bit: Calling getObject() on plugin_Toolbar is redundant, as both pointers are identical. Unfortunately it's not reliable in the client code, that uses the plugin, because the connected signal is not guaranteed to exist in the plugin. You will notice this only at runtime (watch console output for QObjects warnings about failed connections). Alternatively you can use \"QMetaObject\":http://doc.qt.nokia.com/4.7/qmetaobject.html to look if the object has the wanted signal. You can get around this limitation like this: Create an abstract base class (like MyAbstractToolbarPlugin), that inherits from OQbject (and probably from non-QObject IBasePlugin), and declare the signal there. In your concrete plugin, inherit from MyAbstractToolbarPlugin, then you definitely do have the signal. Of course, this solution has another, different downside: You can only implement QObject base class per plugin."
    },
    {
        "link": "https://ftp.nmr.mgh.harvard.edu/pub/dist/freesurfer/tutorial_packages/centos6/freesurfer-fsl-matlab-Linux-centos6_x86_64-dev/freesurfer/lib/qt/qt_doc/html/signalsandslots.html",
        "document": "Signals and slots are used for communication between objects. The signals and slots mechanism is a central feature of Qt and probably the part that differs most from the features provided by other frameworks.\n\nIn GUI programming, when we change one widget, we often want another widget to be notified. More generally, we want objects of any kind to be able to communicate with one another. For example, if a user clicks a Close button, we probably want the window's close() function to be called.\n\nOlder toolkits achieve this kind of communication using callbacks. A callback is a pointer to a function, so if you want a processing function to notify you about some event you pass a pointer to another function (the callback) to the processing function. The processing function then calls the callback when appropriate. Callbacks have two fundamental flaws: Firstly, they are not type-safe. We can never be certain that the processing function will call the callback with the correct arguments. Secondly, the callback is strongly coupled to the processing function since the processing function must know which callback to call.\n\nIn Qt, we have an alternative to the callback technique: We use signals and slots. A signal is emitted when a particular event occurs. Qt's widgets have many predefined signals, but we can always subclass widgets to add our own signals to them. A slot is a function that is called in response to a particular signal. Qt's widgets have many pre-defined slots, but it is common practice to subclass widgets and add your own slots so that you can handle the signals that you are interested in.\n\nThe signals and slots mechanism is type safe: The signature of a signal must match the signature of the receiving slot. (In fact a slot may have a shorter signature than the signal it receives because it can ignore extra arguments.) Since the signatures are compatible, the compiler can help us detect type mismatches. Signals and slots are loosely coupled: A class which emits a signal neither knows nor cares which slots receive the signal. Qt's signals and slots mechanism ensures that if you connect a signal to a slot, the slot will be called with the signal's parameters at the right time. Signals and slots can take any number of arguments of any type. They are completely type safe.\n\nAll classes that inherit from QObject or one of its subclasses (e.g., QWidget) can contain signals and slots. Signals are emitted by objects when they change their state in a way that may be interesting to other objects. This is all the object does to communicate. It does not know or care whether anything is receiving the signals it emits. This is true information encapsulation, and ensures that the object can be used as a software component.\n\nSlots can be used for receiving signals, but they are also normal member functions. Just as an object does not know if anything receives its signals, a slot does not know if it has any signals connected to it. This ensures that truly independent components can be created with Qt.\n\nYou can connect as many signals as you want to a single slot, and a signal can be connected to as many slots as you need. It is even possible to connect a signal directly to another signal. (This will emit the second signal immediately whenever the first is emitted.)\n\nTogether, signals and slots make up a powerful component programming mechanism.\n\nThe QObject-based version has the same internal state, and provides public methods to access the state, but in addition it has support for component programming using signals and slots. This class can tell the outside world that its state has changed by emitting a signal, , and it has a slot which other objects can send signals to.\n\nAll classes that contain signals or slots must mention Q_OBJECT at the top of their declaration. They must also derive (directly or indirectly) from QObject.\n\nSlots are implemented by the application programmer. Here is a possible implementation of the slot:\n\nThe line emits the signal from the object, with the new value as argument.\n\nIn the following code snippet, we create two objects and connect the first object's signal to the second object's slot using QObject::connect():\n\nCalling makes emit a signal, which will receive in its slot, i.e. is called. Then emits the same signal, but since no slot has been connected to 's signal, the signal is ignored.\n\nNote that the function sets the value and emits the signal only if . This prevents infinite looping in the case of cyclic connections (e.g., if were connected to ).\n\nBy default, for every connection you make, a signal is emitted; two signals are emitted for duplicate connections. You can break all of these connections with a single disconnect() call. If you pass the Qt::UniqueConnection type, the connection will only be made if it is not a duplicate. If there is already a duplicate (exact same signal to the exact same slot on the same objects), the connection will fail and connect will return false\n\nThis example illustrates that objects can work together without needing to know any information about each other. To enable this, the objects only need to be connected together, and this can be achieved with some simple QObject::connect() function calls, or with 's automatic connections feature.\n\nThe C++ preprocessor changes or removes the , , and keywords so that the compiler is presented with standard C++.\n\nBy running the moc on class definitions that contain signals or slots, a C++ source file is produced which should be compiled and linked with the other object files for the application. If you use qmake, the makefile rules to automatically invoke will be added to your project's makefile.\n\nSignals are emitted by an object when its internal state has changed in some way that might be interesting to the object's client or owner. Only the class that defines a signal and its subclasses can emit the signal.\n\nWhen a signal is emitted, the slots connected to it are usually executed immediately, just like a normal function call. When this happens, the signals and slots mechanism is totally independent of any GUI event loop. Execution of the code following the statement will occur once all slots have returned. The situation is slightly different when using queued connections; in such a case, the code following the keyword will continue immediately, and the slots will be executed later.\n\nIf several slots are connected to one signal, the slots will be executed one after the other, in the order they have been connected, when the signal is emitted.\n\nSignals are automatically generated by the moc and must not be implemented in the file. They can never have return types (i.e. use ).\n\nA note about arguments: Our experience shows that signals and slots are more reusable if they do not use special types. If QScrollBar::valueChanged() were to use a special type such as the hypothetical QScrollBar::Range, it could only be connected to slots designed specifically for QScrollBar. Connecting different input widgets together would be impossible.\n\nA slot is called when a signal connected to it is emitted. Slots are normal C++ functions and can be called normally; their only special feature is that signals can be connected to them.\n\nSince slots are normal member functions, they follow the normal C++ rules when called directly. However, as slots, they can be invoked by any component, regardless of its access level, via a signal-slot connection. This means that a signal emitted from an instance of an arbitrary class can cause a private slot to be invoked in an instance of an unrelated class.\n\nYou can also define slots to be virtual, which we have found quite useful in practice.\n\nCompared to callbacks, signals and slots are slightly slower because of the increased flexibility they provide, although the difference for real applications is insignificant. In general, emitting a signal that is connected to some slots, is approximately ten times slower than calling the receivers directly, with non-virtual function calls. This is the overhead required to locate the connection object, to safely iterate over all connections (i.e. checking that subsequent receivers have not been destroyed during the emission), and to marshall any parameters in a generic fashion. While ten non-virtual function calls may sound like a lot, it's much less overhead than any or operation, for example. As soon as you perform a string, vector or list operation that behind the scene requires or , the signals and slots overhead is only responsible for a very small proportion of the complete function call costs.\n\nThe same is true whenever you do a system call in a slot; or indirectly call more than ten functions. On an i586-500, you can emit around 2,000,000 signals per second connected to one receiver, or around 1,200,000 per second connected to two receivers. The simplicity and flexibility of the signals and slots mechanism is well worth the overhead, which your users won't even notice.\n\nNote that other libraries that define variables called or may cause compiler warnings and errors when compiled alongside a Qt-based application. To solve this problem, the offending preprocessor symbol.\n\nThe meta-object compiler (moc) parses the class declaration in a C++ file and generates C++ code that initializes the meta-object. The meta-object contains the names of all the signal and slot members, as well as pointers to these functions.\n\nThe meta-object contains additional information such as the object's class name. You can also check if an object inherits a specific class, for example:\n\nThe meta-object information is also used by qobject_cast<T>(), which is similar to QObject::inherits() but is less error-prone:\n\nSee Meta-Object System for more information.\n\nHere is a simple commented example of a widget.\n\ninherits QObject, which has most of the signal-slot knowledge, via QFrame and QWidget. It is somewhat similar to the built-in QLCDNumber widget.\n\nThe Q_OBJECT macro is expanded by the preprocessor to declare several member functions that are implemented by the ; if you get compiler errors along the lines of \"undefined reference to vtable for \", you have probably forgotten to run the moc or to include the moc output in the link command.\n\nIt's not obviously relevant to the moc, but if you inherit QWidget you almost certainly want to have the argument in your constructor and pass it to the base class's constructor.\n\nSome destructors and member functions are omitted here; the ignores member functions.\n\nemits a signal when it is asked to show an impossible value.\n\nIf you don't care about overflow, or you know that overflow cannot occur, you can ignore the signal, i.e. don't connect it to any slot.\n\nIf on the other hand you want to call two different error functions when the number overflows, simply connect the signal to two different slots. Qt will call both (in the order they were connected).\n\nA slot is a receiving function used to get information about state changes in other widgets. uses it, as the code above indicates, to set the displayed number. Since is part of the class's interface with the rest of the program, the slot is public.\n\nSeveral of the example programs connect the valueChanged() signal of a QScrollBar to the slot, so the LCD number continuously shows the value of the scroll bar.\n\nNote that is overloaded; Qt will select the appropriate version when you connect a signal to the slot. With callbacks, you'd have to find five different names and keep track of the types yourself.\n\nSome irrelevant member functions have been omitted from this example.\n\nThe signatures of signals and slots may contain arguments, and the arguments can have default values. Consider QObject::destroyed():\n\nWhen a QObject is deleted, it emits this QObject::destroyed() signal. We want to catch this signal, wherever we might have a dangling reference to the deleted QObject, so we can clean it up. A suitable slot signature might be:\n\nTo connect the signal to the slot, we use QObject::connect() and the and macros. The rule about whether to include arguments or not in the and macros, if the arguments have default values, is that the signature passed to the macro must not have fewer arguments than the signature passed to the macro.\n\nAll of these would work:\n\nBut this one won't work:\n\n...because the slot will be expecting a QObject that the signal will not send. This connection will report a runtime error.\n\nFor cases where you may require information on the sender of the signal, Qt provides the QObject::sender() function, which returns a pointer to the object that sent the signal.\n\nThe QSignalMapper class is provided for situations where many signals are connected to the same slot and the slot needs to handle each signal differently.\n\nSuppose you have three push buttons that determine which file you will open: \"Tax File\", \"Accounts File\", or \"Report File\".\n\nIn order to open the correct file, you use QSignalMapper::setMapping() to map all the clicked() signals to a QSignalMapper object. Then you connect the file's QPushButton::clicked() signal to the QSignalMapper::map() slot.\n\nThen, you connect the mapped() signal to where a different file will be opened, depending on which push button is pressed.\n\nNote: The following code will compile and run, but due to signature normalization, the code will be slower.\n\nUsing Qt with 3rd Party Signals and Slots\n\nIt is possible to use Qt with a 3rd party signal/slot mechanism. You can even use both mechanisms in the same project. Just add the following line to your qmake project (.pro) file.\n\nIt tells Qt not to define the moc keywords , , and , because these names will be used by a 3rd party library, e.g. Boost. Then to continue using Qt signals and slots with the flag, simply replace all uses of the Qt moc keywords in your sources with the corresponding Qt macros Q_SIGNALS (or Q_SIGNAL), Q_SLOTS (or Q_SLOT), and Q_EMIT."
    },
    {
        "link": "https://stackoverflow.com/questions/3794649/qt-events-and-signal-slots",
        "document": "Does one replace the other? Are events an abstraction of signal/slots?\n\nIn the Qt world, what is the difference of events and signal/slots?\n\nIn Qt, signals and events are both implementations of the Observer pattern. They are used in different situations because they have different strengths and weaknesses. First of all let's define what we mean by 'Qt event' exactly: a virtual function in a Qt class, which you're expected to reimplement in a base class of yours if you want to handle the event. It's related to the Template Method pattern. Note how I used the word \"handle\". Indeed, here's a basic difference between the intent of signals and events:\n• You \"get notified of\" signal emissions The difference is that when you \"handle\" the event, you take on the responsibility to \"respond\" with a behavior that is useful outside the class. For example, consider an app that has a button with a number on it. The app needs to let the user focus the button and change the number by pressing the \"up\" and \"down\" keyboard keys. Otherwise the button should function like a normal (it can be clicked, etc). In Qt this is done by creating your own little reusable \"component\" (subclass of ), which reimplements . Pseudocode: class NumericButton extends QPushButton private void addToNumber(int value): // ... reimplement base.keyPressEvent(QKeyEvent event): if(event.key == up) this.addToNumber(1) else if(event.key == down) this.addToNumber(-1) else base.keyPressEvent(event) See? This code presents a new abstraction: a widget that acts like a button, but with some extra functionality. We added this functionality very conveniently:\n• Since we reimplemented a virtual, our implementation automatically became encapsulated in our class. If Qt's designers had made a signal, we would need to decide whether to inherit or just externally connect to the signal. But that would be stupid, since in Qt you're always expected to inherit when writing a widget with a custom behavior (for good reason - reusability/modularity). So by making an event, they convey their intent that is just a basic building block of functionality. If it were a signal, it'd look like a user-facing thing, when it's not intended to be.\n• Since the base-class-implementation of the function is available, we easily implement the Chain-of-responsibility pattern by handling our special cases (up&down keys) and leaving the rest to the base class. You can see this would be nearly impossible if were a signal. The design of Qt is well thought out - they made us fall into the pit of success by making it easy to do the right thing and hard to do the wrong thing (by making keyPressEvent an event). On the other hand, consider the simplest usage of - just instantiating it and getting notified when it's clicked: This is clearly meant to be done by the user of the class:\n• if we had to subclass every time we want some button to notify us of a click, that would require a lot of subclasses for no good reason! A widget that always shows a \"Hello world\" when clicked is useful only in a single case - so it's totally not reusable. Again, we have no choice but to do the right thing - by connecting to it externally.\n• we may want to connect several slots to - or connect several signals to . With signals there is no fuss. With subclassing you would have to sit down and ponder some class diagrams until you decide on an appropriate design. Note that one of the places emits is in its implementation. That doesn't mean and are interchangable - just that they're related. So signals and events have different purposes (but are related in that both let you \"subscribe\" to a notification of something happening).\n\nI don’t like the answers so far. – Let me concentrate on this part of the question: Are events an abstraction of signal/slots? Short answer: no. The long answer raises a “better” question: How are signals and events related? An idle main loop (Qt’s for example) is usually “stuck” in a select() call of the operating system. That call makes the application “sleep”, while it passes a bunch of sockets or files or whatever to the kernel asking for: if something changes on these, let the select() call return. – And the kernel, as the master of the world, knows when that happens. The result of that select() call could be: new data on the socket connect to X11, a packet to a UDP port we listen on came in, etc. – That stuff is neither a Qt signal, nor a Qt event, and the Qt main loop decides itself if it turns the fresh data into the one, the other or ignores it. Qt could call a method (or several) like keyPressEvent(), effectively turning it into a Qt event. Or Qt emits a signal, which in effect looks up all functions registered for that signal, and calls them one after the other. One difference of those two concepts is visible here: a slot has no vote on whether other slots registered to that signal will get called or not. – Events are more like a chain, and the event handler decides if it interrupts that chain or not. Signals look like a star or tree in this respect. An event can trigger or be entirely turned into a signal (just emit one, and don’t call “super()”). A signal can be turned into an event (call an event handler). What abstracts what depends on the case: the clicked()-signal abstracts mouse events (a button goes down and up again without too much moving around). Keyboard events are abstractions from lower levels (things like 果 or é are several key strokes on my system). Maybe the focusInEvent() is an example of the opposite: it could use (and thus abstract) the clicked() signal, but I don’t know if it actually does.\n\nThe Qt documentation probably explains it best: In Qt, events are objects, derived from the abstract class, that represent things that have happened either within an application or as a result of outside activity that the application needs to know about. Events can be received and handled by any instance of a subclass, but they are especially relevant to widgets. This document describes how events are delivered and handled in a typical application. So events and signal/slots are two parallel mechanisms accomplishing the same things. In general, an event will be generated by an outside entity (for example, keyboard or mouse wheel) and will be delivered through the event loop in . In general, unless you set up the code, you will not be generating events. You might filter them through or handle events in subclassed object by overriding the appropriate functions. Signals and Slots are much easier to generate and receive and you can connect any two subclasses. They are handled through the Metaclass (have a look at your moc_classname.cpp file for more), but most of the interclass communication that you will produce will probably use signals and slots. Signals can get delivered immediately or deferred via a queue (if you are using threads).\n\nEvents are dispatched by the event loop. Each GUI program needs an event loop, whatever you write it Windows or Linux, using Qt, Win32 or any other GUI library. As well each thread has its own event loop. In Qt \"GUI Event Loop\" (which is the main loop of all Qt applications) is hidden, but you start it calling: Messages OS and other applications send to your program are dispatched as events. Signals and slots are Qt mechanisms. In the process of compilations using moc (meta-object compiler), they are changed to callback functions. Event should have one receiver, which should dispatch it. No one else should get that event. All slots connected to the emitted signal will be executed. You shouldn't think of Signals as events, because as you can read in the Qt documentation: When a signal is emitted, the slots connected to it are usually executed immediately, just like a normal function call. When this happens, the signals and slots mechanism is totally independent of any GUI event loop. When you send an event, it must wait for some time until the event loop dispatches all events that came earlier. Because of this, execution of the code after sending event or signal is different. Code following sending an event will be run immediately. With the signals and slots mechanisms it depends on the connection type. Normally it will be executed after all slots. Using Qt::QueuedConnection, it will be executed immediately, just like events. Check all connection types in the Qt documentation.\n\nThere is an article that discusses event processing in some detail: http://www.packtpub.com/article/events-and-signals It discussions the difference between events and signals here: Events and signals are two parallel mechanisms used to accomplish the same thing. As a general difference, signals are useful when using a widget, whereas events are useful when implementing the widget. For example, when we are using a widget like QPushButton, we are more interested in its clicked() signal than in the low-level mouse press or key press events that caused the signal to be emitted. But if we are implementing the QPushButton class, we are more interested in the implementation of code for mouse and key events. Also, we usually handle events but get notified by signal emissions. This seems to be a common way of talking about it, as the accepted answer uses some of the same phrases. Note, please see helpful comments below on this answer from Kuba Ober, that make me wonder if it might be a bit simplistic.\n\nEvents (in a general sense of user/network interaction) are typically handled in Qt with signals/slots, but signals/slots can do plenty of other things. QEvent and its subclasses are basically just little standardized data packages for the framework to communicate with your code. If you want to pay attention to the mouse in some way, you only have to look at the QMouseEvent API, and the library designers don't have to reinvent the wheel every time you need to figure out what the mouse did in some corner of the Qt API. It is true that if you're waiting for events (again in the general case) of some sort, your slot will almost certainly accept a QEvent subclass as an argument. With that said, signals and slots can certainly be used without QEvents, although you'll find that the original impetus for activating a signal will often be some kind of user interaction or other asynchronous activity. Sometimes, however, your code will just reach a point where firing off a certain signal will be the right thing to do. For example, firing off a signal connected to a progress bar during a long process doesn't involve a QEvent up to that point."
    },
    {
        "link": "https://forum.qt.io/topic/75485/communication-between-plugins-and-pluginmanager",
        "document": "Your browser does not seem to support JavaScript. As a result, your viewing experience will be diminished, and you have been placed in read-only mode.\n\nPlease download a browser that supports JavaScript, or enable it if it's disabled (i.e. NoScript)."
    },
    {
        "link": "https://doc.qt.io/qtcreator-extending/pluginmanager.html",
        "document": "Usually, plugins do not need to access the plugin manager directly. They interact with it mostly indirectly through the ExtensionSystem::IPlugin interface. There are occasions though, where using the plugin manager API is necessary. Plugins need to access the plugin manager's object pool to extend some aspects of Qt Creator, for example to add pages to the options dialog. They can also utilize the object pool to provide extension points for other plugins.\n\nThe plugin manager handles all the details regarding finding plugins, reading their description files, resolving plugin dependencies, loading and initializing all plugins in the right order, and passing on command-line arguments.\n\nIn addition, the plugin manager manages an object pool, where objects can be registered and retrieved depending on different criteria.\n\nMost interaction of plugins with the plugin manager should be done through the ExtensionSystem::IPlugin interface, but the following tables summarize some functions and signals that can be useful for plugins. See the ExtensionSystem::PluginManager reference documentation for the complete list.\n\nPlugins can register objects to a common pool that is managed by the plugin manager. Objects in the pool must derive from QObject, there are no other prerequisites.\n\nAll objects of a specified type can be retrieved from the object pool via the getObject() function. It is aware of Aggregation::Aggregate, and uses the Aggregation::query() function instead of to determine the matching objects.\n\nAn unfiltered list of all objects that are registered in the object pool can be retrieved via the allObjects() function.\n\nIt is also possible to retrieve an object with a specific object name with getObjectByName() (see QObject::objectName()).\n\nWhenever the state of the object pool changes, a corresponding or signal is emitted by the plugin manager.\n\nA common use case for the object pool is that a plugin (or the application) provides an extension point for other plugins, which is a class that can be implemented and added to the object pool to be retrieved by the providing plugin. It is also possible to use the object pool to provide access to an object without actually linking against the providing plugin library."
    },
    {
        "link": "https://github.com/qt-creator/qt-creator/blob/master/src/libs/extensionsystem/pluginmanager.cpp",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/47435462/how-to-setup-a-plugin",
        "document": "I've written a qt application to communicate to a custom controller over RS232. I now need to extend functionality to the application through a plugin. I've looked at the Echo Plugin Example provided online and what else I can find elsewhere online but I am still pretty lost and the very basic plugin is not compiling. the project .pro file for the plugin is as follows:\n\nBelow is the interface class\n\nI am getting the following error and as far as I can tell, I don't have any code to fail.\n\nI've searched online for a resolution to this error but haven't found any results."
    },
    {
        "link": "https://moreware.org/books/Writing-Qt-Creator-Plugins.pdf",
        "document": ""
    }
]