[
    {
        "link": "https://react.dev/reference/react/useState",
        "document": "Suppose the is . This handler calls three times: However, after one click, will only be rather than ! This is because calling the function does not update the state variable in the already running code. So each call becomes . To solve this problem, you may pass an updater function to instead of the next state: Here, is your updater function. It takes the pending state and calculates the next state from it. React puts your updater functions in a queue. Then, during the next render, it will call them in the same order:\n• will receive as the pending state and return as the next state.\n• will receive as the pending state and return as the next state.\n• will receive as the pending state and return as the next state. There are no other queued updates, so React will store as the current state in the end. By convention, it’s common to name the pending state argument for the first letter of the state variable name, like for . However, you may also call it like or something else that you find clearer. React may call your updaters twice in development to verify that they are pure. You might hear a recommendation to always write code like if the state you’re setting is calculated from the previous state. There is no harm in it, but it is also not always necessary. In most cases, there is no difference between these two approaches. React always makes sure that for intentional user actions, like clicks, the state variable would be updated before the next click. This means there is no risk of a click handler seeing a “stale” at the beginning of the event handler. However, if you do multiple updates within the same event, updaters can be helpful. They’re also helpful if accessing the state variable itself is inconvenient (you might run into this when optimizing re-renders). If you prefer consistency over slightly more verbose syntax, it’s reasonable to always write an updater if the state you’re setting is calculated from the previous state. If it’s calculated from the previous state of some other state variable, you might want to combine them into one object and use a reducer.\n\nReact saves the initial state once and ignores it on the next renders. Although the result of is only used for the initial render, you’re still calling this function on every render. This can be wasteful if it’s creating large arrays or performing expensive calculations. To solve this, you may pass it as an initializer function to instead: Notice that you’re passing , which is the function itself, and not , which is the result of calling it. If you pass a function to , React will only call it during initialization. React may call your initializers twice in development to verify that they are pure.\n\nUsually, you will update state in event handlers. However, in rare cases you might want to adjust state in response to rendering — for example, you might want to change a state variable when a prop changes. In most cases, you don’t need this:\n• If the value you need can be computed entirely from the current props or other state, remove that redundant state altogether. If you’re worried about recomputing too often, the Hook can help.\n• If you want to reset the entire component tree’s state, pass a different to your component.\n• If you can, update all the relevant state in the event handlers. In the rare case that none of these apply, there is a pattern you can use to update state based on the values that have been rendered so far, by calling a function while your component is rendering. Here’s an example. This component displays the prop passed to it: Say you want to show whether the counter has increased or decreased since the last change. The prop doesn’t tell you this — you need to keep track of its previous value. Add the state variable to track it. Add another state variable called to hold whether the count has increased or decreased. Compare with , and if they’re not equal, update both and . Now you can show both the current count prop and how it has changed since the last render.\n\nNote that if you call a function while rendering, it must be inside a condition like , and there must be a call like inside of the condition. Otherwise, your component would re-render in a loop until it crashes. Also, you can only update the state of the currently rendering component like this. Calling the function of another component during rendering is an error. Finally, your call should still update state without mutation — this doesn’t mean you can break other rules of pure functions. This pattern can be hard to understand and is usually best avoided. However, it’s better than updating state in an effect. When you call the function during render, React will re-render that component immediately after your component exits with a statement, and before rendering the children. This way, children don’t need to render twice. The rest of your component function will still execute (and the result will be thrown away). If your condition is below all the Hook calls, you may add an early to restart rendering earlier. Calling the function does not change state in the running code: This is because states behaves like a snapshot. Updating state requests another render with the new state value, but does not affect the JavaScript variable in your already-running event handler. If you need to use the next state, you can save it in a variable before passing it to the function: React will ignore your update if the next state is equal to the previous state, as determined by an comparison. This usually happens when you change an object or an array in state directly: You mutated an existing object and passed it back to , so React ignored the update. To fix this, you need to ensure that you’re always replacing objects and arrays in state instead of mutating them: I’m getting an error: “Too many re-renders” You might get an error that says: Too many re-renders. React limits the number of renders to prevent an infinite loop. Typically, this means that you’re unconditionally setting state during render, so your component enters a loop: render, set state (which causes a render), render, set state (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler: If you can’t find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific function call responsible for the error. In Strict Mode, React will call some of your functions twice instead of once: This is expected and shouldn’t break your code. This development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and updater functions are pure, this shouldn’t affect your logic. However, if they are accidentally impure, this helps you notice the mistakes. For example, this impure updater function mutates an array in state: Because React calls your updater function twice, you’ll see the todo was added twice, so you’ll know that there is a mistake. In this example, you can fix the mistake by replacing the array instead of mutating it: Now that this updater function is pure, calling it an extra time doesn’t make a difference in behavior. This is why React calling it twice helps you find mistakes. Only component, initializer, and updater functions need to be pure. Event handlers don’t need to be pure, so React will never call your event handlers twice. I’m trying to set state to a function, but it gets called instead You can’t put a function into state like this: Because you’re passing a function, React assumes that is an initializer function, and that is an updater function, so it tries to call them and store the result. To actually store a function, you have to put before them in both cases. Then React will store the functions you pass."
    },
    {
        "link": "https://legacy.reactjs.org/docs/hooks-state.html",
        "document": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.\n\nThe introduction page used this example to get familiar with Hooks:\n\nWe’ll start learning about Hooks by comparing this code to an equivalent class example.\n\nIf you used classes in React before, this code should look familiar:\n\nThe state starts as , and we increment when the user clicks a button by calling . We’ll use snippets from this class throughout the page.\n\nAs a reminder, function components in React look like this:\n\nYou might have previously known these as “stateless components”. We’re now introducing the ability to use React state from these, so we prefer the name “function components”.\n\nHooks don’t work inside classes. But you can use them instead of writing classes.\n\nOur new example starts by importing the Hook from React:\n\nWhat is a Hook? A Hook is a special function that lets you “hook into” React features. For example, is a Hook that lets you add React state to function components. We’ll learn other Hooks later.\n\nWhen would I use a Hook? If you write a function component and realize you need to add some state to it, previously you had to convert it to a class. Now you can use a Hook inside the existing function component. We’re going to do that right now!\n\nIn a class, we initialize the state to by setting to in the constructor:\n\nIn a function component, we have no , so we can’t assign or read . Instead, we call the Hook directly inside our component:\n\nWhat does calling do? It declares a “state variable”. Our variable is called but we could call it anything else, like . This is a way to “preserve” some values between the function calls — is a new way to use the exact same capabilities that provides in a class. Normally, variables “disappear” when the function exits but state variables are preserved by React.\n\nWhat do we pass to as an argument? The only argument to the Hook is the initial state. Unlike with classes, the state doesn’t have to be an object. We can keep a number or a string if that’s all we need. In our example, we just want a number for how many times the user clicked, so pass as initial state for our variable. (If we wanted to store two different values in state, we would call twice.)\n\nWhat does return? It returns a pair of values: the current state and a function that updates it. This is why we write . This is similar to and in a class, except you get them in a pair. If you’re not familiar with the syntax we used, we’ll come back to it at the bottom of this page.\n\nNow that we know what the Hook does, our example should make more sense:\n\nWe declare a state variable called , and set it to . React will remember its current value between re-renders, and provide the most recent one to our function. If we want to update the current , we can call .\n\nWhen we want to display the current count in a class, we read :\n\nIn a function, we can use directly:\n\nIn a class, we need to call to update the state:\n\nIn a function, we already have and as variables so we don’t need :\n\nLet’s now recap what we learned line by line and check our understanding.\n• Line 1: We import the Hook from React. It lets us keep local state in a function component.\n• Line 4: Inside the component, we declare a new state variable by calling the Hook. It returns a pair of values, to which we give names. We’re calling our variable because it holds the number of button clicks. We initialize it to zero by passing as the only argument. The second returned item is itself a function. It lets us update the so we’ll name it .\n• Line 9: When the user clicks, we call with a new value. React will then re-render the component, passing the new value to it.\n\nThis might seem like a lot to take in at first. Don’t rush it! If you’re lost in the explanation, look at the code above again and try to read it from top to bottom. We promise that once you try to “forget” how state works in classes, and look at this code with fresh eyes, it will make sense.\n\nTip: What Do Square Brackets Mean?\n\nYou might have noticed the square brackets when we declare a state variable:\n\nThe names on the left aren’t a part of the React API. You can name your own state variables:\n\nThis JavaScript syntax is called “array destructuring”. It means that we’re making two new variables and , where is set to the first value returned by , and is the second. It is equivalent to this code:\n\nWhen we declare a state variable with , it returns a pair — an array with two items. The first item is the current value, and the second is a function that lets us update it. Using and to access them is a bit confusing because they have a specific meaning. This is why we use array destructuring instead.\n\nDeclaring state variables as a pair of is also handy because it lets us give different names to different state variables if we want to use more than one:\n\nIn the above component, we have , , and as local variables, and we can update them individually:\n\nYou don’t have to use many state variables. State variables can hold objects and arrays just fine, so you can still group related data together. However, unlike in a class, updating a state variable always replaces it instead of merging it.\n\nWe provide more recommendations on splitting independent state variables in the FAQ.\n\nOn this page we’ve learned about one of the Hooks provided by React, called . We’re also sometimes going to refer to it as the “State Hook”. It lets us add local state to React function components — which we did for the first time ever!\n\nWe also learned a little bit more about what Hooks are. Hooks are functions that let you “hook into” React features from function components. Their names always start with , and there are more Hooks we haven’t seen yet.\n\nNow let’s continue by learning the next Hook: . It lets you perform side effects in components, and is similar to lifecycle methods in classes."
    },
    {
        "link": "https://hygraph.com/blog/usestate-react",
        "document": "React is a free, open-source JavaScript frontend library that we can use to build frontend applications. Before React v16.8 in 2019, developers always used class components for data management (with states) and other operations like lifecycle methods, and functional components were only to be used for rendering UI.\n\nSince the introduction of React Hooks in React v16.8, we can manage data via states in functional components and work with lifecycle methods. Over time, class components were outdated and deprecated in React. Functional components along with Hooks are the new standard way to write React components.\n\nWhenever an interaction happens, react components often need to change and show the latest data after an interaction. For instance, typing in a form should update the input field with whatever the user typed, clicking “next page” should change the page content, and clicking “Add contact” should add the new contact to the existing contact list.\n\nTo update the UI, components first need to “remember” these things: the current input value, the current page, and the current contact list. This kind of component-specific memory is called state.\n\nIn this code above, we have defined a local variable and an increment button, which tries to increment the count value by one every time it is clicked. However, if we try to run this code and click the increment button it doesn’t work as expected. This happens due to two reasons\n• The value of a local variable does not persist across renders, meaning that on every re-render count will be re-initialized to 0.\n• Local variables do not trigger re-renders, so when we click the Increment button, React would not detect a state change and would not re-render our component.\n\nWe need to have “state” here instead of the local variable to manage the memory of a component.\n• Allows us to obtain a state variable, this is a special variable that is capable of retaining data between renders.\n• Provides us with a setter function to update the state variable and hence trigger a re-render of our component.\n\nWe can import the useState hook from react. The useState() hook takes in the initial value of the state variable as an argument and provides us with the state variable and the setter function. The variable could be of any data type, such as string, number, object, array, and more.\n\nThis setter function can be called anything, but it is a general practice to use the variable name with a prefix of . For example - name, setName | count, setCount | and so on.\n\nTo fix our CounterExample component where we could not see the updates in the UI we can use the useState hook. Here’s how we can use it to fix the situation:\n\nGoing a step further, we should understand that the setter function will always have access to the value of the state variable in the current render. Let us take the example of the counter component we have built above. Try adding some logs before and after calling the setCount and hit the increment button:\n\nYou might have expected it to print 1 in the After Set Count, but it logged a 0 there as well.\n\nThis happens because in the entire execution context of the handleClick function, the value of count was initially 0 and the operations by setCount will take effect in the next render.\n\nNext, let us take a look at this function below:\n\nOkay, two questions arise here:\n• What do you think will be printed in the logs?\n• What will be the value of the count variable in the next render?\n\nFor 1, it will print 0 as the function will have access to the count value of the current render.\n\nFor 2, the value of count in the next render will be 1 and not 3, even though we called thrice.\n\nThis is what actually happens, we are just calling thrice.\n\nYou may run into a situation where you want to access the latest value of a state variable and update it in that case you can use updater functions as shown below:\n\nAs you can see, instead of passing a value to setCount we passed a function, this function gets the latest value of the variable as a parameter and returns an incremented value and this is how it will behave:\n\nAt times we need to store many things for a particular entity, for example - we can choose to have name, age, and hobby as state variables for a person.\n\nInstead of creating three different state variables, it would be better to create an object that stores the state of a person. We can combine name, age, and hobby properties into an object state and use it as shown in the template.\n\nSo far we have seen numbers, and strings as state variables, these JavaScript values are “immutable”, so if we replace them we can trigger a re-render.\n\nWhen we set the distance from to , the value itself doesn’t change. is still\n\nBut when we do something as shown below, we are the state, and the original object itself changes. This is known as a . This is not allowed and would not lead React to re-render our component.\n\nIt is important to remember that we cannot mutate a state variable of type objects/arrays. We always need to replace them entirely or use the spread operator.\n\nSimilarly, we can use arrays to store some data as shown\n\nWhen updating the array state, we must avoid methods like , , , , , , and as these methods mutate the original array. Instead, we should use options like , , , , and as these methods return an entirely new array.\n\nis a hook, so just like any other hook, we should only use the useState() hook at the top level of our component: We should not use it inside any function, loop, nested function, or conditions. This helps React preserve and call hooks in the same order each time a component renders.\n\nIn this guide, we have learned what state is and why it is important, we learned about the useState() hook from React which helps us to manage a component’s memory. We also learned about the lifecycle of a state variable and how the new state value is enforced after a component’s re-render. Finally, we checked how to use objects and arrays as state variables and wrapped up by going through a few caveats about using hooks."
    },
    {
        "link": "https://medium.com/@dezsays/simplify-state-management-with-reacts-usestate-hook-1bf34191ddc5",
        "document": "Introduction\n\nState management plays a crucial role in React applications, enabling components to maintain and update dynamic data. React’s useState hook revolutionizes state management by providing a simple and intuitive way to introduce stateful behavior into functional components. In this blog post, we’ll dive into the useState hook, explore its purpose and benefits, and learn when to leverage its power. Let’s embark on a journey of simplified state management in React with useState!\n\nUnderstanding the useState Hook\n\nThe useState hook is a built-in hook in React that enables functional components to manage state. It allows you to declare and initialize state variables within a component, providing a way to preserve and update data across renders. The hook returns a state variable and a function to update it, allowing you to control and modify the state seamlessly.\n\nWhy Use the useState Hook?\n\nThe useState hook offers several advantages when it comes to managing state in React applications. Let’s explore the key benefits of using useState:\n\n🔄 Simplified State Management: useState simplifies state management by eliminating the need for class components or external state management libraries. It brings state management directly into functional components, making them more concise and easier to understand.\n\n⚡️ Reactive Updates: With useState, React takes care of re-rendering the component whenever the state changes. When you update the state using the provided update function, React intelligently updates the component’s UI to reflect the new state, ensuring a reactive and responsive user interface.\n\n🧩 Modular and Reusable Components: By encapsulating state within functional components, useState promotes modularity and reusability. You can create self-contained components that manage their own state, making it easier to compose and reuse them in different parts of your application.\n\nWhen to Use the useState Hook\n\nNow that we understand the benefits of using the useState hook, let’s explore some scenarios where it proves valuable in React applications:\n\n📝 Managing Local Component State: When you need to introduce local state within a functional component, useState is the go-to solution. It allows you to declare and update state variables directly within the component, enabling you to manage and manipulate data specific to that component.\n\n🔄 Handling User Input and Form Data: useState is particularly useful when dealing with user input and form data. By maintaining state for input fields, checkboxes, or dropdowns, you can easily capture and update the values as the user interacts with the form.\n\n🌐 Controlling UI Interactions and Display: useState is effective in controlling UI interactions and dynamically displaying content. You can use state variables to toggle visibility, control animations, manage active tabs, or handle conditional rendering based on certain conditions.\n\nPractical Tips for Working with useState\n\nTo make the most of the useState hook in your React applications, consider the following tips:\n\n🚀 Declare State Variables with Descriptive Names: Choose descriptive names for your state variables to enhance code readability and maintainability. This helps you and other developers understand the purpose and usage of each state variable.\n\n📦 Destructure State Variables: When working with complex state objects or arrays, use object/array destructuring to access and update individual properties or elements. This ensures clean and concise code, especially when dealing with multiple state variables.\n\n🧪 Use Functional Updates for Complex State: When updating state based on the previous state or performing computations, use functional updates provided by useState. This ensures that state updates are based on the most recent state value and helps prevent unexpected behavior.\n\nConclusion\n\nThe useState hook empowers React developers with a simple and intuitive approach to state management within functional components. By leveraging useState, you can introduce and update state variables seamlessly, resulting in concise and reactive components. Simplify your state management, enhance modularity, and improve the user experience of your React applications with the useState hook. Embrace the power of useState and unlock the potential of stateful functional components in React!\n\nAbout the Author\n\nDezarea Bryan is a passionate developer and technology enthusiast. Connect with Dezarea on GitHub and LinkedIn for more insights and exciting projects."
    },
    {
        "link": "https://blog.logrocket.com/guide-usestate-react",
        "document": "Editor’s note: This React Hook tutorial was last reviewed and updated on 8 October 2024.\n\nIn React, the Hook allows you to add state to functional components. returns an array with two values: the current state and a function to update it.\n\nThe Hook takes an initial state value as an argument and returns an updated state value whenever the function is called. It can be used like this:\n\nHere, the is the value you want to start with and is the current state value that can be used in your component. The function can be used to update the , triggering a re-render of your component.\n\nThe Hook in React is the equivalent of / for functional components.\n\nFor a visual guide to , check out the video tutorial below:\n\nIn React, there are two types of components:\n• Class components: ES6 classes that extend the built-in and methods:\n• Functional components: Functions that accept arguments as the properties of the component and return valid JSX, as shown below: function Message(props) { return <div>{props.message}</div> } // Or as an arrow function const Message = (props) => <div>{props.message}</div>\n\nAs you can see, there are no state or lifecycle methods. However, as of React v16.8, we can use Hooks. React Hooks, which tend to start with “ ” are functions that add state variables to functional components and instrument the lifecycle methods of classes.\n\nWhat does do?\n\nallows you to add state to function components. Calling inside a function component generates a single piece of state associated with that component.\n\nWhereas the state in a class is always an object, with Hooks, the state can be any type. Each piece of state holds a single value: an , an , a , or any other type you can imagine.\n\nSo, when should you use the Hook? It’s beneficial for managing local component state, but for larger projects, additional state management solutions may be necessary.\n\nIn React, can store any type of value, whereas the state in a class component is limited to being an object. This includes primitive data types like , , and , as well as complex data types such as , , and . It can even cover custom data types like class instances.\n\nBasically, anything that can be stored in a JavaScript variable can be stored in a state managed by .\n\nNever directly modify an object or array stored in . Instead, you should create a new updated version of the object or array and call with the new version:\n\nis a named export from . To use it, you can write or import it by writing :\n\nThe object can be declared in a class and allows you to declare more than one state variable, as shown below:\n\nHowever, unlike the object, the Hook allows you to declare only one state variable (of any type) at a time, like this:\n\ntakes the initial value of the state variable as an argument, and you can pass it directly, as shown in the previous example. You can also use a function to lazily initialize the variable. This is useful when the initial state is the result of an expensive computation:\n\nThe initial value will be assigned only on the initial render. If it’s a function, it will be executed only on the initial render. In subsequent renders (due to a change of state in the component or a parent component), the argument of the Hook will be ignored, and the current value will be retrieved.\n\nIt is important to note that if you want to update the state based on new properties the component receives, using alone won’t work. This is because only uses its initial argument the first time — not each time the property changes. Check this out for the correct way to handle this. It’s demonstrated here:\n\nBut doesn’t return just a variable, as the previous examples imply. It returns an array, where the first element is the state variable and the second element is a function to update the value of the variable:\n\nUsually, you’ll use array destructuring to simplify the code shown above like this:\n\nThis way, you can use the state variable in the functional component like any other variable:\n\nBut, why does return an array? This is because, compared to an object, an array is more flexible and easy to use. If the method returned an object with a fixed set of properties, you wouldn’t be able to assign custom names easily.\n\nInstead, you’d have to do something like this (assuming the properties of the object are and ):\n\nUsing React Hooks to update the state\n\nThe second element returned by is a function that takes a new value to update the state variable. Here’s an example that uses a box to update the state variable on every change:\n\nYou can try this on Code Sandbox here.\n\nHowever, this update function doesn’t update the value right away. Instead, it enqueues the update operation. Then, after re-rendering the component, the argument of will be ignored, and this function will return the most recent value.\n\nWhen updating state based on its previous value, you need to pass a function to the function that updates the state. This function receives the previous state value as an argument and returns the new state value, as shown below:\n\nYou can try this on Code Sandbox here.\n\nImplementing an object as a state variable with Hook\n\nThere are two things you need to keep in mind about updates when using objects:\n• The fact that the setter returned by doesn’t merge objects like does in class components\n\nRegarding the first point; if you use the same value as the current state to update the state (React uses for comparing), React won’t trigger a re-render.\n\nWhen working with objects, it’s easy to make the following mistake:\n\nInstead of creating a new object, the above example mutates the existing state object. To React, that’s the same object. To make it work, we must create a new object, just like we discussed earlier:\n\nThis leads us to the second important point you need to remember: when you update a state variable, unlike in a class component, the function returned by does not automatically merge update objects — it replaces them.\n\nFollowing the previous example, if we add another property to the message object ( ) as shown below:\n\nAnd we only update the property like in the above example, React will replace the original state object with the object used in the event, which only contains the property:\n\nYou can see how the property is lost here on Code Sandbox.\n\nYou can replicate the behavior of by using the function argument that contains the object to be replaced and the object spread syntax:\n\nThe part will get all of the properties of the object, and the part will overwrite the property. This will have the same result as using (just remember to create a new object):\n\nTry it here on Code Sandbox.\n\nHowever, the spread syntax simplifies this operation, and it also works with arrays. Basically, when applied to an array, the spread syntax removes the brackets so you can create another one with the values of the original array:\n\nHere’s an example that shows how to use with arrays:\n\nYou have to be careful when applying the spread syntax to multi-dimensional arrays because it only performs a shallow copy, meaning nested arrays won’t be fully copied and will still reference the original data.\n\nHow to update state in a nested object in React with Hooks\n\nIn JavaScript, multi-dimensional arrays are arrays within arrays, as shown below:\n\nYou could use them to group all your state variables in one place. However, for that purpose, it would be better to use nested objects like this:\n\nBut, the problem when working with multi-dimensional arrays and nested objects is that and the spread syntax will create a shallow copy instead of a deep copy.\n\nThis Stack Overflow query offers good explanations for the above example, but the important point is that when using nested objects, we can’t just use the spread syntax to update the state object. For example, consider the following state object:\n\nThe following code snippets show some incorrect ways to update the field:\n\nTo properly update the field, we need to create a new object that includes all fields and nested objects from the original object:\n\nIn the same way, here’s how you’d update the field of the object:\n\nHowever, this is assuming the object doesn’t change. If it does change, you’d have to update the object this way:\n\nWhen working with multiple fields or values as the state of your application, you have the option of organizing the state using multiple state variables:\n\nHowever, you have to be careful when using state objects with a complex structure (nested objects). Consider this example:\n\nIf you have to update a specific field nested deep in the object, you’ll have to copy all the other objects along with the key-value pairs of the object that contains that specific field:\n\nIn some cases, cloning deeply nested objects can be expensive because React may re-render parts of your applications that depend on fields that haven’t even changed.\n\nFor this reason, the first thing you need to consider is trying to flatten your state object(s). In particular, the React documentation recommends splitting the state into multiple state variables based on which values tend to change together.\n\nIf this is not possible, the recommendation is to use libraries that help you work with immutable objects, such as Immutable.js or Immer.\n\nabides by the same rules that all React Hooks follow:\n• Only call hooks at the top level\n\nThe second rule is easy to follow. Don’t use in a class component:\n\nYou’ll get an error. The first rule means that even inside functional components, you shouldn’t call in loops, conditions, or nested functions because React relies on the order in which functions are called to get the correct value for a particular state variable.\n\nIn that regard, the most common mistake is to wrap calls in a conditional statement (they won’t be executed all the time):\n\nA functional component can have many calls to or other Hooks. Each Hook is stored in a list, and there’s a variable that keeps track of the currently executed Hook.\n\nWhen is executed, the state of the current Hook is read (or initialized during the first render), and then, the variable is changed to point to the next Hook. That’s why it is important to always maintain the Hook calls in the same order. Otherwise, a value belonging to another state variable could be returned.\n\nIn general terms, here’s a step-by-step example of how React handles and tracks state changes in functional components when using the Hook:\n• React initializes the list of Hooks and the variable that keeps track of the current Hook\n• React calls your component for the first time\n• React finds a call to , creates a new Hook object (with the initial state), changes the current Hook variable to point to this object, adds the object to the Hooks list, and returns the array with the initial state and the function to update it\n• React finds another call to and repeats the actions of the previous step, storing a new Hook object and changing the current Hook variable\n• React sends the state update operation (performed by the function returned by ) to a queue to be processed\n• React determines it needs to re-render the component\n• React resets the current Hook variable and calls your component\n• React finds a call to , but this time, because there’s already a Hook at the first position of the list of Hooks, it just changes the current Hook variable and returns the array with the current state, and the function to update it\n• React finds another call to and because a Hook exists in the second position, once again, it just changes the current Hook variable and returns the array with the current state and the function to update it\n\nIf you like to read code, refer to the class to learn how Hooks work under the hood.\n\nand allow you to manage state and side effects in your functional components. However, they serve different purposes and should be used in different ways:\n• \n• Allows you to add state to your functional component\n• Returns an array with two values: the current state and a setter function for updating the state\n• Used for managing state that needs to be updated and re-rendered based on user interactions or other events in the component\n• \n• Used to manage side effects in functional components. A side effect is any operation that impacts the component outside of its render, such as making an API call or setting up a timer\n• Used to manage side effects that need to run after every render of the component or perform any cleanup when the component unmounts\n\nFor example, consider a component that fetches data from an API and displays it in a list:\n\nIn this example, the Hook is used to make an API call and update the state whenever the component is rendered. The Hook takes a function as an argument, which will be executed after every render of the component. The second argument to is an array of dependencies, which determines when the effect should run. In this case, the empty array means that the effect will only run once when the component is mounted.\n\nFor advanced use cases, you can use the Hook as an alternative to . This is especially useful when you have complex state logic that uses multiple sub-values or when a state depends on the previous one.\n\nKey points to remember about the React Hook\n• The update function doesn’t update the value right away\n• If you use the previous value to update state, you must pass a function that receives the previous value and returns an updated value, for example,\n• If you use the same value as the current state to update the state, React won’t trigger a re-render\n• Unlike in class components, doesn’t merge objects when the state is updated; it replaces them\n• follows the same rules that all Hooks do. In particular, pay attention to the order in which these functions are called (there’s an ESLint plugin that will help you enforce these rules)"
    },
    {
        "link": "https://medium.com/@rashmipatil24/handling-events-in-react-9c010f783612",
        "document": "In web development, handling user interactions like clicks, form submissions, or keyboard inputs is fundamental. React, with its declarative and component-based architecture, makes event handling more intuitive and efficient. Understanding how to handle events in React is crucial for creating dynamic and interactive user interfaces.\n\nIn this blog, we’ll explore how to handle different types of events in React, such as clicks, form submissions, and keyboard events. By the end, you’ll have a practical understanding of how to work with React’s event system and implement user interactions in your applications.\n\nWhat Are Events in React?\n\nEvents in React are triggered by user actions like clicking a button, typing into a form field, or submitting a form. React’s event system is based on the SyntheticEvent object, which is a cross-browser wrapper around the browser’s native event. This ensures consistent behavior across different browsers.\n• : Triggers when an element is clicked.\n• : Triggers when the value of an input field changes.\n• : Triggers when a key is pressed down.\n\nClick events are among the most common interactions in web apps. In React, handling a click event is simple. You define an event handler function and attach it to the element using the attribute.\n\nIn this example, when the button is clicked, the function updates the message displayed in the tag. The event handler is directly passed to the attribute of the button.\n\nForms are essential for collecting user input, whether for login, signup, or data submission. React handles form events like and smoothly. The event captures changes in form fields, while is used to handle the form submission.\n\nIn this example:\n• updates the and state whenever the user types in the respective input fields.\n• is triggered when the form is submitted, and is used to stop the default page reload.\n\nKeyboard events are particularly useful when you need to trigger actions based on specific key presses, such as navigating through items with the arrow keys or handling form submissions when the user presses “Enter.”\n\nIn this example, the function captures the key pressed by the user. The component requires a attribute to make it focusable, allowing it to listen for key presses when focused.\n\nSometimes, you may want to pass parameters to your event handler. You can achieve this by wrapping the event handler function in an arrow function.\n\nExample of Passing Parameters to Event Handlers:\n\nIn this example, the function takes a parameter , which is passed to the button's event handler via an arrow function.\n\nReact’s SyntheticEvent system reuses event objects across multiple events to optimize performance, a process called event pooling. As a result, the event object will be nullified after the event handler has been executed. If you need to access the event after the handler has run, you can call to keep the event object around.\n\nCalling ensures that the event remains accessible beyond the current event handler’s scope.\n\nBest Practices for Handling Events in React\n• Keep Event Handlers Simple\n\nEvent handlers should focus on handling the interaction and updating the state. Complex logic should be moved into separate functions.\n• Avoid Inline Event Handlers for Complex Logic\n\nFor readability and maintainability, avoid putting complex logic directly into the JSX. Instead, reference a separate function.\n• Pass Data Using Closures\n\nIf you need to pass additional data into the event handler, use closures or bind the event handler with the necessary data.\n• Use State to Handle Form Inputs\n\nReact is all about managing state. For form handling, keep input values and state in sync using and controlled components.\n\nHandling events in React is a key part of building interactive applications. Whether it’s a button click, form submission, or a key press, React provides a clean and consistent API for managing user interactions. By mastering event handling, you can create dynamic and responsive interfaces that improve the user experience.\n\nStart applying these event-handling techniques in your next React project! Experiment with click, form, and keyboard events, and see how they enhance your app’s interactivity. Don’t forget to subscribe for more React tips and tutorials, and let us know in the comments if you have any questions!"
    },
    {
        "link": "https://legacy.reactjs.org/docs/handling-events.html",
        "document": "These docs are old and won’t be updated. Go to react.dev for the new React docs. These new documentation pages teach modern React and include live examples:\n\nHandling events with React elements is very similar to handling events on DOM elements. There are some syntax differences:\n• React events are named using camelCase, rather than lowercase.\n• With JSX you pass a function as the event handler, rather than a string.\n\nFor example, the HTML:\n\nis slightly different in React:\n\nAnother difference is that you cannot return to prevent default behavior in React. You must call explicitly. For example, with plain HTML, to prevent the default form behavior of submitting, you can write:\n\nIn React, this could instead be:\n\nHere, is a synthetic event. React defines these synthetic events according to the W3C spec, so you don’t need to worry about cross-browser compatibility. React events do not work exactly the same as native events. See the reference guide to learn more.\n\nWhen using React, you generally don’t need to call to add listeners to a DOM element after it is created. Instead, just provide a listener when the element is initially rendered.\n\nWhen you define a component using an ES6 class, a common pattern is for an event handler to be a method on the class. For example, this component renders a button that lets the user toggle between “ON” and “OFF” states:\n\nTry it on CodePen\n\nYou have to be careful about the meaning of in JSX callbacks. In JavaScript, class methods are not bound by default. If you forget to bind and pass it to , will be when the function is actually called.\n\nThis is not React-specific behavior; it is a part of how functions work in JavaScript. Generally, if you refer to a method without after it, such as , you should bind that method.\n\nIf calling annoys you, there are two ways you can get around this. You can use public class fields syntax to correctly bind callbacks:\n\nThis syntax is enabled by default in Create React App.\n\nIf you aren’t using class fields syntax, you can use an arrow function in the callback:\n\nThe problem with this syntax is that a different callback is created each time the renders. In most cases, this is fine. However, if this callback is passed as a prop to lower components, those components might do an extra re-rendering. We generally recommend binding in the constructor or using the class fields syntax, to avoid this sort of performance problem.\n\nInside a loop, it is common to want to pass an extra parameter to an event handler. For example, if is the row ID, either of the following would work:\n\nThe above two lines are equivalent, and use arrow functions and respectively.\n\nIn both cases, the argument representing the React event will be passed as a second argument after the ID. With an arrow function, we have to pass it explicitly, but with any further arguments are automatically forwarded."
    },
    {
        "link": "https://linkedin.com/pulse/revamp-your-reactjs-skills-handling-dynamic-events-like-ahsan-raza",
        "document": "Are you looking to enhance your React.js skills and become a pro in handling dynamic events? React.js is an efficient and popular JavaScript library that helps developers build interactive user interfaces. One of the key features of React.js is its ability to handle dynamic events, making it a powerful tool for developing dynamic web applications.\n\nIn this article, we'll explore how to handle dynamic events in React.js and take your React.js skills to the next level. We'll cover the basics of dynamic events, how to handle them, and some best practices for implementing them in your React.js applications.\n\nTo handle dynamic events in React.js, you first need to understand the event system in React. React uses a synthetic event system, which means that it abstracts away the differences between different browsers and provides a consistent interface for handling events.\n\nIn React.js, event handlers are functions that are invoked when a specific event occurs. To create an event handler in React.js, you first need to define a function that specifies the behavior you want to trigger when the event occurs.\n\nNow that you understand how to create event handlers in React.js, let's explore how to handle dynamic events. One of the most common dynamic events in React.js is the onChange event, which is triggered when the user types something into an input field.\n\nThis function logs the current value of the input field whenever the `onChange` event is triggered. To attach this event handler to an input field, you can use the `onChange` attribute:\n\nThis code will attach the `handleChange` function to the input field, which will log the current value of the input field whenever the user types something into the field.\n\nBest Practices for Handling Dynamic Events in React.js\n\nWhen defining event handler functions in React.js, it's important to bind this to the component instance. One way to do this is to use arrow functions instead of traditional function expressions.\n\nThis code will log `undefined` because `this` is not bound to the component instance. To bind `this` to the component instance, you can use an arrow function:\n\nIn some cases, you may want to prevent the default behavior of a dynamic event. For example, you may want to prevent a form from submitting when the user clicks the submit button. To prevent the default behavior of an event, you can use the `event.preventDefault()` method.\n\nWhen handling nested components in React.js, you may want to stop event propagation to prevent the event from bubbling up to the parent component. To stop event propagation, you can use the `event.stopPropagation( )` method.\n\nWhen handling dynamic events in React.js, you may need to access event properties asynchronously. In these cases, the event object may be recycled by the time the asynchronous code is executed. To prevent this, you can use the `event.persist( )` method to persist the event object."
    },
    {
        "link": "https://stackoverflow.com/questions/53467117/how-to-attach-an-event-handler-to-a-dynamically-created-item-in-react",
        "document": "I am new to React and am trying to add an onClick event handle to a list item which is created using .\n\nCurrently, the page renders with the individual items each having their own button. However, when i click on any of the button an error\n\nAny help would be appreciated in understanding what is happening. Thanks in advance."
    },
    {
        "link": "https://crsinfosolutions.com/event-handling-in-react-enhancing-user-interactions-react-js-tutorial-6",
        "document": "In the interactive landscape of modern web applications, handling events efficiently is crucial. React, with its unique approach to event handling, simplifies the process of creating responsive user interfaces. This article dives into the nuances of event handling in React, offering insights into its mechanism and best practices to enhance user experience.\n\nEvent handling in React is quite similar to handling events on DOM elements. However, there are some syntactic differences and underlying principles that set it apart. React events are named using camelCase rather than lowercase, and you pass functions as the event handlers rather than strings.\n\nRead more about Form Handling in React js\n• Synthetic Events: React wraps the browser’s native event into what it calls Synthetic Events. These are cross-browser wrappers around the browser’s native event system, providing a consistent interface across different browsers.\n• Handling Events with JSX: In JSX, you pass a function as the event handler, rather than a string. For example, in HTML, you might see , but in JSX, it’s .\n• Binding Event Handlers: In class components, you often need to bind the context of in event handlers to the component instance. This can be done in the constructor or using class fields syntax.\n\nHere’s a basic example of an event handler in a React component:\n\nWith the introduction of Hooks, functional components have become more prevalent. In functional components, there’s no need to bind event handlers, as they naturally capture the context of the enclosing function.\n\nExplore: How Can You Pass Props to Children Components in React?\n\nReact supports various event types, similar to those in plain JavaScript:\n\nHere are code examples for common event types in React:\n\nReact provides mouse events like and , allowing you to handle user interactions with the mouse.\n\nForm events like and are used to handle form submission and input changes dynamically.\n\nKeyboard events like and can be used to detect specific key presses.\n\nFocus events like and can be used to handle focus and blur events on form elements.\n\nThese examples show how React handles common event types, allowing you to build interactive user interfaces with event-driven behavior.\n\nIn some cases, you might need to pass an extra parameter to an event handler. This can be achieved by using an arrow function or the method.\n\nExample using an arrow function:\n• Use Arrow Functions for Inline Handlers: When you need to pass arguments to event handlers, arrow functions can be more convenient and concise.\n• Avoiding Performance Issues: While inline arrow functions are handy, they can cause performance issues if used carelessly, as they create a new function on every render. If performance is a concern, bind the method in the constructor or use class fields syntax.\n• Declarative Event Handling: Try to keep your event handlers declarative. This means your handlers should ideally handle the logic related to the event and delegate other responsibilities to other functions.\n• Event Pooling: React pools events for performance reasons. If you need to access the event properties asynchronously, call .\n\nForms in React are usually controlled components, with the form data being handled by the component’s state. The event is commonly used to update the state, reflecting the inputs of the user.\n\nHere’s a code example that demonstrates handling forms with event handlers in React using controlled components:\n• State Management: The form data is managed by the component’s state ( ), where each field in the form is tied to a corresponding state variable.\n• onChange Handler: The function is triggered on each input change, updating the state based on the user’s input.\n• Controlled Components: Each input field is a controlled component, with its attribute directly tied to the state, ensuring that the displayed value always reflects the state.\n• onSubmit Handler: When the form is submitted, the function prevents the default page reload and alerts the submitted form data.\n\nThis approach keeps form data and UI in sync with React’s state management.\n\nAccessibility is an important aspect of web development. Ensure that your event handlers are accessible. For example, ensure that keyboard events complement mouse events to allow keyboard navigation.\n\nApart from the standard events, you can also create and handle custom events in React. This can be particularly useful for more complex applications with deeply nested components or when integrating with non-React libraries.\n\nEvent handling in React is a fundamental aspect that enhances the interactivity of applications. It’s a blend of JavaScript’s native event handling and React’s synthetic events, resulting in a cross-browser compatible approach. Understanding the nuances of event handling, from binding context in class components to the use of Hooks in functional components, is essential for any React developer. By following best practices and keeping accessibility in mind, developers can create engaging, responsive, and user-friendly interfaces. As React continues to evolve, so does its event handling, making it an exciting area for developers to explore and master."
    }
]