[
    {
        "link": "https://eazytechy.medium.com/how-to-install-python-3-8-on-ubuntu-22-04-e4ad4d37ad93",
        "document": "Python, version 3.8, comes with several new features and improvements.\n• One of the most notable is the inclusion of a parallel filesystem cache for compiled bytecode. This can provide a significant performance boost when working on large projects.\n• Debug also builds now share ABI as release builds, which should help reduce debug builds’ overall size.\n• f-strings now support a handy = specifier for debugging. This can be used to insert the value of an expression into the string, making it easier to track down errors.\n• continue is now legal in finally: blocks that can be useful when dealing with cleanup procedures that may need to be interrupted\n\nIn the following tutorial, you will learn how to install Python 3.8 using the command terminal and how to download and compile as an alternative method.\n\nBefore proceeding with the tutorial, it is highly advised to run an update in your terminal to ensure all packages are up-to-date to avoid any conflicts during the installation.\n\nThe first and easiest solution for Ubuntu users would be to import the “deadsnakes” team Launchpad PPA. This will always contain the latest updates for Python and all extra packages that may be required\n\nFirst, install the following packages that are required. These are most likely installed but run the command to be safe.\n\nFor users who have not previously imported a GPG key from the Ubuntu keyserver, the command line terminal will often have issues importing GPG keys from LaunchPAD PPAs because the directories are not created. This is an easy fix. Use the following command that will, in turn, generate the directories.\n\nThe next task is to import the GPG key needed.\n\nWith the GPG key now imported, you can import the LaunchPAD PPA. Remember, match the command to the version of Linux Mint you are utilizing, or the installation will likely fail with errors.\n\nBefore you continue, run an APT update to reflect the newly imported PPA.\n\nVerify the installation and build version using the following command.\n\nHooray!! Now you can do amazing things with python\n\nThat’s it folks!! If you like it, do shower your support and like this blog."
    },
    {
        "link": "https://docs.vultr.com/install-the-latest-version-of-python-from-source-on-ubuntu-20-04",
        "document": "Ubuntu 20.04 comes with Python 3.8 pre-installed. However, you can install another version of Python 3 if you want. This guide explains how to install the latest version of Python from source on Ubuntu 20.04.\n• Follow Vultr's best practices guides to create a sudo user and update the Ubuntu server.\n\nBuilding Python from source requires various third-party and system libraries.\n• None Log in to the server as a non-root sudo user via SSH.\n• None To enable the source packages, add their location, including URL, distribution name, and component name.\n• None Install the third-party libraries for all optional modules.\n• None Download the source archive to the home directory. At the time of writing, the latest stable version of Python is 3.9.7. But, of course, you can always visit the Python releases page on GitHub to get the latest version.\n• None Change the working directory to the source directory.\n• None Build the source (this may take a few minutes). The option tells to print only warnings and errors.\n\nWhen finished, you have a Python 3.9 binary suitable for a production installation.\n\nInstalling Python 3.9 side by side with Python 3.8 is better than overwriting Python 3.8 because it allows existing programs that are not compatible with the new version to continue to work.\n\nUsing instead of avoids overwriting Python 3.8 with Python 3.9.\n\nPython 3.8 is the default Python version. However, you still use it the same way as before, by invoking , , or their absolute paths and .\n\nBoth give the same output like this.\n\nTo use Python 3.9, invoke or its absolute paths instead.\n\nThe result is similar to this.\n\nPython 3.9 also comes with pip, the package installer for Python.\n\nThe output should be like this.\n\nIf you ensure that all existing programs are compatible with Python 3.9, you can make it the default version."
    },
    {
        "link": "https://docs.cloudera.com/cdp-private-cloud-upgrade/latest/upgrade-hdp/topics/cdpdc-install-python-3-ubuntu.html",
        "document": "You must install Python 3.8 on all hosts on which you want to run the Hue service after installing Cloudera Manager and before adding the services to your cluster.\n\nInstall the necessary developer tools such as and on your system. Install the following packages before installing Python 3.8:\n• SSH into the host system as a root user.\n• Download Python 3.8 and decompress the package by running the following commands:\n• Change directory to where you decompressed the Python 3.8 package:\n• option. You must also create a symbolic link pointing to or to by running the following command: If you are installing Python 3.8 in any other location, then you must specify the path using theoption. You must also create a symbolic link pointing toor toby running the following command: By default, Python could be installed in any one of the following locations: The option is used to build a shared library instead of a static library.\n• \n• Run the command to compile the files:\n• Run the following command to put the compiled files in the default location or in the custom location that you specified using the option:\n• Copy the shared compiled library files (libpython3.8.so) to the directory: The option is used to prevent overwriting files.\n• Change the permissions of the libpython3.8.so files as follows: error while loading shared libraries: libpython3.8.so.1.0: cannot open shared object file: No such file or directory , then run the following command: If you see an error such as, then run the following command:\n• Change the permission of the Python 3.8 installation directory to so that Hue and its related services can leverage the binary and the site packages, as follows:"
    },
    {
        "link": "https://stackoverflow.com/questions/63090345/how-to-create-a-python-3-8-virtual-environment-in-ubuntu-16-04",
        "document": "I noticed that the deadsnakes ppa has instructions that include this:\n\nSo, I believe you need to make sure to . Then the following will work:\n\nIf you really want to use and not just the native , then you could install it, but you would first need . So the process would look something like this:\n\nI hope this helps! In case you want to read (and review/critique, as I would welcome it) I have written a summary of several Python virtual environment tools you may find helpful. Feel free to tell me how I can make it better."
    },
    {
        "link": "https://askubuntu.com/questions/1493434/how-to-install-python3-8-on-ubuntu-23-04",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://docs.python.org/3/library/venv.html",
        "document": "The module supports creating lightweight “virtual environments”, each with their own independent set of Python packages installed in their directories. A virtual environment is created on top of an existing Python installation, known as the virtual environment’s “base” Python, and may optionally be isolated from the packages in the base environment, so only those explicitly installed in the virtual environment are available.\n\nWhen used from within a virtual environment, common installation tools such as pip will install Python packages into a virtual environment without needing to be told to do so explicitly.\n\nA virtual environment is (amongst other things):\n• None Used to contain a specific Python interpreter and software libraries and binaries which are needed to support a project (library or application). These are by default isolated from software in other virtual environments and Python interpreters and libraries installed in the operating system.\n• None Contained in a directory, conventionally named or in the project directory, or under a container directory for lots of virtual environments, such as .\n• None Not checked into source control systems such as Git.\n• None Considered as disposable – it should be simple to delete and recreate it from scratch. You don’t place any project code in the environment.\n• None Not considered as movable or copyable – you just recreate the same environment in the target location.\n\nSee PEP 405 for more background on Python virtual environments.\n\nVirtual environments are created by executing the module: This creates the target directory (including parent directories as needed) and places a file in it with a key pointing to the Python installation from which the command was run. It also creates a (or on Windows) subdirectory containing a copy or symlink of the Python executable (as appropriate for the platform or arguments used at environment creation time). It also creates a subdirectory (on Windows, this is ). If an existing directory is specified, it will be re-used. Changed in version 3.5: The use of is now recommended for creating virtual environments. Deprecated since version 3.6, removed in version 3.8: pyvenv was the recommended tool for creating virtual environments for Python 3.3 and 3.4, and replaced in 3.5 by executing directly. On Windows, invoke the command as follows: The command, if run with , will show the available options: usage: venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear] [--upgrade] [--without-pip] [--prompt PROMPT] [--upgrade-deps] [--without-scm-ignore-files] ENV_DIR [ENV_DIR ...] Creates virtual Python environments in one or more target directories. positional arguments: ENV_DIR A directory to create the environment in. options: -h, --help show this help message and exit --system-site-packages Give the virtual environment access to the system site-packages dir. --symlinks Try to use symlinks rather than copies, when symlinks are not the default for the platform. --copies Try to use copies rather than symlinks, even when symlinks are the default for the platform. --clear Delete the contents of the environment directory if it already exists, before environment creation. --upgrade Upgrade the environment directory to use this version of Python, assuming Python has been upgraded in-place. --without-pip Skips installing or upgrading pip in the virtual environment (pip is bootstrapped by default) --prompt PROMPT Provides an alternative prompt prefix for this environment. --upgrade-deps Upgrade core dependencies (pip) to the latest version in PyPI --without-scm-ignore-files Skips adding SCM ignore files to the environment directory (Git is supported by default). Once an environment has been created, you may wish to activate it, e.g. by sourcing an activate script in its bin directory. Changed in version 3.4: Installs pip by default, added the and options. Changed in version 3.4: In earlier versions, if the target directory already existed, an error was raised, unless the or option was provided. Changed in version 3.9: Add option to upgrade pip + setuptools to the latest on PyPI. Changed in version 3.12: is no longer a core venv dependency. Changed in version 3.13: now creates a file for Git by default. While symlinks are supported on Windows, they are not recommended. Of particular note is that double-clicking in File Explorer will resolve the symlink eagerly and ignore the virtual environment. On Microsoft Windows, it may be required to enable the script by setting the execution policy for the user. You can do this by issuing the following PowerShell command: See About Execution Policies for more information. The created file also includes the key, set to if is run with the option, otherwise. Unless the option is given, will be invoked to bootstrap into the virtual environment. Multiple paths can be given to , in which case an identical virtual environment will be created, according to the given options, at each provided path.\n\nWhen a Python interpreter is running from a virtual environment, and point to the directories of the virtual environment, whereas and point to those of the base Python used to create the environment. It is sufficient to check to determine if the current interpreter is running from a virtual environment. A virtual environment may be “activated” using a script in its binary directory ( on POSIX; on Windows). This will prepend that directory to your , so that running python will invoke the environment’s Python interpreter and you can run installed scripts without having to use their full path. The invocation of the activation script is platform-specific ( must be replaced by the path to the directory containing the virtual environment): Added in version 3.8: PowerShell activation scripts installed under POSIX for PowerShell Core support. You don’t specifically need to activate a virtual environment, as you can just specify the full path to that environment’s Python interpreter when invoking Python. Furthermore, all scripts installed in the environment should be runnable without activating it. In order to achieve this, scripts installed into virtual environments have a “shebang” line which points to the environment’s Python interpreter, . This means that the script will run with that interpreter regardless of the value of . On Windows, “shebang” line processing is supported if you have the Python Launcher for Windows installed. Thus, double-clicking an installed script in a Windows Explorer window should run it with the correct interpreter without the environment needing to be activated or on the . When a virtual environment has been activated, the environment variable is set to the path of the environment. Since explicitly activating a virtual environment is not required to use it, cannot be relied upon to determine whether a virtual environment is being used. Because scripts installed in environments should not expect the environment to be activated, their shebang lines contain the absolute paths to their environment’s interpreters. Because of this, environments are inherently non-portable, in the general case. You should always have a simple means of recreating an environment (for example, if you have a requirements file , you can invoke using the environment’s to install all of the packages needed by the environment). If for any reason you need to move the environment to a new location, you should recreate it at the desired location and delete the one at the old location. If you move an environment because you moved a parent directory of it, you should recreate the environment in its new location. Otherwise, software installed into the environment may not work as expected. You can deactivate a virtual environment by typing in your shell. The exact mechanism is platform-specific and is an internal implementation detail (typically, a script or shell function will be used).\n\nThe high-level method described above makes use of a simple API which provides mechanisms for third-party virtual environment creators to customize environment creation according to their needs, the class. The class accepts the following keyword arguments on instantiation:\n• None system_site_packages – a boolean value indicating that the system Python site-packages should be available to the environment (defaults to ).\n• None clear – a boolean value which, if true, will delete the contents of any existing target directory, before creating the environment.\n• None symlinks – a boolean value indicating whether to attempt to symlink the Python binary rather than copying.\n• None upgrade – a boolean value which, if true, will upgrade an existing environment with the running Python - for use when that Python has been upgraded in-place (defaults to ).\n• None with_pip – a boolean value which, if true, ensures pip is installed in the virtual environment. This uses with the option.\n• None prompt – a string to be used after virtual environment is activated (defaults to which means directory name of the environment would be used). If the special string is provided, the basename of the current directory is used as the prompt.\n• None upgrade_deps – Update the base venv modules to the latest on PyPI\n• None scm_ignore_files – Create ignore files based for the specified source control managers (SCM) in the iterable. Support is defined by having a method named . The only value supported by default is via . may be used as a base class. Create a virtual environment by specifying the target directory (absolute or relative to the current directory) which is to contain the virtual environment. The method will either create the environment in the specified directory, or raise an appropriate exception. The method of the class illustrates the hooks available for subclass customization: env_dir is the target directory to create an environment in. Each of the methods , , , and can be overridden. Creates the environment directory and all necessary subdirectories that don’t already exist, and returns a context object. This context object is just a holder for attributes (such as paths) for use by the other methods. If the is created with the arg , contents of the environment directory will be cleared and then all necessary subdirectories will be recreated. The returned context object is a with the following attributes:\n• None - The location of the virtual environment. Used for in activation scripts (see ).\n• None - The name of the virtual environment. Used for in activation scripts (see ).\n• None - The prompt to be used by the activation scripts. Used for in activation scripts (see ).\n• None - The underlying Python executable used by the virtual environment. This takes into account the case where a virtual environment is created from another virtual environment.\n• None - The include path for the virtual environment.\n• None - The purelib path for the virtual environment.\n• None - The script path for the virtual environment.\n• None - The name of the script path relative to the virtual environment location. Used for in activation scripts (see ).\n• None - The name of the Python interpreter in the virtual environment. Used for in activation scripts (see ).\n• None - The name of the Python interpreter, taking into account filesystem redirections. This can be used to run Python in the virtual environment. Changed in version 3.11: The venv sysconfig installation scheme is used to construct the paths of the created directories. Changed in version 3.12: The attribute was added to the context, and the context object was documented. Creates the configuration file in the environment. Creates a copy or symlink to the Python executable in the environment. On POSIX systems, if a specific executable was used, symlinks to and will be created pointing to that executable, unless files with those names already exist. Installs activation scripts appropriate to the platform into the virtual environment. Upgrades the core venv dependency packages (currently pip) in the environment. This is done by shelling out to the executable in the environment. Changed in version 3.12: setuptools is no longer a core venv dependency. A placeholder method which can be overridden in third party implementations to pre-install packages in the virtual environment or perform other post-creation steps. This method can be called from or in subclasses to assist in installing custom scripts into the virtual environment. path is the path to a directory that should contain subdirectories , , ; each containing scripts destined for the directory in the environment. The contents of and the directory corresponding to are copied after some text replacement of placeholders:\n• None is replaced with the absolute path of the environment directory.\n• None is replaced with the environment name (final path segment of environment directory).\n• None is replaced with the prompt (the environment name surrounded by parentheses and with a following space)\n• None is replaced with the name of the bin directory (either or ).\n• None is replaced with the absolute path of the environment’s executable. The directories are allowed to exist (for when an existing environment is being upgraded). Creates a file within the virtual environment that causes the entire directory to be ignored by the Git source control manager. Changed in version 3.7.2: Windows now uses redirector scripts for instead of copying the actual binaries. In 3.7.2 only does nothing unless running from a build in the source tree. Changed in version 3.7.3: Windows copies the redirector scripts as part of instead of . This was not the case in 3.7.2. When using symlinks, the original executables will be linked. There is also a module-level convenience function: Create an with the given keyword arguments, and call its method with the env_dir argument.\n\nAn example of extending ¶ The following script shows how to extend by implementing a subclass which installs setuptools and pip into a created virtual environment: This builder installs setuptools and pip so that you can pip or easy_install other packages into the created virtual environment. :param nodist: If true, setuptools and pip are not installed into the :param nopip: If true, pip is not installed into the created :param progress: If setuptools or pip are installed, the progress of the installation can be monitored by passing a progress callable. If specified, it is called with two context indicating where the string is coming from. The context argument can have one of three values: 'main', indicating that it is called from virtualize() itself, and 'stdout' and 'stderr', which are obtained by reading lines from the output streams of a subprocess which is used to install the app. If a callable is not specified, default progress Set up any packages which need to be pre-installed into the :param context: The information for the virtual environment Read lines from a subprocess' output stream and either pass to a progress callable (if specified) or write progress information to sys.stderr. :param context: The information for the virtual environment # clear up the setuptools archive which gets downloaded :param context: The information for the virtual environment 'environments in one or ' 'A directory in which to create the ' \"Don't install setuptools or pip in the \" 'Give the virtual environment access to the ' 'Try to use symlinks rather than copies, ' 'when symlinks are not the default for ' 'Delete the contents of the ' 'directory if it already ' 'from the scripts which ' 'you cannot supply --upgrade and --clear together.' This script is also available for download online."
    },
    {
        "link": "https://docs.python.org/3/tutorial/venv.html",
        "document": "Python applications will often use packages and modules that don’t come as part of the standard library. Applications will sometimes need a specific version of a library, because the application may require that a particular bug has been fixed or the application may be written using an obsolete version of the library’s interface. This means it may not be possible for one Python installation to meet the requirements of every application. If application A needs version 1.0 of a particular module but application B needs version 2.0, then the requirements are in conflict and installing either version 1.0 or 2.0 will leave one application unable to run. The solution for this problem is to create a virtual environment, a self-contained directory tree that contains a Python installation for a particular version of Python, plus a number of additional packages. Different applications can then use different virtual environments. To resolve the earlier example of conflicting requirements, application A can have its own virtual environment with version 1.0 installed while application B has another virtual environment with version 2.0. If application B requires a library be upgraded to version 3.0, this will not affect application A’s environment.\n\nThe module used to create and manage virtual environments is called . will install the Python version from which the command was run (as reported by the option). For instance, executing the command with will install version 3.12. To create a virtual environment, decide upon a directory where you want to place it, and run the module as a script with the directory path: This will create the directory if it doesn’t exist, and also create directories inside it containing a copy of the Python interpreter and various supporting files. A common directory location for a virtual environment is . This name keeps the directory typically hidden in your shell and thus out of the way while giving it a name that explains why the directory exists. It also prevents clashing with environment variable definition files that some tooling supports. Once you’ve created a virtual environment, you may activate it. Activating the virtual environment will change your shell’s prompt to show what virtual environment you’re using, and modify the environment so that running will get you that particular version and installation of Python. For example:\n\nYou can install, upgrade, and remove packages using a program called pip. By default will install packages from the Python Package Index. You can browse the Python Package Index by going to it in your web browser. has a number of subcommands: “install”, “uninstall”, “freeze”, etc. (Consult the Installing Python Modules guide for complete documentation for .) You can install the latest version of a package by specifying a package’s name: You can also install a specific version of a package by giving the package name followed by and the version number: If you re-run this command, will notice that the requested version is already installed and do nothing. You can supply a different version number to get that version, or you can run to upgrade the package to the latest version: followed by one or more package names will remove the packages from the virtual environment. will display information about a particular package: will display all of the packages installed in the virtual environment: will produce a similar list of the installed packages, but the output uses the format that expects. A common convention is to put this list in a file: The can then be committed to version control and shipped as part of an application. Users can then install all the necessary packages with : tutorial-env $ python -m pip install -r requirements.txt Collecting .1.1.3 from -r requirements.txt line ... Collecting .9.2 from -r requirements.txt line ... Collecting .7.0 from -r requirements.txt line ... Installing collected packages: novas, numpy, requests Running setup.py install novas Successfully installed novas-3.1.1.3 numpy-1.9.2 requests-2.7.0 has many more options. Consult the Installing Python Modules guide for complete documentation for . When you’ve written a package and want to make it available on the Python Package Index, consult the Python packaging user guide."
    },
    {
        "link": "https://packaging.python.org/guides/installing-using-pip-and-virtual-environments",
        "document": "Install packages in a virtual environment using pip and venv¶\n\nThis guide discusses how to create and activate a virtual environment using the standard library’s virtual environment tool venv and install packages. The guide covers how to:\n• None Install packages into a virtual environment using the command\n\nThis guide has the prerequisite that you are using an official Python version obtained from <https://www.python.org/downloads/>. If you are using your operating system’s package manager to install Python, please ensure that Python is installed before proceeding with these steps.\n\nvenv (for Python 3) allows you to manage separate package installations for different projects. It creates a “virtual” isolated Python installation. When you switch projects, you can create a new virtual environment which is isolated from other virtual environments. You benefit from the virtual environment since packages can be installed confidently and will not interfere with another project’s environment. It is recommended to use a virtual environment when working with third party packages. To create a virtual environment, go to your project’s directory and run the following command. This will create a new virtual environment in a local folder named : The second argument is the location to create the virtual environment. Generally, you can just create this in your project and call it . will create a virtual Python installation in the folder. You should exclude your virtual environment directory from your version control system using or similar. Before you can start installing or using packages in your virtual environment you’ll need to it. Activating a virtual environment will put the virtual environment-specific and executables into your shell’s . To confirm the virtual environment is activated, check the location of your Python interpreter: While the virtual environment is active, the above command will output a filepath that includes the directory, by ending with the following: While a virtual environment is activated, pip will install packages into that specific environment. This enables you to import and use packages in your Python application. If you want to switch projects or leave your virtual environment, the environment: Closing your shell will deactivate the virtual environment. If you open a new shell window and want to use the virtual environment, reactivate it. If you want to reactivate an existing virtual environment, follow the same instructions about activating a virtual environment. There’s no need to create a new virtual environment.\n\npip is the reference Python package manager. It’s used to install and update packages into a virtual environment. The Python installers for macOS include pip. On Linux, you may have to install an additional package such as . You can make sure that pip is up-to-date by running: Afterwards, you should have the latest version of pip installed in your user site: The Python installers for Windows include pip. You can make sure that pip is up-to-date by running: Afterwards, you should have the latest version of pip:\n\nWhen your virtual environment is activated, you can install packages. Use the command to install packages. For example,let’s install the Requests library from the Python Package Index (PyPI): pip should download requests and all of its dependencies and install them: Collecting requests Using cached requests-2.18.4-py2.py3-none-any.whl Collecting chardet<3.1.0,>=3.0.2 (from requests) Using cached chardet-3.0.4-py2.py3-none-any.whl Collecting urllib3<1.23,>=1.21.1 (from requests) Using cached urllib3-1.22-py2.py3-none-any.whl Collecting certifi>=2017.4.17 (from requests) Using cached certifi-2017.7.27.1-py2.py3-none-any.whl Collecting idna<2.7,>=2.5 (from requests) Using cached idna-2.6-py2.py3-none-any.whl Installing collected packages: chardet, urllib3, certifi, idna, requests Successfully installed certifi-2017.7.27.1 chardet-3.0.4 idna-2.6 requests-2.18.4 urllib3-1.22 pip allows you to specify which version of a package to install using version specifiers. For example, to install a specific version of : To install the latest release of requests: To install pre-release versions of packages, use the flag: Some packages have optional extras. You can tell pip to install these by specifying the extra in brackets: pip can install a package directly from its source code. For example, to install the source code in the directory: Additionally, pip can install packages from source in development mode, meaning that changes to the source directory will immediately affect the installed package without needing to re-install: pip can install packages directly from their version control system. For example, you can install directly from a git repository: For more information on supported version control systems and syntax, see pip’s documentation on VCS Support. If you have a local copy of a Distribution Package’s archive (a zip, wheel, or tar file) you can install it directly with pip: If you have a directory containing archives of multiple packages, you can tell pip to look for packages there and not to use the Python Package Index (PyPI) at all: This is useful if you are installing packages on a system with limited connectivity or if you want to strictly control the origin of distribution packages. If you want to download packages from a different index than the Python Package Index (PyPI), you can use the flag: If you want to allow packages from both the Python Package Index (PyPI) and a separate index, you can use the flag instead:\n\nPip can export a list of all installed packages and their versions using the command: Which will output a list of package specifiers such as: The command is useful for creating Requirements Files that can re-create the exact versions of all packages installed in an environment."
    },
    {
        "link": "https://virtualenv.pypa.io/en/stable/user_guide.html",
        "document": "This will create a python virtual environment of the same version as virtualenv, installed into the subdirectory . The command line tool has quite a few of flags that modify the tool’s behavior, for a full list make sure to check out CLI flags. The tool works in two phases:\n• None Phase 1 discovers a python interpreter to create a virtual environment from (by default this is the same python as the one is running from, however we can change this via the option).\n• None Phase 2 creates a virtual environment at the specified destination ( ), this can be broken down into four further sub-steps:\n• None create a python that matches the target python interpreter from phase 1,\n• None install (bootstrap) seed packages (one or more of pip, setuptools, wheel) in the created virtual environment,\n• None install activation scripts into the binary directory of the virtual environment (these will allow end users to activate the virtual environment from various shells).\n• None create files that mark the virtual environment as to be ignored by version control systems (currently we support Git only, as Mercurial, Bazaar or SVN do not support ignore files in subdirectories). This step can be skipped with the option. The python in your new virtualenv is effectively isolated from the python that was used to create it.\n\nThe first thing we need to be able to create a virtual environment is a python interpreter. This will describe to the tool what type of virtual environment you would like to create, think of it as: version, architecture, implementation. being a python application has always at least one such available, the one itself is using, and as such this is the default discovered element. This means that if you install under python , virtualenv will by default create virtual environments that are also of version . Created python virtual environments are usually not self-contained. A complete python packaging is usually made up of thousands of files, so it’s not efficient to install the entire python again into a new folder. Instead virtual environments are mere shells, that contain little within themselves, and borrow most from the system python (this is what you installed, when you installed python itself). This does mean that if you upgrade your system python your virtual environments might break, so watch out. The upside of this, referring to the system python, is that creating virtual environments can be fast. Here we’ll describe the built-in mechanism (note this can be extended though by plugins). The CLI flag or allows you to specify a python specifier for what type of virtual environment you would like, the format is either:\n• None a specifier identifying the Python implementation, version, architecture in the following format: We have the following restrictions:\n• None the python implementation is all alphabetic characters ( means any implementation, and if is missing it defaults to ),\n• None the version is a dot separated version number optionally followed by for free-threading,\n• None the architecture is either or (missing means ).\n• None means any python implementation having the version ,\n• None means any python implementation having the major version ,\n• None means any python implementation having the version with free threading,\n• None means a python interpreter with the implementation and major version . Given the specifier will apply the following strategy to discover/find the system executable:\n• None If we’re on Windows look into the Windows registry, and check if we see any registered Python implementations that match the specification. This is in line with expectation laid out inside PEP-514\n• None Try to discover a matching python executable within the folders enumerated on the environment variable. In this case we’ll try to find an executable that has a name roughly similar to the specification (for exact logic, please see the implementation code). As detailed above, virtual environments usually just borrow things from the system Python, they don’t actually contain all the data from the system Python. The version of the python executable is hardcoded within the python exe itself. Therefore, if you upgrade your system Python, your virtual environment will still report the version before the upgrade, even though now other than the executable all additional content (standard library, binary libs, etc) are of the new version. Barring any major incompatibilities (rarely the case) the virtual environment will continue working, but other than the content embedded within the python executable it will behave like the upgraded version. If such a virtual environment python is specified as the target python interpreter, we will create virtual environments that match the new system Python version, not the version reported by the virtual environment.\n\nThese are what actually setup the virtual environment, usually as a reference against the system python. virtualenv at the moment has two types of virtual environments:\n• None - this delegates the creation process towards the module, as described in PEP 405. This is only available on Python interpreters having version or later, and also has the downside that virtualenv must create a process to invoke that module (unless virtualenv is installed in the system python), which can be an expensive operation (especially true on Windows).\n• None - this means is able to do the creation operation itself (by knowing exactly what files to create and what system files need to be referenced). The creator with name is an alias on the first creator that’s of this type (we provide creators for various target environments, that all differ in actual create operations, such as CPython 2 on Windows, PyPy2 on Windows, CPython3 on Posix, PyPy3 on Posix, and so on; for a full list see ).\n\nThese will install for you some seed packages (one or more of: pip, setuptools, wheel) that enables you to install additional python packages into the created virtual environment (by invoking pip). Installing setuptools and wheel is disabled by default on Python 3.12+ environments. There are two main seed mechanisms available:\n• None - this method uses the bundled pip with virtualenv to install the seed packages (note, a new child process needs to be created to do this, which can be expensive especially on Windows).\n• None - this method uses the user application data directory to create install images. These images are needed to be created only once, and subsequent virtual environments can just link/copy those images into their pure python library path (the folder). This allows all but the first virtual environment creation to be blazing fast (a mechanism takes usually 98% of the virtualenv creation time, so by creating this install image that we can just link into the virtual environments install directory we can achieve speedups of shaving the initial 1 minute and 10 seconds down to just 8 seconds in case of a copy, or seconds in case symlinks are available - this is on Windows, Linux/macOS with symlinks this can be as low as from 3+ seconds). To override the filesystem location of the seed cache, one can use the environment variable. To install a seed package via either or method virtualenv needs to acquire a wheel of the target package. These wheels may be acquired from multiple locations as follows:\n• None ships out of box with a set of embed for all three seed packages (pip, setuptools, wheel). These are packaged together with the virtualenv source files, and only change upon upgrading virtualenv. Different Python versions require different versions of these, and because virtualenv supports a wide range of Python versions, the number of embedded wheels out of box is greater than 3. Whenever newer versions of these embedded packages are released upstream project upgrades them, and does a new release. Therefore, upgrading virtualenv periodically will also upgrade the version of the seed packages.\n• None However, end users might not be able to upgrade virtualenv at the same speed as we do new releases. Therefore, a user might request to upgrade the list of embedded wheels by invoking virtualenv with the flag. If the operation is triggered in such a manual way subsequent runs of virtualenv will always use the upgraded embed wheels. The operation can trigger automatically too, as a background process upon invocation of virtualenv, if no such upgrade has been performed in the last 14 days. It will only start using automatically upgraded wheel if they have been released for more than 28 days, and the automatic upgrade finished at least an hour ago:\n• None the 28 days period should guarantee end users are not pulling in automatically releases that have known bugs within,\n• None the one hour period after the automatic upgrade finished is implemented so that continuous integration services do not start using a new embedded versions half way through. The automatic behavior might be disabled via the configuration flag/option. To acquire the release date of a package virtualenv will perform the following:\n• None save the date the version was first discovered, and wait until 28 days passed.\n• None Users can specify a set of local paths containing additional wheels by using the command line argument flag. When searching for a wheel to use virtualenv performs lookup in the following order: Bundled wheels are all three above together. If neither of the locations contain the requested wheel version or option is set will use download to load the latest version available from the index server. Custom distributions often want to use their own set of wheel versions to distribute instead of the one virtualenv releases on PyPi. The reason for this is trying to keep the system versions of those packages in sync with what virtualenv uses. In such cases they should patch the module virtualenv.seed.wheels.embed, making sure to provide the function (which returns the wheel to use given a distribution/python version). The , and variables are needed if they want to use virtualenv’s test suite to validate. Furthermore, they might want to disable the periodic update by patching the virtualenv.seed.embed.base_embed.PERIODIC_UPDATE_ON_BY_DEFAULT to , and letting the system update mechanism to handle this. Note in this case the user might still request an upgrade of the embedded wheels by invoking virtualenv via , but no longer happens automatically, and will not alter the OS provided wheels.\n\nThese are activation scripts that will mangle with your shell’s settings to ensure that commands from within the python virtual environment take priority over your system paths. For example, if invoking from your shell returned the system python’s pip before activation, once you do the activation this should refer to the virtual environments . Note, though that all we do is change priority; so, if your virtual environments / folder does not contain some executable, this will still resolve to the same executable it would have resolved before the activation. For a list of shells we provide activators see . The location of these is right alongside the Python executables: usually folder on Windows, on POSIX. They are called , plus an extension that’s specific per activator, with no extension for Bash. You can invoke them, usually by source-ing them. The source command might vary by shell - e.g. on Bash it’s (or ): The activate script prepends the virtual environment’s binary folder onto the environment variable. It’s really just convenience for doing so, since you could do the same yourself. Note that you don’t have to activate a virtual environment to use it. You can instead use the full paths to its executables, rather than relying on your shell to resolve them to your virtual environment. Activator scripts also modify your shell prompt to indicate which environment is currently active, by prepending the environment name (or the name specified by when initially creating the environment) in brackets, like . You can disable this behavior by setting the environment variable to any value. You can also get the environment name via the environment variable if you want to customize your prompt, for example. The scripts also provision a command that will allow you to undo the operation: If using Powershell, the script is subject to the execution policies on the system. By default, Windows 7 and later, the system’s execution policy is set to , meaning no scripts like the script are allowed to be executed. However, that can’t stop us from changing that slightly to allow it to be executed. You may relax the system execution policy to allow running of local scripts without verifying the code signature using the following: Since the script is generated locally for each virtualenv, it is not considered a remote script and can then be executed. A longer explanation of this can be found within Allison Kaptur’s 2013 blog post: There’s no magic: virtualenv edition explains how virtualenv uses bash and Python and and to isolate virtual environments’ paths."
    },
    {
        "link": "https://realpython.com/python-virtual-environments-a-primer",
        "document": "Creating a Python virtual environment allows you to manage dependencies separately for different projects, preventing conflicts and maintaining cleaner setups. With Python’s module, you can create isolated environments that use different versions of libraries or Python itself. This tutorial guides you through creating, activating, and managing these environments efficiently.\n\nBy the end of this tutorial, you’ll understand that:\n• You can use Python’s module to manage dependencies independently for each project.\n• You create and set up a venv in Python using the command .\n• You refer to a virtual environment by the folder name that you used when creating the venv.\n• You activate a venv on Windows with , and on macOS and Linux with .\n• You can enable a venv in VS Code by opening the Command Palette and choosing Python: Select Interpreter.\n\nWorking with virtual environments is a common and effective practice in Python development. Gaining a better understanding of how they work, why you need them, and what you can do with them will help you master your Python programming workflow.\n\nThroughout the tutorial, you can select code examples for either Windows, Linux, or macOS. Pick your platform at the top right of the relevant code blocks to get the commands that you need, and feel free to switch between them if you want to learn how to work with virtual environments on other operating systems.\n\nHow Can You Work With a Python Virtual Environment? If you just need to get a virtual environment up and running to continue working on your favorite project, then this section is for you. This tutorial uses Python’s module to create virtual environments. This module is part of Python’s standard library, and it’s been the officially recommended way to create virtual environments since Python 3.5. Note: There are other great third-party tools for creating virtual environments, such as conda and virtualenv, that you’ll learn more about later in this tutorial. Either of these tools can help you set up a virtual environment and also go beyond just that. For basic usage, is an excellent choice because it already comes packaged with your Python installation. With that in mind, you’re ready to create your first virtual environment. Any time you’re working on a Python project that uses external dependencies you’re installing with , it’s best to first create a virtual environment: This command allows the Python launcher for Windows to select an appropriate version of Python to execute. It comes bundled with the official installation and is the most convenient way to execute Python on Windows. You can bypass the launcher and run the Python executable directly using the command, but if you haven’t configured the and variables, then you might need to provide the full path: The system path shown above assumes that you installed Python 3.12 using the Windows installer provided by the Python downloads page. The path to the Python executable on your system might be different. Working with PowerShell, you can find the path using the command. Note: You don’t need to include the backslash ( ) at the end of the name of your virtual environment, but it’s a helpful reminder that you’re creating a folder. Many Linux operating systems ship with a version of Python 3. If doesn’t work, then you’ll have to first install Python and you may need to use the specific name of the executable version that you installed, for example, for Python 3.12.x. If that’s the case for you, remember to replace mentions of in the code blocks with your specific version number. Note: You don’t need to include the slash ( ) at the end of the name of your virtual environment, but it’s a helpful reminder that you’re creating a folder. Older versions of macOS come with a system installation of Python 2.7.x that you should never use to run your scripts. If you’re working on macOS < 12.3 and invoke the Python interpreter with instead of , then you might accidentally start up the outdated system Python interpreter. If running doesn’t work, then you’ll have to first install a modern version of Python. Note: You don’t need to include the slash ( ) at the end of the name of your virtual environment, but it’s a helpful reminder that you’re creating a folder. This command creates a new virtual environment named venv using Python’s built-in module. The first that you use in the command specifies the module, and the second sets the name for your virtual environment. You could name it differently, but calling it venv is a good practice for consistency. Great! Your project now has its own virtual environment. Generally, before you start to use it, you’ll activate the environment by executing a script that comes with the installation: If your attempt to run this command produces an error, then you’ll first have to loosen the execution policy. Before you run this command, make sure that you’re in the folder containing the virtual environment you just created. If you’ve named your virtual environment something other than venv, then you’ll have to use that name in the path instead of venv when you source the activation script. Note: You can also work with your virtual environment without activating it. To do this, you provide the full path to its Python interpreter when executing a command. However, you’ll likely want to activate the virtual environment after you create it to save yourself the effort of having to repeatedly type long pathnames. Once you can see the name of your virtual environment in your command prompt—in this case —then you’ll know that your virtual environment is active. Now you’re all set and ready to install your external packages! After you’ve created and activated your virtual environment, you can install any external dependencies that you need for your project: This command is the default command that you should use to install external Python packages with . Because you first created and activated the virtual environment, will install the packages in an isolated location. Note: Since you created your virtual environment using a version of Python 3, you don’t need to call or explicitly. As long as your virtual environment is active, and link to the same executable files that and do. You can now install your packages to your virtual environment. To get to this point, you created a virtual environment named and then activated it in your current shell session. As long as you don’t close your terminal, every Python package that you install will end up in this isolated environment instead of your global Python site-packages. This means that you can now work on your Python project without worrying about dependency conflicts. Once you’re done working with this virtual environment, you can deactivate it: After executing the command, your command prompt returns to normal. This change means that you’ve exited your virtual environment. If you interact with Python or now, you’ll interact with your globally configured Python environment. If you want to go back into a virtual environment that you’ve created before, then you’ll need to run the activate script for that virtual environment once again. Before you install a package, look for the name of your virtual environment within parentheses just before your command prompt. In the example above, the name of the environment is . If the name appears, then you know that your virtual environment is active and you can install your external dependencies. If you don’t see the name in your command prompt, remember to activate your Python virtual environment before installing any packages. At this point, you’ve covered the essentials of working with Python virtual environments using the module.\n\nWhy Do You Need Virtual Environments? Nearly everyone in the Python community suggests that you use virtual environments for all your projects. But why? If you want to find out why you need to set up a virtual environment in the first place, then this is the right section for you. The short answer is that Python isn’t great at dependency management. If you’re not specific, then will place all the external packages that you install in a folder called in your base Python installation. Technically, Python comes with two site-packages folders:\n• should contain only modules written in pure Python code.\n• should contain binaries that aren’t written in pure Python, for example , , or files. You can find these folders in different locations if you’re working on Fedora or RedHat Linux distributions. However, most operating systems implement Python’s site-packages setting so that both locations point to the same path, effectively creating a single site-packages folder. You can check the paths using : Most likely, both outputs will show you the same path. If both outputs are the same, then your operating system doesn’t put modules into a different folder than modules. If two different paths show up, then your operating system makes this distinction. Even if your operating system distinguishes between the two, dependency conflicts will still arise because all modules will go into a single location for modules, and the same will happen with the modules. To work with virtual environments, you don’t need to worry about the implementation details of a single site-packages folder or two separate ones. In fact, you probably won’t ever need to think about it again. You can, however, keep in mind that when someone mentions Python’s site-packages directory, they could be talking about two different directories. Several issues can come up if all of your external packages land in the same folder. Next up, you’ll learn more about these issues and other problems that virtual environments mitigate. Linux and macOS come preinstalled with a version of Python that the operating system uses for internal tasks. If you install packages to your operating system’s global Python, these packages will mix with the system-relevant packages. This mix-up could have unexpected side effects on tasks crucial to your operating system’s normal behavior. Additionally, if you update your operating system, then the packages you installed might get overwritten and lost, and you don’t want either of those headaches to happen! One of your projects might require a different version of an external library compared to another project. If you only have one place to install packages, then you won’t be able to work with two different versions of the same library. This is a common reason why it’s recommended to use a Python virtual environment. To better understand why this is so important, imagine you’re building Django websites for two different clients:\n• One client is comfortable with their existing web app, which you initially built using Django 2.2.26, and this client refuses to update their project to a modern Django version.\n• Another client wants you to include async functionality in their website, which is only available starting with Django 3.1. You’ll want to use a modern Django version for this client! If you install Django globally, you can only have one version installed: If you install two different versions of the same package into your global Python environment, the second installation overwrites the first one. For the same reason, having a single virtual environment for both clients won’t work either. You can’t have two different versions of the same package in a single Python environment. Looks like you won’t be able to work on one of the two projects with this setup! However, if you create a virtual environment for each of your clients’ projects, then you can install a different version of Django into each of them: If you now activate either of the two virtual environments, then you’ll notice that it still holds its own specific version of Django. The two environments also have different dependencies, and each only contains the dependencies necessary for that version of Django. With this setup, you can activate one environment when you work on one project and another when you work the other project. Now you can keep any number of clients happy at the same time! If all your packages live in one location, then it’ll be difficult to only pin dependencies that are relevant for a single project. If you’ve worked with Python for a while, then your global Python environment might already include all sorts of third-party packages. If that’s not the case, then pat yourself on the back! You’ve probably installed a new version of Python recently, or you already know how to handle virtual environments to avoid system pollution. To clarify what reproducibility issues you can encounter when sharing a Python environment across multiple projects, you’ll look at an example next. Imagine you’ve worked on two independent projects over the past month: Unaware of virtual environments, you installed all necessary packages into your global Python environment: Your Flask app has turned out to be quite helpful, so other developers want to work on it as well. They need to reproduce the environment that you used for working on it. You want to go ahead and pin your dependencies so that you can share your project online: Which of these packages are relevant to your Flask app, and which ones are here because of your web scraping project? It’s hard to tell when all external dependencies are in a single bucket. With a single environment like this, you’d have to manually go through the dependencies and know which are necessary for your project and which aren’t. At best, this approach is tedious, but even more so, it’s error-prone. If you use a separate virtual environment for each of your projects, then it’ll be more straightforward to read the project requirements from your pinned dependencies. That means you can more easily share your success when you develop a great app, making it possible for others to collaborate with you! Finally, you may need administrator privileges on a computer to install packages into the host Python’s site-packages directory. In a corporate work environment, you most likely won’t have that level of access to the machine that you’re working on. If you use virtual environments, then you create a new installation location within the scope of your user privileges, which allows you to install and work with external packages. Whether you’re coding as a hobby on your own machine, developing websites for clients, or working in a corporate environment, using a virtual environment will save you lots of grief in the long run.\n\nHow Can You Customize a Virtual Environment? If you’re confident about what a virtual environment is and you want to customize it for a specific use case, then you’re in the right place. In this section, you’ll learn about the optional arguments that you can pass when creating a virtual environment with , and how these customizations can help you get precisely the virtual environment you need. When you create your virtual environment, you can change the folder name that contains it by passing a name other than venv. In fact, you’ll often see different names in different projects. Some of the names commonly used are: In practice, you could name the folder you create for your virtual environment anything you want. Note: Naming your virtual environment folder venv is just a convention. Sticking to this convention can help you reliably exclude your virtual environment from version control using a file. Whatever name you choose will show up in your command prompt after you activate the virtual environment: If you give your virtual environment folder an alternate name, you’ll need to include that name when you want to run your activation script, as shown in the code example above. If you want the convenience of seeing a different command prompt, but want to keep the folder name descriptive so that you’ll know it contains a virtual environment, then you can pass your desired command prompt name to : With the optional argument, you can set the command prompt that’ll show up when your virtual environment is active to a descriptive string without changing the name of your virtual environment’s folder. Note: There’s even a special case for when you want to use the name of your current working directory as the command prompt of your virtual environment: When you specify a dot ( ) as the value for , then Python will use the output of as the command prompt for your virtual environment. In the code snippets above, you can see that you’re still calling the folder , which means that you’ll be able to access the activate script with the familiar path. At the same time, the command prompt that displays after activation will be whatever you passed to . At any given time, you might want to delete and re-create one of your virtual environments. If you do this often, then you might be glad to know that you can add the argument to delete the contents of an existing environment before Python creates the new one. Before you try this out, it’s helpful to see that running the command to create a new virtual environment without this argument won’t overwrite an existing virtual environment with the same name: In this code example, you first created a virtual environment called venv, then used the environment-internal executable to install into the site-packages directory of your virtual environment. You then used to confirm that it was installed, together with its dependencies. Note: You ran these commands without activating the virtual environment. Instead, you used the full path to the internal executable to install into your virtual environment. Alternatively, you could’ve activated the virtual environment. In the highlighted line, you attempted to create another virtual environment using the same name, venv. You might expect to notify you that there’s an existing virtual environment on the same path, but it doesn’t. You might also expect to automatically delete the existing virtual environment with the same name and replace it with a new one, but it doesn’t do that either. Instead, when finds an existing virtual environment with the same name on the path you provided, it doesn’t do anything—and again, it doesn’t communicate this to you. If you list the installed packages after running the virtual environment creation command a second time, then you’ll notice that and its dependencies still show up. This might not be what you want. Rather than navigate to your virtual environment folder and delete it, you can explicitly overwrite an existing virtual environment using : Using the same example as before, you added the optional argument when you ran the creation command a second time. You then confirmed that Python automatically discarded the existing virtual environment with the same name and created a new default virtual environment without the previously installed packages. If one virtual environment isn’t enough, then you can create multiple separate virtual environments in one go by passing more than one path to the command: When you run this command, you create two separate virtual environments in two different locations. These two folders are independent virtual environment folders. Passing more than one path, therefore, just saves you the effort of typing the creation command more than once. In the example shown above, you might notice that the first argument, , represents a relative path. Conversely, the second argument uses an absolute path to point to a new folder location. Either option works when you create a virtual environment. You can even mix and match, as you did here. Note: The most common command for creating a virtual environment, , uses a relative path from your current location in your shell and creates a new folder named venv in that directory. You don’t have to do this. Instead, you could provide an absolute path that points anywhere on your system. If any of your path directories don’t yet exist, will create them for you. You’re not limited to creating two virtual environments at once. You can pass as many valid paths as you want, separated by a whitespace character. Python will diligently set up a virtual environment at each location, and even create any missing folders along the way. When you create a virtual environment using with its default settings and then install an external package using , you may encounter a message telling you that your installation of is outdated: WARNING: You are using pip version 23.2.4; however, version 24.2 is available. You should consider upgrading via the 'C:\\Users\\Name\\path\\to\\venv\\Scripts\\python.exe -m pip install --upgrade pip' command. WARNING: You are using pip version 23.2.4; however, version 24.2 is available. You should consider upgrading via the '/path/to/venv/python -m pip install --upgrade pip' command. It can be frustrating to create something new only to see that it’s already outdated! Why does this happen? The installation of that you’ll receive when creating a virtual environment with the default configuration of may be outdated because uses to bootstrap into your virtual environment. intentionally doesn’t connect to the Internet, but instead uses a wheel that comes bundled with each new CPython release. Therefore, the bundled has a different update cycle than the independent project. Once you install an external package using , the program connects to PyPI and also identifies if itself is outdated. If is outdated, then you’ll receive the warning shown above. While using the bootstrapped version of can be helpful in some cases, you might want to have the latest to avoid potential security issues or bugs that might still be around in an older version. For an existing virtual environment, you can follow the instructions that prints to your terminal and use to upgrade itself. If you want to save the effort of doing this manually, you can specify that you want to contact PyPI and update itself right after installation by passing the argument: Suppose you use the optional argument when creating your virtual environment. In that case, it’ll automatically poll PyPI for the newest version of and install it if the local wheel isn’t up-to-date. Gone is that pesky warning message, and you can rest assured that you’re using the most recent version of . You might wonder why it takes a while to set up a Python virtual environment when all it does is create a folder structure. The reason for the time delay is mainly the installation of . itself is quite large and blows up the size of your virtual environment from a few kilobytes to many megabytes! In most use cases, you’ll want to have installed in your virtual environment because you’ll probably use it to install external packages from PyPI. However, if you don’t need for whatever reason, then you can use to create a virtual environment without it: Your virtual environment still does everything that qualifies it as a virtual environment by providing lightweight isolation with a separate Python executable. Note: Even though you didn’t install , running might still seem to work. Don’t do this, though, because running the command won’t give you what you’re looking for. You’d be using a executable from somewhere else on your system, and your package will land in the site-packages folder of whichever Python installation is associated with that executable. To work with a virtual environment that doesn’t have installed, you can manually install packages into your site-packages directory or place your ZIP files there and then import them using Python ZIP imports. In some situations, you might want to keep access to your base Python’s site-packages directory instead of severing that tie. For example, you might have already set up your favorite deep learning framework, such as PyTorch or TensorFlow, including CUDA support, in your global Python environment. Both frameworks are large and can be tricky to set up correctly. You still want to keep your projects in separate environments, but installing these libraries into every environment can take a couple of minutes each. For quick iteration, you want to have access to the existing installation without needing to redo it for every virtual environment that you create. You can access all modules that you’ve installed into your base Python’s site-packages directory by adding the flag when creating your virtual environment. Note: If you install any additional external packages, then Python will put them into the site-packages directory of your virtual environment. Keep in mind that you only get read access to the system site-packages directory. Create a new virtual environment while passing this argument. You’ll see that in addition to your local site-packages directory, the path to your base Python’s site-packages directory will stick around in . To test this, you can create and activate a new virtual environment using the argument: Once again, you’ve created a new virtual environment named , but this time you passed the argument. Adding this optional argument resulted in a different setting in your file: Instead of displaying the default value of , the configuration is now set to . This change means that you’ll see an additional entry to , which allows the Python interpreter in your virtual environment to also access the system site-packages directory. Make sure your virtual environment is active, then start the Python interpreter to check the path variables: The highlighted lines show the additional paths present in a virtual environment when you create it using . They point to the site-packages directories of your base Python installation and give the interpreter inside your virtual environment access to these packages. Whether you receive a copy or a symlink of your Python binaries depends on the operating system that you’re working with:\n• Windows may create either a symlink or a copy, but some versions don’t support symlinks. Creating symlinks might require you to have administrator privileges.\n• Linux distributions may create either a symlink or a copy, but often opt for symlinks over copies.\n• macOS always creates a copy of the binaries. Symlinking is preferable where possible because, in the case of an upgrade to the underlying Python installation, a Python executable copied in a venv might become out-of-sync with the installed standard library and require manual upgrade. (Source) While it can be helpful to symlink the executables so that they automatically stay in sync even if you upgrade your base Python installation, the added flimsiness of this approach may outweigh its benefit. For example, when you double-click in Windows, the operating system will eagerly resolve the symlink and ignore your virtual environment. Most likely, you won’t ever have to touch these arguments, but if you have a good reason for attempting to force either symlinks or copies over your operating system’s default, then you can do so:\n• will attempt to create symlinks instead of copies. This option won’t have any effect on macOS builds.\n• will attempt to create copies of your Python binaries instead of linking them to the base Python installation’s executables. You can pass either one of these optional arguments when you create your virtual environment. Upgrade Your Python to Match the System Python If you’ve built your virtual environment using copies rather than symlinks and then later updated your base Python version on your operating system, you might run into a version mismatch with standard-library modules. The module offers a solution to this. The optional argument keeps your site-packages directory intact while updating the binary files to the new versions on your system: If you run this command and you’ve updated your Python version since you initially created the virtual environment, then you’ll keep your installed libraries, but will update the executables for and Python. In this section, you’ve learned that you can apply a lot of customization to the virtual environments that you build with the module. These adaptations can be pure convenience updates, such as naming your command prompt differently from your environment folder, overwriting existing environments, or creating multiple environments with a single command. Other customizations create different functionality in your virtual environments by, for example, skipping the installation of and its dependencies, or linking back to the base Python’s site-packages folder. But what if you want to do even more than that? In the next section, you’ll explore alternatives to the built-in module.\n\nWhat Other Popular Options Exist, Aside From ? The module is a great way to work with virtual environments. One of its main advantages is that comes preinstalled with Python starting from version 3.3. But it isn’t the only option you have. You can use other tools to create and handle virtual environments in Python. The Python ecosystem sports a wide range of third-party tools for dependency management, packaging, and improving your workflows. Many of these tools allow you to create and manage virtual environments. Note: If you’re interested in learning more about the available tools that can help you create and manage your virtual environments and more, then check out the section on using third-party tools. In this section, you’ll learn about two popular tools that people in the Python community frequently use with the primary intention of creating and handling isolated Python environments. These tools have very different scopes but are both commonly used for the same purpose as the module:\n• Virtualenv is a superset of and provides the basis for its implementation. It’s a powerful, extendable tool for creating isolated Python environments.\n• Conda offers package, dependency, and environment management for Python and other languages. What conda offers goes way beyond virtual environments, but it’s popular and intuitive enough that some people use it primarily for that. These two projects have some advantages over , but they don’t come with your standard Python installation, so you’ll have to install them separately. Virtualenv is a tool that was specifically made for creating isolated Python environments. It’s been a long-time favorite within the Python community and precedes the built-in module. The package is a superset of , which allows you to do everything that you can do using , and more. Virtualenv allows you to:\n• Discover installed versions of Python without needing to provide the absolute path\n• Extend the functionality of the tool yourself Any of these additional functionalities can come in handy when you’re working on your Python projects. You might even want to save a blueprint of your virtualenv in code together with your project to aid reproducibility. Virtualenv has a rich programmatic API that allows you to describe virtual environments without creating them. After installing on your system, you can create and activate a new virtual environment similarly to how you do it using : To avoid running into issues with the execution policy when activating your virtual environment, you first changed the execution policy for the current PowerShell session using . Like with , you can pass a relative or an absolute path and name your virtual environment. Before working in your virtualenv, you’ll usually activate it using one of the provided scripts. Note: You might notice that virtualenv creates the isolated environment much more quickly than the built-in module, which is possible because the tool caches platform-specific application data which it can quickly read from. There are two main user advantages with virtualenv over :\n• Updates: Thanks to virtualenv’s embedded wheels, you’ll receive up-to-date and without needing to connect to the Internet right when you first set up the virtual environment. If you need to work with legacy versions of Python 2.x, then virtualenv can also be helpful for that. It supports building Python virtual environments using Python 2 executables, which isn’t possible using . Note: If you want to try working with virtualenv but you don’t have the permissions to install it, you can use Python’s module to circumvent that. Follow the instructions in the docs on installing virtualenv via zipapp. If you’re just getting started with virtual environments in Python, then you may want to stick with the built-in module. However, if you’ve used for a while and you’re bumping into the tool’s limitations, then it’s a great idea to get started using virtualenv. Conda gives you an alternative package and environment management approach that can replace and in your workflow. While the tool is primarily associated with the data science community and the Anaconda Python distribution, its potential use cases include package, dependency, and environment management for any language. While you can also use conda to set up an isolated environment to install Python packages, this is only one feature of the tool: pip installs python packages within an environment; conda installs any package within conda environments. (Source) As you may gather from this quote, conda accomplishes the isolation of Python and installed third-party packages differently than the module and virtualenv project. Note: A complete discussion of the conda package and environment manager is outside the scope of this tutorial. You’ll gloss over the differences and look at conda specifically for creating and working with a virtual environment. You can set up conda on your system using the Miniconda installer, which brings along the minimal requirements for running on your system. In its default configuration, conda get its packages from repo.anaconda.com instead of the Python Package Index (PyPI). This alternative package index is maintained by the Anaconda project and is similar to PyPI, but not identical. Because conda isn’t limited to Python packages, you’ll find other, often data-science-related packages on conda’s package index written in different languages. Conversely, there are Python packages available on PyPI that you can’t install using conda because they aren’t present in that package repository. If you need such a package in your conda environment, then you can instead install it there using . If you’re working in the data science space and with Python alongside other data science projects, then conda is an excellent choice that works across platforms and languages. After installing Anaconda or Miniconda, you can create a conda environment: # To activate this environment, use # To deactivate an active environment, use Suppose your standard PowerShell session doesn’t recognize the command after successfully installing Anaconda. In that case, you can look for the Anaconda PowerShell Prompt in your programs and work with that one instead. conda create -n <venv-name> To activate this environment, use $ conda activate <venv-name> To deactivate an active environment, use $ conda deactivate conda create -n <venv-name> To activate this environment, use $ conda activate <venv-name> To deactivate an active environment, use $ conda deactivate This command creates a new conda environment in a central location on your computer. Note: Because all conda environments live in the same location, all environment names need to be unique. Therefore, it’s best if you give them descriptive names instead of calling any conda environment . To work within your new conda environment, you’ll need to activate it: After activating the environment, you can install packages from conda’s package repository into that environment: The command installs a third-party package from conda’s package repository into your active conda environment. When you’re done working in the environment, you’ll have to deactivate it: You might notice that the general idea is similar to working with virtual environments that you’ve created using . The commands differ slightly, but you’ll receive the same benefits of working within an isolated environment that you can delete and re-create when necessary. If you primarily work on data science projects and already work with Anaconda, then you might never have to work with . In that case, you can read more about conda environments and how to work with them effectively on your machine. If you only have pure-Python dependencies and you haven’t worked with Anaconda before, then you’re better off using the more lightweight module directly, or giving virtualenv a try."
    }
]