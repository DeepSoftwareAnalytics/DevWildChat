[
    {
        "link": "https://mongodb.com/docs/drivers/node/current/fundamentals/transactions",
        "document": "In this guide, you can learn how to use the Node.js driver to perform transactions. Transactions allow you to run a series of operations that do not change any data until the entire transaction is committed. If any operation in the transaction fails, the driver ends the transaction and discards all data changes before they ever become visible. This feature is called atomicity. Since all write operations on a single document in MongoDB are atomic, you might want to use transactions to make an atomic change that modifies multiple documents. This situation requires a multi-document transaction. Multi-document transactions are ACID compliant because MongoDB guarantees that the data involved in your transaction operations remains consistent, even if the driver encounters unexpected errors. To learn more about ACID compliance and transactions, see our article on ACID transactions . To execute a multi-document transaction, you must be connected to a deployment running MongoDB Server version 4.0 or later. For a detailed list of limitations, see the Transactions and Operations section in the Server manual. In MongoDB, multi-document transactions run within a client session. A client session is a grouping of related read or write operations that you want to execute sequentially. We recommend you reuse your client for multiple sessions and transactions instead of instantiating a new client each time. When combined with read and write concerns, the driver guarantees causal consistency between the operations. To learn more, see Client Sessions and Causal Consistency Guarantees in the Server manual. Learn more about how to use the driver to perform multi-document transactions in the following sections of this guide:\n\nThe driver provides two APIs for performing transactions, the Core API and the Convenient Transaction API. The Core API is a framework that enables you to create, commit, and end transactions. When using this API, you must explicitly perform the following actions:\n• None Create and end the session in which you run the transaction. The Convenient Transaction API is a framework that enables you to perform transactions without being responsible for committing or ending them. This API automatically incorporates error-handling logic to retry operations when the server raises certain error types. To learn more about this behavior, see the Transaction Errors section of this guide. When you connect to MongoDB Server version 4.2 or earlier, you can perform write operations in a transaction only on collections that already exist. When you connect to MongoDB Server version 4.4 and later, the server automatically creates collections as necessary when you perform write operations in a transaction. To learn more about this behavior, see Create Collections and Indexes in a Transaction in the Server manual. The Core API provides the following methods to implement transactions:\n• None commitTransaction() : commits the active transaction in the session that it was created in\n• None abortTransaction() : ends the active transaction in the session that it was created in You must perform the following steps when using this API:\n• None Pass the session instance to each operation that you want to run in that session.\n• None Implement a block in which you identify server transaction errors and implement error-handling logic. The following code demonstrates how to perform a transaction by using the Core API: . ( \"An error occurred during the transaction:\" + error) ; Use a Session with the Client That Started It The driver throws an error if you provide a session from one instance to a different client instance. For example, the following code generates an error because it creates a instance from the client, but provides this session to the client for a write operation: To see a fully runnable example that uses this API, see the Use the Core API usage example. The Convenient Transaction API provides the following methods to implement transactions:\n• None withSession() : Runs the callback passed to it within a session. The API handles the creation and termination of the session automatically.\n• None withTransaction() : Runs the callback passed to it within a transaction and calls the method when the callback returns. These methods return the value that the callback returns. For example, if a callback you pass to the method returns the document , then the method also returns that document. To avoid infinite looping errors, ensure that the callback you pass to the method catches any errors that it raises. When you use the Convenient Transaction API, you can propagate return values from the callback as the return values of the and methods to work with them elsewhere in your code. You must perform the following steps when using this API:\n• None Pass the session instance to each operation that you want to run in that session.\n• None Implement the async syntax for each operation in the session.\n• None Avoid parallelism, such as calling the method. Using sessions in parallel usually leads to server errors. The following code demonstrates how to perform a transaction by using the Convenient Transaction API: To see a fully runnable example that uses this API, see the Use the Convenient Transaction API usage example. The Node.js driver does not support running parallel operations within a single transaction.\n\nYou can pass a instance to the and methods to configure how the driver performs a transaction. When you specify an option, it overrides the value of the option that you might have set on your instance. The following table includes options that you can specify in a instance: To learn more, see in the Server manual. Specifies the write operation level of acknowledgment required from a replica set. To learn more, see in the Server manual. Specifies how to route read operations to members of a replica set. To learn more, see in the Server manual. Specifies the length of time that a commit action on a transaction can run, in milliseconds. For a full list of options, see the API documentation for TransactionOptions . The transaction inherits settings from your instance unless you specify them in your transaction options. The following code shows how to define and pass transaction options to the method:\n\nIf you are using the Core API to perform a transaction, you must incorporate error-handling logic into your application for the following errors:\n• None : Raised if a write operation errors before the driver commits the transaction. To learn more about this error, see the TransientTransactionError description on the Driver API page in the Server manual.\n• None : Raised if the commit operation encounters an error. To learn more about this error, see the UnknownTransactionCommitResult description on the Driver API page in the Server manual. The Convenient Transaction API incorporates retry logic for these error types, so the driver retries the transaction until there is a successful commit."
    },
    {
        "link": "https://mongodb.com/docs/drivers/node/current",
        "document": "Welcome to the documentation site for the official MongoDB Node.js driver. You can add the driver to your application to work with MongoDB in JavaScript or TypeScript. For more information about downloading and installing the Node.js driver, see Download and Install in the Quick Start guide. You can connect using the Node.js driver for deployments hosted in the following environments:\n• None MongoDB Atlas: The fully managed service for MongoDB deployments in the cloud\n• None MongoDB Community: The source-available, free-to-use, and self-managed version of MongoDB\n\nFor a list of new features and changes in each version, see the What's New section.\n\nFor solutions to issues you might encounter when using the driver to connect to a MongoDB deployment, see the Connection Troubleshooting section.\n\nVisit the Developer Hub and MongoDB University to learn more about the Node.js driver. The Developer Hub provides tutorials and social engagement for developers. To learn how to use MongoDB features with the Node.js driver, see the How To's and Articles page . To ask questions and engage in discussions with fellow developers using the Node.js driver, see the Developer Community forums . MongoDB University provides free courses to teach everyone how to use MongoDB. Take the Following Free Online Courses Taught by MongoDB Instructors Learn the essentials of Node.js application development with MongoDB. Gain a comprehensive understanding of Node.js application development, complex operations, interactions with MongoDB Atlas datasets, and more."
    },
    {
        "link": "https://quora.com/How-do-you-use-database-transactions-with-MongoDB-and-Node-js",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/how-to-use-transactions-in-mongodb",
        "document": "The author selected the Open Internet/Free Speech Fund to receive a donation as part of the Write for DOnations program.\n\nA transaction is a sequence of database operations that will only succeed if every operation within the transaction has been executed correctly. Transactions have been an important feature of relational databases for many years, but have been mostly absent from document-oriented databases until recently. The nature of document-oriented databases — where a single document can be a robust, nested structure, containing embedded documents and arrays rather instead of only simple values — streamlines storing related data within a single document. As such, modifying multiple documents as part of a single logical operation is often unnecessary, limiting the need for transactions in many applications.\n\nThere are, however, applications for which accessing and modifying multiple documents in a single operation with guaranteed integrity is required even with document-oriented databases. MongoDB introduced multi-document ACID transactions in version 4.0 of the database engine in order to meet the needs of such use cases. In this article, you’ll explore what transactions are, the ACID properties of a transaction, and how to use transactions in MongoDB.\n\nBecause of the way they’re implemented in MongoDB, transactions can only be performed on MongoDB instances that are running as part of a larger cluster. This could either be a sharded database cluster or a replica set. If you have an existing sharded MongoDB cluster or replica set running that you can use for testing purposes, then you can go on to the next section to learn about ACID transactions.\n\nHowever, setting up a proper, functional replica set or a sharded MongoDB cluster requires you to have at least three running MongoDB instances, ideally running on separate servers. Additionally, this guide’s examples all involve working with a single node running as a member of a replica set. Rather than having you go through the work of provisioning multiple servers and configuring MongoDB on each of them only for you to use just one of them in this guide, you can convert a standalone MongoDB instance into a single-node replica set that you can use to practice running transactions.\n\nThis guide’s first step outlines how to do this, so in order to complete this tutorial, you will only need the following:\n• One server with a regular, non-root user with privileges and a firewall configured with UFW. This tutorial was validated using a server running Ubuntu 20.04, and you can prepare your server by following this initial server setup tutorial for Ubuntu 20.04.\n• MongoDB installed on your server. To set this up, follow our tutorial on How to Install MongoDB on Ubuntu 20.04.\n\nA transaction is a set of database operations (such as reads and writes) that are executed in a sequential order and in an all-or-nothing manner. This means that for the results of running these operations to be saved within the database and visible outside the transaction to other database clients, all of the individual operations must succeed. If any of the operations fail to execute correctly, the transaction aborts and every change made from the beginning of the transaction will be undone. The database will then be restored to its previous state as if the operations never happened.\n\nTo illustrate why transactions are crucial to database systems, imagine you work at a bank and you need to transfer money from Customer A to Customer B. This means you have to decrease the balance for the source account and increase the balance for the destination account at the same time.\n\nIf either of the two operations fails individually and the other goes through, the banking records would become inconsistent. Either Customer B would get the money out of nowhere (if the balance of Customer A’s account was not decreased), or Customer A would lose money for no reason (if their balance was decreased, but Customer B wasn’t credited). To make sure the results are always consistent, both operations must be successful, or both must fail. Transactions are especially handy in situations like this, ensuring an all-or-nothing execution.\n\nThe four properties of database transactions that ensure such complex operations can be safely and reliably performed, guaranteeing data validity despite errors or interruptions, are abbreviated as ACID: atomicity, consistency, isolation, and durability. If the database system can guarantee all four of them for a set of operations grouped in a transaction, it can also guarantee the database will be left in a valid state even in the event of unexpected errors in execution.\n• Atomicity means that all the actions in a transaction are treated as a single unit of work, and either all or none will be executed with nothing in between. The previous example of money debited from one account to be added to another highlights the atomicity principle. Note that, in MongoDB, updates within a single document (no matter how complex and nested the document structure is) are always atomic, even without using transactions. It’s only in cases when you’re dealing with more than one document that transactions provide stronger atomicity guarantees.\n• Consistency means that any changes made to a database must adhere to the database’s existing constraints, otherwise the whole transaction will fail. If, for example, one of the operations violated a unique index or a schema validation rule, MongoDB would abort the transaction.\n• Isolation is the idea that separate, concurrently running transactions are isolated from one another, and neither will affect the other’s outcomes. If two transactions are executed simultaneously, the isolation rule guarantees the end result will be the same as if they were executed one after another.\n• Durability guarantees that as soon as the transaction succeeds, the client can be sure the data has been properly persisted. Even something like hardware failure or a power interruption won’t void the transaction.\n\nTransactions in MongoDB comply with these ACID principles and can be reliably used in cases when it’s necessary to alter multiple documents in a single go.\n\nAs mentioned previously, because of the way they’re implemented in MongoDB, transactions can only be performed on databases that are running as part of a larger cluster. This cluster can either be a sharded database cluster or a replica set.\n\nIf you’ve already configured a replica set or sharded cluster that you can use to practice running transactions, you can skip this step and use that cluster in Step 2. If not, this step outlines how to convert a standalone MongoDB instance into a single-node replica set.\n\nTo convert your standalone MongoDB instance into a replica set, begin by opening up the MongoDB configuration file using your preferred text editor. This example uses :\n\nFind the section that reads towards the bottom of this file:\n\nUncomment this line by removing the pound sign ( ). Then add a directive below this line followed by a name that MongoDB will use to identify the replica set:\n\nIn this example, the directive’s value is . You can provide whatever name you’d like here, but it can be helpful to use a descriptive name.\n\nThose are the only changes you need to make to this file, so you can save and close it. If you used to edit the file, you can do so by pressing , , and then .\n\nFollowing that, restart the service to implement the new configuration changes:\n\nAfter restarting the service, open up the MongoDB shell to connect to the MongoDB instance running on your server:\n\nFrom the MongoDB prompt, run the following method. This will turn your standalone MongoDB instance into a single-node replica set that you can use for testing:\n\nIf this method returns in its output, it means the replica set was started successfully:\n\nAssuming this is the case, your MongoDB shell prompt will change to indicate that the instance the shell is connected to is now a member of the replica set:\n\nNote that this example prompt reflects that this MongoDB instance is a secondary member of the replica set. This is to be expected, as there is usually a gap between the time when a replica set is initiated and the time when one of its members is promoted to become the primary member.\n\nIf you were to run a command or even just press after waiting a few moments, the prompt will update to reflect that you’re connected to the replica set’s primary member:\n\nYour standalone MongoDB instance is now running as a single-node replica set that you can use for testing transactions. Keep the prompt open for now, as you’ll use the MongoDB shell in the next step to create an example collection and insert some sample data into it.\n\nIn order to explain how transactions in MongoDB work and how to use them, this step outlines how to open the MongoDB shell to connect to your replica set’s primary node. It also explains how to create a sample collection and insert a few sample documents into it. This guide will use this sample data to illustrate how to initiate and execute transactions.\n\nIf you skipped the previous step because you had an existing sharded MongoDB cluster or replica set, connect to any node that you can write data to:\n\nTo understand the behavior of transactions, you’ll need a set of documents to work with. This guide will use a collection documents representing a few of the most populated cities in the world. As an example, the following sample document represents Tokyo:\n\nThis document contains the following information:\n• : the country where the city is located.\n• : the continent where the city is located.\n\nRun the following method, which will simultaneously create a collection named and insert three documents into it:\n\nThe output will contain a list of object identifiers assigned to the newly inserted objects:\n\nYou can verify that the documents were properly inserted by running the method with no arguments, which will retrieve every document in the collection:\n\nLastly, use the method to create an index that will ensure every document in the collection has a unique field value. This will be helpful for testing consistency requirements when running transactions later on in this guide:\n\nMongoDB will confirm that the index was created successfully:\n\nWith that, you have successfully created the list of example documents of the most populated cities that will serve as the test data for testing the use of transactions. Next, you’ll learn how to set up a transaction.\n\nThis step outlines how to create a transaction consisting of a single operation that will insert a new document into the sample collection from the previous step.\n\nBegin by opening two separate MongoDB shell sessions. One will be used to execute commands in the transaction, and the other will allow you to check what data is available to other users of the database outside the transaction at different points in time.\n\nAt this point, both shell sessions should list the three cities you inserted before if you query the collection. Verify that by issuing a query in both shell sessions, starting with the first one:\n\nThen run the same query in your second shell session:\n\nAfter confirming that this query’s output is consistent in both sessions, try to insert a new document into the collection. However, instead of using an method, you’ll insert this document as part of a transaction.\n\nTypically, transactions aren’t written and executed from the MongoDB Shell, as this guide outlines. More often than not, transactions are instead used by external applications. To ensure that any transactions it runs remain atomic, consistent, isolated, and durable, the application must start a session.\n\nIn MongoDB, a session is a database object managed by an application through the appropriate MongoDB driver. This allows the driver to associate a sequence of database statements with one another, meaning they will have a shared context and can have additional configurations applied to them as a group, like enabling the use of transactions. What happens inside a single session might not be immediately visible to the outside world, as this step will illustrate.\n\nRather than setting up an external application, this tutorial outlines the concepts and individual steps needed to work with a transaction directly in the MongoDB shell with a simplified JavaScript syntax.\n\nEven though this guide outlines how to use transactions through the MongoDB shell rather than in an application, it’s still necessary to start a session in order to execute a set of operations as a transaction. You can start a session with the following command:\n\nThis command creates a variable that will store the session object. Each time you refer to the object in the following examples, you’re referring to the session you’ve just started.\n\nWith this session object available, you can start the transaction by calling the method as follows:\n\nNotice that the method is called on the variable and not , as the commands in the previous step did. The method accepts two options: and . The setting can accept a few options, but this example only includes the option, which requests that the cluster acknowledges when the transaction’s write operations have been accepted on a specified number of nodes in the cluster. Instead of a single number, this example specifies that the transaction will only be considered to have been saved successfully when a of nodes acknowledge the write operation.\n\nSay that you start a transaction, but after you doing so another user adds a document to the collection you’re using on another node in the cluster. Should your transaction read this new data or only the data written on the node on which the transaction was started? Setting the level allows you to specify which data the transaction should read when you commit the transaction. Setting it to means that the transaction will read a snapshot of data that has been committed by a majority of nodes in the cluster.\n\nNote that setting the transaction’s level requires you to set the to . These values for read and write concerns are safe defaults to follow in most cases. They provide reliable guarantees of data persistence unless you have very particular requirements on performance and acknowledging writes across the replica set. You can learn more about different write and read concerns that MongoDB provides for use in transactions in the official MongoDB documentation.\n\nThe method won’t return any output if it executed correctly. If this method was successful, you’ll be inside a running transaction and you can begin executing statements that will become part of the transaction.\n\nWhile you’re working within the running transaction, any statements you run as part of the transaction must be within the shared context of the session represented by the variable you created previously.\n\nTo a similar end, when working in a running transaction it can be helpful to create another variable that represents the collection you want to work with in the context of the session. The following operation will create a variable called by returning the collection from the database. However, instead of pulling this directly from the object it references the object to ensure that this variable represents the collection in the context of the running session:\n\nFrom now until you commit the transaction, you can use the variable just like you would use to refer to the collection. This newly assigned variable will guarantee that you’re running statements in a session and, likewise, in the started transaction.\n\nTest this out by checking that the object can be used to find documents from the collection:\n\nThe command will return the same list of documents as before since the data has not yet been altered:\n\nFollowing that, insert a new document representing New York City into the collection as part of the running transaction. Use the method, but execute it on the variable to make sure it will be run in the session:\n\nIf you were to execute again, you’ll notice that the newly inserted document is immediately visible in the same session:\n\nHowever, if you run in your second MongoDB shell instance, the document representing New York will be absent:\n\nThe reason for this is that the insert statement has been executed inside the running transaction, but the transaction itself has not been committed yet. At this point, the transaction can still either succeed and persist the data, or it could fail, which would undo all the changes and leave the database in the same state as before you initiated the transaction.\n\nTo commit the transaction and save the inserted document permanently to the database, run the method on the session object:\n\nAs with , this command gives no output if it succeeds.\n\nNow, list the documents from the collection in both MongoDB shells. Start with querying the variable in the running session:\n\nThen query the collection in the second shell running outside of the transaction:\n\nThis time, the newly inserted document is visible both inside the session and outside it. The transaction has been committed and ended successfully, persisting the changes it made to the database. You can now access the object both outside transactions and inside all further transactions.\n\nNow that you know how to start and execute a transaction, you can move on to the next step, which outlines how to abort a transaction after starting one to roll back any changes you’ve made before executing it. Be sure to keep both of your MongoDB shell environments open, as you’ll continue using both for the remainder of this tutorial.\n\nThis step follows a similar path to the previous one, in that it has you start a transaction in the same way. However, this step outlines how to abort the transaction instead of committing the changes. When doing so, all changes introduced by the transaction are rolled back, returning the database to its previous state as if the transaction never happened.\n\nAfter following the previous step, you’ll have four cities in the collection, including the newly added one representing New York.\n\nIn the first MongoDB shell, start the session and assign it to the variable again:\n\nAgain, this method won’t return any output if it succeeds. If it is successful, you’ll be inside a running transaction.\n\nYou will again need access to the collection inside the session context. You can do this by again creating a variable to represent the collection inside the session:\n\nFrom now on, you can use variable to act on the collection in the context of the session.\n\nNow that the transaction is started, insert another new document into this collection as part of the running transaction. The document in this example will represent Buenos Aires. Use the method, but execute it on the variable to ensure it will be run in the session:\n\nNotice that the newly inserted document is immediately visible in the same session within the transaction:\n\nHowever, if you were to query the collection in your second MongoDB shell instance, which is not operating within the transaction, the returned list won’t contain the Buenos Aires document as the transaction hasn’t been committed:\n\nSay you made a mistake and you no longer want to commit the transaction. Instead, you want to cancel any statements that you’ve run as part of this session and abort the transaction altogether. To do this, run the method:\n\nThe method tells MongoDB to discard all changes introduced in the transaction and return the database to the previous state. As with and , this command gives no output if it succeeds.\n\nAfter successfully aborting the transaction, list the documents from the collection in both MongoDB shells. First, run the following operation in the running session:\n\nThen run the following query in your second shell instance which is running outside of the session:\n\nBuenos Aires is absent from both lists. Aborting the transaction after the document was inserted but before the transaction was committed, it’s like inserting it never happened.\n\nIn this step, you learned how to terminate a transaction and roll back the changes introduced during its existence. However, transactions aren’t always aborted manually like this. Oftentimes, the reason MongoDB will terminate a transaction before it can be executed is because one of the operations within the transaction caused an error.\n\nThis step is similar to the previous one, but this time you’ll learn what happens when an error occurs during any of the statements executed inside the transaction.\n\nYou should at this point still have two open shell sessions. Your collection holds four cities, including the newly added document representing New York. However, the document representing Buenos Aires was not inserted, as it was discarded when you aborted the transaction in the previous step.\n\nIn the first MongoDB shell, start the session and assign it to the variable:\n\nFollowing that, insert another new document into this collection as part of the running transaction. This example inserts a document representing Osaka, Japan:\n\nThe newly inserted city will immediately be visible from inside the transaction:\n\nHowever, the Osaka document won’t be visible in the second shell since it is outside the transaction:\n\nThe transaction is still running and can be used to perform further changes on the database.\n\nRun the following operation to try to insert one more document into the collection as part of this transaction. This command will create another document representing New York City. However, because of the uniqueness constraint you applied to the field when setting up this collection, and because this collection already has a document whose field’s value is , this operation will conflict with that constraint and cause an error:\n\nMongoDB will return the error message noting that this operation violated the unique constraint:\n\nThis output indicates that this new document representing New York wasn’t inserted into the database. However, this doesn’t explain what happened to the document representing Osaka that you previously added as part of the transaction.\n\nSay that attempting to add that second New York document was a mistake, but you did intend to keep the Osaka document in the collection. You might try committing the transaction to persist the Osaka document:\n\nMongoDB will not allow this and instead throw an error:\n\nAny time an error occurs inside of a transaction it will cause MongoDB to automatically abort the transaction. Also, because transactions are executed in an all-or-nothing manner, no changes from within the transaction are persisted in such a case. The error caused by adding a second document representing New York caused MongoDB to abort the transaction and discard the document representing Osaka.\n\nYou can verify this by running the query both in both shells. In the first shell, run the query within the context of the session:\n\nThen in the second shell, running outside of the session, run against :\n\nNeither will show Osaka nor a duplicated New York entry. When MongoDB automatically aborted the transaction, it also made sure all changes were reverted. Osaka was briefly visible inside the transaction context but never was available outside the transaction to other database users.\n\nBy reading this article, you familiarized yourself with ACID principles and multi-document transactions in MongoDB. You initiated a transaction, inserted documents as part of that transaction, and learned when the document becomes visible inside and outside the transaction. You learned how to commit the transaction and how to abort it and roll back any changes, as well as what happens when an error occurs inside the transaction.\n\nWith these new skills in hand, you can leverage the ACID guarantees of multi-document transactions in applications where they might be needed. Remember, though, that MongoDB is a document-oriented database. In many scenarios, the document model itself, as well as careful schema design, can reduce the need for working with multi-document transactions.\n\nThe tutorial provided only a brief introduction to transactions in MongoDB. We encourage you to study the official official MongoDB documentation to learn more about how transactions work."
    },
    {
        "link": "https://stackoverflow.com/questions/62945666/mongodb-and-node-js-transaction-alternative-and-relations",
        "document": "I am trying to implement relations on collections. My requirement is\n\nPost request 2, creating from first document so I got company name from previous json body:\n\nPost request 3, creating from first document so I got company name from previous json body:\n\nHere company is foreign key field. How can I achieve company with id field without failing one another like transactions.\n\nIn mysql I will create two tables company, user and using transactions i will insert in both tables in single post using id's if any update in company name id will remain same for owner and engineer.\n\nHow can I achieve these in mongodb, with node.js?\n\nIn online searches I have found most suggest avoid transactions and using mongodb functionalities like mongodb embedded."
    },
    {
        "link": "https://mongodb.com/docs/drivers/node/current/fundamentals/transactions",
        "document": "In this guide, you can learn how to use the Node.js driver to perform transactions. Transactions allow you to run a series of operations that do not change any data until the entire transaction is committed. If any operation in the transaction fails, the driver ends the transaction and discards all data changes before they ever become visible. This feature is called atomicity. Since all write operations on a single document in MongoDB are atomic, you might want to use transactions to make an atomic change that modifies multiple documents. This situation requires a multi-document transaction. Multi-document transactions are ACID compliant because MongoDB guarantees that the data involved in your transaction operations remains consistent, even if the driver encounters unexpected errors. To learn more about ACID compliance and transactions, see our article on ACID transactions . To execute a multi-document transaction, you must be connected to a deployment running MongoDB Server version 4.0 or later. For a detailed list of limitations, see the Transactions and Operations section in the Server manual. In MongoDB, multi-document transactions run within a client session. A client session is a grouping of related read or write operations that you want to execute sequentially. We recommend you reuse your client for multiple sessions and transactions instead of instantiating a new client each time. When combined with read and write concerns, the driver guarantees causal consistency between the operations. To learn more, see Client Sessions and Causal Consistency Guarantees in the Server manual. Learn more about how to use the driver to perform multi-document transactions in the following sections of this guide:\n\nThe driver provides two APIs for performing transactions, the Core API and the Convenient Transaction API. The Core API is a framework that enables you to create, commit, and end transactions. When using this API, you must explicitly perform the following actions:\n• None Create and end the session in which you run the transaction. The Convenient Transaction API is a framework that enables you to perform transactions without being responsible for committing or ending them. This API automatically incorporates error-handling logic to retry operations when the server raises certain error types. To learn more about this behavior, see the Transaction Errors section of this guide. When you connect to MongoDB Server version 4.2 or earlier, you can perform write operations in a transaction only on collections that already exist. When you connect to MongoDB Server version 4.4 and later, the server automatically creates collections as necessary when you perform write operations in a transaction. To learn more about this behavior, see Create Collections and Indexes in a Transaction in the Server manual. The Core API provides the following methods to implement transactions:\n• None commitTransaction() : commits the active transaction in the session that it was created in\n• None abortTransaction() : ends the active transaction in the session that it was created in You must perform the following steps when using this API:\n• None Pass the session instance to each operation that you want to run in that session.\n• None Implement a block in which you identify server transaction errors and implement error-handling logic. The following code demonstrates how to perform a transaction by using the Core API: . ( \"An error occurred during the transaction:\" + error) ; Use a Session with the Client That Started It The driver throws an error if you provide a session from one instance to a different client instance. For example, the following code generates an error because it creates a instance from the client, but provides this session to the client for a write operation: To see a fully runnable example that uses this API, see the Use the Core API usage example. The Convenient Transaction API provides the following methods to implement transactions:\n• None withSession() : Runs the callback passed to it within a session. The API handles the creation and termination of the session automatically.\n• None withTransaction() : Runs the callback passed to it within a transaction and calls the method when the callback returns. These methods return the value that the callback returns. For example, if a callback you pass to the method returns the document , then the method also returns that document. To avoid infinite looping errors, ensure that the callback you pass to the method catches any errors that it raises. When you use the Convenient Transaction API, you can propagate return values from the callback as the return values of the and methods to work with them elsewhere in your code. You must perform the following steps when using this API:\n• None Pass the session instance to each operation that you want to run in that session.\n• None Implement the async syntax for each operation in the session.\n• None Avoid parallelism, such as calling the method. Using sessions in parallel usually leads to server errors. The following code demonstrates how to perform a transaction by using the Convenient Transaction API: To see a fully runnable example that uses this API, see the Use the Convenient Transaction API usage example. The Node.js driver does not support running parallel operations within a single transaction.\n\nYou can pass a instance to the and methods to configure how the driver performs a transaction. When you specify an option, it overrides the value of the option that you might have set on your instance. The following table includes options that you can specify in a instance: To learn more, see in the Server manual. Specifies the write operation level of acknowledgment required from a replica set. To learn more, see in the Server manual. Specifies how to route read operations to members of a replica set. To learn more, see in the Server manual. Specifies the length of time that a commit action on a transaction can run, in milliseconds. For a full list of options, see the API documentation for TransactionOptions . The transaction inherits settings from your instance unless you specify them in your transaction options. The following code shows how to define and pass transaction options to the method:\n\nIf you are using the Core API to perform a transaction, you must incorporate error-handling logic into your application for the following errors:\n• None : Raised if a write operation errors before the driver commits the transaction. To learn more about this error, see the TransientTransactionError description on the Driver API page in the Server manual.\n• None : Raised if the commit operation encounters an error. To learn more about this error, see the UnknownTransactionCommitResult description on the Driver API page in the Server manual. The Convenient Transaction API incorporates retry logic for these error types, so the driver retries the transaction until there is a successful commit."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-use-mongodb-transactions-in-nodejs",
        "document": "How to Use MongoDB Transactions in Node.js?\n\nUsing MongoDB transactions in Node.js involves several steps. Transactions allow multiple operations on the database to be executed in an all-or-nothing manner, ensuring data consistency. we will learn how to use MongoDB transaction in Node.js.\n\nSteps to Use MongoDB Transactions in Node.js\n\nFirst, make sure you have the mongodb package installed. You can install it using npm:\n\nCreate a MongoClient instance and connect to your MongoDB server.\n\nStart a session to use for the transaction.\n\nUse the session object to perform multiple operations.\n• None If all operations succeed, commit the transaction.\n• None If any operation fails, abort the transaction.\n\nIf there is an error.\n\nEnd the session after committing or aborting the transaction.\n\nClose the MongoDB client to clean up resources.\n\nExample: Here is an example of using MongoDB transactions in a Node.js application.\n\nOutput: Run \" node mongots.js \" to see output in terminal.\n\nNote: It is crucial to handle errors appropriately by catching exceptions and ensuring the transaction is aborted if any operation fails."
    },
    {
        "link": "https://stackoverflow.com/questions/51228059/mongo-db-4-0-transactions-with-mongoose-nodejs-express",
        "document": "I am developing an application where I am using MongoDB as database with Nodejs + Express in application layer, I have two collections, namely\n\nHere i have to update wallet of thousands of users with some amount and if successful create a new document with related info for each transaction, This is My code :\n\nbut this solution is not there is always a possibility of user wallet updated with amount but related transaction not created in transactions collection resulting in financial loss.\n\nI have heard that recently has added support in its , I have read the MongoDB docs but couldn't get it to successfully implement it with mongoose in Node.js, can anyone tell me how this above code be reimplemented using the latest feature of MongoDB which have these functions"
    },
    {
        "link": "https://stackoverflow.com/questions/51587451/mongodb-4-0-transactions-support-for-node-js",
        "document": "As mentioned on the comment as well, you can find the reference for transactions on node-mongodb-native v3.1 API ClientSession. This is because transactions are associated with a session. That is, you start a transaction for a session. At any given time, you can have at most one open transaction for a session.\n\nThe documentation for MongoDB multi-document Transactions also contains examples code snippets. For example:\n\nThe reference for the methods above can be found on:\n\nIn addition to MongoDB Node.js driver v3.1, please note that multi-document transactions are available for replica sets only on MongoDB v4.0.x. Transactions for sharded clusters are available starting with version v4.2."
    },
    {
        "link": "https://mongodb.com/docs/drivers/node/upcoming/fundamentals/transactions",
        "document": "In this guide, you can learn how to use the Node.js driver to perform transactions. Transactions allow you to run a series of operations that do not change any data until the entire transaction is committed. If any operation in the transaction fails, the driver ends the transaction and discards all data changes before they ever become visible. This feature is called atomicity. Since all write operations on a single document in MongoDB are atomic, you might want to use transactions to make an atomic change that modifies multiple documents. This situation requires a multi-document transaction. Multi-document transactions are ACID compliant because MongoDB guarantees that the data involved in your transaction operations remains consistent, even if the driver encounters unexpected errors. To learn more about ACID compliance and transactions, see our article on ACID transactions . To execute a multi-document transaction, you must be connected to a deployment running MongoDB Server version 4.0 or later. For a detailed list of limitations, see the Transactions and Operations section in the Server manual. In MongoDB, multi-document transactions run within a client session. A client session is a grouping of related read or write operations that you want to execute sequentially. We recommend you reuse your client for multiple sessions and transactions instead of instantiating a new client each time. When combined with read and write concerns, the driver guarantees causal consistency between the operations. To learn more, see Client Sessions and Causal Consistency Guarantees in the Server manual. Learn more about how to use the driver to perform multi-document transactions in the following sections of this guide:\n\nThe driver provides two APIs for performing transactions, the Core API and the Convenient Transaction API. The Core API is a framework that enables you to create, commit, and end transactions. When using this API, you must explicitly perform the following actions:\n• None Create and end the session in which you run the transaction. The Convenient Transaction API is a framework that enables you to perform transactions without being responsible for committing or ending them. This API automatically incorporates error-handling logic to retry operations when the server raises certain error types. To learn more about this behavior, see the Transaction Errors section of this guide. When you connect to MongoDB Server version 4.2 or earlier, you can perform write operations in a transaction only on collections that already exist. When you connect to MongoDB Server version 4.4 and later, the server automatically creates collections as necessary when you perform write operations in a transaction. To learn more about this behavior, see Create Collections and Indexes in a Transaction in the Server manual. The Core API provides the following methods to implement transactions:\n• None commitTransaction() : commits the active transaction in the session that it was created in\n• None abortTransaction() : ends the active transaction in the session that it was created in You must perform the following steps when using this API:\n• None Pass the session instance to each operation that you want to run in that session.\n• None Implement a block in which you identify server transaction errors and implement error-handling logic. The following code demonstrates how to perform a transaction by using the Core API: . ( \"An error occurred during the transaction:\" + error) ; Use a Session with the Client That Started It The driver throws an error if you provide a session from one instance to a different client instance. For example, the following code generates an error because it creates a instance from the client, but provides this session to the client for a write operation: To see a fully runnable example that uses this API, see the Use the Core API usage example. The Convenient Transaction API provides the following methods to implement transactions:\n• None withSession() : Runs the callback passed to it within a session. The API handles the creation and termination of the session automatically.\n• None withTransaction() : Runs the callback passed to it within a transaction and calls the method when the callback returns. These methods return the value that the callback returns. For example, if a callback you pass to the method returns the document , then the method also returns that document. To avoid infinite looping errors, ensure that the callback you pass to the method catches any errors that it raises. When you use the Convenient Transaction API, you can propagate return values from the callback as the return values of the and methods to work with them elsewhere in your code. You must perform the following steps when using this API:\n• None Pass the session instance to each operation that you want to run in that session.\n• None Implement the async syntax for each operation in the session.\n• None Avoid parallelism, such as calling the method. Using sessions in parallel usually leads to server errors. The following code demonstrates how to perform a transaction by using the Convenient Transaction API: To see a fully runnable example that uses this API, see the Use the Convenient Transaction API usage example. The Node.js driver does not support running parallel operations within a single transaction.\n\nYou can pass a instance to the and methods to configure how the driver performs a transaction. When you specify an option, it overrides the value of the option that you might have set on your instance. The following table includes options that you can specify in a instance: To learn more, see in the Server manual. Specifies the write operation level of acknowledgment required from a replica set. To learn more, see in the Server manual. Specifies how to route read operations to members of a replica set. To learn more, see in the Server manual. Specifies the length of time that a commit action on a transaction can run, in milliseconds. For a full list of options, see the API documentation for TransactionOptions . The transaction inherits settings from your instance unless you specify them in your transaction options. The following code shows how to define and pass transaction options to the method:\n\nIf you are using the Core API to perform a transaction, you must incorporate error-handling logic into your application for the following errors:\n• None : Raised if a write operation errors before the driver commits the transaction. To learn more about this error, see the TransientTransactionError description on the Driver API page in the Server manual.\n• None : Raised if the commit operation encounters an error. To learn more about this error, see the UnknownTransactionCommitResult description on the Driver API page in the Server manual. The Convenient Transaction API incorporates retry logic for these error types, so the driver retries the transaction until there is a successful commit."
    }
]