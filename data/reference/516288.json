[
    {
        "link": "https://stackoverflow.com/questions/61316450/best-practices-working-with-pointers-in-c-functions-with-structs",
        "document": "I'm starting with programming and I believe I have got a grasp about pointers. However I'm trying to understand the best practices for pointers and functions while using struts.\n\nI have made below Toy example code to exemplify two ways to perform same thing:\n\nThe first two prints are just to check about pointers usage.\n\nThe remaining prints are to check the three functions , and that perform same actions in different ways. The first one returns and uses a pointer as input, whereas the second and third one have a variable as input and return a rectangle . Third option seems better than second, but would like to confirm. I'm not sure about the first one compared to the rest.\n\nWhich option would be better in terms of best practice and why? Is there any of these options better in terms of avoiding memory leaks? May there be any other ways using pointers, and would those be even better than those I posted?"
    },
    {
        "link": "https://stackoverflow.com/questions/23351621/c-reference-vs-pointer-best-practices",
        "document": "I have read a number of stackoverflow answers about this and I am not quite satisfied from the responses so I wanted to gather them here.\n\nWhen calling a function using non-primitive and complex objects for parameters it is generally advised to pass them by reference UNLESS there is a possibility of the parameter being NULL. This is mostly due to the fact that references are guaranteed to have a value so you don't have to check if a parameter reference is NULL.\n\nWhen the return value of a function is a non-primitive and complex object you should generally return a pointer because it is easy to confuse a function that returns a reference with one that returns a value as they appear identical when called.\n\nAs an example take this class\n\nAre these the best practices for references vs pointers in function parameters and return types? If not, please explain why not.\n\nEDIT 1: Changed GetDimensions() to return value because it is believed efficient"
    },
    {
        "link": "https://reddit.com/r/embedded/comments/14h39sa/passing_structs_by_reference_or_as_a_copy_best",
        "document": "I am working on a project at the moment that will require a couple of modules to pass structs of data to a central module. To keep each of the modules encapsulated, the structs are set as static. The question I have is in this situation is it typically best practice to pass the structs by reference or pass a copy of the struct. If I pass the struct by reference the data can now be modified by functions external to the module but If I pass a copy of the struct I am added extra data to the stack. Is the best option based on the amount of stack space available or is it always best practice to pass by reference?\n\nEdit: Thanks everyone for the feedback, I will likely go with a const reference to the struct."
    },
    {
        "link": "https://reddit.com/r/C_Programming/comments/zbu79s/is_using_pointer_to_structures_as_function",
        "document": "I currently using C for numerical problems. Therefore I want to know, if it is good practice, if helper variables are passed in with a pointer to a structure.\n\nIf the function would declare a helper variable every time the function gets called, it would slow down the program? Furthermore, do you know a book or webpage which covers extensively pointers (also pointers to arrays, functions etc.)? Thank you very much!"
    },
    {
        "link": "https://cplusplus.com/forum/beginner/261042",
        "document": "Hello! I HAVE googled this a lot. So at an intellectual level I realize:\n\n \n\n Passing/variables by value are useful because changes to the variable will not reflect the one from which it is called.\n\n \n\n Passing/variables by pointer is faster because it does not make a copy. It also allows the pointer variable to be changed at the root of the function.\n\n \n\n Passing/variables by reference is similar to pointers but they cannot be reassigned and are aliases instead of memory addresses. \n\n \n\n - At least that's my understanding right now. \n\n \n\n My problem is that I cannot for the life of me differentiate WHEN to use which one. Maybe I'm just not understanding when I need a copy of a variable and when I can get away with using a pointer/reference. (I should try to use them whenever I can because they're faster, right?) - googling, someone also said to only use them whenever it is your last option. (which did not help me understand when to use them)\n\n \n\n If pointers/reference variables are faster why not always use them? \n\n \n\n Right now I can't consciously think \"ok, this variable should be a copy this could be a pointer/reference\" - Is there any type of rule I can go by when trying to apply these 3 variable types? References are basically memory addresses, correct? When do you need to use that aspect?\n\n \n\n Also, pointers/references can be used on classes and functions? Why?\n\n \n\n Maybe someone could give me an example of when you would definitely need a pointer and when you would definitely need a reference? Also, Why would you use one over the other?\n\n \n\n Sorry, I am really struggling with this!\n\n \n\n Thanks!\n\nFirst when passing variables by value a copy of the value is made when passing to a function. This copy can be expensive (in terms of resources or time) when dealing with non-POD (Plain Old Data) or non trivial types like std::string, std::vector, etc so you usually want to avoid the copy by passing by reference or by pointer instead. \n\n \n\n With POD types is is usually just as fast to copy the value as it is to pass by pointer or reference. So the only time you should consider passing by pointer of reference for a POD type is when you want the function to be able to modify the value.\n\n \n\n Now as to when to pass by pointer or to pass by reference, prefer pass by reference. IMO, Only use pass by pointer when absolutely necessary, such as when it is possible the value to be a nullptr.\n\n \n\n \n\n\n\n\n\n \n\n An integer, for example, is usually about the same size as a pointer, depending on how the integer is declared.\n\n \n\n There is no difference in speed when pushing a copy of an integer when compared to pushing a pointer to an integer, or a reference to an integer.\n\n \n\n The speed difference comes into play when passing larger structures (classes, structs) by value, as compared to pointer or reference.\n\n \n\n If you're passing structures to a function, you probably want the speed benefit, so unless there is a reason to want a copy (a duplicate/constructor/destructor implied), you don't want to pass those by value.\n\n \n\n If you're passing anything, int, float, structure....and you want the calling code to receive the changes made to those values inside the function, you can't pass those by value. \n\n \n\n To be clear:\n\n \n\n f1( a ) { a *= 2; } f2( & a ) { a *= 4; } f3( * a ) { (*a) *= 8; } main() { x = 5; f1( x ); // x is still 5, f1 used a copy f2( x ); // x is now 20, it did not use a copy f3( x ); // x is now 160, it did not use a copy 0; } \n\n \n\n \n\n If you don't need or care that the caller will not see the changes made inside the function, you can pass by value (the function uses a copy).\n\n \n\n If you need the calling code to be aware of the changes made to the value inside the function, as in f2 or f3 above, you can't pass by value (you could use a return from the function, but that's another subject).\n\n \n\n Now....about pointer vs reference.\n\n \n\n The pointer is from C. It is from the origin of the language back in the 70's. It is an older concept. \n\n \n\n In Modern C++ we avoid pointers wherever possible. This implies you should prefer references unless you have no choice be to \"devolve\" toward a pointer.\n\n \n\n Raw pointers come at us from the operating system, as most operating systems are written in C.\n\n \n\n Sometimes you're working at a raw level for the sake of extreme performance, and you may create some custom memory management system, or you're processing video data, audio data, image information...the point here is that by the time you're doing that stuff, you know you need pointers and don't need to even ask anymore.\n\n \n\n Until you're going that, you're best to avoid pointers entirely until you're ready to really study them (and their usage).\n\n \n\n In the 90's, we might:\n\n \n\n \n\n \n\n We'd do this for dynamic allocation of A. Maybe A is polymorphic (has a virtual base class). For whatever reason I could not just use an \"A\" on the stack, if I just had to make one from the heap (that could survive beyond the local function, for example), then I must create it with new.\n\n \n\n Until modern C++.\n\n \n\n Now, one should far prefer:\n\n \n\n \n\n \n\n Or the related \"make_shared\" if using shared_ptr.\n\n \n\n Here, there are no naked pointers. \"p\" will still work like a pointer, fast as a pointer, and \"A\" is dynamically created. However, I will not have to remember to delete it. That will work automatically. \n\n \n\n I also can't accidentally delete it twice because I screw up the management of a raw pointer that owns it.\n\n \n\n ...and a bunch of bugs associated with raw pointers.\n\n \n\n Now, one of the things you didn't ask about is implied with:\n\n \n\n \n\n \n\n That might not strike you, so look at the rawer version of it\n\n \n\n \n\n \n\n That's a reference to a pointer.\n\n \n\n Do not blow a fuse contemplating it. It's rather simple, and has a purpose, just something more to contemplate (and there's more, but I'll pause here).\n\n \n\n \n\n \n\n First, this \"speed\" notion depends entirely on what we are comparing.An integer, for example, is usually about the same size as a pointer, depending on how the integer is declared.There is no difference in speed when pushing a copy of an integer when compared to pushing a pointer to an integer, or a reference to an integer.The speed difference comes into play when passing larger structures (classes, structs) by value, as compared to pointer or reference.If you're passing structures to a function, you probably want the speed benefit, so unless there is a reason to want a copy (a duplicate/constructor/destructor implied), you don't want to pass those by value.If you're passing anything, int, float, structure...., you can't pass those by value.To be clear:If you don't need or care that the caller will not see the changes made inside the function, you can pass by value (the function uses a copy).If you need the calling code to be aware of the changes made to the value inside the function, as in f2 or f3 above, you can't pass by value (you could use a return from the function, but that's another subject).Now....about pointer vs reference.The pointer is from C. It is from the origin of the language back in the 70's. It is an older concept.In Modern C++ we avoid pointers wherever possible. This implies you should prefer references unless you have no choice be to \"devolve\" toward a pointer.Raw pointers come at us from the operating system, as most operating systems are written in C.Sometimes you're working at a raw level for the sake of extreme performance, and you may create some custom memory management system, or you're processing video data, audio data, image information...the point here is that by the time you're doing that stuff, you know you need pointers and don't need to even ask anymore.Until you're going that, you're best to avoid pointers entirely until you're ready to really study them (and their usage).In the 90's, we might:We'd do this for dynamic allocation of A. Maybe A is polymorphic (has a virtual base class). For whatever reason I could not just use an \"A\" on the stack, if I just had to make one from the heap (that could survive beyond the local function, for example), then I must create it with new.Until modern C++.Now, one should far prefer:Or the related \"make_shared\" if using shared_ptr.Here, there are no naked pointers. \"p\" will still work like a pointer, fast as a pointer, and \"A\" is dynamically created. However, I will not have to remember to delete it. That will work automatically.I also can't accidentally delete it twice because I screw up the management of a raw pointer that owns it....and a bunch of bugs associated with raw pointers.Now, one of the things you didn't ask about is implied with:That might not strike you, so look at the rawer version of itThat's a reference to a pointer.Do not blow a fuse contemplating it. It's rather simple, and has a purpose, just something more to contemplate (and there's more, but I'll pause here).\n\nWithout getting into the specifics of modern practices like make_shared, smart pointers, etc, I was just about to post what Furry Guy just posted: A pointer can be null, a reference can't be null. It sounds like you already understand this in theory, but you don't see why it's useful in practice.\n\n \n\n A construct in a language is something that is created to solve a problem. If you haven't yet had a place in your code where you felt you've needed to use pointers/references to solve an issue, then simply don't use them. So the question is, what does using a pointer help solve, or what advantage does it let you achieve? Same question for references.\n• (1) As was already mentioned, passing by reference allows you to still reference an object from a different function, without having to make a copy of the object. So the problem this is solving is one of efficiency. If you have very large objects, like vectors of many elements, it becomes necessary.\n• (2) One place where a reference shines is where you have multiple objects that need to use the same object (a shared third object), and you know that the referenced object will outlive the other object. If you could only work with values, each object would need to have its own copy of the third object, and you lose any meaningful connection between these two objects. A reference lets both objects, well, reference the same third object.\n• (3) Where a pointer shines is similar to where a reference shines, but a pointer allows more freedom (and also, mistakes). It allows you to reference an object, but also change which object your referencing to on the fly.\n• (4) Run-time polymorphism with dynamic arrays of objects. If you need to iterate over polymorphic objects that are stored as elements in an array, you simply can't store the base class of those objects in the array (search: object splicing). And you can't, by language design, have an array of references. So you have to store an array of pointers to those objects, especially if you want to add and remove elements to this array at runtime.\n\n \n\n (2) For example, think of a family tree. You and your brother both have a mother. But your mother is her own being. You and your brother shouldn't have copies of your mother; they have references instead.\n\n (3) In this same family tree example, imagine that when you were born, the hospital accidentally swapped you at birth with another family's baby. When you were born, you had a reference to your original mother, but now you have a different \"mother\"! In this case, you can simply re-assign the pointer so that you are now pointing to your fake mother and not your real mother. A reference couldn't do this, because once a reference is created, it can't be re-assigned to another object.\n\n \n\n Also, I've probably already failed in keeping this as concise as possible, but one thing to note is that everywhere a reference is used, a pointer could also be used; C only had pointers, not references. But pointers come at the cost of ugly syntax and error-prone dereferencing.\n\n \n\n Prefer values when feasible. Prefer references to pointers. Only use pointers if you have to.\n\nanother thing on the speed question ... pointers are 2 variables. You do about twice as much work at the assembly language level to use them.\n\n \n\n for example, take a pure integer...\n\n if you pass an integer to a function by reference, the reference IS the integer variable, so the assembly is something simple like move value in memory to cpu register (one statement). If you passed a pointer to it, you have steps like move pointer's value to register first, then go to that location in memory and move the value there to cpu register. Optimize may be able to short out some of this but often it is unavoidable. \n\n \n\n In terms of pure speed, references are either the best, or at worse equal to, any other option, in MOST code. Again, optimization has gotten really smart and funky so I hesitate to say always instead of most there. That does not mean always use references (plenty on that above), its just a review of the mechanics.\n\n\n\n @Furry Guy, what you say is true (kind of - see end of this post where I check an optional in exactly the same way I check a pointer)\n\n \n\n But I don't need to protect against people having trouble understanding how to check an optional object to see if the object is there or not. If they don't know, they can look that up. What I need to protect against is people not even realising that the object might not be there.\n\n \n\n I see people dereferencing null pointers because they didn't realise it could be null. Null pointer dereferencing because people didn't realise it could be null happens every day. When they don't have a pointer, but they have a std::optional, it is much more likely that they will realise the object they want might not exist.\n\n \n\n That's what I need to protect against, and that's what std::optional gives me that a pointer does not; with std::optional, it's written right there in the code that the object's existence is optional - the word \"optional\" is on the screen right in front of them where the optional is created or declared, and if they're using a helpful IDE in other places too - and thus massively increases the chances that the person reading the code will realise that.\n\n \n\n That said, it's not exactly difficult and it's no more typing:\n\n \n\n Check a pointer isn't null:\n\n \n\n \n\n Check std::optional contains an object:\n\n @Furry Guy, what you say is true (kind of - see end of this post where I check an optional in exactly the same way I check a pointer)But I don't need to protect against people having trouble understanding how to check an optional object to see if the object is there or not. If they don't know, they can look that up. What I need to protect against is people not even realising that the object might not be there.I see people dereferencing null pointers because they didn't realise it could be null. Null pointer dereferencing because people didn't realise it could be null happens every day. When they don't have a pointer, but they have a std::optional, it is much more likely that they will realise the object they want might not exist.That's what I need to protect against, and that's what std::optional gives me that a pointer does not; with std::optional, it's written right there in the code that the object's existence is optional - the word \"optional\" is on the screen right in front of them where the optional is created or declared, and if they're using a helpful IDE in other places too - and thus massively increases the chances that the person reading the code will realise that.That said, it's not exactly difficult and it's no more typing:Check a pointer isn't null:Check std::optional contains an object:"
    },
    {
        "link": "https://cplusplus.com/doc/tutorial/arrays",
        "document": "foo[5]; foo[2] = 75; // access to an element of the array."
    },
    {
        "link": "https://en.cppreference.com/w/c/language/array_initialization",
        "document": "When initializing an object of array type, the initializer must be either a string literal (optionally enclosed in braces) or be a brace-enclosed list of initialized for array members:\n\ncomma-separated list of expressions that are initializers for array elements , optionally using array designators of the form\n\nempty initializer empty-initializes every element of the array\n\nArrays of known size and arrays of unknown size may be initialized, but not VLAs(since C99)(until C23). A VLA can only be empty-initialized.(since C23)\n\nAll array elements that are not initialized explicitly are empty-initialized.\n\nString literal (optionally enclosed in braces) may be used as the initializer for an array of matching type:\n• ordinary string literals can initialize arrays of any character type ( , , )\n• L-prefixed wide string literals can be used to initialize arrays of any type compatible with (ignoring cv-qualifications)\n\nSuccessive bytes of the string literal or wide characters of the wide string literal, including the terminating null byte/character, initialize the elements of the array:\n\nIf the size of the array is known, it may be one less than the size of the string literal, in which case the terminating null character is ignored:\n\nNote that the contents of such array are modifiable, unlike when accessing a string literal directly with char* str = \"abc\";.\n\nWhen an array is initialized with a brace-enclosed list of initializers, the first initializer in the list initializes the array element at index zero (unless a designator is specified)(since C99), and each subsequent initializer without a designator (since C99)initializes the array element at index one greater than the one initialized by the previous initializer.\n\nIt's an error to provide more initializers than elements when initializing an array of known size (except when initializing character arrays from string literals).\n\nWhen initializing an array of unknown size, the largest subscript for which an initializer is specified determines the size of the array being declared.\n\nIf the elements of an array are arrays, structs, or unions, the corresponding initializers in the brace-enclosed list of initializers are any initializers that are valid for those members, except that their braces may be omitted as follows:\n\nIf the nested initializer begins with an opening brace, the entire nested initializer up to its closing brace initializes the corresponding array element:\n\nIf the nested initializer does not begin with an opening brace, only enough initializers from the list are taken to account for the elements or members of the sub-array, struct or union; any remaining initializers are left to initialize the next array element:\n\nThe order of evaluation of subexpressions in an array initializer is indeterminately sequenced in C (but not in C++ since C++11):\n\nAs with all other initialization, every expression in the initializer list must be a constant expression when initializing arrays of static or thread-local storage duration:"
    },
    {
        "link": "https://geeksforgeeks.org/cpp-arrays",
        "document": "In C++, an array is a derived data type that is used to store multiple values of similar data types in a contiguous memory location. Each element can be accessed using its index (position starting from 0).\n\nIn C++, we can create/declare an array by simply specifying the data type first and then the name of the array with its size inside [] square brackets (better known as array subscript operator).\n\nThis statement will create an array with name array_name the can store size elements of given data_type. Once the array is declared, its size cannot be changed.\n\nThis will create an array with name arr that can store 5 integers.\n\nWhen declared, the elements of array does not contain any valid value.\n\nInitialization means assigning initial values to array elements. We can initialize the array with values enclosed in curly braces ‘{}’ are assigned to the array. For example:\n\nThese values will be assigned sequentially. It means that the first element (index 0) will be 10, second will be 20, and so on. The number of values in the list cannot be more than the size of the array. But they can be less that the size. This is called partial initialization.\n\nThe size of the array can be skipped if the size should be same as the number of values.\n\nMoreover, all the elements can be easily initialized to 0 as shown below:\n\nThis method only works for 0,but not for any other value.\n\nElements of an array can be accessed by their position (called index) in the sequence. In C, indexes of an array starts from 0 instead of 1. We just have to pass this index inside the [] square brackets with the array name as shown:\n\nIt is important to note that index cannot be negative or greater than size of the array minus 1. (0 ≤ index ≤ size – 1). Also, it can also be any expression that results in valid index value.\n\nTo change the element at a particular index in an array, just use the = assignment operator with new value as right hand expression while accessing the array element.\n\nTraversing means visiting each element one by one. The advantage of array is that it can be easily traversed by using a loop with loop variable that runs from 0 to size – 1. We use this loop variable as index of the array and access each element one by one sequentially.\n\nThere are more methods to traverse array that are listed here – Traverse an Array in C\n\nIn C++, we do not have the length function as in Java to find array size, but it can be calculated using sizeof() operator trick. First find the size occupied by the whole array in the memory, then divide it by the size of the single element. As all the elements will have same size (due to being same type), this will give us the size/length of the array.\n\nTo know more methods, refer to the article – Length of Array in C\n\nIn C++, arrays and pointers are closely related to each other. The array name can be treated as a constant pointer that stored the memory address of the first element of the array.\n\nInternally, arrays operators are performed using pointer arithmetic. So, we can do almost any array operation using by using pointer to the first element. For example, we can access all the elements of an array using pointer to the first element.\n\nRefer to this article to know more – Relationship Between Pointer and Array\n\nJust like other datatypes in C, arrays can also be passed to functions as parameters for different tasks, but there is a catch. Arrays are always passed as pointers to the function. There are 3 different notations to pass arrays to functions:\n\nNo matter what notation we use, array will still be passed as pointer due to array decay. The direct consequence of this is that passed will lose the information about its size inside the function. It means that we cannot determine the size of the array using sizeof. The compiler will just treat the name arr as pointer and return the size accordingly. To resolve this, it is recommended to pass the size as additional parameter.\n\nIn the above examples, we saw 1D (one dimensional) array. This array’s size can only increase in a single direction (called dimension). C provides the feature to have as many dimensions as desired for an array. Arrays declared with more than one dimension are called multidimensional arrays.\n\nwhere size1, size2 … are the sizes of each dimension.\n\nThe complexity of the array operations increases exponentially with increase in dimensions. So, among multidimensional arrays, 2D arrays and 3D arrays are most widely used.\n\nIn C++, a two-dimensional array is an array that can grow in two directions. It can be visualized as a table arranged in rows and columns. Each element is accessed using two indices: one for the row and one for the column.\n\nExplanation: In the above code, we have declared a 2D array with 4 rows and 4 columns after that we initialized the array with the value of (i+j) in every iteration of the loop. Then we are printing the 2D array using a nested loop and we can see in the below output that there are 4 rows and 4 columns.\n\nThe 3D array uses three dimensions. A can be visualized as a collection of various two-dimensional arrays piled on top of one another can be used to represent it. Three indices: the row index, column index, and depth index are used to uniquely identify each element in a 3D array.\n\nExplanation: In the above code, we have declared a 3D array and then initialized it using three nested for loops. After that, we printed all layers of the 3D array again using three nested for loops as seen in the output.\n• None An array is a collection of data of the same data type, stored at a contiguous memory location.\n• None Indexing of an array starts from 0. It means the first element is stored at the 0 index, the second at 1 , and so on.\n• None Elements of an array can be accessed using their indices.\n• None Once an array is declared its size remains constant throughout the program.\n• None An array can have multiple dimensions.\n• None The size of the array in bytes can be determined by the sizeof operator using which we can also find the number of elements in the array.\n• None We can find the size of the type of elements stored in an array by subtracting adjacent addresses.\n\nThe below practice problems provide you some commonly used scenarios and exercises for practicing arrays in C++:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/cpp/arrays-cpp?view=msvc-170",
        "document": "An array is a sequence of objects of the same type that occupy a contiguous area of memory. Traditional C-style arrays are the source of many bugs, but are still common, especially in older code bases. In modern C++, we strongly recommend using or instead of C-style arrays described in this section. Both of these standard library types store their elements as a contiguous block of memory. However, they provide greater type safety, and support iterators that are guaranteed to point to a valid location within the sequence. For more information, see Containers.\n\nIn a C++ array declaration, the array size is specified after the variable name, not after the type name as in some other languages. The following example declares an array of 1000 doubles to be allocated on the stack. The number of elements must be supplied as an integer literal or else as a constant expression. That's because the compiler has to know how much stack space to allocate; it can't use a value computed at run-time. Each element in the array is assigned a default value of 0. If you don't assign a default value, each element initially contains whatever random values happen to be at that memory location.\n\nThe first element in the array is the zeroth element. The last element is the (n-1) element, where n is the number of elements the array can contain. The number of elements in the declaration must be of an integral type and must be greater than 0. It is your responsibility to ensure that your program never passes a value to the subscript operator that is greater than .\n\nA zero-sized array is legal only when the array is the last field in a or and when the Microsoft extensions are enabled ( or isn't set).\n\nStack-based arrays are faster to allocate and access than heap-based arrays. However, stack space is limited. The number of array elements can't be so large that it uses up too much stack memory. How much is too much depends on your program. You can use profiling tools to determine whether an array is too large.\n\nYou may require an array that's too large to allocate on the stack, or whose size isn't known at compile time. It's possible to allocate this array on the heap by using a expression. The operator returns a pointer to the first element. The subscript operator works on the pointer variable the same way it does on a stack-based array. You can also use pointer arithmetic to move the pointer to any arbitrary elements in the array. It's your responsibility to ensure that:\n• you always keep a copy of the original pointer address so that you can delete the memory when you no longer need the array.\n• you don't increment or decrement the pointer address past the array bounds.\n\nThe following example shows how to define an array on the heap at run time. It shows how to access the array elements using the subscript operator and by using pointer arithmetic:\n\nYou can initialize an array in a loop, one element at a time, or in a single statement. The contents of the following two arrays are identical:\n\nWhen an array is passed to a function, it's passed as a pointer to the first element, whether it's a stack-based or heap-based array. The pointer contains no other size or type information. This behavior is called pointer decay. When you pass an array to a function, you must always specify the number of elements in a separate parameter. This behavior also implies that the array elements aren't copied when the array gets passed to a function. To prevent the function from modifying the elements, specify the parameter as a pointer to elements.\n\nThe following example shows a function that accepts an array and a length. The pointer points to the original array, not a copy. Because the parameter isn't , the function can modify the array elements.\n\nDeclare and define the array parameter as to make it read-only within the function block:\n\nThe same function can also be declared in these ways, with no change in behavior. The array is still passed as a pointer to the first element:\n\nArrays constructed from other arrays are multidimensional arrays. These multidimensional arrays are specified by placing multiple bracketed constant expressions in sequence. For example, consider this declaration:\n\nIt specifies an array of type , conceptually arranged in a two-dimensional matrix of five rows and seven columns, as shown in the following figure:\n\nThe image is a grid 7 cells wide and 5 cells high. Each cell contains the index of the cell. The first cell index is labeled 0,0. The next cell in that row is 0,1 and so on to the last cell in that row which is 0,6. The next row starts with the index 1,0. The cell after that has an index of 1,1. The last cell in that row is 1,6. This pattern repeats until the last row, which starts with the index 4,0. The last cell in the last row has an index of 4,6. :::image-end\n\nYou can declare multidimensioned arrays that have an initializer list (as described in Initializers). In these declarations, the constant expression that specifies the bounds for the first dimension can be omitted. For example:\n\nThe preceding declaration defines an array that is three rows by four columns. The rows represent factories and the columns represent markets to which the factories ship. The values are the transportation costs from the factories to the markets. The first dimension of the array is left out, but the compiler fills it in by examining the initializer.\n\nUse of the indirection operator (*) on an n-dimensional array type yields an n-1 dimensional array. If n is 1, a scalar (or array element) is yielded.\n\nC++ arrays are stored in row-major order. Row-major order means the last subscript varies the fastest.\n\nYou can also omit the bounds specification for the first dimension of a multidimensional array in function declarations, as shown here:\n\nThe function is written such that adding new factories doesn't require any code changes, just a recompilation.\n\nArrays of objects that have a class constructor are initialized by the constructor. When there are fewer items in the initializer list than elements in the array, the default constructor is used for the remaining elements. If no default constructor is defined for the class, the initializer list must be complete, that is, there must be one initializer for each element in the array.\n\nConsider the class that defines two constructors:\n\nThe first element of is constructed using the constructor ; the remaining two elements are constructed using the default constructor.\n\nStatic member arrays (whether or not) can be initialized in their definitions (outside the class declaration). For example:\n\nYou can access individual elements of an array by using the array subscript operator ( ). If you use the name of a one-dimensional array without a subscript, it gets evaluated as a pointer to the array's first element.\n\nWhen you use multidimensional arrays, you can use various combinations in expressions.\n\nIn the preceding code, is a three-dimensional array of type . The pointer points to an array of type of size three. In this example, the array is used with one, two, and three subscripts. Although it's more common to specify all subscripts, as in the statement, sometimes it's useful to select a specific subset of array elements, as shown in the statements that follow .\n\nLike other operators, the subscript operator ( ) can be redefined by the user. The default behavior of the subscript operator, if not overloaded, is to combine the array name and the subscript using the following method:\n\nAs in all addition that involves pointer types, scaling is done automatically to adjust for the size of the type. The resultant value isn't n bytes from the origin of ; instead, it's the nth element of the array. For more information about this conversion, see Additive operators.\n\nSimilarly, for multidimensional arrays, the address is derived using the following method:\n\nWhen an identifier of an array type appears in an expression other than , address-of ( ), or initialization of a reference, it's converted to a pointer to the first array element. For example:\n\nThe pointer points to the first element of the array . Arrays, unlike pointers, aren't modifiable l-values. That's why the following assignment is illegal:"
    },
    {
        "link": "https://stackoverflow.com/questions/2890598/how-to-initialize-all-elements-in-an-array-to-the-same-number-in-c",
        "document": ""
    }
]