[
    {
        "link": "https://learn.microsoft.com/en-us/dax/aggregation-functions-dax",
        "document": ""
    },
    {
        "link": "https://learn.microsoft.com/en-us/dax/dax-overview",
        "document": "Data Analysis Expressions (DAX) is a formula expression language used in Analysis Services, Power BI, and Power Pivot in Excel. DAX formulas include functions, operators, and values to perform advanced calculations and queries on data in related tables and columns in tabular data models.\n\nThis article provides only a basic introduction to the most important concepts in DAX. It describes DAX as it applies to all the products that use it. Some functionality may not apply to certain products or use cases. Refer to your product's documentation describing its particular implementation of DAX.\n\nDAX formulas are used in measures, calculated columns, calculated tables, and row-level security.\n\nMeasures are dynamic calculation formulas where the results change depending on context. Measures are used in reporting that support combining and filtering model data by using multiple attributes such as a Power BI report or Excel PivotTable or PivotChart. Measures are created by using the DAX formula bar in the model designer.\n\nA formula in a measure can use standard aggregation functions automatically created by using the Autosum feature, such as COUNT or SUM, or you can define your own formula by using the DAX formula bar. Named measures can be passed as an argument to other measures.\n\nWhen you define a formula for a measure in the formula bar, a Tooltip feature shows a preview of what the results would be for the total in the current context, but otherwise the results are not immediately output anywhere. The reason you cannot see the (filtered) results of the calculation immediately is because the result of a measure cannot be determined without context. To evaluate a measure requires a reporting client application that can provide the context needed to retrieve the data relevant to each cell and then evaluate the expression for each cell. That client might be an Excel PivotTable or PivotChart, a Power BI report, or a table expression in a DAX query in SQL Server Management Studio (SSMS).\n\nRegardless of the client, a separate query is run for each cell in the results. That is to say, each combination of row and column headers in a PivotTable, or each selection of slicers and filters in a Power BI report, generates a different subset of data over which the measure is calculated. For example, using this very simple measure formula:\n\nWhen a user places the TotalSales measure in a report, and then places the Product Category column from a Product table into Filters, the sum of Sales Amount is calculated and displayed for each product category.\n\nUnlike calculated columns, the syntax for a measure includes the measure's name preceding the formula. In the example just provided, the name Total Sales appears preceding the formula. After you've created a measure, the name and its definition appear in the reporting client application Fields list, and depending on perspectives and roles is available to all users of the model.\n\nTo learn more, see: Measures in Power BI Desktop Measures in Analysis Services Measures in Power Pivot\n\nA calculated column is a column that you add to an existing table (in the model designer) and then create a DAX formula that defines the column's values. When a calculated column contains a valid DAX formula, values are calculated for each row as soon as the formula is entered. Values are then stored in the in-memory data model. For example, in a Date table, when the formula is entered into the formula bar:\n\nA value for each row in the table is calculated by taking values from the Calendar Year column (in the same Date table), adding a space and the capital letter Q, and then adding the values from the Calendar Quarter column (in the same Date table). The result for each row in the calculated column is calculated immediately and appears, for example, as 2017 Q1. Column values are only recalculated if the table or any related table is processed (refresh) or the model is unloaded from memory and then reloaded, like when closing and reopening a Power BI Desktop file.\n\nTo learn more, see: Calculated columns in Power BI Desktop Calculated columns in Analysis Services Calculated Columns in Power Pivot.\n\nA calculated table is a computed object, based on a formula expression, derived from all or part of other tables in the same model. Instead of querying and loading values into your new table's columns from a data source, a DAX formula defines the table's values.\n\nCalculated tables can be helpful in a role-playing dimension. An example is the Date table, as OrderDate, ShipDate, or DueDate, depending on the foreign key relationship. By creating a calculated table for ShipDate explicitly, you get a standalone table that is available for queries, as fully operable as any other table. Calculated tables are also useful when configuring a filtered rowset, or a subset or superset of columns from other existing tables. This allows you to keep the original table intact while creating variations of that table to support specific scenarios.\n\nCalculated tables support relationships with other tables. The columns in your calculated table have data types, formatting, and can belong to a data category. Calculated tables can be named, and surfaced or hidden just like any other table. Calculated tables are re-calculated if any of the tables it pulls data from are refreshed or updated.\n\nTo learn more, see: Calculated tables in Power BI Desktop Calculated tables in Analysis Services.\n\nWith row-level security, a DAX formula must evaluate to a Boolean / condition, defining which rows can be returned by the results of a query by members of a particular role. For example, for members of the Sales role, the Customers table with the following DAX formula:\n\nMembers of the Sales role will only be able to view data for customers in the USA, and aggregates, such as SUM are returned only for customers in the USA. Row-level security is not available in Power Pivot in Excel.\n\nWhen defining row-level secuirty by using DAX formula, you are creating an allowed row set. This does not deny access to other rows; rather, they are simply not returned as part of the allowed row set. Other roles can allow access to the rows excluded by the DAX formula. If a user is a member of another role, and that role's row-level security allows access to that particular row set, the user can view data for that row.\n\nRow-level security formulas apply to the specified rows as well as related rows. When a table has multiple relationships, filters apply security for the relationship that is active. Row-level security formulas will be intersected with other formulas defined for related tables.\n\nTo learn more, see: Row-level security (RLS) with Power BI Roles in Analysis Services\n\nDAX queries can be created and run in SQL Server Management Studio (SSMS) and open-source tools like DAX Studio (daxstudio.org). Unlike DAX calculation formulas, which can only be created in tabular data models, DAX queries can also be run against Analysis Services Multidimensional models. DAX queries are often easier to write and more efficient than Multidimensional Data Expressions (MDX) queries.\n\nA DAX query is a statement, similar to a SELECT statement in T-SQL. The most basic type of DAX query is an evaluate statement. For example,\n\nReturns in Results a table listing only those products with a SafetyStockLevel less than 200, in ascending order by EnglishProductName.\n\nYou can create measures as part of the query. Measures exist only for the duration of the query. To learn more, see DAX queries.\n\nDAX formulas are essential for creating calculations in calculated columns and measures, and securing your data by using row-level security. To create formulas for calculated columns and measures, use the formula bar along the top of the model designer window or the DAX Editor. To create formulas for row-level security, use the Role Manager or Manage roles dialog box. Information in this section is meant to get you started with understanding the basics of DAX formulas.\n\nDAX formulas can be very simple or quite complex. The following table shows some examples of simple formulas that could be used in a calculated column.\n\nWhether the formula you create is simple or complex, you can use the following steps when building a formula:\n• None Each formula must begin with an equal sign (=).\n• None You can either type or select a function name, or type an expression.\n• None Begin to type the first few letters of the function or name you want, and AutoComplete displays a list of available functions, tables, and columns. Press TAB to add an item from the AutoComplete list to the formula. You can also click the Fx button to display a list of available functions. To select a function from the dropdown list, use the arrow keys to highlight the item, and click OK to add the function to the formula.\n• None Supply the arguments to the function by selecting them from a dropdown list of possible tables and columns, or by typing in values.\n• None Check for syntax errors: ensure that all parentheses are closed and columns, tables and values are referenced correctly.\n\nIn this example, let's look at a formula in a measure named Days in Current Quarter:\n\nThis measure is used to create a comparison ratio between an incomplete period and the previous period. The formula must take into account the proportion of the period that has elapsed, and compare it to the same proportion in the previous period. In this case, [Days Current Quarter to Date]/[Days in Current Quarter] gives the proportion elapsed in the current period.\n\nThis formula contains the following elements:\n\nAutoComplete helps you enter a valid formula syntax by providing you with options for each element in the formula.\n• None You can use formula AutoComplete in the middle of an existing formula with nested functions. The text immediately before the insertion point is used to display values in the drop-down list, and all of the text after the insertion point remains unchanged.\n• None AutoComplete does not add the closing parenthesis of functions or automatically match parentheses. You must make sure that each function is syntactically correct or you cannot save or use the formula.\n\nYou can nest functions, meaning that you use the results from one function as an argument of another function. You can nest up to 64 levels of functions in calculated columns. However, nesting can make it difficult to create or troubleshoot formulas. Many functions are designed to be used solely as nested functions. These functions return a table, which cannot be directly saved as a result; it must be provided as input to a table function. For example, the functions SUMX, AVERAGEX, and MINX all require a table as the first argument.\n\nA function is a named formula within an expression. Most functions have required and optional arguments, also known as parameters, as input. When the function is executed, a value is returned. DAX includes functions you can use to perform calculations using dates and times, create conditional values, work with strings, perform lookups based on relationships, and the ability to iterate over a table to perform recursive calculations. If you are familiar with Excel formulas, many of these functions will appear very similar; however, DAX formulas are different in the following important ways:\n• None A DAX function always references a complete column or a table. If you want to use only particular values from a table or column, you can add filters to the formula.\n• None If you need to customize calculations on a row-by-row basis, DAX provides functions that let you use the current row value or a related value as a kind of parameter, to perform calculations that vary by context. To understand how these functions work, see Context in this article.\n• None DAX includes many functions that return a table, rather than a value. The table is not displayed in a reporting client, but is used to provide input to other functions. For example, you can retrieve a table and then count the distinct values in it, or calculate dynamic sums across filtered tables or columns.\n• None DAX functions include a variety of time intelligence functions. These functions let you define or select date ranges, and perform dynamic calculations based on these dates or range. For example, you can compare sums across parallel periods.\n\nAggregation functions calculate a (scalar) value such as count, sum, average, minimum, or maximum for all rows in a column or table as defined by the expression. To learn more, see Aggregation functions.\n\nThe date and time functions in DAX are similar to date and time functions in Microsoft Excel. However, DAX functions are based on a datetime data type starting March 1, 1900. To learn more, see Date and time functions.\n\nThe filter functions in DAX return specific data types, look up values in related tales, and filter by related values. The lookup functions work by using tables and relationships, like a database. The filtering functions let you manipulate data context to create dynamic calculations. To learn more, see Filter functions.\n\nThe financial functions in DAX are used in formulas that perform financial calculations, such as net present value and rate of return. These functions are similar to financial functions used in Microsoft Excel. To learn more, see Financial functions.\n\nAn information function looks at the cell or row that is provided as an argument and tells you whether the value matches the expected type. For example, the ISERROR function returns if the value that you reference contains an error. To learn more, see Information functions.\n\nLogical functions act upon an expression to return information about the values in the expression. For example, the function lets you know whether an expression that you are evaluating returns a value. To learn more, see Logical functions.\n\nThe mathematical functions in DAX are very similar to the Excel mathematical and trigonometric functions. Some minor differences exist in the numeric data types used by DAX functions. To learn more, see Math and trig functions.\n\nThese functions perform unique actions that cannot be defined by any of the categories most other functions belong to. To learn more, see Other functions.\n\nRelationship functions in DAX allow you to return values from another related table, specify a particular relationship to use in an expression, and specify cross filtering direction. To learn more, see Relationship functions.\n\nStatistical functions calculate values related to statistical distributions and probability, such as standard deviation and number of permutations. To learn more, see Statistical functions.\n\nText functions in DAX are very similar to their counterparts in Excel. You can return part of a string, search for text within a string, or concatenate string values. DAX also provides functions for controlling the formats for dates, times, and numbers. To learn more, see Text functions.\n\nThe time intelligence functions provided in DAX let you create calculations that use built-in knowledge about calendars and dates. By using time and date ranges in combination with aggregations or calculations, you can build meaningful comparisons across comparable time periods for sales, inventory, and so on. To learn more, see Time intelligence functions (DAX).\n\nThese functions return a table or manipulate existing tables. For example, by using ADDCOLUMNS you can add calculated columns to a specified table, or you can return a summary table over a set of groups with the SUMMARIZECOLUMNS function. To learn more, see Table manipulation functions.\n\nYou can create variables within an expression by using VAR. VAR is technically not a function, it's a keyword to store the result of an expression as a named variable. That variable can then be passed as an argument to other measure expressions. For example:\n\nIn this example, TotalQty can be passed as a named variable to other expressions. Variables can be of any scalar data type, including tables. Using variables in your DAX formulas can be incredibly powerful.\n\nYou can import data into a model from many different data sources that might support different data types. When you import data into a model, the data is converted to one of the tabular model data types. When the model data is used in a calculation, the data is then converted to a DAX data type for the duration and output of the calculation. When you create a DAX formula, the terms used in the formula will automatically determine the value data type returned.\n\nTabular data models also include the Table data type as the input or output to many DAX functions. For example, the FILTER function takes a table as input and outputs another table that contains only the rows that meet the filter conditions. By combining table functions with aggregation functions, you can perform complex calculations over dynamically defined data sets.\n\nWhile data types are typically automatically set, it is important to understand data types and how they apply, in-particular, to DAX formulas. Errors in formulas or unexpected results, for example, are often caused by using a particular operator that cannot be used with a data type specified in an argument. For example, the formula, , returns a string result of 12. The formula, , however, returns an integer result of 3.\n\nContext is an important concept to understand when creating DAX formulas. Context is what enables you to perform dynamic analysis, as the results of a formula change to reflect the current row or cell selection and also any related data. Understanding context and using context effectively are critical for building high-performing, dynamic analyses, and for troubleshooting problems in formulas.\n\nFormulas in tabular models can be evaluated in a different context, depending on other design elements:\n• Relationships specified by using special functions within a formula\n\nThere are different types of context: row context, query context, and filter context.\n\nRow context can be thought of as \"the current row\". If you create a formula in a calculated column, the row context for that formula includes the values from all columns in the current row. If the table is related to another table, the content also includes all the values from the other table that are related to the current row.\n\nFor example, suppose you create a calculated column, , that adds together values from two columns, Freight and Tax, from the same table. This formula automatically gets only the values from the current row in the specified columns.\n\nRow context also follows any relationships that have been defined between tables, including relationships defined within a calculated column by using DAX formulas, to determine which rows in related tables are associated with the current row.\n\nFor example, the following formula uses the RELATED function to fetch a tax value from a related table, based on the region that the order was shipped to. The tax value is determined by using the value for region in the current table, looking up the region in the related table, and then getting the tax rate for that region from the related table.\n\nThis formula gets the tax rate for the current region from the Region table and adds it to the value of the Freight column. In DAX formulas, you do not need to know or specify the specific relationship that connects the tables.\n\nDAX includes functions that iterate calculations over a table. These functions can have multiple current rows, each with its own row context. In essence, these functions let you create formulas that perform operations recursively over an inner and outer loop.\n\nFor example, suppose your model contains a Products table and a Sales table. Users might want to go through the entire sales table, which is full of transactions involving multiple products, and find the largest quantity ordered for each product in any one transaction.\n\nWith DAX you can build a single formula that returns the correct value, and the results are automatically updated any time a user adds data to the tables.\n\nFor a detailed example of this formula, see EARLIER.\n\nTo summarize, the EARLIER function stores the row context from the operation that preceded the current operation. At all times, the function stores in memory two sets of context: one set of context represents the current row for the inner loop of the formula, and another set of context represents the current row for the outer loop of the formula. DAX automatically feeds values between the two loops so that you can create complex aggregates.\n\nQuery context refers to the subset of data that is implicitly retrieved for a formula. For example, when a user places a measure or field into a report, the engine examines row and column headers, slicers, and report filters to determine the context. The necessary queries are then run against model data to get the correct subset of data, make the calculations defined by the formula, and then populate values in the report.\n\nBecause context changes depending on where you place the formula, the results of the formula can also change. For example, suppose you create a formula that sums the values in the Profit column of the Sales table: . If you use this formula in a calculated column within the Sales table, the results for the formula will be the same for the entire table, because the query context for the formula is always the entire data set of the Sales table. Results will have profit for all regions, all products, all years, and so on.\n\nHowever, users typically don't want to see the same result hundreds of times, but instead want to get the profit for a particular year, a particular country, a particular product, or some combination of these, and then get a grand total.\n\nIn a report, context is changed by filtering, adding or removing fields, and using slicers. For each change, the query context in which the measure is evaluated. Therefore, the same formula, used in a measure, is evaluated in a different query context for each cell.\n\nFilter context is the set of values allowed in each column, or in the values retrieved from a related table. Filters can be applied to the column in the designer, or in the presentation layer (reports and PivotTables). Filters can also be defined explicitly by filter expressions within the formula.\n\nFilter context is added when you specify filter constraints on the set of values allowed in a column or table, by using arguments to a formula. Filter context applies on top of other contexts, such as row context or query context.\n\nIn tabular models, there are many ways to create filter context. Within the context of clients that can consume the model, such as Power BI reports, users can create filters on the fly by adding slicers or report filters on the row and column headings. You can also specify filter expressions directly within the formula, to specify related values, to filter tables that are used as inputs, or to dynamically get context for the values that are used in calculations. You can also completely clear or selectively clear the filters on particular columns. This is very useful when creating formulas that calculate grand totals.\n\nTo learn more about how to create filters within formulas, see the FILTER Function (DAX). For an example of how filters can be cleared to create grand totals, see the ALL Function (DAX).\n\nFor examples of how to selectively clear and apply filters within formulas, see ALLEXCEPT.\n\nWhen you create a DAX formula, the formula is first tested for valid syntax, and then tested to make sure the names of the columns and tables included in the formula can be found in the current context. If any column or table specified by the formula cannot be found, an error is returned.\n\nContext during validation (and recalculation operations) is determined as described in the preceding sections, by using the available tables in the model, any relationships between the tables, and any filters that have been applied.\n\nFor example, if you have just imported some data into a new table and it is not related to any other tables (and you have not applied any filters), the current context is the entire set of columns in the table. If the table is linked by relationships to other tables, the current context includes the related tables. If you add a column from the table to a report that has Slicers and maybe some report filters, the context for the formula is the subset of data in each cell of the report.\n\nContext is a powerful concept that can also make it difficult to troubleshoot formulas. We recommend that you begin with simple formulas and relationships to see how context works. The following section provides some examples of how formulas use different types of context to dynamically return results.\n\nThe DAX language uses four different types of calculation operators in formulas:\n• Comparison operators to compare values and return a logical `FALSE` value.\n• Text concatenation operators to join two or more text strings.\n• Logical operators that combine two or more expressions to return a single result.\n\nFor detailed information about operators used in DAX formulas, see DAX operators.\n\nTables in tabular data models look like Excel tables, but are different in the way they work with data and with formulas:\n• Formulas work only with tables and columns, not with individual cells, range references, or arrays.\n• Formulas can use relationships to get values from related tables. The values that are retrieved are always related to the current row value.\n• You cannot have irregular or \"ragged\" data like you can in an Excel worksheet. Each row in a table must contain the same number of columns. However, you can have empty values in some columns. Excel data tables and tabular model data tables are not interchangeable.\n• Because a data type is set for each column, each value in that column must be of the same type.\n\nReferring to tables and columns in formulas\n\nYou can refer to any table and column by using its name. For example, the following formula illustrates how to refer to columns from two tables by using the fully qualified name:\n\nWhen a formula is evaluated, the model designer first checks for general syntax, and then checks the names of columns and tables that you provide against possible columns and tables in the current context. If the name is ambiguous or if the column or table cannot be found, you will get an error on your formula (an #ERROR string instead of a data value in cells where the error occurs). To learn more about naming requirements for tables, columns, and other objects, see Naming Requirements in DAX syntax.\n\nBy creating relationships between tables, you gain the ability for related values in other tables to be used in calculations. For example, you can use a calculated column to determine all the shipping records related to the current reseller, and then sum the shipping costs for each. In many cases, however, a relationship might not be necessary. You can use the LOOKUPVALUE function in a formula to return the value in result_columnName for the row that meets criteria specified in the search_column and search_value arguments.\n\nMany DAX functions require that a relationship exist between the tables, or among multiple tables, in order to locate the columns that you have referenced and return results that make sense. Other functions will attempt to identify the relationship; however, for best results you should always create a relationship where possible. Tabular data models support multiple relationships among tables. To avoid confusion or incorrect results, only one relationship at a time is designated as the active relationship, but you can change the active relationship as necessary to traverse different connections in the data in calculations. USERELATIONSHIP function can be used to specify one or more relationships to be used in a specific calculation.\n\nIt's important to observe these formula design rules when using relationships:\n• None When tables are connected by a relationship, you must ensure the two columns used as keys have values that match. Referential integrity is not enforced, therefore it is possible to have non-matching values in a key column and still create a relationship. If this happens, you should be aware that blank values or non-matching values might affect the results of formulas.\n• None When you link tables in your model by using relationships, you enlarge the scope, or context, in which your formulas are evaluated. Changes in context resulting from the addition of new tables, new relationships, or from changes in the active relationship can cause your results to change in ways that you might not anticipate. To learn more, see Context in this article.\n\nProcess and recalculation are two separate but related operations. You should thoroughly understand these concepts when designing a model that contains complex formulas, large amounts of data, or data that is obtained from external data sources.\n\nProcess (refresh) is updating the data in a model with new data from an external data source.\n\nRecalculation is the process of updating the results of formulas to reflect any changes to the formulas themselves and to reflect changes in the underlying data. Recalculation can affect performance in the following ways:\n• None The values in a calculated column are computed and stored in the model. To update the values in the calculated column, you must process the model using one of three processing commands – Process Full, Process Data, or Process Recalc. The result of the formula must always be recalculated for the entire column, whenever you change the formula.\n• None The values calculated by measures are dynamically evaluated whenever a user adds the measure to a PivotTable or open a report; as the user modifies the context, values returned by the measure change. The results of the measure always reflect the latest in the in-memory cache.\n\nProcessing and recalculation have no effect on row-level security formulas unless the result of a recalculation returns a different value, thus making the row queryable or not queryable by role members.\n\nDAX is constantly being improved. New and updated functions are released with the next available update, which is usually monthly. Services are updated first, followed by installed applications like Power BI Desktop, Excel, SQL Server Management Studio (SSMS), and Analysis Services project extension for Visual Studio (SSDT). SQL Server Analysis Services is updated with the next cumulative update. New functions are first announced and described in the DAX function reference coinciding with Power BI Desktop updates.\n\nNot all functions are supported in earlier versions of SQL Server Analysis Services and Excel.\n\nIf you get an error when defining a formula, the formula might contain either a syntactic error, semantic error, or calculation error.\n\nSyntactic errors are the easiest to resolve. They typically involve a missing parenthesis or comma.\n\nThe other type of error occurs when the syntax is correct, but the value or a column referenced does not make sense in the context of the formula. Such semantic and calculation errors might be caused by any of the following problems:\n• The formula refers to a non-existing column, table, or function.\n• The formula appears to be correct, but when the data engine fetches the data, it finds a type mismatch and raises an error.\n• The formula passes an incorrect number or type of arguments to a function.\n• The formula refers to a different column that has an error, and therefore its values are invalid.\n• The formula refers to a column that has not been processed, meaning it has metadata but no actual data to use for calculations.\n\nIn the first four cases, DAX flags the entire column that contains the invalid formula. In the last case, DAX grays out the column to indicate that the column is in an unprocessed state.\n\nPower BI Desktop is a free data modeling and reporting application. The model designer includes a DAX editor for creating DAX calculation formulas.\n\nThe Power Pivot in Excel models designer includes a DAX editor for creating DAX calculation formulas.\n\nVisual Studio with Analysis Services projects extension (VSIX) is used to create Analysis Services model projects. Tabular model designer, installed with the projects extension includes a DAX editor.\n\nSQL Server Management Studio (SSMS) is an essential tool for working with Analysis Services. SSMS includes a DAX query editor for querying both tabular and multidimensional models.\n\nDAX Studio is an open-source client tool for creating and running DAX queries against Analysis Services, Power BI Desktop, and Power Pivot in Excel models.\n\nTabular Editor is an open-source tool that provides an intuitive, hierarchical view of every object in tabular model metadata. Tabular Editor includes a DAX Editor with syntax highlighting, which provides an easy way to edit measures, calculated column, and calculated table expressions.\n\nWhen learning DAX, it's best to use the application you'll be using to create your data models. Analysis Services, Power BI Desktop, and Power Pivot in Excel all have articles and tutorials that include lessons on creating measures, calculated columns, and row-filters by using DAX. Here are some additional resources:\n\nThe Definitive Guide to DAX by Alberto Ferrari and Marco Russo (Microsoft Press). Now in its second edition, this extensive guide provides basics to innovative high-performance techniques for beginning data modelers and BI professionals.\n\nDAX has a vibrant community always willing to share their expertise. Microsoft Power BI Community has a special discussion forum just for DAX, DAX Commands and Tips."
    },
    {
        "link": "https://community.powerbi.com/t5/Desktop/Power-BI-Dax-to-find-max-value-date-based-on-two-other-columns/td-p/2670390",
        "document": "Hi All,\n\nI have a Table Shown Below. I need a Dax Formula that will look for IDofPledge (A2), through Column Linkedgift_id (B3:B7) and returns the Max(Date) of Column DateOfInstallment (C7) in the column InstallmentEndingOn (D2).\n\nI have tried creating a Dax column using the Dax Code below, but it doesn't seem to work.\n\nHow do I correct the DAX in order to compare A2 with B3:B7, and to bring C7 in D2 ?\n\nI have scoured the web looking for an answer on this topic and I tried different Filter Arguments, with no success. What am I doing Wrong? Thank You!"
    },
    {
        "link": "https://dev4side.com/en/blog/intro-dax-power-bi",
        "document": "What is the DAX formula in Power BI\n\nDAX formulas play a fundamental role in Power BI to create calculations in both calculated columns and measures. In addition, DAX is critical for implementing row-level security measures to protect data in reports and dashboards.\n\nDecomposing a formula into its constituent elements facilitates a deeper understanding of any language. It is crucial to carefully study the syntax of these expressions to effectively create new formulas based on specific requirements.\n\nTo formulate calculated columns and measures, use the formula bar located at the top of the design model window or use the DAX Editor tool. To establish row-level security formulas, log in to the Role Manager or the Role Management dialog box. The information presented in this section is intended to provide you with a basic understanding of the DAX formulas in Power BI.\n\nHow to write a DAX formula in Power BI\n\nUnderstanding DAX formulas in Power BI is simple because of their intuitive and readable nature. This makes it quick to learn the basic concepts of DAX and start creating your own formulas. Let's explore the basic elements that make up proper DAX syntax:\n• The name of the calculated measure or column\n• The assignment operator (“=”) that indicates the beginning of the formula\n\nNote that each subsequent parameter in a function is separated by a comma (“,”).\n\nWhen you insert a formula into a calculated column and it is successfully validated, the column is instantly populated with the calculated values. In the case of measurements, pressing ENTER saves the definition of the measure together with the table. If there is an error in the formula, an error notification appears.\n\nDAX functions in Power BI can be nested inside each other to perform multiple operations efficiently, which can greatly simplify the process of writing DAX formulas. For example, nesting multiple IF statements or using functions like IFERROR to encapsulate another function allows you to handle errors elegantly and customize error outputs as needed. This approach improves formula clarity and operational efficiency in Power BI and similar environments.\n\nSome of the DAX functions commonly used in reports include:\n• SUMMARIZE: Returns a table often used to perform additional aggregations on different groupings or subsets of data.\n\n‍\n• CALCULATE: Perform an aggregation by applying one or more filters. When multiple filters are specified, the function performs the specific calculation, only when all the specified filters are met. It allows you to modify the filter context, giving you the option to choose the filter contex.\n\n‍\n• IF: Based on a logical condition, this function provides a different result depending on whether the condition evaluates to true or false. It works in a similar way to the CASE WHEN operation commonly seen in SQL queries.\n\n‍\n• IFERROR: Checks for errors within an internal function and returns a specified result if an error is found.\n\n‍\n• ISBLANK: Tests if the rows in a column are empty and returns true or false. This function is useful when combined with other functions such as IF to conditionally handle empty values.\n\n‍\n• EOMONTH: Returns the last day of the month based on a supplied date (indicated in a column formatted as a date), looking back or forward for a specified number of months.\n\n‍\n• DATEDIFF: Returns the difference between two dates, both indicated as date columns, in terms of days, months, quarters, years, or other specified units.\n\n‍\n\nNow let's take a practical example of a formula and break it down step by step. The formula in question is called 'Days in the current quarter':\n\nThis measure calculates a comparison ratio between a partial period and the previous period. The formula adapts to the portion of the period that has passed and compares it with the corresponding portion in the previous period. Specifically, divide [Days Current Quarter to Date] by [Days in Current Quarter] to determine the elapsed proportion of the current period.\n\nWhat is a DAX function in Power BI\n\nA function in an expression is a formula defined with a specific name. Functions typically include mandatory and optional arguments, also called parameters, that serve as input. These parameters can be numeric values, constants, text strings, other functions or formulas, and logical values such as True or False. When a function is executed, it produces a value as a result. DAX includes a variety of functions designed to perform calculations involving dates and times, generate conditional values, manipulate strings, perform relationship-based searches, and iterate over tables to perform recursive calculations.\n\nAlthough Excel formulas may seem familiar, DAX functions differ significantly in two key ways:\n• DAX functions always refer to entire columns or tables. If you need specific values from a table or column, you can add filters to the formula to achieve this granularity.\n\n‍\n• For custom row-level calculations, DAX offers functions that allow the use of current row values or related values, similar to parameters. This flexibility allows you to perform context-sensitive calculations that adapt to varying conditions.\n\nDAX includes several functions that return a table instead of a single value. These tables are generally not displayed directly in a reporting client, but serve as input for subsequent functions. For example, it is possible to retrieve a table and then calculate the count of distinct values within it, or dynamically sum the values through filtered tables or columns.\n\nDAX functions include a range of temporal intelligence capabilities. These functions allow you to define or select date ranges and facilitate dynamic calculations based on these dates or intervals. For example, it is possible to compare sums between corresponding periods.\n\nLet's take a look at some types of DAX functions in Power BI and some examples with their syntax.\n\nAlthough the date and time functions in DAX are similar to those in Microsoft Excel, they operate using a datetime data type that begins on March 1, 1900. This distinction differentiates DAX functions in terms of data management and calculations involving dates and times. Here are some examples of a date and time function.\n\nThe start-date and end-date arguments can accept any DateTime value. The function returns a table consisting of a single column containing a sequence of dates within the specified range.\n\nThe DATEDIFF function calculates the difference between two dates based on the interval units specified by the user.\n\nThe function returns the current value of the date and time in the standard format.\n\nThe DAX aggregation functions calculate a scalar value, such as a count, sum, average, minimum, or maximum, on all rows in a column or table as determined by the specified expression.\n\nThe time intelligence capabilities available in DAX allow the creation of calculations that take advantage of the built-in capabilities related to calendars and dates. Using time frames and dates together with aggregations or calculations, it is possible to build meaningful comparisons between equivalent time periods, such as sales trends and inventory analysis.\n\nThese functions are primarily used to calculate aggregations, manipulate data and develop Business Intelligence solutions using a date table as input.\n\nThe filter functions in DAX are designed to retrieve specific types of data, perform search operations between related tables, and filter data based on associated values. These search mechanisms operate in a similar way to database queries, taking advantage of table structures and defined relationships. Filter functions are crucial for data analysts, as they allow them to dynamically adjust the context of the data and facilitate complex calculations according to the requirements of the analysis.\n\nDAX offers a series of financial functions designed to perform calculations such as net present value and rate of return. These functions reflect the financial instruments found in Microsoft Excel, providing robust capabilities for financial analysis within Power BI and other related environments.\n\nIn Power BI, logical functions evaluate expressions to provide information about the values within the expression. For example, the TRUE function determines if the evaluated expression produces a TRUE value. Some of these features include: DAX AND, DAX OR, DAX IF, DAX SWITCH.\n\nAn information function examines the specified cell or row and indicates if the value matches the expected type. For example, the ISERROR function returns TRUE when the reference value contains an error.\n\nThe mathematical functions in DAX are very similar to the mathematical and trigonometric functions in Excel, with slight variations in the types of numerical data. These functions are essential for performing a variety of calculations within Power BI.\n\nThe statistical functions in DAX calculate values associated with statistical distributions and probabilities, such as standard deviation and permutations. These functions are essential for executing DAX expressions within statistical models and aggregations.\n\nThese functions can generate a new table or modify existing tables. For example, the ADDCOLUMNS function allows you to add calculated columns to a designated table, while the SUMMARIZECOLUMNS function produces a summary table through specified groups.\n\nDAX formulas in Power BI are responsive and adapt based on the source context. Understanding how the context works in DAX is crucial for resolving errors in formulas and ensuring accurate calculations.\n\nDAX operates within two main contexts: the row context and the filter context. Familiarity with these contexts is essential to effectively manage relationships between data and optimize formula results.\n\nThis concept refers to the 'current row', which includes all the columns within a table and also extends to related tables. This context informs the DAX formula about the specific lines to include when executing a formula.\n\nLet's take the following formula as an example:\n\nIn calculating the Cost Price Per Unit, DAX operates on a line-by-line basis. This means that DAX must identify the current row as it iterates through the dataset, performing the calculation and populating the new column with the resulting values.\n\nThe row context is intrinsic to the calculated columns because the calculations are performed individually for each row, automatically establishing the row context. However, this is different for measures where aggregations apply to all rows in the table. In measures, there is no concept of a current row because calculations aggregate all rows collectively.\n\nNow let's see an example of a DAX measurement formula:\n\nIn this case, a single figure is derived by adding the Profit column and then dividing by the sum of the Sales column. Because DAX performs aggregation, it doesn't require row-specific information, meaning that this measure has no row context.\n\nTo establish line context within a measure, you must use specialized functions known as iterators. Examples of these include SUMX, AVERAGEX, COUNTX. These iterators calculate the operations line by line and aggregate the results (such as sum, average, count, etc.). This approach explicitly defines the line context through the use of these iterator functions.\n\nThe following is an example of an iterator function:\n\nIn this example, two calculations are performed: first, the expression is evaluated line by line and then the result is used in the AVERAGE function. An alternative method to achieve the same result is to first create a calculated column called 'Cost Price Per Unit', as shown above, and then establish a separate measure of AVERAGE for that column. The effective use of iterator functions not only improves the efficiency of your reports, but also optimizes memory usage by allowing you to perform two calculations with a single formula.\n\nThe filter context integrates a row context by specifying a subset of rows or columns as filters within the report. These filters can be applied in a variety of ways:\n• Through the fields that make up a visual (such as rows and columns in a matrix)\n\nAn effective method for introducing a filter context into a DAX formula is the use of the CALCULATE function. This function allows you to add one or more filter parameters to a measure. For example, in the following example, let's create a profit margin measure filtered specifically for Italy:\n\nIn summary, DAX in Power BI stands out as a robust formula language that can handle data modeling, improve data insights, and effectively present measures within Power BI visualizations.\n\nWe've looked at what a DAX formula is in Power BI and its syntax, as well as DAX functions and some examples of them. We also discussed the importance of context in DAX formulas. Now, equipped with these fundamental DAX tools, we're only scratching the surface of what DAX can do.\n\nArming yourself with these basic DAX techniques means starting to discover the immense capabilities of this language. With a wealth of 250 features waiting to be explored, mastering DAX represents a formidable challenge and an extremely rewarding journey.\n\nWhat is DAX in Power BI?\n\nDAX (Data Analysis Expressions) is a formula language used in Power BI, Excel Power Pivot, and Analysis Services. It is designed to perform data analysis and calculations on data models, allowing users to create new information from existing data.\n\nDAX enhances Power BI by enabling users to create custom calculations and aggregations, build complex measures, and create calculated columns. This functionality allows for deeper insights and more sophisticated data analysis within reports and dashboards.\n\nWhat are some key features of DAX?\n• Functions for date and time, filtering, information, and mathematical calculations\n• Contextual calculations that consider row and filter context\n\nCan DAX be used with other Microsoft products?\n\nYes, DAX can be used with other Microsoft products such as Excel Power Pivot and SQL Server Analysis Services (SSAS). This allows for a consistent approach to data analysis across different tools and platforms.\n\nWhat are some common DAX functions?\n• CALCULATE: Changes the context in which data is evaluated\n• SUM: Adds up all the numbers in a column\n• RELATED: Retrieves a related value from another table\n• FILTER: Returns a table that has been filtered\n\nHow can one learn DAX effectively?\n• Understanding the basics of data modeling and relationships in Power BI\n• Utilizing resources such as Microsoft's official documentation, online tutorials, and community forums\n• Experimenting with different DAX functions and their combinations to see how they affect data analysis\n\nWhat are some best practices for using DAX in Power BI?\n\nSome best practices for using DAX in Power BI include:\n• Using measures instead of calculated columns where possible for better performance\n• Testing DAX expressions thoroughly to ensure they return expected results"
    },
    {
        "link": "https://community.powerbi.com/t5/Desktop/DAX-measure-for-comparing-MAX-dates-with-conditional-column/td-p/2605155",
        "document": "I'm not sure the title here best describes my predicament and I'm having trouble finding the right search terms, so forgive me if the solution to this is right under my nose here in the forums.\n\n\n\nI am trying to sum the number of loads on a shipping schedule and filter it by only loads that have been invoiced. So I need to compare the MAX date in the DirectCosts table to the MAX date on the ShippingCalendar table, but I want to apply this filter by Cost Code so that I know how many loads of each cost code have been paid already.\n\nHere are some sample tables:\n\n\n\nDirectCosts\n\nBoth tables are joined on a CostCodes table where CostCode is the Primary Key.\n\n\n\n\n\nI thought maybe a simple CALCULATE function would do the trick, but it's not returning any values.\n\nThe table visual I'm looking for should look like this:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dax/best-practices/dax-variables",
        "document": "Use variables to improve your DAX formulas\n\nAs a data modeler, writing and debugging some DAX calculations can be challenging. It's common that complex calculation requirements often involve writing compound or complex expressions. Compound expressions can involve the use of many nested functions, and possibly the reuse of expression logic.\n\nUsing variables in your DAX formulas can help you write more complex and efficient calculations. Variables can improve performance, reliability, readability, and reduce complexity.\n\nIn this article, we'll demonstrate the first three benefits by using an example measure for year-over-year (YoY) sales growth. (The formula for YoY sales growth is period sales, minus sales for the same period last year, divided by sales for the same period last year.)\n\nLet's start with the following measure definition.\n\nThe measure produces the correct result, yet let's now see how it can be improved.\n\nNotice that the formula repeats the expression that calculates \"same period last year\". This formula is inefficient, as it requires Power BI to evaluate the same expression twice. The measure definition can be made more efficient by using a variable, VAR.\n\nThe following measure definition represents an improvement. It uses an expression to assign the \"same period last year\" result to a variable named SalesPriorYear. The variable is then used twice in the RETURN expression.\n\nThe measure continues to produce the correct result, and does so in about half the query time.\n\nIn the previous measure definition, notice how the choice of variable name makes the RETURN expression simpler to understand. The expression is short and self-describing.\n\nVariables can also help you debug a formula. To test an expression assigned to a variable, you temporarily rewrite the RETURN expression to output the variable.\n\nThe following measure definition returns only the SalesPriorYear variable. Notice how it comments-out the intended RETURN expression. This technique allows you to easily revert it back once your debugging is complete.\n\nIn earlier versions of DAX, variables were not yet supported. Complex expressions that introduced new filter contexts were required to use the EARLIER or EARLIEST DAX functions to reference outer filter contexts. Unfortunately, data modelers found these functions difficult to understand and use.\n\nVariables are always evaluated outside the filters your RETURN expression applies. For this reason, when you use a variable within a modified filter context, it achieves the same result as the EARLIEST function. The use of the EARLIER or EARLIEST functions can therefore be avoided. It means you can now write formulas that are less complex, and that are easier to understand.\n\nConsider the following calculated column definition added to the Subcategory table. It evaluates a rank for each product subcategory based on the Subcategory Sales column values.\n\nThe EARLIER function is used to refer to the Subcategory Sales column value in the current row context.\n\nThe calculated column definition can be improved by using a variable instead of the EARLIER function. The CurrentSubcategorySales variable stores the Subcategory Sales column value in the current row context, and the RETURN expression uses it within a modified filter context.\n• Questions? Try asking the Power BI Community"
    },
    {
        "link": "https://sqlbi.com/articles/variables-in-dax",
        "document": "Variables were introduced in DAX in 2015 and so far, they have proven to be the best enhancement of the DAX language ever. When presented with the concept of variables, most newbies focus on performance improvement, thinking that you introduce variables in your code mainly to obtain better performance. Although variables can improve performance, performance is a minor advantage. There are several more important considerations that should encourage any DAX developer to make extensive use of variables. In this article we share a few considerations, along with best practices about variables and DAX.\n\nLet us start with the syntax. You can define a variable in any DAX expression by using VAR followed by RETURN. In one or several VAR sections, you individually declare the variables needed to compute the expression; in the RETURN part you provide the expression itself.\n\nThis simple formula includes the definition of two variables:\n\nThe SalesAmount variable contains the dollar amount of sales computed through SUMX, whereas the NumCustomer variable contains the number of customers, as the DISTINCTCOUNT of Sales[CustomerKey].\n\nThe two variables are used in the RETURN part, where we divide one by the other. The result of the entire expression is the RETURN part.\n\nYou can think about a variable as a name for an expression. The term “variable” itself is somewhat misleading – a DAX variable cannot change its value, as the name would suggest. A DAX variable is indeed a constant, meaning that it is a name for the value computed by the definition of the variable.\n\nEach set of VAR / RETURN can include multiple variables, you can have any number of VAR for one RETURN. Moreover, the definition of a variable can reference other variables provided that the other variables have been defined beforehand – either within the same block or in an outer block. As this last statement suggests, VAR statements can be nested. For example, the previous expression can be written by using more variables in the following, quite verbose way:\n\nThe Quantity and Price variables are not really useful in this example. Yet they help show that you can define variables anywhere in a DAX formula. The VAR / RETURN set replaces an expression, so it can be used wherever an expression is allowed. This is not a very common technique. Mostly, you will see a DAX formula containing an initial set of variable declarations, followed by a single RETURN statement. Regardless, there are cases where for rather complex code the generous use of VAR / RETURN comes handy.\n\nVariables are useful for several reasons:\n• Readability of the code. By assigning a name to an expression you are effectively adding descriptive information to your code, making it easier to read it.\n• Split of the execution into logical steps. Our brain processes expressions containing variables better, because variables provide execution steps. In the previous code, you might think that SalesAmount is computed first, then NumCustomer, and finally the result. Despite this not being true, variables still help read and understand the code.\n• Easier debugging of the code. You can inspect the value of variables using professional debuggers, like the Tabular Editor 3 debugger, or you can return the value of a variable in a complex measure to inspect the intermediate evaluations.\n• Better performance. Using variables, you instruct the DAX optimizer on which parts of the entire expression can be computed once and saved for later use. The value of a variable is computed only once, whereas repeating the same sub-expression in multiple places does not guarantee a unique execution of that piece of code.\n\nThough newbies do not use a lot of variables, seasoned DAX developers get used to starting most measures with VAR! The reason is that any non-trivial measure requires different steps and by splitting the entire calculation into steps, they can better focus on simpler problems. In terms of mindset, it really makes a difference to start thinking about a complex calculation with this sentence: “First, I need a variable with this value, then I will focus on the next steps”.\n\nWe could provide tons of examples of code that is more readable with variables than without variables. Nonetheless, those would be just ad-hoc examples. We think that the best way to appreciate how much we at SQLBI value the relevance of variables, is to browse our articles. We use variables everywhere, for very good reasons.\n\nOne important detail about variables, though not clear at first sight, is that variables can contain tables too. While it is intuitive to consider a variable for a scalar value, it is less intuitive to also consider variables when wanting to store tables.\n\nLook for example at the following piece of DAX code:\n\nThere are several important considerations to be made about this small piece of code.\n\nThe first is that you read it as two separate steps: you would think DAX first computes the BestProducts variable, and then performs an iteration over its content while computing the second variable, SalesOfBestProducts. As we said, this is not true; DAX uses a different execution pattern. Nonetheless, it helps understand the flow.\n\nThe BestProducts variable contains the result of TOPN, which is a table. BestProducts contains the top 10 products ordered by Sales Amount. BestProducts is a table variable.\n\nDuring the evaluation of the SalesOfBestProducts variable, the measure iterates over BestProducts. Then, for each row of BestProducts the measure scans the related sales, during the SUMX over RELATEDTABLE. RELATEDTABLE requires relationships to be in place in order to work. As a matter of fact, a variable containing a table inherits the relationships of the base tables of the columns it contains. Because BestProducts contains rows from Product, it inherits the relationship between Product and Sales. Hence, RELATEDTABLE works just fine.\n\nThe second, non-trivial consideration is that the innermost SUMX computes Sales[Quantity] times Product[Unit Price]. Sales is in the row context, introduced by the innermost SUMX. Product seems to not be in the row context – the outermost SUMX is iterating BestProducts. It would seem intuitive to refer to the Unit Price column in BestProducts as BestProducts[Unit Price]. Unfortunately, this syntax is not available. In order to reference a column inside a variable, you need to reference the column name with the base table prefix. Hence, instead of using BestProducts[Unit Price], you need to use Product[Unit Price].\n\nIn the very special case where a column belongs to a variable but is created inside the measure, say by using ADDCOLUMNS, then you cannot specify a table name. This is the only case where our very strict rules about readability allow the developer to reference a column without the table name prefixed, rather than using the formally corrected but less readable syntax ”[column] using an empty table name as a prefix.\n\nThe last important details about variables is that they represent a certain value when they are defined, and they are never computed again after. In our courses we assist with countless questions from DAX developers that do not understand why replacing an expression with a variable changes the result. Consider for example the following measure:\n\nThe SUMX expression appears twice, identical. It looks like a good candidate for a variable. Unfortunately, it is not. If you change the code by introducing a variable, the measure computes an incorrect result:\n\nPCT (Wrong) returns a constant value of 1. The reason is that the SalesAmount variable is computed once and never again. It does not matter that the second reference to SalesAmount is inside a CALCULATE that removes the filter from Product. Its value has already been computed and it does not change depending on the filter context. You can replace subexpressions with variables, but only if you checked that the subexpressions are computed in the same filter context.\n\nDuring our courses, when it is time to talk about variables, we provide a simple rule: whenever you are in doubt about whether to define a variable or not, define the variable. The answer to the question: “is it better to write the code or use a variable here?” should always be to create a variable.\n\nThere are some very specific scenarios where a variable can actually negatively impact performance, because it sometimes forces an eager evaluation of conditional statements. These are rare, so our suggestion to new DAX developers remains to use as many variables as you can. Over time, your future self will thank you because you used so many variables and made the code so much easier to read.\n• Previous year up to a certain date\n• Using RELATED and RELATEDTABLE in DAX"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dax/var-dax",
        "document": "Stores the result of an expression as a named variable, which can then be passed as an argument to other measure expressions. Once resultant values have been calculated for a variable expression, those values do not change, even if the variable is referenced in another expression.\n\nA named variable containing the result of the expression argument.\n• None An expression passed as an argument to VAR can contain another VAR declaration.\n• \n• Measures cannot refer to variables defined outside the measure expression, but can refer to functional scope variables defined within the expression.\n• Columns in table variables cannot be referenced via TableName[ColumnName] syntax.\n• None For best practices when using VAR, see Use variables to improve your DAX formulas.\n• None To learn more about how VAR is used within a DAX Query, see DAX queries.\n\nTo calculate a percentage of year-over-year growth without using a variable, you could create three separate measures. This first measure calculates Sum of Sales Amount:\n\nA second measure calculates the sales amount for the previous year:\n\nYou can then create a third measure that combines the other two measures to calculate a growth percentage. Notice the Sum of SalesAmount measure is used in two places; first to determine if there is a sale, then again to calculate a percentage.\n\nBy using a variable, you can create a single measure that calculates the same result:\n\nBy using a variable, you can get the same outcome, but in a more readable way. And because the result of the expression is stored in the variable, the measure's performance can be significantly improved because it doesn't have to be recalculated each time it's used.\n\nUse variables to improve your DAX formulas DAX queries"
    },
    {
        "link": "https://maqsoftware.com/insights/dax-best-practices.html",
        "document": "This guide enables you to speed up your Power BI reports by optimizing their back-end code. As the 2021 Microsoft Power BI Partner of the Year, we have proven expertise in implementing business intelligence and analytics solutions.\n\nBased on our experience, we have compiled these best practices in the following categories:\n\nClear your DAX cache before optimizing DAX as your DAX cache builds up from internal VertiPaq queries. You can clear your cache from DAX Studio. Resetting your cache also enables you to measure performance gains more effectively.\n• Use DAX Formatter to format your code Formatted code is easier to read and maintain. DAX Formatter is a free tool that enables you to transform raw DAX into readable code.\n• Use the DISTINCT() and VALUES() functions consistently Power BI adds a blank value to a column if it finds a referential integrity violation. When making direct queries, Power BI adds a blank value to columns because it cannot check for violations. DISTINCT() and VALUES() functions are different:\n• DISTINCT(): Does not return any blanks added due to an integrity violation. The DISTINCT() function includes a blank only if it is part of the original data.\n• VALUES(): Returns both blanks from the original data and blanks that Power BI added due to referential integrity violations. Be consistent in your use of the DISTINCT() and VALUES() functions throughout the entire report. Otherwise, you’ll have inconsistent values for blank columns. We recommend using the VALUES() function if blank values are not an issue.\n• Add column and measure references in your DAX expressions To ensure your DAX code/syntax/etc. can be understood and used by anyone, you need to eliminate ambiguity. By adding column and measure references, you ensure that anyone can easily read your DAX at a glance. We recommend always using fully qualified column references and never using fully qualified measure references. That way, you can quickly differentiate between a column or a measure based on whether it’s fully qualified. Adding column and measure references also ensures that expressions work when a measure home table is changed. Reuse the measure instead of writing the same code. Exercise caution when you have different aggregations and multiple CALCULATE functions.\n• Use friendly names and add description for measures Make sure measure and column names are user friendly.\n\nThere is no problem in adding spaces in the names as they should be self-explanatory. Users shouldn’t have to search for its definition. Add a description in the modelling view to provide additional information about the measure.\n• Use ISBLANK() instead of =Blank() check Use the built-in function ISBLANK() to check for any blank values instead of using the comparison operator = Blank(). While = Blank() returns ‘True’ value for either blank values or empty strings, IsBlank exclusively checks for blanks.\n• Use = 0 instead of checking for ISBLANK() || = 0 The BLANK value in Power BI is associated with the base value of a column’s data type. The BLANK value corresponds to “0” for integers, “(empty string)” for string columns, and “1–1–1900” for date fields. ISBLANK() || = 0 enacts two checks: first it checks if a column is BLANK, then it checks for zeroes. = 0 performs both checks at once, improving calculation speed. To check exclusively for zero, use the IN operator.\n• Use SELECTEDVALUE() instead of HASONEVALUE() It is common practice to use HASONEVALUE() to check if there is only one value present in a column after applying slicers and filters. However, when you do this, you also have to use the VALUES(ColumnName) DAX function to retrieve that single value. SELECTEDVALUE() performs the above steps internally. It automatically retrieves the single value if there is one and returns a blank if there are multiple values available.\n• Use SELECTEDVALUE() instead of VALUES() The VALUES() function returns an error if it encounters multiple values. Often, users address the error using Error functions, which negatively affects performance. Instead of using VALUES(), use SELECTEDVALUE(). The SELECTEDVALUE() function returns a blank if it encounters multiple values (instead of an error).\n• Use variables instead of repeating measures inside the IF branch Here, measures are calculated continuously, meaning the [Total Rows] expression is calculated twice: first for the condition check, then for the true condition expression. Instead of calculating the same expression multiple times, you can store the resulting measure value in a variable. You can use a variable reference wherever required. The same variable process applies to all instances where you call the same measure. Variables can help you avoid repetitive functions. Note: Be aware that variables are actually constants.\n• Use DIVIDE() instead of / / raises an exception if the denominator is zero. The DIVIDE() function internally performs a check to validate whether the denominator is zero. If it is, it returns the value specified in a third (extra) parameter. For “invalid denominator” cases, you need to use the IF condition when using the “/” operator. The DIVIDE() function performs IF checks internally. Note: If you are certain the denominator value is not zero, it is better to use the “/” operator without an IF check.\n• Use KEEPFILTERS() instead of FILTER(T) The FILTER function overrides any existing set of filters on a column applied via slicers. The KEEPFILTER function does not override the existing set of filters. Instead, it uses the intersection of values present in both, thus maintaining the current context. Use it when you want to maintain any filters applied by slicers or at a report level while performing calculations.\n• Use FILTER(all(ColumnName)) instead of FILTER(values()) or FILTER(T) To calculate measures independent of any filters applied to a column, combine the All(ColumnName) function with the FILTER function instead of using Table or VALUE(). For example: Use ALL along with the FILTER function if there is no need to keep the current context. Directly applying filters using expressions instead of the FILTER function behaves in the same way as mentioned above. This method internally translates using the ALL function in the filter. For example: It is always better to apply filters to the desired column than to the whole table, as this can easily scale.\n• Use COUNTROWS instead of COUNT In Power BI, you can either use the COUNT function to count column values, or the COUNTROWS function to count table rows. Both functions achieve the same result if the counted column contains no BLANKs. COUNTROWS is usually the better option for three reasons:\n• It's more efficient, and will perform better\n• The formula intention is clearer and self-descriptive\n• Use SEARCH() with the last parameter The SEARCH() DAX function accepts the last parameter as the value that the query must return if the search string is not found. You should always use the SEARCH() function instead of using Error functions along with SEARCH(). ALLEXCEPT() behaves exactly like ALL(), VALUES() as long as the “exempted” columns are columns on the pivot. ALLEXCEPT() does NOT preserve pivot context on columns that are not on the pivot. Use ALL() instead of ALLEXCEPT() when using VALUES()\n• Avoid using the entire table with ALL ALL() can be used with the entire table or with specific columns. Avoid using entire table unless it’s necessary for calculation; the same can be achieved by filtering with a column/columns instead.\n• For virtual relationships, use TREATAS instead of INTERSECT or FILTER A virtual relationship is a DAX pattern to transfer a filter context from one table to another, simulating the behaviour of a physical relationship defined in the data model. The rule of thumb is to always use a physical relationship to propagate filters whenever possible. If you cannot use a physical relationship, you should implement a virtual relationship using TREATAS instead of INTERSECT or FILTER\n• Do not change BLANK values to zeros or other strings It is common practice to replace blanks with zeros or other strings. However, Power BI automatically filters all rows with blank values. When viewing results from tables with large amounts of data, this limits the result set and improves performance. If you replace blanks, Power BI does not filter the unwanted rows, negatively affecting performance.\n• Use (a-b)/b along with variables instead of a/b — 1 or a/b*100–100 It is common practice to use a/b — 1 to calculate a ratio and avoid duplicate measure calculations. However, you can achieve the same performance by using variables and using (a-b)/b to calculate the ratio. If both a and b are blank values, then (a-b)/b returns a blank value and Power BI will filter the values out. a/b — 1 would return -1 as the result because both a and b are integers. The IFERROR() and ISERROR() functions were widely used in Excel when applying the FIND() and SEARCH() functions. They were necessary because FIND() and SEARCH() returned errors if the query did not obtain the required result. The IFERROR() and ISERROR() functions force the Power BI engine to perform a step-by-step execution of each row to check for errors. There is currently no method to directly state which row returned the error. The FIND() and SEARCH() DAX functions provide an extra parameter that the query can pass. The parameter is returned if the search string is not present. The FIND() and SEARCH() DAX functions check if more than one value is returned. They also ensure nothing is divided by zero. You can avoid using the FIND() and SEARCH() DAX functions altogether by using situationally appropriate DAX functions such as DIVIDE() and SELECTEDVALUE(). The DIVIDE() and SELECTEDVALUE() functions perform error check internally and return the expected results. Remember: You can always use DAX expressions in such a way that they never return an error.\n• Do not use scalar variables in SUMMARIZE() The SUMMARIZE() function is traditionally used to group columns and return resulting aggregations. However, the SUMMARIZECOLUMNS() function is newer and more optimized. Use that instead. Only use SUMMARIZE() for grouped elements of a table that don’t have any associated measures or aggregations. For example: Measures are calculated iteratively by default. If measure definitions use iterative functions such as AddColumns(), Power BI creates nested iterations, which negatively affect report performance.\n• Check if you can convert your column to a Boolean column If there are only two distinct values in a column, check if the column can be converted to use a Boolean data type (true/false). Boolean data types speed up processing when you have a large number of rows. Instead, use ID columns for filtering. For example, if you need to filter by sales location, assign each location a numeric ID. This means you filter by integer columns rather than string columns. Now, you can take advantage of the VertiPaq engine, which uses value encoding to reduce the memory of a column. Note: Value encoding only works on integers. If certain calculations require complex DAX formular, or if multiple filters are applied repeatedly in DAX measures and calculations, consider creating calculated columns or flags in the back end."
    },
    {
        "link": "https://medium.com/@cseprs_54978/optimizing-performance-in-dax-calculations-with-variables-and-iterator-functions-d7dd73e2d8a4",
        "document": "When working with DAX (Data Analysis Expressions) in Power BI, optimizing performance is crucial, especially when dealing with large datasets and complex calculations. Inefficient DAX queries can lead to sluggish report performance, frustrating users. This blog post explores how variables and iterator functions can significantly enhance performance when calculating running totals, rankings, and various aggregations.\n\nThe Importance of Variables and Iterators in DAX\n\nUtilizing variables and iterator functions can dramatically improve both the efficiency and readability of your DAX code. Let’s delve into why these techniques are valuable.\n\nOne of the key advantages of using variables is the ability to simplify complex filter expressions. Variables allow you to store intermediate results, making your DAX formulas more readable and maintainable while enhancing performance by reducing the number of calculations required.\n\nExample of Using Variables:\n\nIn this example, the selected region is stored in a variable, which can then be reused in the calculation without repetitive expressions. You can visually represent this measure in a pie chart or donut chart, where the slices illustrate the sales amount of each product category (e.g., Electronics, Clothing, Furniture) within the selected region. The size of each slice is proportional to the sales contribution of that category in the selected region.\n\nVariables also enable you to store the results of calculations (like MAXX) to avoid redundancy throughout your DAX expressions. This approach is particularly useful for calculations needed multiple times.\n\nIn this measure, the maximum sales amount is calculated once and can be referenced multiple times, enhancing overall efficiency. Here, we calculate 10% of the maximum sales amount. This reuse of the variable avoids recalculating the maximum sales value, thereby improving performance.\n\nAdditionally, in our bar chart, we can add a constant line reflecting this dynamic value, providing a visual reference point for analyzing how actual sales figures compare to this threshold.\n\nIterator functions like SUMX iterate over each row in a table to perform calculations. By storing the filter context in a variable, you can eliminate the need to recalculate that context for each iteration. This is particularly beneficial in scenarios with large datasets, leading to notable performance improvements.\n\nLet’s consider a scenario where we need to dynamically rank sales by product category for each region in a Power BI report. To achieve this, we utilize two variables — SelectedRegion and SelectedCategory — which capture the current filter context for both the region and category. By incorporating these variables into the FILTER expression, we eliminate the need to recalculate the selected region and category during each iteration of SUMX over the table.\n\nThis approach not only enhances performance by minimizing the computational overhead of repeatedly evaluating the same filters but also improves code readability by clearly delineating the conditions applied to the calculation.\n\nIn summary, strategically using variables and iterator functions in DAX can significantly enhance the performance and clarity of your calculations. By minimizing redundant calculations and efficiently managing filter contexts, variables help reduce complexity and computational overhead in large datasets. Iterator functions like SUMX and RANKX facilitate detailed row-by-row analysis while benefiting from the performance optimizations provided by variables.\n\nWhether you’re calculating running totals, ranking sales by category, or adding visual elements like constant lines in bar charts, these techniques are essential for developing responsive and scalable Power BI reports. Implementing these best practices will not only improve the performance of your reports but also make your DAX code easier to maintain and debug.\n\nSmall changes in how we approach DAX calculations can lead to significant performance gains and an improved overall user experience."
    }
]