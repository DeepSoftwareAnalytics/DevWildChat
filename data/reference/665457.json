[
    {
        "link": "https://docs.python.org/2/tutorial/controlflow.html",
        "document": ""
    },
    {
        "link": "https://docs.python.org/3/reference/expressions.html",
        "document": "This chapter explains the meaning of the elements of expressions in Python.\n\nSyntax Notes: In this and the following chapters, extended BNF notation will be used to describe syntax, not lexical analysis. When (one alternative of) a syntax rule has the form\n\nand no semantics are given, the semantics of this form of are the same as for .\n\nPrimaries represent the most tightly bound operations of the language. Their syntax is: An attribute reference is a primary followed by a period and a name: The primary must evaluate to an object of a type that supports attribute references, which most objects do. This object is then asked to produce the attribute whose name is the identifier. The type and value produced is determined by the object. Multiple evaluations of the same attribute reference may yield different objects. This production can be customized by overriding the method or the method. The method is called first and either returns a value or raises if the attribute is not available. If an is raised and the object has a method, that method is called as a fallback. The subscription of an instance of a container class will generally select an element from the container. The subscription of a generic class will generally return a GenericAlias object. When an object is subscripted, the interpreter will evaluate the primary and the expression list. The primary must evaluate to an object that supports subscription. An object may support subscription through defining one or both of and . When the primary is subscripted, the evaluated result of the expression list will be passed to one of these methods. For more details on when is called instead of , see __class_getitem__ versus __getitem__. If the expression list contains at least one comma, or if any of the expressions are starred, the expression list will evaluate to a containing the items of the expression list. Otherwise, the expression list will evaluate to the value of the list’s sole member. Changed in version 3.11: Expressions in an expression list may be starred. See PEP 646. For built-in objects, there are two types of objects that support subscription via :\n• None Mappings. If the primary is a mapping, the expression list must evaluate to an object whose value is one of the keys of the mapping, and the subscription selects the value in the mapping that corresponds to that key. An example of a builtin mapping class is the class.\n• None Sequences. If the primary is a sequence, the expression list must evaluate to an or a (as discussed in the following section). Examples of builtin sequence classes include the , and classes. The formal syntax makes no special provision for negative indices in sequences. However, built-in sequences all provide a method that interprets negative indices by adding the length of the sequence to the index so that, for example, selects the last item of . The resulting value must be a nonnegative integer less than the number of items in the sequence, and the subscription selects the item whose index is that value (counting from zero). Since the support for negative indices and slicing occurs in the object’s method, subclasses overriding this method will need to explicitly add that support. A is a special kind of sequence whose items are characters. A character is not a separate data type but a string of exactly one character. A slicing selects a range of items in a sequence object (e.g., a string, tuple or list). Slicings may be used as expressions or as targets in assignment or statements. The syntax for a slicing: There is ambiguity in the formal syntax here: anything that looks like an expression list also looks like a slice list, so any subscription can be interpreted as a slicing. Rather than further complicating the syntax, this is disambiguated by defining that in this case the interpretation as a subscription takes priority over the interpretation as a slicing (this is the case if the slice list contains no proper slice). The semantics for a slicing are as follows. The primary is indexed (using the same method as normal subscription) with a key that is constructed from the slice list, as follows. If the slice list contains at least one comma, the key is a tuple containing the conversion of the slice items; otherwise, the conversion of the lone slice item is the key. The conversion of a slice item that is an expression is that expression. The conversion of a proper slice is a slice object (see section The standard type hierarchy) whose , and attributes are the values of the expressions given as lower bound, upper bound and stride, respectively, substituting for missing expressions. An optional trailing comma may be present after the positional and keyword arguments but does not affect the semantics. The primary must evaluate to a callable object (user-defined functions, built-in functions, methods of built-in objects, class objects, methods of class instances, and all objects having a method are callable). All argument expressions are evaluated before the call is attempted. Please refer to section Function definitions for the syntax of formal parameter lists. If keyword arguments are present, they are first converted to positional arguments, as follows. First, a list of unfilled slots is created for the formal parameters. If there are N positional arguments, they are placed in the first N slots. Next, for each keyword argument, the identifier is used to determine the corresponding slot (if the identifier is the same as the first formal parameter name, the first slot is used, and so on). If the slot is already filled, a exception is raised. Otherwise, the argument is placed in the slot, filling it (even if the expression is , it fills the slot). When all arguments have been processed, the slots that are still unfilled are filled with the corresponding default value from the function definition. (Default values are calculated, once, when the function is defined; thus, a mutable object such as a list or dictionary used as default value will be shared by all calls that don’t specify an argument value for the corresponding slot; this should usually be avoided.) If there are any unfilled slots for which no default value is specified, a exception is raised. Otherwise, the list of filled slots is used as the argument list for the call. CPython implementation detail: An implementation may provide built-in functions whose positional parameters do not have names, even if they are ‘named’ for the purpose of documentation, and which therefore cannot be supplied by keyword. In CPython, this is the case for functions implemented in C that use to parse their arguments. If there are more positional arguments than there are formal parameter slots, a exception is raised, unless a formal parameter using the syntax is present; in this case, that formal parameter receives a tuple containing the excess positional arguments (or an empty tuple if there were no excess positional arguments). If any keyword argument does not correspond to a formal parameter name, a exception is raised, unless a formal parameter using the syntax is present; in this case, that formal parameter receives a dictionary containing the excess keyword arguments (using the keywords as keys and the argument values as corresponding values), or a (new) empty dictionary if there were no excess keyword arguments. If the syntax appears in the function call, must evaluate to an iterable. Elements from these iterables are treated as if they were additional positional arguments. For the call , if y evaluates to a sequence y1, …, yM, this is equivalent to a call with M+4 positional arguments x1, x2, y1, …, yM, x3, x4. A consequence of this is that although the syntax may appear after explicit keyword arguments, it is processed before the keyword arguments (and any arguments – see below). So: It is unusual for both keyword arguments and the syntax to be used in the same call, so in practice this confusion does not often arise. If the syntax appears in the function call, must evaluate to a mapping, the contents of which are treated as additional keyword arguments. If a parameter matching a key has already been given a value (by an explicit keyword argument, or from another unpacking), a exception is raised. When is used, each key in this mapping must be a string. Each value from the mapping is assigned to the first formal parameter eligible for keyword assignment whose name is equal to the key. A key need not be a Python identifier (e.g. is acceptable, although it will not match any formal parameter that could be declared). If there is no match to a formal parameter the key-value pair is collected by the parameter, if there is one, or if there is not, a exception is raised. Formal parameters using the syntax or cannot be used as positional argument slots or as keyword argument names. Changed in version 3.5: Function calls accept any number of and unpackings, positional arguments may follow iterable unpackings ( ), and keyword arguments may follow dictionary unpackings ( ). Originally proposed by PEP 448. A call always returns some value, possibly , unless it raises an exception. How this value is computed depends on the type of the callable object. The code block for the function is executed, passing it the argument list. The first thing the code block will do is bind the formal parameters to the arguments; this is described in section Function definitions. When the code block executes a statement, this specifies the return value of the function call. If execution reaches the end of the code block without executing a statement, the return value is . The result is up to the interpreter; see Built-in Functions for the descriptions of built-in functions and methods. A new instance of that class is returned. The corresponding user-defined function is called, with an argument list that is one longer than the argument list of the call: the instance becomes the first argument. The class must define a method; the effect is then the same as if that method was called.\n\nThe binary arithmetic operations have the conventional priority levels. Note that some of these operations also apply to certain non-numeric types. Apart from the power operator, there are only two levels, one for multiplicative operators and one for additive operators: The (multiplication) operator yields the product of its arguments. The arguments must either both be numbers, or one argument must be an integer and the other must be a sequence. In the former case, the numbers are converted to a common type and then multiplied together. In the latter case, sequence repetition is performed; a negative repetition factor yields an empty sequence. This operation can be customized using the special and methods. The (at) operator is intended to be used for matrix multiplication. No builtin Python types implement this operator. This operation can be customized using the special and methods. The (division) and (floor division) operators yield the quotient of their arguments. The numeric arguments are first converted to a common type. Division of integers yields a float, while floor division of integers results in an integer; the result is that of mathematical division with the ‘floor’ function applied to the result. Division by zero raises the exception. The division operation can be customized using the special and methods. The floor division operation can be customized using the special and methods. The (modulo) operator yields the remainder from the division of the first argument by the second. The numeric arguments are first converted to a common type. A zero right argument raises the exception. The arguments may be floating-point numbers, e.g., equals (since equals .) The modulo operator always yields a result with the same sign as its second operand (or zero); the absolute value of the result is strictly smaller than the absolute value of the second operand . The floor division and modulo operators are connected by the following identity: . Floor division and modulo are also connected with the built-in function : . . In addition to performing the modulo operation on numbers, the operator is also overloaded by string objects to perform old-style string formatting (also known as interpolation). The syntax for string formatting is described in the Python Library Reference, section printf-style String Formatting. The modulo operation can be customized using the special and methods. The floor division operator, the modulo operator, and the function are not defined for complex numbers. Instead, convert to a floating-point number using the function if appropriate. The (addition) operator yields the sum of its arguments. The arguments must either both be numbers or both be sequences of the same type. In the former case, the numbers are converted to a common type and then added together. In the latter case, the sequences are concatenated. This operation can be customized using the special and methods. The (subtraction) operator yields the difference of its arguments. The numeric arguments are first converted to a common type. This operation can be customized using the special and methods.\n\nUnlike C, all comparison operations in Python have the same priority, which is lower than that of any arithmetic, shifting or bitwise operation. Also unlike C, expressions like have the interpretation that is conventional in mathematics: comparison ::= ( )* comp_operator ::= \"<\" | \">\" | \"==\" | \">=\" | \"<=\" | \"!=\" | \"is\" [\"not\"] | [\"not\"] \"in\" Comparisons yield boolean values: or . Custom rich comparison methods may return non-boolean values. In this case Python will call on such value in boolean contexts. Comparisons can be chained arbitrarily, e.g., is equivalent to , except that is evaluated only once (but in both cases is not evaluated at all when is found to be false). Formally, if a, b, c, …, y, z are expressions and op1, op2, …, opN are comparison operators, then is equivalent to a op1 b and b op2 c and ... y opN z , except that each expression is evaluated at most once. Note that doesn’t imply any kind of comparison between a and c, so that, e.g., is perfectly legal (though perhaps not pretty). The operators , , , , , and compare the values of two objects. The objects do not need to have the same type. Chapter Objects, values and types states that objects have a value (in addition to type and identity). The value of an object is a rather abstract notion in Python: For example, there is no canonical access method for an object’s value. Also, there is no requirement that the value of an object should be constructed in a particular way, e.g. comprised of all its data attributes. Comparison operators implement a particular notion of what the value of an object is. One can think of them as defining the value of an object indirectly, by means of their comparison implementation. Because all types are (direct or indirect) subtypes of , they inherit the default comparison behavior from . Types can customize their comparison behavior by implementing rich comparison methods like , described in Basic customization. The default behavior for equality comparison ( and ) is based on the identity of the objects. Hence, equality comparison of instances with the same identity results in equality, and equality comparison of instances with different identities results in inequality. A motivation for this default behavior is the desire that all objects should be reflexive (i.e. implies ). A default order comparison ( , , , and ) is not provided; an attempt raises . A motivation for this default behavior is the lack of a similar invariant as for equality. The behavior of the default equality comparison, that instances with different identities are always unequal, may be in contrast to what types will need that have a sensible definition of object value and value-based equality. Such types will need to customize their comparison behavior, and in fact, a number of built-in types have done that. The following list describes the comparison behavior of the most important built-in types.\n• None Numbers of built-in numeric types (Numeric Types — int, float, complex) and of the standard library types and can be compared within and across their types, with the restriction that complex numbers do not support order comparison. Within the limits of the types involved, they compare mathematically (algorithmically) correct without loss of precision. The not-a-number values and are special. Any ordered comparison of a number to a not-a-number value is false. A counter-intuitive implication is that not-a-number values are not equal to themselves. For example, if , , and are all false, while is true. This behavior is compliant with IEEE 754.\n• None and are singletons. PEP 8 advises that comparisons for singletons should always be done with or , never the equality operators.\n• None Binary sequences (instances of or ) can be compared within and across their types. They compare lexicographically using the numeric values of their elements.\n• None Strings (instances of ) compare lexicographically using the numerical Unicode code points (the result of the built-in function ) of their characters. Strings and binary sequences cannot be directly compared.\n• None Sequences (instances of , , or ) can be compared only within each of their types, with the restriction that ranges do not support order comparison. Equality comparison across these types results in inequality, and ordering comparison across these types raises . Sequences compare lexicographically using comparison of corresponding elements. The built-in containers typically assume identical objects are equal to themselves. That lets them bypass equality tests for identical objects to improve performance and to maintain their internal invariants. Lexicographical comparison between built-in collections works as follows:\n• None For two collections to compare equal, they must be of the same type, have the same length, and each pair of corresponding elements must compare equal (for example, is false because the type is not the same).\n• None Collections that support order comparison are ordered the same as their first unequal elements (for example, has the same value as ). If a corresponding element does not exist, the shorter collection is ordered first (for example, is true).\n• None Mappings (instances of ) compare equal if and only if they have equal pairs. Equality comparison of the keys and values enforces reflexivity.\n• None Sets (instances of or ) can be compared within and across their types. They define order comparison operators to mean subset and superset tests. Those relations do not define total orderings (for example, the two sets and are not equal, nor subsets of one another, nor supersets of one another). Accordingly, sets are not appropriate arguments for functions which depend on total ordering (for example, , , and produce undefined results given a list of sets as inputs). Comparison of sets enforces reflexivity of its elements.\n• None Most other built-in types have no comparison methods implemented, so they inherit the default comparison behavior. User-defined classes that customize their comparison behavior should follow some consistency rules, if possible:\n• None Equality comparison should be reflexive. In other words, identical objects should compare equal:\n• None Comparison should be symmetric. In other words, the following expressions should have the same result:\n• None Comparison should be transitive. The following (non-exhaustive) examples illustrate that:\n• None Inverse comparison should result in the boolean negation. In other words, the following expressions should have the same result: The last two expressions apply to totally ordered collections (e.g. to sequences, but not to sets or mappings). See also the decorator.\n• None The result should be consistent with equality. Objects that are equal should either have the same hash value, or be marked as unhashable. Python does not enforce these consistency rules. In fact, the not-a-number values are an example for not following these rules. The operators and test for membership. evaluates to if x is a member of s, and otherwise. returns the negation of . All built-in sequences and set types support this as well as dictionary, for which tests whether the dictionary has a given key. For container types such as list, tuple, set, frozenset, dict, or collections.deque, the expression is equivalent to any(x is e or x == e for e in y) . For the string and bytes types, is if and only if x is a substring of y. An equivalent test is . Empty strings are always considered to be a substring of any other string, so will return . For user-defined classes which define the method, returns if returns a true value, and otherwise. For user-defined classes which do not define but do define , is if some value , for which the expression is true, is produced while iterating over . If an exception is raised during the iteration, it is as if raised that exception. Lastly, the old-style iteration protocol is tried: if a class defines , is if and only if there is a non-negative integer index i such that , and no lower integer index raises the exception. (If any other exception is raised, it is as if raised that exception). The operator is defined to have the inverse truth value of . The operators and test for an object’s identity: is true if and only if x and y are the same object. An Object’s identity is determined using the function. yields the inverse truth value."
    },
    {
        "link": "https://docs.aws.amazon.com/lambda/latest/dg/lambda-python.html",
        "document": "You can run Python code in AWS Lambda. Lambda provides runtimes for Python that run your code to process events. Your code runs in an environment that includes the SDK for Python (Boto3), with credentials from an AWS Identity and Access Management (IAM) role that you manage. To learn more about the SDK versions included with the Python runtimes, see Runtime-included SDK versions.\n\nThe console creates a Lambda function with a single source file named . You can edit this file and add more files in the built-in code editor. In the DEPLOY section, choose Deploy to update your function's code. Then, to run your code, choose Create test event in the TEST EVENTS section.\n\nYour Lambda function comes with a CloudWatch Logs log group. The function runtime sends details about each invocation to CloudWatch Logs. It relays any logs that your function outputs during invocation. If your function returns an error, Lambda formats the error and returns it to the invoker.\n\nThe version of the AWS SDK included in the Python runtime depends on the runtime version and your AWS Region. To find the version of the SDK included in the runtime you're using, create a Lambda function with the following code.\n\nThe Python 3.13 managed runtime and base images do not support the following experimental features. You cannot enable these features using runtime flags. To use these features in a Lambda function, you must deploy a custom runtime or container image containing your own build of Python 3.13.\n\nIn Python 3.12 and later Python runtimes, functions return Unicode characters as part of their JSON response. Earlier Python runtimes return escaped sequences for Unicode characters in responses. For example, in Python 3.11, if you return a Unicode string such as \"こんにちは\", it escapes the Unicode characters and returns \"\\u3053\\u3093\\u306b\\u3061\\u306f\". The Python 3.12 runtime returns the original \"こんにちは\".\n\nUsing Unicode responses reduces the size of Lambda responses, making it easier to fit larger responses into the 6 MB maximum payload size for synchronous functions. In the previous example, the escaped version is 32 bytes—compared to 17 bytes with the Unicode string.\n\nWhen you upgrade to Python 3.12 or later Python runtimes, you might need to adjust your code to account for the new response format. If the caller expects escaped Unicode, you must either add code to the returning function to escape the Unicode manually, or adjust the caller to handle the Unicode return.\n\nPython 3.12 and later Python runtimes offer improved graceful shutdown capabilities for functions with external extensions. When Lambda shuts down an execution environment, it sends a signal to the runtime and then a event to each registered external extension. You can catch the signal in your Lambda function and clean up resources such as database connections that were created by the function.\n\nTo learn more about the execution environment lifecycle, see Understanding the Lambda execution environment lifecycle. For examples of how to use graceful shutdown with extensions, see the AWS Samples GitHub repository ."
    },
    {
        "link": "https://book.pythontips.com/en/latest/lambdas.html",
        "document": "Lambdas are one line functions. They are also known as anonymous functions in some other languages. You might want to use lambdas when you don’t want to use a function twice in a program. They are just like normal functions and even behave like them.\n\nHere are a few useful use cases for lambdas and just a few ways in which they are used in the wild:"
    },
    {
        "link": "http://python-reference.readthedocs.io/en/latest/docs/operators/lambda.html",
        "document": "lambda expression is a shorthand way of defining a function that is not bound to a specified name during its creation.\n\nConsider the following function:\n\nThe same function can be defined using lambda expression as follows:\n\nBoth functions are the same. Note that does not include a return statement. The right expression is the implicit return value. Lambda functions need not to be assigned to any variables."
    },
    {
        "link": "https://medium.com/@engr.tanveersultan53/map-filter-reduce-and-lambda-function-in-python-3822916f3de8",
        "document": "Lambda or Anonymous Function -> A function which have no name is called lambda or anonymous function. Normally we use def keyword for define normal function in python and we use lambda keyword for creating lambda/anonymous function in python.\n\nFind Sum of Two Number with Lambda Function\n\nMultiplication of Two Number with Lambda Function\n\nExplanation :- sum_of_two_number is a variable that is use to store the return valued from the lambda function and is the keyword to define the anonymous function are the arguments of that function and after this is the expression and of that function.\n\nMap( ) :- It is a function that apply on the iterable items. It takes two argument first a function and second an iterable item and return an object and we store that object in a list.\n\nIn map() function we can use both a function. To look more we generally use (lambda function) with map().\n\nFilter( ) function :- It is same like map() function its also takes two arguments first a and second an object and return the list object of only values.\n\nreduce( ) :- It is also same like map() and filter() but its return only a single value or item, but to use reduce( ) function you have to import first\n\nThank you for Reading …"
    },
    {
        "link": "https://geeksforgeeks.org/python-lambda-anonymous-functions-filter-map-reduce",
        "document": "Python Lambda Functions are anonymous functions means that the function is without a name. As we already know the def keyword is used to define a normal function in Python. Similarly, the lambda keyword is used to define an anonymous function in Python.\n\nIn the example, we defined a lambda function(upper) to convert a string to its upper case using upper().\n\nThis code defines a lambda function named 2 that takes a string as its argument and converts it to uppercase using the method. It then applies this lambda function to the string ‘GeeksforGeeks’ and prints the result.\n• lambda: The keyword to define the function.\n• arguments: A comma-separated list of input parameters (like in a regular function).\n• expression: A single expression that is evaluated and returned.\n\nLet’s see some of the practical uses of the Python lambda function.\n\nA lambda function can include conditions using if statements.\n• None It uses nested if-else statements to return “Positive,” “Negative,” or “Zero.”\n\nlambda is concise but less powerful than def when handling complex logic. Let’s take a look at short comparison between the two:\n\nAs we can see in the above example, both the sq() function and sqdef() function behave the same and as intended.\n\nCombining lambda with list comprehensions enables us to apply transformations to data in a concise way.\n• None The list comprehension iterates through li and applies the lambda to each element.\n• None This is ideal for applying transformations to datasets in data preprocessing or manipulation tasks.\n\nlambda functions can incorporate conditional logic directly, allowing us to handle simple decision making within the function.\n• None The lambda checks if a number is divisible by 2 (x % 2 == 0).\n• None Returns “Even” for true and “Odd” otherwise.\n• None This approach is useful for labeling or categorizing values based on simple conditions.\n\nLambda functions do not allow multiple statements, however, we can create two lambda functions and then call the other lambda function as a parameter to the first function.\n• None The lambda function performs both addition and multiplication and returns a tuple with both results.\n• None This is useful for scenarios where multiple calculations need to be performed and returned together.\n\nLambda functions can be used along with built-in functions like filter(), map() and reduce().\n\nThe filter() function in Python takes in a function and a list as arguments. This offers an elegant way to filter out all the elements of a sequence “sequence”, for which the function returns True.\n• None The lambda function checks if a number is even (x % 2 == 0).\n• None filter() applies this condition to each element in nums.\n\nThe map() function in Python takes in a function and a list as an argument. The function is called with a lambda function and a new list is returned which contains all the lambda-modified items returned by that function for each item.\n• None map() iterates through a and applies the transformation.\n\nThe reduce() function in Python takes in a function and a list as an argument. The function is called with a lambda function and an iterable and a new reduced result is returned. This performs a repetitive operation over the pairs of the iterable. The reduce() function belongs to the functools module.\n• None The lambda multiplies two numbers at a time.\n• None reduce() applies this operation across the list.\n\nWhat is the use of lambda function Python?\n\nWhat is difference between def and lambda in Python?\n\nWhat is the functionality of lambda?\n\nWhen to use lambda?\n\nWhat is key lambda in Python?"
    },
    {
        "link": "https://freecodecamp.org/news/lambda-functions-in-python",
        "document": "In this tutorial, we will explore the various aspects of lambda functions in Python, including their syntax, use cases, and limitations.\n\nBy understanding how to effectively utilize lambda functions, you can write more concise and efficient Python code. This will enhance your programming skills and make your codebase cleaner and easier to manage.\n• What are Lambda Functions in Python?\n• Ways to Call Lambda Functions\n\n– Assigning to a Variable\n\n– Directly Calling the Lambda Function\n\n– Using as an Argument to Higher-Order Functions\n\nWhat are Lambda Functions in Python?\n\nIn Python, a lambda function is a small, anonymous function defined using the keyword.\n\nThese functions are typically used for short, throwaway operations where a full function definition might be overkill. They are called anonymous because they do not require a name (although they can be assigned to a variable for reuse).\n\nLambda functions excel in scenarios where you need a quick, simple function for a brief period, and a full function definition would be excessive. This makes them ideal for operations that are straightforward and can be written in a single line, such as simple mathematical calculations or basic data transformations.\n\nThey are particularly used in functional programming contexts with higher-order functions like , , and where they are often passed as arguments. Just remember that for more complex operations, regular functions are preferred for their readability and maintainability.\n\nUnlike regular functions defined with , lambda functions are limited to a single expression due to their design for simplicity and brevity. They can take single or multiple arguments but cannot contain statements or multiple expressions.\n\nLambda functions are intended for short, straightforward operations that can be written in a single line.\n\nAlthough lambda functions can only contain one expression, we can still do a lot with them.\n\nFor example, here's a Lambda function to concatenate 2 strings and convert them to uppercase:\n\nThere are primarily three ways to use or call lambda functions:\n\nAssign the lambda function to a variable and then call it using that variable:\n\nDefine and immediately invoke the lambda function by wrapping the definition in parentheses and providing the arguments directly:\n\n3. Using as an Argument to Higher-Order Functions\n\nLambda functions are often used as arguments to higher-order functions like , , and .\n\nThese are functions that take other functions as arguments. They help in processing collections of data (like lists or tuples) in a functional programming style.\n\nThe function applies a specified function to each item in an iterable (like a list) and returns a new iterable with the updated items.\n• here takes one argument and returns a value.\n• iterable's elements (for example, , ) will be passed to the function.\n\nExplanation: In this code, we use a lambda function to define a small, anonymous function that takes each pair of numbers and prints their multiplication.\n\nThe function applies this lambda function to each pair (tuple) in the list. Wrapping the call with ensures the lambda function is executed for each pair. As a result, the code prints the multiplication results for each pair in the list, showing outputs like \"2 3 = 6\", \"4 5 = 20\", and \"6 * 7 = 42\".\n\nThe function filters elements in an iterable based on a specified predicate. Only elements for which the predicate returns are included in the new iterable.\n\nPredicate is a function that takes one argument and returns a boolean value (True or False). Iterable elements here will be tested by the predicate.\n\nExplanation: In this code, we start with a list of ages. We use a lambda function to define a simple condition that checks if an age is 18 or older.\n\nThe function applies this lambda function to each age in the list, filtering out any ages below 18. By converting the result of to a list, we obtain a list of ages that are 18 and above. Finally, we print this filtered list, which results in the ages being displayed, as these are the ages that meet the criterion of being 18 or older.\n\nThe function applies a specified function to the elements of an iterable cumulatively to reduce them to a single value. It is part of the module.\n\nHere, Function takes two arguments and returns a single value. Iterable elements will be processed by the function.\n\nExplanation: In this code, we start with a list of numbers. We use the function from the module to compute the sum of all the numbers in the list. We use a lambda function to define a simple addition operation that takes two arguments, and , and returns their sum. The function applies this lambda function cumulatively to the items in the list, starting from the first pair and continuing through the entire list, like this:\n• Initially, is the first element of the list (1) and is the second element (2), resulting in 3.\n• This sum (3) then becomes , and the next element in the list (3) becomes , yielding 6.\n• This process continues until all elements in the list have been summed. Ultimately, the final result is 15, representing the sum of all the numbers in the list [1, 2, 3, 4, 5].\n\nLambda functions can also be used in sorting or other functional programming contexts. For example:\n\nIn this code, we have a list called containing the names of different cities. We use the function to sort these city names alphabetically, ignoring case sensitivity. The parameter in the function allows us to specify a function (in this case, a lambda function) to customize the sorting order.\n\nThe lambda function converts each city name to lowercase before sorting. This ensures that the sorting is case-insensitive, so cities with different capitalization are treated the same way.\n\nAfter sorting, the sorted list is assigned to the variable , and we print the result. The output shows the sorted list of cities: , where the cities are arranged alphabetically ignoring the case of the letters.\n\nLambda functions can be used within list comprehensions to apply a function to each element in a list.\n\nLambda functions in Python provide a quick and concise way to create small, throwaway functions. They're especially useful in functional programming with higher-order functions like , , and .\n\nWhile lambda functions are powerful and concise, make sure you balance their use with code readability and maintainability. For more complex logic, regular functions defined with are preferred because they support multiple expressions and statements, and you can include documentation.\n\nBy understanding and using lambda functions effectively, you can write more concise and efficient Python code.\n\nThank you for reading! If you have any comments, criticisms, or questions, feel free to tweet or reach out to me at @OGsamyak. Your feedback helps me improve!"
    },
    {
        "link": "https://analyticsvidhya.com/blog/2021/10/an-explanation-to-pythons-lambda-map-filter-and-reduce",
        "document": "An Explanation to Python’s Lambda, Map, Filter and Reduce\n\nThis article was published as a part of the Data Science Blogathon\n\nHola folks. Have you ever got confused in Python’s Lambda, Map, Filter, and Reduce? Huh? No worries, I’ve got you covered. In this article, we will be clearing all the confusion you might have had. Specifically, after reading this article, you will know:\n• What is Lambda, Map, Filter, and Reduce?\n• Why do we use Lambda, Map, Filter, and Reduce?\n• How to use Lambda, Map, Filter, and Reduce?\n• When to use Lambda, Map, Filter, and Reduce?\n\nIf you don’t have any confusion on this topic, you can directly move on to the Summary section.\n\nLambda is a keyword in Python used to define functions, more specifically Anonymous Functions, and such functions are known as Lambda Functions or Lambda Expressions.\n\nLet us understand this with an example.\n\nWhat If I ask you to write a function to square a number? You would probably write something like the following:\n\nThe code shown above is self-explanatory and isn’t Pythonic. There we have lambda functions to make it Pythonic. Following is the square equivalent function using lambda:\n\nThe expression n ** 2 gets evaluated first, and a value gets returned to the identifier square. The identifier square can now act as a function, and thus we can pass any number as an argument to find the square of a number.\n\nWe can also extend the lambda functions by adding conditional statements. Refer to the following self-explanatory example.\n\nSo, that’s about making your code Pythonic using lambda. But that’s not all that lambda does. It is also often used to create function wrappers, such as Python’s decorators. Following is one such example.\n\nThe transform function takes in a number and returns the lambda expression/function. Lambda function further adds two numbers, x and n.\n\nThe limitation of Lambda functions is that they can have any number of arguments but only one expression.\n\nLambda functions are mainly used with the map functions as in-place functions. So, let’s discuss the map functions.\n\nWhat If I ask you to find a square of the first five odd numbers. You would probably write something like the following:\n\nThe loop iterates through 1 to 10 with a step size of 2 and appends the square of each number to squares. The approach shown above can be improved using list comprehension but that too will use for loop. So, there’s a faster way to do the same without using explicit for loop. Python’s map function does that. It transforms the given iterable based on the given condition.\n\nThe syntax for the map function is as follows:\n\nThe map function takes in a function and an iterable(list, tuple, etc.) as an input; applies passed function to each item of an iterable and returns a map object(an iterator).\n\nLet us re-implement the above example using the map function.\n\nThe square function returns the square of any number. The map function takes in square function and range(1, 10, 2) as arguments. It applies the square function on a given range(1, 3, 5, 7, and 9) which returns a map object and is later converted into the list.\n\nThe code above is longer than the earlier one. Thus, let’s make it pythonic using a lambda function. Have a look at the following self-explanatory code.\n\nHere, the lambda function is applied on a given iterable which returns a map object and is later converted into the list.\n\nThe map function can have multiple iterables. Let’s take a quick example to demonstrate the same.\n\nHere, we have performed element-wise addition of lists.\n\nKeep in mind that the map can take any iterable as an argument and not only a list.\n\nLet’s say you want to find the odd numbers from a given list. A quick way to approach this problem is to use a for loop inside a list comprehension.\n\nThe loop iterates through nums and stores every odd number. The conditional statement here filters out the even numbers and returns only the odd numbers. This kind of functionality is known as filtering.\n\nPython’s filter does the same in a faster way. It has the same syntax as the map.\n\nIt works similarly to the map. It returns a filter object, unlike a map object.\n\nLet us re-implement the above example using the filter function.\n\nLet us convert this find_odd function to a lambda function and rewrite the code to make it shorter.\n\nAll the items of an iterable for which the lambda function evaluates to true will get added to the odd.\n\nLet’s say you want to compute a sum of the first five integers. You can write something like the following:\n\nThe loop iterates through nums and keeps adding all the numbers to summ. Again to make it pythonic, we have a function, i.e. Reduce.\n\nThe syntax for the reduce is as follows:\n\nThe reduce applies a function cumulatively on all the items of an iterable and returns a single value. Don’t worry if you haven’t get it yet.\n\nLet us re-implement the above example with the reduce function.\n\nRefer to the following figure to understand what’s happening behind the scenes.\n\nHere, the sum is performed in cumulative/successive manner: ((((1 + 2) + 3) + 4) + 5).\n• Function with many arguments but only one expression.\n• It helps to make our code pythonic and to create function wrappers.\n• A function that applies a given function to each item of an iterable and returns an iterator.\n• It provides a faster way to transform an iterable based on the given condition.\n• It can have multiple iterables.\n• It has the same syntax as the map function.\n• It helps in extracting items from an iterable based on the given condition.\n• It applies a function cumulatively/successively on each item of an iterable and returns a single value.\n\nThis completes today’s discussion. Thank you for reading this article! I hope you enjoyed this article and had fun reading it as much as I had while writing it 🙂\n\nDid I miss something important or want to share your thoughts? Comment down below, and I’ll get back to you.\n\nI am Harsh Dhamecha, a final year undergrad student of Artificial Intelligence, Machine Learning Mentor, and aspiring Data Scientist. I write about Python, Machine Learning, and Deep Learning.\n\nIf you have any queries, you can directly email me, too boring huh? There we have LinkedIn and Twitter. I regularly write threads on Python, Machine Learning, Deep Learning, and Data Science on Twitter. Follow me to stay updated!\n\nYou can have a look at the other articles I have written.\n\nStill, reading this article? Special thanks to you 🙌"
    },
    {
        "link": "https://python-course.eu/advanced-python/lambda-filter-reduce-map.php",
        "document": "If Guido van Rossum, the author of the programming language Python, had got his will, this chapter would have been missing in our tutorial. In his article from May 2005 \"All Things Pythonic: The fate of reduce() in Python 3000\", he gives his reasons for dropping lambda, map(), filter() and reduce(). He expected resistance from the Lisp and the scheme \"folks\". What he didn't anticipate was the rigidity of this opposition. Enough that Guido van Rossum wrote hardly a year later: \"After so many attempts to come up with an alternative for lambda, perhaps we should admit defeat. I've not had the time to follow the most recent rounds, but I propose that we keep lambda, so as to stop wasting everybody's talent and time on an impossible quest.\" We can see the result: lambda, map() and filter() are still part of core Python. Only reduce() had to go; it moved into the module functools.\n\nHis reasoning for dropping them is like this:\n• There is an equally powerful alternative to lambda, filter, map and reduce, i.e. list comprehension\n• List comprehension( is more evident and easier to understand\n• Having both list comprehension and \"Filter, map, reduce and lambda\" is transgressing the Python motto \"There should be one obvious way to solve a problem\"\n\nSome like it, others hate it and many are afraid of the lambda operator. The lambda operator or lambda function is a way to create small anonymous functions, i.e. functions without a name. These functions are throw-away functions, i.e. they are just needed where they have been created. Lambda functions are mainly used in combination with the functions filter(), map() and reduce(). The lambda feature was added to Python due to the demand from Lisp programmers.\n\nThe general syntax of a lambda function is quite simple:\n\nThe argument list consists of a comma separated list of arguments and the expression is an arithmetic expression using these arguments. You can assign the function to a variable to give it a name.\n\nThe following example of a lambda function returns the sum of its two arguments:\n\nThe above example might look like a plaything for a mathematician. A formalism which turns an easy to comprehend issue into an abstract harder to grasp formalism. Above all, we could have had the same effect by just using the following conventional function definition:\n\nWe can assure you that the advantages of this approach will be apparent, when you will have learnt to use the map() function.\n\nAs we have mentioned earlier, the advantage of the lambda operator can be seen when it is used in combination with the map() function. map() is a function which takes two arguments:\n\nThe first argument func is the name of a function and the second a sequence (e.g. a list) seq. map() applies the function func to all the elements of the sequence seq. Before Python3, map() used to return a list, where each element of the result list was the result of the function func applied on the corresponding element of the list or tuple \"seq\". With Python 3, map() returns an iterator.\n\nThe following example illustrates the way of working of map():\n\nIn the example above we haven't used lambda. By using lambda, we wouldn't have had to define and name the functions fahrenheit() and celsius(). You can see this in the following interactive session:\n\nmap() can be applied to more than one list. The lists don't have to have the same length. map() will apply its lambda function to the elements of the argument lists, i.e. it first applies to the elements with the 0th index, then to the elements with the 1st index until the n-th index is reached:\n\nIf one list has fewer elements than the others, map will stop when the shortest list has been consumed:\n\nWe can see in the example above that the parameter x gets its values from the list a, while y gets its values from b, and z from list c.\n\nThe map function of the previous chapter was used to apply one function to one or more iterables. We will now write a function which applies a bunch of functions, which may be an iterable such as a list or a tuple, for example, to one Python object.\n\nThe previously defined map_functions function can be simplified with the list comprehension technique, which we will cover in the chapter list comprehension:\n\noffers an elegant way to filter out all the elements of a sequence \"sequence\", for which the function function returns True. i.e. an item will be produced by the iterator result of filter(function, sequence) if item is included in the sequence \"sequence\" and if function(item) returns True.\n\nIn other words: The function filter(f,l) needs a function f as its first argument. f has to return a Boolean value, i.e. either True or False. This function will be applied to every element of the list l. Only if f returns True will the element be produced by the iterator, which is the return value of filter(function, sequence).\n\nIn the following example, we filter out first the odd and then the even elements of the sequence of the first 11 Fibonacci numbers:\n\nAs we mentioned in the introduction of this chapter of our tutorial. reduce() had been dropped from the core of Python when migrating to Python 3. Guido van Rossum hates reduce(), as we can learn from his statement in a posting, March 10, 2005, in artima.com:\n\ncontinually applies the function func() to the sequence seq. It returns a single value.\n\nIf seq = [ s1, s2, s3, ... , sn ], calling reduce(func, seq) works like this:\n\nIf n is equal to 4 the previous explanation can be illustrated like this:\n\nWe want to illustrate this way of working of reduce() with a simple example. We have to import functools to be capable of using reduce:\n\nThe following diagram shows the intermediate steps of the calculation:\n\nDetermining the maximum of a list of numerical values by using reduce:\n\nCalculating the sum of the numbers from 1 to 100:\n\nIt's very simple to change the previous example to calculate the product (the factorial) from 1 to a number, but do not choose 100. We just have to turn the \"+\" operator into \"*\":\n\nIf you are into lottery, here are the chances to win a 6 out of 49 drawing:\n\n1) Imagine an accounting routine used in a book shop. It works on a list with sublists, which look like this:\n\n2) The same bookshop, but this time we work on a different list. The sublists of our lists look like this: [ordernumber, (article number, quantity, price per unit), ... (article number, quantity, price per unit) ] Write a program which returns a list of two tuples with (order number, total amount of order)."
    }
]