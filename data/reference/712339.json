[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/fundamentals/networking/http/httpclient-guidelines",
        "document": "The System.Net.Http.HttpClient class sends HTTP requests and receives HTTP responses from a resource identified by a URI. An HttpClient instance is a collection of settings that's applied to all requests executed by that instance, and each instance uses its own connection pool, which isolates its requests from others. Starting in .NET Core 2.1, the SocketsHttpHandler class provides the implementation, making behavior consistent across all platforms.\n\nHttpClient only resolves DNS entries when a connection is created. It does not track any time to live (TTL) durations specified by the DNS server. If DNS entries change regularly, which can happen in some scenarios, the client won't respect those updates. To solve this issue, you can limit the lifetime of the connection by setting the PooledConnectionLifetime property, so that DNS lookup is repeated when the connection is replaced. Consider the following example:\n\nThe preceding is configured to reuse connections for 15 minutes. After the timespan specified by PooledConnectionLifetime has elapsed and the connection has completed its last associated request (if any), this connection is closed. If there are any requests waiting in the queue, a new connection is created as needed.\n\nThe 15-minute interval was chosen arbitrarily for illustration purposes. You should choose the value based on the expected frequency of DNS or other network changes.\n\nThe connection pool for an HttpClient is linked to the underlying SocketsHttpHandler. When the HttpClient instance is disposed, it disposes all existing connections inside the pool. If you later send a request to the same server, a new connection must be recreated. As a result, there's a performance penalty for unnecessary connection creation. Moreover, TCP ports are not released immediately after connection closure. (For more information on that, see TCP in RFC 9293.) If the rate of requests is high, the operating system limit of available ports might be exhausted. To avoid port exhaustion problems, we recommend reusing HttpClient instances for as many HTTP requests as possible.\n\nTo summarize recommended use in terms of lifetime management, you should use either long-lived clients and set (.NET Core and .NET 5+) or short-lived clients created by .\n‚Ä¢ \n‚Ä¢ Use a or singleton HttpClient instance with PooledConnectionLifetime set to the desired interval, such as 2 minutes, depending on expected DNS changes. This solves both the port exhaustion and DNS changes problems without adding the overhead of IHttpClientFactory. If you need to be able to mock your handler, you can register it separately. If you only use a limited number of HttpClient instances, that's also an acceptable strategy. What matters is that they're not created and disposed with each request, as they each contain a connection pool. Using more than one instance is necessary for scenarios with multiple proxies or to separate cookie containers without completely disabling cookie handling.\n‚Ä¢ None Using IHttpClientFactory, you can have multiple, differently configured clients for different use cases. However, be aware that the factory-created clients are intended to be short-lived, and once the client is created, the factory no longer has control over it. The factory pools HttpMessageHandler instances, and, if its lifetime hasn't expired, a handler can be reused from the pool when the factory creates a new HttpClient instance. This reuse avoids any socket exhaustion issues. If you desire the configurability that IHttpClientFactory provides, we recommend using the typed-client approach.\n‚Ä¢ None In .NET Framework, use IHttpClientFactory to manage your instances. If you don't use the factory and instead create a new client instance for each request yourself, you can exhaust available ports. If your app requires cookies, consider disabling automatic cookie handling or avoiding IHttpClientFactory. Pooling the HttpMessageHandler instances results in sharing of CookieContainer objects. Unanticipated CookieContainer object sharing often results in incorrect code.\n\nFor more information about managing lifetime with , see guidelines.\n\nIt's possible to configure a or singleton client to use any number of resilience pipelines using the following pattern:\n‚Ä¢ Specifies a transient HTTP error handler, configured with retry pipeline that with each attempt will exponentially backoff delay intervals.\n‚Ä¢ Defines a pooled connection lifetime of fifteen minutes for the .\n‚Ä¢ Passes the to the with the retry logic."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=net-9.0",
        "document": ""
    },
    {
        "link": "https://medium.com/@iamprovidence/http-client-in-c-best-practices-for-experts-840b36d8f8c4",
        "document": "Did you think that learning how to create an is all you need to start using it? Oh silly you are üòå. Network communication is unreliable, therefore you need to make your resilient.\n\nWhen you have one service calling another, there are multiple issues you can encounter:\n‚Ä¢ the request may take too long\n‚Ä¢ the server may be slow or not available at all\n\nTherefore, you should learn about:\n\nThere is another popular NuGet, called , which allows you to write resilient code in a fluent manner:\n\nMicrosoft saw how good it is, and decided to use in their own NuGet ( that adds resiliency to .\n\nLet‚Äôs see it in practice.\n\nWhen a user clicks a button, he does not care whether you are performing complex computations or calling an external service. The user just expects to see a response right away.\n\nHowever, when an external service is overloaded and the request takes too long, it will cause slowness in your application.\n\nTherefore you should set a timeout of how long you can wait for the response:\n\nIf the request takes longer, it will be aborted and considered as a failed one.\n\nWe can face another issue. The response is returned in an acceptable interval, however, it failed with an error.\n\nIn that case, it is worth try sending the same request again.\n\nWith retries you need to consider the following factors:\n‚Ä¢ which status codes should be retried\n\nHTTP‚Äôs status code indicates the result of the request, whether it was successful or encountered an error. The codes are grouped into five categories based on their first digit:\n\nAnd only and groups indicate an error.\n\nIt is important to understand which codes should be retried.\n\nIf the request is returned with client error ( ), it means that it was poorly formed. Parameters are invalid, the authorization token is missing, the validation failed, and so on. Retrying such a request will likely result in the same error.\n\nTherefore you should not retry the group. But there are exceptions:\n‚Ä¢ . This status code indicates that the server did not complete the request within the expected time. Retrying after a reasonable delay might help\n‚Ä¢ . If you encounter this status code, it means you‚Äôre making too many requests in a given time frame. Retrying after some period can help avoid hitting rate limits\n\nOn the other hand, server errors ( ), typically means temporary issues that will be resolved on a retry (except üòÖ).\n\nIn practice, you don‚Äôt have to think about which status codes to retry, because Microsoft already implemented that üôè:\n\nIt‚Äôs often a good practice to set a limit on the number of retry attempts to prevent infinite retry loops in case of persistent failures.\n\nOf course, in case you are integrating with a third party, you should take into account the number of requests you send, the rate limits it imposes, and the potential impact on performance and costs.\n\nWe agreed on a number of retry attempts. It is also important to choose a delay between retries.\n\nEach retry can happen after a constant timeout, let‚Äôs say .\n\nThis can be easily set in our retry policy:\n\nIt is simple, but not very effective.\n\nIf the server returns an error, retrying after a short delay can help quickly obtain a response from the server.\n\nHowever, if you fail on a second attempt, on the third one, it usually means the server is overloaded, and spamming it with more requests just worsens the situation.\n\nSo, if the client ‚Äúsees‚Äù that the server is unavailable, but it desperately needs a response, it is better to wait for a longer period.\n\nIt is recommended to increase the delay between each retry linearly or exponentially. This way you wait , then , then , and so on.\n\nEven though this strategy is a bit better, it still has some drawbacks.\n\nPicture this: your server goes down entirely. Multiple begin retrying their requests, and these retries align in time, generating peak load moments on the already overwhelmed server. This can potentially lead to a self-DDoS attack.\n\nYou need to add a random delay to each retry, also known as jitter.\n\nWhen implementing retries you should remember that some HTTP methods may have side effects.\n\nAccording to REST, you can classify any operation as Create, Read, Update, or Delete (CRUD).\n\nLet‚Äôs say we receive from a server. This does not mean that the request was not handled. It just indicates that we no longer wait for a response.\n\nAs expected our client will do the retry. The behavior will be different depending on the operation:\n‚Ä¢ ‚Äî on the first attempt, the server will delete the resource, and on the second retry, there will be nothing to delete, so the retry should not harm our server\n‚Ä¢ ‚Äî generally, the update operation is not harmful. For example, if you send the same data multiple times, the server should overwrite the resource with identical values\n‚Ä¢ ‚Äî it does not matter, how many times you retrieve the data as fetch is a read-only, side-effect-free operation\n‚Ä¢ ‚Äî retrying the request responsible for creation could result in duplicate entries üòñ\n\nTherefore, the server should ensure idempotency.\n\nOr in plain English, if you have an API endpoint to pay for an order and unpetient users click 10 times, only 1 payment will be charged.\n\nTypically, clients should include a with each request, enabling the server to maintain a record of processed requests:\n\nWe won‚Äôt discuss idempotency in detail here. It is another big topic that deserves its own article üôÉ. Just remember, that if your server does not implement idempotency (which is often the case with third-party apps), retries can cause more issues than solve.\n\nSo, we have timeout and retries. Still, there is another known problem.\n\nLet‚Äôs say our server is overwhelmed with requests and it takes time to respond.\n\nSure we have a timeout, however, during the waiting period, the client continues sending requeues and also runs out of resources, such as memory, TCP connections, available threads, and so on.\n\nOver time the client will deplete its resources and also fail.\n\nSometimes it is better to fail fast instead of trying to send requests that will allocate the client‚Äôs resources and fail anyway.\n\nIt is solved with the Circuit-Breaker pattern. The idea is as follows:\n‚Ä¢ we add a proxy that will gather the statistics about the number of failed requests\n‚Ä¢ if at some point we realize that the server has stopped responding, we should stop all requests for a while. This is known as open-state\n‚Ä¢ from time to time, our proxy goes to a half-open state. It allows some requests through just to verify whether the server has recovered or not\n‚Ä¢ in case, the server starts responding at a reasonable rate, we can get back to the close state when there is no gap in the connection line\n\nThe good news here is that we don‚Äôt need to implement Circuit-Breaker from scratch or add any proxy service here. As before, everything can be done with one configuration line üòÅ:\n\nYou can tune parameters more granularly, depending on your needs, but I will leave it as is because I am lazy üôÉ.\n\nAs you can see, configuring the resiliency pipeline is complex. Microsoft also knows that it is quite easy to f#ck it up üòÖ. You can set policies in the wrong order, set invalid parameters, and so on. Therefore, they give us an extension method, that will register standard policies:\n\nThey look like this:\n\nStill, it is possible to tune some settings, if needed:"
    },
    {
        "link": "https://stackoverflow.com/questions/58493140/what-are-the-best-practices-with-using-httpclient-httpclienthandler-for-multip",
        "document": "Using is not as straight forward as I would've hoped. Despite it being an type it is not best practice to wrap it in a statement and it's even ideal to make it a singleton. However, what about when you pass in a to the constructor of the like:\n\nI've seen code like above where the is deliberately wrapped in a statement but the is a singleton. The docs indicate the client handler is disposed of unless the second param indicates as is done above:\n\nPart of the problem with using HttpClient is several things like a timeout must be shared with all instances of that HttpClient, so for this reason it would be nice to create separate instances of HttpClient that use the same connection pool presumably provided by the HttpClientHandler (assuming that is how this works). My concern is that I don't want HttpClient to create a connection pool that will then be disposed of each time. There's multiple posts on how this is really bad for performance. I can't seem to find any good documentation on effectively using HttpClient together with HttpClientHandlers.\n\nSo... My question is basically:\n\nWhen using an HttpClient & HttpClientHandler together, is it best to make the HttpClientHandler a singleton and then instantiate as many new HttpClients in blocks each time? -- This again only makes sense if the connection pool is managed by the HttpClientHandler, which I think is the case."
    },
    {
        "link": "https://stackoverflow.com/questions/37157164/best-practice-for-use-httpclient",
        "document": "The challenge in using just one HttpClient across your application is when you want to use different credentials or you try to vary the default headers for your requests (or anything in the HttpClientHandler passed in). In this case you will need a set of purpose specific HttpClients to re-use since using just one will be problematic.\n\nI suggest creating a HttpClient per the \"type\" of request you wish to make and re-use those. E.g. one for each credential you need - and maybe if you have a few sets of default headers, one per each of those.\n\nIt can be a bit of a juggling act between the HttpClient properties (which are not thread safe) and need their own instance if being varied:\n\nAnd what you can pass in to the \"VERB\" methods (get, put, post etc). For example, using you can specify your headers for the (and not have to put them in the HttpClient DefaultHeaders).\n\nAll of the Async methods off the HttpClient are thread safe (PostAsync) etc."
    },
    {
        "link": "https://learn.microsoft.com/en-us/aspnet/core/fundamentals/http-requests?view=aspnetcore-9.0",
        "document": "An IHttpClientFactory can be registered and used to configure and create HttpClient instances in an app. offers the following benefits:\n‚Ä¢ Provides a central location for naming and configuring logical instances. For example, a client named github could be registered and configured to access GitHub. A default client can be registered for general access.\n‚Ä¢ Codifies the concept of outgoing middleware via delegating handlers in . Provides extensions for Polly-based middleware to take advantage of delegating handlers in .\n‚Ä¢ Manages the pooling and lifetime of underlying instances. Automatic management avoids common DNS (Domain Name System) problems that occur when manually managing lifetimes.\n‚Ä¢ Adds a configurable logging experience (via ) for all requests sent through clients created by the factory. The sample code in this topic version uses System.Text.Json to deserialize JSON content returned in HTTP responses. For samples that use and , use the version selector to select a 2.x version of this topic. There are several ways can be used in an app: The best approach depends upon the app's requirements. An can be requested using dependency injection (DI). The following code uses to create an instance: public class BasicModel : PageModel { private readonly IHttpClientFactory _httpClientFactory; public BasicModel(IHttpClientFactory httpClientFactory) => _httpClientFactory = httpClientFactory; public IEnumerable<GitHubBranch>? GitHubBranches { get; set; } public async Task OnGet() { var httpRequestMessage = new HttpRequestMessage( HttpMethod.Get, \"https://api.github.com/repos/dotnet/AspNetCore.Docs/branches\") { Headers = { { HeaderNames.Accept, \"application/vnd.github.v3+json\" }, { HeaderNames.UserAgent, \"HttpRequestsSample\" } } }; var httpClient = _httpClientFactory.CreateClient(); var httpResponseMessage = await httpClient.SendAsync(httpRequestMessage); if (httpResponseMessage.IsSuccessStatusCode) { using var contentStream = await httpResponseMessage.Content.ReadAsStreamAsync(); GitHubBranches = await JsonSerializer.DeserializeAsync <IEnumerable<GitHubBranch>>(contentStream); } } } Using like in the preceding example is a good way to refactor an existing app. It has no impact on how is used. In places where instances are created in an existing app, replace those occurrences with calls to CreateClient.\n‚Ä¢ The app requires many distinct uses of .\n‚Ä¢ Many s have different configuration. Specify configuration for a named during its registration in : builder.Services.AddHttpClient(\"GitHub\", httpClient => { httpClient.BaseAddress = new Uri(\"https://api.github.com/\"); // using Microsoft.Net.Http.Headers; // The GitHub API requires two headers. httpClient.DefaultRequestHeaders.Add( HeaderNames.Accept, \"application/vnd.github.v3+json\"); httpClient.DefaultRequestHeaders.Add( HeaderNames.UserAgent, \"HttpRequestsSample\"); }); In the preceding code the client is configured with:\n‚Ä¢ Two headers required to work with the GitHub API.\n‚Ä¢ A new instance of is created. To create a named client, pass its name into : public class NamedClientModel : PageModel { private readonly IHttpClientFactory _httpClientFactory; public NamedClientModel(IHttpClientFactory httpClientFactory) => _httpClientFactory = httpClientFactory; public IEnumerable<GitHubBranch>? GitHubBranches { get; set; } public async Task OnGet() { var httpClient = _httpClientFactory.CreateClient(\"GitHub\"); var httpResponseMessage = await httpClient.GetAsync( \"repos/dotnet/AspNetCore.Docs/branches\"); if (httpResponseMessage.IsSuccessStatusCode) { using var contentStream = await httpResponseMessage.Content.ReadAsStreamAsync(); GitHubBranches = await JsonSerializer.DeserializeAsync <IEnumerable<GitHubBranch>>(contentStream); } } } In the preceding code, the request doesn't need to specify a hostname. The code can pass just the path, since the base address configured for the client is used.\n‚Ä¢ Provide the same capabilities as named clients without the need to use strings as keys.\n‚Ä¢ Provides IntelliSense and compiler help when consuming clients.\n‚Ä¢ Provide a single location to configure and interact with a particular . For example, a single typed client might be used:\n‚Ä¢ To encapsulate all logic dealing with the endpoint.\n‚Ä¢ Work with DI and can be injected where required in the app. A typed client accepts an parameter in its constructor: public class GitHubService { private readonly HttpClient _httpClient; public GitHubService(HttpClient httpClient) { _httpClient = httpClient; _httpClient.BaseAddress = new Uri(\"https://api.github.com/\"); // using Microsoft.Net.Http.Headers; // The GitHub API requires two headers. _httpClient.DefaultRequestHeaders.Add( HeaderNames.Accept, \"application/vnd.github.v3+json\"); _httpClient.DefaultRequestHeaders.Add( HeaderNames.UserAgent, \"HttpRequestsSample\"); } public async Task<IEnumerable<GitHubBranch>?> GetAspNetCoreDocsBranchesAsync() => await _httpClient.GetFromJsonAsync<IEnumerable<GitHubBranch>>( \"repos/dotnet/AspNetCore.Docs/branches\"); }\n‚Ä¢ The configuration is moved into the typed client.\n‚Ä¢ The provided instance is stored as a private field. API-specific methods can be created that expose functionality. For example, the method encapsulates code to retrieve docs GitHub branches. The following code calls AddHttpClient in to register the typed client class: The typed client is registered as transient with DI. In the preceding code, registers as a transient service. This registration uses a factory method to:\n‚Ä¢ Create an instance of , passing in the instance of to its constructor. The typed client can be injected and consumed directly: The configuration for a typed client can also be specified during its registration in , rather than in the typed client's constructor: can be used in combination with third-party libraries such as Refit. Refit is a REST library for .NET. It converts REST APIs into live interfaces. Call to generate a dynamic implementation of an interface, which uses to make the external HTTP calls. Call to generate the dynamic implementation and then call to configure the underlying : builder.Services.AddRefitClient<IGitHubClient>() .ConfigureHttpClient(httpClient => { httpClient.BaseAddress = new Uri(\"https://api.github.com/\"); // using Microsoft.Net.Http.Headers; // The GitHub API requires two headers. httpClient.DefaultRequestHeaders.Add( HeaderNames.Accept, \"application/vnd.github.v3+json\"); httpClient.DefaultRequestHeaders.Add( HeaderNames.UserAgent, \"HttpRequestsSample\"); }); Use DI to access the dynamic implementation of : In the preceding examples, all HTTP requests use the GET HTTP verb. also supports other HTTP verbs, including: For a complete list of supported HTTP verbs, see HttpMethod. The following example shows how to make an HTTP POST request: public async Task CreateItemAsync(TodoItem todoItem) { var todoItemJson = new StringContent( JsonSerializer.Serialize(todoItem), Encoding.UTF8, Application.Json); // using static System.Net.Mime.MediaTypeNames; using var httpResponseMessage = await _httpClient.PostAsync(\"/api/TodoItems\", todoItemJson); httpResponseMessage.EnsureSuccessStatusCode(); } In the preceding code, the method:\n‚Ä¢ Serializes the parameter to JSON using .\n‚Ä¢ Creates an instance of StringContent to package the serialized JSON for sending in the HTTP request's body.\n‚Ä¢ Calls PostAsync to send the JSON content to the specified URL. This is a relative URL that gets added to the HttpClient.BaseAddress.\n‚Ä¢ Calls EnsureSuccessStatusCode to throw an exception if the response status code doesn't indicate success. also supports other types of content. For example, MultipartContent and StreamContent. For a complete list of supported content, see HttpContent. The following example shows an HTTP PUT request: The preceding code is similar to the POST example. The method calls PutAsync instead of . The following example shows an HTTP DELETE request: In the preceding code, the method calls DeleteAsync. Because HTTP DELETE requests typically contain no body, the method doesn't provide an overload that accepts an instance of . To learn more about using different HTTP verbs with , see HttpClient. has the concept of delegating handlers that can be linked together for outgoing HTTP requests. :\n‚Ä¢ Simplifies defining the handlers to apply for each named client.\n‚Ä¢ Supports registration and chaining of multiple handlers to build an outgoing request middleware pipeline. Each of these handlers is able to perform work before and after the outgoing request. This pattern:\n‚Ä¢ Is similar to the inbound middleware pipeline in ASP.NET Core.\n‚Ä¢ Provides a mechanism to manage cross-cutting concerns around HTTP requests, such as:\n‚Ä¢ Override SendAsync. Execute code before passing the request to the next handler in the pipeline: public class ValidateHeaderHandler : DelegatingHandler { protected override async Task<HttpResponseMessage> SendAsync( HttpRequestMessage request, CancellationToken cancellationToken) { if (!request.Headers.Contains(\"X-API-KEY\")) { return new HttpResponseMessage(HttpStatusCode.BadRequest) { Content = new StringContent( \"The API key header X-API-KEY is required.\") }; } return await base.SendAsync(request, cancellationToken); } } The preceding code checks if the header is in the request. If is missing, BadRequest is returned. More than one handler can be added to the configuration for an with Microsoft.Extensions.DependencyInjection.HttpClientBuilderExtensions.AddHttpMessageHandler: In the preceding code, the is registered with DI. Once registered, AddHttpMessageHandler can be called, passing in the type for the handler. Multiple handlers can be registered in the order that they should execute. Each handler wraps the next handler until the final executes the request: In the preceding code, runs first, before . When creates a new delegating handler, it uses DI to fulfill the handler's constructor parameters. creates a separate DI scope for each handler, which can lead to surprising behavior when a handler consumes a scoped service. For example, consider the following interface and its implementation, which represents a task as an operation with an identifier, : As its name suggests, is registered with DI using a scoped lifetime: The following delegating handler consumes and uses to set the header for the outgoing request: In the download, navigate to and refresh the page. The request scope value changes for each request, but the handler scope value only changes every 5 seconds. Handlers can depend upon services of any scope. Services that handlers depend upon are disposed when the handler is disposed. Use one of the following approaches to share per-request state with message handlers:\n‚Ä¢ Pass data into the handler using HttpRequestMessage.Options.\n‚Ä¢ Use IHttpContextAccessor to access the current request. integrates with the third-party library Polly. Polly is a comprehensive resilience and transient fault-handling library for .NET. It allows developers to express policies such as Retry, Circuit Breaker, Timeout, Bulkhead Isolation, and Fallback in a fluent and thread-safe manner. Extension methods are provided to enable the use of Polly policies with configured instances. The Polly extensions support adding Polly-based handlers to clients. Polly requires the Microsoft.Extensions.Http.Polly NuGet package. Faults typically occur when external HTTP calls are transient. AddTransientHttpErrorPolicy allows a policy to be defined to handle transient errors. Policies configured with handle the following responses: provides access to a object configured to handle errors representing a possible transient fault: In the preceding code, a policy is defined. Failed requests are retried up to three times with a delay of 600 ms between attempts. Extension methods are provided to add Polly-based handlers, for example, AddPolicyHandler. The following overload inspects the request to decide which policy to apply: In the preceding code, if the outgoing request is an HTTP GET, a 10-second timeout is applied. For any other HTTP method, a 30-second timeout is used. In the preceding example:\n‚Ä¢ The first handler uses AddTransientHttpErrorPolicy to add a retry policy. Failed requests are retried up to three times.\n‚Ä¢ The second call adds a circuit breaker policy. Further external requests are blocked for 30 seconds if 5 failed attempts occur sequentially. Circuit breaker policies are stateful. All calls through this client share the same circuit state. An approach to managing regularly used policies is to define them once and register them with a . For example:\n‚Ä¢ Two policies, and , are added to the Polly registry.\n‚Ä¢ AddPolicyHandlerFromRegistry configures individual named clients to use these policies from the Polly registry. For more information on and Polly integrations, see the Polly wiki. A new instance is returned each time is called on the . An HttpMessageHandler is created per named client. The factory manages the lifetimes of the instances. pools the instances created by the factory to reduce resource consumption. An instance may be reused from the pool when creating a new instance if its lifetime hasn't expired. Pooling of handlers is desirable as each handler typically manages its own underlying HTTP connections. Creating more handlers than necessary can result in connection delays. Some handlers also keep connections open indefinitely, which can prevent the handler from reacting to DNS (Domain Name System) changes. The default handler lifetime is two minutes. The default value can be overridden on a per named client basis: instances can generally be treated as .NET objects not requiring disposal. Disposal cancels outgoing requests and guarantees the given instance can't be used after calling Dispose. tracks and disposes resources used by instances. Keeping a single instance alive for a long duration is a common pattern used before the inception of . This pattern becomes unnecessary after migrating to . There are alternative ways to solve the preceding problems using a long-lived SocketsHttpHandler instance.\n‚Ä¢ Create an instance of when the app starts and use it for the life of the app.\n‚Ä¢ Configure PooledConnectionLifetime to an appropriate value based on DNS refresh times. The preceding approaches solve the resource management problems that solves in a similar way.\n‚Ä¢ The shares connections across instances. This sharing prevents socket exhaustion.\n‚Ä¢ The cycles connections according to to avoid stale DNS problems. Clients created via record log messages for all requests. Enable the appropriate information level in the logging configuration to see the default log messages. Additional logging, such as the logging of request headers, is only included at trace level. The log category used for each client includes the name of the client. A client named MyNamedClient, for example, logs messages with a category of \"System.Net.Http.HttpClient.MyNamedClient.LogicalHandler\". Messages suffixed with LogicalHandler occur outside the request handler pipeline. On the request, messages are logged before any other handlers in the pipeline have processed it. On the response, messages are logged after any other pipeline handlers have received the response. Logging also occurs inside the request handler pipeline. In the MyNamedClient example, those messages are logged with the log category \"System.Net.Http.HttpClient.MyNamedClient.ClientHandler\". For the request, this occurs after all other handlers have run and immediately before the request is sent. On the response, this logging includes the state of the response before it passes back through the handler pipeline. Enabling logging outside and inside the pipeline enables inspection of the changes made by the other pipeline handlers. This may include changes to request headers or to the response status code. Including the name of the client in the log category enables log filtering for specific named clients. It may be necessary to control the configuration of the inner used by a client. An is returned when adding named or typed clients. The ConfigurePrimaryHttpMessageHandler extension method can be used to define a delegate. The delegate is used to create and configure the primary used by that client: The pooled instances results in objects being shared. Unanticipated object sharing often results in incorrect code. For apps that require cookies, consider either: In a console app, add the following package references to the project: In the following example:\n‚Ä¢ IHttpClientFactory and are registered in the Generic Host's service container.\n‚Ä¢ is requested from DI, which in-turn requests an instance of .\n‚Ä¢ uses to create an instance of , which it uses to retrieve docs GitHub branches. using System.Text.Json; using System.Text.Json.Serialization; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; using Microsoft.Extensions.Logging; var host = new HostBuilder() .ConfigureServices(services => { services.AddHttpClient(); services.AddTransient<GitHubService>(); }) .Build(); try { var gitHubService = host.Services.GetRequiredService<GitHubService>(); var gitHubBranches = await gitHubService.GetAspNetCoreDocsBranchesAsync(); Console.WriteLine($\"{gitHubBranches?.Count() ?? 0} GitHub Branches\"); if (gitHubBranches is not null) { foreach (var gitHubBranch in gitHubBranches) { Console.WriteLine($\"- {gitHubBranch.Name}\"); } } } catch (Exception ex) { host.Services.GetRequiredService<ILogger<Program>>() .LogError(ex, \"Unable to load branches from GitHub.\"); } public class GitHubService { private readonly IHttpClientFactory _httpClientFactory; public GitHubService(IHttpClientFactory httpClientFactory) => _httpClientFactory = httpClientFactory; public async Task<IEnumerable<GitHubBranch>?> GetAspNetCoreDocsBranchesAsync() { var httpRequestMessage = new HttpRequestMessage( HttpMethod.Get, \"https://api.github.com/repos/dotnet/AspNetCore.Docs/branches\") { Headers = { { \"Accept\", \"application/vnd.github.v3+json\" }, { \"User-Agent\", \"HttpRequestsConsoleSample\" } } }; var httpClient = _httpClientFactory.CreateClient(); var httpResponseMessage = await httpClient.SendAsync(httpRequestMessage); httpResponseMessage.EnsureSuccessStatusCode(); using var contentStream = await httpResponseMessage.Content.ReadAsStreamAsync(); return await JsonSerializer.DeserializeAsync <IEnumerable<GitHubBranch>>(contentStream); } } public record GitHubBranch( [property: JsonPropertyName(\"name\")] string Name); Header propagation is an ASP.NET Core middleware to propagate HTTP headers from the incoming request to the outgoing requests. To use header propagation:\n‚Ä¢ None Configure the and middleware pipeline in : // Add services to the container. builder.Services.AddControllers(); builder.Services.AddHttpClient(\"PropagateHeaders\") .AddHeaderPropagation(); builder.Services.AddHeaderPropagation(options => { options.Headers.Add(\"X-TraceId\"); }); var app = builder.Build(); // Configure the HTTP request pipeline. app.UseHttpsRedirection(); app.UseHeaderPropagation(); app.MapControllers();\n‚Ä¢ None Make outbound requests using the configured instance, which includes the added headers.\n‚Ä¢ View or download sample code (how to download)\n‚Ä¢ Implement HTTP call retries with exponential backoff with HttpClientFactory and Polly policies\n‚Ä¢ How to serialize and deserialize JSON in .NET\n\nAn IHttpClientFactory can be registered and used to configure and create HttpClient instances in an app. offers the following benefits:\n‚Ä¢ Provides a central location for naming and configuring logical instances. For example, a client named github could be registered and configured to access GitHub. A default client can be registered for general access.\n‚Ä¢ Codifies the concept of outgoing middleware via delegating handlers in . Provides extensions for Polly-based middleware to take advantage of delegating handlers in .\n‚Ä¢ Manages the pooling and lifetime of underlying instances. Automatic management avoids common DNS (Domain Name System) problems that occur when manually managing lifetimes.\n‚Ä¢ Adds a configurable logging experience (via ) for all requests sent through clients created by the factory. View or download sample code (how to download). The sample code in this topic version uses System.Text.Json to deserialize JSON content returned in HTTP responses. For samples that use and , use the version selector to select a 2.x version of this topic. There are several ways can be used in an app: The best approach depends upon the app's requirements. can be registered by calling : An can be requested using dependency injection (DI). The following code uses to create an instance: public class BasicUsageModel : PageModel { private readonly IHttpClientFactory _clientFactory; public IEnumerable<GitHubBranch> Branches { get; private set; } public bool GetBranchesError { get; private set; } public BasicUsageModel(IHttpClientFactory clientFactory) { _clientFactory = clientFactory; } public async Task OnGet() { var request = new HttpRequestMessage(HttpMethod.Get, \"https://api.github.com/repos/dotnet/AspNetCore.Docs/branches\"); request.Headers.Add(\"Accept\", \"application/vnd.github.v3+json\"); request.Headers.Add(\"User-Agent\", \"HttpClientFactory-Sample\"); var client = _clientFactory.CreateClient(); var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { using var responseStream = await response.Content.ReadAsStreamAsync(); Branches = await JsonSerializer.DeserializeAsync <IEnumerable<GitHubBranch>>(responseStream); } else { GetBranchesError = true; Branches = Array.Empty<GitHubBranch>(); } } } Using like in the preceding example is a good way to refactor an existing app. It has no impact on how is used. In places where instances are created in an existing app, replace those occurrences with calls to CreateClient.\n‚Ä¢ The app requires many distinct uses of .\n‚Ä¢ Many s have different configuration. Configuration for a named can be specified during registration in : In the preceding code the client is configured with:\n‚Ä¢ Two headers required to work with the GitHub API.\n‚Ä¢ A new instance of is created. To create a named client, pass its name into : public class NamedClientModel : PageModel { private readonly IHttpClientFactory _clientFactory; public IEnumerable<GitHubPullRequest> PullRequests { get; private set; } public bool GetPullRequestsError { get; private set; } public bool HasPullRequests => PullRequests.Any(); public NamedClientModel(IHttpClientFactory clientFactory) { _clientFactory = clientFactory; } public async Task OnGet() { var request = new HttpRequestMessage(HttpMethod.Get, \"repos/dotnet/AspNetCore.Docs/pulls\"); var client = _clientFactory.CreateClient(\"github\"); var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { using var responseStream = await response.Content.ReadAsStreamAsync(); PullRequests = await JsonSerializer.DeserializeAsync <IEnumerable<GitHubPullRequest>>(responseStream); } else { GetPullRequestsError = true; PullRequests = Array.Empty<GitHubPullRequest>(); } } } In the preceding code, the request doesn't need to specify a hostname. The code can pass just the path, since the base address configured for the client is used.\n‚Ä¢ Provide the same capabilities as named clients without the need to use strings as keys.\n‚Ä¢ Provides IntelliSense and compiler help when consuming clients.\n‚Ä¢ Provide a single location to configure and interact with a particular . For example, a single typed client might be used:\n‚Ä¢ To encapsulate all logic dealing with the endpoint.\n‚Ä¢ Work with DI and can be injected where required in the app. A typed client accepts an parameter in its constructor:\n‚Ä¢ The configuration is moved into the typed client.\n‚Ä¢ The object is exposed as a public property. API-specific methods can be created that expose functionality. For example, the method encapsulates code to retrieve open issues. The following code calls AddHttpClient in to register a typed client class: The typed client is registered as transient with DI. In the preceding code, registers as a transient service. This registration uses a factory method to:\n‚Ä¢ Create an instance of , passing in the instance of to its constructor. The typed client can be injected and consumed directly: public class TypedClientModel : PageModel { private readonly GitHubService _gitHubService; public IEnumerable<GitHubIssue> LatestIssues { get; private set; } public bool HasIssue => LatestIssues.Any(); public bool GetIssuesError { get; private set; } public TypedClientModel(GitHubService gitHubService) { _gitHubService = gitHubService; } public async Task OnGet() { try { LatestIssues = await _gitHubService.GetAspNetDocsIssues(); } catch(HttpRequestException) { GetIssuesError = true; LatestIssues = Array.Empty<GitHubIssue>(); } } } The configuration for a typed client can be specified during registration in , rather than in the typed client's constructor: The can be encapsulated within a typed client. Rather than exposing it as a property, define a method which calls the instance internally: In the preceding code, the is stored in a private field. Access to the is by the public method. can be used in combination with third-party libraries such as Refit. Refit is a REST library for .NET. It converts REST APIs into live interfaces. An implementation of the interface is generated dynamically by the , using to make the external HTTP calls. An interface and a reply are defined to represent the external API and its response: A typed client can be added, using Refit to generate the implementation: The defined interface can be consumed where necessary, with the implementation provided by DI and Refit: In the preceding examples, all HTTP requests use the GET HTTP verb. also supports other HTTP verbs, including: For a complete list of supported HTTP verbs, see HttpMethod. The following example shows how to make an HTTP POST request: In the preceding code, the method:\n‚Ä¢ Serializes the parameter to JSON using . This uses an instance of JsonSerializerOptions to configure the serialization process.\n‚Ä¢ Creates an instance of StringContent to package the serialized JSON for sending in the HTTP request's body.\n‚Ä¢ Calls PostAsync to send the JSON content to the specified URL. This is a relative URL that gets added to the HttpClient.BaseAddress.\n‚Ä¢ Calls EnsureSuccessStatusCode to throw an exception if the response status code does not indicate success. also supports other types of content. For example, MultipartContent and StreamContent. For a complete list of supported content, see HttpContent. The following example shows an HTTP PUT request: The preceding code is very similar to the POST example. The method calls PutAsync instead of . The following example shows an HTTP DELETE request: In the preceding code, the method calls DeleteAsync. Because HTTP DELETE requests typically contain no body, the method doesn't provide an overload that accepts an instance of . To learn more about using different HTTP verbs with , see HttpClient. has the concept of delegating handlers that can be linked together for outgoing HTTP requests. :\n‚Ä¢ Simplifies defining the handlers to apply for each named client.\n‚Ä¢ Supports registration and chaining of multiple handlers to build an outgoing request middleware pipeline. Each of these handlers is able to perform work before and after the outgoing request. This pattern:\n‚Ä¢ Is similar to the inbound middleware pipeline in ASP.NET Core.\n‚Ä¢ Provides a mechanism to manage cross-cutting concerns around HTTP requests, such as:\n‚Ä¢ Override SendAsync. Execute code before passing the request to the next handler in the pipeline: public class ValidateHeaderHandler : DelegatingHandler { protected override async Task<HttpResponseMessage> SendAsync( HttpRequestMessage request, CancellationToken cancellationToken) { if (!request.Headers.Contains(\"X-API-KEY\")) { return new HttpResponseMessage(HttpStatusCode.BadRequest) { Content = new StringContent( \"You must supply an API key header called X-API-KEY\") }; } return await base.SendAsync(request, cancellationToken); } } The preceding code checks if the header is in the request. If is missing, BadRequest is returned. More than one handler can be added to the configuration for an with Microsoft.Extensions.DependencyInjection.HttpClientBuilderExtensions.AddHttpMessageHandler: public void ConfigureServices(IServiceCollection services) { services.AddTransient<ValidateHeaderHandler>(); services.AddHttpClient(\"externalservice\", c => { // Assume this is an \"external\" service which requires an API KEY c.BaseAddress = new Uri(\"https://localhost:5001/\"); }) .AddHttpMessageHandler<ValidateHeaderHandler>(); // Remaining code deleted for brevity. In the preceding code, the is registered with DI. Once registered, AddHttpMessageHandler can be called, passing in the type for the handler. Multiple handlers can be registered in the order that they should execute. Each handler wraps the next handler until the final executes the request: services.AddTransient<SecureRequestHandler>(); services.AddTransient<RequestDataHandler>(); services.AddHttpClient(\"clientwithhandlers\") // This handler is on the outside and called first during the // request, last during the response. .AddHttpMessageHandler<SecureRequestHandler>() // This handler is on the inside, closest to the request being // sent. .AddHttpMessageHandler<RequestDataHandler>(); When creates a new delegating handler, it uses DI to fulfill the handler's constructor parameters. creates a separate DI scope for each handler, which can lead to surprising behavior when a handler consumes a scoped service. For example, consider the following interface and its implementation, which represents a task as an operation with an identifier, : As its name suggests, is registered with DI using a scoped lifetime: public void ConfigureServices(IServiceCollection services) { services.AddDbContext<TodoContext>(options => options.UseInMemoryDatabase(\"TodoItems\")); services.AddHttpContextAccessor(); services.AddHttpClient<TodoClient>((sp, httpClient) => { var httpRequest = sp.GetRequiredService<IHttpContextAccessor>().HttpContext.Request; // For sample purposes, assume TodoClient is used in the context of an incoming request. httpClient.BaseAddress = new Uri(UriHelper.BuildAbsolute(httpRequest.Scheme, httpRequest.Host, httpRequest.PathBase)); httpClient.Timeout = TimeSpan.FromSeconds(5); }); services.AddScoped<IOperationScoped, OperationScoped>(); services.AddTransient<OperationHandler>(); services.AddTransient<OperationResponseHandler>(); services.AddHttpClient(\"Operation\") .AddHttpMessageHandler<OperationHandler>() .AddHttpMessageHandler<OperationResponseHandler>() .SetHandlerLifetime(TimeSpan.FromSeconds(5)); services.AddControllers(); services.AddRazorPages(); } The following delegating handler consumes and uses to set the header for the outgoing request: In the download], navigate to and refresh the page. The request scope value changes for each request, but the handler scope value only changes every 5 seconds. Handlers can depend upon services of any scope. Services that handlers depend upon are disposed when the handler is disposed. Use one of the following approaches to share per-request state with message handlers:\n‚Ä¢ Pass data into the handler using HttpRequestMessage.Options.\n‚Ä¢ Use IHttpContextAccessor to access the current request. integrates with the third-party library Polly. Polly is a comprehensive resilience and transient fault-handling library for .NET. It allows developers to express policies such as Retry, Circuit Breaker, Timeout, Bulkhead Isolation, and Fallback in a fluent and thread-safe manner. Extension methods are provided to enable the use of Polly policies with configured instances. The Polly extensions support adding Polly-based handlers to clients. Polly requires the Microsoft.Extensions.Http.Polly NuGet package. Faults typically occur when external HTTP calls are transient. AddTransientHttpErrorPolicy allows a policy to be defined to handle transient errors. Policies configured with handle the following responses: provides access to a object configured to handle errors representing a possible transient fault: In the preceding code, a policy is defined. Failed requests are retried up to three times with a delay of 600 ms between attempts. Extension methods are provided to add Polly-based handlers, for example, AddPolicyHandler. The following overload inspects the request to decide which policy to apply: var timeout = Policy.TimeoutAsync<HttpResponseMessage>( TimeSpan.FromSeconds(10)); var longTimeout = Policy.TimeoutAsync<HttpResponseMessage>( TimeSpan.FromSeconds(30)); services.AddHttpClient(\"conditionalpolicy\") // Run some code to select a policy based on the request .AddPolicyHandler(request => request.Method == HttpMethod.Get ? timeout : longTimeout); In the preceding code, if the outgoing request is an HTTP GET, a 10-second timeout is applied. For any other HTTP method, a 30-second timeout is used. In the preceding example:\n‚Ä¢ The first handler uses AddTransientHttpErrorPolicy to add a retry policy. Failed requests are retried up to three times.\n‚Ä¢ The second call adds a circuit breaker policy. Further external requests are blocked for 30 seconds if 5 failed attempts occur sequentially. Circuit breaker policies are stateful. All calls through this client share the same circuit state. An approach to managing regularly used policies is to define them once and register them with a .\n‚Ä¢ The \"regular\" and \"long\" policies are added.\n‚Ä¢ AddPolicyHandlerFromRegistry adds the \"regular\" and \"long\" policies from the registry. For more information on and Polly integrations, see the Polly wiki. A new instance is returned each time is called on the . An HttpMessageHandler is created per named client. The factory manages the lifetimes of the instances. pools the instances created by the factory to reduce resource consumption. An instance may be reused from the pool when creating a new instance if its lifetime hasn't expired. Pooling of handlers is desirable as each handler typically manages its own underlying HTTP connections. Creating more handlers than necessary can result in connection delays. Some handlers also keep connections open indefinitely, which can prevent the handler from reacting to DNS (Domain Name System) changes. The default handler lifetime is two minutes. The default value can be overridden on a per named client basis: instances can generally be treated as .NET objects not requiring disposal. Disposal cancels outgoing requests and guarantees the given instance can't be used after calling Dispose. tracks and disposes resources used by instances. Keeping a single instance alive for a long duration is a common pattern used before the inception of . This pattern becomes unnecessary after migrating to . There are alternative ways to solve the preceding problems using a long-lived SocketsHttpHandler instance.\n‚Ä¢ Create an instance of when the app starts and use it for the life of the app.\n‚Ä¢ Configure PooledConnectionLifetime to an appropriate value based on DNS refresh times. The preceding approaches solve the resource management problems that solves in a similar way.\n‚Ä¢ The shares connections across instances. This sharing prevents socket exhaustion.\n‚Ä¢ The cycles connections according to to avoid stale DNS problems. The pooled instances results in objects being shared. Unanticipated object sharing often results in incorrect code. For apps that require cookies, consider either: Clients created via record log messages for all requests. Enable the appropriate information level in the logging configuration to see the default log messages. Additional logging, such as the logging of request headers, is only included at trace level. The log category used for each client includes the name of the client. A client named MyNamedClient, for example, logs messages with a category of \"System.Net.Http.HttpClient.MyNamedClient.LogicalHandler\". Messages suffixed with LogicalHandler occur outside the request handler pipeline. On the request, messages are logged before any other handlers in the pipeline have processed it. On the response, messages are logged after any other pipeline handlers have received the response. Logging also occurs inside the request handler pipeline. In the MyNamedClient example, those messages are logged with the log category \"System.Net.Http.HttpClient.MyNamedClient.ClientHandler\". For the request, this occurs after all other handlers have run and immediately before the request is sent. On the response, this logging includes the state of the response before it passes back through the handler pipeline. Enabling logging outside and inside the pipeline enables inspection of the changes made by the other pipeline handlers. This may include changes to request headers or to the response status code. Including the name of the client in the log category enables log filtering for specific named clients. It may be necessary to control the configuration of the inner used by a client. An is returned when adding named or typed clients. The ConfigurePrimaryHttpMessageHandler extension method can be used to define a delegate. The delegate is used to create and configure the primary used by that client: In a console app, add the following package references to the project: In the following example:\n‚Ä¢ IHttpClientFactory is registered in the Generic Host's service container.\n‚Ä¢ creates a client factory instance from the service, which is used to create an . is used to retrieve a webpage.\n‚Ä¢ creates a scope to execute the service's method and write the first 500 characters of the webpage content to the console. using System; using System.Net.Http; using System.Threading.Tasks; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; using Microsoft.Extensions.Logging; class Program { static async Task<int> Main(string[] args) { var builder = new HostBuilder() .ConfigureServices((hostContext, services) => { services.AddHttpClient(); services.AddTransient<IMyService, MyService>(); }).UseConsoleLifetime(); var host = builder.Build(); try { var myService = host.Services.GetRequiredService<IMyService>(); var pageContent = await myService.GetPage(); Console.WriteLine(pageContent.Substring(0, 500)); } catch (Exception ex) { var logger = host.Services.GetRequiredService<ILogger<Program>>(); logger.LogError(ex, \"An error occurred.\"); } return 0; } public interface IMyService { Task<string> GetPage(); } public class MyService : IMyService { private readonly IHttpClientFactory _clientFactory; public MyService(IHttpClientFactory clientFactory) { _clientFactory = clientFactory; } public async Task<string> GetPage() { // Content from BBC One: Dr. Who website (¬©BBC) var request = new HttpRequestMessage(HttpMethod.Get, \"https://www.bbc.co.uk/programmes/b006q2x0\"); var client = _clientFactory.CreateClient(); var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { return await response.Content.ReadAsStringAsync(); } else { return $\"StatusCode: {response.StatusCode}\"; } } } } Header propagation is an ASP.NET Core middleware to propagate HTTP headers from the incoming request to the outgoing HTTP Client requests. To use header propagation:\n‚Ä¢ None Configure the middleware and in :\n‚Ä¢ None The client includes the configured headers on outbound requests:\n‚Ä¢ Implement HTTP call retries with exponential backoff with HttpClientFactory and Polly policies\n‚Ä¢ How to serialize and deserialize JSON in .NET\n\nAn IHttpClientFactory can be registered and used to configure and create HttpClient instances in an app. offers the following benefits:\n‚Ä¢ Provides a central location for naming and configuring logical instances. For example, a client named github could be registered and configured to access GitHub. A default client can be registered for general access.\n‚Ä¢ Codifies the concept of outgoing middleware via delegating handlers in . Provides extensions for Polly-based middleware to take advantage of delegating handlers in .\n‚Ä¢ Manages the pooling and lifetime of underlying instances. Automatic management avoids common DNS (Domain Name System) problems that occur when manually managing lifetimes.\n‚Ä¢ Adds a configurable logging experience (via ) for all requests sent through clients created by the factory. View or download sample code (how to download). The sample code in this topic version uses System.Text.Json to deserialize JSON content returned in HTTP responses. For samples that use and , use the version selector to select a 2.x version of this topic. There are several ways can be used in an app: The best approach depends upon the app's requirements. can be registered by calling : An can be requested using dependency injection (DI). The following code uses to create an instance: public class BasicUsageModel : PageModel { private readonly IHttpClientFactory _clientFactory; public IEnumerable<GitHubBranch> Branches { get; private set; } public bool GetBranchesError { get; private set; } public BasicUsageModel(IHttpClientFactory clientFactory) { _clientFactory = clientFactory; } public async Task OnGet() { var request = new HttpRequestMessage(HttpMethod.Get, \"https://api.github.com/repos/dotnet/AspNetCore.Docs/branches\"); request.Headers.Add(\"Accept\", \"application/vnd.github.v3+json\"); request.Headers.Add(\"User-Agent\", \"HttpClientFactory-Sample\"); var client = _clientFactory.CreateClient(); var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { using var responseStream = await response.Content.ReadAsStreamAsync(); Branches = await JsonSerializer.DeserializeAsync <IEnumerable<GitHubBranch>>(responseStream); } else { GetBranchesError = true; Branches = Array.Empty<GitHubBranch>(); } } } Using like in the preceding example is a good way to refactor an existing app. It has no impact on how is used. In places where instances are created in an existing app, replace those occurrences with calls to CreateClient.\n‚Ä¢ The app requires many distinct uses of .\n‚Ä¢ Many s have different configuration. Configuration for a named can be specified during registration in : In the preceding code the client is configured with:\n‚Ä¢ Two headers required to work with the GitHub API.\n‚Ä¢ A new instance of is created. To create a named client, pass its name into : public class NamedClientModel : PageModel { private readonly IHttpClientFactory _clientFactory; public IEnumerable<GitHubPullRequest> PullRequests { get; private set; } public bool GetPullRequestsError { get; private set; } public bool HasPullRequests => PullRequests.Any(); public NamedClientModel(IHttpClientFactory clientFactory) { _clientFactory = clientFactory; } public async Task OnGet() { var request = new HttpRequestMessage(HttpMethod.Get, \"repos/dotnet/AspNetCore.Docs/pulls\"); var client = _clientFactory.CreateClient(\"github\"); var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { using var responseStream = await response.Content.ReadAsStreamAsync(); PullRequests = await JsonSerializer.DeserializeAsync <IEnumerable<GitHubPullRequest>>(responseStream); } else { GetPullRequestsError = true; PullRequests = Array.Empty<GitHubPullRequest>(); } } } In the preceding code, the request doesn't need to specify a hostname. The code can pass just the path, since the base address configured for the client is used.\n‚Ä¢ Provide the same capabilities as named clients without the need to use strings as keys.\n‚Ä¢ Provides IntelliSense and compiler help when consuming clients.\n‚Ä¢ Provide a single location to configure and interact with a particular . For example, a single typed client might be used:\n‚Ä¢ To encapsulate all logic dealing with the endpoint.\n‚Ä¢ Work with DI and can be injected where required in the app. A typed client accepts an parameter in its constructor: public class GitHubService { public HttpClient Client { get; } public GitHubService(HttpClient client) { client.BaseAddress = new Uri(\"https://api.github.com/\"); // GitHub API versioning client.DefaultRequestHeaders.Add(\"Accept\", \"application/vnd.github.v3+json\"); // GitHub requires a user-agent client.DefaultRequestHeaders.Add(\"User-Agent\", \"HttpClientFactory-Sample\"); Client = client; } public async Task<IEnumerable<GitHubIssue>> GetAspNetDocsIssues() { var response = await Client.GetAsync( \"/repos/dotnet/AspNetCore.Docs/issues?state=open&sort=created&direction=desc\"); response.EnsureSuccessStatusCode(); using var responseStream = await response.Content.ReadAsStreamAsync(); return await JsonSerializer.DeserializeAsync <IEnumerable<GitHubIssue>>(responseStream); } } If you would like to see code comments translated to languages other than English, let us know in this GitHub discussion issue.\n‚Ä¢ The configuration is moved into the typed client.\n‚Ä¢ The object is exposed as a public property. API-specific methods can be created that expose functionality. For example, the method encapsulates code to retrieve open issues. The following code calls AddHttpClient in to register a typed client class: The typed client is registered as transient with DI. In the preceding code, registers as a transient service. This registration uses a factory method to:\n‚Ä¢ Create an instance of , passing in the instance of to its constructor. The typed client can be injected and consumed directly: public class TypedClientModel : PageModel { private readonly GitHubService _gitHubService; public IEnumerable<GitHubIssue> LatestIssues { get; private set; } public bool HasIssue => LatestIssues.Any(); public bool GetIssuesError { get; private set; } public TypedClientModel(GitHubService gitHubService) { _gitHubService = gitHubService; } public async Task OnGet() { try { LatestIssues = await _gitHubService.GetAspNetDocsIssues(); } catch(HttpRequestException) { GetIssuesError = true; LatestIssues = Array.Empty<GitHubIssue>(); } } } The configuration for a typed client can be specified during registration in , rather than in the typed client's constructor: The can be encapsulated within a typed client. Rather than exposing it as a property, define a method which calls the instance internally: In the preceding code, the is stored in a private field. Access to the is by the public method. can be used in combination with third-party libraries such as Refit. Refit is a REST library for .NET. It converts REST APIs into live interfaces. An implementation of the interface is generated dynamically by the , using to make the external HTTP calls. An interface and a reply are defined to represent the external API and its response: A typed client can be added, using Refit to generate the implementation: The defined interface can be consumed where necessary, with the implementation provided by DI and Refit: In the preceding examples, all HTTP requests use the GET HTTP verb. also supports other HTTP verbs, including: For a complete list of supported HTTP verbs, see HttpMethod. The following example shows how to make an HTTP POST request: In the preceding code, the method:\n‚Ä¢ Serializes the parameter to JSON using . This uses an instance of JsonSerializerOptions to configure the serialization process.\n‚Ä¢ Creates an instance of StringContent to package the serialized JSON for sending in the HTTP request's body.\n‚Ä¢ Calls PostAsync to send the JSON content to the specified URL. This is a relative URL that gets added to the HttpClient.BaseAddress.\n‚Ä¢ Calls EnsureSuccessStatusCode to throw an exception if the response status code does not indicate success. also supports other types of content. For example, MultipartContent and StreamContent. For a complete list of supported content, see HttpContent. The following example shows an HTTP PUT request: The preceding code is very similar to the POST example. The method calls PutAsync instead of . The following example shows an HTTP DELETE request: In the preceding code, the method calls DeleteAsync. Because HTTP DELETE requests typically contain no body, the method doesn't provide an overload that accepts an instance of . To learn more about using different HTTP verbs with , see HttpClient. has the concept of delegating handlers that can be linked together for outgoing HTTP requests. :\n‚Ä¢ Simplifies defining the handlers to apply for each named client.\n‚Ä¢ Supports registration and chaining of multiple handlers to build an outgoing request middleware pipeline. Each of these handlers is able to perform work before and after the outgoing request. This pattern:\n‚Ä¢ Is similar to the inbound middleware pipeline in ASP.NET Core.\n‚Ä¢ Provides a mechanism to manage cross-cutting concerns around HTTP requests, such as:\n‚Ä¢ Override SendAsync. Execute code before passing the request to the next handler in the pipeline: public class ValidateHeaderHandler : DelegatingHandler { protected override async Task<HttpResponseMessage> SendAsync( HttpRequestMessage request, CancellationToken cancellationToken) { if (!request.Headers.Contains(\"X-API-KEY\")) { return new HttpResponseMessage(HttpStatusCode.BadRequest) { Content = new StringContent( \"You must supply an API key header called X-API-KEY\") }; } return await base.SendAsync(request, cancellationToken); } } The preceding code checks if the header is in the request. If is missing, BadRequest is returned. More than one handler can be added to the configuration for an with Microsoft.Extensions.DependencyInjection.HttpClientBuilderExtensions.AddHttpMessageHandler: public void ConfigureServices(IServiceCollection services) { services.AddTransient<ValidateHeaderHandler>(); services.AddHttpClient(\"externalservice\", c => { // Assume this is an \"external\" service which requires an API KEY c.BaseAddress = new Uri(\"https://localhost:5001/\"); }) .AddHttpMessageHandler<ValidateHeaderHandler>(); // Remaining code deleted for brevity. In the preceding code, the is registered with DI. Once registered, AddHttpMessageHandler can be called, passing in the type for the handler. Multiple handlers can be registered in the order that they should execute. Each handler wraps the next handler until the final executes the request: services.AddTransient<SecureRequestHandler>(); services.AddTransient<RequestDataHandler>(); services.AddHttpClient(\"clientwithhandlers\") // This handler is on the outside and called first during the // request, last during the response. .AddHttpMessageHandler<SecureRequestHandler>() // This handler is on the inside, closest to the request being // sent. .AddHttpMessageHandler<RequestDataHandler>(); When creates a new delegating handler, it uses DI to fulfill the handler's constructor parameters. creates a separate DI scope for each handler, which can lead to surprising behavior when a handler consumes a scoped service. For example, consider the following interface and its implementation, which represents a task as an operation with an identifier, : As its name suggests, is registered with DI using a scoped lifetime: public void ConfigureServices(IServiceCollection services) { services.AddDbContext<TodoContext>(options => options.UseInMemoryDatabase(\"TodoItems\")); services.AddHttpContextAccessor(); services.AddHttpClient<TodoClient>((sp, httpClient) => { var httpRequest = sp.GetRequiredService<IHttpContextAccessor>().HttpContext.Request; // For sample purposes, assume TodoClient is used in the context of an incoming request. httpClient.BaseAddress = new Uri(UriHelper.BuildAbsolute(httpRequest.Scheme, httpRequest.Host, httpRequest.PathBase)); httpClient.Timeout = TimeSpan.FromSeconds(5); }); services.AddScoped<IOperationScoped, OperationScoped>(); services.AddTransient<OperationHandler>(); services.AddTransient<OperationResponseHandler>(); services.AddHttpClient(\"Operation\") .AddHttpMessageHandler<OperationHandler>() .AddHttpMessageHandler<OperationResponseHandler>() .SetHandlerLifetime(TimeSpan.FromSeconds(5)); services.AddControllers(); services.AddRazorPages(); } The following delegating handler consumes and uses to set the header for the outgoing request: In the download], navigate to and refresh the page. The request scope value changes for each request, but the handler scope value only changes every 5 seconds. Handlers can depend upon services of any scope. Services that handlers depend upon are disposed when the handler is disposed. Use one of the following approaches to share per-request state with message handlers:\n‚Ä¢ Pass data into the handler using HttpRequestMessage.Properties.\n‚Ä¢ Use IHttpContextAccessor to access the current request. integrates with the third-party library Polly. Polly is a comprehensive resilience and transient fault-handling library for .NET. It allows developers to express policies such as Retry, Circuit Breaker, Timeout, Bulkhead Isolation, and Fallback in a fluent and thread-safe manner. Extension methods are provided to enable the use of Polly policies with configured instances. The Polly extensions support adding Polly-based handlers to clients. Polly requires the Microsoft.Extensions.Http.Polly NuGet package. Faults typically occur when external HTTP calls are transient. AddTransientHttpErrorPolicy allows a policy to be defined to handle transient errors. Policies configured with handle the following responses: provides access to a object configured to handle errors representing a possible transient fault: In the preceding code, a policy is defined. Failed requests are retried up to three times with a delay of 600 ms between attempts. Extension methods are provided to add Polly-based handlers, for example, AddPolicyHandler. The following overload inspects the request to decide which policy to apply: var timeout = Policy.TimeoutAsync<HttpResponseMessage>( TimeSpan.FromSeconds(10)); var longTimeout = Policy.TimeoutAsync<HttpResponseMessage>( TimeSpan.FromSeconds(30)); services.AddHttpClient(\"conditionalpolicy\") // Run some code to select a policy based on the request .AddPolicyHandler(request => request.Method == HttpMethod.Get ? timeout : longTimeout); In the preceding code, if the outgoing request is an HTTP GET, a 10-second timeout is applied. For any other HTTP method, a 30-second timeout is used. In the preceding example:\n‚Ä¢ The first handler uses AddTransientHttpErrorPolicy to add a retry policy. Failed requests are retried up to three times.\n‚Ä¢ The second call adds a circuit breaker policy. Further external requests are blocked for 30 seconds if 5 failed attempts occur sequentially. Circuit breaker policies are stateful. All calls through this client share the same circuit state. An approach to managing regularly used policies is to define them once and register them with a .\n‚Ä¢ The \"regular\" and \"long\" policies are added.\n‚Ä¢ AddPolicyHandlerFromRegistry adds the \"regular\" and \"long\" policies from the registry. For more information on and Polly integrations, see the Polly wiki. A new instance is returned each time is called on the . An HttpMessageHandler is created per named client. The factory manages the lifetimes of the instances. pools the instances created by the factory to reduce resource consumption. An instance may be reused from the pool when creating a new instance if its lifetime hasn't expired. Pooling of handlers is desirable as each handler typically manages its own underlying HTTP connections. Creating more handlers than necessary can result in connection delays. Some handlers also keep connections open indefinitely, which can prevent the handler from reacting to DNS (Domain Name System) changes. The default handler lifetime is two minutes. The default value can be overridden on a per named client basis: instances can generally be treated as .NET objects not requiring disposal. Disposal cancels outgoing requests and guarantees the given instance can't be used after calling Dispose. tracks and disposes resources used by instances. Keeping a single instance alive for a long duration is a common pattern used before the inception of . This pattern becomes unnecessary after migrating to . There are alternative ways to solve the preceding problems using a long-lived SocketsHttpHandler instance.\n‚Ä¢ Create an instance of when the app starts and use it for the life of the app.\n‚Ä¢ Configure PooledConnectionLifetime to an appropriate value based on DNS refresh times. The preceding approaches solve the resource management problems that solves in a similar way.\n‚Ä¢ The shares connections across instances. This sharing prevents socket exhaustion.\n‚Ä¢ The cycles connections according to to avoid stale DNS problems. The pooled instances results in objects being shared. Unanticipated object sharing often results in incorrect code. For apps that require cookies, consider either: Clients created via record log messages for all requests. Enable the appropriate information level in the logging configuration to see the default log messages. Additional logging, such as the logging of request headers, is only included at trace level. The log category used for each client includes the name of the client. A client named MyNamedClient, for example, logs messages with a category of \"System.Net.Http.HttpClient.MyNamedClient.LogicalHandler\". Messages suffixed with LogicalHandler occur outside the request handler pipeline. On the request, messages are logged before any other handlers in the pipeline have processed it. On the response, messages are logged after any other pipeline handlers have received the response. Logging also occurs inside the request handler pipeline. In the MyNamedClient example, those messages are logged with the log category \"System.Net.Http.HttpClient.MyNamedClient.ClientHandler\". For the request, this occurs after all other handlers have run and immediately before the request is sent. On the response, this logging includes the state of the response before it passes back through the handler pipeline. Enabling logging outside and inside the pipeline enables inspection of the changes made by the other pipeline handlers. This may include changes to request headers or to the response status code. Including the name of the client in the log category enables log filtering for specific named clients. It may be necessary to control the configuration of the inner used by a client. An is returned when adding named or typed clients. The ConfigurePrimaryHttpMessageHandler extension method can be used to define a delegate. The delegate is used to create and configure the primary used by that client: In a console app, add the following package references to the project: In the following example:\n‚Ä¢ IHttpClientFactory is registered in the Generic Host's service container.\n‚Ä¢ creates a client factory instance from the service, which is used to create an . is used to retrieve a webpage.\n‚Ä¢ creates a scope to execute the service's method and write the first 500 characters of the webpage content to the console. using System; using System.Net.Http; using System.Threading.Tasks; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; using Microsoft.Extensions.Logging; class Program { static async Task<int> Main(string[] args) { var builder = new HostBuilder() .ConfigureServices((hostContext, services) => { services.AddHttpClient(); services.AddTransient<IMyService, MyService>(); }).UseConsoleLifetime(); var host = builder.Build(); try { var myService = host.Services.GetRequiredService<IMyService>(); var pageContent = await myService.GetPage(); Console.WriteLine(pageContent.Substring(0, 500)); } catch (Exception ex) { var logger = host.Services.GetRequiredService<ILogger<Program>>(); logger.LogError(ex, \"An error occurred.\"); } return 0; } public interface IMyService { Task<string> GetPage(); } public class MyService : IMyService { private readonly IHttpClientFactory _clientFactory; public MyService(IHttpClientFactory clientFactory) { _clientFactory = clientFactory; } public async Task<string> GetPage() { // Content from BBC One: Dr. Who website (¬©BBC) var request = new HttpRequestMessage(HttpMethod.Get, \"https://www.bbc.co.uk/programmes/b006q2x0\"); var client = _clientFactory.CreateClient(); var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { return await response.Content.ReadAsStringAsync(); } else { return $\"StatusCode: {response.StatusCode}\"; } } } } Header propagation is an ASP.NET Core middleware to propagate HTTP headers from the incoming request to the outgoing HTTP Client requests. To use header propagation:\n‚Ä¢ None Configure the middleware and in :\n‚Ä¢ None The client includes the configured headers on outbound requests:\n‚Ä¢ Implement HTTP call retries with exponential backoff with HttpClientFactory and Polly policies\n‚Ä¢ How to serialize and deserialize JSON in .NET\n\nAn IHttpClientFactory can be registered and used to configure and create HttpClient instances in an app. It offers the following benefits:\n‚Ä¢ Provides a central location for naming and configuring logical instances. For example, a github client can be registered and configured to access GitHub. A default client can be registered for other purposes.\n‚Ä¢ Codifies the concept of outgoing middleware via delegating handlers in and provides extensions for Polly-based middleware to take advantage of that.\n‚Ä¢ Manages the pooling and lifetime of underlying instances to avoid common DNS problems that occur when manually managing lifetimes.\n‚Ä¢ Adds a configurable logging experience (via ) for all requests sent through clients created by the factory. View or download sample code (how to download) Projects targeting .NET Framework require installation of the Microsoft.Extensions.Http NuGet package. Projects that target .NET Core and reference the Microsoft.AspNetCore.App metapackage already include the package. There are several ways can be used in an app: None of them are strictly superior to another. The best approach depends upon the app's constraints. The can be registered by calling the extension method on the , inside the method. Once registered, code can accept an anywhere services can be injected with dependency injection (DI). The can be used to create an instance: public class BasicUsageModel : PageModel { private readonly IHttpClientFactory _clientFactory; public IEnumerable<GitHubBranch> Branches { get; private set; } public bool GetBranchesError { get; private set; } public BasicUsageModel(IHttpClientFactory clientFactory) { _clientFactory = clientFactory; } public async Task OnGet() { var request = new HttpRequestMessage(HttpMethod.Get, \"https://api.github.com/repos/dotnet/AspNetCore.Docs/branches\"); request.Headers.Add(\"Accept\", \"application/vnd.github.v3+json\"); request.Headers.Add(\"User-Agent\", \"HttpClientFactory-Sample\"); var client = _clientFactory.CreateClient(); var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { Branches = await response.Content .ReadAsAsync<IEnumerable<GitHubBranch>>(); } else { GetBranchesError = true; Branches = Array.Empty<GitHubBranch>(); } } } Using in this fashion is a good way to refactor an existing app. It has no impact on the way is used. In places where instances are currently created, replace those occurrences with a call to CreateClient. If an app requires many distinct uses of , each with a different configuration, an option is to use named clients. Configuration for a named can be specified during registration in . In the preceding code, is called, providing the name github. This client has some default configuration applied‚Äînamely the base address and two headers required to work with the GitHub API. Each time is called, a new instance of is created and the configuration action is called. To consume a named client, a string parameter can be passed to . Specify the name of the client to be created: public class NamedClientModel : PageModel { private readonly IHttpClientFactory _clientFactory; public IEnumerable<GitHubPullRequest> PullRequests { get; private set; } public bool GetPullRequestsError { get; private set; } public bool HasPullRequests => PullRequests.Any(); public NamedClientModel(IHttpClientFactory clientFactory) { _clientFactory = clientFactory; } public async Task OnGet() { var request = new HttpRequestMessage(HttpMethod.Get, \"repos/dotnet/AspNetCore.Docs/pulls\"); var client = _clientFactory.CreateClient(\"github\"); var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { PullRequests = await response.Content .ReadAsAsync<IEnumerable<GitHubPullRequest>>(); } else { GetPullRequestsError = true; PullRequests = Array.Empty<GitHubPullRequest>(); } } } In the preceding code, the request doesn't need to specify a hostname. It can pass just the path, since the base address configured for the client is used.\n‚Ä¢ Provide the same capabilities as named clients without the need to use strings as keys.\n‚Ä¢ Provides IntelliSense and compiler help when consuming clients.\n‚Ä¢ Provide a single location to configure and interact with a particular . For example, a single typed client might be used for a single backend endpoint and encapsulate all logic dealing with that endpoint.\n‚Ä¢ Work with DI and can be injected where required in your app. A typed client accepts an parameter in its constructor: In the preceding code, the configuration is moved into the typed client. The object is exposed as a public property. It's possible to define API-specific methods that expose functionality. The method encapsulates the code needed to query for and parse out the latest open issues from a GitHub repository. To register a typed client, the generic AddHttpClient extension method can be used within , specifying the typed client class: The typed client is registered as transient with DI. The typed client can be injected and consumed directly: public class TypedClientModel : PageModel { private readonly GitHubService _gitHubService; public IEnumerable<GitHubIssue> LatestIssues { get; private set; } public bool HasIssue => LatestIssues.Any(); public bool GetIssuesError { get; private set; } public TypedClientModel(GitHubService gitHubService) { _gitHubService = gitHubService; } public async Task OnGet() { try { LatestIssues = await _gitHubService.GetAspNetDocsIssues(); } catch(HttpRequestException) { GetIssuesError = true; LatestIssues = Array.Empty<GitHubIssue>(); } } } If preferred, the configuration for a typed client can be specified during registration in , rather than in the typed client's constructor: It's possible to entirely encapsulate the within a typed client. Rather than exposing it as a property, public methods can be provided which call the instance internally. In the preceding code, the is stored as a private field. All access to make external calls goes through the method. can be used in combination with other third-party libraries such as Refit. Refit is a REST library for .NET. It converts REST APIs into live interfaces. An implementation of the interface is generated dynamically by the , using to make the external HTTP calls. An interface and a reply are defined to represent the external API and its response: A typed client can be added, using Refit to generate the implementation: The defined interface can be consumed where necessary, with the implementation provided by DI and Refit: already has the concept of delegating handlers that can be linked together for outgoing HTTP requests. The makes it easy to define the handlers to apply for each named client. It supports registration and chaining of multiple handlers to build an outgoing request middleware pipeline. Each of these handlers is able to perform work before and after the outgoing request. This pattern is similar to the inbound middleware pipeline in ASP.NET Core. The pattern provides a mechanism to manage cross-cutting concerns around HTTP requests, including caching, error handling, serialization, and logging. To create a handler, define a class deriving from DelegatingHandler. Override the method to execute code before passing the request to the next handler in the pipeline: public class ValidateHeaderHandler : DelegatingHandler { protected override async Task<HttpResponseMessage> SendAsync( HttpRequestMessage request, CancellationToken cancellationToken) { if (!request.Headers.Contains(\"X-API-KEY\")) { return new HttpResponseMessage(HttpStatusCode.BadRequest) { Content = new StringContent( \"You must supply an API key header called X-API-KEY\") }; } return await base.SendAsync(request, cancellationToken); } } The preceding code defines a basic handler. It checks to see if an header has been included on the request. If the header is missing, it can avoid the HTTP call and return a suitable response. During registration, one or more handlers can be added to the configuration for an . This task is accomplished via extension methods on the IHttpClientBuilder. services.AddTransient<ValidateHeaderHandler>(); services.AddHttpClient(\"externalservice\", c => { // Assume this is an \"external\" service which requires an API KEY c.BaseAddress = new Uri(\"https://localhost:5000/\"); }) .AddHttpMessageHandler<ValidateHeaderHandler>(); In the preceding code, the is registered with DI. The handler must be registered in DI as a transient service, never scoped. If the handler is registered as a scoped service and any services that the handler depends upon are disposable:\n‚Ä¢ The handler's services could be disposed before the handler goes out of scope.\n‚Ä¢ The disposed handler services causes the handler to fail. Once registered, AddHttpMessageHandler can be called, passing in the handler type. Multiple handlers can be registered in the order that they should execute. Each handler wraps the next handler until the final executes the request: services.AddTransient<SecureRequestHandler>(); services.AddTransient<RequestDataHandler>(); services.AddHttpClient(\"clientwithhandlers\") // This handler is on the outside and called first during the // request, last during the response. .AddHttpMessageHandler<SecureRequestHandler>() // This handler is on the inside, closest to the request being // sent. .AddHttpMessageHandler<RequestDataHandler>(); Use one of the following approaches to share per-request state with message handlers:\n‚Ä¢ Pass data into the handler using .\n‚Ä¢ Use to access the current request. integrates with a popular third-party library called Polly. Polly is a comprehensive resilience and transient fault-handling library for .NET. It allows developers to express policies such as Retry, Circuit Breaker, Timeout, Bulkhead Isolation, and Fallback in a fluent and thread-safe manner. Extension methods are provided to enable the use of Polly policies with configured instances. The Polly extensions:\n‚Ä¢ Can be used after installing the Microsoft.Extensions.Http.Polly NuGet package. The package isn't included in the ASP.NET Core shared framework. Most common faults occur when external HTTP calls are transient. A convenient extension method called is included which allows a policy to be defined to handle transient errors. Policies configured with this extension method handle , HTTP 5xx responses, and HTTP 408 responses. The extension can be used within . The extension provides access to a object configured to handle errors representing a possible transient fault: In the preceding code, a policy is defined. Failed requests are retried up to three times with a delay of 600 ms between attempts. Additional extension methods exist which can be used to add Polly-based handlers. One such extension is , which has multiple overloads. One overload allows the request to be inspected when defining which policy to apply: var timeout = Policy.TimeoutAsync<HttpResponseMessage>( TimeSpan.FromSeconds(10)); var longTimeout = Policy.TimeoutAsync<HttpResponseMessage>( TimeSpan.FromSeconds(30)); services.AddHttpClient(\"conditionalpolicy\") // Run some code to select a policy based on the request .AddPolicyHandler(request => request.Method == HttpMethod.Get ? timeout : longTimeout); In the preceding code, if the outgoing request is an HTTP GET, a 10-second timeout is applied. For any other HTTP method, a 30-second timeout is used. It's common to nest Polly policies to provide enhanced functionality: In the preceding example, two handlers are added. The first uses the extension to add a retry policy. Failed requests are retried up to three times. The second call to adds a circuit breaker policy. Further external requests are blocked for 30 seconds if five failed attempts occur sequentially. Circuit breaker policies are stateful. All calls through this client share the same circuit state. An approach to managing regularly used policies is to define them once and register them with a . An extension method is provided which allows a handler to be added using a policy from the registry: In the preceding code, two policies are registered when the is added to the . To use a policy from the registry, the method is used, passing the name of the policy to apply. Further information about and Polly integrations can be found on the Polly wiki. A new instance is returned each time is called on the . There's an HttpMessageHandler per named client. The factory manages the lifetimes of the instances. pools the instances created by the factory to reduce resource consumption. An instance may be reused from the pool when creating a new instance if its lifetime hasn't expired. Pooling of handlers is desirable as each handler typically manages its own underlying HTTP connections. Creating more handlers than necessary can result in connection delays. Some handlers also keep connections open indefinitely, which can prevent the handler from reacting to DNS changes. The default handler lifetime is two minutes. The default value can be overridden on a per named client basis. To override it, call SetHandlerLifetime on the that is returned when creating the client: Disposal of the client isn't required. Disposal cancels outgoing requests and guarantees the given instance can't be used after calling Dispose. tracks and disposes resources used by instances. The instances can generally be treated as .NET objects not requiring disposal. Keeping a single instance alive for a long duration is a common pattern used before the inception of . This pattern becomes unnecessary after migrating to . There are alternative ways to solve the preceding problems using a long-lived SocketsHttpHandler instance.\n‚Ä¢ Create an instance of when the app starts and use it for the life of the app.\n‚Ä¢ Configure PooledConnectionLifetime to an appropriate value based on DNS refresh times. The preceding approaches solve the resource management problems that solves in a similar way.\n‚Ä¢ The shares connections across instances. This sharing prevents socket exhaustion.\n‚Ä¢ The cycles connections according to to avoid stale DNS problems. The pooled instances results in objects being shared. Unanticipated object sharing often results in incorrect code. For apps that require cookies, consider either: Clients created via record log messages for all requests. Enable the appropriate information level in your logging configuration to see the default log messages. Additional logging, such as the logging of request headers, is only included at trace level. The log category used for each client includes the name of the client. A client named MyNamedClient, for example, logs messages with a category of . Messages suffixed with LogicalHandler occur outside the request handler pipeline. On the request, messages are logged before any other handlers in the pipeline have processed it. On the response, messages are logged after any other pipeline handlers have received the response. Logging also occurs inside the request handler pipeline. In the MyNamedClient example, those messages are logged against the log category . For the request, this occurs after all other handlers have run and immediately before the request is sent out on the network. On the response, this logging includes the state of the response before it passes back through the handler pipeline. Enabling logging outside and inside the pipeline enables inspection of the changes made by the other pipeline handlers. This may include changes to request headers, for example, or to the response status code. Including the name of the client in the log category enables log filtering for specific named clients where necessary. It may be necessary to control the configuration of the inner used by a client. An is returned when adding named or typed clients. The ConfigurePrimaryHttpMessageHandler extension method can be used to define a delegate. The delegate is used to create and configure the primary used by that client: In a console app, add the following package references to the project: In the following example:\n‚Ä¢ IHttpClientFactory is registered in the Generic Host's service container.\n‚Ä¢ creates a client factory instance from the service, which is used to create an . is used to retrieve a webpage.\n‚Ä¢ The service's method is executed to write the first 500 characters of the webpage content to the console. For more information on calling services from , see Dependency injection in ASP.NET Core. using System; using System.Net.Http; using System.Threading.Tasks; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; using Microsoft.Extensions.Logging; class Program { static async Task<int> Main(string[] args) { var builder = new HostBuilder() .ConfigureServices((hostContext, services) => { services.AddHttpClient(); services.AddTransient<IMyService, MyService>(); }).UseConsoleLifetime(); var host = builder.Build(); try { var myService = host.Services.GetRequiredService<IMyService>(); var pageContent = await myService.GetPage(); Console.WriteLine(pageContent.Substring(0, 500)); } catch (Exception ex) { var logger = host.Services.GetRequiredService<ILogger<Program>>(); logger.LogError(ex, \"An error occurred.\"); } return 0; } public interface IMyService { Task<string> GetPage(); } public class MyService : IMyService { private readonly IHttpClientFactory _clientFactory; public MyService(IHttpClientFactory clientFactory) { _clientFactory = clientFactory; } public async Task<string> GetPage() { // Content from BBC One: Dr. Who website (¬©BBC) var request = new HttpRequestMessage(HttpMethod.Get, \"https://www.bbc.co.uk/programmes/b006q2x0\"); var client = _clientFactory.CreateClient(); var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { return await response.Content.ReadAsStringAsync(); } else { return $\"StatusCode: {response.StatusCode}\"; } } } } Header propagation is a community supported middleware to propagate HTTP headers from the incoming request to the outgoing HTTP Client requests. To use header propagation:\n‚Ä¢ None Reference the community supported port of the package HeaderPropagation. ASP.NET Core 3.1 and later supports Microsoft.AspNetCore.HeaderPropagation.\n‚Ä¢ None Configure the middleware and in :\n‚Ä¢ None The client includes the configured headers on outbound requests:\n‚Ä¢ Implement HTTP call retries with exponential backoff with HttpClientFactory and Polly policies"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests",
        "document": "IHttpClientFactory is a contract implemented by , an opinionated factory, available since .NET Core 2.1, for creating HttpClient instances to be used in your applications.\n\nIssues with the original HttpClient class available in .NET\n\nThe original and well-known HttpClient class can be easily used, but in some cases, it isn't being properly used by many developers.\n\nThough this class implements , declaring and instantiating it within a statement is not preferred because when the object gets disposed of, the underlying socket is not immediately released, which can lead to a socket exhaustion problem. For more information about this issue, see the blog post You're using HttpClient wrong and it's destabilizing your software.\n\nTherefore, is intended to be instantiated once and reused throughout the life of an application. Instantiating an class for every request will exhaust the number of sockets available under heavy loads. That issue will result in errors. Possible approaches to solve that problem are based on the creation of the object as singleton or static, as explained in this Microsoft article on HttpClient usage. This can be a good solution for short-lived console apps or similar, that run a few times a day.\n\nAnother issue that developers run into is when using a shared instance of in long-running processes. In a situation where the HttpClient is instantiated as a singleton or a static object, it fails to handle the DNS changes as described in this issue of the dotnet/runtime GitHub repository.\n\nHowever, the issue isn't really with per se, but with the default constructor for HttpClient, because it creates a new concrete instance of HttpMessageHandler, which is the one that has sockets exhaustion and DNS changes issues mentioned above.\n\nTo address the issues mentioned above and to make instances manageable, .NET Core 2.1 introduced two approaches, one of them being IHttpClientFactory. It's an interface that's used to configure and create instances in an app through Dependency Injection (DI). It also provides extensions for Polly-based middleware to take advantage of delegating handlers in HttpClient.\n\nThe alternative is to use with configured . This approach is applied to long-lived, or singleton instances. To learn more about different strategies, see HttpClient guidelines for .NET.\n\nPolly is a transient-fault-handling library that helps developers add resiliency to their applications, by using some pre-defined policies in a fluent and thread-safe manner.\n\nThe current implementation of IHttpClientFactory, that also implements IHttpMessageHandlerFactory, offers the following benefits:\n‚Ä¢ Provides a central location for naming and configuring logical objects. For example, you may configure a client (Service Agent) that's pre-configured to access a specific microservice.\n‚Ä¢ Codify the concept of outgoing middleware via delegating handlers in and implementing Polly-based middleware to take advantage of Polly's policies for resiliency.\n‚Ä¢ already has the concept of delegating handlers that could be linked together for outgoing HTTP requests. You can register HTTP clients into the factory and you can use a Polly handler to use Polly policies for Retry, CircuitBreakers, and so on.\n‚Ä¢ Manage the lifetime of HttpMessageHandler to avoid the mentioned problems/issues that can occur when managing lifetimes yourself.\n\nThere are several ways that you can use in your application:\n\nFor the sake of brevity, this guidance shows the most structured way to use , which is to use Typed Clients (Service Agent pattern). However, all options are documented and are currently listed in this article covering the usage.\n\nHow to use Typed Clients with IHttpClientFactory\n\nSo, what's a \"Typed Client\"? It's just an that's pre-configured for some specific use. This configuration can include specific values such as the base server, HTTP headers or time outs.\n\nThe following diagram shows how Typed Clients are used with :\n\nIn the above image, a (used by a controller or client code) uses an created by the registered . This factory assigns an from a pool to the . The can be configured with Polly's policies when registering the in the DI container with the extension method AddHttpClient.\n\nTo configure the above structure, add IHttpClientFactory in your application by installing the NuGet package that includes the AddHttpClient extension method for IServiceCollection. This extension method registers the internal class to be used as a singleton for the interface . It defines a transient configuration for the HttpMessageHandlerBuilder. This message handler (HttpMessageHandler object), taken from a pool, is used by the returned from the factory.\n\nIn the next snippet, you can see how can be used to register Typed Clients (Service Agents) that need to use .\n\nRegistering the client services as shown in the previous snippet, makes the create a standard for each service. The typed client is registered as transient with DI container. In the preceding code, registers CatalogService, BasketService, OrderingService as transient services so they can be injected and consumed directly without any need for additional registrations.\n\nYou could also add instance-specific configuration in the registration to, for example, configure the base address, and add some resiliency policies, as shown in the following:\n\nIn this next example, you can see the configuration of one of the above policies:\n\nYou can find more details about using Polly in the Next article.\n\nEach time you get an object from the , a new instance is returned. But each uses an that's pooled and reused by the to reduce resource consumption, as long as the 's lifetime hasn't expired.\n\nPooling of handlers is desirable as each handler typically manages its own underlying HTTP connections; creating more handlers than necessary can result in connection delays. Some handlers also keep connections open indefinitely, which can prevent the handler from reacting to DNS changes.\n\nThe objects in the pool have a lifetime that's the length of time that an instance in the pool can be reused. The default value is two minutes, but it can be overridden per Typed Client. To override it, call on the IHttpClientBuilder that's returned when creating the client, as shown in the following code:\n\nEach Typed Client can have its own configured handler lifetime value. Set the lifetime to to disable handler expiry.\n\nImplement your Typed Client classes that use the injected and configured HttpClient\n\nAs a previous step, you need to have your Typed Client classes defined, such as the classes in the sample code, like 'BasketService', 'CatalogService', 'OrderingService', etc. ‚Äì A Typed Client is a class that accepts an object (injected through its constructor) and uses it to call some remote HTTP service. For example:\n\nThe Typed Client ( in the example) is activated by DI (Dependency Injection), which means it can accept any registered service in its constructor, in addition to .\n\nA Typed Client is effectively a transient object, that means a new instance is created each time one is needed. It receives a new instance each time it's constructed. However, the objects in the pool are the objects that are reused by multiple instances.\n\nFinally, once you have your typed classes implemented, you can have them registered and configured with . After that you can use them wherever services are injected by DI, such as in Razor page code or an MVC web app controller, shown in the below code from eShopOnContainers:\n\nUp to this point, the above code snippet only shows the example of performing regular HTTP requests. But the 'magic' comes in the following sections where it shows how all the HTTP requests made by can have resilient policies such as retries with exponential backoff, circuit breakers, security features using auth tokens, or even any other custom feature. And all of these can be done just by adding policies and delegating handlers to your registered Typed Clients."
    },
    {
        "link": "https://medium.com/@imstevenphan/leveraging-ihttpclientfactory-in-asp-net-e1970b9719f5",
        "document": "If you found this article helpful or enjoyed reading it, consider supporting my work by buying me a coffee! Your support allows me to continue creating valuable content like this :\n\nIn the modern landscape of web development, applications are often required to interact with various external services, APIs, and resources over the internet. Whether it‚Äôs fetching data from a remote server, sending requests to third-party APIs, or communicating with microservices within your own architecture, the need for making HTTP requests is ubiquitous. However, handling HTTP requests efficiently and effectively is crucial for the overall performance, scalability, and maintainability of your application.\n\nThe HttpClient class has been a staple in .NET for making HTTP requests, but as applications grow in complexity, so do the challenges associated with its usage. This is where HttpClientFactory comes into play, offering a sophisticated solution to address these challenges while providing a streamlined approach to managing HTTP clients. In this article, we will delve deep into the reasons why we need to use HttpClientFactory in ASP.NET Core, exploring its benefits and best practices.\n\nBefore we explore the merits of HttpClientFactory , let's take a moment to understand the challenges that can arise when using HttpClient directly.\n‚Ä¢ Resource Exhaustion: When HttpClient instances are created and disposed of individually, it can lead to resource exhaustion due to socket exhaustion. This is particularly problematic when dealing with a large number of requests in a short period of time.\n‚Ä¢ Connection Reuse and DNS Caching: Reusing connections across multiple requests is crucial for performance. With direct HttpClient usage, managing connection reuse and DNS caching becomes complex and error-prone.\n‚Ä¢ Timeouts and Circuit Breaking: Applying consistent timeout values and implementing circuit-breaking patterns for fault tolerance require manual intervention, making the codebase harder to maintain.\n‚Ä¢ Logging and Instrumentation: Incorporating proper logging and instrumentation for monitoring request and response details can become cumbersome when dealing with multiple HttpClient instances.\n\nHttpClientFactory is a feature introduced in ASP.NET Core to address the challenges associated with direct HttpClient usage. It serves as a centralized mechanism for creating and managing instances of HttpClient, promoting best practices and enhancing performance and maintainability.\n‚Ä¢ Resource Management: One of the core benefits of HttpClientFactory is its efficient management of HttpClient instances. By using a pool of reusable HttpClient instances, it mitigates the issues of resource exhaustion and socket leaks that can occur with direct instantiation.\n‚Ä¢ Connection Pooling: HttpClientFactory manages connection pooling automatically, reusing connections across multiple requests. This leads to reduced overhead and improved performance, especially in scenarios where a high volume of requests is anticipated.\n‚Ä¢ Lifetime Management: With HttpClientFactory, you can define the lifetime of HttpClient instances. Scoped lifetime, for example, ensures that an instance is reused within a single HTTP request, while singleton lifetime allows sharing an instance across the entire application. This flexibility ensures optimal memory usage and connection reuse.\n‚Ä¢ Configuration and Policies: HttpClientFactory provides a convenient way to configure and apply policies to HttpClient instances. This includes setting timeout values, defining retry behaviors, and implementing circuit-breaking patterns. This abstraction simplifies the codebase and centralizes the configuration logic.\n‚Ä¢ Logging and Instrumentation: Incorporating logging and instrumentation becomes seamless with HttpClientFactory. You can apply message logging and capture detailed request and response information without cluttering your business logic.\n‚Ä¢ Testing and Mocking: HttpClientFactory enhances testability by allowing you to inject mock or custom implementations of HttpClient . This makes unit testing more straightforward and decouples your code from the actual HTTP requests during testing.\n\nHere‚Äôs a sample code that demonstrates how to use HttpClientFactory in an ASP.NET Core application. This example will show you how to create a service that makes HTTP requests using HttpClientFactory.\n\nLet‚Äôs assume you have an ASP.NET Core application set up and you want to create a service that interacts with an external API.\n\n4. Use the Service in a Controller:\n\nIn this example, we‚Äôve utilized IHttpClientFactoryto create an HttpClient instance within the MyApiService class. By doing this, we ensure that the instance is managed efficiently, benefiting from connection pooling and proper resource management. This pattern of using IHttpClientFactory to is scalable, maintainable, and aligns with best practices for working with HTTP requests in ASP.NET Core."
    },
    {
        "link": "https://stackoverflow.com/questions/70571787/asp-net-core-services-addhttpclient-ihttpclientfactory-vs-httpclient-injection",
        "document": "I'm trying to understand something I've seen in some production code and when investigating it I found this page: https://learn.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests\n\nThe code I've seen is an ASP.NET Core Web App. It uses the AddHttpClient() extension:\n\nAccording to the documentation this injects an IHttpClientFactory into the controllers. But the production code declares the constructors like so:\n\nI did some testing and this works too (with necessary adjustments of course):\n\nAccording to the documentation an HttpClient is injected into typed clients. But doesn't that require me to specify the type by using\n\nI don't do that so is the type infered some way?\n\nThe IServiceCollection must do some magic based on what I choose to declare in the constructor. I cannot find any examples that use the combination of\n\nCan I find that documented somewhere?"
    },
    {
        "link": "https://infoworld.com/article/2260813/how-to-use-ihttpclientfactory-in-aspnet-core.html",
        "document": "When working in applications in ASP.NET Core you might often need to invoke the Web API action methods using HttpClient to check if the endpoints are working fine. To achieve this, you would typically instantiate HttpClient and use the instance to invoke your action methods. However, there are certain downsides to using HttpClient directly, mainly having to do with managing the lifetimes of the instances manually.\n\nYou can avoid these downsides by using IHttpClientFactory to create your HttpClient instances. Introduced in .NET Core 2.1, IHttpClientFactory provides a central place to name, configure, and create HttpClient instances and manages the pooling and lifetimes of the instances automatically.\n\nI‚Äôve discussed HttpClient and HttpClientFactory in an earlier article here. This article further discusses HttpClient and IHttpClientFactory with code examples to illustrate the concepts covered. To work with the code examples provided, you should have Visual Studio 2019 installed in your system. If you don‚Äôt already have a copy, you can download Visual Studio 2019 here.\n\nFirst off, let‚Äôs create an ASP.NET Core project in Visual Studio 2019. Assuming Visual Studio 2019 is installed in your system, follow the steps outlined below to create a new ASP.NET Core project in Visual Studio.\n‚Ä¢ In the ‚ÄúCreate new project‚Äù window, select ‚ÄúASP.NET Core Web Application‚Äù from the list of templates displayed.\n‚Ä¢ In the ‚ÄúConfigure your new project‚Äù window, specify the name and location for the new project.\n‚Ä¢ Optionally check the ‚ÄúPlace solution and project in the same directory‚Äù check box, depending on your preferences.\n‚Ä¢ In the ‚ÄúCreate a New ASP.NET Core Web Application‚Äù window shown next, select .NET Core as the runtime and ASP.NET Core 3.1 (or later) from the drop-down list at the top.\n‚Ä¢ Select ‚ÄúWeb Application (Model-View-Controller)‚Äù as the project template to create a new ASP.NET Core MVC application.\n‚Ä¢ Ensure that the check boxes ‚ÄúEnable Docker Support‚Äù and ‚ÄúConfigure for HTTPS‚Äù are unchecked as we won‚Äôt be using those features here.\n‚Ä¢ Ensure that Authentication is set to ‚ÄúNo Authentication‚Äù as we won‚Äôt be using authentication either.\n\nFollowing these steps should create a new ASP.NET Core MVC project in Visual Studio 2019. In the new project, create a new API controller and save it using the default name, i.e., ValuesController. We‚Äôll use this project in the sections that follow.\n\nAlthough the HttpClient class doesn‚Äôt implement the IDisposable interface directly, it extends the System.Net.Http.HttpMessageInvoker class, which does implement IDisposable. Nevertheless, when working with HttpClient instances, you shouldn‚Äôt be disposing of them. Although you can call the Dispose method on an HttpClient instance, it is not a recommended practice.\n\nWhat should you do instead? One option is to make the HttpClient instance static or wrap a non-static instance of the HttpClient inside a custom class and make it a singleton class. But a better alternative is to use IHttpClientFactory to retrieve an instance of HttpClient and then use the instance for calling action methods.\n\nIHttpClientFactory is an interface that is implemented by the DefaultHttpClientFactory class, which is an opinionated factory. The DefaultHttpClientFactory implements the IHttpClientFactory and IHttpMessageHandlerFactory interfaces. IHttpClientFactory was introduced to provide ASP.NET Core with excellent built-in support for creating, caching, and disposing of HttpClient instances.\n\nNote that HttpClientFactory (discussed in my earlier article) is just a helper to create HttpClient instances configured with the handlers provided. This class has the following methods:\n\nThe overloaded Create methods of the HttpClientFactory class look like this:\n\nBoth HttpClientFactory and IHttpClientFactory were introduced to better manage the lifetime of HttpMessageHandler instances.\n\nWhen you dispose of a HttpClient instance, the connection remains open for up to four minutes. Further, the number of sockets that you can open at any point in time has a limit ‚Äî you can‚Äôt have too many sockets open at once. So when you use too many HttpClient instances, you might end up exhausting your supply of sockets.\n\nHere‚Äôs where IHttpClientFactory comes to the rescue. You can take advantage of IHttpClientFactory to create HttpClient instances for invoking HTTP API methods by adhering to the best practices to avoid issues faced with HttpClient. The primary goal of IHttpClientFactory in ASP.NET Core is to ensure that HttpClient instances are created using the factory while at the same time eliminating socket exhaustion.\n\nYou can register an instance of type IHttpClientFactory in the ConfigureServices method of the Startup class by calling the AddHttpClient extension method on the IServiceCollection instance as shown in the code snippet given below.\n\nInject an IHttpClientFactory instance to your controllers in ASP.NET Core\n\nYou can then inject an IHttpClientFactory instance to your controllers as shown in the code snippet given below.\n\nCall your action methods using HttpClient in ASP.NET Core\n\nTo create an HttpClient using IHttpClientFactory, you should call the CreateClient method. Once the HttpClient instance is available, you can use the following code in the Index action method of the HomeController class to invoke the Get method of the ValuesController class.\n\nUse IHttpClientFactory to create and manage HttpClient instances in ASP.NET Core\n\nThere are several ways you can use IHttpClientFactory in your application. These include using IHttpClientFactory directly, using named clients, and using typed clients.\n\nThe basic or general usage pattern‚Äîi.e., using IHttpClientFactory directly‚Äîhas already been discussed in the preceding sections. Refer to the section ‚ÄúRegister an IHttpClientFactory instance‚Äù that discusses how you can register an HttpClient instance.\n\nIf you would like to use HttpClient instances with different configurations, named clients is a good choice. The following code snippet illustrates how you can create a named client.\n\nA typed client is defined using a custom class that wraps an HttpClient instance, encapsulating the logic for calls to all of the endpoints over the HTTP protocol. The following code snippet illustrates how a custom HttpClient class can be defined.\n\nThe following code snippet shows how you can register your custom typed HttpClient.\n\nAdd MessageHandlers to the pipeline in ASP.NET Core\n\nA Message handler is a class that extends the HttpMessageHandler class, accepts an HTTP request, and returns an HTTP response. If you would like to build your own message handler, you should create a class that extends the DelegatingHandler class.\n\nYou can add HttpMessageHandlers to the request processing pipeline. If you‚Äôre using a named client, you can use the following code in the ConfigureServices method of the Startup class to add message handlers to the pipeline.\n\nIHttpClientFactory is an opinionated factory that has been available since .NET Core 2.1. If you use IHttpClientFactory to create your HttpClient instances, then the pooling and lifetime of the underlying HttpClientMessagehandler instances are managed for you automatically. IHttpClientFactory also takes care of common concerns such as logging.\n\nHow to do more in ASP.NET Core:\n‚Ä¢ How to use the ProblemDetails middleware in ASP.NET Core\n‚Ä¢ How to create route constraints in ASP.NET Core\n‚Ä¢ How to manage user secrets in ASP.NET Core\n‚Ä¢ How to build gRPC applications in ASP.NET Core\n‚Ä¢ How to redirect a request in ASP.NET Core\n‚Ä¢ How to use attribute routing in ASP.NET Core\n‚Ä¢ How to pass parameters to action methods in ASP.NET Core MVC\n‚Ä¢ How to use API Analyzers in ASP.NET Core\n‚Ä¢ How to use route data tokens in ASP.NET Core\n‚Ä¢ How to use API versioning in ASP.NET Core\n‚Ä¢ How to use Data Transfer Objects in ASP.NET Core 3.1\n‚Ä¢ How to handle 404 errors in ASP.NET Core MVC\n‚Ä¢ How to use dependency injection in action filters in ASP.NET Core 3.1\n‚Ä¢ How to use the options pattern in ASP.NET Core\n‚Ä¢ How to use endpoint routing in ASP.NET Core 3.0 MVC\n‚Ä¢ How to export data to Excel in ASP.NET Core 3.0\n‚Ä¢ How to use LoggerMessage in ASP.NET Core 3.0\n‚Ä¢ How to send emails in ASP.NET Core\n‚Ä¢ How to log data to SQL Server in ASP.NET Core\n‚Ä¢ How to schedule jobs using Quartz.NET in ASP.NET Core\n‚Ä¢ How to return data from ASP.NET Core Web API\n‚Ä¢ How to format response data in ASP.NET Core\n‚Ä¢ How to consume an ASP.NET Core Web API using RestSharp\n‚Ä¢ How to perform async operations using Dapper\n‚Ä¢ How to use feature flags in ASP.NET Core\n‚Ä¢ How to use the FromServices attribute in ASP.NET Core\n‚Ä¢ How to work with cookies in ASP.NET Core\n‚Ä¢ How to work with static files in ASP.NET Core\n‚Ä¢ How to use URL Rewriting Middleware in ASP.NET Core\n‚Ä¢ How to implement rate limiting in ASP.NET Core\n‚Ä¢ How to use Azure Application Insights in ASP.NET Core\n‚Ä¢ How to handle errors in ASP.NET Web API\n‚Ä¢ How to implement global exception handling in ASP.NET Core MVC\n‚Ä¢ How to handle null values in ASP.NET Core MVC\n‚Ä¢ How to work with worker services in ASP.NET Core\n‚Ä¢ How to use the Data Protection API in ASP.NET Core\n‚Ä¢ How to use conditional middleware in ASP.NET Core\n‚Ä¢ How to work with session state in ASP.NET Core\n‚Ä¢ How to write efficient controllers in ASP.NET Core"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/deserialization",
        "document": "How to read JSON as .NET objects (deserialize)\n\nThis article shows how to use the System.Text.Json namespace to deserialize from JavaScript Object Notation (JSON). If you're porting existing code from , see How to migrate to .\n\nA common way to deserialize JSON is to have (or create) a .NET class with properties and fields that represent one or more of the JSON properties. Then, to deserialize from a string or a file, call the JsonSerializer.Deserialize method. For the generic overloads, the generic type parameter is the .NET class. For the non-generic overloads, you pass the type of the class as a method parameter. You can deserialize either synchronously or asynchronously.\n\nAny JSON properties that aren't represented in your class are ignored by default. Also, if any properties on the type are required but not present in the JSON payload, deserialization will fail.\n\nThe following example shows how to deserialize a JSON string:\n\nTo deserialize from a file by using synchronous code, read the file into a string, as shown in the following example:\n\nTo deserialize from a file by using asynchronous code, call the DeserializeAsync method:\n\nThe following behaviors apply when deserializing JSON:\n‚Ä¢ By default, property name matching is case-sensitive. You can specify case-insensitivity.\n‚Ä¢ Non-public constructors are ignored by the serializer.\n‚Ä¢ Deserialization to immutable objects or properties that don't have public accessors is supported but not enabled by default. See Immutable types and records.\n‚Ä¢ By default, enums are supported as numbers. You can deserialize string enum fields.\n‚Ä¢ By default, fields are ignored. You can include fields.\n‚Ä¢ By default, comments or trailing commas in the JSON throw exceptions. You can allow comments and trailing commas.\n\nWhen you use System.Text.Json indirectly in an ASP.NET Core app, some default behaviors are different. For more information, see Web defaults for JsonSerializerOptions.\n\nYou can implement custom converters to provide functionality that isn't supported by the built-in converters.\n\nIf you have JSON that you want to deserialize, and you don't have the class to deserialize it into, you have options other than manually creating the class that you need:\n‚Ä¢ None Deserialize into a JSON DOM (document object model) and extract what you need from the DOM. The DOM lets you navigate to a subsection of a JSON payload and deserialize a single value, a custom type, or an array. For information about the JsonNode DOM, see Deserialize subsections of a JSON payload. For information about the JsonDocument DOM, see How to search a JsonDocument and JsonElement for sub-elements.\n‚Ä¢ None Use Visual Studio 2022 to automatically generate the class you need:\n‚Ä¢ Copy the JSON that you need to deserialize. The result is a class that you can use for your deserialization target.\n\nTo deserialize from UTF-8, call a JsonSerializer.Deserialize overload that takes a or a , as shown in the following examples. The examples assume the JSON is in a byte array named jsonUtf8Bytes.\n\nYou can use GitHub Copilot in your IDE to generate code that uses to deserialize from JSON. You can customize the prompt to use a JSON string with property names and values that suit your requirements.\n\nThe following text shows an example prompt for Copilot Chat:\n\nGitHub Copilot is powered by AI, so surprises and mistakes are possible. For more information, see Copilot FAQs.\n\nLearn more about GitHub Copilot in Visual Studio and GitHub Copilot in VS Code."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/how-to",
        "document": "How to write .NET objects as JSON (serialize)\n\nThis article shows how to use the System.Text.Json namespace to serialize to JavaScript Object Notation (JSON). If you're porting existing code from , see How to migrate to .\n\nTo write JSON to a string or to a file, call the JsonSerializer.Serialize method.\n\nThe following example creates JSON as a string:\n\nThe JSON output is minified (whitespace, indentation, and new-line characters are removed) by default.\n\nThe following example uses synchronous code to create a JSON file:\n\nThe following example uses asynchronous code to create a JSON file:\n\nThe preceding examples use type inference for the type being serialized. An overload of takes a generic type parameter:\n\nYou can also use GitHub Copilot to generate serialization code for you. For instructions, see the Use GitHub Copilot section in this article.\n‚Ä¢ By default, all public properties are serialized. You can specify properties to ignore. You can also include private members.\n‚Ä¢ The default encoder escapes non-ASCII characters, HTML-sensitive characters within the ASCII-range, and characters that must be escaped according to the RFC 8259 JSON spec.\n‚Ä¢ By default, JSON is minified. You can pretty-print the JSON.\n‚Ä¢ By default, casing of JSON names matches the .NET names. You can customize JSON name casing.\n‚Ä¢ By default, circular references are detected and exceptions thrown. You can preserve references and handle circular references.\n‚Ä¢ By default, fields are ignored. You can include fields.\n\nWhen you use System.Text.Json indirectly in an ASP.NET Core app, some default behaviors are different. For more information, see Web defaults for JsonSerializerOptions.\n‚Ä¢ None .NET primitives that map to JavaScript primitives, such as numeric types, strings, and Boolean.\n‚Ä¢ None Collections and dictionaries from the following namespaces: For more information, see Supported types in System.Text.Json.\n\nYou can implement custom converters to handle additional types or to provide functionality that isn't supported by the built-in converters.\n\nHere's an example showing how a class that contains collection properties and a user-defined type is serialized:\n\nIt's 5-10% faster to serialize to a UTF-8 byte array than to use the string-based methods. That's because the bytes (as UTF-8) don't need to be converted to strings (UTF-16).\n\nTo serialize to a UTF-8 byte array, call the JsonSerializer.SerializeToUtf8Bytes method:\n\nA Serialize overload that takes a Utf8JsonWriter is also available.\n\nTo pretty-print the JSON output, set JsonSerializerOptions.WriteIndented to :\n\nStarting in .NET 9, you can also customize the indent character and size using IndentCharacter and IndentSize.\n\nUse GitHub Copilot to serialize to JSON\n\nYou can use GitHub Copilot in your IDE to generate code that uses to serialize to JSON. You can customize the prompt to use object fields that suit your requirements.\n\nThe following text shows an example prompt for Copilot Chat:\n\nGitHub Copilot is powered by AI, so surprises and mistakes are possible. For more information, see Copilot FAQs.\n\nLearn more about GitHub Copilot in Visual Studio and GitHub Copilot in VS Code."
    },
    {
        "link": "https://stackoverflow.com/questions/69058507/how-to-deserialize-asynchronously-using-system-text-json-library",
        "document": "I have a json that I am deserializing by using NewtonSoftJson Json library as shown below:\n\nNow I am trying to use library to deserialize asynchronously so I read their docs and they do have method which I can use but when I replace content of above method like below then I get compilation error -\n\nI am new to dotnet world so kinda confuse what is wrong I am doing here?"
    },
    {
        "link": "https://stackoverflow.com/questions/58572524/asynchonously-deserializing-a-list-using-system-text-json",
        "document": "Looks like someone already posted full code for a struct that reads buffers from a stream and feeds them to a Utf8JsonRreader, allowing easy deserialization with . The code isn't trivial either. The related question is here and the answer is here.\n\nThat's not enough though - will return only after the entire response is received, essentially buffering everything in memory.\n\nTo avoid this, HttpClient.GetAsync(string,HttpCompletionOption ) should be used with .\n\nThe deserialization loop should check the cancellation token too, and either exit or throw if it's signalled. Otherwise the loop will go on until the entire stream is received and processed.\n\nThis code is based in the related answer's example and uses and checks the cancellation token. It can parse JSON strings that contain a proper array of items, eg :\n\nThe first call to moves to the start of the array while the second moves to the start of the first object. The loop itself terminates when the end of the array ( ) is detected.\n\nIt's quite common in event streaming or logging scenarios to append individual JSON objects to a file, one element per line eg :\n\nThis isn't a valid JSON document but the individual fragments are valid. This has several advantages for big data/highly concurrent scenarios. Adding a new event only requires appending a new line to the file, not parsing and rebuilding the entire file. Processing, especially parallel processing is easier for two reasons:\n‚Ä¢ Individual elements can be retrieved one at a time, simply by reading one line from a stream.\n‚Ä¢ The input file can be easily partitioned and split across line boundaries, feeding each part to a separate worker process, eg in a Hadoop cluster, or simply different threads in an application: Calculate the split points eg by dividing the length by the number of workers, then look for the first newline. Feed everything up to that point to a separate worker.\n\nThe allocate-y way to do this would be to use a TextReader, read one line at a time and parse it with JsonSerializer.Deserialize :\n\nThat's a lot simpler than the code that deserializes a proper array. There are two issues :\n‚Ä¢ Each iteration allocates a new string, one of the things we wanted to avoid by using System.Text.Json\n\nThis may be enough though as trying to produce the buffers needed by JsonSerializer.Deserialize isn't trivial.\n\nTo avoid alllocations, we need to get a from the stream. Doing this requires using System.IO.Pipeline pipes and the SequenceReader struct. Steve Gordon's An Introduction to SequenceReader explains how this class can be used to read data from a stream using delimiters.\n\nUnfortunately, is a ref struct which means it can't be used in async or local methods. That's why Steve Gordon in his article creates a\n\nmethod to read items form a ReadOnlySequence and return the ending position, so the PipeReader can resume from it. Unfortunately we want to return an IEnumerable or IAsyncEnumerable, and iterator methods don't like or parameters either.\n\nWe could collect the deserialized items in a List or Queue and return them as a single result, but that would still allocate lists, buffers or nodes and have to wait for all items in a buffer to be deserialized before returning :\n\nWe need something that acts like an enumerable without requiring an iterator method, works with async and doesn't buffer everything the way.\n\nChannelReader.ReadAllAsync returns an IAsyncEnumerable. We can return a ChannelReader from methods that couldn't work as iterators and still produce a stream of elements without caching.\n\nAdapting Steve Gordon's code to use channels, we get the ReadItems(ChannelWriter...) and methods. The first one, reads one item at a time, up to a newline using . This can be used by . If can't find the delimiter, it returns its position so the PipelineReader can pull the next chunk from the stream.\n\nWhen we reach the last chunk and there's no other delimiter, ReadLastItem` reads the remaining bytes and deserializes them.\n\nThe code is almost identical to Steve Gordon's. Instead of writing to the Console, we write to the ChannelWriter.\n\nThe method creates a Pipeline reader on top of the stream, creates a channel and starts a worker task that parses chunks and pushes them to the channel :\n\ncan be used to consume all items through an :"
    },
    {
        "link": "https://madhawapolkotuwa.medium.com/mastering-json-serialization-in-c-with-system-text-json-01f4cec0440d",
        "document": "Import the necessary namespaces. This includes for JSON processing and for handling advanced options like converters and reference handling.\" Define a simple class, which includes properties like , , , , and . This class represents the objects that will be serialized into JSON. public class Product\n\n{\n\n public int ID {get; set;}\n\n public string ProductName {get; set;}\n\n public string Category {get; set;}\n\n public decimal Price {get; set;}\n\n public DateTime PurchasedDate {get; set;}\n\n} Now, Let‚Äôs create a list of objects with some sample data. This data will demonstrate how JSON serialization handles different data types, including strings, numbers, and dates. One of the products has a value for the , which will help us showcase how deals with null values. List<Product> products = new List<Product>\n\n{\n\n new Product { ID = 2, ProductName = \"Harry Potter\", Category = \"Books\", Price = 24.99m, PurchasedDate = new DateTime(2024,09,24,10,20,30) },\n\n new Product { ID = 3, ProductName = \"Console\", Category = \"Electronics\", Price = 199.99m, PurchasedDate = new DateTime(2024,09,25,12,22,45) },\n\n new Product { ID = 4, ProductName = \"Pen\", Category = null, Price = 10.0m, PurchasedDate = new DateTime(2024,09,25,06,10,15) }, // Category is null\n\n new Product { ID = 5, ProductName = \"TShirt\", Category = \"Clothing\", Price = 49.99m, PurchasedDate = new DateTime(2024,09,27,08,12,20) },\n\n new Product { ID = 1, ProductName = \"Laptop\", Category = \"Electronics\", Price = 299.99m, PurchasedDate = DateTime.Now }\n\n};\n\nLet‚Äôs start by serializing the list of products using the default settings. This will convert the object graph into a JSON string, automatically handling types like strings, decimals, and dates [\n\n {\n\n \"ID\": 2,\n\n \"PrductName\": \"Harry Potter\",\n\n \"Category\": \"Books\",\n\n \"Price\": 24.99,\n\n \"PurchasedDate\": \"2024-09-24T10:20:30\"\n\n },\n\n {\n\n \"ID\": 3,\n\n \"PrductName\": \"Console\",\n\n \"Category\": \"Electronics\",\n\n \"Price\": 199.99,\n\n \"PurchasedDate\": \"2024-09-25T12:22:45\"\n\n },\n\n {\n\n \"ID\": 4,\n\n \"PrductName\": \"Pen\", /* In this case Category is null so it won't appear in the JSON output. */\n\n \"Price\": 10.0,\n\n \"PurchasedDate\": \"2024-09-25T06:10:15\"\n\n },\n\n {\n\n \"ID\": 5,\n\n \"PrductName\": \"TShirt\",\n\n \"Category\": \"Clothing\",\n\n \"Price\": 49.99,\n\n \"PurchasedDate\": \"2024-09-27T08:12:20\"\n\n },\n\n {\n\n \"ID\": 1,\n\n \"PrductName\": \"Laptop\",\n\n \"Category\": \"Electronics\",\n\n \"Price\": 299.99,\n\n \"PurchasedDate\": \"2024-09-27T09:55:51.3731903+09:00\"\n\n }\n\n] Change the property naming policy, such as using CamelCase or keeping original names. You can also implement a custom if you need more control over the transformation of dictionary keys. public class UpperCaseNamingPolicy : JsonNamingPolicy\n\n{\n\n public override string ConvertName(string name)\n\n {\n\n return name.ToUpper(); // Convert keys to uppercase\n\n }\n\n}\n\n\n\noptions = new JsonSerializerOptions\n\n{\n\n WriteIndented = true,\n\n PropertyNamingPolicy = new UpperCaseNamingPolicy()\n\n};\n\njson = JsonSerializer.Serialize(products, options);\n\njson A custom converter class is used to control how specific types are serialized and deserialized. You inherit from , where is the type you want to customize. public class CustomDateTimeConverter : JsonConverter<DateTime>\n\n{\n\n public override DateTime Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n\n {\n\n return DateTime.ParseExact(reader.GetString(), \"yyyy-MM-dd\", null);\n\n }\n\n\n\n public override void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options)\n\n {\n\n writer.WriteStringValue(value.ToString(\"yyyy-MM-dd\"));\n\n }\n\n}\n\n\n\noptions = new JsonSerializerOptions\n\n{\n\n WriteIndented = true,\n\n};\n\noptions.Converters.Add(new CustomDateTimeConverter()); // you can add multiple converters\n\n\n\njson = JsonSerializer.Serialize(products, options);\n\njson In this example the custom converter for that formats dates in format.\n\nHandling case sensitivity in JSON serialization and deserialization is an important aspect when dealing with JSON data where property names might differ in casing. In C#, you can control case sensitivity using the property. By default, is case-sensitive, meaning that property names in the JSON must exactly match the property names in the C# class. public class Person\n\n{\n\n public string FirstName { get; set; }\n\n public string LastName { get; set; }\n\n}\n\n// JSON with property names that don't match C# class case exactly\n\njson = \"{\\\"firstname\\\": \\\"Ron\\\", \\\"lastname\\\": \\\"Weasley\\\"}\";\n\n\n\n// Deserialize without setting case-insensitivity (default behavior is case-sensitive)\n\nvar person = JsonSerializer.Deserialize<Person>(json);\n\nperson Since the property names in the JSON (‚Äúfirstname‚Äù and ‚Äúlastname‚Äù) are all lowercase, and the Person class has properties with FirstName and LastName using PascalCase, deserialization failsto map the JSON properties to the class fields, leaving them as null. You can enable case-insensitive property name matching during deserialization by setting in . This makes the deserialization process ignore case differences between JSON property names and C# property names. In this case, even though the JSON uses lowercase for the property names,deserialization succeeds because case sensitivity has been disabled.\n\nYou can use the option to enable reference handling in JSON serialization. This will handle circular references by using special and properties in the JSON. Consider two classes, and , where each can reference the other, creating a cyclic reference. public class Person\n\n{\n\n public string Name { get; set; }\n\n public Address Address { get; set; }\n\n}\n\n\n\npublic class Address\n\n{\n\n public string City { get; set; }\n\n public Person Resident { get; set; } // Circular reference back to Person\n\n}\n\n\n\nvar person = new Person { Name = \"Ron Weasley\" };\n\nvar address = new Address { City = \"Hogwarts Gryffindor\", Resident = person };\n\nperson.Address = address;\n\n\n\n// Set up JsonSerializerOptions with ReferenceHandler.Preserve\n\noptions = new JsonSerializerOptions\n\n{\n\n ReferenceHandler = ReferenceHandler.Preserve, // Enable reference handling\n\n WriteIndented = true // Format the JSON for readability\n\n};\n\n\n\n// Serialize the object graph with cyclic references\n\njson = JsonSerializer.Serialize(person, options);\n\njson The and properties are used to manage cyclic references. In this case\n‚Ä¢ means the object's property refers back to the same object with , resolving the circular reference. If you want to ignore cyclic references during serialization (i.e., not serialize the properties that would cause a cycle), you can use the option. // Set up JsonSerializerOptions with ReferenceHandler.IgnoreCycles\n\nvar options = new JsonSerializerOptions\n\n{\n\n ReferenceHandler = ReferenceHandler.IgnoreCycles, // Ignore circular references\n\n WriteIndented = true // Format the JSON for readability\n\n};\n\n\n\n // Serialize the object graph ignoring cyclic references\n\njson = JsonSerializer.Serialize(person, options);\n\njson You can also manually prevent cyclic references by using the attribute on properties that would cause a cycle. public class Person\n\n{\n\n public string Name { get; set; }\n\n public Address Address { get; set; }\n\n}\n\n\n\npublic class Address\n\n{\n\n public string City { get; set; }\n\n\n\n [JsonIgnore] // Ignore the cyclic reference during serialization\n\n public Person Resident { get; set; }\n\n}\n\n\n\n\n\nvar person = new Person { Name = \"Ron Weasley\" };\n\nvar address = new Address { City = \"Hogwarts Gryffindor\", Resident = person };\n\nperson.Address = address;\n\n\n\n// Serialize the object graph with the [JsonIgnore] attribute\n\njson = JsonSerializer.Serialize(person, new JsonSerializerOptions { WriteIndented = true });\n\njson\n‚Ä¢ The attribute prevents the property from being serialized, thus avoiding the cyclic reference.\n‚Ä¢ This is a simple way to manually control which properties should be excluded from the serialization process."
    }
]