[
    {
        "link": "https://documentation-service.arm.com/static/64f9cc76bc48b0381ce07a47?token=",
        "document": ""
    },
    {
        "link": "https://developer.arm.com/documentation/107829/latest/Assembly-language-basics",
        "document": ""
    },
    {
        "link": "https://developer.apple.com/documentation/xcode/writing-arm64-code-for-apple-platforms",
        "document": "Please turn on JavaScript in your browser and refresh the page to view its content."
    },
    {
        "link": "https://documentation-service.arm.com/static/64e7245d04d0d65e67136806",
        "document": ""
    },
    {
        "link": "https://mariokartwii.com/armv8",
        "document": "Hello there! My name is Vega. I am a Video Game Cheat Code Developer who loves to write code/programs in various Assembly Languages. This page includes chapters of information that will teach a Beginner about the ARMv8 AArch64/ARM64 Assembly Language. For Beginners who are completely new to Assembly, there seems to be no decent ARMv8 AArch64 Assembly Tutorials on the Web. The tutorials that are present on other sites are tailored for those who are already familiar with an older version of ARM. Granted, ARMv8 AArch64 is not the ideal Assembly Language to learn as someone's first. However, if a true Beginner can learn ARMv8 AArch64, then all other Assembly Languages will be easy work.\n\nFollow all the Chapters in consecutive order. However, there is a Glossary Page linked near the bottom of this page. Feel free to reference that page any time you need to do so. You *must* have a Linux Machine and understand how to run basic Terminal commands (sorry I don't use Windows or Mac). To the Windows and MAC users, the three programs that get installed in this Tutorial are GNU AArch64 Assembler, QEMU, and GNU Debugger. Google results may provide the guides you need to get those installed and running.\n\nI was originally going to make a Nintendo Switch Cheat Code tutorial which would include some sections covering ARMv8 AArch64 for those already familiar with Assembly Languages. However, I decided to make a full-on ARMv8 AArch64 \"Beginner to Advanced\" Assembly Language Tutorial. Do **not** skim or skip any content. English is not my best language (lol), so if you find any grammatical errors or any incorrect information, please contact me. Discord - vega8365.\n\nChapter 1: Intro, What is an Assembly Language?\n\n Chapter 2: Basic Vocabulary, Data/Number Types\n\n Chapter 3: Navigating through Memory\n\n Chapter 4: Basic Registers\n\n Chapter 5: Assembler Installation & Overview\n\n Chapter 6: Instruction Format\n\n Chapter 7: Basic Instructions\n\n Chapter 8: Writing Full Values to Registers\n\n Chapter 9: Basic Loads & Stores, Big vs Little Endian\n\n Chapter 10: Compares & Branches\n\n Chapter 11: Pre & Post Indexing of Loads/Stores\n\n Chapter 12: Loops\n\n Chapter 13: Logical Operations\n\n Chapter 14: Bit Rotation, Shifting, Clearing\n\n Chapter 15: Extra Instruction Features\n\n Chapter 16: Condition Flags, Carry & Borrow\n\n Chapter 17: Conditional Select\n\n Chapter 18: Exception Basics, Exception Levels\n\n Chapter 19: Assembler Directives\n\n Chapter 20: Address Relative Loading\n\n Chapter 21: Using the Assembler, QEMU, & GDB\n\n Chapter 22: Load & Store Pair\n\n Chapter 23: Basic Register Safety\n\n Chapter 24: Float Basics\n\n Chapter 25: Float Loads & Stores\n\n Chapter 26: Functions\n\n Chapter 27: The Stack\n\n Chapter 28: Cache Part 1/2\n\n Chapter 29: Cache Part 2/2\n\n Chapter 30: Broadcasting, Barrier Instructions, Self Modifying Code\n\n Chapter 31: SIMD Part 1/3\n\n Chapter 32: SIMD Part 2/3\n\n Chapter 33: SIMD Part 3/3\n\n Chapter 34: Conclusion, What is to be done?"
    },
    {
        "link": "https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/using-the-stack-in-aarch64-implementing-push-and-pop",
        "document": "As described in my last article, AArch64 performs stack pointer alignment checks in hardware. In particular, whenever the stack pointer is used as the base register in an address operand, it must have 16-byte alignment.\n\nThe alignment checks can be very inconvenient in code generators where it is not feasible to determine how much stack space a function will require. Many JIT compilers fall into this category; they tend to rely on being able to push individual values to the stack.\n\nFor conventional C and C++ compilers, the stack pointer alignment restrictions in AAPCS64 don't seem to cause much trouble 1. Many C functions start with a prologue that allocates the stack space required for the whole function. This space is then accessed as needed during the function. This is possible because the C compiler can determine in advance the stack space that will be required. Special handling will be required for variable-length arrays and , but these are special cases that aren't often seen in real code.\n\nJIT compilers (and other time-constrained code generators) cannot usually do this because it is expensive to analyse the code to extract this information. Also, many simple compilers are based around a stack machine, and assume that there is an efficient implementation for an arbitrary number of registers. This is easy to manage in AArch32 because the basic data type is usually a single 4-byte register, and these can be pushed individually (between function calls) without violating any alignment rules. However, for AArch64, the required stack pointer alignment is two or four registers, and it is not possible to push individual registers.\n\nThe most appropriate method of implementing push and pop operations will depend on the nature of the engine you are using. I considered a number of possible solutions for use in the AArch64 port of the Google V8 JavaScript engine. I will present each idea along with their advantages and disadvantages.\n\nIf the required analysis is possible, it can result in fast generated code and efficient use of stack memory, so I've included this as a kind of benchmark, even though it might not be possible for many JIT compilers. The generated code will typically look something like this:\n\nIndexed addressing modes can sometimes be used to combine some of the operations. For example:\n\nDepending on the design of your compiler (and your source language), it might be possible to calculate stack usage for individual basic blocks, even if function-level analysis isn't feasible. You'll have a separate allocation instruction ( ) for each block, but this is still cheaper than some other approaches that I'll describe in this article.\n\nIt sounds wasteful – and in most cases it is – but the simplest way to handle the stack pointer can be to push each value to a 16-byte slot. This doubles the stack usage (for pointer-sized values), and it effectively reduces the available memory bandwidth. It is also awkward to implement multiple-register operations using this scheme, since each register requires a separate instruction.\n\nIn general, I don't consider this approach to be appropriate. However, it does have one significant advantage, which is that it is very simple; there might be situations where this simplicity is worth the cost.\n\nUse a register other than as the stack pointer\n\nThis mechanism is simple in principle: if the alignment restrictions of are inconvenient, just use another register as your stack pointer. General-purpose registers have no special alignment restrictions. Interfaces with PCS-compliant code (such as the C or C++ parts of the virtual machine) need to synchronise and the replacement stack pointer, but this is usually simple and quite cheap.\n\nThere is a notable complication: memory below the architectural (but in the stack area) cannot be safely accessed. Notably, this area is used by signal handlers, which execute asynchronously (like interrupts). If we just copy to some other register and start using it as a (descending) stack pointer, our special stack area will eventually be corrupted.\n\nOne way to use a separate register for the stack is to have a completely separate area of memory allocated for generated code to use as a stack. The two stacks would grow and shrink independently, and the procedure-call standard would apply only to the architectural stack. You must ensure that you allocate enough memory, but on most platforms you can allocate a large range of contiguous virtual addresses without actually reserving physical memory. (This is how Linux creates the normal process stack, for example.)\n\nThere aren't very many complications with this technique. Generated code must be careful around entry and exit points, but not significantly more than usual. The biggest complication in most situations will be integration with other components. For example, in a virtual machine where a garbage collector needs to scan and update the stack, it also needs to be aware of the special stack area.\n\nIf the application can reliably predict a maximum stack space for a given function, the entry point can simply move down temporarily to accomodate this space. It is often easier to determine the maximum stack space required than it is to determine precisely how much stack is needed.\n\nNote that doesn't need to be kept 16-byte aligned in the example above because it isn't used to access memory.\n\nSadly, although finding an upper limit on the required stack space is easier than calculating the usage exactly, it still often requires analysis that isn't easily available, so this is definitely not a drop-in solution.\n\nAnother solution is to update just before every push. won't necessarily be 16-byte aligned, but since it is never used to access memory, it doesn't matter. This method is what the Google V8 JavaScript engine uses, and it's also what VIXL's MacroAssembler uses if you tell it to use a different stack pointer.\n\nIn general, there is no need to unwind the architectural on instructions, since it is harmless to leave it where it is.\n\nWith some care, the preparation step for several pushes can be combined in order to minimise the code-size overhead. (If you take this far enough, it starts to look quite similar to the \"reserve stack area in advance\" proposal above.)\n\nAside from the wasteful 16-byte-per-slot mechanism, this shadow- design is probably the simplest drop-in solution available; and macros can be written to hide the alignment restrictions for ad-hoc usage, and no additional analysis is required to get it to work. It performs well, since most processors can execute the and at the same time. The only significant cost to be aware of is the code size overhead, especially where you have many small pushes.\n\nNone of these ideas will work well in every context, so the best choice really depends on the constraints that you have to work within. However, hopefully I've explained a few of the practical problems that you're likely to face, and given a bit of inspiration.\n\n1I've never actually worked on a C compiler, but their stack allocation behaviour is clear from disassembly."
    },
    {
        "link": "https://stackoverflow.com/questions/31346886/arm-aarch64-stack-management",
        "document": "Much like in 32-bit*, SP is a valid base register for any load/store instruction, so the mechanics aren't all that different. What is different is that SP is no longer a general-purpose register you can do whatever you want with, you don't have variable load/store-multiple operations any more, and there are no programmer-friendly aliases. Thus a typical \"push\" would be:\n\nNote that you should generally use / in favour of / in order to maintain alignment when operating on the stack (and especially when you have the hardware alignment checking turned on) - if you only have one register you care about, push/pop as the other to fill the gap.\n\n* Remember that e.g. \"push\" in the ARM instruction set is just an assembler alias for or as appropriate, and such aliases were only introduced with the unified assembly language as part of Thumb-2. Specific push/pop instructions did appear in original 16-bit Thumb, as SP can't be encoded in the normal load/store ops there which only operate on low registers."
    },
    {
        "link": "https://quora.com/How-do-I-create-a-recursion-in-ARM-architecture-assembly-language",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://sciencedirect.com/topics/computer-science/subroutine-call",
        "document": ""
    },
    {
        "link": "https://chegg.com/homework-help/questions-and-answers/write-aarch64-assembly-language-function-computes-sum-values-array-function-must-use-recur-q172070039",
        "document": "﻿assembly language function that computes the sum of all the\n\nvalues in the array. This function must use recursion to compute the sum. Use the\n\n﻿function prototype to design your function. The inputs are passed into x ﻿so this implementation is not correct based on how you load the parameters."
    }
]