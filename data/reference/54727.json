[
    {
        "link": "https://cdf.gsfc.nasa.gov",
        "document": "\n• The CDF and Perl distributions are universal binary of X86_64 and ARM64 code. All others are still x86_64-based, which can run on Apple Silicon Macs.\n• The CDF package installer allows installation at users home's Applications directory, instead of the default at system's /Applications folder.\n\nWe encourage all to subscribe to the CDF Announcements Mailing List to receive warnings of future leap seconds and other CDF issues.\n\nAs always, please report any problems, issues or questions to CDF_Support."
    },
    {
        "link": "https://spdf.gsfc.nasa.gov/pub/software/cdf/doc/cdf360/cdf360crm.pdf",
        "document": ""
    },
    {
        "link": "https://spdf.gsfc.nasa.gov/pub/software/cdf/doc/cdf380/cdf380ug.pdf",
        "document": ""
    },
    {
        "link": "https://cdf.gsfc.nasa.gov/html/cdf_docs.html",
        "document": ""
    },
    {
        "link": "https://spdf.gsfc.nasa.gov/pub/software/cdf/doc/cdf_CSharp_RefManual.pdf",
        "document": ""
    },
    {
        "link": "https://root.cern",
        "document": "You may have heard about the second ROOT Hackathon, that took place at IdeaSquare, CERN, last week (25-27 of November)! After a few days of recovering our energies, it’s time to look back at this vibrant event, so let’s go.\n\nYou may have heard of RNTuple, from CHEP’24, from other talks, or from our previous ROOT blog post. In case you haven’t: RNTuple is ROOT’s new I/O system for event data. Think of it as TTree, but more compact, faster, modern and more robust. With respect to TTree, we routinely see file size reductions between 10%-50%, multiple times faster read throughput, and much better write performance and multicore scalability. RNTuple can fully harness the performance of modern NVMe drives and object stores, and it comes with a modern, safe, and feature rich API.\n\nIn October 2024, the software and computing community in high-energy and nuclear physics met in Krakow at the CHEP24 conference. The event featured a rich scientific program in a great location.\n\nChoosing an appropriate color scheme is essential for making results easy to understand and interpret. Factors like colorblindness and converting colors to grayscale for publications can impact accessibility. Furthermore, results should be aesthetically pleasing. The following three color schemes, recommended by M. Petroff in arXiv:2107.02270v2 and available on GitHub under the MIT License, meet these criteria.\n\nThe academic year is about to start, so why not learn ROOT with us? During the summer, the ROOT team has organized a number of ROOT Summer Student courses at CERN and two HSF/IRIS-HEP Python for Analysis Trainings online, meaning the ROOT community has expanded by around 200 new students! And that is only the beginning; we think more students should have an opportunity to acquire the course material, this time in a self-study manner."
    },
    {
        "link": "https://root.cern.ch/root/htmldoc/guides/primer/ROOTPrimer.html",
        "document": "ROOT is a software framework for data analysis and I/O: a powerful tool to cope with the demanding tasks typical of state of the art scientific data analysis. Among its prominent features are an advanced graphical user interface, ideal for interactive analysis, an interpreter for the C++ programming language, for rapid and efficient prototyping and a persistency mechanism for C++ objects, used also to write every year petabytes of data recorded by the Large Hadron Collider experiments. This introductory guide illustrates the main features of ROOT which are relevant for the typical problems of data analysis: input and plotting of data from measurements and fitting of analytical functions.\n\nOriginal Authors - D. Piparo - G. Quast - M. Zeise\n\nComparison of measurements to theoretical models is one of the standard tasks in experimental physics. In the most simple case, a “model” is just a function providing predictions of measured data. Very often, the model depends on parameters. Such a model may simply state “the current I is proportional to the voltage U”, and the task of the experimentalist consists of determining the resistance, R, from a set of measurements.\n\nAs a first step, a visualisation of the data is needed. Next, some manipulations typically have to be applied, e.g. corrections or parameter transformations. Quite often, these manipulations are complex ones, and a powerful library of mathematical functions and procedures should be provided - think for example of an integral or peak-search or a Fourier transformation applied to an input spectrum to obtain the actual measurement described by the model.\n\nOne specialty of experimental physics are the inevitable uncertainties affecting each measurement, and visualisation tools have to include these. In subsequent analysis, the statistical nature of the errors must be handled properly.\n\nAs the last step, measurements are compared to models, and free model parameters need to be determined in this process. See Figure 1.1 for an example of a function (model) fit to data points. Several standard methods are available, and a data analysis tool should provide easy access to more than one of them. Means to quantify the level of agreement between measurements and model must also be available.\n\nQuite often, the data volume to be analyzed is large - think of fine-granular measurements accumulated with the aid of computers. A usable tool therefore must contain easy-to-use and efficient methods for storing and handling data.\n\nIn Quantum mechanics, models typically only predict the probability density function (“pdf”) of measurements depending on a number of parameters, and the aim of the experimental analysis is to extract the parameters from the observed distribution of frequencies at which certain values of the measurement are observed. Measurements of this kind require means to generate and visualize frequency distributions, so-called histograms, and stringent statistical treatment to extract the model parameters from purely statistical distributions.\n\nSimulation of expected data is another important aspect in data analysis. By repeated generation of “pseudo-data”, which are analysed in the same manner as intended for the real data, analysis procedures can be validated or compared. In many cases, the distribution of the measurement errors is not precisely known, and simulation offers the possibility to test the effects of different assumptions.\n\nA powerful software framework addressing all of the above requirements is ROOT, an open source project coordinated by the European Organisation for Nuclear Research, CERN in Geneva.\n\nROOT is very flexible and provides both a programming interface to use in own applications and a graphical user interface for interactive data analysis. The purpose of this document is to serve as a beginners guide and provides extendable examples for your own use cases, based on typical problems addressed in student labs. This guide will hopefully lay the ground for more complex applications in your future scientific work building on a modern, state-of the art tool for data analysis.\n\nThis guide in form of a tutorial is intended to introduce you quickly to the ROOT package. This goal will be accomplished using concrete examples, according to the “learning by doing” principle. Also because of this reason, this guide cannot cover all the complexity of the ROOT package. Nevertheless, once you feel confident with the concepts presented in the following chapters, you will be able to appreciate the ROOT Users Guide (The Root Users Guide 2020) and navigate through the Class Reference (The Root Reference Guide 2023) to find all the details you might be interested in. You can even look at the code itself, since ROOT is a free, open-source product. Use these documents in parallel to this tutorial!\n\nThe ROOT Data Analysis Framework itself is written in and heavily relies on the programming language: some knowledge about is required. Jus take advantage from the immense available literature about if you do not have any idea of what this language is about.\n\nROOT is available for many platforms (Linux, Mac OS X, Windows…), but in this guide we will implicitly assume that you are using Linux. The first thing you need to do with ROOT is install it, don’t you ? Obtaining the latest ROOT version is straightforward. Just seek the “Pro” version on this webpage http://root.cern.ch/downloading-root. You will find precompiled versions for the different architectures, or the ROOT source code to compile yourself. Just pick up the flavour you need and follow the installation instructions.\n\nNow that you have installed ROOT, what’s this interactive shell thing you’re running ? It’s like this: ROOT leads a double life. It has an interpreter for macros (Cling (“What is Cling” 2015)) that you can run from the command line or run like applications. But it is also an interactive shell that can evaluate arbitrary statements and expressions. This is extremely useful for debugging, quick hacking and testing. Let us first have a look at some very simple examples.\n\nYou can even use the ROOT interactive shell in lieu of a calculator! Launch the ROOT interactive shell with the command\n\nNot bad. You can see that ROOT offers you the possibility not only to type in statements, but also advanced mathematical functions, which live in the namespace.\n\nHere we made a step forward. We even declared variables and used a for control structure. Note that there are some subtle differences between Cling and the standard language. You do not need the “;” at the end of line in interactive mode – try the difference e.g. using the command at line .\n\nBehind the ROOT prompt there is an interpreter based on a real compiler toolkit: LLVM. It is therefore possible to exercise many features of and the standard library. For example in the following snippet we define a lambda function, a vector and we sort it in different ways:\n\nUsing one of ROOT’s powerful classes, here , will allow us to display a function of one variable, x. Try the following:\n\nis an instance of a TF1 class, the arguments are used in the constructor; the first one of type string is a name to be entered in the internal ROOT memory management system, the second string type parameter defines the function, here , and the two parameters of type double define the range of the variable x. The method, here without any parameters, displays the function in a window which should pop up after you typed the above two lines.\n\nA slightly extended version of this example is the definition of a function with parameters, called , and so on in the ROOT formula syntax. We now need a way to assign values to these parameters; this is achieved with the method of class . Here is an example:\n\nOf course, this version shows the same results as the initial one. Try playing with the parameters and plot the function again. The class has a large number of very useful methods, including integration and differentiation. To make full use of this and other ROOT classes, visit the documentation on the Internet under https://root.cern/doc/master/. Formulae in ROOT are evaluated using the class , so also look up the relevant class documentation for examples, implemented functions and syntax.\n\nConsider the example below, which calculates and displays the interference pattern produced by light falling on a multiple slit. Please do not type in the example below at the ROOT command line, there is a much simpler way: Make sure you have the file on disk, and type in the shell. This will start root and make it read the “macro” , i.e. all the lines in the file will be executed one after the other.\n\nThe example first asks for user input, namely the ratio of slit width over slit distance, and the number of slits. After entering this information, you should see the graphical output as is shown in Figure 2.1.\n\nThis is a more complicated example than the ones we have seen before, so spend some time analysing it carefully, you should have understood it before continuing. Let us go through it in detail:\n\nLines 7-18 define the necessary functions in code, split into three separate functions, as suggested by the problem considered. The full interference pattern is given by the product of a function depending on the ratio of the width and distance of the slits, and a second one depending on the number of slits. More important for us here is the definition of the interface of these functions to make them usable for the ROOT class : the first argument is the pointer to x, the second one points to the array of parameters.\n\nThe main program starts at line 21 with the definition of a function of type . After asking for user input, a ROOT function is defined using the C-type function given in the beginning. We can now use all methods of the class to control the behaviour of our function – nice, isn’t it ?\n\nIf you like, you can easily extend the example to also plot the interference pattern of a single slit, using function , or of a grid with narrow slits, function , in instances.\n\nHere, we used a macro, some sort of lightweight program, that the interpreter distributed with ROOT, Cling, is able to execute. This is a rather extraordinary situation, since is not natively an interpreted language! There is much more to say: chapter is indeed dedicated to macros.\n\nOne more remark at this point: as every command you type into ROOT is usually interpreted by Cling, an “escape character” is needed to pass commands to ROOT directly. This character is the dot at the beginning of a line:\n• None access the shell of the operating system, type ; try, e.g. or\n• None execute a macro, enter ; in the above example, you might have used at the ROOT prompt\n• None load a macro, type ; in the above example, you might instead have used the command followed by the function call . Note that after loading a macro all functions and procedures defined therein are available at the ROOT prompt.\n• None compile a macro, type ; ROOT is able to manage for you the compiler behind the scenes and to produce machine code starting from your macro. One could decide to compile a macro in order to obtain better performance or to get nearer to the production environment.\n\nTo display measurements in ROOT, including errors, there exists a powerful class with different types of constructors. In the example here, we use data from the file in text format:\n\nMake sure the file is available in the directory from which you started ROOT. Inspect this file now with your favourite editor, or use the command to inspect the file, you will see that the format is very simple and easy to understand. Lines beginning with are ignored. It is very convenient to add some comments about the type of data. The data itself consist of lines with four real numbers each, representing the x- and y- coordinates and their errors of each data point.\n\nThe argument of the method is important here. Behind the scenes, it tells the class to show the axes and to plot markers at the x and y positions of the specified data points. Note that this simple example relies on the default settings of ROOT, concerning the size of the canvas holding the plot, the marker type and the line colours and thickness used and so on. In a well-written, complete example, all this would need to be specified explicitly in order to obtain nice and well readable results. A full chapter on graphs will explain many more of the features of the class and its relation to other ROOT classes in much more detail.\n\nFrequency distributions in ROOT are handled by a set of classes derived from the histogram class , in our case . The letter stands for “float”, meaning that the data type is used to store the entries in one histogram bin.\n\nThe first three lines of this example define a function, an exponential in this case, and set its parameters. In line 3 a histogram is instantiated, with a name, a title, a certain number of bins (100 of them, equidistant, equally sized) in the range from 0 to 5.\n\nWe use yet another new feature of ROOT to fill this histogram with data, namely pseudo-random numbers generated with the method , which in turn uses an instance of the ROOT class created when ROOT is started. Data is entered in the histogram at line 4 using the method in a loop construct. As a result, the histogram is filled with 1000 random numbers distributed according to the defined function. The histogram is displayed using the method . You may think of this example as repeated measurements of the life time of a quantum mechanical state, which are entered into the histogram, thus giving a visual impression of the probability density distribution. The plot is shown in Figure 2.3.\n\nNote that you will not obtain an identical plot when executing the lines above, depending on how the random number generator is initialised.\n\nThe class does not contain a convenient input format from plain text files. The following lines of code do the job. One number per line stored in the text file “expo.dat” is read in via an input stream and filled in the histogram until end of file is reached.\n\nLook at one of your plots again and move the mouse across. You will notice that this is much more than a static picture, as the mouse pointer changes its shape when touching objects on the plot. When the mouse is over an object, a right-click opens a pull-down menu displaying in the top line the name of the ROOT class you are dealing with, e.g. for the display window itself, for the frame of the plot, for the axes, for the plot name. Depending on which plot you are investigating, menus for the ROOT classes , or will show up when a right-click is performed on the respective graphical representations. The menu items allow direct access to the members of the various classes, and you can even modify them, e.g. change colour and size of the axis ticks or labels, the function lines, marker types and so on. Try it!\n\nYou will probably like the following: in the output produced by the example , right-click on the function line and select “SetLineAttributes”, then left-click on “Set Parameters”. This gives access to a panel allowing you to interactively change the parameters of the function, as shown in Figure 2.4. Change the slit width, or go from one to two and then three or more slits, just as you like. When clicking on “Apply”, the function plot is updated to reflect the actual value of the parameters you have set.\n\nAnother very useful interactive tool is the , available for the classes and . Predefined fit functions can be selected from a pull-down menu, including “ ”, “ ” and “ ” - “ ” for Gaussian and exponential functions or polynomials of degree 0 to 9, respectively. In addition, user-defined functions using the same syntax as for functions with parameters are possible.\n\nAfter setting the initial parameters, a fit of the selected function to the data of a graph or histogram can be performed and the result displayed on the plot. The fit panel is shown in Figure 2.5. The fit panel has a number of control options to select the fit method, fix or release individual parameters in the fit, to steer the level of output printed on the console, or to extract and display additional information like contour lines showing parameter correlations. As function fitting is of prime importance in any kind of data analysis, this topic will again show up later.\n\nIf you are satisfied with your plot, you probably want to save it. Just close all selector boxes you opened previously and select the menu item from the menu line of the window. It will pop up a file selector box to allow you to choose the format, file name and target directory to store the image. There is one very noticeable feature here: you can store a plot as a root macro! In this macro, you find the C++ representation of all methods and classes involved in generating the plot. This is a valuable source of information for your own macros, which you will hopefully write after having worked through this tutorial.\n\nUsing ROOT’s interactive capabilities is useful for a first exploration of possibilities. Other ROOT classes you will encounter in this tutorial have such graphical interfaces. We will not comment further on this, just be aware of the existence of ROOT’s interactive features and use them if you find them convenient. Some trial-and-error is certainly necessary to find your way through the huge number of menus and parameter settings.\n\nAt this point of the guide, some basic questions could have already come to your mind. We will try to clarify some of them with further explanations in the following.\n\nIn the official ROOT documentation, you find special data types replacing the normal ones, e.g. , or replacing the standard , or types. Using the ROOT types makes it easier to port code between platforms (64/32 bit) or operating systems (windows/Linux), as these types are mapped to suitable ones in the ROOT header files. If you want adaptive code of this type, use the ROOT type declarations. However, usually you do not need such adaptive code, and you can safely use the standard C type declarations for your private code, as we did and will do throughout this guide. If you intend to become a ROOT developer, however, you better stick to the official coding rules!\n\nThe behaviour of a ROOT session can be tailored with the options in the file. Examples of the tunable parameters are the ones related to the operating and window system, to the fonts to be used, to the location of start-up files. At start-up, ROOT looks for a file in the following order:\n\nIf more than one files are found in the search paths above, the options are merged, with precedence local, user, global. The parsing and interpretation of this file is handled by the ROOT class . Have a look to its documentation if you need such rather advanced features. The file defines the location of two rather important files inspected at start-up: and . They can contain code that needs to be loaded and executed at ROOT startup. is only loaded and best used to define some often used functions. contains code that will be executed at startup: this file is extremely useful for example to pre-load a custom style for the plots created with ROOT. This is done most easily by creating a new object with your preferred settings, as described in the class reference guide, and then use the command to make this new style definition the default one. As an example, have a look in the file coming with this tutorial. Another relevant file is that it called when the session is finished.\n\nEvery command typed at the ROOT prompt is stored in a file in your home directory. ROOT uses this file to allow for navigation in the command history with the up-arrow and down-arrow keys. It is also convenient to extract successful ROOT commands with the help of a text editor for use in your own macros.\n\nAll global pointers in ROOT begin with a small “g”. Some of them were already implicitly introduced (for example in the section Configure ROOT at start-up). The most important among them are presented in the following:\n• None gROOT: the variable is the entry point to the ROOT system. Technically it is an instance of the class. Using the pointer one has access to basically every object created in a ROOT based program. The object is essentially a container of several lists pointing to the main objects.\n• None gStyle: By default ROOT creates a default style that can be accessed via the pointer. This class includes functions to set some of the following object attributes.\n• None gSystem: An instance of a base class defining a generic interface to the underlying Operating System, in our case .\n• None gInterpreter: The entry point for the ROOT interpreter. Technically an abstraction level over a singleton instance of .\n\nYou know how other books go on and on about programming fundamentals and finally work up to building a complete, working program ? Let’s skip all that. In this guide, we will describe macros executed by the ROOT C++ interpreter Cling.\n\nIf you have a number of lines which you were able to execute at the ROOT prompt, they can be turned into a ROOT macro by giving them a name which corresponds to the file name without extension. The general structure for a macro stored in file is\n\nat the ROOT prompt. Note that more than one macro can be loaded this way, as each macro has a unique name in the ROOT name space. A small set of options can help making your plot nicer.\n\nNext, you should create a canvas for graphical output, with size, subdivisions and format suitable to your needs, see documentation of class :\n\nThese parts of a well-written macro are pretty standard, and you should remember to include pieces of code like in the examples above to make sure your plots always look as you had intended.\n\nBelow, in section Interpretation and Compilation, some more code fragments will be shown, allowing you to use the system compiler to compile macros for more efficient execution, or turn macros into stand-alone applications linked against the ROOT libraries.\n\nLet us now look at a rather complete example of a typical task in data analysis, a macro that constructs a graph with errors, fits a (linear) model to it and saves it as an image. To run this macro, simply type in the shell:\n\nThe code is built around the ROOT class , which was already introduced previously. Have a look at it in the class reference guide, where you will also find further examples. The macro shown below uses additional classes, to define a function, to define size and properties of the window used for our plot, and to add a nice legend. For the moment, ignore the commented include statements for header files, they will only become important at the end in section Interpretation and Compilation.\n• None Line 13: the name of the principal function (it plays the role of the “main” function in compiled programs) in the macro file. It has to be the same as the file name without extension.\n• None Line 24-25: instance of the class. The constructor takes the number of points and the pointers to the arrays of x values, y values, x errors (in this case none, represented by the NULL pointer) and y errors. The second line defines in one shot the title of the graph and the titles of the two axes, separated by a “;”.\n• None Line 28-30: These three lines are rather intuitive right ? To understand better the enumerators for colours and styles see the reference for the and classes.\n• None Line 33: the canvas object that will host the drawn objects. The “memory leak” is intentional, to make the object existing also out of the macro1 scope.\n• None Line 36: the method DrawClone draws a clone of the object on the canvas. It has to be a clone, to survive after the scope of , and be displayed on screen after the end of the macro execution. The string option “APE” stands for:\n• None A imposes the drawing of the Axes.\n• None P imposes the drawing of the graph’s markers.\n• None E imposes the drawing of the graph’s error bars.\n• None Line 39: define a mathematical function. There are several ways to accomplish this, but in this case the constructor accepts the name of the function, the formula, and the function range.\n• None Line 41: maquillage. Try to give a look to the line styles at your disposal visiting the documentation of the class.\n• None Line 43: fits the f function to the graph, observe that the pointer is passed. It is more interesting to look at the output on the screen to see the parameters values and other crucial information that we will learn to read at the end of this guide.\n• None Line 44: again draws the clone of the object on the canvas. The “Same” option avoids the cancellation of the already drawn objects, in our case, the graph. The function f will be drawn using the same axis system defined by the previously drawn graph.\n• None Line 47-52: completes the plot with a legend, represented by a instance. The constructor takes as parameters the lower left and upper right corners coordinates with respect to the total size of the canvas, assumed to be 1, and the legend header string. You can add to the legend the objects, previously drawn or not drawn, through the method. Observe how the legend is drawn at the end: looks familiar now, right ?\n• None Line 55-57: defines an arrow with a triangle on the right hand side, a thickness of 2 and draws it.\n• None Line 60-61: interpret a Latex string which hast its lower left corner located in the specified coordinate. The construct allows to store multiple lines in the same object.\n• None Line 63: save the canvas as image. The format is automatically inferred from the file extension (it could have been eps, gif, …).\n\nLet’s give a look to the obtained plot in Figure 3.1. Beautiful outcome for such a small bunch of lines, isn’t it ?\n\nWe have seen that to specify a colour, some identifiers like kWhite, kRed or kBlue can be specified for markers, lines, arrows etc. The complete summary of colours is represented by the ROOT “colour wheel”. To know more about the full story, refer to the online documentation of .\n\nROOT provides several graphics markers types. Select the most suited symbols for your plot among dots, triangles, crosses or stars. An alternative set of names for the markers is available.\n\nThe macro line 55 shows how to define an arrow and draw it. The class representing arrows is , which inherits from . The constructors of lines and arrows always contain the coordinates of the endpoints. Arrows also foresee parameters to specify their shapes. Do not underestimate the role of lines and arrows in your plots. Since each plot should contain a message, it is convenient to stress it with additional graphics primitives.\n\nAlso text plays a fundamental role in making the plots self-explanatory. A possibility to add text in your plot is provided by the class. The objects of this class are constructed with the coordinates of the bottom-left corner of the text and a string which contains the text itself. The real twist is that ordinary Latex mathematical symbols are automatically interpreted, you just need to replace the “\\” by a “#”.\n\nIf “\\” is used as control character , then the TMathText interface is invoked. It provides the plain TeX syntax and allow to access character’s set like Russian and Japanese.\n\nAs you observed, up to now we heavily exploited the capabilities of ROOT for interpreting our code, more than compiling and then executing. This is sufficient for a wide range of applications, but you might have already asked yourself “how can this code be compiled ?”. There are two answers.\n\nACLiC will create for you a compiled dynamic library for your macro, without any effort from your side, except the insertion of the appropriate header files in lines 5–11. In this example, they are already included. To generate an object library from the macro code, from inside the interpreter type (please note the “+”):\n\nOnce this operation is accomplished, the macro symbols will be available in memory and you will be able to execute it simply by calling from inside the interpreter:\n\nA plethora of excellent compilers are available, both free and commercial. We will refer to the compiler in the following. In this case, you have to include the appropriate headers in the code and then exploit the root-config tool for the automatic settings of all the compiler flags. root-config is a script that comes with ROOT; it prints all flags and libraries needed to compile code and link it with the ROOT libraries. In order to make the code executable stand-alone, an entry point for the operating system is needed, in C++ this is the procedure . The easiest way to turn a ROOT macro code into a stand-alone application is to add the following “dressing code” at the end of the macro file. This defines the procedure main, the only purpose of which is to call your macro:\n\nThis procedure will, however, not give access to the ROOT graphics, as neither control of mouse or keyboard events nor access to the graphics windows of ROOT is available. If you want your stand-alone application have display graphics output and respond to mouse and keyboard, a slightly more complex piece of code can be used. In the example below, a macro is executed by the ROOT class . As a additional feature, this code example offers access to parameters eventually passed to the program when started from the command line. Here is the code fragment:\n\nIn this Chapter we will learn how to exploit some of the functionalities ROOT provides to display data exploiting the class , which you already got to know previously.\n\nThe fastest way in which you can fill a graph with experimental data is to use the constructor which reads data points and their errors from an ASCII file (i.e. standard text) format:\n\nThis approach has the nice feature of allowing the user to reuse the macro for many different data sets. Here is an example of an input file. The nice graphic result shown is produced by the macro below, which reads two such input files and uses different options to display the data points.\n\nIn addition to the inspection of the plot, you can check the actual contents of the graph with the method at any time, obtaining a printout of the coordinates of data points on screen. The macro also shows us how to print a coloured band around a graph instead of error bars, quite useful for example to represent the errors of a theoretical prediction.\n\nWith ROOT you can profit from rather advanced plotting routines, like the ones implemented in the , a class to draw graphs in polar coordinates. You can see the example macro in the following and the resulting Figure is 4.2:\n\nA new element was added on line 4, the size of the canvas: it is sometimes optically better to show plots in specific canvas sizes.\n\nUnder specific circumstances, it might be useful to plot some quantities versus two variables, therefore creating a bi-dimensional graph. Of course ROOT can help you in this task, with the class. The following macro produces a bi-dimensional graph representing a hypothetical measurement, fits a bi-dimensional function to it and draws it together with its x and y projections. Some points of the code will be explained in detail. This time, the graph is populated with data points using random numbers, introducing a new and very important ingredient, the ROOT random number generator using the Mersenne Twister algorithm (Matsumoto 1997).\n• None Line 7: The instance of the random generator. You can then draw out of this instance random numbers distributed according to different probability density functions, like the Uniform one at lines 27-29. See the on-line documentation to appreciate the full power of this ROOT feature.\n• None Line 8: You are already familiar with the class. This is its two-dimensional version. At line 16 two random numbers distributed according to the formula are drawn with the method .\n• None Line 27-29: Fitting a 2-dimensional function just works like in the one-dimensional case, i.e. initialisation of parameters and calling of the method.\n• None Line 34: The Surf1 option draws the objects (but also bi-dimensional histograms) as coloured surfaces with a wire-frame on three-dimensional canvases. See Figure 4.3.\n• None Line 41: Draw the cloud of points on top of the coloured surface.\n• None Line 43-49: Here you learn how to create a canvas, partition it in two sub-pads and access them. It is very handy to show multiple plots in the same window or image.\n\nThe class allows to manipulate a set of graphs as a single entity. It is a collection of (or derived) objects. When drawn, the X and Y axis ranges are automatically computed such as all the graphs will be visible.\n• None Line 30-32: draw the multigraph. The axis limits are computed automatically to make sure all the graphs’ points will be in range.\n\nHistograms play a fundamental role in any type of physics analysis, not only to visualise measurements but being a powerful form of data reduction. ROOT offers many classes that represent histograms, all inheriting from the class. We will focus in this chapter on uni- and bi- dimensional histograms the bin contents of which are represented by floating point numbers, the and classes respectively.\n\nLet’s suppose you want to measure the counts of a Geiger detector located in proximity of a radioactive source in a given time interval. This would give you an idea of the activity of your source. The count distribution in this case is a Poisson distribution. Let’s see how operatively you can fill and draw a histogram with the following example macro.\n• None line 5: The histograms have a name and a title right from the start, no predefined number of entries but a number of bins and a lower-upper range.\n• None line 15: An entry is stored in the histogram through the method.\n• None line 18 and 21: The histogram can be drawn also normalised, ROOT automatically takes cares of the necessary rescaling.\n\nQuite a large number of operations can be carried out with histograms. The most useful are addition and division. In the following macro we will learn how to manage these procedures within ROOT.\n\nThe plots that you will obtain are shown in Figures 5.2 and 5.3.\n• None line 3: Cling, as we know, is also able to interpret more than one function per file. In this case the function simply sets up some parameters to conveniently set the line of histograms.\n• None line 19 to 21: Some syntax for conditional statements is used to fill the histograms with different numbers of entries inside the loop.\n• None line 30: The sum of two histograms. A weight, which can be negative, can be assigned to the added histogram.\n\nTwo-dimensional histograms are a very useful tool, for example to inspect correlations between variables. You can exploit the bi-dimensional histogram classes provided by ROOT in a simple way. Let’s see how in this macro:\n\nTwo kinds of plots are provided within the code, the first one containing three-dimensional representations (Figure 5.4) and the second one projections and profiles (Figure 5.5) of the bi-dimensional histogram.\n\nWhen a projection is performed along the x (y) direction, for every bin along the x (y) axis, all bin contents along the y (x) axis are summed up (upper the plots of Figure 5.5). When a profile is performed along the x (y) direction, for every bin along the x (y) axis, the average of all the bin contents along the y (x) is calculated together with their RMS and displayed as a symbol with error bar (lower two plots of Figure 5.5).\n\nCorrelations between the variables are quantified by the methods and .\n\nThe class allows to manipulate a set of histograms as a single entity. It is a collection of (or derived) objects. When drawn, the X and Y axis ranges are automatically computed such as all the histograms will be visible. Several drawing option are available for both 1D and 2D histograms. The next macros shows how it looks for 2D histograms:\n• None Lines 20-21: add the histograms in the stack.\n• None Line 23: draws the stack as a lego plot. The colour distinguish the two histograms 5.6.\n\nAfter going through the previous chapters, you already know how to use analytical functions (class ), and you got some insight into the graph ( ) and histogram classes ( ) for data visualisation. In this chapter we will add more detail to the previous approximate explanations to face the fundamental topic of parameter estimation by fitting functions to data. For graphs and histograms, ROOT offers an easy-to-use interface to perform fits - either the fit panel of the graphical interface, or the method. The class allows access to the detailed results.\n\nVery often it is necessary to study the statistical properties of analysis procedures. This is most easily achieved by applying the analysis to many sets of simulated data (or “pseudo data”), each representing one possible version of the true experiment. If the simulation only deals with the final distributions observed in data, and does not perform a full simulation of the underlying physics and the experimental apparatus, the name “Toy Monte Carlo” is frequently used. Since the true values of all parameters are known in the pseudo-data, the differences between the parameter estimates from the analysis procedure w.r.t. the true values can be determined, and it is also possible to check that the analysis procedure provides correct error estimates.\n\nROOT offers various minimisation algorithms to minimise a chi2 or a negative log-likelihood function. The default minimiser is MINUIT, a package originally implemented in the FORTRAN programming language. A C++ version is also available, MINUIT2, as well as Fumili (Silin 1983) an algorithm optimised for fitting. The minimisation algorithms can be selected using the static functions of the class. Steering options for the minimiser, such as the convergence tolerance or the maximum number of function calls, can also be set using the methods of this class. All currently implemented minimisers are documented in the reference documentation of ROOT: have a look for example to the class documentation. The complication level of the code below is intentionally a little higher than in the previous examples. The graphical output of the macro is shown in Figure 6.1:\n• None Lines 1-3: A simple function to ease the make-up of lines. Remember that the class inherits from .\n• None Lines 5-7 : Definition of a customised function, namely a Gaussian (the “signal”) plus a parabolic function, the “background”.\n• None Lines 10-12: Some make-up for the Canvas. In particular we want that the parameters of the fit appear very clearly and nicely on the plot.\n• None Lines 20-25: Define and initialise an instance of .\n• None Lines 33-38: For convenience, the same function as for the generation of the pseudo-data is used in the fit; hence, we need to reset the function parameters. This part of the code is very important for each fit procedure, as it sets the initial values of the fit.\n• None Lines 42-46: Retrieve the output from the fit. Here, we simply print the fit result and access and print the covariance matrix of the parameters.\n• None Lines 54-end: Plot the pseudo-data, the fitted function and the signal and background components at the best-fit values.\n\nAs a very simple yet powerful quantity to check the quality of the fit results, we construct for each pseudo-data set the so-called “pull”, the difference of the estimated and the true value of a parameter, normalised to the estimated error on the parameter, \\(\\frac{(p_{estim} - p_{true})}{\\sigma_{p}}\\). If everything is OK, the distribution of the pull values is a standard normal distribution, i.e. a Gaussian distribution centred around zero with a standard deviation of one.\n\nThe macro performs a rather big number of toy experiments, where a histogram is repeatedly filled with Gaussian distributed numbers, representing the pseudo-data in this example. Each time, a fit is performed according to the selected method, and the pull is calculated and filled into a histogram. Here is the code:\n\nYour present knowledge of ROOT should be enough to understand all the technicalities behind the macro. Note that the variable in line 61 is different from the definition above: instead of the parameter error on , the fitted standard deviation of the distribution divided by the square root of the number of entries, , is used.\n• None What method exhibits the better performance with the default parameters ?\n• None What happens if you increase the number of entries per histogram by a factor of ten ? Why ?\n\nThe answers to these questions are well beyond the scope of this guide. Basically all books about statistical methods provide a complete treatment of the aforementioned topics.\n\nROOT offers the possibility to write instances of classes on disk, into a ROOT-file (see the class for more details). One says that the object is made “persistent” by storing it on disk. When reading the file back, the object is reconstructed in memory. The requirement to be satisfied to perform I/O of instances of a certain class is that the ROOT type system is aware of the layout in memory of that class. This topic is beyond the scope of this document: it is worth to mention that I/O can be performed out of the box for the almost complete set of ROOT classes.\n\nNot bad, eh ? Especially for a language that does not foresees persistency natively like C++. The RECREATE option forces ROOT to create a new file even if a file with the same name exists on disk.\n\nNow, you may use the Cling command line to access information in the file and draw the previously written histogram:\n• None Store not only numbers, but also objects in the columns.\n\nIn this section we will discuss briefly the class, which is a simplified version of the class. A ROOT object can store rows of float entries. Let’s tackle the problem according to the usual strategy commenting a minimal example\n\nThis data written to this example n-tuple represents, in the statistical sense, three independent variables (Potential or Voltage, Pressure and Temperature), and one variable (Current) which depends on the others according to very simple laws, and an additional Gaussian smearing. This set of variables mimics a measurement of an electrical resistance while varying pressure and temperature.\n\nImagine your task now consists in finding the relations among the variables – of course without knowing the code used to generate them. You will see that the possibilities of the class enable you to perform this analysis task. Open the ROOT file ( ) written by the macro above in an interactive session and use a to interactively inspect it:\n\nYou find the columns of your n-tuple written as leafs. Simply clicking on them you can obtain histograms of the variables!\n\nNext, try the following commands at the shell prompt and in the interactive ROOT shell, respectively:\n\nThe macro shows the easiest way of accessing the content of a n-tuple: after loading the n-tuple, its branches are assigned to variables and automatically fills them with the content for a specific row. By doing so, the logic for reading the n-tuple and the code to process it can be split and the source code remains clear.\n\nIt is also possible to write n-tuples of arbitrary type by using ROOT’s class. This is especially important as accepts only floats. The following macro creates the same n-tuple as before but the branches are booked directly. The function then fills the current values of the connected variables to the tree.\n\nThe function requires a pointer to a variable and a definition of the variable type. The following table lists some of the possible values. Please note that ROOT is not checking the input and mistakes are likely to result in serious problems. This holds especially if values are read as another type than they have been written, e.g. when storing a variable as float and reading it as double.\n\nList of variable types that can be used to define the type of a branch in ROOT:\n\nUsually n-tuples or trees span over many files and it would be difficult to add them manually. ROOT thus kindly provides a helper class in the form of . Its usage is shown in the following macro which is very similar to the previous example. The constructor of a takes the name of the (or ) as an argument. The files are added with the function , where one can also use wild-cards as shown in the example.\n\nAnother very general and powerful way of processing a is provided via the method . This method takes as arguments an instance of a – user-implemented– class of type , and – optionally – the number of entries and the first entry to be processed. A template for the class is provided by the method , as is shown in the little macro below.\n\nIt opens the n-tuple from the example above and creates from it the header file and a template to insert your own analysis code, .\n\nThe template contains the entry points and called before processing of the starts, called for every entry of the chain, and and called after the last entry has been processed. Typically, initialization like booking of histograms is performed in , the analysis, i.e. the selection of entries, calculations and filling of histograms, is done in , and final operations like plotting and storing of results happen in or .\n\nA simple example of a selector class is shown in the macro . The example is executed with the following sequence of commands:\n\nAs usual, the “ ” appended to the name of the macro to be executed initiates the compilation of the with the system compiler in order to improve performance.\n\nThe code in , shown in the listing below, books some histograms in and adds them to the instance , which is of the class . The final processing in allows to access histograms and store, display or save them as pictures. This is shown in the example via the . See the commented listing below for more details; most of the text is actually comments generated automatically by .\n\nThe processing of n-tuples via a selector function of type through , as described at the end of the previous section, offers an additional advantage in particular for very large data sets: on distributed systems or multi-core architectures, portions of data can be processed in parallel, thus significantly reducing the execution time. On modern computers with multi-core CPUs or hardware-threading enabled, this allows a much faster turnaround of analyses, since all the available CPU power is used.\n\nOn distributed systems, a PROOF server and worker nodes have to be set up, as described in detail in the ROOT documentation. On a single computer with multiple cores, can be used instead. Try the following little macro, , which contains two extra lines compared to the example above (adjust the number of workers according to the number of CPU cores):\n\nThe first command, starts a local PROOF server (if no arguments are specified, all cores will be used), and the command enables processing of the chain using PROOF. Now, when issuing the command , the code in is compiled and executed on each slave node. The methods and are executed on the master only. The list of n-tuple files is analysed, and portions of the data are assigned to the available slave processes. Histograms booked in exist in the processes on the slave nodes, and are filled accordingly. Upon termination, the PROOF master collects the histograms from the slaves and merges them. In all merged histograms are available and can be inspected, analysed or stored. The histograms are handled via the instances of class in each slave process, and can be retrieved from this list after merging in .\n\nTo explore the power of this mechanism, generate some very large n-tuples using the script from the section Storing Arbitrary N-tuples - you could try 10 000 000 events (this results in a large n-tuple of about 160 MByte in size). You could also generate a large number of files and use wildcards to add the to the . Now execute: and watch what happens:\n\nLog files of the whole processing chain are kept in the directory for each worker node. This is very helpful for debugging or if something goes wrong. As the method described here also works without using PROOF, the development work on an analysis script can be done in the standard way on a small subset of the data, and only for the full processing one would use parallelism via PROOF.\n\nIt is worth to remind the reader that the speed of typical data analysis programs limited by the I/O speed (for example the latencies implied by reading data from a hard drive). It is therefore expected that this limitation cannot be eliminated with the usage of any parallel analysis toolkit.\n\nROOT automatically applies compression algorithms on n-tuples to reduce the memory consumption. A value that is in most cases the same will consume only small space on your disk (but it has to be decompressed on reading). Nevertheless, you should think about the design of your n-tuples and your analyses as soon as the processing time exceeds some minutes.\n• None Experimental conditions that do not change with every single measurement should be stored in a separate tree. Although the compression can handle redundant values, the processing time increase with every variable that has to be filled.\n• None The function specifies the size of the cache for reading a object from a file. The default value is 30MB. A manual increase may help in certain situations. Please note that the caching mechanism can cover only one object per object.\n• None You can select the branches to be covered by the caching algorithm with and deactivate unneeded branches with . This mechanism can result in a significant speed-up for simple operations on trees with many branches.\n• None You can measure the performance easily with . The ROOT documentation on this class also includes an introductory example. For example, can show you that it is beneficial to store meta data and payload data separately, i.e. write the meta data tree in a bulk to a file at the end of your job instead of writing both trees interleaved.\n\nROOT offers the possibility to interface to Python via a set of bindings called PyROOT. Python is used in a wide variety of application areas and one of the most used scripting languages today. With the help of PyROOT it becomes possible to combine the power of a scripting language with ROOT tools. Introductory material to Python is available from many sources on the web, see e. g. http://docs.python.org.\n\nThe access to ROOT classes and their methods in PyROOT is almost identical to C++ macros, except for the special language features of Python, most importantly dynamic type declaration at the time of assignment. Coming back to our first example, simply plotting a function in ROOT, the following C++ code:\n\nA slightly more advanced example hands over data defined in the macro to the ROOT class . Note that a Python array can be used to pass data between Python and ROOT. The first line in the Python script allows it to be executed directly from the operating system, without the need to start the script from python or the highly recommended powerful interactive shell ipython. The last line in the python script is there to allow you to have a look at the graphical output in the ROOT canvas before it disappears upon termination of the script.\n\nHere is the C++ version:\n\nComparing the C++ and Python versions in these two examples, it now should be clear how easy it is to convert any ROOT Macro in C++ to a Python version.\n\nAs another example, let us revisit macro3 from Chapter 4. A straight-forward Python version relying on the ROOT class :\n\nA more “pythonic” version of the above macro3 would use a replacement of the ROOT class TMath for the provisioning of data to TGraphPolar. With the math package, the part of the code becomes\n\nThis example combines comfortable handling of arrays in Python to define variable bin sizes of a ROOT histogram. All we need to know is the interface of the relevant ROOT class and its methods (from the ROOT documentation):\n\nThe ROOT interpreter and type sytem offer interesting possibilities when it comes to JITting of C++ code. Take for example this header file, containing a class and a function.\n\nThis example might seem trivial, but it shows a powerful ROOT feature. C++ code can be JITted within PyROOT and the entities defined in C++ can be transparently used in Python!\n\nThis is the end of our guided tour for beginners through ROOT. There is still a lot coming to mind to be said, but by now you are experienced enough to use the ROOT documentation, most importantly the ROOT home page and the ROOT reference guide with the documentation of all ROOT classes, or the ROOT users manual.\n\nA very useful way for you to continue exploring ROOT is to study the examples in the sub-directory of any ROOT installation.\n\nThere are some powerful features of ROOT which were not treated in this document, e.g. packages named RooFit and RooStats providing an advanced framework for model building, fitting and statistical analysis. The ROOT namespace offers multi-variate analysis tools including an artificial neural network and many other advanced tools for classification problems. The remarkable ability of ROOT to handle large data volumes was already mentioned in this guide, implemented through the class . But there is still much more for you to explore!\n\nEnd of this guide … but hopefully not of your interaction with ROOT !"
    },
    {
        "link": "https://cds.cern.ch/record/491486/files/p11.pdf",
        "document": ""
    },
    {
        "link": "https://casact.org/sites/default/files/database/forum_08wforum_kumar_tripathi.pdf",
        "document": ""
    },
    {
        "link": "https://root.cern/download/RubyRoot.pdf",
        "document": ""
    }
]