[
    {
        "link": "https://stackoverflow.com/questions/57998015/mappageroute-is-throwing-error-in-global-asax",
        "document": "I am trying to re-write the URL for SEO friendly pattern. Best way is to remove the file extension. I visited some tutorial where the use of Global.asax file was suggested.\n\nI am using .net framework 3.5 and in which I am getting the below error:\n\nError CS1061 'RouteCollection' does not contain a definition for 'MapPageRoute' and no accessible extension method 'MapPageRoute' accepting a first argument of type 'RouteCollection' could be found (are you missing a using directive or an assembly reference?)\n\nI am using the code below in the global.asax file for routing.\n\nPlease help how to fix this issue.\n\nI have checked the reference of system.web.routing. Its correct."
    },
    {
        "link": "https://stackoverflow.com/questions/19974107/routemapping-works-on-development-server-but-results-in-404-in-production",
        "document": "I have the following code in Global.asax, in a web site project with webforms, not an MVC application:\n\nThe route mapping works correctly on my dev environment which runs IIS Express, but in production it returns a 404 error.\n\nThe server runs IIS 7 and has almost identical web.config-files. I haven't been able to identify any changes between the dev web.config and the production one that might be the cause.\n\nHow come my route mappings work in my dev environment but not in my production environment?"
    },
    {
        "link": "https://docs.kentico.com/k9/developing-websites/developing-sites-using-asp-net-mvc/developing-mvc-applications/handling-404-not-found-globally-in-mvc-applications",
        "document": "The Kentico.Web.Mvc integration package comes with a feature that allows you to return the same ‘404 Not Found’ page in the MVC application in the following scenarios:\n• A controller action returns ‘System.Web.Mvc.HttpNotFoundResult’ (usually returned by calling the controller’s ‘HttpNotFound’ method)\n\nFor this feature to work, the <modules> element in the <system.webServer> section of your MVC project’s main web.config file needs to have the runAllManagedModulesForAllRequests attribute set to true. The attribute is automatically added by installing the Kentico.Web.Mvc integration package.\n\nEnabling the global Not Found handler in MVC applications\n• None Install the Kentico.Web.Mvc integration package in your MVC application project.\n• None In the MVC application’s Global.asax file, add the following line in the Application_Start method:\n• None Make sure the feature is enabled in the MVC application’s ApplicationConfig.csfile:\n• None In your MVC application’s project, create a ‘NotFound.cshtml’ view under the ‘Views\\Shared’ path.\n\nNow, whenever a request for a page that doesn’t match any controller or controller action is made, the system returns the NotFound.cshtml page. The system also returns the page whenever a controller action returns the *System.Web.Mvc.**HttpNotFoundResult* class (for example, when calling the System.Web.Mvc.Controller.HttpNotFound method).\n\nHandling requests not matched by any route\n\nYou can also return the ‘NotFound.cshtml’ view in other cases in which the MVC application responds with a ‘Not Found’ status. To cover a scenario when a request that doesn’t match any configured route is made, you need to implement a catch-all route in the RouteConfig.cs file.\n• None Create a new catch-all route in the MVC application’s RouteConfig.cs file. Make sure the route is the last route that you register in the file:\n• None Create a controller and action for the catch-all route.\n\nThe system returns the NotFound.cshtml page whenever a request for an undefined route is made on the MVC site."
    },
    {
        "link": "https://hanselman.com/blog/introducing-aspnet-friendlyurls-cleaner-urls-easier-routing-and-mobile-views-for-aspnet-web-forms",
        "document": "I've said before how surprised I am that more ASP.NET Web Forms developers don't use Routing to make their URLs prettier. If you don't want \"foo.aspx\" in your URL, then change it with Routes.MapPageRoute(). However, managing Routing Tables is a little tedious and most WebForms folks aren't used to the concept and don't want to invest the time.\n\nI've also heard a number of ASP.NET Web Forms Developers express a little envy at how easy it is to make a site that has both desktop and mobile views using ASP.NET MVC. They like the idea of seeing an iPhone show up and showing a different view while reusing logic as I've shown in my mobile talks before.\n\nLet's solve both these problems with a new ASP.NET feature just pre-released today in alpha form on NuGet. My peer Damian Edwards and developer Levi Broderick along with QA by Pranav and Anton have come up with a pretty awesome solution based on the original \"Smarty Routes\" idea from Eilon Lipton and the result is FriendlyUrls.\n\nIt's also worth noting that this FriendlyUrls NuGet package includes BOTH an ASP.NET 4.5 and ASP.NET 4 version so .NET 4 folks get love too.\n\nFirst, the obvious example. Bring up Visual Studio and File | New Project | New ASP.NET Web Forms Application. Now, from the Package Manager Console or from Manage NuGet Packages, install Microsoft.AspNet.FriendlyUrls. You'll need to \"Include Prerelease\" packages with -pre from the command line or via the dropdown in the UI.\n\nBe sure to read the readme.txt that pops up as you'll need to ensure that the FriendlyUrls routing gets called on application startup! I added this one line to my Application_Start:\n\nHere's the cool part. If I hit one of my existing links, like Contact.aspx, look what happened. See how the GET request for /Contact.aspx turned into a 301 redirect to /Contact?\n\nIf you have a Web Form called /Foo.aspx, you automatically get a /Foo route and can call your page like that! Hence, Microsoft.AspNet.FriendlyUrls.\n\nJust by adding the one package and calling\n\nin RouteConfig (this default came down with the NuGet package) my whole WebForms app loses its .ASPX extensions and gets reasonable defaults.\n\nGet it? Ok, let's dig into some of the obvious next questions and some more advanced scenarios. How do I get values out of the URL? I'm used to Request.QueryString and Request.Form, but how do I get ahold of these URL segments?\n\nIf I click \"Click Me\" the URL points to .\n\nNOTE: Be aware of the magic. It makes sense. If there was a 34.aspx in a folder called Bar in a folder called Foo, we would have used that file. There wasn't. If there was a file called Bar.aspx in a folder called Foo we would have used that. There wasn't. So, we used Foo.aspx and passed in the rest of the URL.\n\nI can get the segments out like this:\n\nUPDATE: One thing I forgot to mention was how to get the values out of the FriendlyURL. You can use things like [Form] and [QueryString] to model bind in WebForms. Now you can add [FriendlyUrlSegments] to get data out, like the ID in this example:\n\nThey're sitting on the Request option. I did have to import the Microsoft.AspNet.FriendlyUrls namespace to have this extension appear.\n\nBetter yet, I can generate Friendly URLs without string concatenation!\n\nWhen you bring down the NuGet package you'll also get a Site.Mobile.Master. If I visit them with the Electric Plum Mobile Simulator (iPhone) I see a default mobile page, automatically.\n\nAh, you see where this is going. I'll copy Foo.aspx to Foo.Mobile.aspx. I'll make a small change. I'll visit /Foo/bar/34 again except now I get the mobile master and the mobile foo, automatically.\n\nWhat I want to support switching back and forth from Desktop to Mobile? Just add a ViewSwitcher control, also included.\n\nNow I re-render and I get a \"switch to mobile\" and switch to desktop.\n\nNow I can go back and forth between views and request a desktop site even when on mobile.\n\nSo basic mobile is nice but I might want very specific mobile views for iPhone, iPad, Opera Mobile, etc.\n\nBy default FriendlyUrls uses a class called WebFormsFriendlyUrlResolver but you can derive from this class and change its behavior however you like. Here's an example of a \"DeviceSpecificWebFormsFriendlyUrlResolver\" or, better yet, Mobile Friendly Urls for WebForms.\n\nThis derived URL resolver does just that, it resolves URLs to physical Web Forms pages. You'd then pass it into the overload of EnableFriendlyUrls(...);\n\nIMPORTANT NOTE: This code is just a very early sample, there will be a more complete one released later.\n\nNow we've created a map of device specific suffixes, so we can have not Foo.Mobile.aspx, but rather Foo.iPhone.aspx and Foo.OperaMobile.aspx, etc.\n\nHere's a little demo that loads a bunch of names into a list. Here's /async, the desktop view.\n\nNow we'll add jQuery mobile to the mobile master page, and use it on the mobile version of the same page. We're still calling the same data source and reusing all that code.\n\nI'm pretty jazzed about what this means for ASP.NET and Web Forms developers. We're going to continue to push forward and improve ASP.NET even now, after Visual Studio 2012 has been released. Sometimes we'll add small features via NuGet packages, sometimes editor improvements as free VSIX Extensions like the Web Essentials playground for 2012 and larger changes via released updates to all of ASP.NET. I hope you like the direction we're heading.\n\nGo play with Microsoft.AspNet.FriendlyUrls now and thank Damian and friends on Twitter!\n\nThis week's sponsor: Be part of GENERATION APP. Your Idea. Your App. 30 Days. Begin your 30-day journey to create a Windows Store style app and talk 1-on-1 with a Windows 8 app development pro. Get started today."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.web.routing.routecollection.mappageroute?view=netframework-4.8.1",
        "document": "The following example shows how to define routes for a Web Forms application by using this method. The example shows a method named that is called from in the Global.asax file. The method uses each overload of MapPageRoute to add a route to the application. For more information about how to define routes for Web Forms applications, see How to: Define Routes for Web Forms Applications.\n\nThis method is provided for coding convenience. It is equivalent to calling the Add method and passing a Route object that is created by using the PageRouteHandler class.\n\nProvides a way to define routes for Web Forms applications. Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String) As Route The URL pattern for the route. The physical URL for the route. The route that is added to the route collection. The following example shows how to define a route by using this method. The first statement defines a route that does not have a name. The second statement defines a named route. This example is part of a larger example that is available in the MapPageRoute method overview. This method is provided for coding convenience. It is equivalent to calling the Add method and passing a Route object that is created by using the PageRouteHandler class.\n\nProvides a way to define routes for Web Forms applications. Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean) As Route The URL pattern for the route. The physical URL for the route. A value that indicates whether ASP.NET should validate that the user has authority to access the physical URL (the route URL is always checked). This parameter sets the CheckPhysicalUrlAccess property. The route that is added to the route collection. The following example shows how to define a route by using this method. This example is part of a larger example that is available in the MapPageRoute method overview. This method is provided for coding convenience. It is equivalent to calling the Add method and passing a Route object that is created by using the PageRouteHandler class.\n\nProvides a way to define routes for Web Forms applications. Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean, defaults As RouteValueDictionary, constraints As RouteValueDictionary) As Route The URL pattern for the route. The physical URL for the route. A value that indicates whether ASP.NET should validate that the user has authority to access the physical URL (the route URL is always checked). This parameter sets the CheckPhysicalUrlAccess property. Constraints that a URL request must meet in order to be processed as this route. The route that is added to the route collection. The following example shows how to define a route by using this method. This example is part of a larger example that is available in the MapPageRoute method overview. routes.MapPageRoute(\"ExpenseCurrentYearRoute\", \"ExpenseReportCurrent/{locale}\", \"~/expenses.aspx\", false, new RouteValueDictionary { { \"locale\", \"US\" }, { \"year\", DateTime.Now.Year.ToString() } }, new RouteValueDictionary { { \"locale\", \"[a-z]{2}\" }, { \"year\", @\"\\d{4}\" } }); routes.MapPageRoute(\"ExpenseCurrentYearRoute\", \"ExpenseReportCurrent/{locale}\", \"~/expenses.aspx\", false, new RouteValueDictionary(New With _ { .locale = \"US\", .year = DateTime.Now.Year.ToString()}), new RouteValueDictionary(New With _ { .locale = \"[a-z]{2}\", .year = \"\\d{4}\" })) This method is provided for coding convenience. It is equivalent to calling the Add method and passing a Route object that is created by using the PageRouteHandler class.\n\nProvides a way to define routes for Web Forms applications. Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean, defaults As RouteValueDictionary, constraints As RouteValueDictionary, dataTokens As RouteValueDictionary) As Route The URL pattern for the route. The physical URL for the route. A value that indicates whether ASP.NET should validate that the user has authority to access the physical URL (the route URL is always checked). This parameter sets the CheckPhysicalUrlAccess property. Constraints that a URL request must meet in order to be processed as this route. Values that are associated with the route that are not used to determine whether a route matches a URL pattern. The route that is added to the route collection. The following example shows how to define a route by using this method. This example is part of a larger example that is available in the MapPageRoute method overview. routes.MapPageRoute(\"ExpenseDetailRoute\", \"ExpenseReportDetail/{locale}/{year}/{*queryvalues}\", \"~/expenses.aspx\", false, new RouteValueDictionary { { \"locale\", \"US\" }, { \"year\", DateTime.Now.Year.ToString() } }, new RouteValueDictionary { { \"locale\", \"[a-z]{2}\" }, { \"year\", @\"\\d{4}\" } }, new RouteValueDictionary { { \"account\", \"1234\" }, { \"subaccount\", \"5678\" } }); routes.MapPageRoute(\"ExpenseDetailRoute\", \"ExpenseReportDetail/{locale}/{year}/{*queryvalues}\", \"~/expenses.aspx\", false, new RouteValueDictionary(New With _ { .locale = \"US\", .year = DateTime.Now.Year.ToString()}), new RouteValueDictionary(New With _ { .locale = \"[a-z]{2}\", .year = \"\\d{4}\" }), new RouteValueDictionary(New With _ { .account = \"1234\", .subaccount = \"5678\" })) This method is provided for coding convenience. It is equivalent to calling the Add method and passing a Route object that is created by using the PageRouteHandler class."
    },
    {
        "link": "https://stackoverflow.com/questions/67050966/how-to-build-a-404-page-with-react-router-dom-v6",
        "document": "I just upgraded to v6beta for react-router-dom because I wanted to organize my routes, but the 404 page is now broken:\n\nSo everything works as expected (including the home page) except the not found page, which does not work even when adding or\n\nAny easy solution for this?"
    },
    {
        "link": "https://dhiwise.com/post/a-comprehensive-guide-to-fixing-react-router-refresh-404",
        "document": "A frontend innovator with 3+ years of crafting dynamic React experiences. Passionate about intuitive UI, performance optimization, and solving complex problems with elegant code. Probably refining micro-interactions while brainstorming the future of the web.\n\nWhen developing a react application, encountering a 404 error can be a common yet frustrating experience. This error often occurs when a user attempts to hit refresh on their browser while viewing a page served by a react router. The 404 error signifies that the requested url path does not exist on the server, leading to a page not found message. This is particularly perplexing in a single page application where client side routing is supposed to handle different paths.\n\nIn the above code snippet, a react route is defined using react router dom. If a user refreshes the browser while on the /about url, the server looks for a file at that path which doesn't exist, hence the 404 error.\n\nThe core issue arises from the difference between client side routing and traditional server-based routing. In a single page app, react router dynamically renders components without the browser making a new request to the server for each route. However, when a user hits refresh, the browser makes a direct request to the server using the current url, which may not correspond to any server-side file or route.\n\nIn this example, react router handles the routing within the browser, but the server is not configured to understand these routes.\n\nThe Role of React Router in a Single Page App\n\nClient side routing is a technique where the routing of a web application is handled internally by the javascript that runs on the browser. React router is a popular library that enables client side routing in react apps, allowing for smooth navigation between different views without a full page reload. This is essential in creating a single page application where all html content is dynamically loaded and swapped in the root component based on the url.\n\nThe Switch component renders the first route that matches the path. If no path matches, the NotFoundPage component is rendered, providing a simple solution for handling 404 errors.\n\nTo demonstrate how react router works within a function app, let's set up a basic react app with some routes. We'll use react router dom to create our routing logic and define a component for each route.\n\nIn this code, we have a function app that uses react router dom to define three routes: the home page, about page, and a catch-all route for handling 404 errors.\n\nDuring development, the webpack dev server can be configured to fallback to the index page whenever a 404 error occurs. This allows react router to handle any url that doesn't correspond to a static file in the public folder. The config file for the dev server can include a historyApiFallback setting to enable this behavior.\n\nWith this configuration, the webpack dev server will redirect all requests to the index.html page, allowing the react router to take over and manage the routing from there.\n\nHow to Handle 404 Page in React Router\n\nTo effectively manage 404 errors in a react app, you can implement a redirect to a custom 404 page using react router dom. This ensures that when a user navigates to a route that does not exist, they are presented with a user-friendly error page rather than a generic browser error message.\n\nIn this example, we use the Redirect component from react router dom to catch all unmatched routes and redirect the user to a custom 404 page.\n\nExample: Designing an HTML Page for 404 Errors\n\nCreating a custom 404 html page in your react application can provide a better user experience. This page can include links back to the home page or other pages, ensuring that users are not left at a dead end.\n\nThis simple solution for a NotFoundPage component can be styled with CSS and integrated into your react app to handle any incorrect paths.\n\nConfiguring the Server to Redirect and Serve the Index Page\n\nFor a react application in production, the server must be configured to handle routing for the react router. This typically involves setting up a catch all route on the server that will serve the index.html file for any request that does not match a static file or an api endpoint.\n\nIn this code snippet, an Express server is configured to serve the index.html file from the build folder for any GET request that does not match another route. This ensures that the react router can handle the routing on the client side, even after a page refresh.\n\nWhen deploying a react application to production, it's important to ensure that the build process generates a production build folder that includes an index.html file and all the necessary assets. The server should be set up to serve files from this build folder and to redirect any missing routes to the index.html file, allowing the react router to handle the routing.\n\nThis example shows an Express server configured to serve the static files from the build folder and to handle all other requests by serving the index.html file, which is the entry point for the react application.\n\nAnother approach to preventing 404 errors on refresh in a react router application is to use hash history. This technique relies on the URL hash to keep track of the user's position in the app. Since the hash is never sent to the server, refreshing the page won't cause a 404 error.\n\nUsing the HashRouter component from react router dom, the URL will include a hash (#) before the route's path, ensuring that the server only needs to handle the root URL and leaving the rest to the client side routing.\n\nBest practices for using react router include keeping your routes organized and intuitive for the user. Avoid deeply nested routes and complex patterns that can make navigation confusing. It's also important to ensure that your application handles redirects and private routes appropriately, providing feedback to the user whenever they attempt to access a restricted area.\n\nIn this example, the route checks if the user is authenticated before rendering the DashboardPage component. If not, it redirects the user to the login page. This pattern helps in maintaining a secure and user-friendly app.\n\nHow to Fix 404 Error in React JS and Ensure Routes Work Fine\n\nWhen facing a 404 error in a React JS application, there are several steps you can take to troubleshoot and resolve the issue. First, ensure that your server is correctly configured to handle client-side routing by redirecting all requests to the index.html file. Next, check your react router configuration for any incorrect paths or typos in your route definitions.\n\nIn this code snippet, a dynamic route is set up to handle user pages. If a 404 error occurs when accessing a user page, verify that the URL is correct and that the UserPage component exists and is exported properly.\n\nAdditionally, ensure that your webpack dev server or other development server is set up with the historyApiFallback option enabled to handle SPA routing during development.\n\nHow to Set Error Page in React Router DOM\n\nSetting up a NotFound page in React Router DOM is straightforward. You can create a dedicated component that will be displayed whenever the app encounters an undefined route. This component can then be included in your Switch statement as the last Route without a path, ensuring that it catches all undefined routes.\n\nThe NotFoundPage component will be rendered when no other routes match the current URL. It's a best practice to include a link or button on this page to redirect users back to a known route, like the home page, improving the overall user experience.\n\nRemember to test your routes thoroughly in both development and production environments to ensure that all paths lead to the correct components and that your 404 page behaves as expected. By following these guidelines and utilizing the provided code examples, you can effectively manage routing in your React applications, providing a seamless experience for your users even when they encounter a 404 error.\n\nShort on time? Speed things up with DhiWise!\n\nTired of manually designing screens, coding on weekends, and technical debt? Let DhiWise handle it for you!\n\nYou can build an e-commerce store, healthcare app, portfolio, blogging website, social media or admin panel right away. Use our library of 40+ pre-built free templates to create your first application using DhiWise."
    },
    {
        "link": "https://stackoverflow.com/questions/62047422/404-when-trying-to-enter-a-react-app-route",
        "document": "I just deployed my react app build on c-panel. The app includes different routes and everytime I try to get to one of them I get . For example if I try to get to it will enter the website, and if I'll press on a button which links me to it will work. But If I'll try to get from a link that I shared or just typing this address I'll get . This is not happening when I'm running the develope mode on localhost.\n\nI changed the homepage url - in package.json and it did not effect.\n\nMy app root is wrapped with\n\nAnd this is Main.js component which is maneuvered by the routes.\n\nCan someone give me a clue how to make those pages load when I enter them directly by their link?"
    },
    {
        "link": "https://medium.com/@leonardobrunolima/react-tips-handling-404-pages-24d27191a8dd",
        "document": "Handling 404 pages is very easy with react router. Let’s get started. First you need to create a new app, I will use create-react-app boilerplate.\n\nAfter that install the package react-router-dom and import some components at App.js file.\n\nOk, now we are going to use the same App.js file to create two components: Home and About.\n\nNow, let’s create some links and routes:\n\nAt this point we have something like this for Home component:\n\nAnd this for About component:\n\nNow let’s add another link to a unknown route:\n\nIf you click this link you will be showed a blank page, but the correct would be a 404 page right? So, let’s create another component called Page404:\n\nBut how do we render Page404? If we render a Route but don’t specify a path, that route will always be rendered, so we could show a new Route with no path that rendered Page404, right?\n\nNow, let’s refresh the page and see what we get:\n\nAs you can see, the route for component Page404 is always been rendered. To fix this, we need to use another component called Switch.\n\nImport it and use as parent of the routers:\n\nYou can clone this project here: https://github.com/lblima/react-router-404"
    },
    {
        "link": "https://hygraph.com/blog/routing-in-react",
        "document": "React is an open-source frontend JavaScript framework that allows developers to create user interfaces using UI components and single-page applications. Routing is one of the most important features we always want to implement when developing these applications.\n\nRouting redirects users to different pages based on their actions or requests. In React routing, you'll use an external library called React router, which can be challenging to configure if you need help understanding how it works.\n\nIn this article, we will show you how to perform routing in React using a React router. Learn the various routing aspects and how React router handles them, such as dynamic routing, programmatic navigation, no-matching routes, etc.\n\nTo fully comprehend and follow this guide, we would create an application that properly illustrates all aspects of navigation with appropriate use cases. We would create/use a cocktails app that retrieves data from Hygraph via GraphQL. This application, which can be accessed via this live link, uses all aspects of routing covered in this guide.\n\nYou should have the following to follow along with this guide and code:\n• Some experience or knowledge of React\n• Node and npm or yarn installed on your machine\n\nAs previously stated, React makes use of an external library to handle routing; however, before we can implement routing with that library, we must first install it in our project, which is accomplished by running the following command in your terminal (within your project directory):\n\nAfter successfully installing the package, we can set up and configure the React router for our project.\n\nTo configure React router, navigate to the file, which is the root file, and import from the package that we installed, wrapping it around our App component as follows:\n\n# How to configure routes in React\n\nWe have now successfully installed and imported React router into our project; the next step is to use React router to implement routing. The first step is configuring all of our routes (all the pages/components we want to navigate).\n\nWe would first create those components, in our case, three pages: the Home page, the About Page, and the Products Page. This GitHub repository contains the content for these pages. Once those pages are properly configured, we can now set up and configure our routes in the file, which serves as the foundation for our React application:\n\nWe can see in the above code that we imported and components from and then used them to declare the routes we want. All Routes are wrapped in the tag, and these Routes have two major properties:\n• None : As the name implies, this identifies the path we want users to take to reach the set component. When we set the to , for example, when the user adds to the URL link, it navigates to that page.\n• None : This contains the component that we want the set path to load. This is simple to understand, but remember to import any components we are using here, or else an error will occur.\n\nWhen we go to our browser and try to navigate via the URL, it will load whatever content we have on such pages.\n\nLet us now create a standard Navigation bar component that can be used to navigate inside our application.\n\nThe component from react-router-dom is a special component that helps you navigate different routes using the prop. component also knows whether the route is currently \"active\" and adds a default class to the link. We can use this class in our CSS to define some styling for active links, as shown below:\n\nAlso, we can assign our custom classes instead of using the default active class. The NavLink component gives us access to properties like isActive, which can be used like this.\n\nFinally, let us use the Navbar component inside our App.\n\nHow to fix No Routes Found Error\n\nWhen routing, a situation may cause a user to access an unconfigured route or a route that does not exist; when this occurs, React does not display anything on the screen except a warning with the message \"No routes matched location.\"\n\nThis can be fixed by configuring a new route to return a specific component when a user navigates to an unconfigured route as follows:\n\nIn the preceding code, we created a route with the path to get all non-configured paths and assign them to the attached component.\n\n# How to navigate programmatically in React\n\nProgrammatic navigation is the process of navigating/redirecting a user as a result of an action on a route, such as a login or a signup action, order success, or when he clicks on a back button.\n\nLet's first look at how we can redirect to a page when an action occurs, such as when a button is clicked. We accomplish this by adding an event, but first, we must create the route in our file. After that, we can import the hook from the and use it to navigate programmatically as follows:\n\nEnsure you already have the hook imported and instantiated as we did earlier else this won’t work.\n\n# How to implement dynamic routing with React router\n\nWe created three files in our pages folder earlier to implement routing, one of which was the products component, which we will populate with Hygraph content. We created a schema in Hygraph to receive cocktail details, and this is how it looks:\n\nWe then filled it in with cocktail specifics. We will now use GraphQL to retrieve these data so that we can consume them in our React project. This is how the products page appears:We fetched our content from Hygraph in the preceding code; if you already created your own schema, you can simply change the Endpoint URL and possibly the schema name if you gave it a different name.\n\nWe added a and used string interpolation to dynamically attach the of each product to the path, so we can get the and use it to get the data to show.\n\nLet us now put dynamic routing into action.\n\nThe first step would be to create the component that we want to render dynamically, and for that we would create a file where we would dynamically fetch details of each product based on the passed through the URL, but for now we can just place dummy data into the component like this:\n\nWe can now proceed to create a route to handle dynamic routing in our file this way:\n\nSo far, we've dealt with the first part of dynamic routing. We must now obtain the parameter passed through the URL in order to dynamically query the data for the specific cocktail. This will be accomplished through the use of .\n\nHow to use URL params to handle dynamic routing\n\nWe will import the hook into the component so that we can use it to get the URL parameter and then use that parameter to query our data from Hygraph via GraphQL.\n\nAt this point, we have successfully been able to get the URL param passed, let’s now make use of this slug to fetch data from Hygraph using GraphQL:\n\n# How to implement lazy loading with React router\n\nAt this point, we have successfully implemented dynamic routing.\n\nWe've already seen how to create routes and implement routing with React router; now let's look at how to lazy load routes with React router.\n\nLazy loading is a technique in which components that are not required on the home page are not loaded until a user navigates to that page, allowing our application to load faster than having to wait for the entire app to load at once. This contributes to improved performance, which leads to a positive user experience.\n\nTo implement lazy loading, simply go to and wrap our routes with the component, along with a props that are rendered on the screen until the component loads:\n\nWe learned about routing and how to implement it in our React application in this guide. It is critical to understand that the React router is what allows us to perform single-page routing without reloading the application."
    }
]