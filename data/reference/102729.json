[
    {
        "link": "https://docs.djangoproject.com/en/5.1/topics/db",
        "document": "A model is the single, definitive source of information about your data. It contains the essential fields and behaviors of the data you’re storing. Generally, each model maps to a single database table."
    },
    {
        "link": "https://docs.djangoproject.com/en/5.1/topics/db/models",
        "document": "A model is the single, definitive source of information about your data. It contains the essential fields and behaviors of the data you’re storing. Generally, each model maps to a single database table.\n• None Each model is a Python class that subclasses .\n• None Each attribute of the model represents a database field.\n• None With all of this, Django gives you an automatically-generated database-access API; see Making queries.\n\nDefine custom methods on a model to add custom “row-level” functionality to your objects. Whereas methods are intended to do “table-wide” things, model methods should act on a particular model instance. This is a valuable technique for keeping business logic in one place – the model. For example, this model has a few custom methods: The last method in this example is a property. The model instance reference has a complete list of methods automatically given to each model. You can override most of these – see overriding predefined model methods, below – but there are a couple that you’ll almost always want to define: A Python “magic method” that returns a string representation of any object. This is what Python and Django will use whenever a model instance needs to be coerced and displayed as a plain string. Most notably, this happens when you display an object in an interactive console or in the admin. You’ll always want to define this method; the default isn’t very helpful at all. This tells Django how to calculate the URL for an object. Django uses this in its admin interface, and any time it needs to figure out a URL for an object. Any object that has a URL that uniquely identifies it should define this method. There’s another set of model methods that encapsulate a bunch of database behavior that you’ll want to customize. In particular you’ll often want to change the way and work. You’re free to override these methods (and any other model method) to alter behavior. A classic use-case for overriding the built-in methods is if you want something to happen whenever you save an object. For example (see for documentation of the parameters it accepts): You can also prevent saving: # Yoko shall never have her own blog! It’s important to remember to call the superclass method – that’s that business – to ensure that the object still gets saved into the database. If you forget to call the superclass method, the default behavior won’t happen and the database won’t get touched. It’s also important that you pass through the arguments that can be passed to the model method – that’s what the bit does. Django will, from time to time, extend the capabilities of built-in model methods, adding new keyword arguments. If you use in your method definitions, you are guaranteed that your code will automatically support those arguments when they are added. If you wish to update a field value in the method, you may also want to have this field added to the keyword argument. This will ensure the field is saved when is specified. For example: See Specifying which fields to save for more details. Overridden model methods are not called on bulk operations Note that the method for an object is not necessarily called when deleting objects in bulk using a QuerySet or as a result of a . To ensure customized delete logic gets executed, you can use and/or signals. Unfortunately, there isn’t a workaround when or objects in bulk, since none of , , and are called. Another common pattern is writing custom SQL statements in model methods and module-level methods. For more details on using raw SQL, see the documentation on using raw SQL.\n\nModel inheritance in Django works almost identically to the way normal class inheritance works in Python, but the basics at the beginning of the page should still be followed. That means the base class should subclass . The only decision you have to make is whether you want the parent models to be models in their own right (with their own database tables), or if the parents are just holders of common information that will only be visible through the child models. There are three styles of inheritance that are possible in Django.\n• None Often, you will just want to use the parent class to hold information that you don’t want to have to type out for each child model. This class isn’t going to ever be used in isolation, so Abstract base classes are what you’re after.\n• None If you’re subclassing an existing model (perhaps something from another application entirely) and want each model to have its own database table, Multi-table inheritance is the way to go.\n• None Finally, if you only want to modify the Python-level behavior of a model, without changing the models fields in any way, you can use Proxy models. Abstract base classes are useful when you want to put some common information into a number of other models. You write your base class and put in the Meta class. This model will then not be used to create any database table. Instead, when it is used as a base class for other models, its fields will be added to those of the child class. The model will have three fields: , and . The model cannot be used as a normal Django model, since it is an abstract base class. It does not generate a database table or have a manager, and cannot be instantiated or saved directly. Fields inherited from abstract base classes can be overridden with another field or value, or be removed with . For many uses, this type of model inheritance will be exactly what you want. It provides a way to factor out common information at the Python level, while still only creating one database table per child model at the database level. When an abstract base class is created, Django makes any Meta inner class you declared in the base class available as an attribute. If a child class does not declare its own Meta class, it will inherit the parent’s Meta. If the child wants to extend the parent’s Meta class, it can subclass it. For example: Django does make one adjustment to the Meta class of an abstract base class: before installing the Meta attribute, it sets . This means that children of abstract base classes don’t automatically become abstract classes themselves. To make an abstract base class that inherits from another abstract base class, you need to explicitly set on the child. Some attributes won’t make sense to include in the Meta class of an abstract base class. For example, including would mean that all the child classes (the ones that don’t specify their own Meta) would use the same database table, which is almost certainly not what you want. Due to the way Python inheritance works, if a child class inherits from multiple abstract base classes, only the Meta options from the first listed class will be inherited by default. To inherit Meta options from multiple abstract base classes, you must explicitly declare the Meta inheritance. For example: Be careful with and ¶ If you are using or on a or , you must always specify a unique reverse name and query name for the field. This would normally cause a problem in abstract base classes, since the fields on this class are included into each of the child classes, with exactly the same values for the attributes (including and ) each time. To work around this problem, when you are using or in an abstract base class (only), part of the value should contain and .\n• None is replaced by the lowercased name of the child class that the field is used in.\n• None is replaced by the lowercased name of the app the child class is contained within. Each installed application name must be unique and the model class names within each app must also be unique, therefore the resulting name will end up being different. For example, given an app : Along with another app : The reverse name of the field will be and the reverse query name will be . The reverse name of the field will be and the reverse query name will be . Finally, the reverse name of the field will be and the reverse query name will be . It’s up to you how you use the and portion to construct your related name or related query name but if you forget to use it, Django will raise errors when you perform system checks (or run ). If you don’t specify a attribute for a field in an abstract base class, the default reverse name will be the name of the child class followed by , just as it normally would be if you’d declared the field directly on the child class. For example, in the above code, if the attribute was omitted, the reverse name for the field would be in the case and for the field. The second type of model inheritance supported by Django is when each model in the hierarchy is a model all by itself. Each model corresponds to its own database table and can be queried and created individually. The inheritance relationship introduces links between the child model and each of its parents (via an automatically-created ). For example: All of the fields of will also be available in , although the data will reside in a different database table. So these are both possible: If you have a that is also a , you can get from the object to the object by using the lowercase version of the model name: # If p is a Restaurant object, this will give the child class: However, if in the above example was not a (it had been created directly as a object or was the parent of some other class), referring to would raise a exception. The automatically-created on that links it to looks like this: You can override that field by declaring your own with on . In the multi-table inheritance situation, it doesn’t make sense for a child class to inherit from its parent’s Meta class. All the Meta options have already been applied to the parent class and applying them again would normally only lead to contradictory behavior (this is in contrast with the abstract base class case, where the base class doesn’t exist in its own right). So a child model does not have access to its parent’s Meta class. However, there are a few limited cases where the child inherits behavior from the parent: if the child does not specify an attribute or a attribute, it will inherit these from its parent. If the parent has an ordering and you don’t want the child to have any natural ordering, you can explicitly disable it: Because multi-table inheritance uses an implicit to link the child and the parent, it’s possible to move from the parent down to the child, as in the above example. However, this uses up the name that is the default value for and relations. If you are putting those types of relations on a subclass of the parent model, you must specify the attribute on each such field. If you forget, Django will raise a validation error. For example, using the above class again, let’s create another subclass with a : This results in the error: Reverse query name for 'Supplier.customers' clashes with reverse query HINT: Add or change a related_name argument to the definition for Adding to the field as follows would resolve the error: . As mentioned, Django will automatically create a linking your child class back to any non-abstract parent models. If you want to control the name of the attribute linking back to the parent, you can create your own and set to indicate that your field is the link back to the parent class. When using multi-table inheritance, a new database table is created for each subclass of a model. This is usually the desired behavior, since the subclass needs a place to store any additional data fields that are not present on the base class. Sometimes, however, you only want to change the Python behavior of a model – perhaps to change the default manager, or add a new method. This is what proxy model inheritance is for: creating a proxy for the original model. You can create, delete and update instances of the proxy model and all the data will be saved as if you were using the original (non-proxied) model. The difference is that you can change things like the default model ordering or the default manager in the proxy, without having to alter the original. Proxy models are declared like normal models. You tell Django that it’s a proxy model by setting the attribute of the class to . For example, suppose you want to add a method to the model. You can do it like this: The class operates on the same database table as its parent class. In particular, any new instances of will also be accessible through , and vice-versa: You could also use a proxy model to define a different default ordering on a model. You might not always want to order the model, but regularly order by the attribute when you use the proxy: Now normal queries will be unordered and queries will be ordered by . Proxy models inherit attributes in the same way as regular models. s still return the model that was requested¶ There is no way to have Django return, say, a object whenever you query for objects. A queryset for objects will return those types of objects. The whole point of proxy objects is that code relying on the original will use those and your own code can use the extensions you included (that no other code is relying on anyway). It is not a way to replace the (or any other) model everywhere with something of your own creation. A proxy model must inherit from exactly one non-abstract model class. You can’t inherit from multiple non-abstract models as the proxy model doesn’t provide any connection between the rows in the different database tables. A proxy model can inherit from any number of abstract model classes, providing they do not define any model fields. A proxy model may also inherit from any number of proxy models that share a common non-abstract parent class. If you don’t specify any model managers on a proxy model, it inherits the managers from its model parents. If you define a manager on the proxy model, it will become the default, although any managers defined on the parent classes will still be available. Continuing our example from above, you could change the default manager used when you query the model like this: If you wanted to add a new manager to the Proxy, without replacing the existing default, you can use the techniques described in the custom manager documentation: create a base class containing the new managers and inherit that after the primary base class: # Create an abstract class for the new manager. You probably won’t need to do this very often, but, when you do, it’s possible. Proxy model inheritance might look fairly similar to creating an unmanaged model, using the attribute on a model’s class. With careful setting of you could create an unmanaged model that shadows an existing model and adds Python methods to it. However, that would be very repetitive and fragile as you need to keep both copies synchronized if you make any changes. On the other hand, proxy models are intended to behave exactly like the model they are proxying for. They are always in sync with the parent model since they directly inherit its fields and managers.\n• None If you are mirroring an existing model or database table and don’t want all the original database table columns, use . That option is normally useful for modeling database views and tables not under the control of Django.\n• None If you are wanting to change the Python-only behavior of a model, but keep all the same fields as in the original, use . This sets things up so that the proxy model is an exact copy of the storage structure of the original model when data is saved. Just as with Python’s subclassing, it’s possible for a Django model to inherit from multiple parent models. Keep in mind that normal Python name resolution rules apply. The first base class that a particular name (e.g. Meta) appears in will be the one that is used; for example, this means that if multiple parents contain a Meta class, only the first one is going to be used, and all others will be ignored. Generally, you won’t need to inherit from multiple parents. The main use-case where this is useful is for “mix-in” classes: adding a particular extra field or method to every class that inherits the mix-in. Try to keep your inheritance hierarchies as simple and straightforward as possible so that you won’t have to struggle to work out where a particular piece of information is coming from. Note that inheriting from multiple models that have a common primary key field will raise an error. To properly use multiple inheritance, you can use an explicit in the base models: Or use a common ancestor to hold the . This requires using an explicit from each parent model to the common ancestor to avoid a clash between the fields that are automatically generated and inherited by the child: Field name “hiding” is not permitted¶ In normal Python class inheritance, it is permissible for a child class to override any attribute from the parent class. In Django, this isn’t usually permitted for model fields. If a non-abstract model base class has a field called , you can’t create another model field or define an attribute called in any class that inherits from that base class. This restriction doesn’t apply to model fields inherited from an abstract model. Such fields may be overridden with another field or value, or be removed by setting . Model managers are inherited from abstract base classes. Overriding an inherited field which is referenced by an inherited may cause subtle bugs. See custom managers and model inheritance. Some fields define extra attributes on the model, e.g. a defines an extra attribute with appended to the field name, as well as and on the foreign model. These extra attributes cannot be overridden unless the field that defines it is changed or removed so that it no longer defines the extra attribute. Overriding fields in a parent model leads to difficulties in areas such as initializing new instances (specifying which field is being initialized in ) and serialization. These are features which normal Python class inheritance doesn’t have to deal with in quite the same way, so the difference between Django model inheritance and Python class inheritance isn’t arbitrary. This restriction only applies to attributes which are instances. Normal Python attributes can be overridden if you wish. It also only applies to the name of the attribute as Python sees it: if you are manually specifying the database column name, you can have the same column name appearing in both a child and an ancestor model for multi-table inheritance (they are columns in two different database tables). Django will raise a if you override any model field in any ancestor model. Note that because of the way fields are resolved during class definition, model fields inherited from multiple abstract parent models are resolved in a strict depth-first order. This contrasts with standard Python MRO, which is resolved breadth-first in cases of diamond shaped inheritance. This difference only affects complex model hierarchies, which (as per the advice above) you should try to avoid."
    },
    {
        "link": "https://docs.djangoproject.com/en/5.1/intro/tutorial02",
        "document": "This tutorial begins where Tutorial 1 left off. We’ll set up the database, create your first model, and get a quick introduction to Django’s automatically-generated admin site.\n\nNow, open up . It’s a normal Python module with module-level variables representing Django settings. By default, the configuration uses SQLite. If you’re new to databases, or you’re just interested in trying Django, this is the easiest choice. SQLite is included in Python, so you won’t need to install anything else to support your database. When starting your first real project, however, you may want to use a more scalable database like PostgreSQL, to avoid database-switching headaches down the road. If you wish to use another database, see details to customize and get your database running. While you’re editing , set to your time zone. Also, note the setting at the top of the file. That holds the names of all Django applications that are activated in this Django instance. Apps can be used in multiple projects, and you can package and distribute them for use by others in their projects. By default, contains the following apps, all of which come with Django:\n• None – The admin site. You’ll use it shortly. These applications are included by default as a convenience for the common case. Some of these applications make use of at least one database table, though, so we need to create the tables in the database before we can use them. To do that, run the following command: The command looks at the setting and creates any necessary database tables according to the database settings in your file and the database migrations shipped with the app (we’ll cover those later). You’ll see a message for each migration it applies. If you’re interested, run the command-line client for your database and type (PostgreSQL), (MariaDB, MySQL), (SQLite), or (Oracle) to display the tables Django created. Like we said above, the default applications are included for the common case, but not everybody needs them. If you don’t need any or all of them, feel free to comment-out or delete the appropriate line(s) from before running . The command will only run migrations for apps in .\n\nNow we’ll define your models – essentially, your database layout, with additional metadata. A model is the single, definitive source of information about your data. It contains the essential fields and behaviors of the data you’re storing. Django follows the DRY Principle. The goal is to define your data model in one place and automatically derive things from it. This includes the migrations - unlike in Ruby On Rails, for example, migrations are entirely derived from your models file, and are essentially a history that Django can roll through to update your database schema to match your current models. In our poll app, we’ll create two models: and . A has a question and a publication date. A has two fields: the text of the choice and a vote tally. Each is associated with a . These concepts are represented by Python classes. Edit the file so it looks like this: Here, each model is represented by a class that subclasses . Each model has a number of class variables, each of which represents a database field in the model. Each field is represented by an instance of a class – e.g., for character fields and for datetimes. This tells Django what type of data each field holds. The name of each instance (e.g. or ) is the field’s name, in machine-friendly format. You’ll use this value in your Python code, and your database will use it as the column name. You can use an optional first positional argument to a to designate a human-readable name. That’s used in a couple of introspective parts of Django, and it doubles as documentation. If this field isn’t provided, Django will use the machine-readable name. In this example, we’ve only defined a human-readable name for . For all other fields in this model, the field’s machine-readable name will suffice as its human-readable name. Some classes have required arguments. , for example, requires that you give it a . That’s used not only in the database schema, but in validation, as we’ll soon see. A can also have various optional arguments; in this case, we’ve set the value of to 0. Finally, note a relationship is defined, using . That tells Django each is related to a single . Django supports all the common database relationships: many-to-one, many-to-many, and one-to-one.\n\nThat small bit of model code gives Django a lot of information. With it, Django is able to: But first we need to tell our project that the app is installed. Django apps are “pluggable”: You can use an app in multiple projects, and you can distribute apps, because they don’t have to be tied to a given Django installation. To include the app in our project, we need to add a reference to its configuration class in the setting. The class is in the file, so its dotted path is . Edit the file and add that dotted path to the setting. It’ll look like this: Now Django knows to include the app. Let’s run another command: You should see something similar to the following: By running , you’re telling Django that you’ve made some changes to your models (in this case, you’ve made new ones) and that you’d like the changes to be stored as a migration. Migrations are how Django stores changes to your models (and thus your database schema) - they’re files on disk. You can read the migration for your new model if you like; it’s the file . Don’t worry, you’re not expected to read them every time Django makes one, but they’re designed to be human-editable in case you want to manually tweak how Django changes things. There’s a command that will run the migrations for you and manage your database schema automatically - that’s called , and we’ll come to it in a moment - but first, let’s see what SQL that migration would run. The command takes migration names and returns their SQL: You should see something similar to the following (we’ve reformatted it for readability):\n• None The exact output will vary depending on the database you are using. The example above is generated for PostgreSQL.\n• None Table names are automatically generated by combining the name of the app ( ) and the lowercase name of the model – and . (You can override this behavior.)\n• None Primary keys (IDs) are added automatically. (You can override this, too.)\n• None By convention, Django appends to the foreign key field name. (Yes, you can override this, as well.)\n• None The foreign key relationship is made explicit by a constraint. Don’t worry about the parts; it’s telling PostgreSQL to not enforce the foreign key until the end of the transaction.\n• None It’s tailored to the database you’re using, so database-specific field types such as (MySQL), (PostgreSQL), or (SQLite) are handled for you automatically. Same goes for the quoting of field names – e.g., using double quotes or single quotes.\n• None The command doesn’t actually run the migration on your database - instead, it prints it to the screen so that you can see what SQL Django thinks is required. It’s useful for checking what Django is going to do or if you have database administrators who require SQL scripts for changes. If you’re interested, you can also run ; this checks for any problems in your project without making migrations or touching the database. Now, run again to create those model tables in your database: The command takes all the migrations that haven’t been applied (Django tracks which ones are applied using a special table in your database called ) and runs them against your database - essentially, synchronizing the changes you made to your models with the schema in the database. Migrations are very powerful and let you change your models over time, as you develop your project, without the need to delete your database or tables and make new ones - it specializes in upgrading your database live, without losing data. We’ll cover them in more depth in a later part of the tutorial, but for now, remember the three-step guide to making model changes:\n• None Run to create migrations for those changes\n• None Run to apply those changes to the database. The reason that there are separate commands to make and apply migrations is because you’ll commit migrations to your version control system and ship them with your app; they not only make your development easier, they’re also usable by other developers and in production. Read the django-admin documentation for full information on what the utility can do.\n\nNow, let’s hop into the interactive Python shell and play around with the free API Django gives you. To invoke the Python shell, use this command: We’re using this instead of simply typing “python”, because sets the environment variable, which gives Django the Python import path to your file. Once you’re in the shell, explore the database API: # Import the model classes we just wrote. # No questions are in the system yet. # Support for time zones is enabled in the default settings file, so # Django expects a datetime with tzinfo for pub_date. Use timezone.now() # instead of datetime.datetime.now() and it will do the right thing. # Save the object into the database. You have to call save() explicitly. # Change values by changing the attributes, then calling save(). # objects.all() displays all the questions in the database. Wait a minute. isn’t a helpful representation of this object. Let’s fix that by editing the model (in the file) and adding a method to both and : It’s important to add methods to your models, not only for your own convenience when dealing with the interactive prompt, but also because objects’ representations are used throughout Django’s automatically-generated admin. Let’s also add a custom method to this model: Note the addition of and , to reference Python’s standard module and Django’s time-zone-related utilities in , respectively. If you aren’t familiar with time zone handling in Python, you can learn more in the time zone support docs. Save these changes and start a new Python interactive shell by running again: # Django provides a rich database lookup API that's entirely driven by # Get the question that was published this year. # Request an ID that doesn't exist, this will raise an exception. : # Lookup by a primary key is the most common case, so Django provides a # The following is identical to Question.objects.get(id=1). # Give the Question a couple of Choices. The create call constructs a new # Choice object, does the INSERT statement, adds the choice to the set # of available choices and returns the new Choice object. Django creates # a set (defined as \"choice_set\") to hold the \"other side\" of a ForeignKey # relation (e.g. a question's choice) which can be accessed via the API. # Display any choices from the related object set -- none so far. # Choice objects have API access to their related Question objects. # And vice versa: Question objects get access to Choice objects. <QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]> # The API automatically follows relationships as far as you need. # This works as many levels deep as you want; there's no limit. # Find all Choices for any question whose pub_date is in this year # (reusing the 'current_year' variable we created above). <QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]> # Let's delete one of the choices. Use delete() for that. For more information on model relations, see Accessing related objects. For more on how to use double underscores to perform field lookups via the API, see Field lookups. For full details on the database API, see our Database API reference.\n\nGenerating admin sites for your staff or clients to add, change, and delete content is tedious work that doesn’t require much creativity. For that reason, Django entirely automates creation of admin interfaces for models. Django was written in a newsroom environment, with a very clear separation between “content publishers” and the “public” site. Site managers use the system to add news stories, events, sports scores, etc., and that content is displayed on the public site. Django solves the problem of creating a unified interface for site administrators to edit content. The admin isn’t intended to be used by site visitors. It’s for site managers. First we’ll need to create a user who can login to the admin site. Run the following command: You will then be prompted for your desired email address: The final step is to enter your password. You will be asked to enter your password twice, the second time as a confirmation of the first. The Django admin site is activated by default. Let’s start the development server and explore it. If the server is not running start it like so: Now, open a web browser and go to “/admin/” on your local domain – e.g., http://127.0.0.1:8000/admin/. You should see the admin’s login screen: Since translation is turned on by default, if you set , the login screen will be displayed in the given language (if Django has appropriate translations). Now, try logging in with the superuser account you created in the previous step. You should see the Django admin index page: You should see a few types of editable content: groups and users. They are provided by , the authentication framework shipped by Django. Make the poll app modifiable in the admin¶ But where’s our poll app? It’s not displayed on the admin index page. Only one more thing to do: we need to tell the admin that objects have an admin interface. To do this, open the file, and edit it to look like this: Now that we’ve registered , Django knows that it should be displayed on the admin index page: Click “Questions”. Now you’re at the “change list” page for questions. This page displays all the questions in the database and lets you choose one to change it. There’s the “What’s up?” question we created earlier: Click the “What’s up?” question to edit it:\n• None The form is automatically generated from the model.\n• None The different model field types ( , ) correspond to the appropriate HTML input widget. Each type of field knows how to display itself in the Django admin.\n• None Each gets free JavaScript shortcuts. Dates get a “Today” shortcut and calendar popup, and times get a “Now” shortcut and a convenient popup that lists commonly entered times. The bottom part of the page gives you a couple of options:\n• None Save – Saves changes and returns to the change-list page for this type of object.\n• None Save and continue editing – Saves changes and reloads the admin page for this object.\n• None Save and add another – Saves changes and loads a new, blank form for this type of object. If the value of “Date published” doesn’t match the time when you created the question in Tutorial 1, it probably means you forgot to set the correct value for the setting. Change it, reload the page and check that the correct value appears. Change the “Date published” by clicking the “Today” and “Now” shortcuts. Then click “Save and continue editing.” Then click “History” in the upper right. You’ll see a page listing all changes made to this object via the Django admin, with the timestamp and username of the person who made the change: When you’re comfortable with the models API and have familiarized yourself with the admin site, read part 3 of this tutorial to learn about how to add more views to our polls app."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Server-side/Django/Models",
        "document": "Before you jump in and start coding the models, it's worth taking a few minutes to think about what data we need to store and the relationships between the different objects. We know that we need to store information about books (title, summary, author, written language, category, ISBN) and that we might have multiple copies available (with globally unique id, availability status, etc.). We might need to store more information about the author than just their name, and there might be multiple authors with the same or similar names. We want to be able to sort information based on book title, author, written language, and category. When designing your models, it makes sense to have separate models for every \"object\" (a group of related information). In this case, the obvious objects are books, book instances, and authors. You might also want to use models to represent selection-list options (e.g. like a drop down list of choices), rather than hard coding the choices into the website itself — this is recommended when all the options aren't known up front or may change. Obvious candidates for models, in this case, include the book genre (e.g. Science Fiction, French Poetry, etc.) and language (English, French, Japanese). Once we've decided on our models and field, we need to think about the relationships. Django allows you to define relationships that are one to one ( ), one to many ( ) and many to many ( ). With that in mind, the UML association diagram below shows the models we'll define in this case (as boxes). We've created models for the book (the generic details of the book), book instance (status of specific physical copies of the book available in the system), and author. We have also decided to have a model for the genre so that values can be created/selected through the admin interface. We've decided not to have a model for the — we've hardcoded the values ( ) because we don't expect these to change. Within each of the boxes, you can see the model name, the field names, and types, and also the methods and their return types. The diagram also shows the relationships between the models, including their multiplicities. The multiplicities are the numbers on the diagram showing the numbers (maximum and minimum) of each model that may be present in the relationship. For example, the connecting line between the boxes shows that Book and a Genre are related. The numbers close to the Genre model show that a book must have one or more Genres (as many as you like), while the numbers on the other end of the line next to the Book model show that a Genre can have zero or many associated books. Note: The next section provides a basic primer explaining how models are defined and used. As you read it, consider how we will construct each of the models in the diagram above.\n\nModels are usually defined in an application's models.py file. They are implemented as subclasses of , and can include fields, methods and metadata. The code fragment below shows a \"typical\" model, named : from django.db import models from django.urls import reverse class MyModelName(models.Model): \"\"\"A typical class defining a model, derived from the Model class.\"\"\" # Fields my_field_name = models.CharField(max_length=20, help_text='Enter field documentation') # … # Metadata class Meta: ordering = ['-my_field_name'] # Methods def get_absolute_url(self): \"\"\"Returns the URL to access a particular instance of MyModelName.\"\"\" return reverse('model-detail-view', args=[str(self.id)]) def __str__(self): \"\"\"String for representing the MyModelName object (in Admin site etc.).\"\"\" return self.my_field_name In the below sections we'll explore each of the features inside the model in detail: A model can have an arbitrary number of fields, of any type — each one represents a column of data that we want to store in one of our database tables. Each database record (row) will consist of one of each field value. Let's look at the example seen below: Our above example has a single field called , of type — which means that this field will contain strings of alphanumeric characters. The field types are assigned using specific classes, which determine the type of record that is used to store the data in the database, along with validation criteria to be used when values are received from an HTML form (i.e. what constitutes a valid value). The field types can also take arguments that further specify how the field is stored or can be used. In this case we are giving our field two arguments:\n• — States that the maximum length of a value in this field is 20 characters.\n• — helpful text that may be displayed in a form to help users understand how the field is used. The field name is used to refer to it in queries and templates. Fields also have a label, which is specified using the argument (with a default value of ). If is not set, the label is created from the field name by replacing any underscores with a space, and capitalizing the first letter (for example, the field would have a default label of My field name when used in forms). The order that fields are declared will affect their default order if a model is rendered in a form (e.g. in the Admin site), though this may be overridden. The following common arguments can be used when declaring many/most of the different field types:\n• help_text: Provides a text label for HTML forms (e.g. in the admin site), as described above.\n• verbose_name: A human-readable name for the field used in field labels. If not specified, Django will infer the default verbose name from the field name.\n• default: The default value for the field. This can be a value or a callable object, in which case the object will be called every time a new record is created.\n• null: If , Django will store blank values as in the database for fields where this is appropriate (a will instead store an empty string). The default is .\n• blank: If , the field is allowed to be blank in your forms. The default is , which means that Django's form validation will force you to enter a value. This is often used with , because if you're going to allow blank values, you also want the database to be able to represent them appropriately.\n• choices: A group of choices for this field. If this is provided, the default corresponding form widget will be a select box with these choices instead of the standard text field.\n• unique: If , ensures that the field value is unique across the database. This can be used to prevent duplication of fields that can't have the same values. The default is .\n• primary_key: If , sets the current field as the primary key for the model (A primary key is a special database column designated to uniquely identify all the different table records). If no field is specified as the primary key, Django will automatically add a field for this purpose. The type of auto-created primary key fields can be specified for each app in or globally in the setting. Note: Apps created using manage.py set the type of the primary key to a BigAutoField. You can see this in the local library catalog/apps.py file: There are many other options — you can view the full list of field options here. The following list describes some of the more commonly used types of fields.\n• CharField is used to define short-to-mid sized fixed-length strings. You must specify the of the data to be stored.\n• TextField is used for large arbitrary-length strings. You may specify a for the field, but this is used only when the field is displayed in forms (it is not enforced at the database level).\n• IntegerField is a field for storing integer (whole number) values, and for validating entered values as integers in forms.\n• DateField and DateTimeField are used for storing/representing dates and date/time information (as Python and objects, respectively). These fields can additionally declare the (mutually exclusive) parameters (to set the field to the current date every time the model is saved), (to only set the date when the model is first created), and (to set a default date that can be overridden by the user).\n• EmailField is used to store and validate email addresses.\n• FileField and ImageField are used to upload files and images respectively (the adds additional validation that the uploaded file is an image). These have parameters to define how and where the uploaded files are stored.\n• AutoField is a special type of that automatically increments. A primary key of this type is automatically added to your model if you don't explicitly specify one.\n• ForeignKey is used to specify a one-to-many relationship to another database model (e.g. a car has one manufacturer, but a manufacturer can make many cars). The \"one\" side of the relationship is the model that contains the \"key\" (models containing a \"foreign key\" referring to that \"key\", are on the \"many\" side of such a relationship).\n• ManyToManyField is used to specify a many-to-many relationship (e.g. a book can have several genres, and each genre can contain several books). In our library app we will use these very similarly to , but they can be used in more complicated ways to describe the relationships between groups. These have the parameter to define what happens when the associated record is deleted (e.g. a value of would set the value to ). There are many other types of fields, including fields for different types of numbers (big integers, small integers, floats), booleans, URLs, slugs, unique ids, and other \"time-related\" information (duration, time, etc.). You can view the full list here. You can declare model-level metadata for your Model by declaring , as shown. One of the most useful features of this metadata is to control the default ordering of records returned when you query the model type. You do this by specifying the match order in a list of field names to the attribute, as shown above. The ordering will depend on the type of field (character fields are sorted alphabetically, while date fields are sorted in chronological order). As shown above, you can prefix the field name with a minus symbol (-) to reverse the sorting order. So as an example, if we chose to sort books like this by default: the books would be sorted alphabetically by title, from A-Z, and then by publication date inside each title, from newest to oldest. Another common attribute is , a verbose name for the class in singular and plural form: Class metadata can be used to create and apply new \"access permissions\" for the model (default permissions are applied automatically), allow ordering based on another field, define constraints on possible values of data that can be stored, or to declare that the class is \"abstract\" (a base class that you cannot create records for, and will instead be derived from to create other models). Many of the other metadata options control what database must be used for the model and how the data is stored (these are really only useful if you need to map a model to an existing database). The full list of metadata options are available here: Model metadata options (Django docs). A model can also have methods. Minimally, in every model you should define the standard Python class method to return a human-readable string for each object. This string is used to represent individual records in the administration site (and anywhere else you need to refer to a model instance). Often this will return a title or name field from the model. Another common method to include in Django models is , which returns a URL for displaying individual model records on the website (if you define this method then Django will automatically add a \"View on Site\" button to the model's record editing screens in the Admin site). A typical pattern for is shown below. def get_absolute_url(self): \"\"\"Returns the URL to access a particular instance of the model.\"\"\" return reverse('model-detail-view', args=[str(self.id)]) Note: Assuming you will use URLs like to display individual records for your model (where \"2\" is the for a particular record), you will need to create a URL mapper to pass the response and id to a \"model detail view\" (which will do the work required to display the record). The function above is able to \"reverse\" your URL mapper (in the above case named 'model-detail-view') in order to create a URL of the right format. Of course to make this work you still have to write the URL mapping, view, and template! You can also define any other methods you like, and call them from your code or templates (provided that they don't take any parameters).\n\nOnce you've defined your model classes you can use them to create, update, or delete records, and to run queries to get all records or particular subsets of records. We'll show you how to do that in the tutorial when we define our views, but here is a brief summary. To create a record you can define an instance of the model and then call . # Create a new record using the model's constructor. record = MyModelName(my_field_name=\"Instance #1\") # Save the object into the database. record.save() Note: If you haven't declared any field as a , the new record will be given one automatically, with the field name . You could query this field after saving the above record, and it would have a value of 1. You can access the fields in this new record using the dot syntax, and change the values. You have to call to store modified values to the database. # Access model field values using Python attributes. print(record.id) # should return 1 for the first record. print(record.my_field_name) # should print 'Instance #1' # Change record by modifying the fields, then calling save(). record.my_field_name = \"New Instance Name\" record.save() You can search for records that match certain criteria using the model's attribute (provided by the base class). Note: Explaining how to search for records using \"abstract\" model and field names can be a little confusing. In the discussion below, we'll refer to a model with and fields, where genre is also a model with a single field . We can get all records for a model as a , using . The is an iterable object, meaning that it contains a number of objects that we can iterate/loop through. Django's method allows us to filter the returned to match a specified text or numeric field against particular criteria. For example, to filter for books that contain \"wild\" in the title and then count them, we could do the following: The fields to match and the type of match are defined in the filter parameter name, using the format: (note the double underscore between and above). Above we're filtering with a case-sensitive match. There are many other types of matches you can do: (case insensitive), (case-insensitive exact match), (case-sensitive exact match) and , (greater than), , etc. The full list is here. In some cases, you'll need to filter on a field that defines a one-to-many relationship to another model (e.g. a ). In this case, you can \"index\" to fields within the related model with additional double underscores. So for example to filter for books with a specific genre pattern, you will have to index to the through the field, as shown below: # Will match on: Fiction, Science fiction, non-fiction etc. books_containing_genre = Book.objects.filter(genre__name__icontains='fiction') Note: You can use underscores ( ) to navigate as many levels of relationships ( / ) as you like. For example, a that had different types, defined using a further \"cover\" relationship might have a parameter name: There is a lot more you can do with queries, including backwards searches from related models, chaining filters, returning a smaller set of values, etc. For more information, see Making queries (Django Docs).\n\nCopy the model code shown below and paste it into the bottom of your file. This model is used to store information about the book category — for example whether it is fiction or non-fiction, romance or military history, etc. As mentioned above, we've created the genre as a model rather than as free text or a selection list so that the possible values can be managed through the database rather than being hard coded. from django.urls import reverse # Used in get_absolute_url() to get URL for specified ID from django.db.models import UniqueConstraint # Constrains fields to unique values from django.db.models.functions import Lower # Returns lower cased value of field class Genre(models.Model): \"\"\"Model representing a book genre.\"\"\" name = models.CharField( max_length=200, unique=True, help_text=\"Enter a book genre (e.g. Science Fiction, French Poetry etc.)\" ) def __str__(self): \"\"\"String for representing the Model object.\"\"\" return self.name def get_absolute_url(self): \"\"\"Returns the url to access a particular genre instance.\"\"\" return reverse('genre-detail', args=[str(self.id)]) class Meta: constraints = [ UniqueConstraint( Lower('name'), name='genre_name_case_insensitive_unique', violation_error_message = \"Genre already exists (case insensitive match)\" ), ] The model has a single field ( ), which is used to describe the genre (this is limited to 200 characters and has some ). We've set this field to be unique ( ) because there should only be one record for each genre. After the field, we declare a method, which returns the name of the genre defined by a particular record. No verbose name has been defined, so the field label will be when it is used in forms. Then we declare the method, which returns a URL that can be used to access a detail record for this model (for this to work, we will have to define a URL mapping that has the name , and define an associated view and template). Setting on the field above prevents genres being created with exactly the same name, but not variations such as \"fantasy\", \"Fantasy\", or even \"FaNtAsY\". The last part of the model definition uses a option on the model's metadata to specify that the lower case of the value in the field must be unique in the database, and display the string if it isn't. Here we don't need to do anything else, but you can define multiple constraints against a field or fields. For more information see the Constraints reference, including (and ).\n\nCopy the model below and again paste it into the bottom of your file. The model represents all information about an available book in a general sense, but not a particular physical \"instance\" or \"copy\" available for loan. The model uses a to represent the book's and . For , note how the first unnamed parameter explicitly sets the label as \"ISBN\" (otherwise, it would default to \"Isbn\"). We also set the parameter as to ensure all books have a unique ISBN (the unique parameter makes the field value globally unique in a table). Unlike for the (and the genre name), the is not set to be unique, because it is possible for different books to have the same name. The model uses for the , because this text may need to be quite long. class Book(models.Model): \"\"\"Model representing a book (but not a specific copy of a book).\"\"\" title = models.CharField(max_length=200) author = models.ForeignKey('Author', on_delete=models.RESTRICT, null=True) # Foreign Key used because book can only have one author, but authors can have multiple books. # Author as a string rather than object because it hasn't been declared yet in file. summary = models.TextField( max_length=1000, help_text=\"Enter a brief description of the book\") isbn = models.CharField('ISBN', max_length=13, unique=True, help_text='13 Character <a href=\"https://www.isbn-international.org/content/what-isbn' '\">ISBN number</a>') # ManyToManyField used because genre can contain many books. Books can cover many genres. # Genre class has already been defined so we can specify the object above. genre = models.ManyToManyField( Genre, help_text=\"Select a genre for this book\") def __str__(self): \"\"\"String for representing the Model object.\"\"\" return self.title def get_absolute_url(self): \"\"\"Returns the URL to access a detail record for this book.\"\"\" return reverse('book-detail', args=[str(self.id)]) The genre is a , so that a book can have multiple genres and a genre can have many books. The author is declared as , so each book will only have one author, but an author may have many books (in practice a book might have multiple authors, but not in this implementation!) In both field types the related model class is declared as the first unnamed parameter using either the model class or a string containing the name of the related model. You must use the name of the model as a string if the associated class has not yet been defined in this file before it is referenced! The other parameters of interest in the field are , which allows the database to store a value if no author is selected, and , which will prevent the book's associated author being deleted if it is referenced by any book. Warning: By default , which means that if the author was deleted, this book would be deleted too! We use here, but we could also use to prevent the author being deleted while any book uses it or to set the book's author to if the record is deleted. The model also defines , using the book's field to represent a record. The final method, returns a URL that can be used to access a detail record for this model (we will have to define a URL mapping that has the name , and define an associated view and template)."
    },
    {
        "link": "https://django-tenant-schemas.readthedocs.io/en/latest",
        "document": "This application enables Django powered websites to have multiple tenants via PostgreSQL schemas. A vital feature for every Software-as-a-Service website.\n\nDjango provides currently no simple way to support multiple tenants using the same project instance, even when only the data is different. Because we don’t want you running many copies of your project, you’ll be able to have:\n• Multiple customers running on the same instance\n\nA schema can be seen as a directory in an operating system, each directory (schema) with it’s own set of files (tables and objects). This allows the same table name and objects to be used in different schemas without conflict. For an accurate description on schemas, see PostgreSQL’s official documentation on schemas.\n\nThere are typically three solutions for solving the multitenancy problem.\n• Isolated Approach: Separate Databases. Each tenant has it’s own database.\n• Semi Isolated Approach: Shared Database, Separate Schemas. One database for all tenants, but one schema per tenant.\n• Shared Approach: Shared Database, Shared Schema. All tenants share the same database and schema. There is a main tenant-table, where all other tables have a foreign key pointing to. This application implements the second approach, which in our opinion, represents the ideal compromise between simplicity and performance.\n• Simplicity: barely make any changes to your current code to support multitenancy. Plus, you only manage one database.\n• Performance: make use of shared connections, buffers and memory. Each solution has it’s up and down sides, for a more in-depth discussion, see Microsoft’s excellent article on Multi-Tenant Data Architecture.\n\nTenants are identified via their host name (i.e tenant.domain.com). This information is stored on a table on the schema. Whenever a request is made, the host name is used to match a tenant in the database. If there’s a match, the search path is updated to use this tenant’s schema. So from now on all queries will take place at the tenant’s schema. For example, suppose you have a tenant at http://customer.example.com. Any request incoming at will automatically use ’s schema and make the tenant available at the request. If no tenant is found, a 404 error is raised. This also means you should have a tenant for your main domain, typically using the schema. For more information please read the [setup](#setup) section.\n\nMost of your applications are probably tenant-specific, that is, its data is not to be shared with any of the other tenants. An application is considered to be shared when its tables are in the schema. Some apps make sense being shared. Suppose you have some sort of public data set, for example, a table containing census data. You want every tenant to be able to query it. This application enables shared apps by always adding the schema to the search path, making these apps also always available."
    },
    {
        "link": "https://docs.djangoproject.com/en/5.1/ref/forms/api",
        "document": "A instance is either bound to a set of data, or unbound.\n• None If it’s bound to a set of data, it’s capable of validating that data and rendering the form as HTML with the data displayed in the HTML.\n• None If it’s unbound, it cannot do validation (because there’s no data to validate!), but it can still render the blank form as HTML. To create an unbound instance, instantiate the class: To bind data to a form, pass the data as a dictionary as the first parameter to your class constructor: In this dictionary, the keys are the field names, which correspond to the attributes in your class. The values are the data you’re trying to validate. These will usually be strings, but there’s no requirement that they be strings; the type of data you pass depends on the , as we’ll see in a moment. If you need to distinguish between bound and unbound form instances at runtime, check the value of the form’s attribute: Note that passing an empty dictionary creates a bound form with empty data: If you have a bound instance and want to change the data somehow, or if you want to bind an unbound instance to some data, create another instance. There is no way to change data in a instance. Once a instance has been created, you should consider its data immutable, whether it has data or not.\n\nUse to declare the initial value of form fields at runtime. For example, you might want to fill in a field with the username of the current session. To accomplish this, use the argument to a . This argument, if given, should be a dictionary mapping field names to initial values. Only include the fields for which you’re specifying an initial value; it’s not necessary to include every field in your form. For example: These values are only displayed for unbound forms, and they’re not used as fallback values if a particular value isn’t provided. If a defines and you include when instantiating the , then the latter will have precedence. In this example, is provided both at the field level and at the form instance level, and the latter gets precedence: Returns the initial data for a form field. It retrieves the data from if present, otherwise trying . Callable values are evaluated. It is recommended to use over because has a simpler interface. Also, unlike , caches its values. This is useful especially when dealing with callables whose return values can change (e.g. or ):\n\nUse the method on your when you need to check if the form data has been changed from the initial data. When the form is submitted, we reconstruct it and provide the original data so that the comparison can be done: will be if the data from differs from what was provided in or otherwise. The result is computed by calling for each field in the form. The attribute returns a list of the names of the fields whose values in the form’s bound data (usually ) differ from what was provided in . It returns an empty list if no data differs.\n\nEach field in a class is responsible not only for validating data, but also for “cleaning” it – normalizing it to a consistent format. This is a nice feature, because it allows data for a particular field to be input in a variety of ways, always resulting in consistent output. For example, normalizes input into a Python object. Regardless of whether you pass it a string in the format , a object, or a number of other formats, will always normalize it to a object as long as it’s valid. Once you’ve created a instance with a set of data and validated it, you can access the clean data via its attribute: {'cc_myself': True, 'message': 'Hi there', 'sender': 'foo@example.com', 'subject': 'hello'} Note that any text-based field – such as or – always cleans the input into a string. We’ll cover the encoding implications later in this document. If your data does not validate, the dictionary contains only the valid fields: will always only contain a key for fields defined in the , even if you pass extra data when you define the . In this example, we pass a bunch of extra fields to the constructor, but contains only the form’s fields: {'cc_myself': True, 'message': 'Hi there', 'sender': 'foo@example.com', 'subject': 'hello'} When the is valid, will include a key and value for all its fields, even if the data didn’t include a value for some optional fields. In this example, the data dictionary doesn’t include a value for the field, but includes it, with an empty value: In this above example, the value for is set to an empty string, because is , and s treat empty values as an empty string. Each field type knows what its “blank” value is – e.g., for , it’s instead of the empty string. For full details on each field’s behavior in this case, see the “Empty value” note for each field in the “Built-in classes” section below. You can write code to perform validation for particular form fields (based on their name) or for the form as a whole (considering combinations of various fields). More information about this is in Form and field validation.\n\nThe second task of a object is to render itself as HTML. To do so, it: If the form is bound to data, the HTML output will include that data appropriately. For example, if a field is represented by an , the data will be in the attribute. If a field is represented by an , then that HTML will include if appropriate: This default output wraps each field with a . Notice the following:\n• None For flexibility, the output does not include the and tags or an tag. It’s your job to do that.\n• None Each field type has a default HTML representation. is represented by an and by an . is represented by an . Note these are merely sensible defaults; you can specify which HTML to use for a given field by using widgets, which we’ll explain shortly.\n• None The HTML for each tag is taken directly from its attribute name in the class.\n• None The text label for each field – e.g. , and is generated from the field name by converting all underscores to spaces and upper-casing the first letter. Again, note these are merely sensible defaults; you can also specify labels manually.\n• None Each text label is surrounded in an HTML tag, which points to the appropriate form field via its . Its , in turn, is generated by prepending to the field name. The attributes and tags are included in the output by default, to follow best practices, but you can change that behavior.\n• None The output uses HTML5 syntax, targeting . For example, it uses boolean attributes such as rather than the XHTML style of . Although output is the default output style when you a form you can customize the output by using your own form template which can be set site-wide, per-form, or per-instance. See Reusable form templates. The default rendering when you a form uses the following methods and attributes. The name of the template rendered if the form is cast into a string, e.g. via or in a template via . By default, a property returning the value of the renderer’s . You may set it as a string template name in order to override that for a particular form class. The render method is called by as well as the , , , and methods. All arguments are optional and default to: By passing you can customize the template used for just a single call. Return the template context for rendering the form. The available context is:\n• None : All bound fields, except the hidden fields.\n• None : All non field related or hidden field related form errors. The template used to render a field’s , used when calling / . Can be changed per form by overriding this attribute or more generally by overriding the default template, see also Overriding built-in form templates. The recommended approach for changing form output style is to set a custom form template either site-wide, per-form, or per-instance. See Reusable form templates for examples. The following helper functions are provided for backward compatibility and are a proxy to passing a particular value. Of the framework provided templates and output styles, the default is recommended over the , , and versions as the template implements and to group related inputs and is easier for screen reader users to navigate. Each helper pairs a form method with an attribute giving the appropriate template name. The template used by . Default: . renders the form as a series of elements, with each containing one field, such as: The template used by . Default: . renders the form as a series of tags, with each containing one field: The template used by . Default: . renders the form as a series of tags, with each containing one field. It does not include the or , so that you can specify any HTML attributes on the for flexibility: The template used by . Default: . renders the form as an HTML : It’s pretty common to style form rows and fields that are required or have errors. For example, you might want to present required form rows in bold and highlight errors in red. The class has a couple of hooks you can use to add attributes to required rows or to rows with errors: set the and/or attributes: # ... and the rest of your fields here Once you’ve done that, rows will be given and/or classes, as needed. The HTML will look something like: Specifies the renderer to use for the form. Defaults to which means to use the default renderer specified by the setting. You can set this as a class attribute when declaring your form or use the argument to . For example: In the , and shortcuts, the fields are displayed in the order in which you define them in your form class. For example, in the example, the fields are defined in the order , , , . To reorder the HTML output, change the order in which those fields are listed in the class. There are several other ways to customize the order: By default , which retains the order in which you define the fields in your form class. If is a list of field names, the fields are ordered as specified by the list and remaining fields are appended according to the default order. Unknown field names in the list are ignored. This makes it possible to disable a field in a subclass by setting it to without having to redefine ordering. You can also use the argument to a to override the field order. If a defines and you include when instantiating the , then the latter will have precedence. You may rearrange the fields any time using with a list of field names as in . If you render a bound object, the act of rendering will automatically run the form’s validation if it hasn’t already happened, and the HTML output will include the validation errors as a near the field. The particular positioning of the error messages depends on the output method you’re using: By default, forms use to format validation errors. is a list like object where is the list of errors. In addition this class has the following attributes and methods. The CSS classes to be used when rendering the error list. Any provided classes are added to the default class. Specifies the renderer to use for . Defaults to which means to use the default renderer specified by the setting. The name of the template used when calling or . By default this is which is a proxy for the template. The name of the template used when calling . By default this is . This template renders the errors as a list of bullet points. The name of the template used when calling . By default this is . This template renders the errors in tags with a wrapping with the CSS classes as defined by . Return context for rendering of errors in a template. The available context is: The render method is called by as well as by the method. All arguments are optional and will default to: Renders the error list using the template defined by . Renders the error list using the template defined by . If you’d like to customize the rendering of errors this can be achieved by overriding the attribute or more generally by overriding the default template, see also Overriding built-in form templates.\n\nThe , , and methods are shortcuts – they’re not the only way a form object can be displayed. Used to display HTML or access attributes for a single field of a instance. The method of this object displays the HTML for this field. To retrieve a single , use dictionary lookup syntax on your form using the field’s name as the key: To retrieve all objects, iterate the form: The HTML ID attribute for this . Returns an empty string if is . This property returns the data for this extracted by the widget’s method, or if it wasn’t given: A list-like object that is displayed as an HTML when printed: When rendering a field with errors, will be set on the field’s widget to indicate there is an error to screen reader users. The was added when a field has errors. The form instance from the form class that this wraps. The instance this is bound to. The of the field. The name that will be used in the widget’s HTML attribute. It takes the form into account. Use this property to render the ID of this field. For example, if you are manually constructing a in your template (despite the fact that / will do this for you): By default, this will be the field’s name prefixed by (” ” for the example above). You may modify the ID by setting on the field’s widget. For example, declaring a field like this: and using the template above, would render something like: Use to retrieve initial data for a form field. It retrieves the data from if present, otherwise trying . Callable values are evaluated. See Initial form values for more examples. caches its return value, which is useful especially when dealing with callables whose return values can change (e.g. or ): Using is recommended over . Returns if this ’s widget is hidden. The of the field. This is used in / . The name of this field in the form: The name of the template rendered with . A property returning the value of the if set otherwise . Returns the value of this BoundField widget’s attribute. Returns the lowercased class name of the wrapped field’s widget, with any trailing or removed. This may be used when building forms where the layout is dependent upon the widget type. For example: # render one way # render another way Renders the field using with default values which renders the , including its label, help text and errors using the template’s if set otherwise Returns a string of HTML for representing this as an . This method is primarily used internally. You should use a widget instead. Renders the field by rendering the passed widget, adding any HTML attributes passed as . If no widget is specified, then the field’s default widget will be used. is used by Django internals and should not be set explicitly. When you use Django’s rendering shortcuts, CSS classes are used to indicate required form fields or fields that contain errors. If you’re manually rendering a form, you can access these CSS classes using the method: If you want to provide some additional classes in addition to the error and required classes that may be required, you can provide those classes as an argument: Return the template context for rendering the field. The available context is being the instance of the bound field. Renders a label tag for the form field using the template specified by . The available context is:\n• None : This instance of the .\n• None : By default a concatenated string of and (or , if set). This can be overridden by the and arguments.\n• None : A containing , , and . is generated by the field’s widget or . Additional attributes can be provided by the argument.\n• None : A boolean which is if the label has an . If the default template omits the .\n• None : An optional string to customize the tag, defaults to . In your template is the instance of the . Therefore accesses being the field you declare, e.g. . To separately render the label tag of a form field, you can call its method: If you’d like to customize the rendering this can be achieved by overriding the attribute or more generally by overriding the default template, see also Overriding built-in form templates. Calls with to render the label with tags. This is useful when rendering radio and multiple checkbox widgets where may be more appropriate than a . The render method is called by . All arguments are optional and default to: By passing you can customize the template used for just a single call. Use this method to render the raw value of this field as it would be rendered by a :\n\nDealing with forms that have and fields is a little more complicated than a normal form. Firstly, in order to upload files, you’ll need to make sure that your element correctly defines the as : Secondly, when you use the form, you need to bind the file data. File data is handled separately to normal form data, so when your form contains a and , you will need to specify a second argument when you bind your form. So if we extend our ContactForm to include an called , we need to bind the file data containing the mugshot image: In practice, you will usually specify as the source of file data (just like you use as the source of form data): # Bound form with an image field, data from the request Constructing an unbound form is the same as always – omit both form data and file data: If you’re writing reusable views or templates, you may not know ahead of time whether your form is a multipart form or not. The method tells you whether the form requires multipart encoding for submission: Here’s an example of how you might use this in a template:\n\nIf you have multiple classes that share fields, you can use subclassing to remove redundancy. When you subclass a custom class, the resulting subclass will include all fields of the parent class(es), followed by the fields you define in the subclass. In this example, contains all the fields from , plus an additional field, . The fields are ordered first: It’s possible to subclass multiple forms, treating forms as mixins. In this example, subclasses both and (in that order), and its field list includes the fields from the parent classes: It’s possible to declaratively remove a inherited from a parent class by setting the name of the field to on the subclass. For example:"
    },
    {
        "link": "https://docs.djangoproject.com/en/5.1/topics/forms",
        "document": "Unless you’re planning to build websites and applications that do nothing but publish content, and don’t accept input from your visitors, you’re going to need to understand and use forms.\n\nDjango provides a range of tools and libraries to help you build forms to accept input from site visitors, and then process and respond to the input.\n\nIn HTML, a form is a collection of elements inside that allow a visitor to do things like enter text, select options, manipulate objects or controls, and so on, and then send that information back to the server. Some of these form interface elements - text input or checkboxes - are built into HTML itself. Others are much more complex; an interface that pops up a date picker or allows you to move a slider or manipulate controls will typically use JavaScript and CSS as well as HTML form elements to achieve these effects. As well as its elements, a form must specify two things:\n• None where: the URL to which the data corresponding to the user’s input should be returned\n• None how: the HTTP method the data should be returned by As an example, the login form for the Django admin contains several elements: one of for the username, one of for the password, and one of for the “Log in” button. It also contains some hidden text fields that the user doesn’t see, which Django uses to determine what to do next. It also tells the browser that the form data should be sent to the URL specified in the ’s attribute - - and that it should be sent using the HTTP mechanism specified by the attribute - . When the element is triggered, the data is returned to . and are the only HTTP methods to use when dealing with forms. Django’s login form is returned using the method, in which the browser bundles up the form data, encodes it for transmission, sends it to the server, and then receives back its response. , by contrast, bundles the submitted data into a string, and uses this to compose a URL. The URL contains the address where the data must be sent, as well as the data keys and values. You can see this in action if you do a search in the Django documentation, which will produce a URL of the form . and are typically used for different purposes. Any request that could be used to change the state of the system - for example, a request that makes changes in the database - should use . should be used only for requests that do not affect the state of the system. would also be unsuitable for a password form, because the password would appear in the URL, and thus, also in browser history and server logs, all in plain text. Neither would it be suitable for large quantities of data, or for binary data, such as an image. A web application that uses requests for admin forms is a security risk: it can be easy for an attacker to mimic a form’s request to gain access to sensitive parts of the system. , coupled with other protections like Django’s CSRF protection offers more control over access. On the other hand, is suitable for things like a web search form, because the URLs that represent a request can easily be bookmarked, shared, or resubmitted.\n\nHandling forms is a complex business. Consider Django’s admin, where numerous items of data of several different types may need to be prepared for display in a form, rendered as HTML, edited using a convenient interface, returned to the server, validated and cleaned up, and then saved or passed on for further processing. Django’s form functionality can simplify and automate vast portions of this work, and can also do it more securely than most programmers would be able to do in code they wrote themselves. Django handles three distinct parts of the work involved in forms:\n• None preparing and restructuring data to make it ready for rendering\n• None receiving and processing submitted forms and data from the client It is possible to write code that does all of this manually, but Django can take care of it all for you.\n\nWe’ve described HTML forms briefly, but an HTML is just one part of the machinery required. In the context of a web application, ‘form’ might refer to that HTML , or to the Django that produces it, or to the structured data returned when it is submitted, or to the end-to-end working collection of these parts. At the heart of this system of components is Django’s class. In much the same way that a Django model describes the logical structure of an object, its behavior, and the way its parts are represented to us, a class describes a form and determines how it works and appears. In a similar way that a model class’s fields map to database fields, a form class’s fields map to HTML form elements. (A maps a model class’s fields to HTML form elements via a ; this is what the Django admin is based upon.) A form’s fields are themselves classes; they manage form data and perform validation when a form is submitted. A and a handle very different kinds of data and have to do different things with it. A form field is represented to a user in the browser as an HTML “widget” - a piece of user interface machinery. Each field type has an appropriate default Widget class, but these can be overridden as required. When rendering an object in Django, we generally:\n• None get hold of it in the view (fetch it from the database, for example)\n• None pass it to the template context\n• None expand it to HTML markup using template variables Rendering a form in a template involves nearly the same work as rendering any other kind of object, but there are some key differences. In the case of a model instance that contained no data, it would rarely if ever be useful to do anything with it in a template. On the other hand, it makes perfect sense to render an unpopulated form - that’s what we do when we want the user to populate it. So when we handle a model instance in a view, we typically retrieve it from the database. When we’re dealing with a form we typically instantiate it in the view. When we instantiate a form, we can opt to leave it empty or prepopulate it, for example with:\n• None data from a saved model instance (as in the case of admin forms for editing)\n• None data that we have collated from other sources The last of these cases is the most interesting, because it’s what makes it possible for users not just to read a website, but to send information back to it too.\n\nThe work that needs to be done¶ Suppose you want to create a simple form on your website, in order to obtain the user’s name. You’d need something like this in your template: This tells the browser to return the form data to the URL , using the method. It will display a text field, labeled “Your name:”, and a button marked “OK”. If the template context contains a variable, that will be used to pre-fill the field. You’ll need a view that renders the template containing the HTML form, and that can supply the field as appropriate. When the form is submitted, the request which is sent to the server will contain the form data. Now you’ll also need a view corresponding to that URL which will find the appropriate key/value pairs in the request, and then process them. This is a very simple form. In practice, a form might contain dozens or hundreds of fields, many of which might need to be prepopulated, and we might expect the user to work through the edit-submit cycle several times before concluding the operation. We might require some validation to occur in the browser, even before the form is submitted; we might want to use much more complex fields, that allow the user to do things like pick dates from a calendar and so on. At this point it’s much easier to get Django to do most of this work for us. We already know what we want our HTML form to look like. Our starting point for it in Django is this: This defines a class with a single field ( ). We’ve applied a human-friendly label to the field, which will appear in the when it’s rendered (although in this case, the we specified is actually the same one that would be generated automatically if we had omitted it). The field’s maximum allowable length is defined by . This does two things. It puts a on the HTML (so the browser should prevent the user from entering more than that number of characters in the first place). It also means that when Django receives the form back from the browser, it will validate the length of the data. A instance has an method, which runs validation routines for all its fields. When this method is called, if all fields contain valid data, it will:\n• None place the form’s data in its attribute. The whole form, when rendered for the first time, will look like: Note that it does not include the tags, or a submit button. We’ll have to provide those ourselves in the template. Form data sent back to a Django website is processed by a view, generally the same view which published the form. This allows us to reuse some of the same logic. To handle the form we need to instantiate it in the view for the URL where we want it to be published: # if this is a POST request we need to process the form data # create a form instance and populate it with data from the request: # process the data in form.cleaned_data as required # if a GET (or any other method) we'll create a blank form If we arrive at this view with a request, it will create an empty form instance and place it in the template context to be rendered. This is what we can expect to happen the first time we visit the URL. If the form is submitted using a request, the view will once again create a form instance and populate it with data from the request: This is called “binding data to the form” (it is now a bound form). We call the form’s method; if it’s not , we go back to the template with the form. This time the form is no longer empty (unbound) so the HTML form will be populated with the data previously submitted, where it can be edited and corrected as required. If is , we’ll now be able to find all the validated form data in its attribute. We can use this data to update the database or do other processing before sending an HTTP redirect to the browser telling it where to go next. We don’t need to do much in our template: All the form’s fields and their attributes will be unpacked into HTML markup from that by Django’s template language. Django ships with an easy-to-use protection against Cross Site Request Forgeries. When submitting a form via with CSRF protection enabled you must use the template tag as in the preceding example. However, since CSRF protection is not directly tied to forms in templates, this tag is omitted from the following examples in this document. If your form includes a , an or any integer field type, Django will use the , and HTML5 input types. By default, browsers may apply their own validation on these fields, which may be stricter than Django’s validation. If you would like to disable this behavior, set the attribute on the tag, or specify a different widget on the field, like . We now have a working web form, described by a Django , processed by a view, and rendered as an HTML . That’s all you need to get started, but the forms framework puts a lot more at your fingertips. Once you understand the basics of the process described above, you should be prepared to understand other features of the forms system and ready to learn a bit more about the underlying machinery.\n\nAll form classes are created as subclasses of either or . You can think of as a subclass of . and actually inherit common functionality from a (private) class, but this implementation detail is rarely important. In fact if your form is going to be used to directly add or edit a Django model, a ModelForm can save you a great deal of time, effort, and code, because it will build a form, along with the appropriate fields and their attributes, from a class. The distinction between Bound and unbound forms is important:\n• None An unbound form has no data associated with it. When rendered to the user, it will be empty or will contain default values.\n• None A bound form has submitted data, and hence can be used to tell if that data is valid. If an invalid bound form is rendered, it can include inline error messages telling the user what data to correct. The form’s attribute will tell you whether a form has data bound to it or not. Consider a more useful form than our minimal example above, which we could use to implement “contact me” functionality on a personal website: Our earlier form used a single field, , a . In this case, our form has four fields: , , and . , and are just three of the available field types; a full list can be found in Form fields. Each form field has a corresponding Widget class, which in turn corresponds to an HTML form widget such as . In most cases, the field will have a sensible default widget. For example, by default, a will have a widget, that produces an in the HTML. If you needed instead, you’d specify the appropriate widget when defining your form field, as we have done for the field. Whatever the data submitted with a form, once it has been successfully validated by calling (and has returned ), the validated form data will be in the dictionary. This data will have been nicely converted into Python types for you. You can still access the unvalidated data directly from at this point, but the validated data is better. In the contact form example above, will be a boolean value. Likewise, fields such as and convert values to a Python and respectively. Here’s how the form data could be processed in the view that handles this form: For more on sending email from Django, see Sending email. Some field types need some extra handling. For example, files that are uploaded using a form need to be handled differently (they can be retrieved from , rather than ). For details of how to handle file uploads with your form, see Binding uploaded files to a form.\n\nAll you need to do to get your form into a template is to place the form instance into the template context. So if your form is called in the context, will render its and elements appropriately. Don’t forget that a form’s output does not include the surrounding tags, or the form’s control. You will have to provide these yourself. The HTML output when rendering a form is itself generated via a template. You can control this by creating an appropriate template file and setting a custom to use that site-wide. You can also customize per-form by overriding the form’s attribute to render the form using the custom template, or by passing the template name directly to . The example below will result in being rendered as the output of the template. # In your template: # In form_snippet.html: Then you can configure the setting: … or for a single render of a form instance, passing in the template name to the . Here’s an example of this being used in a view: See Outputting forms as HTML for more details. Each field is available as an attribute of the form, using in a template. A field has a method which renders the related elements of the field as a group, its label, widget, errors, and help text. This allows generic templates to be written that arrange fields elements in the required layout. For example: By default Django uses the template which is designed for use with the default form style. The default template can be customized by setting in your project-level : … or on a per-request basis by calling and supplying a template name: More fine grained control over field rendering is also possible. Likely this will be in a custom field template, to allow the template to be written once and reused for each field. However, it can also be directly accessed from the field attribute on the form. For example: Email subject: Your message: Your email address: CC yourself? Complete elements can also be generated using the . For example: The price of this flexibility is a bit more work. Until now we haven’t had to worry about how to display form errors, because that’s taken care of for us. In this example we have had to make sure we take care of any errors for each field and any errors for the form as a whole. Note at the top of the form and the template lookup for errors on each field. Using displays a list of form errors, rendered as an unordered list. This might look like: The list has a CSS class of to allow you to style its appearance. If you wish to further customize the display of errors you can do so by looping over them: Non-field errors (and/or hidden field errors that are rendered at the top of the form when using helpers like ) will be rendered with an additional class of to help distinguish them from field-specific errors. For example, would look like: See The Forms API for more on errors, styling, and working with form attributes in templates. If you’re using the same HTML for each of your form fields, you can reduce duplicate code by looping through each field in turn using a loop: Outputs a containing any validation errors corresponding to this field. You can customize the presentation of the errors with a loop. In this case, each object in the loop is a string containing the error message. The instance from the form class that this wraps. You can use it to access attributes, e.g. . Any help text that has been associated with the field. The name of the field that will be used in the input element’s name field. This takes the form prefix into account, if it has been set. The ID that will be used for this field ( in the example above). If you are constructing the label manually, you may want to use this in lieu of . It’s also useful, for example, if you have some inline JavaScript and want to avoid hardcoding the field’s ID. This attribute is if the form field is a hidden field and otherwise. It’s not particularly useful as a template variable, but could be useful in conditional tests such as: The label of the field, e.g. . The field’s label wrapped in the appropriate HTML tag. This includes the form’s . For example, the default is a colon: Similar to but uses a tag in place of , for widgets with multiple inputs wrapped in a . This attribute is if the form field’s widget contains multiple inputs that should be semantically grouped in a with a to improve accessibility. An example use in a template: The value of the field. e.g . For a complete list of attributes and methods, see . If you’re manually laying out a form in a template, as opposed to relying on Django’s default form layout, you might want to treat fields differently from non-hidden fields. For example, because hidden fields don’t display anything, putting error messages “next to” the field could cause confusion for your users – so errors for those fields should be handled differently. Django provides two methods on a form that allow you to loop over the hidden and visible fields independently: and . Here’s a modification of an earlier example that uses these two methods: This example does not handle any errors in the hidden fields. Usually, an error in a hidden field is a sign of form tampering, since normal form interaction won’t alter them. However, you could easily insert some error displays for those form errors, as well."
    },
    {
        "link": "https://docs.djangoproject.com/en/5.1/ref/forms/validation",
        "document": "Form validation happens when the data is cleaned. If you want to customize this process, there are various places to make changes, each one serving a different purpose. Three types of cleaning methods are run during form processing. These are normally executed when you call the method on a form. There are other things that can also trigger cleaning and validation (accessing the attribute or calling directly), but normally they won’t be needed.\n\nIn general, any cleaning method can raise if there is a problem with the data it is processing, passing the relevant information to the constructor. See below for the best practice in raising . If no is raised, the method should return the cleaned (normalized) data as a Python object.\n\nMost validation can be done using validators - helpers that can be reused. Validators are functions (or callables) that take a single argument and raise on invalid input. Validators are run after the field’s and methods have been called.\n\nValidation of a form is split into several steps, which can be customized or overridden:\n• None The method on a is the first step in every validation. It coerces the value to a correct datatype and raises if that is not possible. This method accepts the raw value from the widget and returns the converted value. For example, a will turn the data into a Python or raise a .\n• None The method on a handles field-specific validation that is not suitable for a validator. It takes a value that has been coerced to a correct datatype and raises on any error. This method does not return anything and shouldn’t alter the value. You should override it to handle validation logic that you can’t or don’t want to put in a validator.\n• None The method on a runs all of the field’s validators and aggregates all the errors into a single . You shouldn’t need to override this method.\n• None The method on a subclass is responsible for running , , and in the correct order and propagating their errors. If, at any time, any of the methods raise , the validation stops and that error is raised. This method returns the clean data, which is then inserted into the dictionary of the form.\n• None The method is called on a form subclass – where is replaced with the name of the form field attribute. This method does any cleaning that is specific to that particular attribute, unrelated to the type of field that it is. This method is not passed any parameters. You will need to look up the value of the field in and remember that it will be a Python object at this point, not the original string submitted in the form (it will be in because the general field method, above, has already cleaned the data once). For example, if you wanted to validate that the contents of a called was unique, would be the right place to do this. You don’t need a specific field (it’s a ), but you want a formfield-specific piece of validation and, possibly, cleaning/normalizing the data. The return value of this method replaces the existing value in , so it must be the field’s value from (even if this method didn’t change it) or a new cleaned value.\n• None The form subclass’s method can perform validation that requires access to multiple form fields. This is where you might put in checks such as “if field is supplied, field must contain a valid email address”. This method can return a completely different dictionary if it wishes, which will be used as the . Since the field validation methods have been run by the time is called, you also have access to the form’s attribute which contains all the errors raised by cleaning of individual fields. Note that any errors raised by your override will not be associated with any field in particular. They go into a special “field” (called ), which you can access via the method if you need to. If you want to attach errors to a specific field in the form, you need to call . Also note that there are special considerations when overriding the method of a subclass. (see the ModelForm documentation for more information)\n\nThese methods are run in the order given above, one field at a time. That is, for each field in the form (in the order they are declared in the form definition), the method (or its override) is run, then . Finally, once those two methods are run for every field, the method, or its override, is executed whether or not the previous methods have raised errors.\n\nExamples of each of these methods are provided below.\n\nAs mentioned, any of these methods can raise a . For any field, if the method raises a , any field-specific cleaning method is not called. However, the cleaning methods for all remaining fields are still executed.\n\nIn order to make error messages flexible and easy to override, consider the following guidelines:\n• None Don’t coerce variables into the message; use placeholders and the argument of the constructor:\n• None Use mapping keys instead of positional formatting. This enables putting the variables in any order or omitting them altogether when rewriting the message:\n• None Wrap the message with to enable translation: Following these guidelines is particularly necessary if you write reusable forms, form fields, and model fields. While not recommended, if you are at the end of the validation chain (i.e. your form method) and you know you will never need to override your error message you can still opt for the less verbose: The and methods greatly benefit from fully featured s (with a name and a dictionary). If you detect multiple errors during a cleaning method and wish to signal all of them to the form submitter, it is possible to pass a list of errors to the constructor. As above, it is recommended to pass a list of instances with s and but a list of strings will also work:\n\nThe previous sections explained how validation works in general for forms. Since it can sometimes be easier to put things into place by seeing each feature in use, here are a series of small examples that use each of the previous features. Django’s form (and model) fields support use of utility functions and classes known as validators. A validator is a callable object or function that takes a value and returns nothing if the value is valid or raises a if not. These can be passed to a field’s constructor, via the field’s argument, or defined on the class itself with the attribute. Validators can be used to validate values inside the field, let’s have a look at Django’s : As you can see, is a with a customized validator that validates that submitted text obeys to some character rules. This can also be done on field definition so: Common cases such as validating against an email or a regular expression can be handled using existing validator classes available in Django. For example, is an instance of a constructed with the first argument being the pattern: . See the section on writing validators to see a list of what is already available and for an example of how to write a validator. Let’s first create a custom form field that validates its input is a string containing comma-separated email addresses. The full class looks like this: # Return an empty list if no input was given. \"\"\"Check if value consists only of valid emails.\"\"\" # Use the parent's handling of required fields, etc. Every form that uses this field will have these methods run before anything else can be done with the field’s data. This is cleaning that is specific to this type of field, regardless of how it is subsequently used. Let’s create a to demonstrate how you’d use this field: Use like any other form field. When the method is called on the form, the method will be run as part of the cleaning process and it will, in turn, call the custom and methods. Continuing on from the previous example, suppose that in our , we want to make sure that the field always contains the address . This is validation that is specific to our form, so we don’t want to put it into the general class. Instead, we write a cleaning method that operates on the field, like so: \"You have forgotten about Fred!\" # Always return a value to use as the new cleaned data, even if Cleaning and validating fields that depend on each other¶ Suppose we add another requirement to our contact form: if the field is , the must contain the word . We are performing validation on more than one field at a time, so the form’s method is a good spot to do this. Notice that we are talking about the method on the form here, whereas earlier we were writing a method on a field. It’s important to keep the field and form difference clear when working out where to validate things. Fields are single data points, forms are a collection of fields. By the time the form’s method is called, all the individual field clean methods will have been run (the previous two sections), so will be populated with any data that has survived so far. So you also need to remember to allow for the fact that the fields you are wanting to validate might not have survived the initial individual field checks. There are two ways to report any errors from this step. Probably the most common method is to display the error at the top of the form. To create such an error, you can raise a from the method. For example: # Only do something if both fields are valid so far. \"Did not send for 'help' in the subject despite CC'ing yourself.\" In this code, if the validation error is raised, the form will display an error message at the top of the form (normally) describing the problem. Such errors are non-field errors, which are displayed in the template with . The call to in the example code ensures that any validation logic in parent classes is maintained. If your form inherits another that doesn’t return a dictionary in its method (doing so is optional), then don’t assign to the result of the call and use instead: The second approach for reporting validation errors might involve assigning the error message to one of the fields. In this case, let’s assign an error message to both the “subject” and “cc_myself” rows in the form display. Be careful when doing this in practice, since it can lead to confusing form output. We’re showing what is possible here and leaving it up to you and your designers to work out what works effectively in your particular situation. Our new code (replacing the previous sample) looks like this: \"Must put 'help' in subject when cc'ing yourself.\" The second argument of can be a string, or preferably an instance of . See Raising ValidationError for more details. Note that automatically removes the field from ."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Server-side/Django/Forms",
        "document": "An HTML Form is a group of one or more fields/widgets on a web page, which can be used to collect information from users for submission to a server. Forms are a flexible mechanism for collecting user input because there are suitable widgets for entering many different types of data, including text boxes, checkboxes, radio buttons, date pickers and so on. Forms are also a relatively secure way of sharing data with the server, as they allow us to send data in requests with cross-site request forgery protection. While we haven't created any forms in this tutorial so far, we've already encountered them in the Django Admin site — for example, the screenshot below shows a form for editing one of our Book models, comprised of a number of selection lists and text editors. Working with forms can be complicated! Developers need to write HTML for the form, validate and properly sanitize entered data on the server (and possibly also in the browser), repost the form with error messages to inform users of any invalid fields, handle the data when it has successfully been submitted, and finally respond to the user in some way to indicate success. Django Forms take a lot of the work out of all these steps, by providing a framework that lets you define forms and their fields programmatically, and then use these objects to both generate the form HTML code and handle much of the validation and user interaction. In this tutorial, we're going to show you a few of the ways you can create and work with forms, and in particular, how the generic editing views can significantly reduce the amount of work you need to do to create forms to manipulate your models. Along the way, we'll extend our LocalLibrary application by adding a form to allow librarians to renew library books, and we'll create pages to create, edit and delete books and authors (reproducing a basic version of the form shown above for editing books).\n\nFirst, a brief overview of HTML Forms. Consider a simple HTML form, with a single text field for entering the name of some \"team\", and its associated label: The form is defined in HTML as a collection of elements inside tags, containing at least one element of . <form action=\"/team_name_url/\" method=\"post\"> <label for=\"team_name\">Enter name: </label> <input id=\"team_name\" type=\"text\" name=\"name_field\" value=\"Default name for team.\" /> <input type=\"submit\" value=\"OK\" /> </form> While here we just have one text field for entering the team name, a form may have any number of other input elements and their associated labels. The field's attribute defines what sort of widget will be displayed. The and of the field are used to identify the field in JavaScript/CSS/HTML, while defines the initial value for the field when it is first displayed. The matching team label is specified using the tag (see \"Enter name\" above), with a field containing the value of the associated . The input will be displayed as a button by default. This can be pressed to upload the data in all the other input elements in the form to the server (in this case, just the field). The form attributes define the HTTP used to send the data and the destination of the data on the server ( ):\n• : The resource/URL where data is to be sent for processing when the form is submitted. If this is not set (or set to an empty string), then the form will be submitted back to the current page URL.\n• : The HTTP method used to send the data: post or get.\n• The method should always be used if the data is going to result in a change to the server's database, because it can be made more resistant to cross-site forgery request attacks.\n• The method should only be used for forms that don't change user data (for example, a search form). It is recommended for when you want to be able to bookmark or share the URL. The role of the server is first to render the initial form state — either containing blank fields or pre-populated with initial values. After the user presses the submit button, the server will receive the form data with values from the web browser and must validate the information. If the form contains invalid data, the server should display the form again, this time with user-entered data in \"valid\" fields and messages to describe the problem for the invalid fields. Once the server gets a request with all valid form data, it can perform an appropriate action (such as: saving the data, returning the result of a search, uploading a file, etc.) and then notify the user. As you can imagine, creating the HTML, validating the returned data, re-displaying the entered data with error reports if needed, and performing the desired operation on valid data can all take quite a lot of effort to \"get right\". Django makes this a lot easier by taking away some of the heavy lifting and repetitive code!\n\nThe class is the heart of Django's form handling system. It specifies the fields in the form, their layout, display widgets, labels, initial values, valid values, and (once validated) the error messages associated with invalid fields. The class also provides methods for rendering itself in templates using predefined formats (tables, lists, etc.) or for getting the value of any element (enabling fine-grained manual rendering). The declaration syntax for a is very similar to that for declaring a , and shares the same field types (and some similar parameters). This makes sense because in both cases we need to ensure that each field handles the right types of data, is constrained to valid data, and has a description for display/documentation. Form data is stored in an application's forms.py file, inside the application directory. Create and open the file django-locallibrary-tutorial/catalog/forms.py. To create a , we import the library, derive from the class, and declare the form's fields. A very basic form class for our library book renewal form is shown below — add this to your new file: from django import forms class RenewBookForm(forms.Form): renewal_date = forms.DateField(help_text=\"Enter a date between now and 4 weeks (default 3).\") In this case, we have a single for entering the renewal date that will render in HTML with a blank value, the default label \"Renewal date:\", and some helpful usage text: \"Enter a date between now and 4 weeks (default 3 weeks).\" As none of the other optional arguments are specified the field will accept dates using the input_formats: YYYY-MM-DD (2024-11-06), MM/DD/YYYY (02/26/2024), MM/DD/YY (10/25/24), and will be rendered using the default widget: DateInput. There are many other types of form fields, which you will largely recognize from their similarity to the equivalent model field classes: The arguments that are common to most fields are listed below (these have sensible default values):\n• : If , the field may not be left blank or given a value. Fields are required by default, so you would set to allow blank values in the form.\n• : The label to use when rendering the field in HTML. If a label is not specified, Django will create one from the field name by capitalizing the first letter and replacing underscores with spaces (e.g. Renewal date).\n• : By default, a colon is displayed after the label (e.g. Renewal date​:). This argument allows you to specify a different suffix containing other character(s).\n• : The initial value for the field when the form is displayed.\n• : The display widget to use.\n• (as seen in the example above): Additional text that can be displayed in forms to explain how to use the field.\n• : A list of error messages for the field. You can override these with your own messages if needed.\n• : A list of functions that will be called on the field when it is validated.\n• : Enables the localization of form data input (see link for more information).\n• : The field is displayed but its value cannot be edited if this is . The default is . Django provides numerous places where you can validate your data. The easiest way to validate a single field is to override the method for the field you want to check. So for example, we can validate that entered values are between now and 4 weeks by implementing as shown below. Update your forms.py file so it looks like this: import datetime from django import forms from django.core.exceptions import ValidationError from django.utils.translation import gettext_lazy as _ class RenewBookForm(forms.Form): renewal_date = forms.DateField(help_text=\"Enter a date between now and 4 weeks (default 3).\") def clean_renewal_date(self): data = self.cleaned_data['renewal_date'] # Check if a date is not in the past. if data < datetime.date.today(): raise ValidationError(_('Invalid date - renewal in past')) # Check if a date is in the allowed range (+4 weeks from today). if data > datetime.date.today() + datetime.timedelta(weeks=4): raise ValidationError(_('Invalid date - renewal more than 4 weeks ahead')) # Remember to always return the cleaned data. return data There are two important things to note. The first is that we get our data using and that we return this data whether or not we change it at the end of the function. This step gets us the data \"cleaned\" and sanitized of potentially unsafe input using the default validators, and converted into the correct standard type for the data (in this case a Python object). The second point is that if a value falls outside our range we raise a , specifying the error text that we want to display in the form if an invalid value is entered. The example above also wraps this text in one of Django's translation functions, (imported as ), which is good practice if you want to translate your site later. Note: There are numerous other methods and examples for validating forms in Form and field validation (Django docs). For example, in cases where you have multiple fields that depend on each other, you can override the Form.clean() function and again raise a . That's all we need for the form in this example!\n\nAs discussed in the Django form handling process above, the view has to render the default form when it is first called and then either re-render it with error messages if the data is invalid, or process the data and redirect to a new page if the data is valid. In order to perform these different actions, the view has to be able to know whether it is being called for the first time to render the default form, or a subsequent time to validate data. For forms that use a request to submit information to the server, the most common pattern is for the view to test against the request type ( ) to identify form validation requests and (using an condition) to identify the initial form creation request. If you want to submit your data using a request, then a typical approach for identifying whether this is the first or subsequent view invocation is to read the form data (e.g. to read a hidden value in the form). The book renewal process will be writing to our database, so, by convention, we use the request approach. The code fragment below shows the (very standard) pattern for this sort of function view. import datetime from django.shortcuts import render, get_object_or_404 from django.http import HttpResponseRedirect from django.urls import reverse from catalog.forms import RenewBookForm def renew_book_librarian(request, pk): book_instance = get_object_or_404(BookInstance, pk=pk) # If this is a POST request then process the Form data if request.method == 'POST': # Create a form instance and populate it with data from the request (binding): form = RenewBookForm(request.POST) # Check if the form is valid: if form.is_valid(): # process the data in form.cleaned_data as required (here we just write it to the model due_back field) book_instance.due_back = form.cleaned_data['renewal_date'] book_instance.save() # redirect to a new URL: return HttpResponseRedirect(reverse('all-borrowed')) # If this is a GET (or any other method) create the default form. else: proposed_renewal_date = datetime.date.today() + datetime.timedelta(weeks=3) form = RenewBookForm(initial={'renewal_date': proposed_renewal_date}) context = { 'form': form, 'book_instance': book_instance, } return render(request, 'catalog/book_renew_librarian.html', context) First, we import our form ( ) and a number of other useful objects/methods used in the body of the view function:\n• : Returns a specified object from a model based on its primary key value, and raises an exception (not found) if the record does not exist.\n• : This creates a redirect to a specified URL (HTTP status code 302).\n• : This generates a URL from a URL configuration name and a set of arguments. It is the Python equivalent of the tag that we've been using in our templates. In the view, we first use the argument in to get the current (if this does not exist, the view will immediately exit and the page will display a \"not found\" error). If this is not a request (handled by the clause) then we create the default form passing in an value for the field, 3 weeks from the current date. book_instance = get_object_or_404(BookInstance, pk=pk) # If this is a GET (or any other method) create the default form else: proposed_renewal_date = datetime.date.today() + datetime.timedelta(weeks=3) form = RenewBookForm(initial={'renewal_date': proposed_renewal_date}) context = { 'form': form, 'book_instance': book_instance, } return render(request, 'catalog/book_renew_librarian.html', context) After creating the form, we call to create the HTML page, specifying the template and a context that contains our form. In this case, the context also contains our , which we'll use in the template to provide information about the book we're renewing. However, if this is a request, then we create our object and populate it with data from the request. This process is called \"binding\" and allows us to validate the form. We then check if the form is valid, which runs all the validation code on all of the fields — including both the generic code to check that our date field is actually a valid date and our specific form's function to check the date is in the right range. book_instance = get_object_or_404(BookInstance, pk=pk) # If this is a POST request then process the Form data if request.method == 'POST': # Create a form instance and populate it with data from the request (binding): form = RenewBookForm(request.POST) # Check if the form is valid: if form.is_valid(): # process the data in form.cleaned_data as required (here we just write it to the model due_back field) book_instance.due_back = form.cleaned_data['renewal_date'] book_instance.save() # redirect to a new URL: return HttpResponseRedirect(reverse('all-borrowed')) context = { 'form': form, 'book_instance': book_instance, } return render(request, 'catalog/book_renew_librarian.html', context) If the form is not valid we call again, but this time the form value passed in the context will include error messages. If the form is valid, then we can start to use the data, accessing it through the attribute (e.g. ). Here, we just save the data into the value of the associated object. Warning: While you can also access the form data directly through the request (for example, or if using a GET request), this is NOT recommended. The cleaned data is sanitized, validated, and converted into Python-friendly types. The final step in the form-handling part of the view is to redirect to another page, usually a \"success\" page. In this case, we use and to redirect to the view named (this was created as the \"challenge\" in Django Tutorial Part 8: User authentication and permissions). If you didn't create that page consider redirecting to the home page at URL ). That's everything needed for the form handling itself, but we still need to restrict access to the view to just logged-in librarians who have permission to renew books. We use to require that the user is logged in, and the function decorator with our existing permission to allow access (decorators are processed in order). Note that we probably should have created a new permission setting in ( ), but we will reuse the existing one to keep the example simple. The final view is therefore as shown below. Please copy this into the bottom of django-locallibrary-tutorial/catalog/views.py. import datetime from django.contrib.auth.decorators import login_required, permission_required from django.shortcuts import get_object_or_404 from django.http import HttpResponseRedirect from django.urls import reverse from catalog.forms import RenewBookForm @login_required @permission_required('catalog.can_mark_returned', raise_exception=True) def renew_book_librarian(request, pk): \"\"\"View function for renewing a specific BookInstance by librarian.\"\"\" book_instance = get_object_or_404(BookInstance, pk=pk) # If this is a POST request then process the Form data if request.method == 'POST': # Create a form instance and populate it with data from the request (binding): form = RenewBookForm(request.POST) # Check if the form is valid: if form.is_valid(): # process the data in form.cleaned_data as required (here we just write it to the model due_back field) book_instance.due_back = form.cleaned_data['renewal_date'] book_instance.save() # redirect to a new URL: return HttpResponseRedirect(reverse('all-borrowed')) # If this is a GET (or any other method) create the default form. else: proposed_renewal_date = datetime.date.today() + datetime.timedelta(weeks=3) form = RenewBookForm(initial={'renewal_date': proposed_renewal_date}) context = { 'form': form, 'book_instance': book_instance, } return render(request, 'catalog/book_renew_librarian.html', context)\n\nCreate the template referenced in the view (/catalog/templates/catalog/book_renew_librarian.html) and copy the code below into it: Most of this will be completely familiar from previous tutorials. We extend the base template and then redefine the content block. We are able to reference (and its variables) because it was passed into the context object in the function, and we use these to list the book title, borrower, and the original due date. The form code is relatively simple. First, we declare the tags, specifying where the form is to be submitted ( ) and the for submitting the data (in this case a ) — if you recall the HTML Forms overview at the top of the page, an empty as shown, means that the form data will be posted back to the current URL of the page (which is what we want). Inside the tags, we define the input, which a user can press to submit the data. The added just inside the form tags is part of Django's cross-site forgery protection. Note: Add the to every Django template you create that uses to submit data. This will reduce the chance of forms being hijacked by malicious users. All that's left is the template variable, which we passed to the template in the context dictionary. Perhaps unsurprisingly, when used as shown this provides the default rendering of all the form fields, including their labels, widgets, and help text — the rendering is as shown below: <tr> <th><label for=\"id_renewal_date\">Renewal date:</label></th> <td> <input id=\"id_renewal_date\" name=\"renewal_date\" type=\"text\" value=\"2023-11-08\" required /> <br /> <span class=\"helptext\"> Enter date between now and 4 weeks (default 3 weeks). </span> </td> </tr> Note: It is perhaps not obvious because we only have one field, but, by default, every field is defined in its own table row. This same rendering is provided if you reference the template variable . If you were to enter an invalid date, you'd additionally get a list of the errors rendered on the page (see below). <tr> <th><label for=\"id_renewal_date\">Renewal date:</label></th> <td> <ul class=\"errorlist\"> <li>Invalid date - renewal in past</li> </ul> <input id=\"id_renewal_date\" name=\"renewal_date\" type=\"text\" value=\"2023-11-08\" required /> <br /> <span class=\"helptext\"> Enter date between now and 4 weeks (default 3 weeks). </span> </td> </tr> Other ways of using form template variable Using as shown above, each field is rendered as a table row. You can also render each field as a list item (using ) or as a paragraph (using ). It is also possible to have complete control over the rendering of each part of the form, by indexing its properties using dot notation. So, for example, we can access a number of separate items for our field:\n• : The id of the label. For more examples of how to manually render forms in templates and dynamically loop over template fields, see Working with forms > Rendering fields manually (Django docs).\n\nCreating a class using the approach described above is very flexible, allowing you to create whatever sort of form page you like and associate it with any model or models. However, if you just need a form to map the fields of a single model then your model will already define most of the information that you need in your form: fields, labels, help text and so on. Rather than recreating the model definitions in your form, it is easier to use the ModelForm helper class to create the form from your model. This can then be used within your views in exactly the same way as an ordinary . A basic containing the same field as our original is shown below. All you need to do to create the form is add with the associated ( ) and a list of the model to include in the form. Note: You can also include all fields in the form using , or you can use (instead of ) to specify the fields not to include from the model). Neither approach is recommended because new fields added to the model are then automatically included in the form (without the developer necessarily considering possible security implications). Note: This might not look all that much simpler than just using a (and it isn't in this case, because we just have one field). However, if you have a lot of fields, it can considerably reduce the amount of code required! The rest of the information comes from the model field definitions (e.g. labels, widgets, help text, error messages). If these aren't quite right, then we can override them in our , specifying a dictionary containing the field to change and its new value. For example, in this form, we might want a label for our field of \"Renewal date\" (rather than the default based on the field name: Due Back), and we also want our help text to be specific to this use case. The below shows you how to override these fields, and you can similarly set and if the defaults aren't sufficient. class Meta: model = BookInstance fields = ['due_back'] labels = {'due_back': _('New renewal date')} help_texts = {'due_back': _('Enter a date between now and 4 weeks (default 3).')} To add validation you can use the same approach as for a normal — you define a function named and raise exceptions for invalid values. The only difference with respect to our original form is that the model field is named and not . This change is necessary since the corresponding field in is called . from django.forms import ModelForm from catalog.models import BookInstance class RenewBookModelForm(ModelForm): def clean_due_back(self): data = self.cleaned_data['due_back'] # Check if a date is not in the past. if data < datetime.date.today(): raise ValidationError(_('Invalid date - renewal in past')) # Check if a date is in the allowed range (+4 weeks from today). if data > datetime.date.today() + datetime.timedelta(weeks=4): raise ValidationError(_('Invalid date - renewal more than 4 weeks ahead')) # Remember to always return the cleaned data. return data class Meta: model = BookInstance fields = ['due_back'] labels = {'due_back': _('Renewal date')} help_texts = {'due_back': _('Enter a date between now and 4 weeks (default 3).')} The class above is now functionally equivalent to our original . You could import and use it wherever you currently use as long as you also update the corresponding form variable name from to as in the second form declaration: .\n\nOpen the views file (django-locallibrary-tutorial/catalog/views.py) and append the following code block to the bottom of it: from django.views.generic.edit import CreateView, UpdateView, DeleteView from django.urls import reverse_lazy from .models import Author class AuthorCreate(PermissionRequiredMixin, CreateView): model = Author fields = ['first_name', 'last_name', 'date_of_birth', 'date_of_death'] initial = {'date_of_death': '11/11/2023'} permission_required = 'catalog.add_author' class AuthorUpdate(PermissionRequiredMixin, UpdateView): model = Author # Not recommended (potential security issue if more fields added) fields = '__all__' permission_required = 'catalog.change_author' class AuthorDelete(PermissionRequiredMixin, DeleteView): model = Author success_url = reverse_lazy('authors') permission_required = 'catalog.delete_author' def form_valid(self, form): try: self.object.delete() return HttpResponseRedirect(self.success_url) except Exception as e: return HttpResponseRedirect( reverse(\"author-delete\", kwargs={\"pk\": self.object.pk}) ) As you can see, to create, update, or delete the views you need to derive from , , and (respectively) and then define the associated model. We also restrict calling these views to only logged in users with the , , and permissions, respectively. For the \"create\" and \"update\" cases you also need to specify the fields to display in the form (using the same syntax as for ). In this case, we show how to list them individually and the syntax to list \"all\" fields. You can also specify initial values for each of the fields using a dictionary of field_name/value pairs (here we arbitrarily set the date of death for demonstration purposes — you might want to remove that). By default, these views will redirect on success to a page displaying the newly created/edited model item, which in our case will be the author detail view we created in a previous tutorial. You can specify an alternative redirect location by explicitly declaring parameter . The class doesn't need to display any of the fields, so these don't need to be specified. We also set a (as shown above), because there is no obvious default URL for Django to navigate to after successfully deleting the . Above we use the function to redirect to our author list after an author has been deleted — is a lazily executed version of , used here because we're providing a URL to a class-based view attribute. If deletion of authors should always succeed that would be it. Unfortunately deleting an will cause an exception if the author has an associated book, because our model specifies for the author field. To handle this case the view overrides the method so that if deleting the succeeds it redirects to the , but if not, it just redirects back to the same form. We'll update the template below to make clear that you can't delete an instance that is used in any ."
    },
    {
        "link": "https://stackoverflow.com/questions/60024276/how-to-validate-forms-using-django-and-how-many-ways-to-validate-form-using-djan",
        "document": "Django can handle server-side validation for you. The two examples you posted above are two valid ways to do this and they are almost correct. You just need to pass some data to your form to validate. So if you change your view to\n\nit will display the error in your html page if the user entered something else than 'hari' in the input.\n\nServer-side means your data is sent to the server and validated there, returnin with an error message or else in the case of data which is not valid.\n\nWhen we talk about client-side validation this is done by the client (i.e. the user's browser) before the data is sent to the server. This is not handled by django. To accomplish this you can use build-in html5 validation or javascript to write you custom validation methods. Examples for build-in html5 validation is the : If a user enters a letter into such a field and tries to submit the form a bubble appears telling the user that he should enter a valid number. The build in validations are easier to use as the do not require any javascript but do have limitations, e.g. you cannot define you own error messages.\n\nTo achieve the validatation in you post with client - side validation you can use the \"pattern\" attribute of the input. The pattern is a regular expression used for validation. E.g.\n\nwill show a bubble in the browser saying that the input is not a valid pattern if the user tries to submit a form which does not contain \"hari\" as a first name.\n\nYou can add this attribute when creating your form, e.g. by overriding the method of your form:\n\nIf you want custom messages etc. you need to write javascript.\n\nAs you can see client-side validation is quite an extensive subject, maybe you would like to read some docs about this like these, also containing examples.\n\nOne final word: Client side validation and server-side validation are not a question of one or the other. You should always use server-side validation as it is much more reliable. Client-side validation is an additional benefit improving user experience but should never be the only validation method."
    },
    {
        "link": "https://docs.djangoproject.com/en/5.1/topics/http/urls",
        "document": "A clean, elegant URL scheme is an important detail in a high-quality web application. Django lets you design URLs however you want, with no framework limitations.\n\nSee Cool URIs don’t change, by World Wide Web creator Tim Berners-Lee, for excellent arguments on why URLs should be clean and usable.\n\nTo design URLs for an app, you create a Python module informally called a URLconf (URL configuration). This module is pure Python code and is a mapping between URL path expressions to Python functions (your views). This mapping can be as short or as long as needed. It can reference other mappings. And, because it’s pure Python code, it can be constructed dynamically. Django also provides a way to translate URLs according to the active language. See the internationalization documentation for more information.\n\nIf the paths and converters syntax isn’t sufficient for defining your URL patterns, you can also use regular expressions. To do so, use instead of . In Python regular expressions, the syntax for named regular expression groups is , where is the name of the group and is some pattern to match. Here’s the example URLconf from earlier, rewritten using regular expressions: This accomplishes roughly the same thing as the previous example, except:\n• None The exact URLs that will match are slightly more constrained. For example, the year 10000 will no longer match since the year integers are constrained to be exactly four digits long.\n• None Each captured argument is sent to the view as a string, regardless of what sort of match the regular expression makes. When switching from using to or vice versa, it’s particularly important to be aware that the type of the view arguments may change, and so you may need to adapt your views. As well as the named group syntax, e.g. , you can also use the shorter unnamed group, e.g. . This usage isn’t particularly recommended as it makes it easier to accidentally introduce errors between the intended meaning of a match and the arguments of the view. In either case, using only one style within a given regex is recommended. When both styles are mixed, any unnamed groups are ignored and only named groups are passed to the view function. Regular expressions allow nested arguments, and Django will resolve them and pass them to the view. When reversing, Django will try to fill in all outer captured arguments, ignoring any nested captured arguments. Consider the following URL patterns which optionally take a page argument: Both patterns use nested arguments and will resolve: for example, will result in a match to with two positional arguments: and . The second pattern for will match with keyword argument set to 2. The outer argument in this case is a non-capturing argument . The view needs the outermost captured argument to be reversed, or no arguments in this case, while can be reversed with either no arguments or a value for . Nested captured arguments create a strong coupling between the view arguments and the URL as illustrated by : the view receives part of the URL ( ) instead of only the value the view is interested in. This coupling is even more pronounced when reversing, since to reverse the view we need to pass the piece of URL instead of the page number. As a rule of thumb, only capture the values the view needs to work with and use non-capturing arguments when the regular expression needs an argument but the view ignores it.\n\nAt any point, your can “include” other URLconf modules. This essentially “roots” a set of URLs below other ones. For example, here’s an excerpt of the URLconf for the Django website itself. It includes a number of other URLconfs: Whenever Django encounters , it chops off whatever part of the URL matched up to that point and sends the remaining string to the included URLconf for further processing. Another possibility is to include additional URL patterns by using a list of instances. For example, consider this URLconf: In this example, the URL will be handled by the Django view. This can be used to remove redundancy from URLconfs where a single pattern prefix is used repeatedly. For example, consider this URLconf: We can improve this by stating the common path prefix only once and grouping the suffixes that differ: An included URLconf receives any captured parameters from parent URLconfs, so the following example is valid: In the above example, the captured variable is passed to the included URLconf, as expected.\n\nURLconfs have a hook that lets you pass extra arguments to your view functions, as a Python dictionary. The function can take an optional third argument which should be a dictionary of extra keyword arguments to pass to the view function. In this example, for a request to , Django will call . This technique is used in the syndication framework to pass metadata and options to views. It’s possible to have a URL pattern which captures named keyword arguments, and also passes arguments with the same names in its dictionary of extra arguments. When this happens, the arguments in the dictionary will be used instead of the arguments captured in the URL. Similarly, you can pass extra options to and each line in the included URLconf will be passed the extra options. For example, these two URLconf sets are functionally identical: Note that extra options will always be passed to every line in the included URLconf, regardless of whether the line’s view actually accepts those options as valid. For this reason, this technique is only useful if you’re certain that every view in the included URLconf accepts the extra options you’re passing.\n\nA common need when working on a Django project is the possibility to obtain URLs in their final forms either for embedding in generated content (views and assets URLs, URLs shown to the user, etc.) or for handling of the navigation flow on the server side (redirections, etc.) It is strongly desirable to avoid hard-coding these URLs (a laborious, non-scalable and error-prone strategy). Equally dangerous is devising ad-hoc mechanisms to generate URLs that are parallel to the design described by the URLconf, which can result in the production of URLs that become stale over time. In other words, what’s needed is a DRY mechanism. Among other advantages it would allow evolution of the URL design without having to go over all the project source code to search and replace outdated URLs. The primary piece of information we have available to get a URL is an identification (e.g. the name) of the view in charge of handling it. Other pieces of information that necessarily must participate in the lookup of the right URL are the types (positional, keyword) and values of the view arguments. Django provides a solution such that the URL mapper is the only repository of the URL design. You feed it with your URLconf and then it can be used in both directions:\n• None Starting with a URL requested by the user/browser, it calls the right Django view providing any arguments it might need with their values as extracted from the URL.\n• None Starting with the identification of the corresponding Django view plus the values of arguments that would be passed to it, obtain the associated URL. The first one is the usage we’ve been discussing in the previous sections. The second one is what is known as reverse resolution of URLs, reverse URL matching, reverse URL lookup, or simply URL reversing. Django provides tools for performing URL reversing that match the different layers where URLs are needed:\n• None In templates: Using the template tag.\n• None In Python code: Using the function.\n• None In higher level code related to handling of URLs of Django model instances: The method. Consider again this URLconf entry: According to this design, the URL for the archive corresponding to year nnnn is . You can obtain these in template code by using: 2012 Archive {# Or with the year in a template context variable: #} Archive If, for some reason, it was decided that the URLs where content for yearly article archives are published at should be changed then you would only need to change the entry in the URLconf. In some scenarios where views are of a generic nature, a many-to-one relationship might exist between URLs and views. For these cases the view name isn’t a good enough identifier for it when comes the time of reversing URLs. Read the next section to know about the solution Django provides for this.\n\nIn order to perform URL reversing, you’ll need to use named URL patterns as done in the examples above. The string used for the URL name can contain any characters you like. You are not restricted to valid Python names. When naming URL patterns, choose names that are unlikely to clash with other applications’ choice of names. If you call your URL pattern and another application does the same thing, the URL that finds depends on whichever pattern is last in your project’s list. Putting a prefix on your URL names, perhaps derived from the application name (such as instead of ), decreases the chance of collision. You can deliberately choose the same URL name as another application if you want to override a view. For example, a common use case is to override the . Parts of Django and most third-party apps assume that this view has a URL pattern with the name . If you have a custom login view and give its URL the name , will find your custom view as long as it’s in after is included (if that’s included at all). You may also use the same name for multiple URL patterns if they differ in their arguments. In addition to the URL name, matches the number of arguments and the names of the keyword arguments. Path converters can also raise to indicate no match, see Registering custom path converters for details.\n\nURL namespaces allow you to uniquely reverse named URL patterns even if different applications use the same URL names. It’s a good practice for third-party apps to always use namespaced URLs (as we did in the tutorial). Similarly, it also allows you to reverse URLs if multiple instances of an application are deployed. In other words, since multiple instances of a single application will share named URLs, namespaces provide a way to tell these named URLs apart. Django applications that make proper use of URL namespacing can be deployed more than once for a particular site. For example has an class which allows you to deploy more than one instance of the admin. In a later example, we’ll discuss the idea of deploying the polls application from the tutorial in two different locations so we can serve the same functionality to two different audiences (authors and publishers). A URL namespace comes in two parts, both of which are strings: This describes the name of the application that is being deployed. Every instance of a single application will have the same application namespace. For example, Django’s admin application has the somewhat predictable application namespace of . This identifies a specific instance of an application. Instance namespaces should be unique across your entire project. However, an instance namespace can be the same as the application namespace. This is used to specify a default instance of an application. For example, the default Django admin instance has an instance namespace of . Namespaced URLs are specified using the operator. For example, the main index page of the admin application is referenced using . This indicates a namespace of , and a named URL of . Namespaces can also be nested. The named URL would look for a pattern named in the namespace that is itself defined within the top-level namespace . When given a namespaced URL (e.g. ) to resolve, Django splits the fully qualified name into parts and then tries the following lookup:\n• None First, Django looks for a matching application namespace (in this example, ). This will yield a list of instances of that application.\n• None If there is a current application defined, Django finds and returns the URL resolver for that instance. The current application can be specified with the argument to the function. The template tag uses the namespace of the currently resolved view as the current application in a . You can override this default by setting the current application on the attribute.\n• None If there is no current application, Django looks for a default application instance. The default application instance is the instance that has an instance namespace matching the application namespace (in this example, an instance of called ).\n• None If there is no default application instance, Django will pick the last deployed instance of the application, whatever its instance name may be.\n• None If the provided namespace doesn’t match an application namespace in step 1, Django will attempt a direct lookup of the namespace as an instance namespace. If there are nested namespaces, these steps are repeated for each part of the namespace until only the view name is unresolved. The view name will then be resolved into a URL in the namespace that has been found. To show this resolution strategy in action, consider an example of two instances of the application from the tutorial: one called and one called . Assume we have enhanced that application so that it takes the instance namespace into consideration when creating and displaying polls. Using this setup, the following lookups are possible:\n• None If one of the instances is current - say, if we were rendering the detail page in the instance - will resolve to the index page of the instance; i.e. both of the following will result in . In the method of a class-based view:\n• None If there is no current instance - say, if we were rendering a page somewhere else on the site - will resolve to the last registered instance of . Since there is no default instance (instance namespace of ), the last instance of that is registered will be used. This would be since it’s declared last in the .\n• None will always resolve to the index page of the instance (and likewise for ) . If there were also a default instance - i.e., an instance named - the only change from above would be in the case where there is no current instance (the second item in the list above). In this case would resolve to the index page of the default instance instead of the instance declared last in . Application namespaces of included URLconfs can be specified in two ways. Firstly, you can set an attribute in the included URLconf module, at the same level as the attribute. You have to pass the actual module, or a string reference to the module, to , not the list of itself. The URLs defined in will have an application namespace . Secondly, you can include an object that contains embedded namespace data. If you a list of or instances, the URLs contained in that object will be added to the global namespace. However, you can also a 2-tuple containing: This will include the nominated URL patterns into the given application namespace. The instance namespace can be specified using the argument to . If the instance namespace is not specified, it will default to the included URLconf’s application namespace. This means it will also be the default instance for that namespace."
    },
    {
        "link": "https://medium.com/@ukemeboswilson/mastering-url-routing-in-django-rest-framework-a-comprehensive-guide-4c7bc85d516d",
        "document": "Django Rest Framework (DRF) stands out as a powerful and flexible toolkit for building Web APIs in Django. When building APIs, Django Rest Framework (DRF) extends this routing system to make it easy to create RESTful endpoints.\n\nDjango’s URL routing system allows you to map URLs to views, enabling you to handle various HTTP methods (GET, POST, PUT, DELETE) and parameters.\n\nURLs map incoming HTTP requests to the appropriate views, which handle the requests and return responses.\n\nLet’s consider this analogy of a postal service to visualize DRF URLs.\n\nIn a postal service, each house or building has a unique address. The post office receives letters and mails, sorts them, and sends each one to the correct address. After receiving the mail, the recipient can in turn send back another mail to the initial sender, and the post office will ensure the returned mail reaches the specific recipient.\n\nIn Django Rest Framework (DRF), each API endpoint has a unique URL, analogous to unique houses. This unique address helps identify the specific location where the mail (HTTP request) should be delivered. The router maps each URL to the appropriate view, acting like the post office. It receives incoming HTTP requests, determines the correct view to handle the request based on the URL, and sends the request to the appropriate view. Sending the mails corresponds to the HTTP requests, while the returned mails represent the HTTP responses.\n\nTo demonstrate these views, lets quickly set up a Django project and a Django app called urlProject and urlApp respectively. (if you need more insight into Django projects and Django Apps, check here)\n\nAdd the urlApp to the list of installed apps in settings.py file of the urlProject directory\n\nSet up a model. (check here for more details about models)\n\nSet up serializers. (check here for more details about serializers)\n\nThis uses traditional function-based views to handle requests and defining URL patterns in the list for a simpler and more customized behavior.\n\nThis uses the class-based views (CBVs) for handling requests and defining URL patterns in the list.\n\nThis automatically generate URL patterns for standard CRUD operations. The viewsets defines common actions (list, create, retrieve, update, delete) while the Router automatically generates the URL patterns.\n\nNested routers allow you to define URL patterns for nested resources in a hierarchical manner, making your API URLs more intuitive and organized\n\nThis allows the creation of URL patterns for resources with parent-child relationships.\n\nThe NestedDefaultRouter generates nested URLs like authors/<author_pk>/books/ , allowing access to books of a specific author.\n\nThis gives you the ability to add more specific endpoints or actions to your API. This is done using the `@action` decorator from viewsets.\n\nYou can specify whether the action applies to a single instance (detail=True) or the entire collection (detail=False) as well as the method that the action is being applied to.\n\nIn conclusion, Django Rest Framework (DRF) provides a powerful and flexible way to manage URLs in your API. By leveraging viewsets and routers, you can easily define standard CRUD operations for your resources.\n\nThe use of viewsets allows you to encapsulate the logic for handling different HTTP methods in a single class, while routers automatically generate the necessary URL patterns.\n\nFor more customized and specific needs, the @action decorator allows you to add custom endpoints, enhancing the functionality of your API without complicating your URL configuration\n\nThe best way to solidify your understanding of DRF URL routing is through hands-on practice.\n\nLet’s Get in Touch! Follow me on:\n\nYou can read other of my Medium Articles here"
    },
    {
        "link": "https://stackoverflow.com/questions/66699673/proper-practice-for-url-structure-with-django",
        "document": "I've already partially solved an issue I was struggling with but I would like some clarity on if this is the right way to do it in the first place.\n\nUltimately, I wanted to my URL's to follow something like this: www.whatever.com/company/{company_id}/person/{patient_id} (i.e. whatever.com/company/4/patient/2)\n\nThat's not actually perfect because what I really want is the name of the company and patient where the ID is, so www.whatever.com/company/ryan-corp/patient/jim-jones. I'll leave that for another day for now.\n\nWhat I ended up doing to get the result with the ID is this:\n\nThis doesn't feel like I am following a best practice and I feel like I literally guessed to get this working by reading the documentation found here: https://docs.djangoproject.com/en/3.1/topics/http/urls/\n\nIt esentially laid out how Django processes the URL's and I noticed that it basically grabs each part of the URL as kwargss. Which is why I passed the company variable in the patient_detail function in views. Then I took a guess and added and it worked.\n\nWhat is the best way to actually achieve this result in a Django approved method? Again, it works but I feel like this is a hack and there is a better way."
    },
    {
        "link": "https://jasspencer.medium.com/urls-in-django-f452339141d1",
        "document": "In any application or project that you work on, having route paths or urls adds an extra level of functionality to improve the user experience. Being able to guide the user from place to place with navigation makes it easier for the creator to have the user see what they want the user to see. In React, there is React Router, in Rails there is the ‘routes.rb’ file. Today, I’m diving into how to configure urls in Django.\n\nBefore getting into it, I do use the terms ‘route’, ‘path’, and ‘url’ pretty interchangeably. They are pretty much the same thing. The url address determines where to go in the project which then displays something to the user. Don’t get too confused.\n\nA URL (Uniform Resource Locator) commonly referred to as a web address. Is whatever is displayed in your browsers web address bar. Whatever is typed or displayed represents a path that the user (that’s you) is trying to get to. If that path exists, what ever the path results in will come up on your screen. Maybe it’s the login page, or where you can edit your profile, or write that amazing blog post. If you build your own project that is larger than a single page, you need to have ways to direct the user from place to place. Those typically can be done with links, but in order for those links to work, you need to have routes planned on the back end. In the case of Django, it works like this.\n\nUpon creating a new project in Django, you will find a ‘urls.py’ file, and if you open it you will see something like this:\n\nWhat lines like this do is build out a template for a url. If that url begins with ‘admin’, Django will try to find the corresponding view and do whatever action is defined in that view.\n\nThis is also where we can add our own urls, and we can link them to other apps that have been created in the project. In the following examples, I’mg going to reference code from a social media site I built. So in that same ‘urls.py’ file I added:\n\nThe empty quotes in the second url line means that it will be the root path for the application, or the default spot the user will end up at upon using the application.\n\nBoth of the new lines mean that Django will look in the landing and social app folders and look at the urls. Those files aren’t automatically created to they need to manually be done in whatever code editor you are using. Let’s take a look over to my ‘landing/urls.py’ file and see what I setup on the other side.\n\nAs I want to render whatever is in the Index view. I import it at the top of the file. When defining the url, I use the ‘as_view()’ method on the index view, and then I give that url the name of ‘index’. Naming urls make it easier to reference them in template throughout the project.\n\nBecause the url is rendering the Index as a view, I need to tell that view what to render in order to complete the url. In my Index view I tell it:\n\nNow I build a template in the landing app called ‘index.html’ and whatever code is in there will be displayed to the user!\n\nTo reference urls in other templates is very simple, and it has to do with naming urls as shown above. Django has a tag syntax which causes some of logic like a loop to run. Using ‘{% %}’ will run what ever code is placed in side those tags, so if we want to build our url into a link tag, we can simply:\n\nThe class part of that tag is just some styling, don’t get too caught up on it.\n\nThis will render a link to the user that when clicked, will navigate the user to the index url that we have defined!\n\nUnderstanding urls is essential to building out any project no matter what the framework. It greatly improves the user experience and more importantly, helps to show off the great code you’ve worked so hard on!"
    },
    {
        "link": "https://learntube.ai/blog/uncategorized/djangos-url-routing-system-explained",
        "document": "Django’s URL routing system is a powerful feature that allows developers to map URLs to views and functions within their application. This system is an integral part of the Django framework and is used to build clean, understandable, and maintainable web applications. In this blog, we will explain Django’s URL routing system in detail and how it works.\n\nURL routing is the process of mapping a URL to a view function in a web application. In simple terms, it is the process of handling incoming requests and directing them to the appropriate view function to generate a response. URL routing plays a crucial role in the architecture of web applications and is responsible for handling the client-side requests and responses.\n\nDjango’s URL routing system is built on top of a regular expression (regex) based matching mechanism. It works by defining a set of URL patterns that are matched against the requested URL. Each URL pattern is associated with a view function that generates a response when the pattern is matched.\n\nTo define a URL pattern, you need to create a URL configuration file. This file is typically named urls.py and is located in the root directory of your Django application. The urls.py file contains a list of URL patterns that are matched against incoming requests.\n\nHere is an example of how to define a URL pattern in Django:\n\nIn this example, we are defining a URL pattern that matches the URL /my-url/ and associates it with the view function my_view_function.\n\nDjango’s URL routing system also supports capturing URL parameters and passing them to the view function as arguments. This is useful when you need to handle dynamic URLs that contain variable components.\n\nHere is an example of how to capture a URL parameter in Django:\n\nIn this example, we are defining a URL pattern that matches the URL /my-url/1/, where 1 is a variable component that can be captured and passed to the view function as an argument.\n\nDjango’s URL routing system also supports regular expressions to match complex URL patterns. This allows developers to build more flexible and dynamic URL configurations.\n\nHere is an example of how to use regular expressions in Django’s URL routing system:\n\nIn this example, we are using a regular expression to match URLs that contain a year in the format of YYYY. The year value is captured and passed to the view function as an argument.\n\nDjango’s URL routing system also supports reverse URL resolution, which is the process of generating URLs based on their corresponding view functions. This is useful when you need to dynamically generate URLs in your application, such as for redirecting users after form submissions or linking to other pages.\n\nHere is an example of how to use reverse URL resolution in Django:\n\nIn this example, we are using the reverse() function to generate the URL associated with the view function named my_url. The resulting url variable would contain the string /my-url/.\n\nDjango’s URL routing system also supports namespace URL routing, which is the process of grouping related URL patterns under a common namespace. This is useful when you have multiple applications in your Django project that share similar URL patterns.\n\nHere is an example of how to use namespace URL routing in Django:\n\nIn this example, we are defining a namespace for our myapp application and including its URL patterns under that namespace.\n\nDjango’s URL routing system can also be extended using middleware. Middleware is a way to modify the behavior of the request/response processing pipeline in Django. URL routing middleware can be used to dynamically modify or redirect incoming requests based on their URLs.\n\nHere is an example of how to use URL routing middleware in Django:\n\n# Do something with the request\n\nIn this example, we are defining a custom middleware class that checks the incoming request’s path and performs some action if it matches the URL pattern /my-url/.\n\nDjango’s URL routing system is a fundamental feature of the Django framework that allows developers to map URLs to view functions in their web applications. It provides a powerful and flexible way to handle incoming requests and generate appropriate responses. With support for capturing URL parameters, using regular expressions, reverse URL resolution, namespace URL routing, and middleware, Django’s URL routing system provides a wide range of functionality for building dynamic and scalable web applications.\n\nIf you’re looking to enhance your expertise in Django, LearnTube has got you covered with an array of online courses tailored to your needs. With the help of our specialized learning app and WhatsApp bot, you can enjoy a seamless learning experience. Our platform offers an extensive range of courses that cater to both novices and seasoned learners. For valuable insights, explore our diverse selection of courses on our website."
    }
]