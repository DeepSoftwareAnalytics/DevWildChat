[
    {
        "link": "https://go.dev/doc/effective_go",
        "document": "Go is a new language. Although it borrows ideas from existing languages, it has unusual properties that make effective Go programs different in character from programs written in its relatives. A straightforward translation of a C++ or Java program into Go is unlikely to produce a satisfactory result—Java programs are written in Java, not Go. On the other hand, thinking about the problem from a Go perspective could produce a successful but quite different program. In other words, to write Go well, it's important to understand its properties and idioms. It's also important to know the established conventions for programming in Go, such as naming, formatting, program construction, and so on, so that programs you write will be easy for other Go programmers to understand.\n\nThis document gives tips for writing clear, idiomatic Go code. It augments the language specification, the Tour of Go, and How to Write Go Code, all of which you should read first.\n\nNote added January, 2022: This document was written for Go's release in 2009, and has not been updated significantly since. Although it is a good guide to understand how to use the language itself, thanks to the stability of the language, it says little about the libraries and nothing about significant changes to the Go ecosystem since it was written, such as the build system, testing, modules, and polymorphism. There are no plans to update it, as so much has happened and a large and growing set of documents, blogs, and books do a fine job of describing modern Go usage. Effective Go continues to be useful, but the reader should understand it is far from a complete guide. See issue 28782 for context.\n\nThe Go package sources are intended to serve not only as the core library but also as examples of how to use the language. Moreover, many of the packages contain working, self-contained executable examples you can run directly from the go.dev web site, such as this one (if necessary, click on the word \"Example\" to open it up). If you have a question about how to approach a problem or how something might be implemented, the documentation, code and examples in the library can provide answers, ideas and background.\n\nFormatting issues are the most contentious but the least consequential. People can adapt to different formatting styles but it's better if they don't have to, and less time is devoted to the topic if everyone adheres to the same style. The problem is how to approach this Utopia without a long prescriptive style guide.\n\nWith Go we take an unusual approach and let the machine take care of most formatting issues. The program (also available as , which operates at the package level rather than source file level) reads a Go program and emits the source in a standard style of indentation and vertical alignment, retaining and if necessary reformatting comments. If you want to know how to handle some new layout situation, run ; if the answer doesn't seem right, rearrange your program (or file a bug about ), don't work around it.\n\nAs an example, there's no need to spend time lining up the comments on the fields of a structure. will do that for you. Given the declaration\n\nwill line up the columns:\n\nAll Go code in the standard packages has been formatted with .\n\nGo provides C-style block comments and C++-style line comments. Line comments are the norm; block comments appear mostly as package comments, but are useful within an expression or to disable large swaths of code.\n\nComments that appear before top-level declarations, with no intervening newlines, are considered to document the declaration itself. These “doc comments” are the primary documentation for a given Go package or command. For more about doc comments, see “Go Doc Comments”.\n\nNames are as important in Go as in any other language. They even have semantic effect: the visibility of a name outside a package is determined by whether its first character is upper case. It's therefore worth spending a little time talking about naming conventions in Go programs.\n\nWhen a package is imported, the package name becomes an accessor for the contents. After\n\nthe importing package can talk about . It's helpful if everyone using the package can use the same name to refer to its contents, which implies that the package name should be good: short, concise, evocative. By convention, packages are given lower case, single-word names; there should be no need for underscores or mixedCaps. Err on the side of brevity, since everyone using your package will be typing that name. And don't worry about collisions a priori. The package name is only the default name for imports; it need not be unique across all source code, and in the rare case of a collision the importing package can choose a different name to use locally. In any case, confusion is rare because the file name in the import determines just which package is being used.\n\nAnother convention is that the package name is the base name of its source directory; the package in is imported as but has name , not and not .\n\nThe importer of a package will use the name to refer to its contents, so exported names in the package can use that fact to avoid repetition. (Don't use the notation, which can simplify tests that must run outside the package they are testing, but should otherwise be avoided.) For instance, the buffered reader type in the package is called , not , because users see it as , which is a clear, concise name. Moreover, because imported entities are always addressed with their package name, does not conflict with . Similarly, the function to make new instances of —which is the definition of a constructor in Go—would normally be called , but since is the only type exported by the package, and since the package is called , it's called just , which clients of the package see as . Use the package structure to help you choose good names.\n\nAnother short example is ; reads well and would not be improved by writing . Long names don't automatically make things more readable. A helpful doc comment can often be more valuable than an extra long name.\n\nGo doesn't provide automatic support for getters and setters. There's nothing wrong with providing getters and setters yourself, and it's often appropriate to do so, but it's neither idiomatic nor necessary to put into the getter's name. If you have a field called (lower case, unexported), the getter method should be called (upper case, exported), not . The use of upper-case names for export provides the hook to discriminate the field from the method. A setter function, if needed, will likely be called . Both names read well in practice:\n\nBy convention, one-method interfaces are named by the method name plus an -er suffix or similar modification to construct an agent noun: , , , etc.\n\nThere are a number of such names and it's productive to honor them and the function names they capture. , , , , and so on have canonical signatures and meanings. To avoid confusion, don't give your method one of those names unless it has the same signature and meaning. Conversely, if your type implements a method with the same meaning as a method on a well-known type, give it the same name and signature; call your string-converter method not .\n\nFinally, the convention in Go is to use or rather than underscores to write multiword names.\n\nLike C, Go's formal grammar uses semicolons to terminate statements, but unlike in C, those semicolons do not appear in the source. Instead the lexer uses a simple rule to insert semicolons automatically as it scans, so the input text is mostly free of them.\n\nThe rule is this. If the last token before a newline is an identifier (which includes words like and ), a basic literal such as a number or string constant, or one of the tokens\n\nthe lexer always inserts a semicolon after the token. This could be summarized as, “if the newline comes after a token that could end a statement, insert a semicolon”.\n\nA semicolon can also be omitted immediately before a closing brace, so a statement such as\n\nneeds no semicolons. Idiomatic Go programs have semicolons only in places such as loop clauses, to separate the initializer, condition, and continuation elements. They are also necessary to separate multiple statements on a line, should you write code that way.\n\nOne consequence of the semicolon insertion rules is that you cannot put the opening brace of a control structure ( , , , or ) on the next line. If you do, a semicolon will be inserted before the brace, which could cause unwanted effects. Write them like this\n\nnot like this\n\nThe control structures of Go are related to those of C but differ in important ways. There is no or loop, only a slightly generalized ; is more flexible; and accept an optional initialization statement like that of ; and statements take an optional label to identify what to break or continue; and there are new control structures including a type switch and a multiway communications multiplexer, . The syntax is also slightly different: there are no parentheses and the bodies must always be brace-delimited.\n\nIn Go a simple looks like this:\n\nMandatory braces encourage writing simple statements on multiple lines. It's good style to do so anyway, especially when the body contains a control statement such as a or .\n\nSince and accept an initialization statement, it's common to see one used to set up a local variable.\n\nIn the Go libraries, you'll find that when an statement doesn't flow into the next statement—that is, the body ends in , , , or —the unnecessary is omitted.\n\nThis is an example of a common situation where code must guard against a sequence of error conditions. The code reads well if the successful flow of control runs down the page, eliminating error cases as they arise. Since error cases tend to end in statements, the resulting code needs no statements.\n\nAn aside: The last example in the previous section demonstrates a detail of how the short declaration form works. The declaration that calls reads,\n\nThis statement declares two variables, and . A few lines later, the call to reads,\n\nwhich looks as if it declares and . Notice, though, that appears in both statements. This duplication is legal: is declared by the first statement, but only re-assigned in the second. This means that the call to uses the existing variable declared above, and just gives it a new value.\n\nIn a declaration a variable may appear even if it has already been declared, provided:\n• this declaration is in the same scope as the existing declaration of (if is already declared in an outer scope, the declaration will create a new variable §),\n• the corresponding value in the initialization is assignable to , and\n• there is at least one other variable that is created by the declaration.\n\nThis unusual property is pure pragmatism, making it easy to use a single value, for example, in a long chain. You'll see it used often.\n\n§ It's worth noting here that in Go the scope of function parameters and return values is the same as the function body, even though they appear lexically outside the braces that enclose the body.\n\nThe Go loop is similar to—but not the same as—C's. It unifies and and there is no . There are three forms, only one of which has semicolons.\n\nShort declarations make it easy to declare the index variable right in the loop.\n\nIf you're looping over an array, slice, string, or map, or reading from a channel, a clause can manage the loop.\n\nIf you only need the first item in the range (the key or index), drop the second:\n\nIf you only need the second item in the range (the value), use the blank identifier, an underscore, to discard the first:\n\nThe blank identifier has many uses, as described in a later section.\n\nFor strings, the does more work for you, breaking out individual Unicode code points by parsing the UTF-8. Erroneous encodings consume one byte and produce the replacement rune U+FFFD. (The name (with associated builtin type) is Go terminology for a single Unicode code point. See the language specification for details.) The loop\n\nFinally, Go has no comma operator and and are statements not expressions. Thus if you want to run multiple variables in a you should use parallel assignment (although that precludes and ).\n\nGo's is more general than C's. The expressions need not be constants or even integers, the cases are evaluated top to bottom until a match is found, and if the has no expression it switches on . It's therefore possible—and idiomatic—to write an - - - chain as a .\n\nThere is no automatic fall through, but cases can be presented in comma-separated lists.\n\nAlthough they are not nearly as common in Go as some other C-like languages, statements can be used to terminate a early. Sometimes, though, it's necessary to break out of a surrounding loop, not the switch, and in Go that can be accomplished by putting a label on the loop and \"breaking\" to that label. This example shows both uses.\n\nOf course, the statement also accepts an optional label but it applies only to loops.\n\nTo close this section, here's a comparison routine for byte slices that uses two statements:\n\nA switch can also be used to discover the dynamic type of an interface variable. Such a type switch uses the syntax of a type assertion with the keyword inside the parentheses. If the switch declares a variable in the expression, the variable will have the corresponding type in each clause. It's also idiomatic to reuse the name in such cases, in effect declaring a new variable with the same name but a different type in each case.\n\nOne of Go's unusual features is that functions and methods can return multiple values. This form can be used to improve on a couple of clumsy idioms in C programs: in-band error returns such as for and modifying an argument passed by address.\n\nIn C, a write error is signaled by a negative count with the error code secreted away in a volatile location. In Go, can return a count and an error: “Yes, you wrote some bytes but not all of them because you filled the device”. The signature of the method on files from package is:\n\nand as the documentation says, it returns the number of bytes written and a non-nil when . This is a common style; see the section on error handling for more examples.\n\nA similar approach obviates the need to pass a pointer to a return value to simulate a reference parameter. Here's a simple-minded function to grab a number from a position in a byte slice, returning the number and the next position.\n\nYou could use it to scan the numbers in an input slice like this:\n\nThe return or result \"parameters\" of a Go function can be given names and used as regular variables, just like the incoming parameters. When named, they are initialized to the zero values for their types when the function begins; if the function executes a statement with no arguments, the current values of the result parameters are used as the returned values.\n\nThe names are not mandatory but they can make code shorter and clearer: they're documentation. If we name the results of it becomes obvious which returned is which.\n\nBecause named results are initialized and tied to an unadorned return, they can simplify as well as clarify. Here's a version of that uses them well:\n\nGo's statement schedules a function call (the deferred function) to be run immediately before the function executing the returns. It's an unusual but effective way to deal with situations such as resources that must be released regardless of which path a function takes to return. The canonical examples are unlocking a mutex or closing a file.\n\nDeferring a call to a function such as has two advantages. First, it guarantees that you will never forget to close the file, a mistake that's easy to make if you later edit the function to add a new return path. Second, it means that the close sits near the open, which is much clearer than placing it at the end of the function.\n\nThe arguments to the deferred function (which include the receiver if the function is a method) are evaluated when the defer executes, not when the call executes. Besides avoiding worries about variables changing values as the function executes, this means that a single deferred call site can defer multiple function executions. Here's a silly example.\n\nDeferred functions are executed in LIFO order, so this code will cause to be printed when the function returns. A more plausible example is a simple way to trace function execution through the program. We could write a couple of simple tracing routines like this:\n\nWe can do better by exploiting the fact that arguments to deferred functions are evaluated when the executes. The tracing routine can set up the argument to the untracing routine. This example:\n\nFor programmers accustomed to block-level resource management from other languages, may seem peculiar, but its most interesting and powerful applications come precisely from the fact that it's not block-based but function-based. In the section on and we'll see another example of its possibilities.\n\nGo has two allocation primitives, the built-in functions and . They do different things and apply to different types, which can be confusing, but the rules are simple. Let's talk about first. It's a built-in function that allocates memory, but unlike its namesakes in some other languages it does not initialize the memory, it only zeros it. That is, allocates zeroed storage for a new item of type and returns its address, a value of type . In Go terminology, it returns a pointer to a newly allocated zero value of type .\n\nSince the memory returned by is zeroed, it's helpful to arrange when designing your data structures that the zero value of each type can be used without further initialization. This means a user of the data structure can create one with and get right to work. For example, the documentation for states that \"the zero value for is an empty buffer ready to use.\" Similarly, does not have an explicit constructor or method. Instead, the zero value for a is defined to be an unlocked mutex.\n\nThe zero-value-is-useful property works transitively. Consider this type declaration.\n\nValues of type are also ready to use immediately upon allocation or just declaration. In the next snippet, both and will work correctly without further arrangement.\n\nSometimes the zero value isn't good enough and an initializing constructor is necessary, as in this example derived from package .\n\nThere's a lot of boilerplate in there. We can simplify it using a composite literal, which is an expression that creates a new instance each time it is evaluated.\n\nNote that, unlike in C, it's perfectly OK to return the address of a local variable; the storage associated with the variable survives after the function returns. In fact, taking the address of a composite literal allocates a fresh instance each time it is evaluated, so we can combine these last two lines.\n\nThe fields of a composite literal are laid out in order and must all be present. However, by labeling the elements explicitly as field value pairs, the initializers can appear in any order, with the missing ones left as their respective zero values. Thus we could say\n\nAs a limiting case, if a composite literal contains no fields at all, it creates a zero value for the type. The expressions and are equivalent.\n\nComposite literals can also be created for arrays, slices, and maps, with the field labels being indices or map keys as appropriate. In these examples, the initializations work regardless of the values of , , and , as long as they are distinct.\n\nBack to allocation. The built-in function args serves a purpose different from . It creates slices, maps, and channels only, and it returns an initialized (not zeroed) value of type (not ). The reason for the distinction is that these three types represent, under the covers, references to data structures that must be initialized before use. A slice, for example, is a three-item descriptor containing a pointer to the data (inside an array), the length, and the capacity, and until those items are initialized, the slice is . For slices, maps, and channels, initializes the internal data structure and prepares the value for use. For instance,\n\nallocates an array of 100 ints and then creates a slice structure with length 10 and a capacity of 100 pointing at the first 10 elements of the array. (When making a slice, the capacity can be omitted; see the section on slices for more information.) In contrast, returns a pointer to a newly allocated, zeroed slice structure, that is, a pointer to a slice value.\n\nThese examples illustrate the difference between and .\n\nRemember that applies only to maps, slices and channels and does not return a pointer. To obtain an explicit pointer allocate with or take the address of a variable explicitly.\n\nArrays are useful when planning the detailed layout of memory and sometimes can help avoid allocation, but primarily they are a building block for slices, the subject of the next section. To lay the foundation for that topic, here are a few words about arrays.\n\nThere are major differences between the ways arrays work in Go and C. In Go,\n• Arrays are values. Assigning one array to another copies all the elements.\n• In particular, if you pass an array to a function, it will receive a copy of the array, not a pointer to it.\n• The size of an array is part of its type. The types and are distinct.\n\nThe value property can be useful but also expensive; if you want C-like behavior and efficiency, you can pass a pointer to the array.\n\nBut even this style isn't idiomatic Go. Use slices instead.\n\nSlices wrap arrays to give a more general, powerful, and convenient interface to sequences of data. Except for items with explicit dimension such as transformation matrices, most array programming in Go is done with slices rather than simple arrays.\n\nSlices hold references to an underlying array, and if you assign one slice to another, both refer to the same array. If a function takes a slice argument, changes it makes to the elements of the slice will be visible to the caller, analogous to passing a pointer to the underlying array. A function can therefore accept a slice argument rather than a pointer and a count; the length within the slice sets an upper limit of how much data to read. Here is the signature of the method of the type in package :\n\nThe method returns the number of bytes read and an error value, if any. To read into the first 32 bytes of a larger buffer , slice (here used as a verb) the buffer.\n\nSuch slicing is common and efficient. In fact, leaving efficiency aside for the moment, the following snippet would also read the first 32 bytes of the buffer.\n\nThe length of a slice may be changed as long as it still fits within the limits of the underlying array; just assign it to a slice of itself. The capacity of a slice, accessible by the built-in function , reports the maximum length the slice may assume. Here is a function to append data to a slice. If the data exceeds the capacity, the slice is reallocated. The resulting slice is returned. The function uses the fact that and are legal when applied to the slice, and return 0.\n\nWe must return the slice afterwards because, although can modify the elements of , the slice itself (the run-time data structure holding the pointer, length, and capacity) is passed by value.\n\nThe idea of appending to a slice is so useful it's captured by the built-in function. To understand that function's design, though, we need a little more information, so we'll return to it later.\n\nGo's arrays and slices are one-dimensional. To create the equivalent of a 2D array or slice, it is necessary to define an array-of-arrays or slice-of-slices, like this:\n\nBecause slices are variable-length, it is possible to have each inner slice be a different length. That can be a common situation, as in our example: each line has an independent length.\n\nSometimes it's necessary to allocate a 2D slice, a situation that can arise when processing scan lines of pixels, for instance. There are two ways to achieve this. One is to allocate each slice independently; the other is to allocate a single array and point the individual slices into it. Which to use depends on your application. If the slices might grow or shrink, they should be allocated independently to avoid overwriting the next line; if not, it can be more efficient to construct the object with a single allocation. For reference, here are sketches of the two methods. First, a line at a time:\n\nAnd now as one allocation, sliced into lines:\n\nMaps are a convenient and powerful built-in data structure that associate values of one type (the key) with values of another type (the element or value). The key can be of any type for which the equality operator is defined, such as integers, floating point and complex numbers, strings, pointers, interfaces (as long as the dynamic type supports equality), structs and arrays. Slices cannot be used as map keys, because equality is not defined on them. Like slices, maps hold references to an underlying data structure. If you pass a map to a function that changes the contents of the map, the changes will be visible in the caller.\n\nMaps can be constructed using the usual composite literal syntax with colon-separated key-value pairs, so it's easy to build them during initialization.\n\nAssigning and fetching map values looks syntactically just like doing the same for arrays and slices except that the index doesn't need to be an integer.\n\nAn attempt to fetch a map value with a key that is not present in the map will return the zero value for the type of the entries in the map. For instance, if the map contains integers, looking up a non-existent key will return . A set can be implemented as a map with value type . Set the map entry to to put the value in the set, and then test it by simple indexing.\n\nSometimes you need to distinguish a missing entry from a zero value. Is there an entry for or is that 0 because it's not in the map at all? You can discriminate with a form of multiple assignment.\n\nFor obvious reasons this is called the “comma ok” idiom. In this example, if is present, will be set appropriately and will be true; if not, will be set to zero and will be false. Here's a function that puts it together with a nice error report:\n\nTo test for presence in the map without worrying about the actual value, you can use the blank identifier ( ) in place of the usual variable for the value.\n\nTo delete a map entry, use the built-in function, whose arguments are the map and the key to be deleted. It's safe to do this even if the key is already absent from the map.\n\nFormatted printing in Go uses a style similar to C's family but is richer and more general. The functions live in the package and have capitalized names: , , and so on. The string functions ( etc.) return a string rather than filling in a provided buffer.\n\nYou don't need to provide a format string. For each of , and there is another pair of functions, for instance and . These functions do not take a format string but instead generate a default format for each argument. The versions also insert a blank between arguments and append a newline to the output while the versions add blanks only if the operand on neither side is a string. In this example each line produces the same output.\n\nThe formatted print functions and friends take as a first argument any object that implements the interface; the variables and are familiar instances.\n\nHere things start to diverge from C. First, the numeric formats such as do not take flags for signedness or size; instead, the printing routines use the type of the argument to decide these properties.\n\nIf you just want the default conversion, such as decimal for integers, you can use the catchall format (for “value”); the result is exactly what and would produce. Moreover, that format can print any value, even arrays, slices, structs, and maps. Here is a print statement for the time zone map defined in the previous section.\n\nFor maps, and friends sort the output lexicographically by key.\n\nWhen printing a struct, the modified format annotates the fields of the structure with their names, and for any value the alternate format prints the value in full Go syntax.\n\n(Note the ampersands.) That quoted string format is also available through when applied to a value of type or . The alternate format will use backquotes instead if possible. (The format also applies to integers and runes, producing a single-quoted rune constant.) Also, works on strings, byte arrays and byte slices as well as on integers, generating a long hexadecimal string, and with a space in the format ( ) it puts spaces between the bytes.\n\nAnother handy format is , which prints the type of a value.\n\nIf you want to control the default format for a custom type, all that's required is to define a method with the signature on the type. For our simple type , that might look like this.\n\nto print in the format\n\nOur method is able to call because the print routines are fully reentrant and can be wrapped this way. There is one important detail to understand about this approach, however: don't construct a method by calling in a way that will recur into your method indefinitely. This can happen if the call attempts to print the receiver directly as a string, which in turn will invoke the method again. It's a common and easy mistake to make, as this example shows.\n\nIt's also easy to fix: convert the argument to the basic string type, which does not have the method.\n\nIn the initialization section we'll see another technique that avoids this recursion.\n\nAnother printing technique is to pass a print routine's arguments directly to another such routine. The signature of uses the type for its final argument to specify that an arbitrary number of parameters (of arbitrary type) can appear after the format.\n\nWithin the function , acts like a variable of type but if it is passed to another variadic function, it acts like a regular list of arguments. Here is the implementation of the function we used above. It passes its arguments directly to for the actual formatting.\n\nWe write after in the nested call to to tell the compiler to treat as a list of arguments; otherwise it would just pass as a single slice argument.\n\nThere's even more to printing than we've covered here. See the documentation for package for the details.\n\nBy the way, a parameter can be of a specific type, for instance for a min function that chooses the least of a list of integers:\n\nNow we have the missing piece we needed to explain the design of the built-in function. The signature of is different from our custom function above. Schematically, it's like this:\n\nwhere T is a placeholder for any given type. You can't actually write a function in Go where the type is determined by the caller. That's why is built in: it needs support from the compiler.\n\nWhat does is append the elements to the end of the slice and return the result. The result needs to be returned because, as with our hand-written , the underlying array may change. This simple example\n\nprints . So works a little like , collecting an arbitrary number of arguments.\n\nBut what if we wanted to do what our does and append a slice to a slice? Easy: use at the call site, just as we did in the call to above. This snippet produces identical output to the one above.\n\nWithout that , it wouldn't compile because the types would be wrong; is not of type .\n\nAlthough it doesn't look superficially very different from initialization in C or C++, initialization in Go is more powerful. Complex structures can be built during initialization and the ordering issues among initialized objects, even among different packages, are handled correctly.\n\nConstants in Go are just that—constant. They are created at compile time, even when defined as locals in functions, and can only be numbers, characters (runes), strings or booleans. Because of the compile-time restriction, the expressions that define them must be constant expressions, evaluatable by the compiler. For instance, is a constant expression, while is not because the function call to needs to happen at run time.\n\nIn Go, enumerated constants are created using the enumerator. Since can be part of an expression and expressions can be implicitly repeated, it is easy to build intricate sets of values.\n\nThe ability to attach a method such as to any user-defined type makes it possible for arbitrary values to format themselves automatically for printing. Although you'll see it most often applied to structs, this technique is also useful for scalar types such as floating-point types like .\n\nThe expression prints as , while prints as .\n\nThe use here of to implement 's method is safe (avoids recurring indefinitely) not because of a conversion but because it calls with , which is not a string format: will only call the method when it wants a string, and wants a floating-point value.\n\nVariables can be initialized just like constants but the initializer can be a general expression computed at run time.\n\nFinally, each source file can define its own niladic function to set up whatever state is required. (Actually each file can have multiple functions.) And finally means finally: is called after all the variable declarations in the package have evaluated their initializers, and those are evaluated only after all the imported packages have been initialized.\n\nBesides initializations that cannot be expressed as declarations, a common use of functions is to verify or repair correctness of the program state before real execution begins.\n\nAs we saw with , methods can be defined for any named type (except a pointer or an interface); the receiver does not have to be a struct.\n\nIn the discussion of slices above, we wrote an function. We can define it as a method on slices instead. To do this, we first declare a named type to which we can bind the method, and then make the receiver for the method a value of that type.\n\nThis still requires the method to return the updated slice. We can eliminate that clumsiness by redefining the method to take a pointer to a as its receiver, so the method can overwrite the caller's slice.\n\nIn fact, we can do even better. If we modify our function so it looks like a standard method, like this,\n\nthen the type satisfies the standard interface , which is handy. For instance, we can print into one.\n\nWe pass the address of a because only satisfies . The rule about pointers vs. values for receivers is that value methods can be invoked on pointers and values, but pointer methods can only be invoked on pointers.\n\nThis rule arises because pointer methods can modify the receiver; invoking them on a value would cause the method to receive a copy of the value, so any modifications would be discarded. The language therefore disallows this mistake. There is a handy exception, though. When the value is addressable, the language takes care of the common case of invoking a pointer method on a value by inserting the address operator automatically. In our example, the variable is addressable, so we can call its method with just . The compiler will rewrite that to for us.\n\nBy the way, the idea of using on a slice of bytes is central to the implementation of .\n\nInterfaces in Go provide a way to specify the behavior of an object: if something can do this, then it can be used here. We've seen a couple of simple examples already; custom printers can be implemented by a method while can generate output to anything with a method. Interfaces with only one or two methods are common in Go code, and are usually given a name derived from the method, such as for something that implements .\n\nA type can implement multiple interfaces. For instance, a collection can be sorted by the routines in package if it implements , which contains , , and , and it could also have a custom formatter. In this contrived example satisfies both.\n\nThe method of is recreating the work that already does for slices. (It also has complexity O(N²), which is poor.) We can share the effort (and also speed it up) if we convert the to a plain before calling .\n\nThis method is another example of the conversion technique for calling safely from a method. Because the two types ( and ) are the same if we ignore the type name, it's legal to convert between them. The conversion doesn't create a new value, it just temporarily acts as though the existing value has a new type. (There are other legal conversions, such as from integer to floating point, that do create a new value.)\n\nIt's an idiom in Go programs to convert the type of an expression to access a different set of methods. As an example, we could use the existing type to reduce the entire example to this:\n\nNow, instead of having implement multiple interfaces (sorting and printing), we're using the ability of a data item to be converted to multiple types ( , and ), each of which does some part of the job. That's more unusual in practice but can be effective.\n\nType switches are a form of conversion: they take an interface and, for each case in the switch, in a sense convert it to the type of that case. Here's a simplified version of how the code under turns a value into a string using a type switch. If it's already a string, we want the actual string value held by the interface, while if it has a method we want the result of calling the method.\n\nThe first case finds a concrete value; the second converts the interface into another interface. It's perfectly fine to mix types this way.\n\nWhat if there's only one type we care about? If we know the value holds a and we just want to extract it? A one-case type switch would do, but so would a type assertion. A type assertion takes an interface value and extracts from it a value of the specified explicit type. The syntax borrows from the clause opening a type switch, but with an explicit type rather than the keyword:\n\nand the result is a new value with the static type . That type must either be the concrete type held by the interface, or a second interface type that the value can be converted to. To extract the string we know is in the value, we could write:\n\nBut if it turns out that the value does not contain a string, the program will crash with a run-time error. To guard against that, use the \"comma, ok\" idiom to test, safely, whether the value is a string:\n\nIf the type assertion fails, will still exist and be of type string, but it will have the zero value, an empty string.\n\nAs an illustration of the capability, here's an - statement that's equivalent to the type switch that opened this section.\n\nIf a type exists only to implement an interface and will never have exported methods beyond that interface, there is no need to export the type itself. Exporting just the interface makes it clear the value has no interesting behavior beyond what is described in the interface. It also avoids the need to repeat the documentation on every instance of a common method.\n\nIn such cases, the constructor should return an interface value rather than the implementing type. As an example, in the hash libraries both and return the interface type . Substituting the CRC-32 algorithm for Adler-32 in a Go program requires only changing the constructor call; the rest of the code is unaffected by the change of algorithm.\n\nA similar approach allows the streaming cipher algorithms in the various packages to be separated from the block ciphers they chain together. The interface in the package specifies the behavior of a block cipher, which provides encryption of a single block of data. Then, by analogy with the package, cipher packages that implement this interface can be used to construct streaming ciphers, represented by the interface, without knowing the details of the block encryption.\n\nThe interfaces look like this:\n\nHere's the definition of the counter mode (CTR) stream, which turns a block cipher into a streaming cipher; notice that the block cipher's details are abstracted away:\n\napplies not just to one specific encryption algorithm and data source but to any implementation of the interface and any . Because they return interface values, replacing CTR encryption with other encryption modes is a localized change. The constructor calls must be edited, but because the surrounding code must treat the result only as a , it won't notice the difference.\n\nSince almost anything can have methods attached, almost anything can satisfy an interface. One illustrative example is in the package, which defines the interface. Any object that implements can serve HTTP requests.\n\nis itself an interface that provides access to the methods needed to return the response to the client. Those methods include the standard method, so an can be used wherever an can be used. is a struct containing a parsed representation of the request from the client.\n\nFor brevity, let's ignore POSTs and assume HTTP requests are always GETs; that simplification does not affect the way the handlers are set up. Here's a trivial implementation of a handler to count the number of times the page is visited.\n\n(Keeping with our theme, note how can print to an .) In a real server, access to would need protection from concurrent access. See the and packages for suggestions.\n\nFor reference, here's how to attach such a server to a node on the URL tree.\n\nBut why make a struct? An integer is all that's needed. (The receiver needs to be a pointer so the increment is visible to the caller.)\n\nWhat if your program has some internal state that needs to be notified that a page has been visited? Tie a channel to the web page.\n\nFinally, let's say we wanted to present on the arguments used when invoking the server binary. It's easy to write a function to print the arguments.\n\nHow do we turn that into an HTTP server? We could make a method of some type whose value we ignore, but there's a cleaner way. Since we can define a method for any type except pointers and interfaces, we can write a method for a function. The package contains this code:\n\nis a type with a method, , so values of that type can serve HTTP requests. Look at the implementation of the method: the receiver is a function, , and the method calls . That may seem odd but it's not that different from, say, the receiver being a channel and the method sending on the channel.\n\nTo make into an HTTP server, we first modify it to have the right signature.\n\nnow has the same signature as , so it can be converted to that type to access its methods, just as we converted to to access . The code to set it up is concise:\n\nWhen someone visits the page , the handler installed at that page has value and type . The HTTP server will invoke the method of that type, with as the receiver, which will in turn call (via the invocation inside ). The arguments will then be displayed.\n\nIn this section we have made an HTTP server from a struct, an integer, a channel, and a function, all because interfaces are just sets of methods, which can be defined for (almost) any type.\n\nWe've mentioned the blank identifier a couple of times now, in the context of loops and maps. The blank identifier can be assigned or declared with any value of any type, with the value discarded harmlessly. It's a bit like writing to the Unix file: it represents a write-only value to be used as a place-holder where a variable is needed but the actual value is irrelevant. It has uses beyond those we've seen already.\n\nThe use of a blank identifier in a loop is a special case of a general situation: multiple assignment.\n\nIf an assignment requires multiple values on the left side, but one of the values will not be used by the program, a blank identifier on the left-hand-side of the assignment avoids the need to create a dummy variable and makes it clear that the value is to be discarded. For instance, when calling a function that returns a value and an error, but only the error is important, use the blank identifier to discard the irrelevant value.\n\nOccasionally you'll see code that discards the error value in order to ignore the error; this is terrible practice. Always check error returns; they're provided for a reason.\n\nIt is an error to import a package or to declare a variable without using it. Unused imports bloat the program and slow compilation, while a variable that is initialized but not used is at least a wasted computation and perhaps indicative of a larger bug. When a program is under active development, however, unused imports and variables often arise and it can be annoying to delete them just to have the compilation proceed, only to have them be needed again later. The blank identifier provides a workaround.\n\nThis half-written program has two unused imports ( and ) and an unused variable ( ), so it will not compile, but it would be nice to see if the code so far is correct.\n\nTo silence complaints about the unused imports, use a blank identifier to refer to a symbol from the imported package. Similarly, assigning the unused variable to the blank identifier will silence the unused variable error. This version of the program does compile.\n\nBy convention, the global declarations to silence import errors should come right after the imports and be commented, both to make them easy to find and as a reminder to clean things up later.\n\nAn unused import like or in the previous example should eventually be used or removed: blank assignments identify code as a work in progress. But sometimes it is useful to import a package only for its side effects, without any explicit use. For example, during its function, the package registers HTTP handlers that provide debugging information. It has an exported API, but most clients need only the handler registration and access the data through a web page. To import the package only for its side effects, rename the package to the blank identifier:\n\nThis form of import makes clear that the package is being imported for its side effects, because there is no other possible use of the package: in this file, it doesn't have a name. (If it did, and we didn't use that name, the compiler would reject the program.)\n\nAs we saw in the discussion of interfaces above, a type need not declare explicitly that it implements an interface. Instead, a type implements the interface just by implementing the interface's methods. In practice, most interface conversions are static and therefore checked at compile time. For example, passing an to a function expecting an will not compile unless implements the interface.\n\nSome interface checks do happen at run-time, though. One instance is in the package, which defines a interface. When the JSON encoder receives a value that implements that interface, the encoder invokes the value's marshaling method to convert it to JSON instead of doing the standard conversion. The encoder checks this property at run time with a type assertion like:\n\nIf it's necessary only to ask whether a type implements an interface, without actually using the interface itself, perhaps as part of an error check, use the blank identifier to ignore the type-asserted value:\n\nOne place this situation arises is when it is necessary to guarantee within the package implementing the type that it actually satisfies the interface. If a type—for example, —needs a custom JSON representation, it should implement , but there are no static conversions that would cause the compiler to verify this automatically. If the type inadvertently fails to satisfy the interface, the JSON encoder will still work, but will not use the custom implementation. To guarantee that the implementation is correct, a global declaration using the blank identifier can be used in the package:\n\nIn this declaration, the assignment involving a conversion of a to a requires that implements , and that property will be checked at compile time. Should the interface change, this package will no longer compile and we will be on notice that it needs to be updated.\n\nThe appearance of the blank identifier in this construct indicates that the declaration exists only for the type checking, not to create a variable. Don't do this for every type that satisfies an interface, though. By convention, such declarations are only used when there are no static conversions already present in the code, which is a rare event.\n\nGo does not provide the typical, type-driven notion of subclassing, but it does have the ability to “borrow” pieces of an implementation by embedding types within a struct or interface.\n\nInterface embedding is very simple. We've mentioned the and interfaces before; here are their definitions.\n\nThe package also exports several other interfaces that specify objects that can implement several such methods. For instance, there is , an interface containing both and . We could specify by listing the two methods explicitly, but it's easier and more evocative to embed the two interfaces to form the new one, like this:\n\nThis says just what it looks like: A can do what a does and what a does; it is a union of the embedded interfaces. Only interfaces can be embedded within interfaces.\n\nThe same basic idea applies to structs, but with more far-reaching implications. The package has two struct types, and , each of which of course implements the analogous interfaces from package . And also implements a buffered reader/writer, which it does by combining a reader and a writer into one struct using embedding: it lists the types within the struct but does not give them field names.\n\nThe embedded elements are pointers to structs and of course must be initialized to point to valid structs before they can be used. The struct could be written as\n\nbut then to promote the methods of the fields and to satisfy the interfaces, we would also need to provide forwarding methods, like this:\n\nBy embedding the structs directly, we avoid this bookkeeping. The methods of embedded types come along for free, which means that not only has the methods of and , it also satisfies all three interfaces: , , and .\n\nThere's an important way in which embedding differs from subclassing. When we embed a type, the methods of that type become methods of the outer type, but when they are invoked the receiver of the method is the inner type, not the outer one. In our example, when the method of a is invoked, it has exactly the same effect as the forwarding method written out above; the receiver is the field of the , not the itself.\n\nEmbedding can also be a simple convenience. This example shows an embedded field alongside a regular, named field.\n\nThe type now has the , , and other methods of . We could have given the a field name, of course, but it's not necessary to do so. And now, once initialized, we can log to the :\n\nThe is a regular field of the struct, so we can initialize it in the usual way inside the constructor for , like this,\n\nIf we need to refer to an embedded field directly, the type name of the field, ignoring the package qualifier, serves as a field name, as it did in the method of our struct. Here, if we needed to access the of a variable , we would write , which would be useful if we wanted to refine the methods of .\n\nEmbedding types introduces the problem of name conflicts but the rules to resolve them are simple. First, a field or method hides any other item in a more deeply nested part of the type. If contained a field or method called , the field of would dominate it.\n\nSecond, if the same name appears at the same nesting level, it is usually an error; it would be erroneous to embed if the struct contained another field or method called . However, if the duplicate name is never mentioned in the program outside the type definition, it is OK. This qualification provides some protection against changes made to types embedded from outside; there is no problem if a field is added that conflicts with another field in another subtype if neither field is ever used.\n\nConcurrent programming is a large topic and there is space only for some Go-specific highlights here.\n\nConcurrent programming in many environments is made difficult by the subtleties required to implement correct access to shared variables. Go encourages a different approach in which shared values are passed around on channels and, in fact, never actively shared by separate threads of execution. Only one goroutine has access to the value at any given time. Data races cannot occur, by design. To encourage this way of thinking we have reduced it to a slogan:\n\nThis approach can be taken too far. Reference counts may be best done by putting a mutex around an integer variable, for instance. But as a high-level approach, using channels to control access makes it easier to write clear, correct programs.\n\nOne way to think about this model is to consider a typical single-threaded program running on one CPU. It has no need for synchronization primitives. Now run another such instance; it too needs no synchronization. Now let those two communicate; if the communication is the synchronizer, there's still no need for other synchronization. Unix pipelines, for example, fit this model perfectly. Although Go's approach to concurrency originates in Hoare's Communicating Sequential Processes (CSP), it can also be seen as a type-safe generalization of Unix pipes.\n\nThey're called goroutines because the existing terms—threads, coroutines, processes, and so on—convey inaccurate connotations. A goroutine has a simple model: it is a function executing concurrently with other goroutines in the same address space. It is lightweight, costing little more than the allocation of stack space. And the stacks start small, so they are cheap, and grow by allocating (and freeing) heap storage as required.\n\nGoroutines are multiplexed onto multiple OS threads so if one should block, such as while waiting for I/O, others continue to run. Their design hides many of the complexities of thread creation and management.\n\nPrefix a function or method call with the keyword to run the call in a new goroutine. When the call completes, the goroutine exits, silently. (The effect is similar to the Unix shell's notation for running a command in the background.)\n\nA function literal can be handy in a goroutine invocation.\n\nIn Go, function literals are closures: the implementation makes sure the variables referred to by the function survive as long as they are active.\n\nThese examples aren't too practical because the functions have no way of signaling completion. For that, we need channels.\n\nLike maps, channels are allocated with , and the resulting value acts as a reference to an underlying data structure. If an optional integer parameter is provided, it sets the buffer size for the channel. The default is zero, for an unbuffered or synchronous channel.\n\nUnbuffered channels combine communication—the exchange of a value—with synchronization—guaranteeing that two calculations (goroutines) are in a known state.\n\nThere are lots of nice idioms using channels. Here's one to get us started. In the previous section we launched a sort in the background. A channel can allow the launching goroutine to wait for the sort to complete.\n\nReceivers always block until there is data to receive. If the channel is unbuffered, the sender blocks until the receiver has received the value. If the channel has a buffer, the sender blocks only until the value has been copied to the buffer; if the buffer is full, this means waiting until some receiver has retrieved a value.\n\nA buffered channel can be used like a semaphore, for instance to limit throughput. In this example, incoming requests are passed to , which sends a value into the channel, processes the request, and then receives a value from the channel to ready the “semaphore” for the next consumer. The capacity of the channel buffer limits the number of simultaneous calls to .\n\nOnce handlers are executing , any more will block trying to send into the filled channel buffer, until one of the existing handlers finishes and receives from the buffer.\n\nThis design has a problem, though: creates a new goroutine for every incoming request, even though only of them can run at any moment. As a result, the program can consume unlimited resources if the requests come in too fast. We can address that deficiency by changing to gate the creation of the goroutines:\n\nAnother approach that manages resources well is to start a fixed number of goroutines all reading from the request channel. The number of goroutines limits the number of simultaneous calls to . This function also accepts a channel on which it will be told to exit; after launching the goroutines it blocks receiving from that channel.\n\nOne of the most important properties of Go is that a channel is a first-class value that can be allocated and passed around like any other. A common use of this property is to implement safe, parallel demultiplexing.\n\nIn the example in the previous section, was an idealized handler for a request but we didn't define the type it was handling. If that type includes a channel on which to reply, each client can provide its own path for the answer. Here's a schematic definition of type .\n\nThe client provides a function and its arguments, as well as a channel inside the request object on which to receive the answer.\n\nOn the server side, the handler function is the only thing that changes.\n\nThere's clearly a lot more to do to make it realistic, but this code is a framework for a rate-limited, parallel, non-blocking RPC system, and there's not a mutex in sight.\n\nAnother application of these ideas is to parallelize a calculation across multiple CPU cores. If the calculation can be broken into separate pieces that can execute independently, it can be parallelized, with a channel to signal when each piece completes.\n\nLet's say we have an expensive operation to perform on a vector of items, and that the value of the operation on each item is independent, as in this idealized example.\n\nWe launch the pieces independently in a loop, one per CPU. They can complete in any order but it doesn't matter; we just count the completion signals by draining the channel after launching all the goroutines.\n\nRather than create a constant value for numCPU, we can ask the runtime what value is appropriate. The function returns the number of hardware CPU cores in the machine, so we could write\n\nThere is also a function , which reports (or sets) the user-specified number of cores that a Go program can have running simultaneously. It defaults to the value of but can be overridden by setting the similarly named shell environment variable or by calling the function with a positive number. Calling it with zero just queries the value. Therefore if we want to honor the user's resource request, we should write\n\nBe sure not to confuse the ideas of concurrency—structuring a program as independently executing components—and parallelism—executing calculations in parallel for efficiency on multiple CPUs. Although the concurrency features of Go can make some problems easy to structure as parallel computations, Go is a concurrent language, not a parallel one, and not all parallelization problems fit Go's model. For a discussion of the distinction, see the talk cited in this blog post.\n\nThe tools of concurrent programming can even make non-concurrent ideas easier to express. Here's an example abstracted from an RPC package. The client goroutine loops receiving data from some source, perhaps a network. To avoid allocating and freeing buffers, it keeps a free list, and uses a buffered channel to represent it. If the channel is empty, a new buffer gets allocated. Once the message buffer is ready, it's sent to the server on .\n\nThe server loop receives each message from the client, processes it, and returns the buffer to the free list.\n\nThe client attempts to retrieve a buffer from ; if none is available, it allocates a fresh one. The server's send to puts back on the free list unless the list is full, in which case the buffer is dropped on the floor to be reclaimed by the garbage collector. (The clauses in the statements execute when no other case is ready, meaning that the never block.) This implementation builds a leaky bucket free list in just a few lines, relying on the buffered channel and the garbage collector for bookkeeping.\n\nLibrary routines must often return some sort of error indication to the caller. As mentioned earlier, Go's multivalue return makes it easy to return a detailed error description alongside the normal return value. It is good style to use this feature to provide detailed error information. For example, as we'll see, doesn't just return a pointer on failure, it also returns an error value that describes what went wrong.\n\nA library writer is free to implement this interface with a richer model under the covers, making it possible not only to see the error but also to provide some context. As mentioned, alongside the usual return value, also returns an error value. If the file is opened successfully, the error will be , but when there is a problem, it will hold an :\n\nSuch an error, which includes the problematic file name, the operation, and the operating system error it triggered, is useful even if printed far from the call that caused it; it is much more informative than the plain \"no such file or directory\".\n\nWhen feasible, error strings should identify their origin, such as by having a prefix naming the operation or package that generated the error. For example, in package , the string representation for a decoding error due to an unknown format is \"image: unknown format\".\n\nCallers that care about the precise error details can use a type switch or a type assertion to look for specific errors and extract details. For this might include examining the internal field for recoverable failures.\n\nThe second statement here is another type assertion. If it fails, will be false, and will be . If it succeeds, will be true, which means the error was of type , and then so is , which we can examine for more information about the error.\n\nThe usual way to report an error to a caller is to return an as an extra return value. The canonical method is a well-known instance; it returns a byte count and an . But what if the error is unrecoverable? Sometimes the program simply cannot continue.\n\nFor this purpose, there is a built-in function that in effect creates a run-time error that will stop the program (but see the next section). The function takes a single argument of arbitrary type—often a string—to be printed as the program dies. It's also a way to indicate that something impossible has happened, such as exiting an infinite loop.\n\nThis is only an example but real library functions should avoid . If the problem can be masked or worked around, it's always better to let things continue to run rather than taking down the whole program. One possible counterexample is during initialization: if the library truly cannot set itself up, it might be reasonable to panic, so to speak.\n\nWhen is called, including implicitly for run-time errors such as indexing a slice out of bounds or failing a type assertion, it immediately stops execution of the current function and begins unwinding the stack of the goroutine, running any deferred functions along the way. If that unwinding reaches the top of the goroutine's stack, the program dies. However, it is possible to use the built-in function to regain control of the goroutine and resume normal execution.\n\nA call to stops the unwinding and returns the argument passed to . Because the only code that runs while unwinding is inside deferred functions, is only useful inside deferred functions.\n\nOne application of is to shut down a failing goroutine inside a server without killing the other executing goroutines.\n\nIn this example, if panics, the result will be logged and the goroutine will exit cleanly without disturbing the others. There's no need to do anything else in the deferred closure; calling handles the condition completely.\n\nBecause always returns unless called directly from a deferred function, deferred code can call library routines that themselves use and without failing. As an example, the deferred function in might call a logging function before calling , and that logging code would run unaffected by the panicking state.\n\nWith our recovery pattern in place, the function (and anything it calls) can get out of any bad situation cleanly by calling . We can use that idea to simplify error handling in complex software. Let's look at an idealized version of a package, which reports parsing errors by calling with a local error type. Here's the definition of , an method, and the function.\n\nIf panics, the recovery block will set the return value to —deferred functions can modify named return values. It will then check, in the assignment to , that the problem was a parse error by asserting that it has the local type . If it does not, the type assertion will fail, causing a run-time error that continues the stack unwinding as though nothing had interrupted it. This check means that if something unexpected happens, such as an index out of bounds, the code will fail even though we are using and to handle parse errors.\n\nWith error handling in place, the method (because it's a method bound to a type, it's fine, even natural, for it to have the same name as the builtin type) makes it easy to report parse errors without worrying about unwinding the parse stack by hand:\n\nUseful though this pattern is, it should be used only within a package. turns its internal calls into values; it does not expose to its client. That is a good rule to follow.\n\nBy the way, this re-panic idiom changes the panic value if an actual error occurs. However, both the original and new failures will be presented in the crash report, so the root cause of the problem will still be visible. Thus this simple re-panic approach is usually sufficient—it's a crash after all—but if you want to display only the original value, you can write a little more code to filter unexpected problems and re-panic with the original error. That's left as an exercise for the reader.\n\nLet's finish with a complete Go program, a web server. This one is actually a kind of web re-server. Google provides a service at that does automatic formatting of data into charts and graphs. It's hard to use interactively, though, because you need to put the data into the URL as a query. The program here provides a nicer interface to one form of data: given a short piece of text, it calls on the chart server to produce a QR code, a matrix of boxes that encode the text. That image can be grabbed with your cell phone's camera and interpreted as, for instance, a URL, saving you typing the URL into the phone's tiny keyboard.\n\nHere's the complete program. An explanation follows.\n\nThe pieces up to should be easy to follow. The one flag sets a default HTTP port for our server. The template variable is where the fun happens. It builds an HTML template that will be executed by the server to display the page; more about that in a moment.\n\nThe function parses the flags and, using the mechanism we talked about above, binds the function to the root path for the server. Then is called to start the server; it blocks while the server runs.\n\njust receives the request, which contains form data, and executes the template on the data in the form value named .\n\nThe template package is powerful; this program just touches on its capabilities. In essence, it rewrites a piece of HTML text on the fly by substituting elements derived from data items passed to , in this case the form value. Within the template text ( ), double-brace-delimited pieces denote template actions. The piece from to executes only if the value of the current data item, called (dot), is non-empty. That is, when the string is empty, this piece of the template is suppressed.\n\nThe two snippets say to show the data presented to the template—the query string—on the web page. The HTML template package automatically provides appropriate escaping so the text is safe to display.\n\nThe rest of the template string is just the HTML to show when the page loads. If this is too quick an explanation, see the documentation for the template package for a more thorough discussion.\n\nAnd there you have it: a useful web server in a few lines of code plus some data-driven HTML text. Go is powerful enough to make a lot happen in a few lines."
    },
    {
        "link": "https://go.dev/doc",
        "document": "The Go programming language is an open source project to make programmers more productive.\n\nGo is expressive, concise, clean, and efficient. Its concurrency mechanisms make it easy to write programs that get the most out of multicore and networked machines, while its novel type system enables flexible and modular program construction. Go compiles quickly to machine code yet has the convenience of garbage collection and the power of run-time reflection. It's a fast, statically typed, compiled language that feels like a dynamically typed, interpreted language.\n\nYou can collect related packages into modules, then publish the modules for other developers to use. This topic gives an overview of developing and publishing modules. When you develop modules for use by other developers, you can follow a workflow that helps ensure a reliable, consistent experience for developers using the module. This topic describes the high-level steps in that workflow. When you're developing modules to publish for others to use, you can help ensure that your modules are easier for other developers to use by following the repository conventions described in this topic. What is the right way to organize the files and directories in a typical Go project? This topic discusses some common layouts depending on the kind of module you have. A major version update can be very disruptive to your module's users because it includes breaking changes and represents a new module. Learn more in this topic. When you want to make a module available for other developers, you publish it so that it's visible to Go tools. Once you've published the module, developers importing its packages will be able to resolve a dependency on the module by running commands such as . A module's developer uses each part of a module's version number to signal the version’s stability and backward compatibility. For each new release, a module's release version number specifically reflects the nature of the module's changes since the preceding release.\n\nThree things that make Go fast, fun, and productive: interfaces, reflection, and concurrency. Builds a toy web crawler to demonstrate these. One of Go's key design goals is code adaptability; that it should be easy to take a simple design and build upon it in a clean and natural way. In this talk Andrew Gerrand describes a simple \"chat roulette\" server that matches pairs of incoming TCP connections, and then use Go's concurrency mechanisms, interfaces, and standard library to extend it with a web interface and other features. While the function of the program changes dramatically, Go's flexibility preserves the original design as it grows. Concurrency is the key to designing high performance network services. Go's concurrency primitives (goroutines and channels) provide a simple and efficient means of expressing concurrent execution. In this talk we see how tricky concurrency problems can be solved gracefully with simple Go code. This talk expands on the Go Concurrency Patterns talk to dive deeper into Go's concurrency primitives. See the Go Talks site and wiki page for more Go talks.\n\nThe Go Wiki, maintained by the Go community, includes articles about the Go language, tools, and other resources. See the Learn page at the Wiki for more Go learning resources."
    },
    {
        "link": "https://tip.golang.org/doc/comment",
        "document": "“Doc comments” are comments that appear immediately before top-level package, const, func, type, and var declarations with no intervening newlines. Every exported (capitalized) name should have a doc comment.\n\nThe go/doc and go/doc/comment packages provide the ability to extract documentation from Go source code, and a variety of tools make use of this functionality. The command looks up and prints the doc comment for a given package or symbol. (A symbol is a top-level const, func, type, or var.) The web server pkg.go.dev shows the documentation for public Go packages (when their licenses permit that use). The program serving that site is golang.org/x/pkgsite/cmd/pkgsite, which can also be run locally to view documentation for private modules or without an internet connection. The language server gopls provides documentation when editing Go source files in IDEs.\n\nThe rest of this page documents how to write Go doc comments.\n\nEvery package should have a package comment introducing the package. It provides information relevant to the package as a whole and generally sets expectations for the package. Especially in large packages, it can be helpful for the package comment to give a brief overview of the most important parts of the API, linking to other doc comments as needed.\n\nIf the package is simple, the package comment can be brief. For example:\n\nAs can be seen in this example, Go doc comments use complete sentences. For a package comment, that means the first sentence begins with “Package\n\nFor multi-file packages, the package comment should only be in one source file. If multiple files have package comments, they are concatenated to form one large comment for the entire package.\n\nA package comment for a command is similar, but it describes the behavior of the program rather than the Go symbols in the package. The first sentence conventionally begins with the name of the program itself, capitalized because it is at the start of a sentence. For example, here is an abridged version of the package comment for gofmt:\n\nThe beginning of the comment is written using semantic linefeeds, in which each new sentence or long phrase is on a line by itself, which can make diffs easier to read as code and comments evolve. The later paragraphs happen not to follow this convention and have been wrapped by hand. Whatever is best for your code base is fine. Either way, and rewrap doc comment text when printing it. For example:\n\nThe indented lines are treated as preformatted text: they are not rewrapped and are printed in code font in HTML and Markdown presentations. (The Syntax section below gives the details.)\n\nA type’s doc comment should explain what each instance of that type represents or provides. If the API is simple, the doc comment can be quite short. For example:\n\nBy default, programmers should expect that a type is safe for use only by a single goroutine at a time. If a type provides stronger guarantees, the doc comment should state them. For example:\n\nGo types should also aim to make the zero value have a useful meaning. If it isn’t obvious, that meaning should be documented. For example:\n\nFor a struct with exported fields, either the doc comment or per-field comments should explain the meaning of each exported field. For example, this type’s doc comment explains the fields:\n\nIn contrast, this type’s doc comment leaves the explanations to per-field comments:\n\nAs with packages (above) and funcs (below), doc comments for types start with complete sentences naming the declared symbol. An explicit subject often makes the wording clearer, and it makes the text easier to search, whether on a web page or a command line. For example:\n\nA function’s doc comment should explain what the function returns or, for functions called for side effects, what it does. Named parameters and results can be referred to directly in the comment, without any special syntax like backquotes. (A consequence of this convention is that names like , which might be mistaken for ordinary words, are typically avoided.) For example:\n\nDoc comments typically use the phrase “reports whether” to describe functions that return a boolean. The phrase “or not” is unnecessary. For example:\n\nIf a doc comment needs to explain multiple results, naming the results can make the doc comment more understandable, even if the names are not used in the body of the function. For example:\n\nConversely, when the results don’t need to be named in the doc comment, they are usually omitted in the code as well, like in the example above, to avoid cluttering the presentation.\n\nThese rules all apply both to plain functions and to methods. For methods, using the same receiver name avoids needless variation when listing all the methods of a type:\n\nThis example also shows that top-level functions returning a type or pointer , perhaps with an additional error result, are shown alongside the type and its methods, under the assumption that they are ’s constructors.\n\nBy default, programmers can assume that a top-level function is safe to call from multiple goroutines; this fact need not be stated explicitly.\n\nOn the other hand, as noted in the previous section, using an instance of a type in any way, including calling a method, is typically assumed to be restricted to a single goroutine at a time. If the methods that are safe for concurrent use are not documented in the type’s doc comment, they should be documented in per-method comments. For example:\n\nNote that function and method doc comments focus on what the operation returns or does, detailing what the caller needs to know. Special cases can be particularly important to document. For example:\n\nDoc comments should not explain internal details such as the algorithm used in the current implementation. Those are best left to comments inside the function body. It may be appropriate to give asymptotic time or space bounds when that detail is particularly important to callers. For example:\n\nBecause this doc comment makes no mention of which sorting algorithm is used, it is easier to change the implementation to use a different algorithm in the future.\n\nGo’s declaration syntax allows grouping of declarations, in which case a single doc comment can introduce a group of related constants, with individual constants only documented by short end-of-line comments. For example:\n\nSometimes the group needs no doc comment at all. For example:\n\nOn the other hand, ungrouped constants typically warrant a full doc comment starting with a complete sentence. For example:\n\nTyped constants are displayed next to the declaration of their type and as a result often omit a const group doc comment in favor of the type’s doc comment. For example:\n\nThe conventions for variables are the same as those for constants. For example, here is a set of grouped variables:\n\nGo doc comments are written in a simple syntax that supports paragraphs, headings, links, lists, and preformatted code blocks. To keep comments lightweight and readable in source files, there is no support for complex features like font changes or raw HTML. Markdown aficionados can view the syntax as a simplified subset of Markdown.\n\nThe standard formatter gofmt reformats doc comments to use a canonical formatting for each of these features. Gofmt aims for readability and user control over how comments are written in source code but will adjust presentation to make the semantic meaning of a particular comment clearer, analogous to reformatting to in ordinary source code.\n\nDirective comments such as are not considered part of a doc comment and are omitted from rendered documentation. Gofmt moves directive comments to the end of the doc comment, preceded by a blank line. For example:\n\nA directive comment is a line matching the regular expression . Tools that define their own directives should use the form .\n\nGofmt removes leading and trailing blank lines in doc comments. If all lines in a doc comment begin with the same sequence of spaces and tabs, gofmt removes that prefix.\n\nA paragraph is a span of unindented non-blank lines. We’ve already seen many examples of paragraphs.\n\nA pair of consecutive backticks (` U+0060) is interpreted as a Unicode left quote (“ U+201C), and a pair of consecutive single quotes (' U+0027) is interpreted as a Unicode right quote (” U+201D).\n\nGofmt preserves line breaks in paragraph text: it does not rewrap the text. This allows the use of semantic linefeeds, as seen earlier. Gofmt replaces duplicated blank lines between paragraphs with a single blank line. Gofmt also reformats consecutive backticks or single quotes to their Unicode interpretations.\n\nNotes are special comments of the form . MARKER should consist of 2 or more upper case letters, identifying the type of note, while uid is at least 1 character, usually a username of someone who can provide more information. The following the uid is optional.\n\nNotes are collected and rendered in their own section on pkg.go.dev.\n\nParagraphs starting with are treated as deprecation notices. Some tools will warn when deprecated identifiers are used. pkg.go.dev will hide their docs by default.\n\nDeprecation notices are followed by some information about the deprecation, and a recommendation on what to use instead, if applicable. The paragraph does not have to be the last paragraph in the doc comment.\n\nA heading is a line beginning with a number sign (U+0023) and then a space and the heading text. To be recognized as a heading, the line must be unindented and set off from adjacent paragraph text by blank lines.\n\nOn the other hand:\n\nThe # syntax was added in Go 1.19. Before Go 1.19, headings were identified implicitly by single-line paragraphs satisfying certain conditions, most notably the lack of any terminating punctuation.\n\nGofmt reformats lines treated as implicit headings by earlier versions of Go to use # headings instead. If the reformatting is not appropriate—that is, if the line was not meant to be a heading—the easiest way to make it a paragraph is to introduce terminating punctuation such as a period or colon, or to break it into two lines.\n\nA span of unindented non-blank lines defines link targets when every line is of the form “[Text]: URL”. In other text in the same doc comment, “[Text]” represents a link to URL using the given text—in HTML, <a href=“URL”>Text</a>. For example:\n\nBy keeping URLs in a separate section, this format only minimally interrupts the flow of the actual text. It also roughly matches the Markdown shortcut reference link format, without the optional title text.\n\nIf there is no corresponding URL declaration, then (except for doc links, described in the next section) “[Text]” is not a hyperlink, and the square brackets are preserved when displayed. Each doc comment is considered independently: link target definitions in one comment do not affect other comments.\n\nAlthough link target definition blocks may be interleaved with ordinary paragraphs, gofmt moves all link target definitions to the end of the doc comment, in up to two blocks: first a block containing all the link targets that are referenced in the comment, and then a block containing all the targets not referenced in the comment. The separate block makes unused targets easy to notice and fix (in case the links or the definitions have typos) or to delete (in case the definitions are no longer needed).\n\nPlain text that is recognized as a URL is automatically linked in HTML renderings.\n\nDoc links are links of the form “[Name1]” or “[Name1.Name2]” to refer to exported identifiers in the current package, or “[pkg]”, “[pkg.Name1]”, or “[pkg.Name1.Name2]” to refer to identifiers in other packages.\n\nThe bracketed text for a symbol link can include an optional leading star, making it easy to refer to pointer types, such as [*bytes.Buffer].\n\nWhen referring to other packages, “pkg” can be either a full import path or the assumed package name of an existing import. The assumed package name is either the identifier in a renamed import or else the name assumed by goimports. (Goimports inserts renamings when that assumption is not correct, so this rule should work for essentially all Go code.) For example, if the current package imports encoding/json, then “[json.Decoder]” can be written in place of “[encoding/json.Decoder]” to link to the docs for encoding/json’s Decoder. If different source files in a package import different packages using the same name, then the shorthand is ambiguous and cannot be used.\n\nA “pkg” is only assumed to be a full import path if it starts with a domain name (a path element with a dot) or is one of the packages from the standard library (“[os]”, “[encoding/json]”, and so on). For example, and are documentation links (the latter will be a broken link), but is not, because there is no os/sys package in the standard library.\n\nTo avoid problems with maps, generics, and array types, doc links must be both preceded and followed by punctuation, spaces, tabs, or the start or end of a line. For example, the text “map[ast.Expr]TypeAndValue” does not contain a doc link.\n\nA list is a span of indented or blank lines (which would otherwise be a code block, as described in the next section) in which the first indented line begins with a bullet list marker or a numbered list marker.\n\nA bullet list marker is a star, plus, dash, or Unicode bullet (*, +, -, •; U+002A, U+002B, U+002D, U+2022) followed by a space or tab and then text. In a bullet list, each line beginning with a bullet list marker starts a new list item.\n\nA numbered list marker is a decimal number of any length followed by a period or right parenthesis, then a space or tab, and then text. In a numbered list, each line beginning with a number list marker starts a new list item. Item numbers are left as is, never renumbered.\n\nList items only contain paragraphs, not code blocks or nested lists. This avoids any space-counting subtlety as well as questions about how many spaces a tab counts for in inconsistent indentation.\n\nGofmt reformats bullet lists to use a dash as the bullet marker, two spaces of indentation before the dash, and four spaces of indentation for continuation lines.\n\nGofmt reformats numbered lists to use a single space before the number, a period after the number, and again four spaces of indentation for continuation lines.\n\nGofmt preserves but does not require a blank line between a list and the preceding paragraph. It inserts a blank line between a list and the following paragraph or heading.\n\nA code block is a span of indented or blank lines not starting with a bullet list marker or numbered list marker. It is rendered as preformatted text (a <pre> block in HTML).\n\nCode blocks often contain Go code. For example:\n\nOf course, code blocks also often contain preformatted text besides code. For example:\n\nGofmt indents all lines in a code block by a single tab, replacing any other indentation the non-blank lines have in common. Gofmt also inserts a blank line before and after each code block, distinguishing the code block clearly from the surrounding paragraph text.\n\nThe rule that any span of indented or blank lines in a doc comment is rendered as a code block dates to the earliest days of Go. Unfortunately, the lack of support for doc comments in gofmt has led to many existing comments that use indentation without meaning to create a code block.\n\nFor example, this unindented list has always been interpreted by godoc as a three-line paragraph followed by a one-line code block:\n\nThis always rendered in as:\n\nSimilarly, the command in this comment is a one-line paragraph followed by a one-line code block:\n\nThis rendered in as:\n\nAnd this comment is a two-line paragraph (the second line is “{”), followed by a six-line indented code block and a one-line paragraph (“}”).\n\nAnd this rendered in as:\n\nAnother common mistake was an unindented Go function definition or block statement, similarly bracketed by “{” and “}”.\n\nThe introduction of doc comment reformatting in Go 1.19’s gofmt makes mistakes like these more visible by adding blank lines around the code blocks.\n\nAnalysis in 2022 found that only 3% of doc comments in public Go modules were reformatted at all by the draft Go 1.19 gofmt. Limiting ourselves to those comments, about 87% of gofmt’s reformattings preserved the structure that a person would infer from reading the comment; about 6% were tripped up by these kinds of unindented lists, unindented multiline shell commands, and unindented brace-delimited code blocks.\n\nBased on this analysis, the Go 1.19 gofmt applies a few heuristics to merge unindented lines into an adjacent indented list or code block. With those adjustments, the Go 1.19 gofmt reformats the above examples to:\n\nThis reformatting makes the meaning clearer as well as making the doc comments render correctly in earlier versions of Go. If the heuristic ever makes a bad decision, it can be overridden by inserting a blank line to clearly separate the paragraph text from non-paragraph text.\n\nEven with these heuristics, other existing comments will need manual adjustment to correct their rendering. The most common mistake is indenting a wrapped unindented line of text. For example:\n\nIn both of these, the last line is indented, making it a code block. The fix is to unindent the lines.\n\nAnother common mistake is not indenting a wrapped indented line of a list or code block. For example:\n\nThe fix is to indent the wrapped lines.\n\nGo doc comments do not support nested lists, so gofmt reformats\n\nRewriting the text to avoid nested lists usually improves the documentation and is the best solution. Another potential workaround is to mix list markers, since bullet markers do not introduce list items in a numbered list, nor vice versa. For example:"
    },
    {
        "link": "https://go.dev/doc/modules/layout",
        "document": "A common question developers new to Go have is “How do I organize my Go project?”, in terms of the layout of files and folders. The goal of this document is to provide some guidelines that will help answer this question. To make the most of this document, make sure you’re familiar with the basics of Go modules by reading the tutorial and managing module source.\n\nGo projects can include packages, command-line programs or a combination of the two. This guide is organized by project type.\n\nA basic Go package has all its code in the project’s root directory. The project consists of a single module, which consists of a single package. The package name matches the last path component of the module name. For a very simple package requiring a single Go file, the project structure is:\n\n[throughout this document, file/package names are entirely arbitrary]\n\nAssuming this directory is uploaded to a GitHub repository at , the line in the file should say .\n\nThe code in declares the package with:\n\nUsers can then rely on this package by -ing it in their Go code with:\n\nA Go package can be split into multiple files, all residing within the same directory, e.g.:\n\nAll the files in the directory declare .\n\nA basic executable program (or command-line tool) is structured according to its complexity and code size. The simplest program can consist of a single Go file where is defined. Larger programs can have their code split across multiple files, all declaring :\n\nHere the file contains , but this is just a convention. The “main” file can also be called (for an appropriate value of ) or anything else.\n\nAssuming this directory is uploaded to a GitHub repository at , the line in the file should say:\n\nAnd a user should be able to install it on their machine with:\n\nLarger packages or commands may benefit from splitting off some functionality into supporting packages. Initially, it’s recommended placing such packages into a directory named ; this prevents other modules from depending on packages we don’t necessarily want to expose and support for external uses. Since other projects cannot import code from our directory, we’re free to refactor its API and generally move things around without breaking external users. The project structure for a package is thus:\n\nThe file declares , declares and so on. can import the package as follows:\n\nThe layout for a command with supporting packages in an directory is very similar, except that the file(s) in the root directory declare .\n\nA module can consist of multiple importable packages; each package has its own directory, and can be structured hierarchically. Here’s a sample project structure:\n\nAs a reminder, we assume that the line in says:\n\nThe package resides in the root directory, declares and can be imported by users with:\n\nSub-packages can be imported by users as follows:\n\nPackage that resides in cannot be imported outside this module. It’s recommended to keep packages in as much as possible.\n\nMultiple programs in the same repository will typically have separate directories:\n\nIn each directory, the program’s Go files declare . A top-level directory can contain shared packages used by all commands in the repository.\n\nUsers can install these programs as follows:\n\nA common convention is placing all commands in a repository into a directory; while this isn’t strictly necessary in a repository that consists only of commands, it’s very useful in a mixed repository that has both commands and importable packages, as we will discuss next.\n\nPackages and commands in the same repository\n\nSometimes a repository will provide both importable packages and installable commands with related functionality. Here’s a sample project structure for such a repository:\n\nAssuming this module is called , users can now both import packages from it:\n\nAnd install programs from it:\n\nGo is a common language choice for implementing servers. There is a very large variance in the structure of such projects, given the many aspects of server development: protocols (REST? gRPC?), deployments, front-end files, containerization, scripts and so on. We will focus our guidance here on the parts of the project written in Go.\n\nServer projects typically won’t have packages for export, since a server is usually a self-contained binary (or a group of binaries). Therefore, it’s recommended to keep the Go packages implementing the server’s logic in the directory. Moreover, since the project is likely to have many other directories with non-Go files, it’s a good idea to keep all Go commands together in a directory:\n\nIn case the server repository grows packages that become useful for sharing with other projects, it’s best to split these off to separate modules."
    },
    {
        "link": "https://go.dev/ref/spec",
        "document": "This is the reference manual for the Go programming language. The pre-Go1.18 version, without generics, can be found here. For more information and other documents, see go.dev.\n\nGo is a general-purpose language designed with systems programming in mind. It is strongly typed and garbage-collected and has explicit support for concurrent programming. Programs are constructed from packages, whose properties allow efficient management of dependencies.\n\nThe syntax is compact and simple to parse, allowing for easy analysis by automatic tools such as integrated development environments.\n\nThe syntax is specified using a variant of Extended Backus-Naur Form (EBNF):\n\nProductions are expressions constructed from terms and the following operators, in increasing precedence:\n\nLowercase production names are used to identify lexical (terminal) tokens. Non-terminals are in CamelCase. Lexical tokens are enclosed in double quotes or back quotes .\n\nThe form represents the set of characters from through as alternatives. The horizontal ellipsis is also used elsewhere in the spec to informally denote various enumerations or code snippets that are not further specified. The character (as opposed to the three characters ) is not a token of the Go language.\n\nA link of the form [Go 1.xx] indicates that a described language feature (or some aspect of it) was changed or added with language version 1.xx and thus requires at minimum that language version to build. For details, see the linked section in the appendix.\n\nSource code is Unicode text encoded in UTF-8. The text is not canonicalized, so a single accented code point is distinct from the same character constructed from combining an accent and a letter; those are treated as two code points. For simplicity, this document will use the unqualified term character to refer to a Unicode code point in the source text.\n\nEach code point is distinct; for instance, uppercase and lowercase letters are different characters.\n\nImplementation restriction: For compatibility with other tools, a compiler may disallow the NUL character (U+0000) in the source text.\n\nImplementation restriction: For compatibility with other tools, a compiler may ignore a UTF-8-encoded byte order mark (U+FEFF) if it is the first Unicode code point in the source text. A byte order mark may be disallowed anywhere else in the source.\n\nThe following terms are used to denote specific Unicode character categories:\n\nIn The Unicode Standard 8.0, Section 4.5 \"General Category\" defines a set of character categories. Go treats all characters in any of the Letter categories Lu, Ll, Lt, Lm, or Lo as Unicode letters, and those in the Number category Nd as Unicode digits.\n\nComments serve as program documentation. There are two forms:\n• Line comments start with the character sequence and stop at the end of the line.\n• General comments start with the character sequence and stop with the first subsequent character sequence .\n\nA comment cannot start inside a rune or string literal, or inside a comment. A general comment containing no newlines acts like a space. Any other comment acts like a newline.\n\nTokens form the vocabulary of the Go language. There are four classes: identifiers, keywords, operators and punctuation, and literals. White space, formed from spaces (U+0020), horizontal tabs (U+0009), carriage returns (U+000D), and newlines (U+000A), is ignored except as it separates tokens that would otherwise combine into a single token. Also, a newline or end of file may trigger the insertion of a semicolon. While breaking the input into tokens, the next token is the longest sequence of characters that form a valid token.\n\nThe formal syntax uses semicolons as terminators in a number of productions. Go programs may omit most of these semicolons using the following two rules:\n• When the input is broken into tokens, a semicolon is automatically inserted into the token stream immediately after a line's final token if that token is\n• one of the keywords , , , or\n• one of the operators and punctuation , , , , or\n• To allow complex statements to occupy a single line, a semicolon may be omitted before a closing or .\n\nTo reflect idiomatic use, code examples in this document elide semicolons using these rules.\n\nIdentifiers name program entities such as variables and types. An identifier is a sequence of one or more letters and digits. The first character in an identifier must be a letter.\n\nThe following keywords are reserved and may not be used as identifiers.\n\nThe following character sequences represent operators (including assignment operators) and punctuation [Go 1.18]:\n\nAn integer literal is a sequence of digits representing an integer constant. An optional prefix sets a non-decimal base: or for binary, , , or for octal, and or for hexadecimal [Go 1.13]. A single is considered a decimal zero. In hexadecimal literals, letters through and through represent values 10 through 15.\n\nFor readability, an underscore character may appear after a base prefix or between successive digits; such underscores do not change the literal's value.\n\nA floating-point literal is a decimal or hexadecimal representation of a floating-point constant.\n\nA decimal floating-point literal consists of an integer part (decimal digits), a decimal point, a fractional part (decimal digits), and an exponent part ( or followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; one of the decimal point or the exponent part may be elided. An exponent value exp scales the mantissa (integer and fractional part) by 10exp.\n\nA hexadecimal floating-point literal consists of a or prefix, an integer part (hexadecimal digits), a radix point, a fractional part (hexadecimal digits), and an exponent part ( or followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; the radix point may be elided as well, but the exponent part is required. (This syntax matches the one given in IEEE 754-2008 §5.12.3.) An exponent value exp scales the mantissa (integer and fractional part) by 2exp [Go 1.13].\n\nFor readability, an underscore character may appear after a base prefix or between successive digits; such underscores do not change the literal value.\n\nAn imaginary literal represents the imaginary part of a complex constant. It consists of an integer or floating-point literal followed by the lowercase letter . The value of an imaginary literal is the value of the respective integer or floating-point literal multiplied by the imaginary unit i [Go 1.13]\n\nFor backward compatibility, an imaginary literal's integer part consisting entirely of decimal digits (and possibly underscores) is considered a decimal integer, even if it starts with a leading .\n\nA rune literal represents a rune constant, an integer value identifying a Unicode code point. A rune literal is expressed as one or more characters enclosed in single quotes, as in or . Within the quotes, any character may appear except newline and unescaped single quote. A single quoted character represents the Unicode value of the character itself, while multi-character sequences beginning with a backslash encode values in various formats.\n\nThe simplest form represents the single character within the quotes; since Go source text is Unicode characters encoded in UTF-8, multiple UTF-8-encoded bytes may represent a single integer value. For instance, the literal holds a single byte representing a literal , Unicode U+0061, value , while holds two bytes ( ) representing a literal -dieresis, U+00E4, value .\n\nSeveral backslash escapes allow arbitrary values to be encoded as ASCII text. There are four ways to represent the integer value as a numeric constant: followed by exactly two hexadecimal digits; followed by exactly four hexadecimal digits; followed by exactly eight hexadecimal digits, and a plain backslash followed by exactly three octal digits. In each case the value of the literal is the value represented by the digits in the corresponding base.\n\nAlthough these representations all result in an integer, they have different valid ranges. Octal escapes must represent a value between 0 and 255 inclusive. Hexadecimal escapes satisfy this condition by construction. The escapes and represent Unicode code points so within them some values are illegal, in particular those above and surrogate halves.\n\nAn unrecognized character following a backslash in a rune literal is illegal.\n\nA string literal represents a string constant obtained from concatenating a sequence of characters. There are two forms: raw string literals and interpreted string literals.\n\nRaw string literals are character sequences between back quotes, as in . Within the quotes, any character may appear except back quote. The value of a raw string literal is the string composed of the uninterpreted (implicitly UTF-8-encoded) characters between the quotes; in particular, backslashes have no special meaning and the string may contain newlines. Carriage return characters ('\\r') inside raw string literals are discarded from the raw string value.\n\nInterpreted string literals are character sequences between double quotes, as in . Within the quotes, any character may appear except newline and unescaped double quote. The text between the quotes forms the value of the literal, with backslash escapes interpreted as they are in rune literals (except that is illegal and is legal), with the same restrictions. The three-digit octal ( nnn) and two-digit hexadecimal ( nn) escapes represent individual bytes of the resulting string; all other escapes represent the (possibly multi-byte) UTF-8 encoding of individual characters. Thus inside a string literal and represent a single byte of value =255, while , , and represent the two bytes of the UTF-8 encoding of character U+00FF.\n\nThese examples all represent the same string:\n\nIf the source code represents a character as two code points, such as a combining form involving an accent and a letter, the result will be an error if placed in a rune literal (it is not a single code point), and will appear as two code points if placed in a string literal.\n\nThere are boolean constants, rune constants, integer constants, floating-point constants, complex constants, and string constants. Rune, integer, floating-point, and complex constants are collectively called numeric constants.\n\nA constant value is represented by a rune, integer, floating-point, imaginary, or string literal, an identifier denoting a constant, a constant expression, a conversion with a result that is a constant, or the result value of some built-in functions such as or applied to constant arguments, applied to certain values, or applied to some expressions, and applied to a complex constant and applied to numeric constants. The boolean truth values are represented by the predeclared constants and . The predeclared identifier iota denotes an integer constant.\n\nIn general, complex constants are a form of constant expression and are discussed in that section.\n\nNumeric constants represent exact values of arbitrary precision and do not overflow. Consequently, there are no constants denoting the IEEE 754 negative zero, infinity, and not-a-number values.\n\nConstants may be typed or untyped. Literal constants, , , , and certain constant expressions containing only untyped constant operands are untyped.\n\nA constant may be given a type explicitly by a constant declaration or conversion, or implicitly when used in a variable declaration or an assignment statement or as an operand in an expression. It is an error if the constant value cannot be represented as a value of the respective type. If the type is a type parameter, the constant is converted into a non-constant value of the type parameter.\n\nAn untyped constant has a default type which is the type to which the constant is implicitly converted in contexts where a typed value is required, for instance, in a short variable declaration such as where there is no explicit type. The default type of an untyped constant is , , , , , or respectively, depending on whether it is a boolean, rune, integer, floating-point, complex, or string constant.\n\nImplementation restriction: Although numeric constants have arbitrary precision in the language, a compiler may implement them using an internal representation with limited precision. That said, every implementation must:\n• Represent integer constants with at least 256 bits.\n• Represent floating-point constants, including the parts of a complex constant, with a mantissa of at least 256 bits and a signed binary exponent of at least 16 bits.\n• Give an error if unable to represent an integer constant precisely.\n• Give an error if unable to represent a floating-point or complex constant due to overflow.\n• Round to the nearest representable constant if unable to represent a floating-point or complex constant due to limits on precision.\n\nThese requirements apply both to literal constants and to the result of evaluating constant expressions.\n\nA variable is a storage location for holding a value. The set of permissible values is determined by the variable's type.\n\nA variable declaration or, for function parameters and results, the signature of a function declaration or function literal reserves storage for a named variable. Calling the built-in function or taking the address of a composite literal allocates storage for a variable at run time. Such an anonymous variable is referred to via a (possibly implicit) pointer indirection.\n\nStructured variables of array, slice, and struct types have elements and fields that may be addressed individually. Each such element acts like a variable.\n\nThe static type (or just type) of a variable is the type given in its declaration, the type provided in the call or composite literal, or the type of an element of a structured variable. Variables of interface type also have a distinct dynamic type, which is the (non-interface) type of the value assigned to the variable at run time (unless the value is the predeclared identifier , which has no type). The dynamic type may vary during execution but values stored in interface variables are always assignable to the static type of the variable.\n\nA variable's value is retrieved by referring to the variable in an expression; it is the most recent value assigned to the variable. If a variable has not yet been assigned a value, its value is the zero value for its type.\n\nA type determines a set of values together with operations and methods specific to those values. A type may be denoted by a type name, if it has one, which must be followed by type arguments if the type is generic. A type may also be specified using a type literal, which composes a type from existing types.\n\nThe language predeclares certain type names. Others are introduced with type declarations or type parameter lists. Composite types—array, struct, pointer, function, interface, slice, map, and channel types—may be constructed using type literals.\n\nPredeclared types, defined types, and type parameters are called named types. An alias denotes a named type if the type given in the alias declaration is a named type.\n\nA boolean type represents the set of Boolean truth values denoted by the predeclared constants and . The predeclared boolean type is ; it is a defined type.\n\nAn integer, floating-point, or complex type represents the set of integer, floating-point, or complex values, respectively. They are collectively called numeric types. The predeclared architecture-independent numeric types are:\n\nThe value of an n-bit integer is n bits wide and represented using two's complement arithmetic.\n\nThere is also a set of predeclared integer types with implementation-specific sizes:\n\nTo avoid portability issues all numeric types are defined types and thus distinct except , which is an alias for , and , which is an alias for . Explicit conversions are required when different numeric types are mixed in an expression or assignment. For instance, and are not the same type even though they may have the same size on a particular architecture.\n\nA string type represents the set of string values. A string value is a (possibly empty) sequence of bytes. The number of bytes is called the length of the string and is never negative. Strings are immutable: once created, it is impossible to change the contents of a string. The predeclared string type is ; it is a defined type.\n\nThe length of a string can be discovered using the built-in function . The length is a compile-time constant if the string is a constant. A string's bytes can be accessed by integer indices 0 through . It is illegal to take the address of such an element; if is the 'th byte of a string, is invalid.\n\nAn array is a numbered sequence of elements of a single type, called the element type. The number of elements is called the length of the array and is never negative.\n\nThe length is part of the array's type; it must evaluate to a non-negative constant representable by a value of type . The length of array can be discovered using the built-in function . The elements can be addressed by integer indices 0 through . Array types are always one-dimensional but may be composed to form multi-dimensional types.\n\nAn array type may not have an element of type , or of a type containing as a component, directly or indirectly, if those containing types are only array or struct types.\n\nA slice is a descriptor for a contiguous segment of an underlying array and provides access to a numbered sequence of elements from that array. A slice type denotes the set of all slices of arrays of its element type. The number of elements is called the length of the slice and is never negative. The value of an uninitialized slice is .\n\nThe length of a slice can be discovered by the built-in function ; unlike with arrays it may change during execution. The elements can be addressed by integer indices 0 through . The slice index of a given element may be less than the index of the same element in the underlying array.\n\nA slice, once initialized, is always associated with an underlying array that holds its elements. A slice therefore shares storage with its array and with other slices of the same array; by contrast, distinct arrays always represent distinct storage.\n\nThe array underlying a slice may extend past the end of the slice. The capacity is a measure of that extent: it is the sum of the length of the slice and the length of the array beyond the slice; a slice of length up to that capacity can be created by slicing a new one from the original slice. The capacity of a slice can be discovered using the built-in function .\n\nA new, initialized slice value for a given element type may be made using the built-in function , which takes a slice type and parameters specifying the length and optionally the capacity. A slice created with always allocates a new, hidden array to which the returned slice value refers. That is, executing\n\nproduces the same slice as allocating an array and slicing it, so these two expressions are equivalent:\n\nLike arrays, slices are always one-dimensional but may be composed to construct higher-dimensional objects. With arrays of arrays, the inner arrays are, by construction, always the same length; however with slices of slices (or arrays of slices), the inner lengths may vary dynamically. Moreover, the inner slices must be initialized individually.\n\nA struct is a sequence of named elements, called fields, each of which has a name and a type. Field names may be specified explicitly (IdentifierList) or implicitly (EmbeddedField). Within a struct, non-blank field names must be unique.\n\nA field declared with a type but no explicit field name is called an embedded field. An embedded field must be specified as a type name or as a pointer to a non-interface type name , and itself may not be a pointer type or type parameter. The unqualified type name acts as the field name.\n\nThe following declaration is illegal because field names must be unique in a struct type:\n\nA field or method of an embedded field in a struct is called promoted if is a legal selector that denotes that field or method .\n\nPromoted fields act like ordinary fields of a struct except that they cannot be used as field names in composite literals of the struct.\n\nGiven a struct type and a type name , promoted methods are included in the method set of the struct as follows:\n• If contains an embedded field , the method sets of and both include promoted methods with receiver . The method set of also includes promoted methods with receiver .\n• If contains an embedded field , the method sets of and both include promoted methods with receiver or .\n\nA field declaration may be followed by an optional string literal tag, which becomes an attribute for all the fields in the corresponding field declaration. An empty tag string is equivalent to an absent tag. The tags are made visible through a reflection interface and take part in type identity for structs but are otherwise ignored.\n\nA struct type may not contain a field of type , or of a type containing as a component, directly or indirectly, if those containing types are only array or struct types.\n\nA pointer type denotes the set of all pointers to variables of a given type, called the base type of the pointer. The value of an uninitialized pointer is .\n\nA function type denotes the set of all functions with the same parameter and result types. The value of an uninitialized variable of function type is .\n\nWithin a list of parameters or results, the names (IdentifierList) must either all be present or all be absent. If present, each name stands for one item (parameter or result) of the specified type and all non-blank names in the signature must be unique. If absent, each type stands for one item of that type. Parameter and result lists are always parenthesized except that if there is exactly one unnamed result it may be written as an unparenthesized type.\n\nThe final incoming parameter in a function signature may have a type prefixed with . A function with such a parameter is called variadic and may be invoked with zero or more arguments for that parameter.\n\nAn interface type defines a type set. A variable of interface type can store a value of any type that is in the type set of the interface. Such a type is said to implement the interface. The value of an uninitialized variable of interface type is .\n\nAn interface type is specified by a list of interface elements. An interface element is either a method or a type element, where a type element is a union of one or more type terms. A type term is either a single type or a single underlying type.\n\nIn its most basic form an interface specifies a (possibly empty) list of methods. The type set defined by such an interface is the set of types which implement all of those methods, and the corresponding method set consists exactly of the methods specified by the interface. Interfaces whose type sets can be defined entirely by a list of methods are called basic interfaces.\n\nThe name of each explicitly specified method must be unique and not blank.\n\nMore than one type may implement an interface. For instance, if two types and have the method set\n\n(where stands for either or ) then the interface is implemented by both and , regardless of what other methods and may have or share.\n\nEvery type that is a member of the type set of an interface implements that interface. Any given type may implement several distinct interfaces. For instance, all types implement the empty interface which stands for the set of all (non-interface) types:\n\nFor convenience, the predeclared type is an alias for the empty interface. [Go 1.18]\n\nSimilarly, consider this interface specification, which appears within a type declaration to define an interface called :\n\nIf and also implement\n\nthey implement the interface as well as the interface.\n\nIn a slightly more general form an interface may use a (possibly qualified) interface type name as an interface element. This is called embedding interface in [Go 1.14]. The type set of is the intersection of the type sets defined by 's explicitly declared methods and the type sets of ’s embedded interfaces. In other words, the type set of is the set of all types that implement all the explicitly declared methods of and also all the methods of [Go 1.18].\n\nWhen embedding interfaces, methods with the same names must have identical signatures.\n\nIn their most general form, an interface element may also be an arbitrary type term , or a term of the form specifying the underlying type , or a union of terms [Go 1.18]. Together with method specifications, these elements enable the precise definition of an interface's type set as follows:\n• The type set of the empty interface is the set of all non-interface types.\n• The type set of a non-empty interface is the intersection of the type sets of its interface elements.\n• The type set of a method specification is the set of all non-interface types whose method sets include that method.\n• The type set of a non-interface type term is the set consisting of just that type.\n• The type set of a term of the form is the set of all types whose underlying type is .\n• The type set of a union of terms is the union of the type sets of the terms.\n\nThe quantification \"the set of all non-interface types\" refers not just to all (non-interface) types declared in the program at hand, but all possible types in all possible programs, and hence is infinite. Similarly, given the set of all non-interface types that implement a particular method, the intersection of the method sets of those types will contain exactly that method, even if all types in the program at hand always pair that method with another method.\n\nBy construction, an interface's type set never contains an interface type.\n\nIn a term of the form , the underlying type of must be itself, and cannot be an interface.\n\nThe type in a term of the form or cannot be a type parameter, and the type sets of all non-interface terms must be pairwise disjoint (the pairwise intersection of the type sets must be empty). Given a type parameter :\n\nImplementation restriction: A union (with more than one term) cannot contain the predeclared identifier or interfaces that specify methods, or embed or interfaces that specify methods.\n\nInterfaces that are not basic may only be used as type constraints, or as elements of other interfaces used as constraints. They cannot be the types of values or variables, or components of other, non-interface types.\n\nAn interface type may not embed a type element that is, contains, or embeds , directly or indirectly.\n• is not an interface and is an element of the type set of ; or\n• is an interface and the type set of is a subset of the type set of .\n\nA value of type implements an interface if implements the interface.\n\nA map is an unordered group of elements of one type, called the element type, indexed by a set of unique keys of another type, called the key type. The value of an uninitialized map is .\n\nThe comparison operators and must be fully defined for operands of the key type; thus the key type must not be a function, map, or slice. If the key type is an interface type, these comparison operators must be defined for the dynamic key values; failure will cause a run-time panic.\n\nThe number of map elements is called its length. For a map , it can be discovered using the built-in function and may change during execution. Elements may be added during execution using assignments and retrieved with index expressions; they may be removed with the and built-in function.\n\nA new, empty map value is made using the built-in function , which takes the map type and an optional capacity hint as arguments:\n\nThe initial capacity does not bound its size: maps grow to accommodate the number of items stored in them, with the exception of maps. A map is equivalent to an empty map except that no elements may be added.\n\nA channel provides a mechanism for concurrently executing functions to communicate by sending and receiving values of a specified element type. The value of an uninitialized channel is .\n\nThe optional operator specifies the channel direction, send or receive. If a direction is given, the channel is directional, otherwise it is bidirectional. A channel may be constrained only to send or only to receive by assignment or explicit conversion.\n\nThe operator associates with the leftmost possible:\n\nA new, initialized channel value can be made using the built-in function , which takes the channel type and an optional capacity as arguments:\n\nThe capacity, in number of elements, sets the size of the buffer in the channel. If the capacity is zero or absent, the channel is unbuffered and communication succeeds only when both a sender and receiver are ready. Otherwise, the channel is buffered and communication succeeds without blocking if the buffer is not full (sends) or not empty (receives). A channel is never ready for communication.\n\nA channel may be closed with the built-in function . The multi-valued assignment form of the receive operator reports whether a received value was sent before the channel was closed.\n\nA single channel may be used in send statements, receive operations, and calls to the built-in functions and by any number of goroutines without further synchronization. Channels act as first-in-first-out queues. For example, if one goroutine sends values on a channel and a second goroutine receives them, the values are received in the order sent.\n\nValues of predeclared types (see below for the interfaces and ), arrays, and structs are self-contained: Each such value contains a complete copy of all its data, and variables of such types store the entire value. For instance, an array variable provides the storage (the variables) for all elements of the array. The respective zero values are specific to the value's types; they are never .\n\nNon-nil pointer, function, slice, map, and channel values contain references to underlying data which may be shared by multiple values:\n• A pointer value is a reference to the variable holding the pointer base type value.\n• A function value contains references to the (possibly anonymous) function and enclosed variables.\n• A slice value contains the slice length, capacity, and a reference to its underlying array.\n• A map or channel value is a reference to the implementation-specific data structure of the map or channel.\n\nAn interface value may be self-contained or contain references to underlying data depending on the interface's dynamic type. The predeclared identifier is the zero value for types whose values can contain references.\n\nWhen multiple values share underlying data, changing one value may change another. For instance, changing an element of a slice will change that element in the underlying array for all slices that share the array.\n\nEach type has an underlying type: If is one of the predeclared boolean, numeric, or string types, or a type literal, the corresponding underlying type is itself. Otherwise, 's underlying type is the underlying type of the type to which refers in its declaration. For a type parameter that is the underlying type of its type constraint, which is always an interface.\n\nThe underlying type of , , , , and is . The underlying type of , , and is . The underlying type of is .\n\nEach non-interface type has a core type, which is the same as the underlying type of .\n\nAn interface has a core type if one of the following conditions is satisfied:\n• There is a single type which is the underlying type of all types in the type set of ; or\n• the type set of contains only channel types with identical element type , and all directional channels have the same direction.\n\nNo other interfaces have a core type.\n\nThe core type of an interface is, depending on the condition that is satisfied, either:\n• the type if contains only bidirectional channels, or the type or depending on the direction of the directional channels present.\n\nBy definition, a core type is never a defined type, type parameter, or interface type.\n\nSome operations (slice expressions, and ) rely on a slightly more loose form of core types which accept byte slices and strings. Specifically, if there are exactly two types, and , which are the underlying types of all types in the type set of interface , the core type of is called .\n\nNote that is not a real type; it cannot be used to declare variables or compose other types. It exists solely to describe the behavior of some operations that read from a sequence of bytes, which may be a byte slice or a string.\n\nTwo types are either identical or different.\n\nA named type is always different from any other type. Otherwise, two types are identical if their underlying type literals are structurally equivalent; that is, they have the same literal structure and corresponding components have identical types. In detail:\n• Two array types are identical if they have identical element types and the same array length.\n• Two slice types are identical if they have identical element types.\n• Two struct types are identical if they have the same sequence of fields, and if corresponding pairs of fields have the same names, identical types, and identical tags, and are either both embedded or both not embedded. Non-exported field names from different packages are always different.\n• Two pointer types are identical if they have identical base types.\n• Two function types are identical if they have the same number of parameters and result values, corresponding parameter and result types are identical, and either both functions are variadic or neither is. Parameter and result names are not required to match.\n• Two interface types are identical if they define the same type set.\n• Two map types are identical if they have identical key and element types.\n• Two channel types are identical if they have identical element types and the same direction.\n• Two instantiated types are identical if their defined types and all type arguments are identical.\n\nand are different because they are new types created by distinct type definitions; and are different because is different from ; and and are different because they are different type parameters. and are different because the former is an instantiated defined type while the latter is a type literal (but they are still assignable).\n\nA value of type is assignable to a variable of type (\" is assignable to \") if one of the following conditions applies:\n• and have identical underlying types but are not type parameters and at least one of or is not a named type.\n• and are channel types with identical element types, is a bidirectional channel, and at least one of or is not a named type.\n• is an interface type, but not a type parameter, and implements .\n• is the predeclared identifier and is a pointer, function, slice, map, channel, or interface type, but not a type parameter.\n• is an untyped constant representable by a value of type .\n\nAdditionally, if 's type or are type parameters, is assignable to a variable of type if one of the following conditions applies:\n• is the predeclared identifier , is a type parameter, and is assignable to each type in 's type set.\n• is not a named type, is a type parameter, and is assignable to each type in 's type set.\n• is a type parameter and is not a named type, and values of each type in 's type set are assignable to .\n\nA constant is representable by a value of type , where is not a type parameter, if one of the following conditions applies:\n• is in the set of values determined by .\n• is a floating-point type and can be rounded to 's precision without overflow. Rounding uses IEEE 754 round-to-even rules but with an IEEE negative zero further simplified to an unsigned zero. Note that constant values never result in an IEEE negative zero, NaN, or infinity.\n• is a complex type, and 's components and are representable by values of 's component type ( or ).\n\nIf is a type parameter, is representable by a value of type if is representable by a value of each type in 's type set.\n\nThe method set of a type determines the methods that can be called on an operand of that type. Every type has a (possibly empty) method set associated with it:\n• The method set of a defined type consists of all methods declared with receiver type .\n• The method set of a pointer to a defined type (where is neither a pointer nor an interface) is the set of all methods declared with receiver or .\n• The method set of an interface type is the intersection of the method sets of each type in the interface's type set (the resulting method set is usually just the set of declared methods in the interface).\n\nFurther rules apply to structs (and pointer to structs) containing embedded fields, as described in the section on struct types. Any other type has an empty method set.\n\nIn a method set, each method must have a unique non-blank method name.\n\nA block is a possibly empty sequence of declarations and statements within matching brace brackets.\n\nIn addition to explicit blocks in the source code, there are implicit blocks:\n• The universe block encompasses all Go source text.\n• Each package has a package block containing all Go source text for that package.\n• Each file has a file block containing all Go source text in that file.\n• Each \"if\", \"for\", and \"switch\" statement is considered to be in its own implicit block.\n• Each clause in a \"switch\" or \"select\" statement acts as an implicit block.\n\nA declaration binds a non-blank identifier to a constant, type, type parameter, variable, function, label, or package. Every identifier in a program must be declared. No identifier may be declared twice in the same block, and no identifier may be declared in both the file and package block.\n\nThe blank identifier may be used like any other identifier in a declaration, but it does not introduce a binding and thus is not declared. In the package block, the identifier may only be used for function declarations, and like the blank identifier it does not introduce a new binding.\n\nThe scope of a declared identifier is the extent of source text in which the identifier denotes the specified constant, type, variable, function, label, or package.\n\nGo is lexically scoped using blocks:\n• The scope of a predeclared identifier is the universe block.\n• The scope of an identifier denoting a constant, type, variable, or function (but not method) declared at top level (outside any function) is the package block.\n• The scope of the package name of an imported package is the file block of the file containing the import declaration.\n• The scope of an identifier denoting a method receiver, function parameter, or result variable is the function body.\n• The scope of an identifier denoting a type parameter of a function or declared by a method receiver begins after the name of the function and ends at the end of the function body.\n• The scope of an identifier denoting a type parameter of a type begins after the name of the type and ends at the end of the TypeSpec.\n• The scope of a constant or variable identifier declared inside a function begins at the end of the ConstSpec or VarSpec (ShortVarDecl for short variable declarations) and ends at the end of the innermost containing block.\n• The scope of a type identifier declared inside a function begins at the identifier in the TypeSpec and ends at the end of the innermost containing block.\n\nAn identifier declared in a block may be redeclared in an inner block. While the identifier of the inner declaration is in scope, it denotes the entity declared by the inner declaration.\n\nThe package clause is not a declaration; the package name does not appear in any scope. Its purpose is to identify the files belonging to the same package and to specify the default package name for import declarations.\n\nLabels are declared by labeled statements and are used in the \"break\", \"continue\", and \"goto\" statements. It is illegal to define a label that is never used. In contrast to other identifiers, labels are not block scoped and do not conflict with identifiers that are not labels. The scope of a label is the body of the function in which it is declared and excludes the body of any nested function.\n\nThe blank identifier is represented by the underscore character . It serves as an anonymous placeholder instead of a regular (non-blank) identifier and has special meaning in declarations, as an operand, and in assignment statements.\n\nThe following identifiers are implicitly declared in the universe block [Go 1.18] [Go 1.21]:\n\nAn identifier may be exported to permit access to it from another package. An identifier is exported if both:\n• the first character of the identifier's name is a Unicode uppercase letter (Unicode character category Lu); and\n• the identifier is declared in the package block or it is a field name or method name.\n\nAll other identifiers are not exported.\n\nGiven a set of identifiers, an identifier is called unique if it is different from every other in the set. Two identifiers are different if they are spelled differently, or if they appear in different packages and are not exported. Otherwise, they are the same.\n\nA constant declaration binds a list of identifiers (the names of the constants) to the values of a list of constant expressions. The number of identifiers must be equal to the number of expressions, and the nth identifier on the left is bound to the value of the nth expression on the right.\n\nIf the type is present, all constants take the type specified, and the expressions must be assignable to that type, which must not be a type parameter. If the type is omitted, the constants take the individual types of the corresponding expressions. If the expression values are untyped constants, the declared constants remain untyped and the constant identifiers denote the constant values. For instance, if the expression is a floating-point literal, the constant identifier denotes a floating-point constant, even if the literal's fractional part is zero.\n\nWithin a parenthesized declaration list the expression list may be omitted from any but the first ConstSpec. Such an empty list is equivalent to the textual substitution of the first preceding non-empty expression list and its type if any. Omitting the list of expressions is therefore equivalent to repeating the previous list. The number of identifiers must be equal to the number of expressions in the previous list. Together with the constant generator this mechanism permits light-weight declaration of sequential values:\n\nWithin a constant declaration, the predeclared identifier represents successive untyped integer constants. Its value is the index of the respective ConstSpec in that constant declaration, starting at zero. It can be used to construct a set of related constants:\n\nBy definition, multiple uses of in the same ConstSpec all have the same value:\n\nThis last example exploits the implicit repetition of the last non-empty expression list.\n\nA type declaration binds an identifier, the type name, to a type. Type declarations come in two forms: alias declarations and type definitions.\n\nAn alias declaration binds an identifier to the given type [Go 1.9].\n\nWithin the scope of the identifier, it serves as an alias for the given type.\n\nIf the alias declaration specifies type parameters [Go 1.24], the type name denotes a generic alias. Generic aliases must be instantiated when they are used.\n\nIn an alias declaration the given type cannot be a type parameter.\n\nA type definition creates a new, distinct type with the same underlying type and operations as the given type and binds an identifier, the type name, to it.\n\nThe new type is called a defined type. It is different from any other type, including the type it is created from.\n\nA defined type may have methods associated with it. It does not inherit any methods bound to the given type, but the method set of an interface type or of elements of a composite type remains unchanged:\n\nType definitions may be used to define different boolean, numeric, or string types and associate methods with them:\n\nIf the type definition specifies type parameters, the type name denotes a generic type. Generic types must be instantiated when they are used.\n\nIn a type definition the given type cannot be a type parameter.\n\nA generic type may also have methods associated with it. In this case, the method receivers must declare the same number of type parameters as present in the generic type definition.\n\nA type parameter list declares the type parameters of a generic function or type declaration. The type parameter list looks like an ordinary function parameter list except that the type parameter names must all be present and the list is enclosed in square brackets rather than parentheses [Go 1.18].\n\nAll non-blank names in the list must be unique. Each name declares a type parameter, which is a new and different named type that acts as a placeholder for an (as of yet) unknown type in the declaration. The type parameter is replaced with a type argument upon instantiation of the generic function or type.\n\nJust as each ordinary function parameter has a parameter type, each type parameter has a corresponding (meta-)type which is called its type constraint.\n\nA parsing ambiguity arises when the type parameter list for a generic type declares a single type parameter with a constraint such that the text forms a valid expression:\n\nIn these rare cases, the type parameter list is indistinguishable from an expression and the type declaration is parsed as an array type declaration. To resolve the ambiguity, embed the constraint in an interface or use a trailing comma:\n\nType parameters may also be declared by the receiver specification of a method declaration associated with a generic type.\n\nWithin a type parameter list of a generic type , a type constraint may not (directly, or indirectly through the type parameter list of another generic type) refer to .\n\nA type constraint is an interface that defines the set of permissible type arguments for the respective type parameter and controls the operations supported by values of that type parameter [Go 1.18].\n\nIf the constraint is an interface literal of the form where is an embedded type element (not a method), in a type parameter list the enclosing may be omitted for convenience:\n\nThe predeclared interface type denotes the set of all non-interface types that are strictly comparable [Go 1.18].\n\nEven though interfaces that are not type parameters are comparable, they are not strictly comparable and therefore they do not implement . However, they satisfy .\n\nThe interface and interfaces that (directly or indirectly) embed may only be used as type constraints. They cannot be the types of values or variables, or components of other, non-interface types.\n\nA type argument satisfies a type constraint if is an element of the type set defined by ; in other words, if implements . As an exception, a strictly comparable type constraint may also be satisfied by a comparable (not necessarily strictly comparable) type argument [Go 1.20]. More precisely:\n• can be written in the form , where is a basic interface and is comparable and implements .\n\nBecause of the exception in the constraint satisfaction rule, comparing operands of type parameter type may panic at run-time (even though comparable type parameters are always strictly comparable).\n\nA variable declaration creates one or more variables, binds corresponding identifiers to them, and gives each a type and an initial value.\n\nIf a list of expressions is given, the variables are initialized with the expressions following the rules for assignment statements. Otherwise, each variable is initialized to its zero value.\n\nIf a type is present, each variable is given that type. Otherwise, each variable is given the type of the corresponding initialization value in the assignment. If that value is an untyped constant, it is first implicitly converted to its default type; if it is an untyped boolean value, it is first implicitly converted to type . The predeclared identifier cannot be used to initialize a variable with no explicit type.\n\nImplementation restriction: A compiler may make it illegal to declare a variable inside a function body if the variable is never used.\n\nIt is shorthand for a regular variable declaration with initializer expressions but no types:\n\nUnlike regular variable declarations, a short variable declaration may redeclare variables provided they were originally declared earlier in the same block (or the parameter lists if the block is the function body) with the same type, and at least one of the non-blank variables is new. As a consequence, redeclaration can only appear in a multi-variable short declaration. Redeclaration does not introduce a new variable; it just assigns a new value to the original. The non-blank variable names on the left side of must be unique.\n\nShort variable declarations may appear only inside functions. In some contexts such as the initializers for \"if\", \"for\", or \"switch\" statements, they can be used to declare local temporary variables.\n\nA function declaration binds an identifier, the function name, to a function.\n\nIf the function's signature declares result parameters, the function body's statement list must end in a terminating statement.\n\nIf the function declaration specifies type parameters, the function name denotes a generic function. A generic function must be instantiated before it can be called or used as a value.\n\nA function declaration without type parameters may omit the body. Such a declaration provides the signature for a function implemented outside Go, such as an assembly routine.\n\nA method is a function with a receiver. A method declaration binds an identifier, the method name, to a method, and associates the method with the receiver's base type.\n\nThe receiver is specified via an extra parameter section preceding the method name. That parameter section must declare a single non-variadic parameter, the receiver. Its type must be a defined type or a pointer to a defined type , possibly followed by a list of type parameter names enclosed in square brackets. is called the receiver base type. A receiver base type cannot be a pointer or interface type and it must be defined in the same package as the method. The method is said to be bound to its receiver base type and the method name is visible only within selectors for type or .\n\nA non-blank receiver identifier must be unique in the method signature. If the receiver's value is not referenced inside the body of the method, its identifier may be omitted in the declaration. The same applies in general to parameters of functions and methods.\n\nFor a base type, the non-blank names of methods bound to it must be unique. If the base type is a struct type, the non-blank method and field names must be distinct.\n\nbind the methods and , with receiver type , to the base type .\n\nIf the receiver base type is a generic type, the receiver specification must declare corresponding type parameters for the method to use. This makes the receiver type parameters available to the method. Syntactically, this type parameter declaration looks like an instantiation of the receiver base type: the type arguments must be identifiers denoting the type parameters being declared, one for each type parameter of the receiver base type. The type parameter names do not need to match their corresponding parameter names in the receiver base type definition, and all non-blank parameter names must be unique in the receiver parameter section and the method signature. The receiver type parameter constraints are implied by the receiver base type definition: corresponding type parameters have corresponding constraints.\n\nIf the receiver type is denoted by (a pointer to) an alias, the alias must not be generic and it must not denote an instantiated generic type, neither directly nor indirectly via another alias, and irrespective of pointer indirections.\n\nAn expression specifies the computation of a value by applying operators and functions to operands.\n\nOperands denote the elementary values in an expression. An operand may be a literal, a (possibly qualified) non-blank identifier denoting a constant, variable, or function, or a parenthesized expression.\n\nAn operand name denoting a generic function may be followed by a list of type arguments; the resulting operand is an instantiated function.\n\nThe blank identifier may appear as an operand only on the left-hand side of an assignment statement.\n\nImplementation restriction: A compiler need not report an error if an operand's type is a type parameter with an empty type set. Functions with such type parameters cannot be instantiated; any attempt will lead to an error at the instantiation site.\n\nA qualified identifier is an identifier qualified with a package name prefix. Both the package name and the identifier must not be blank.\n\nA qualified identifier accesses an identifier in a different package, which must be imported. The identifier must be exported and declared in the package block of that package.\n\nComposite literals construct new composite values each time they are evaluated. They consist of the type of the literal followed by a brace-bound list of elements. Each element may optionally be preceded by a corresponding key.\n\nThe LiteralType's core type must be a struct, array, slice, or map type (the syntax enforces this constraint except when the type is given as a TypeName). The types of the elements and keys must be assignable to the respective field, element, and key types of type ; there is no additional conversion. The key is interpreted as a field name for struct literals, an index for array and slice literals, and a key for map literals. For map literals, all elements must have a key. It is an error to specify multiple elements with the same field name or constant key value. For non-constant map keys, see the section on evaluation order.\n\nFor struct literals the following rules apply:\n• A key must be a field name declared in the struct type.\n• An element list that does not contain any keys must list an element for each struct field in the order in which the fields are declared.\n• If any element has a key, every element must have a key.\n• An element list that contains keys does not need to have an element for each struct field. Omitted fields get the zero value for that field.\n• A literal may omit the element list; such a literal evaluates to the zero value for its type.\n• It is an error to specify an element for a non-exported field of a struct belonging to a different package.\n\nFor array and slice literals the following rules apply:\n• Each element has an associated integer index marking its position in the array.\n• An element with a key uses the key as its index. The key must be a non-negative constant representable by a value of type ; and if it is typed it must be of integer type.\n• An element without a key uses the previous element's index plus one. If the first element has no key, its index is zero.\n\nTaking the address of a composite literal generates a pointer to a unique variable initialized with the literal's value.\n\nNote that the zero value for a slice or map type is not the same as an initialized but empty value of the same type. Consequently, taking the address of an empty slice or map composite literal does not have the same effect as allocating a new slice or map value with new.\n\nThe length of an array literal is the length specified in the literal type. If fewer elements than the length are provided in the literal, the missing elements are set to the zero value for the array element type. It is an error to provide elements with index values outside the index range of the array. The notation specifies an array length equal to the maximum element index plus one.\n\nA slice literal describes the entire underlying array literal. Thus the length and capacity of a slice literal are the maximum element index plus one. A slice literal has the form\n\nand is shorthand for a slice operation applied to an array:\n\nWithin a composite literal of array, slice, or map type , elements or map keys that are themselves composite literals may elide the respective literal type if it is identical to the element or key type of . Similarly, elements or keys that are addresses of composite literals may elide the when the element or key type is .\n\nA parsing ambiguity arises when a composite literal using the TypeName form of the LiteralType appears as an operand between the keyword and the opening brace of the block of an \"if\", \"for\", or \"switch\" statement, and the composite literal is not enclosed in parentheses, square brackets, or curly braces. In this rare case, the opening brace of the literal is erroneously parsed as the one introducing the block of statements. To resolve the ambiguity, the composite literal must appear within parentheses.\n\nA function literal can be assigned to a variable or invoked directly.\n\nFunction literals are closures: they may refer to variables defined in a surrounding function. Those variables are then shared between the surrounding function and the function literal, and they survive as long as they are accessible.\n\nPrimary expressions are the operands for unary and binary expressions.\n\nFor a primary expression that is not a package name, the selector expression\n\ndenotes the field or method of the value (or sometimes ; see below). The identifier is called the (field or method) selector; it must not be the blank identifier. The type of the selector expression is the type of . If is a package name, see the section on qualified identifiers.\n\nA selector may denote a field or method of a type , or it may refer to a field or method of a nested embedded field of . The number of embedded fields traversed to reach is called its depth in . The depth of a field or method declared in is zero. The depth of a field or method declared in an embedded field in is the depth of in plus one.\n\nThe following rules apply to selectors:\n• For a value of type or where is not a pointer or interface type, denotes the field or method at the shallowest depth in where there is such an . If there is not exactly one with shallowest depth, the selector expression is illegal.\n• For a value of type where is an interface type, denotes the actual method with name of the dynamic value of . If there is no method with name in the method set of , the selector expression is illegal.\n• As an exception, if the type of is a defined pointer type and is a valid selector expression denoting a field (but not a method), is shorthand for .\n• In all other cases, is illegal.\n• If is of pointer type and has the value and denotes a struct field, assigning to or evaluating causes a run-time panic.\n• If is of interface type and has the value , calling or evaluating the method causes a run-time panic.\n\nFor example, given the declarations:\n\nbut the following is invalid:\n\nIf is in the method set of type , is a function that is callable as a regular function with the same arguments as prefixed by an additional argument that is the receiver of the method.\n\nConsider a struct type with two methods, , whose receiver is of type , and , whose receiver is of type .\n\nyields a function equivalent to but with an explicit receiver as its first argument; it has signature\n\nThat function may be called normally with an explicit receiver, so these five invocations are equivalent:\n\nFor a method with a value receiver, one can derive a function with an explicit pointer receiver, so\n\nSuch a function indirects through the receiver to create a value to pass as the receiver to the underlying method; the method does not overwrite the value whose address is passed in the function call.\n\nThe final case, a value-receiver function for a pointer-receiver method, is illegal because pointer-receiver methods are not in the method set of the value type.\n\nFunction values derived from methods are called with function call syntax; the receiver is provided as the first argument to the call. That is, given , is invoked as not . To construct a function that binds the receiver, use a function literal or method value.\n\nIt is legal to derive a function value from a method of an interface type. The resulting function takes an explicit receiver of that interface type.\n\nIf the expression has static type and is in the method set of type , is called a method value. The method value is a function value that is callable with the same arguments as a method call of . The expression is evaluated and saved during the evaluation of the method value; the saved copy is then used as the receiver in any calls, which may be executed later.\n\nThe type may be an interface or non-interface type.\n\nAs in the discussion of method expressions above, consider a struct type with two methods, , whose receiver is of type , and , whose receiver is of type .\n\nThese two invocations are equivalent:\n\nAs with selectors, a reference to a non-interface method with a value receiver using a pointer will automatically dereference that pointer: is equivalent to .\n\nAs with method calls, a reference to a non-interface method with a pointer receiver using an addressable value will automatically take the address of that value: is equivalent to .\n\nAlthough the examples above use non-interface types, it is also legal to create a method value from a value of interface type.\n\ndenotes the element of the array, pointer to array, slice, string or map indexed by . The value is called the index or map key, respectively. The following rules apply:\n\nIf is neither a map nor a type parameter:\n• the index must be an untyped constant or its core type must be an integer\n• a constant index must be non-negative and representable by a value of type\n• a constant index that is untyped is given type\n• the index is in range if , otherwise it is out of range\n• a constant index must be in range\n• if is out of range at run time, a run-time panic occurs\n• is the array element at index and the type of is the element type of\n\nFor of pointer to array type:\n• if is out of range at run time, a run-time panic occurs\n• is the slice element at index and the type of is the element type of\n• a constant index must be in range if the string is also constant\n• if is out of range at run time, a run-time panic occurs\n• is the non-constant byte value at index and the type of is\n• may not be assigned to\n• 's type must be assignable to the key type of\n• if the map contains an entry with key , is the map element with key and the type of is the element type of\n• if the map is or does not contain such an entry, is the zero value for the element type of\n• The index expression must be valid for values of all types in 's type set.\n• The element types of all types in 's type set must be identical. In this context, the element type of a string type is .\n• If there is a map type in the type set of , all types in that type set must be map types, and the respective key types must be all identical.\n• is the array, slice, or string element at index , or the map element with key of the type argument that is instantiated with, and the type of is the type of the (identical) element types.\n• may not be assigned to if 's type set includes string types.\n\nAn index expression on a map of type used in an assignment statement or initialization of the special form\n\nyields an additional untyped boolean value. The value of is if the key is present in the map, and otherwise.\n\nAssigning to an element of a map causes a run-time panic.\n\nSlice expressions construct a substring or slice from a string, array, pointer to array, or slice. There are two variants: a simple form that specifies a low and high bound, and a full form that also specifies a bound on the capacity.\n\nconstructs a substring or slice. The core type of must be a string, array, pointer to array, slice, or a . The indices and select which elements of operand appear in the result. The result has indices starting at 0 and length equal to - . After slicing the array\n\nthe slice has type , length 3, capacity 4, and elements\n\nFor convenience, any of the indices may be omitted. A missing index defaults to zero; a missing index defaults to the length of the sliced operand:\n\nIf is a pointer to an array, is shorthand for .\n\nFor arrays or strings, the indices are in range if <= <= <= , otherwise they are out of range. For slices, the upper index bound is the slice capacity rather than the length. A constant index must be non-negative and representable by a value of type ; for arrays or constant strings, constant indices must also be in range. If both indices are constant, they must satisfy . If the indices are out of range at run time, a run-time panic occurs.\n\nExcept for untyped strings, if the sliced operand is a string or slice, the result of the slice operation is a non-constant value of the same type as the operand. For untyped string operands the result is a non-constant value of type . If the sliced operand is an array, it must be addressable and the result of the slice operation is a slice with the same element type as the array.\n\nIf the sliced operand of a valid slice expression is a slice, the result is a slice. Otherwise, if the result is a slice, it shares its underlying array with the operand.\n\nconstructs a slice of the same type, and with the same length and elements as the simple slice expression . Additionally, it controls the resulting slice's capacity by setting it to . Only the first index may be omitted; it defaults to 0. The core type of must be an array, pointer to array, or slice (but not a string). After slicing the array\n\nthe slice has type , length 2, capacity 4, and elements\n\nAs for simple slice expressions, if is a pointer to an array, is shorthand for . If the sliced operand is an array, it must be addressable.\n\nThe indices are in range if , otherwise they are out of range. A constant index must be non-negative and representable by a value of type ; for arrays, constant indices must also be in range. If multiple indices are constant, the constants that are present must be in range relative to each other. If the indices are out of range at run time, a run-time panic occurs.\n\nFor an expression of interface type, but not a type parameter, and a type , the primary expression\n\nasserts that is not and that the value stored in is of type . The notation is called a type assertion.\n\nMore precisely, if is not an interface type, asserts that the dynamic type of is identical to the type . In this case, must implement the (interface) type of ; otherwise the type assertion is invalid since it is not possible for to store a value of type . If is an interface type, asserts that the dynamic type of implements the interface .\n\nIf the type assertion holds, the value of the expression is the value stored in and its type is . If the type assertion is false, a run-time panic occurs. In other words, even though the dynamic type of is known only at run time, the type of is known to be in a correct program.\n\nA type assertion used in an assignment statement or initialization of the special form\n\nyields an additional untyped boolean value. The value of is if the assertion holds. Otherwise it is and the value of is the zero value for type . No run-time panic occurs in this case.\n\nGiven an expression with a core type of function type,\n\ncalls with arguments . Except for one special case, arguments must be single-valued expressions assignable to the parameter types of and are evaluated before the function is called. The type of the expression is the result type of . A method invocation is similar but the method itself is specified as a selector upon a value of the receiver type for the method.\n\nIf denotes a generic function, it must be instantiated before it can be called or used as a function value.\n\nIn a function call, the function value and arguments are evaluated in the usual order. After they are evaluated, new storage is allocated for the function's variables, which includes its parameters and results. Then, the arguments of the call are passed to the function, which means that they are assigned to their corresponding function parameters, and the called function begins execution. The return parameters of the function are passed back to the caller when the function returns.\n\nAs a special case, if the return values of a function or method are equal in number and individually assignable to the parameters of another function or method , then the call will invoke after passing the return values of to the parameters of in order. The call of must contain no parameters other than the call of , and must have at least one return value. If has a final parameter, it is assigned the return values of that remain after assignment of regular parameters.\n\nA method call is valid if the method set of (the type of) contains and the argument list can be assigned to the parameter list of . If is addressable and 's method set contains , is shorthand for :\n\nThere is no distinct method type and there are no method literals.\n\nIf is variadic with a final parameter of type , then within the type of is equivalent to type . If is invoked with no actual arguments for , the value passed to is . Otherwise, the value passed is a new slice of type with a new underlying array whose successive elements are the actual arguments, which all must be assignable to . The length and capacity of the slice is therefore the number of arguments bound to and may differ for each call site.\n\nGiven the function and calls\n\nwithin , will have the value in the first call, and in the second.\n\nIf the final argument is assignable to a slice type and is followed by , it is passed unchanged as the value for a parameter. In this case no new slice is created.\n\nGiven the slice and call\n\nwithin , will have the same value as with the same underlying array.\n\nA generic function or type is instantiated by substituting type arguments for the type parameters [Go 1.18]. Instantiation proceeds in two steps:\n• Each type argument is substituted for its corresponding type parameter in the generic declaration. This substitution happens across the entire function or type declaration, including the type parameter list itself and any types in that list.\n• After substitution, each type argument must satisfy the constraint (instantiated, if necessary) of the corresponding type parameter. Otherwise instantiation fails.\n\nInstantiating a type results in a new non-generic named type; instantiating a function produces a new non-generic function.\n\nWhen using a generic function, type arguments may be provided explicitly, or they may be partially or completely inferred from the context in which the function is used. Provided that they can be inferred, type argument lists may be omitted entirely if the function is:\n• assigned to a variable with a known type\n• passed as an argument to another function, or\n\nIn all other cases, a (possibly partial) type argument list must be present. If a type argument list is absent or partial, all missing type arguments must be inferrable from the context in which the function is used.\n\nA partial type argument list cannot be empty; at least the first argument must be present. The list is a prefix of the full list of type arguments, leaving the remaining arguments to be inferred. Loosely speaking, type arguments may be omitted from \"right to left\".\n\nFor a generic type, all type arguments must always be provided explicitly.\n\nA use of a generic function may omit some or all type arguments if they can be inferred from the context within which the function is used, including the constraints of the function's type parameters. Type inference succeeds if it can infer the missing type arguments and instantiation succeeds with the inferred type arguments. Otherwise, type inference fails and the program is invalid.\n\nType inference uses the type relationships between pairs of types for inference: For instance, a function argument must be assignable to its respective function parameter; this establishes a relationship between the type of the argument and the type of the parameter. If either of these two types contains type parameters, type inference looks for the type arguments to substitute the type parameters with such that the assignability relationship is satisfied. Similarly, type inference uses the fact that a type argument must satisfy the constraint of its respective type parameter.\n\nEach such pair of matched types corresponds to a type equation containing one or multiple type parameters, from one or possibly multiple generic functions. Inferring the missing type arguments means solving the resulting set of type equations for the respective type parameters.\n\nFor example, given\n\nthe variable of type must be assignable to the function parameter type for the program to be valid. To reduce complexity, type inference ignores the directionality of assignments, so the type relationship between and can be expressed via the (symmetric) type equation (or for that matter), where the in indicates that the LHS and RHS types must match per assignability rules (see the section on type unification for details). Similarly, the type parameter must satisfy its constraint . This can be expressed as where stands for \" satisfies constraint \". These observations lead to a set of two equations\n\nwhich now can be solved for the type parameters and . From (1) a compiler can infer that the type argument for is . Similarly, because the underlying type of is and must match of the constraint, a compiler can infer that must be . Thus, for these two equations, type inference infers\n\nGiven a set of type equations, the type parameters to solve for are the type parameters of the functions that need to be instantiated and for which no explicit type arguments is provided. These type parameters are called bound type parameters. For instance, in the example above, the type parameters and are bound to . An argument to a generic function call may be a generic function itself. The type parameters of that function are included in the set of bound type parameters. The types of function arguments may contain type parameters from other functions (such as a generic function enclosing a function call). Those type parameters may also appear in type equations but they are not bound in that context. Type equations are always solved for the bound type parameters only.\n\nType inference supports calls of generic functions and assignments of generic functions to (explicitly function-typed) variables. This includes passing generic functions as arguments to other (possibly also generic) functions, and returning generic functions as results. Type inference operates on a set of equations specific to each of these cases. The equations are as follows (type argument lists are omitted for clarity):\n• For a function call where or a function argument is a generic function: \n\n Each pair of corresponding function arguments and parameters where is not an untyped constant yields an equation . \n\n If is an untyped constant , and is a bound type parameter , the pair is collected separately from the type equations.\n• For an assignment of a generic function to a (non-generic) variable of function type: \n\n .\n• For a return statement where is a generic function returned as a result to a (non-generic) result variable of function type: \n\n .\n\nAdditionally, each type parameter and corresponding type constraint yields the type equation .\n\nType inference gives precedence to type information obtained from typed operands before considering untyped constants. Therefore, inference proceeds in two phases:\n• The type equations are solved for the bound type parameters using type unification. If unification fails, type inference fails.\n• For each bound type parameter for which no type argument has been inferred yet and for which one or more pairs with that same type parameter were collected, determine the constant kind of the constants in all those pairs the same way as for constant expressions. The type argument for is the default type for the determined constant kind. If a constant kind cannot be determined due to conflicting constant kinds, type inference fails.\n\nIf not all type arguments have been found after these two phases, type inference fails.\n\nIf the two phases are successful, type inference determined a type argument for each bound type parameter:\n\nA type argument may be a composite type, containing other bound type parameters as element types (or even be just another bound type parameter). In a process of repeated simplification, the bound type parameters in each type argument are substituted with the respective type arguments for those type parameters until each type argument is free of bound type parameters.\n\nIf type arguments contain cyclic references to themselves through bound type parameters, simplification and thus type inference fails. Otherwise, type inference succeeds.\n\nType inference solves type equations through type unification. Type unification recursively compares the LHS and RHS types of an equation, where either or both types may be or contain bound type parameters, and looks for type arguments for those type parameters such that the LHS and RHS match (become identical or assignment-compatible, depending on context). To that effect, type inference maintains a map of bound type parameters to inferred type arguments; this map is consulted and updated during type unification. Initially, the bound type parameters are known but the map is empty. During type unification, if a new type argument is inferred, the respective mapping from type parameter to argument is added to the map. Conversely, when comparing types, a known type argument (a type argument for which a map entry already exists) takes the place of its corresponding type parameter. As type inference progresses, the map is populated more and more until all equations have been considered, or until unification fails. Type inference succeeds if no unification step fails and the map has an entry for each type parameter.\n\nFor example, given the type equation with the bound type parameter\n\ntype inference starts with an empty map. Unification first compares the top-level structure of the LHS and RHS types. Both are arrays of the same length; they unify if the element types unify. Both element types are structs; they unify if they have the same number of fields with the same names and if the field types unify. The type argument for is not known yet (there is no map entry), so unifying with adds the mapping to the map. Unifying the types of the field requires unifying and and thus and . Since the type argument for is known at this point (there is a map entry for ), its type argument takes the place of . And since is identical to , this unification step succeeds as well. Unification of the LHS and RHS of the equation is now finished. Type inference succeeds because there is only one type equation, no unification step failed, and the map is fully populated.\n\nUnification uses a combination of exact and loose unification depending on whether two types have to be identical, assignment-compatible, or only structurally equal. The respective type unification rules are spelled out in detail in the Appendix.\n\nFor an equation of the form , where and are types involved in an assignment (including parameter passing and return statements), the top-level type structures may unify loosely but element types must unify exactly, matching the rules for assignments.\n\nFor an equation of the form , where is a type parameter and its corresponding constraint, the unification rules are bit more complicated:\n• If has a core type and has a known type argument , and must unify loosely. If does not have a known type argument and contains exactly one type term that is not an underlying (tilde) type, unification adds the mapping to the map.\n• If does not have a core type and has a known type argument , must have all methods of , if any, and corresponding method types must unify exactly.\n\nWhen solving type equations from type constraints, solving one equation may infer additional type arguments, which in turn may enable solving other equations that depend on those type arguments. Type inference repeats type unification as long as new type arguments are inferred.\n\nComparisons are discussed elsewhere. For other binary operators, the operand types must be identical unless the operation involves shifts or untyped constants. For operations involving constants only, see the section on constant expressions.\n\nExcept for shift operations, if one operand is an untyped constant and the other operand is not, the constant is implicitly converted to the type of the other operand.\n\nThe right operand in a shift expression must have integer type [Go 1.13] or be an untyped constant representable by a value of type . If the left operand of a non-constant shift expression is an untyped constant, it is first implicitly converted to the type it would assume if the shift expression were replaced by its left operand alone.\n\nUnary operators have the highest precedence. As the and operators form statements, not expressions, they fall outside the operator hierarchy. As a consequence, statement is the same as .\n\nThere are five precedence levels for binary operators. Multiplication operators bind strongest, followed by addition operators, comparison operators, (logical AND), and finally (logical OR):\n\nBinary operators of the same precedence associate from left to right. For instance, is the same as .\n\nArithmetic operators apply to numeric values and yield a result of the same type as the first operand. The four standard arithmetic operators ( , , , ) apply to integer, floating-point, and complex types; also applies to strings. The bitwise logical and shift operators apply to integers only.\n\nIf the operand type is a type parameter, the operator must apply to each type in that type set. The operands are represented as values of the type argument that the type parameter is instantiated with, and the operation is computed with the precision of that type argument. For example, given the function:\n\nthe product and the addition are computed with or precision, respectively, depending on the type argument for .\n\nFor two integer values and , the integer quotient and remainder satisfy the following relationships:\n\nwith truncated towards zero (\"truncated division\").\n\nThe one exception to this rule is that if the dividend is the most negative value for the int type of , the quotient is equal to (and ) due to two's-complement integer overflow:\n\nIf the divisor is a constant, it must not be zero. If the divisor is zero at run time, a run-time panic occurs. If the dividend is non-negative and the divisor is a constant power of 2, the division may be replaced by a right shift, and computing the remainder may be replaced by a bitwise AND operation:\n\nThe shift operators shift the left operand by the shift count specified by the right operand, which must be non-negative. If the shift count is negative at run time, a run-time panic occurs. The shift operators implement arithmetic shifts if the left operand is a signed integer and logical shifts if it is an unsigned integer. There is no upper limit on the shift count. Shifts behave as if the left operand is shifted times by 1 for a shift count of . As a result, is the same as and is the same as but truncated towards negative infinity.\n\nFor integer operands, the unary operators , , and are defined as follows:\n\nFor unsigned integer values, the operations , , , and are computed modulo 2n, where n is the bit width of the unsigned integer's type. Loosely speaking, these unsigned integer operations discard high bits upon overflow, and programs may rely on \"wrap around\".\n\nFor signed integers, the operations , , , , and may legally overflow and the resulting value exists and is deterministically defined by the signed integer representation, the operation, and its operands. Overflow does not cause a run-time panic. A compiler may not optimize code under the assumption that overflow does not occur. For instance, it may not assume that is always true.\n\nFor floating-point and complex numbers, is the same as , while is the negation of . The result of a floating-point or complex division by zero is not specified beyond the IEEE 754 standard; whether a run-time panic occurs is implementation-specific.\n\nAn implementation may combine multiple floating-point operations into a single fused operation, possibly across statements, and produce a result that differs from the value obtained by executing and rounding the instructions individually. An explicit floating-point type conversion rounds to the precision of the target type, preventing fusion that would discard that rounding.\n\nFor instance, some architectures provide a \"fused multiply and add\" (FMA) instruction that computes without rounding the intermediate result . These examples show when a Go implementation can use that instruction:\n\nStrings can be concatenated using the operator or the assignment operator:\n\nString addition creates a new string by concatenating the operands.\n\nComparison operators compare two operands and yield an untyped boolean value.\n\nIn any comparison, the first operand must be assignable to the type of the second operand, or vice versa.\n\nThe equality operators and apply to operands of comparable types. The ordering operators , , , and apply to operands of ordered types. These terms and the result of the comparisons are defined as follows:\n• Boolean types are comparable. Two boolean values are equal if they are either both or both .\n• Integer types are comparable and ordered. Two integer values are compared in the usual way.\n• Floating-point types are comparable and ordered. Two floating-point values are compared as defined by the IEEE 754 standard.\n• Complex types are comparable. Two complex values and are equal if both and .\n• String types are comparable and ordered. Two string values are compared lexically byte-wise.\n• Pointer types are comparable. Two pointer values are equal if they point to the same variable or if both have value . Pointers to distinct zero-size variables may or may not be equal.\n• Channel types are comparable. Two channel values are equal if they were created by the same call to or if both have value .\n• Interface types that are not type parameters are comparable. Two interface values are equal if they have identical dynamic types and equal dynamic values or if both have value .\n• A value of non-interface type and a value of interface type can be compared if type is comparable and implements . They are equal if 's dynamic type is identical to and 's dynamic value is equal to .\n• Struct types are comparable if all their field types are comparable. Two struct values are equal if their corresponding non-blank field values are equal. The fields are compared in source order, and comparison stops as soon as two field values differ (or all fields have been compared).\n• Array types are comparable if their array element types are comparable. Two array values are equal if their corresponding element values are equal. The elements are compared in ascending index order, and comparison stops as soon as two element values differ (or all elements have been compared).\n• Type parameters are comparable if they are strictly comparable (see below).\n\nA comparison of two interface values with identical dynamic types causes a run-time panic if that type is not comparable. This behavior applies not only to direct interface value comparisons but also when comparing arrays of interface values or structs with interface-valued fields.\n\nSlice, map, and function types are not comparable. However, as a special case, a slice, map, or function value may be compared to the predeclared identifier . Comparison of pointer, channel, and interface values to is also allowed and follows from the general rules above.\n\nA type is strictly comparable if it is comparable and not an interface type nor composed of interface types. Specifically:\n• Struct types are strictly comparable if all their field types are strictly comparable.\n• Array types are strictly comparable if their array element types are strictly comparable.\n• Type parameters are strictly comparable if all types in their type set are strictly comparable.\n\nLogical operators apply to boolean values and yield a result of the same type as the operands. The left operand is evaluated, and then the right if the condition requires it.\n\nFor an operand of type , the address operation generates a pointer of type to . The operand must be addressable, that is, either a variable, pointer indirection, or slice indexing operation; or a field selector of an addressable struct operand; or an array indexing operation of an addressable array. As an exception to the addressability requirement, may also be a (possibly parenthesized) composite literal. If the evaluation of would cause a run-time panic, then the evaluation of does too.\n\nFor an operand of pointer type , the pointer indirection denotes the variable of type pointed to by . If is , an attempt to evaluate will cause a run-time panic.\n\nFor an operand whose core type is a channel, the value of the receive operation is the value received from the channel . The channel direction must permit receive operations, and the type of the receive operation is the element type of the channel. The expression blocks until a value is available. Receiving from a channel blocks forever. A receive operation on a closed channel can always proceed immediately, yielding the element type's zero value after any previously sent values have been received.\n\nA receive expression used in an assignment statement or initialization of the special form\n\nyields an additional untyped boolean result reporting whether the communication succeeded. The value of is if the value received was delivered by a successful send operation to the channel, or if it is a zero value generated because the channel is closed and empty.\n\nA conversion changes the type of an expression to the type specified by the conversion. A conversion may appear literally in the source, or it may be implied by the context in which an expression appears.\n\nAn explicit conversion is an expression of the form where is a type and is an expression that can be converted to type .\n\nIf the type starts with the operator or , or if the type starts with the keyword and has no result list, it must be parenthesized when necessary to avoid ambiguity:\n\nA constant value can be converted to type if is representable by a value of . As a special case, an integer constant can be explicitly converted to a string type using the same rule as for non-constant .\n\nConverting a constant to a type that is not a type parameter yields a typed constant.\n\nConverting a constant to a type parameter yields a non-constant value of that type, with the value represented as a value of the type argument that the type parameter is instantiated with. For example, given the function:\n\nthe conversion results in a non-constant value of type and the value is represented as a or a depending on the type argument for . Accordingly, if is instantiated with a type, the numeric value of the expression will be computed with the same precision as the corresponding non-constant addition.\n\nA non-constant value can be converted to type in any of these cases:\n• ignoring struct tags (see below), 's type and are not type parameters but have identical underlying types.\n• ignoring struct tags (see below), 's type and are pointer types that are not named types, and their pointer base types are not type parameters but have identical underlying types.\n• 's type and are both integer or floating point types.\n• 's type and are both complex types.\n• is an integer or a slice of bytes or runes and is a string type.\n• is a string and is a slice of bytes or runes.\n• is a slice, is an array [Go 1.20] or a pointer to an array [Go 1.17], and the slice and array types have identical element types.\n\nAdditionally, if or 's type are type parameters, can also be converted to type if one of the following conditions applies:\n• Both and are type parameters and a value of each type in 's type set can be converted to each type in 's type set.\n• Only is a type parameter and a value of each type in 's type set can be converted to .\n• Only is a type parameter and can be converted to each type in 's type set.\n\nStruct tags are ignored when comparing struct types for identity for the purpose of conversion:\n\nSpecific rules apply to (non-constant) conversions between numeric types or to and from a string type. These conversions may change the representation of and incur a run-time cost. All other conversions only change the type but not the representation of .\n\nThere is no linguistic mechanism to convert between pointers and integers. The package implements this functionality under restricted circumstances.\n\nFor the conversion of non-constant numeric values, the following rules apply:\n• When converting between integer types, if the value is a signed integer, it is sign extended to implicit infinite precision; otherwise it is zero extended. It is then truncated to fit in the result type's size. For example, if , then . The conversion always yields a valid value; there is no indication of overflow.\n• When converting a floating-point number to an integer, the fraction is discarded (truncation towards zero).\n• When converting an integer or floating-point number to a floating-point type, or a complex number to another complex type, the result value is rounded to the precision specified by the destination type. For instance, the value of a variable of type may be stored using additional precision beyond that of an IEEE 754 32-bit number, but float32(x) represents the result of rounding 's value to 32-bit precision. Similarly, may use more than 32 bits of precision, but does not.\n\nIn all non-constant conversions involving floating-point or complex values, if the result type cannot represent the value the conversion succeeds but the result value is implementation-dependent.\n\nConversions to and from a string type\n• Converting a slice of bytes to a string type yields a string whose successive bytes are the elements of the slice.\n• Converting a slice of runes to a string type yields a string that is the concatenation of the individual rune values converted to strings.\n• Converting a value of a string type to a slice of bytes type yields a non-nil slice whose successive elements are the bytes of the string. The capacity of the resulting slice is implementation-specific and may be larger than the slice length.\n• Converting a value of a string type to a slice of runes type yields a slice containing the individual Unicode code points of the string. The capacity of the resulting slice is implementation-specific and may be larger than the slice length.\n• Finally, for historical reasons, an integer value may be converted to a string type. This form of conversion yields a string containing the (possibly multi-byte) UTF-8 representation of the Unicode code point with the given integer value. Values outside the range of valid Unicode code points are converted to . Note: This form of conversion may eventually be removed from the language. The tool flags certain integer-to-string conversions as potential errors. Library functions such as or should be used instead.\n\nConversions from slice to array or array pointer\n\nConverting a slice to an array yields an array containing the elements of the underlying array of the slice. Similarly, converting a slice to an array pointer yields a pointer to the underlying array of the slice. In both cases, if the length of the slice is less than the length of the array, a run-time panic occurs.\n\nConstant expressions may contain only constant operands and are evaluated at compile time.\n\nUntyped boolean, numeric, and string constants may be used as operands wherever it is legal to use an operand of boolean, numeric, or string type, respectively.\n\nA constant comparison always yields an untyped boolean constant. If the left operand of a constant shift expression is an untyped constant, the result is an integer constant; otherwise it is a constant of the same type as the left operand, which must be of integer type.\n\nAny other operation on untyped constants results in an untyped constant of the same kind; that is, a boolean, integer, floating-point, complex, or string constant. If the untyped operands of a binary operation (other than a shift) are of different kinds, the result is of the operand's kind that appears later in this list: integer, rune, floating-point, complex. For example, an untyped integer constant divided by an untyped complex constant yields an untyped complex constant.\n\nApplying the built-in function to untyped integer, rune, or floating-point constants yields an untyped complex constant.\n\nConstant expressions are always evaluated exactly; intermediate values and the constants themselves may require precision significantly larger than supported by any predeclared type in the language. The following are legal declarations:\n\nThe divisor of a constant division or remainder operation must not be zero:\n\nThe values of typed constants must always be accurately representable by values of the constant type. The following constant expressions are illegal:\n\nThe mask used by the unary bitwise complement operator matches the rule for non-constants: the mask is all 1s for unsigned constants and -1 for signed and untyped constants.\n\nImplementation restriction: A compiler may use rounding while computing untyped floating-point or complex constant expressions; see the implementation restriction in the section on constants. This rounding may cause a floating-point constant expression to be invalid in an integer context, even if it would be integral when calculated using infinite precision, and vice versa.\n\nAt package level, initialization dependencies determine the evaluation order of individual initialization expressions in variable declarations. Otherwise, when evaluating the operands of an expression, assignment, or return statement, all function calls, method calls, receive operations, and binary logical operations are evaluated in lexical left-to-right order.\n\nFor example, in the (function-local) assignment\n\nthe function calls and communication happen in the order , (if evaluates to false), , , , , and . However, the order of those events compared to the evaluation and indexing of and the evaluation of and is not specified, except as required lexically. For instance, cannot be called before its arguments are evaluated.\n\nAt package level, initialization dependencies override the left-to-right rule for individual initialization expressions, but not for operands within each expression:\n\nThe function calls happen in the order , , , , , and .\n\nFloating-point operations within a single expression are evaluated according to the associativity of the operators. Explicit parentheses affect the evaluation by overriding the default associativity. In the expression the addition is performed before adding .\n\nA terminating statement interrupts the regular flow of control in a block. The following statements are terminating:\n• A block in which the statement list ends in a terminating statement.\n• An \"if\" statement in which:\n• the \"else\" branch is present, and\n• A \"for\" statement in which:\n• there are no \"break\" statements referring to the \"for\" statement, and\n• the loop condition is absent, and\n• the \"for\" statement does not use a range clause.\n• A \"switch\" statement in which:\n• there are no \"break\" statements referring to the \"switch\" statement,\n• there is a default case, and\n• the statement lists in each case, including the default, end in a terminating statement, or a possibly labeled \"fallthrough\" statement.\n• A \"select\" statement in which:\n• there are no \"break\" statements referring to the \"select\" statement, and\n• the statement lists in each case, including the default if present, end in a terminating statement.\n\nAll other statements are not terminating.\n\nA statement list ends in a terminating statement if the list is not empty and its final non-empty statement is terminating.\n\nThe empty statement does nothing.\n\nA labeled statement may be the target of a , or statement.\n\nWith the exception of specific built-in functions, function and method calls and receive operations can appear in statement context. Such statements may be parenthesized.\n\nThe following built-in functions are not permitted in statement context:\n\nA send statement sends a value on a channel. The channel expression's core type must be a channel, the channel direction must permit send operations, and the type of the value to be sent must be assignable to the channel's element type.\n\nBoth the channel and the value expression are evaluated before communication begins. Communication blocks until the send can proceed. A send on an unbuffered channel can proceed if a receiver is ready. A send on a buffered channel can proceed if there is room in the buffer. A send on a closed channel proceeds by causing a run-time panic. A send on a channel blocks forever.\n\nThe \"++\" and \"--\" statements increment or decrement their operands by the untyped constant . As with an assignment, the operand must be addressable or a map index expression.\n\nThe following assignment statements are semantically equivalent:\n\nAn assignment replaces the current value stored in a variable with a new value specified by an expression. An assignment statement may assign a single value to a single variable, or multiple values to a matching number of variables.\n\nEach left-hand side operand must be addressable, a map index expression, or (for assignments only) the blank identifier. Operands may be parenthesized.\n\nAn assignment operation op where op is a binary arithmetic operator is equivalent to op but evaluates only once. The op construct is a single token. In assignment operations, both the left- and right-hand expression lists must contain exactly one single-valued expression, and the left-hand expression must not be the blank identifier.\n\nA tuple assignment assigns the individual elements of a multi-valued operation to a list of variables. There are two forms. In the first, the right hand operand is a single multi-valued expression such as a function call, a channel or map operation, or a type assertion. The number of operands on the left hand side must match the number of values. For instance, if is a function returning two values,\n\nassigns the first value to and the second to . In the second form, the number of operands on the left must equal the number of expressions on the right, each of which must be single-valued, and the nth expression on the right is assigned to the nth operand on the left:\n\nThe blank identifier provides a way to ignore right-hand side values in an assignment:\n\nThe assignment proceeds in two phases. First, the operands of index expressions and pointer indirections (including implicit pointer indirections in selectors) on the left and the expressions on the right are all evaluated in the usual order. Second, the assignments are carried out in left-to-right order.\n\nIn assignments, each value must be assignable to the type of the operand to which it is assigned, with the following special cases:\n• Any typed value may be assigned to the blank identifier.\n• If an untyped constant is assigned to a variable of interface type or the blank identifier, the constant is first implicitly converted to its default type.\n• If an untyped boolean value is assigned to a variable of interface type or the blank identifier, it is first implicitly converted to type .\n\nWhen a value is assigned to a variable, only the data that is stored in the variable is replaced. If the value contains a reference, the assignment copies the reference but does not make a copy of the referenced data (such as the underlying array of a slice).\n\n\"If\" statements specify the conditional execution of two branches according to the value of a boolean expression. If the expression evaluates to true, the \"if\" branch is executed, otherwise, if present, the \"else\" branch is executed.\n\nThe expression may be preceded by a simple statement, which executes before the expression is evaluated.\n\n\"Switch\" statements provide multi-way execution. An expression or type is compared to the \"cases\" inside the \"switch\" to determine which branch to execute.\n\nThere are two forms: expression switches and type switches. In an expression switch, the cases contain expressions that are compared against the value of the switch expression. In a type switch, the cases contain types that are compared against the type of a specially annotated switch expression. The switch expression is evaluated exactly once in a switch statement.\n\nIn an expression switch, the switch expression is evaluated and the case expressions, which need not be constants, are evaluated left-to-right and top-to-bottom; the first one that equals the switch expression triggers execution of the statements of the associated case; the other cases are skipped. If no case matches and there is a \"default\" case, its statements are executed. There can be at most one default case and it may appear anywhere in the \"switch\" statement. A missing switch expression is equivalent to the boolean value .\n\nIf the switch expression evaluates to an untyped constant, it is first implicitly converted to its default type. The predeclared untyped value cannot be used as a switch expression. The switch expression type must be comparable.\n\nIf a case expression is untyped, it is first implicitly converted to the type of the switch expression. For each (possibly converted) case expression and the value of the switch expression, must be a valid comparison.\n\nIn other words, the switch expression is treated as if it were used to declare and initialize a temporary variable without explicit type; it is that value of against which each case expression is tested for equality.\n\nIn a case or default clause, the last non-empty statement may be a (possibly labeled) \"fallthrough\" statement to indicate that control should flow from the end of this clause to the first statement of the next clause. Otherwise control flows to the end of the \"switch\" statement. A \"fallthrough\" statement may appear as the last statement of all but the last clause of an expression switch.\n\nThe switch expression may be preceded by a simple statement, which executes before the expression is evaluated.\n\nImplementation restriction: A compiler may disallow multiple case expressions evaluating to the same constant. For instance, the current compilers disallow duplicate integer, floating point, or string constants in case expressions.\n\nA type switch compares types rather than values. It is otherwise similar to an expression switch. It is marked by a special switch expression that has the form of a type assertion using the keyword rather than an actual type:\n\nCases then match actual types against the dynamic type of the expression . As with type assertions, must be of interface type, but not a type parameter, and each non-interface type listed in a case must implement the type of . The types listed in the cases of a type switch must all be different.\n\nThe TypeSwitchGuard may include a short variable declaration. When that form is used, the variable is declared at the end of the TypeSwitchCase in the implicit block of each clause. In clauses with a case listing exactly one type, the variable has that type; otherwise, the variable has the type of the expression in the TypeSwitchGuard.\n\nInstead of a type, a case may use the predeclared identifier ; that case is selected when the expression in the TypeSwitchGuard is a interface value. There may be at most one case.\n\nGiven an expression of type , the following type switch:\n\nA type parameter or a generic type may be used as a type in a case. If upon instantiation that type turns out to duplicate another entry in the switch, the first matching case is chosen.\n\nThe type switch guard may be preceded by a simple statement, which executes before the guard is evaluated.\n\nThe \"fallthrough\" statement is not permitted in a type switch.\n\nA \"for\" statement specifies repeated execution of a block. There are three forms: The iteration may be controlled by a single condition, a \"for\" clause, or a \"range\" clause.\n\nIn its simplest form, a \"for\" statement specifies the repeated execution of a block as long as a boolean condition evaluates to true. The condition is evaluated before each iteration. If the condition is absent, it is equivalent to the boolean value .\n\nA \"for\" statement with a ForClause is also controlled by its condition, but additionally it may specify an init and a post statement, such as an assignment, an increment or decrement statement. The init statement may be a short variable declaration, but the post statement must not.\n\nIf non-empty, the init statement is executed once before evaluating the condition for the first iteration; the post statement is executed after each execution of the block (and only if the block was executed). Any element of the ForClause may be empty but the semicolons are required unless there is only a condition. If the condition is absent, it is equivalent to the boolean value .\n\nEach iteration has its own separate declared variable (or variables) [Go 1.22]. The variable used by the first iteration is declared by the init statement. The variable used by each subsequent iteration is declared implicitly before executing the post statement and initialized to the value of the previous iteration's variable at that moment.\n\nPrior to [Go 1.22], iterations share one set of variables instead of having their own separate variables. In that case, the example above prints\n\nA \"for\" statement with a \"range\" clause iterates through all entries of an array, slice, string or map, values received on a channel, integer values from zero to an upper limit [Go 1.22], or values passed to an iterator function's yield function [Go 1.23]. For each entry it assigns iteration values to corresponding iteration variables if present and then executes the block.\n\nThe expression on the right in the \"range\" clause is called the range expression, its core type must be an array, pointer to an array, slice, string, map, channel permitting receive operations, an integer, or a function with specific signature (see below). As with an assignment, if present the operands on the left must be addressable or map index expressions; they denote the iteration variables. If the range expression is a function, the maximum number of iteration variables depends on the function signature. If the range expression is a channel or integer, at most one iteration variable is permitted; otherwise there may be up to two. If the last iteration variable is the blank identifier, the range clause is equivalent to the same clause without that identifier.\n\nThe range expression is evaluated before beginning the loop, with one exception: if at most one iteration variable is present and or is constant, the range expression is not evaluated.\n\nFunction calls on the left are evaluated once per iteration. For each iteration, iteration values are produced as follows if the respective iteration variables are present:\n• For an array, pointer to array, or slice value , the index iteration values are produced in increasing order, starting at element index 0. If at most one iteration variable is present, the range loop produces iteration values from 0 up to and does not index into the array or slice itself. For a slice, the number of iterations is 0.\n• For a string value, the \"range\" clause iterates over the Unicode code points in the string starting at byte index 0. On successive iterations, the index value will be the index of the first byte of successive UTF-8-encoded code points in the string, and the second value, of type , will be the value of the corresponding code point. If the iteration encounters an invalid UTF-8 sequence, the second value will be , the Unicode replacement character, and the next iteration will advance a single byte in the string.\n• The iteration order over maps is not specified and is not guaranteed to be the same from one iteration to the next. If a map entry that has not yet been reached is removed during iteration, the corresponding iteration value will not be produced. If a map entry is created during iteration, that entry may be produced during the iteration or may be skipped. The choice may vary for each entry created and from one iteration to the next. If the map is , the number of iterations is 0.\n• For channels, the iteration values produced are the successive values sent on the channel until the channel is closed. If the channel is , the range expression blocks forever.\n• For an integer value , where is of integer type or an untyped integer constant, the iteration values 0 through are produced in increasing order. If is of integer type, the iteration values have that same type. Otherwise, the type of is determined as if it were assigned to the iteration variable. Specifically: if the iteration variable is preexisting, the type of the iteration values is the type of the iteration variable, which must be of integer type. Otherwise, if the iteration variable is declared by the \"range\" clause or is absent, the type of the iteration values is the default type for . If <= 0, the loop does not run any iterations.\n• For a function , the iteration proceeds by calling with a new, synthesized function as its argument. If is called before returns, the arguments to become the iteration values for executing the loop body once. After each successive loop iteration, returns true and may be called again to continue the loop. As long as the loop body does not terminate, the \"range\" clause will continue to generate iteration values this way for each call until returns. If the loop body terminates (such as by a statement), returns false and must not be called again.\n\nThe iteration variables may be declared by the \"range\" clause using a form of short variable declaration ( ). In this case their scope is the block of the \"for\" statement and each iteration has its own new variables [Go 1.22] (see also \"for\" statements with a ForClause). The variables have the types of their respective iteration values.\n\nIf the iteration variables are not explicitly declared by the \"range\" clause, they must be preexisting. In this case, the iteration values are assigned to the respective variables as in an assignment statement.\n\nA \"go\" statement starts the execution of a function call as an independent concurrent thread of control, or goroutine, within the same address space.\n\nThe expression must be a function or method call; it cannot be parenthesized. Calls of built-in functions are restricted as for expression statements.\n\nThe function value and parameters are evaluated as usual in the calling goroutine, but unlike with a regular call, program execution does not wait for the invoked function to complete. Instead, the function begins executing independently in a new goroutine. When the function terminates, its goroutine also terminates. If the function has any return values, they are discarded when the function completes.\n\nA \"select\" statement chooses which of a set of possible send or receive operations will proceed. It looks similar to a \"switch\" statement but with the cases all referring to communication operations.\n\nA case with a RecvStmt may assign the result of a RecvExpr to one or two variables, which may be declared using a short variable declaration. The RecvExpr must be a (possibly parenthesized) receive operation. There can be at most one default case and it may appear anywhere in the list of cases.\n\nExecution of a \"select\" statement proceeds in several steps:\n• For all the cases in the statement, the channel operands of receive operations and the channel and right-hand-side expressions of send statements are evaluated exactly once, in source order, upon entering the \"select\" statement. The result is a set of channels to receive from or send to, and the corresponding values to send. Any side effects in that evaluation will occur irrespective of which (if any) communication operation is selected to proceed. Expressions on the left-hand side of a RecvStmt with a short variable declaration or assignment are not yet evaluated.\n• If one or more of the communications can proceed, a single one that can proceed is chosen via a uniform pseudo-random selection. Otherwise, if there is a default case, that case is chosen. If there is no default case, the \"select\" statement blocks until at least one of the communications can proceed.\n• Unless the selected case is the default case, the respective communication operation is executed.\n• If the selected case is a RecvStmt with a short variable declaration or an assignment, the left-hand side expressions are evaluated and the received value (or values) are assigned.\n• The statement list of the selected case is executed.\n\nSince communication on channels can never proceed, a select with only channels and no default case blocks forever.\n\nA \"return\" statement in a function terminates the execution of , and optionally provides one or more result values. Any functions deferred by are executed before returns to its caller.\n\nIn a function without a result type, a \"return\" statement must not specify any result values.\n\nThere are three ways to return values from a function with a result type:\n• The return value or values may be explicitly listed in the \"return\" statement. Each expression must be single-valued and assignable to the corresponding element of the function's result type.\n• The expression list in the \"return\" statement may be a single call to a multi-valued function. The effect is as if each value returned from that function were assigned to a temporary variable with the type of the respective value, followed by a \"return\" statement listing these variables, at which point the rules of the previous case apply.\n• The expression list may be empty if the function's result type specifies names for its result parameters. The result parameters act as ordinary local variables and the function may assign values to them as necessary. The \"return\" statement returns the values of these variables.\n\nRegardless of how they are declared, all the result values are initialized to the zero values for their type upon entry to the function. A \"return\" statement that specifies results sets the result parameters before any deferred functions are executed.\n\nImplementation restriction: A compiler may disallow an empty expression list in a \"return\" statement if a different entity (constant, type, or variable) with the same name as a result parameter is in scope at the place of the return.\n\nA \"break\" statement terminates execution of the innermost \"for\", \"switch\", or \"select\" statement within the same function.\n\nIf there is a label, it must be that of an enclosing \"for\", \"switch\", or \"select\" statement, and that is the one whose execution terminates.\n\nA \"continue\" statement begins the next iteration of the innermost enclosing \"for\" loop by advancing control to the end of the loop block. The \"for\" loop must be within the same function.\n\nIf there is a label, it must be that of an enclosing \"for\" statement, and that is the one whose execution advances.\n\nA \"goto\" statement transfers control to the statement with the corresponding label within the same function.\n\nExecuting the \"goto\" statement must not cause any variables to come into scope that were not already in scope at the point of the goto. For instance, this example:\n\nis erroneous because the jump to label skips the creation of .\n\nA \"goto\" statement outside a block cannot jump to a label inside that block. For instance, this example:\n\nis erroneous because the label is inside the \"for\" statement's block but the is not.\n\nA \"fallthrough\" statement transfers control to the first statement of the next case clause in an expression \"switch\" statement. It may be used only as the final non-empty statement in such a clause.\n\nA \"defer\" statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking.\n\nThe expression must be a function or method call; it cannot be parenthesized. Calls of built-in functions are restricted as for expression statements.\n\nEach time a \"defer\" statement executes, the function value and parameters to the call are evaluated as usual and saved anew but the actual function is not invoked. Instead, deferred functions are invoked immediately before the surrounding function returns, in the reverse order they were deferred. That is, if the surrounding function returns through an explicit return statement, deferred functions are executed after any result parameters are set by that return statement but before the function returns to its caller. If a deferred function value evaluates to , execution panics when the function is invoked, not when the \"defer\" statement is executed.\n\nFor instance, if the deferred function is a function literal and the surrounding function has named result parameters that are in scope within the literal, the deferred function may access and modify the result parameters before they are returned. If the deferred function has any return values, they are discarded when the function completes. (See also the section on handling panics.)\n\nBuilt-in functions are predeclared. They are called like any other function but some of them accept a type instead of an expression as the first argument.\n\nThe built-in functions do not have standard Go types, so they can only appear in call expressions; they cannot be used as function values.\n\nThe built-in functions and assist in common slice operations. For both functions, the result is independent of whether the memory referenced by the arguments overlaps.\n\nThe variadic function appends zero or more values to a slice and returns the resulting slice of the same type as . The core type of must be a slice of type . The values are passed to a parameter of type and the respective parameter passing rules apply. As a special case, if the core type of is , also accepts a second argument with core type followed by . This form appends the bytes of the byte slice or string.\n\nIf the capacity of is not large enough to fit the additional values, allocates a new, sufficiently large underlying array that fits both the existing slice elements and the additional values. Otherwise, re-uses the underlying array.\n\nThe function copies slice elements from a source to a destination and returns the number of elements copied. The core types of both arguments must be slices with identical element type. The number of elements copied is the minimum of and . As a special case, if the destination's core type is , also accepts a source argument with core type . This form copies the bytes from the byte slice or string into the byte slice.\n\nThe built-in function takes an argument of map, slice, or type parameter type, and deletes or zeroes out all elements [Go 1.21].\n\nIf the type of the argument to is a type parameter, all types in its type set must be maps or slices, and performs the operation corresponding to the actual type argument.\n\nIf the map or slice is , is a no-op.\n\nFor an argument with a core type that is a channel, the built-in function records that no more values will be sent on the channel. It is an error if is a receive-only channel. Sending to or closing a closed channel causes a run-time panic. Closing the nil channel also causes a run-time panic. After calling , and after any previously sent values have been received, receive operations will return the zero value for the channel's type without blocking. The multi-valued receive operation returns a received value along with an indication of whether the channel is closed.\n\nThree functions assemble and disassemble complex numbers. The built-in function constructs a complex value from a floating-point real and imaginary part, while and extract the real and imaginary parts of a complex value.\n\nThe type of the arguments and return value correspond. For , the two arguments must be of the same floating-point type and the return type is the complex type with the corresponding floating-point constituents: for arguments, and for arguments. If one of the arguments evaluates to an untyped constant, it is first implicitly converted to the type of the other argument. If both arguments evaluate to untyped constants, they must be non-complex numbers or their imaginary parts must be zero, and the return value of the function is an untyped complex constant.\n\nFor and , the argument must be of complex type, and the return type is the corresponding floating-point type: for a argument, and for a argument. If the argument evaluates to an untyped constant, it must be a number, and the return value of the function is an untyped floating-point constant.\n\nThe and functions together form the inverse of , so for a value of a complex type , .\n\nIf the operands of these functions are all constants, the return value is a constant.\n\nArguments of type parameter type are not permitted.\n\nThe built-in function removes the element with key from a map . The value must be assignable to the key type of .\n\nIf the type of is a type parameter, all types in that type set must be maps, and they must all have identical key types.\n\nIf the map is or the element does not exist, is a no-op.\n\nThe built-in functions and take arguments of various types and return a result of type . The implementation guarantees that the result always fits into an .\n\nIf the argument type is a type parameter , the call (or respectively) must be valid for each type in 's type set. The result is the length (or capacity, respectively) of the argument whose type corresponds to the type argument with which was instantiated.\n\nThe capacity of a slice is the number of elements for which there is space allocated in the underlying array. At any time the following relationship holds:\n\nThe length of a slice, map or channel is 0. The capacity of a slice or channel is 0.\n\nThe expression is constant if is a string constant. The expressions and are constants if the type of is an array or pointer to an array and the expression does not contain channel receives or (non-constant) function calls; in this case is not evaluated. Otherwise, invocations of and are not constant and is evaluated.\n\nThe built-in function takes a type , optionally followed by a type-specific list of expressions. The core type of must be a slice, map or channel. It returns a value of type (not ). The memory is initialized as described in the section on initial values.\n\nEach of the size arguments and must be of integer type, have a type set containing only integer types, or be an untyped constant. A constant size argument must be non-negative and representable by a value of type ; if it is an untyped constant it is given type . If both and are provided and are constant, then must be no larger than . For slices and channels, if is negative or larger than at run time, a run-time panic occurs.\n\nCalling with a map type and size hint will create a map with initial space to hold map elements. The precise behavior is implementation-dependent.\n\nThe built-in functions and compute the smallest—or largest, respectively—value of a fixed number of arguments of ordered types. There must be at least one argument [Go 1.21].\n\nThe same type rules as for operators apply: for ordered arguments and , is valid if is valid, and the type of is the type of (and similarly for ). If all arguments are constant, the result is constant.\n\nFor numeric arguments, assuming all NaNs are equal, and are commutative and associative:\n\nFor floating-point arguments negative zero, NaN, and infinity the following rules apply:\n\nFor string arguments the result for is the first argument with the smallest (or for , largest) value, compared lexically byte-wise:\n\nThe built-in function takes a type , allocates storage for a variable of that type at run time, and returns a value of type pointing to it. The variable is initialized as described in the section on initial values.\n\nallocates storage for a variable of type , initializes it ( , ), and returns a value of type containing the address of the location.\n\nTwo built-in functions, and , assist in reporting and handling run-time panics and program-defined error conditions.\n\nWhile executing a function , an explicit call to or a run-time panic terminates the execution of . Any functions deferred by are then executed as usual. Next, any deferred functions run by 's caller are run, and so on up to any deferred by the top-level function in the executing goroutine. At that point, the program is terminated and the error condition is reported, including the value of the argument to . This termination sequence is called panicking.\n\nThe function allows a program to manage behavior of a panicking goroutine. Suppose a function defers a function that calls and a panic occurs in a function on the same goroutine in which is executing. When the running of deferred functions reaches , the return value of 's call to will be the value passed to the call of . If returns normally, without starting a new , the panicking sequence stops. In that case, the state of functions called between and the call to is discarded, and normal execution resumes. Any functions deferred by before are then run and 's execution terminates by returning to its caller.\n\nThe return value of is when the goroutine is not panicking or was not called directly by a deferred function. Conversely, if a goroutine is panicking and was called directly by a deferred function, the return value of is guaranteed not to be . To ensure this, calling with a interface value (or an untyped ) causes a run-time panic.\n\nThe function in the example below invokes the function argument and protects callers from run-time panics raised by .\n\nCurrent implementations provide several built-in functions useful during bootstrapping. These functions are documented for completeness but are not guaranteed to stay in the language. They do not return a result.\n\nImplementation restriction: and need not accept arbitrary argument types, but printing of boolean, numeric, and string types must be supported.\n\nGo programs are constructed by linking together packages. A package in turn is constructed from one or more source files that together declare constants, types, variables and functions belonging to the package and which are accessible in all files of the same package. Those elements may be exported and used in another package.\n\nEach source file consists of a package clause defining the package to which it belongs, followed by a possibly empty set of import declarations that declare packages whose contents it wishes to use, followed by a possibly empty set of declarations of functions, types, variables, and constants.\n\nA package clause begins each source file and defines the package to which the file belongs.\n\nThe PackageName must not be the blank identifier.\n\nA set of files sharing the same PackageName form the implementation of a package. An implementation may require that all source files for a package inhabit the same directory.\n\nAn import declaration states that the source file containing the declaration depends on functionality of the imported package (§Program initialization and execution) and enables access to exported identifiers of that package. The import names an identifier (PackageName) to be used for access and an ImportPath that specifies the package to be imported.\n\nThe PackageName is used in qualified identifiers to access exported identifiers of the package within the importing source file. It is declared in the file block. If the PackageName is omitted, it defaults to the identifier specified in the package clause of the imported package. If an explicit period ( ) appears instead of a name, all the package's exported identifiers declared in that package's package block will be declared in the importing source file's file block and must be accessed without a qualifier.\n\nThe interpretation of the ImportPath is implementation-dependent but it is typically a substring of the full file name of the compiled package and may be relative to a repository of installed packages.\n\nImplementation restriction: A compiler may restrict ImportPaths to non-empty strings using only characters belonging to Unicode's L, M, N, P, and S general categories (the Graphic characters without spaces) and may also exclude the characters and the Unicode replacement character U+FFFD.\n\nConsider a compiled a package containing the package clause , which exports function , and installed the compiled package in the file identified by . This table illustrates how is accessed in files that import the package after the various types of import declaration.\n\nAn import declaration declares a dependency relation between the importing and imported package. It is illegal for a package to import itself, directly or indirectly, or to directly import a package without referring to any of its exported identifiers. To import a package solely for its side-effects (initialization), use the blank identifier as explicit package name:\n\nHere is a complete Go package that implements a concurrent prime sieve.\n\nThe zero value\n\nWhen storage is allocated for a variable, either through a declaration or a call of , or when a new value is created, either through a composite literal or a call of , and no explicit initialization is provided, the variable or value is given a default value. Each element of such a variable or value is set to the zero value for its type: for booleans, for numeric types, for strings, and for pointers, functions, interfaces, slices, channels, and maps. This initialization is done recursively, so for instance each element of an array of structs will have its fields zeroed if no value is specified.\n\nThese two simple declarations are equivalent:\n\nThe same would also be true after\n\nWithin a package, package-level variable initialization proceeds stepwise, with each step selecting the variable earliest in declaration order which has no dependencies on uninitialized variables.\n\nMore precisely, a package-level variable is considered ready for initialization if it is not yet initialized and either has no initialization expression or its initialization expression has no dependencies on uninitialized variables. Initialization proceeds by repeatedly initializing the next package-level variable that is earliest in declaration order and ready for initialization, until there are no variables ready for initialization.\n\nIf any variables are still uninitialized when this process ends, those variables are part of one or more initialization cycles, and the program is not valid.\n\nMultiple variables on the left-hand side of a variable declaration initialized by single (multi-valued) expression on the right-hand side are initialized together: If any of the variables on the left-hand side is initialized, all those variables are initialized in the same step.\n\nFor the purpose of package initialization, blank variables are treated like any other variables in declarations.\n\nThe declaration order of variables declared in multiple files is determined by the order in which the files are presented to the compiler: Variables declared in the first file are declared before any of the variables declared in the second file, and so on. To ensure reproducible initialization behavior, build systems are encouraged to present multiple files belonging to the same package in lexical file name order to a compiler.\n\nDependency analysis does not rely on the actual values of the variables, only on lexical references to them in the source, analyzed transitively. For instance, if a variable 's initialization expression refers to a function whose body refers to variable then depends on . Specifically:\n• A reference to a variable or function is an identifier denoting that variable or function.\n• A reference to a method is a method value or method expression of the form , where the (static) type of is not an interface type, and the method is in the method set of . It is immaterial whether the resulting function value is invoked.\n• A variable, function, or method depends on a variable if 's initialization expression or body (for functions and methods) contains a reference to or to a function or method that depends on .\n\nFor example, given the declarations\n\nthe initialization order is , , , . Note that the order of subexpressions in initialization expressions is irrelevant: and result in the same initialization order in this example.\n\nDependency analysis is performed per package; only references referring to variables, functions, and (non-interface) methods declared in the current package are considered. If other, hidden, data dependencies exists between variables, the initialization order between those variables is unspecified.\n\nFor instance, given the declarations\n\nthe variable will be initialized after but whether is initialized before , between and , or after , and thus also the moment at which is called (before or after is initialized) is not specified.\n\nVariables may also be initialized using functions named declared in the package block, with no arguments and no result parameters.\n\nMultiple such functions may be defined per package, even within a single source file. In the package block, the identifier can be used only to declare functions, yet the identifier itself is not declared. Thus functions cannot be referred to from anywhere in a program.\n\nThe entire package is initialized by assigning initial values to all its package-level variables followed by calling all functions in the order they appear in the source, possibly in multiple files, as presented to the compiler.\n\nThe packages of a complete program are initialized stepwise, one package at a time. If a package has imports, the imported packages are initialized before initializing the package itself. If multiple packages import a package, the imported package will be initialized only once. The importing of packages, by construction, guarantees that there can be no cyclic initialization dependencies. More precisely:\n\nGiven the list of all packages, sorted by import path, in each step the first uninitialized package in the list for which all imported packages (if any) are already initialized is initialized. This step is repeated until all packages are initialized.\n\nPackage initialization—variable initialization and the invocation of functions—happens in a single goroutine, sequentially, one package at a time. An function may launch other goroutines, which can run concurrently with the initialization code. However, initialization always sequences the functions: it will not invoke the next one until the previous one has returned.\n\nA complete program is created by linking a single, unimported package called the main package with all the packages it imports, transitively. The main package must have package name and declare a function that takes no arguments and returns no value.\n\nProgram execution begins by initializing the program and then invoking the function in package . When that function invocation returns, the program exits. It does not wait for other (non- ) goroutines to complete.\n\nThe predeclared type is defined as\n\nIt is the conventional interface for representing an error condition, with the nil value representing no error. For instance, a function to read data from a file might be defined:\n\nExecution errors such as attempting to index an array out of bounds trigger a run-time panic equivalent to a call of the built-in function with a value of the implementation-defined interface type . That type satisfies the predeclared interface type . The exact error values that represent distinct run-time error conditions are unspecified.\n\nThe built-in package , known to the compiler and accessible through the import path , provides facilities for low-level programming including operations that violate the type system. A package using must be vetted manually for type safety and may not be portable. The package provides the following interface:\n\nA is a pointer type but a value may not be dereferenced. Any pointer or value of core type can be converted to a type of core type and vice versa. The effect of converting between and is implementation-defined.\n\nThe functions and take an expression of any type and return the alignment or size, respectively, of a hypothetical variable as if were declared via .\n\nThe function takes a (possibly parenthesized) selector , denoting a field of the struct denoted by or , and returns the field offset in bytes relative to the struct's address. If is an embedded field, it must be reachable without pointer indirections through fields of the struct. For a struct with field :\n\nComputer architectures may require memory addresses to be aligned; that is, for addresses of a variable to be a multiple of a factor, the variable's type's alignment. The function takes an expression denoting a variable of any type and returns the alignment of the (type of the) variable in bytes. For a variable :\n\nA (variable of) type has variable size if is a type parameter, or if it is an array or struct type containing elements or fields of variable size. Otherwise the size is constant. Calls to , , and are compile-time constant expressions of type if their arguments (or the struct in the selector expression for ) are types of constant size.\n\nThe function adds to and returns the updated pointer [Go 1.17]. The argument must be of integer type or an untyped constant. A constant argument must be representable by a value of type ; if it is an untyped constant it is given type . The rules for valid uses of still apply.\n\nThe function returns a slice whose underlying array starts at and whose length and capacity are . is equivalent to\n\nexcept that, as a special case, if is and is zero, returns [Go 1.17].\n\nThe argument must be of integer type or an untyped constant. A constant argument must be non-negative and representable by a value of type ; if it is an untyped constant it is given type . At run time, if is negative, or if is and is not zero, a run-time panic occurs [Go 1.17].\n\nThe function returns a pointer to the underlying array of the argument. If the slice's capacity is not zero, that pointer is . If is , the result is . Otherwise it is a non- pointer to an unspecified memory address [Go 1.20].\n\nThe function returns a value whose underlying bytes start at and whose length is . The same requirements apply to the and argument as in the function . If is zero, the result is the empty string . Since Go strings are immutable, the bytes passed to must not be modified afterwards. [Go 1.20]\n\nThe function returns a pointer to the underlying bytes of the argument. For an empty string the return value is unspecified, and may be . Since Go strings are immutable, the bytes returned by must not be modified [Go 1.20].\n\nFor the numeric types, the following sizes are guaranteed:\n\nThe following minimal alignment properties are guaranteed:\n• For a variable of any type: is at least 1.\n• For a variable of struct type: is the largest of all the values for each field of , but at least 1.\n• For a variable of array type: is the same as the alignment of a variable of the array's element type.\n\nA struct or array type has size zero if it contains no fields (or elements, respectively) that have a size greater than zero. Two distinct zero-size variables may have the same address in memory.\n\nThe Go 1 compatibility guarantee ensures that programs written to the Go 1 specification will continue to compile and run correctly, unchanged, over the lifetime of that specification. More generally, as adjustments are made and features added to the language, the compatibility guarantee ensures that a Go program that works with a specific Go language version will continue to work with any subsequent version.\n\nFor instance, the ability to use the prefix for binary integer literals was introduced with Go 1.13, indicated by [Go 1.13] in the section on integer literals. Source code containing an integer literal such as will be rejected if the implied or required language version used by the compiler is older than Go 1.13.\n\nThe following table describes the minimum language version required for features introduced after Go 1.\n• An alias declaration may be used to declare an alias name for a type.\n• Integer literals may use the prefixes , , , and for binary, and octal literals, respectively.\n• Hexadecimal floating-point literals may be written using the prefixes and .\n• The imaginary suffix may be used with any (binary, decimal, hexadecimal) integer or floating-point literal, not just decimal literals.\n• The digits of any number literal may be separated (grouped) using underscores .\n• The shift count in a shift operation may be a signed integer type.\n• Emdedding a method more than once through different embedded interfaces is not an error.\n• A slice may be converted to an array pointer if the slice and array element types match, and the array is not longer than the slice.\n• The built-in package includes the new functions and .\n\nThe 1.18 release adds polymorphic functions and types (\"generics\") to the language. Specifically:\n• The set of operators and punctuation includes the new token .\n• Interface types may embed arbitrary types (not just type names of interfaces) as well as union and type elements.\n• The set of predeclared types includes the new types and .\n• A slice may be converted to an array if the slice and array element types match and the array is not longer than the slice.\n• The built-in package includes the new functions , , and .\n• Comparable types (such as ordinary interfaces) may satisfy constraints, even if the type arguments are not strictly comparable.\n• The set of predeclared functions includes the new functions , , and .\n• Type inference uses the types of interface methods for inference. It also infers type arguments for generic functions assigned to variables or passed as arguments to other (possibly generic) functions.\n• In a \"for\" statement, each iteration has its own set of iteration variables rather than sharing the same variables in each iteration.\n• A \"for\" statement with \"range\" clause may iterate over integer values from zero to an upper limit.\n• A \"for\" statement with \"range\" clause accepts an iterator function as range expression.\n\nThe type unification rules describe if and how two types unify. The precise details are relevant for Go implementations, affect the specifics of error messages (such as whether a compiler reports a type inference or other error), and may explain why type inference fails in unusual code situations. But by and large these rules can be ignored when writing Go code: type inference is designed to mostly \"work as expected\", and the unification rules are fine-tuned accordingly.\n\nType unification is controlled by a matching mode, which may be exact or loose. As unification recursively descends a composite type structure, the matching mode used for elements of the type, the element matching mode, remains the same as the matching mode except when two types are unified for assignability ( ): in this case, the matching mode is loose at the top level but then changes to exact for element types, reflecting the fact that types don't have to be identical to be assignable.\n\nTwo types that are not bound type parameters unify exactly if any of following conditions is true:\n• Both types have identical structure and their element types unify exactly.\n• Exactly one type is an unbound type parameter with a core type, and that core type unifies with the other type per the unification rules for (loose unification at the top level and exact unification for element types).\n\nIf both types are bound type parameters, they unify per the given matching modes if:\n• At most one of the type parameters has a known type argument. In this case, the type parameters are joined: they both stand for the same type argument. If neither type parameter has a known type argument yet, a future type argument inferred for one the type parameters is simultaneously inferred for both of them.\n• Both type parameters have a known type argument and the type arguments unify per the given matching modes.\n\nA single bound type parameter and another type unify per the given matching modes if:\n• doesn't have a known type argument. In this case, is inferred as the type argument for .\n• does have a known type argument , and unify per the given matching modes, and one of the following conditions is true:\n• Both and are interface types: In this case, if both and are also defined types, they must be identical. Otherwise, if neither of them is a defined type, they must have the same number of methods (unification of and already established that the methods match).\n• Neither nor are interface types: In this case, if is a defined type, replaces as the inferred type argument for .\n\nFinally, two types that are not bound type parameters unify loosely (and per the element matching mode) if:\n• One type is a defined type, the other type is a type literal, but not an interface, and their underlying types unify per the element matching mode.\n• Both types are interfaces (but not type parameters) with identical type terms, both or neither embed the predeclared type comparable, corresponding method types unify exactly, and the method set of one of the interfaces is a subset of the method set of the other interface.\n• Only one type is an interface (but not a type parameter), corresponding methods of the two types unify per the element matching mode, and the method set of the interface is a subset of the method set of the other type.\n• Both types have the same structure and their element types unify per the element matching mode."
    },
    {
        "link": "https://doulos.com/knowhow/python/python-coding-guidelines-and-idioms",
        "document": "Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\n\nThis document is about recommended coding styles and idioms that are specific to Python. There are many general recommendations about coding style that would apply equally to Python and to other languages (e.g. use meaningful variable names, keep most functions short, insert blank lines between functions and between groups of related statements), but are not included in this document. In what follows, recommended Python coding styles and idioms are tagged as GOOD, and counter-examples are tagged as BAD. The counter examples are not necessarily bad in themselves, but each has been chosen to contrast with a particular GOOD example, just to make a specific point. Some of the points made are mere conventions that reflect common practice in the Python community. Many of the points made are not black-and-white, but require judgement and interpretation. Sometimes you may need to be a bit forgiving because it is not always possible to capture the full spirit of a coding guideline in a short example. Often you will need to \"close your eyes\" to certain aspects of an example, because the example has been contrived to illustrate a specific point. For example, many of the variable and function names below are single letters rather than being meaningful words (because they have no meaning in these contrived examples!) Please don't get hung up or dogmatic about any of this, but try to understand the spirit!"
    },
    {
        "link": "https://testdriven.io/blog/clean-code-python",
        "document": "In this article, we'll talk about clean code -- its benefits, different code standards and principles, and general guidelines on how to write clean code.\n\nClean code is a set of rules and principles that help to keep our code readable, maintainable, and extendable. It's one of the most important aspects of writing quality software. We (developers) spend way more time reading the code than actually writing it, which is why it's important that we write good code.\n\nWriting code is easy, but writing good, clean code is hard.\n\nThe code we write should be simple, expressive, and free from more than a few duplicates. Expressive code means that even though we're just providing instructions to a computer, it should still be readable and clearly communicate its intent when read by humans.\n\nWriting clean code has a number of benefits. For instance, clean code is:\n\nIt also tends to require less documentation.\n\nCode standards are collections of coding rules, guidelines, and best practices. Each programming language comes with its own coding standards, which should be followed in order to write cleaner code. They usually address:\n\nPEP 8 is a style guide that describes the coding standards for Python. It's the most popular guide within the Python community. The most important rules state the following:\n• variable names should be snake_case and all lowercase ( )\n• function names should be snake_case and all lowercase ( )\n• constants should be snake_case and all uppercase ( )\n• modules should have short, snake_case names and all lowercase ( )\n• single quotes and double quotes are treated the same (just pick one and be consistent)\n• indent using 4 spaces (spaces are preferred over tabs)\n• lines should not be longer than 79 characters\n• avoid multiple statements on the same line\n• top-level function and class definitions are surrounded with two blank lines\n• imports should be on separate lines\n• always surround binary operators with a single space on either side\n• if operators with different priorities are used, consider adding whitespace around the operators with the lowest priority\n• don't use spaces around the = sign when used to indicate a keyword argument\n• comments should not contradict the code\n• comments should have a space after the # sign with the first word capitalized\n• multi-line comments used in functions (docstrings) should have a short single-line description followed by more text\n\nIf you want to learn more read the official PEP 8 reference.\n\nPythonic code is a set of idioms, adopted by the Python community. It simply means that you're using Python's idioms and paradigms well in order to make your code cleaner, readable, and highly performant.\n\nThere's a big difference between writing Python code and writing Pythonic code. To write Pythonic code you can't just idiomatically translate another language (like Java or C++) to Python; you need to be thinking in Python to being with.\n\nLet's look at an example. We have to add the first 10 numbers together like so .\n\nA non-Pythonic solution would be something like this:\n\nA more Pythonic solution might look like this:\n\nThis second example is much easier to read by an experienced Python developer, but it does require a deeper understanding of Python's built-in functions and syntax. The easiest way to write Pythonic code is to keep the Zen of Python in mind as you're writing code and to incrementally learn Python's standard library.\n\nThe Zen of Python is a collection of 19 \"guiding principles\" for writing computer programs in Python. The collection was written in 1999 by software engineer Tim Peters. It's included as an Easter egg in the Python interpreter.\n\nYou can see it by executing the following command:\n\nIf you're curious about the meaning of the \"poem\", check out The Zen of Python, Explained, which provides a line-by-line explanation.\n\nThere are numerous coding principles you can follow to write better code, each having their own pros/cons and tradeoffs. This article covers four of the more popular principles: DRY, KISS, SoC, and SOLID.\n\nThis is one of the simplest coding principles. Its only rule is that code should not be duplicated. Instead of duplicating lines, find an algorithm that uses iteration. DRY code is easily maintainable. You can take this principle even further with model/data abstraction.\n\nThe cons of the DRY principle are that you can end up with too many abstractions, external dependency creations, and complex code. DRY can also cause complications if you try to change a bigger chunk of your codebase. This is why you should avoid DRYing your code too early. It's always better to have a few repeated code sections than wrong abstractions.\n\nThe KISS principle states that most systems work best if they are kept simple rather than made complicated. Simplicity should be a key goal in design, and unnecessary complexity should be avoided.\n\nA good example of SoC is MVC (Model - View - Controller).\n\nIf you decide to go with this approach be careful not to split your app into too many modules. You should only create a new module when it makes sense to do so. More modules equals more problems.\n\nSOLID is extremely useful when writing OOP code. It talks about splitting your class into multiple subclasses, inheritance, abstraction, interfaces, and more.\n\nIt consists of the following five concepts:\n• The Single-responsibility principle: \"A class should have one, and only one, reason to change.\"\n• The Open–closed principle: \"Entities should be open for extension, but closed for modification.\"\n• The Liskov substitution principle: \"Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.\"\n• The Interface segregation principle: \"A client should not be forced to implement an interface that it doesn’t use.\"\n• The Dependency inversion principle: \"Depend upon abstractions, not concretions.\"\n\nCode formatters enforce coding style through automatic formatting and help to achieve and maintain clean code. Most of them allow you to create a style configuration file that you can share with your colleagues.\n\nThe most popular Python code formatters are:\n\nMost modern IDEs also include linters, which run in the background as you type and help to identify small coding mistakes, errors, dangerous code patterns and keep your code formatted. There are two types of linters: logical and stylistic.\n\nThe most popular Python linters are:\n\nOne of the most important aspects of writing clean code is naming conventions. You should always use meaningful and intention-revealing names. It's always better to use long, descriptive names than short names with comments.\n\nWe'll look at more examples in the next two sections.\n\nOther developers should be able to figure out what a variable stores just by reading its name.\n\nYou should always use pronounceable names; otherwise, you'll have a hard time explaining your algorithms out loud.\n\nDon't try to come up with your own abbreviations. It's better for a variable to have a longer name than a confusing name.\n\n5. Always use the same vocabulary\n\nMagic numbers are strange numbers that appear in code, which do not have a clear meaning. Let's take a look at an example:\n\nInstead of using magic numbers, we can extract them into a meaningful variable.\n\nIf you use a lot of different data types in your algorithm or class and you can't figure them out from the variable name itself, don't be afraid to add data type suffix to your variable name. For example:\n\nAnd here's a bad example (because you can't figure out the data type from the variable name):\n\nDo not add unnecessary data to variable names, especially if you're working with classes.\n\nWe're already inside the class, so there's no need to add a prefix to every class variable.\n\n2. Do not use different words for the same concept\n\nPick a word for each concept and stick to it. Using different words for the same concept will cause confusion.\n\nIf your function contains the keyword 'and' you can probably split it into two functions. Let's look at an example:\n\nFunctions should do one thing and, as a reader, they do what you expect them to do.\n\n5. Keep your arguments at a minimum\n\nThe arguments in your function should be kept to a minimum. Ideally, your functions should only have one to two arguments. If you need to provide more arguments to the function, you can create a config object which you pass to the function or split it into multiple functions.\n\nFlags are variables (usually booleans) passed to functions, which the function uses to determine its behavior. They are considered bad design because functions should only perform one task. The easiest way to avoid flags is to split your function into smaller functions.\n\nA function produces a side effect if it does anything other than take a value in and return another value or values. For example, a side effect could be writing to a file or modifying a global variable.\n\nNo matter how hard we try to write clean code, there are still going to be parts of your program that need additional explanation. Comments allow us to quickly tell other developers (and our future selves) why we wrote it in the manner that we did. Keep in mind that adding too many comments can make your code messier than it would be without them.\n\nWhat's the difference between code comments and documentation?\n\nCommenting bad code -- i.e., # TODO: RE-WRITE THIS TO BE BETTER -- only helps you in the short term. Sooner or later one of your colleagues will have to work with your code and they'll end up rewriting it after spending multiple hours trying to figure out what it does.\n\nIf your code is readable enough you don't need comments. Adding useless comments will only make your code less readable. Here's a bad example:\n\nAs a general rule, if you need to add comments, they should explain \"why\" you did something rather than \"what\" is happening.\n\nDon't add comments that do not add anything of value to the code. This is bad:\n\nThis is also bad:\n\nMost programming languages have different comment types. Learn their differences and use them accordingly. You should also learn the comment documentation syntax. A good example:\n\nThe worst thing you can do is to leave code commented out in your programs. All the debug code or debug messages should be removed before pushing to a version control system, otherwise, your colleagues will be scared of deleting it and your commented code will stay there forever.\n\nIn this section, we'll look at some Python concepts and tricks, which we can use to write better code.\n\nDecorators are an extremely powerful tool in Python, which allows us to add some custom functionality to a function. At its core, they are just functions called inside functions. By using them we take advantage of the SoC (Separation of concerns) principle and make our code more modular. Learn them and you'll be on your way to Pythonic code!\n\nLet's say we have a server, which is protected with a password. We could either ask for the password in every server method or create a decorator and protect our server methods like so:\n\nOur server will now ask for a password every time or is called.\n\nContext managers simplify how we interact with external resources, like files and databases. The most common usage is the statement. The good thing about them is that they automatically deallocate memory outside of their block.\n\nLet's look at an example:\n\nWithout a context manager our code would look like this:\n\nAn iterator is an object that contains a countable number of values. Iterators allow an object to be iterated upon, which means that you can traverse through all the values.\n\nLet's say we have a list of names and we want to loop through it. We can loop through it using :\n\nOr use an enhanced loop:\n\nA generator is a function in Python which returns an iterator object instead of one single value. The main difference between normal functions and generators is that generators use the keyword instead of . Each next value in the iterator is fetched using .\n\nLet's say we want to generate the first multiples of . Our generator would look something like this:\n\nIn order to keep your code as organized as possible, you should split it into multiple files which are then split up into different directories. If you're writing code in an OOP-oriented language you should also follow basic OOP principles like encapsulation, abstraction, inheritance, and polymorphism.\n\nSplitting code into multiple classes will make your code easier to understand and maintain. There is no fixed rule on how long a file or a class should be, but try your best to keep them small (preferably under 200 lines).\n\nDjango's default project structure is a good example of how your code should be structured:\n\nDjango is an MTV (Model - Template - View) framework, which is similar to an MVC framework that we discussed earlier. This pattern divides program logic into three interconnected parts. You can see that each app is in a separate directory and each file serves one specific thing. If your project is split into multiple apps, you should make sure that the apps don't depend too much on each other.\n\nQuality software doesn't come without tests. Testing software allows us to discover bugs and errors in the software before it is deployed. Tests are of the same importance as production code and you should spend a fair amount of time working on them.\n\nFor more on testing clean code and writing clean test code, review the following articles:\n\nWriting clean code is hard. There's no single recipe you can follow to write good, clean code. It takes time and experience to master. We've looked at some of the coding standards and general guidelines which can help you write better code. One of the best pieces of advice I can give you is to stay consistent and try to write simple code that's easy to test. If you find that your code is hard to test, it's probably hard to use.\n\nIf you're looking for more, check out the Complete Python Development Guide, where you'll learn how to write clean code from a practical, learning-by-doing approach."
    },
    {
        "link": "https://docs.python-guide.org/writing/style",
        "document": "If you ask Python programmers what they like most about Python, they will often cite its high readability. Indeed, a high level of readability is at the heart of the design of the Python language, following the recognized fact that code is read much more often than it is written.\n\nOne reason for the high readability of Python code is its relatively complete set of Code Style guidelines and “Pythonic” idioms.\n\nWhen a veteran Python developer (a Pythonista) calls portions of code not “Pythonic”, they usually mean that these lines of code do not follow the common guidelines and fail to express its intent in what is considered the best (hear: most readable) way.\n\nOn some border cases, no best way has been agreed upon on how to express an intent in Python code, but these cases are rare.\n\nWhile any kind of black magic is possible with Python, the most explicit and straightforward manner is preferred. In the good code above, x and y are explicitly received from the caller, and an explicit dictionary is returned. The developer using this function knows exactly what to do by reading the first and last lines, which is not the case with the bad example. While some compound statements such as list comprehensions are allowed and appreciated for their brevity and their expressiveness, it is bad practice to have two disjointed statements on the same line of code. Arguments can be passed to functions in four different ways.\n• Positional arguments are mandatory and have no default values. They are the simplest form of arguments and they can be used for the few function arguments that are fully part of the function’s meaning and their order is natural. For instance, in or the user of the function has no difficulty remembering that those two functions require two arguments, and in which order. In those two cases, it is possible to use argument names when calling the functions and, doing so, it is possible to switch the order of arguments, calling for instance and but this reduces readability and is unnecessarily verbose, compared to the more straightforward calls to and .\n• Keyword arguments are not mandatory and have default values. They are often used for optional parameters sent to the function. When a function has more than two or three positional parameters, its signature is more difficult to remember and using keyword arguments with default values is helpful. For instance, a more complete function could be defined as . Here and are optional, and evaluate to when they are not passed another value. Calling a function with keyword arguments can be done in multiple ways in Python; for example, it is possible to follow the order of arguments in the definition without explicitly naming the arguments, like in , sending a blind carbon copy to God. It would also be possible to name arguments in another order, like in . Those two possibilities are better avoided without any strong reason to not follow the syntax that is the closest to the function definition: . As a side note, following the YAGNI principle, it is often harder to remove an optional argument (and its logic inside the function) that was added “just in case” and is seemingly never used, than to add a new optional argument and its logic when needed.\n• The arbitrary argument list is the third way to pass arguments to a function. If the function intention is better expressed by a signature with an extensible number of positional arguments, it can be defined with the constructs. In the function body, will be a tuple of all the remaining positional arguments. For example, can be called with each recipient as an argument: , and in the function body will be equal to . However, this construct has some drawbacks and should be used with caution. If a function receives a list of arguments of the same nature, it is often more clear to define it as a function of one argument, that argument being a list or any sequence. Here, if has multiple recipients, it is better to define it explicitly: and call it with . This way, the user of the function can manipulate the recipient list as a list beforehand, and it opens the possibility to pass any sequence, including iterators, that cannot be unpacked as other sequences.\n• The arbitrary keyword argument dictionary is the last way to pass arguments to functions. If the function requires an undetermined series of named arguments, it is possible to use the construct. In the function body, will be a dictionary of all the passed named arguments that have not been caught by other keyword arguments in the function signature. The same caution as in the case of arbitrary argument list is necessary, for similar reasons: these powerful techniques are to be used when there is a proven necessity to use them, and they should not be used if the simpler and clearer construct is sufficient to express the function’s intention. It is up to the programmer writing the function to determine which arguments are positional arguments and which are optional keyword arguments, and to decide whether to use the advanced techniques of arbitrary argument passing. If the advice above is followed wisely, it is possible and enjoyable to write Python functions that are:\n• easy to read (the name and arguments need no explanations)\n• easy to change (adding a new keyword argument does not break other parts of the code) A powerful tool for hackers, Python comes with a very rich set of hooks and tools allowing you to do almost any kind of tricky tricks. For instance, it is possible to do each of the following:\n• change how objects are created and instantiated\n• It is even possible (and recommended if needed) to embed C routines in Python. However, all these options have many drawbacks and it is always better to use the most straightforward way to achieve your goal. The main drawback is that readability suffers greatly when using these constructs. Many code analysis tools, such as pylint or pyflakes, will be unable to parse this “magic” code. We consider that a Python developer should know about these nearly infinite possibilities, because it instills confidence that no impassable problem will be on the way. However, knowing how and particularly when not to use them is very important. Like a kung fu master, a Pythonista knows how to kill with a single finger, and never to actually do it. We are all responsible users¶ As seen above, Python allows many tricks, and some of them are potentially dangerous. A good example is that any client code can override an object’s properties and methods: there is no “private” keyword in Python. This philosophy, very different from highly defensive languages like Java, which give a lot of mechanisms to prevent any misuse, is expressed by the saying: “We are all responsible users”. This doesn’t mean that, for example, no properties are considered private, and that no proper encapsulation is possible in Python. Rather, instead of relying on concrete walls erected by the developers between their code and others’, the Python community prefers to rely on a set of conventions indicating that these elements should not be accessed directly. The main convention for private properties and implementation details is to prefix all “internals” with an underscore. If the client code breaks this rule and accesses these marked elements, any misbehavior or problems encountered if the code is modified is the responsibility of the client code. Using this convention generously is encouraged: any method or property that is not intended to be used by client code should be prefixed with an underscore. This will guarantee a better separation of duties and easier modification of existing code; it will always be possible to publicize a private property, but making a public property private might be a much harder operation. When a function grows in complexity, it is not uncommon to use multiple return statements inside the function’s body. However, in order to keep a clear intent and a sustainable readability level, it is preferable to avoid returning meaningful values from many output points in the body. There are two main cases for returning values in a function: the result of the function return when it has been processed normally, and the error cases that indicate a wrong input parameter or any other reason for the function to not be able to complete its computation or task. If you do not wish to raise exceptions for the second case, then returning a value, such as None or False, indicating that the function could not perform correctly might be needed. In this case, it is better to return as early as the incorrect context has been detected. It will help to flatten the structure of the function: all the code after the return-because-of-error statement can assume the condition is met to further compute the function’s main result. Having multiple such return statements is often necessary. However, when a function has multiple main exit points for its normal course, it becomes difficult to debug the returned result, so it may be preferable to keep a single exit point. This will also help factoring out some code paths, and the multiple exit points are a probable indication that such a refactoring is needed. # Raising an exception might be better # Raising an exception might be better # Some complex code trying to compute x from a, b and c # One single exit point for the returned value x will help\n\nA programming idiom, put simply, is a way to write code. The notion of programming idioms is discussed amply at c2 and at Stack Overflow. Idiomatic Python code is often referred to as being Pythonic. Although there usually is one — and preferably only one — obvious way to do it; the way to write idiomatic Python code can be non-obvious to Python beginners. So, good idioms must be consciously acquired. If you know the length of a list or tuple, you can assign names to its elements with unpacking. For example, since will provide a tuple of two elements for each item in list: # do something with index and item You can use this to swap variables as well: In Python 3, a new method of extended unpacking was introduced by PEP 3132: If you need to assign something (for instance, in Unpacking) but will not need that variable, use : Many Python style guides recommend the use of a single underscore “ ” for throwaway variables rather than the double underscore “ ” recommended here. The issue is that “ ” is commonly used as an alias for the function, and is also used at the interactive prompt to hold the value of the last operation. Using a double underscore instead is just as clear and almost as convenient, and eliminates the risk of accidentally interfering with either of these other use cases. Create a length-N list of the same thing¶ Because lists are mutable, the operator (as above) will create a list of N references to the list, which is not likely what you want. Instead, use a list comprehension: A common idiom for creating strings is to use on an empty string. This will set the value of the variable word to ‘spam’. This idiom can be applied to lists and tuples. Searching for an item in a collection¶ Sometimes we need to search through a collection of things. Let’s look at two options: lists and sets. Take the following code for example: Even though both functions look identical, because lookup_set is utilizing the fact that sets in Python are hashtables, the lookup performance between the two is very different. To determine whether an item is in a list, Python will have to go through each item until it finds a matching item. This is time consuming, especially for long lists. In a set, on the other hand, the hash of the item will tell Python where in the set to look for a matching item. As a result, the search can be done quickly, even if the set is large. Searching in dictionaries works the same way. For more information see this StackOverflow page. For detailed information on the amount of time various common operations take on each of these data structures, see this page. Because of these differences in performance, it is often a good idea to use sets or dictionaries instead of lists in cases where:\n• The collection will contain a large number of items\n• You will be repeatedly searching for items in the collection\n• You do not have duplicate items. For small collections, or collections which you will not frequently be searching through, the additional time and memory required to set up the hashtable will often be greater than the time saved by the improved search speed.\n\nAlso known as PEP 20, the guiding principles for Python’s design. The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Special cases aren't special enough to break the rules. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those! For some examples of good Python style, see these slides from a Python user group.\n\nPEP 8 is the de facto code style guide for Python. A high quality, easy-to-read version of PEP 8 is also available at pep8.org. This is highly recommended reading. The entire Python community does their best to adhere to the guidelines laid out within this document. Some project may sway from it from time to time, while others may amend its recommendations. That being said, conforming your Python code to PEP 8 is generally a good idea and helps make code more consistent when working on projects with other developers. There is a command-line program, pycodestyle (previously known as ), that can check your code for conformance. Install it by running the following command in your terminal: Then run it on a file or series of files to get a report of any violations. pycodestyle optparse.py optparse.py:544:21: W601 .has_key() is deprecated, use 'in' There are several auto-formatting tools that can reformat your code, in order to comply with PEP 8. The program autopep8 can be used to automatically reformat code in the PEP 8 style. Install the program with: Use it to format a file in-place with: Excluding the flag will cause the program to output the modified code directly to the console for review. The flag will perform more substantial changes and can be applied multiple times for greater effect. While autopep8 focuses on solving the PEP 8 violations, yapf tries to improve the format of your code aside from complying with PEP 8. This formatter aims at providing as good looking code as a programmer who writes PEP 8 compliant code. It gets installed with: Run the auto-formatting of a file with: Similar to autopep8, running the command without the flag will output the diff for review before applying the changes. The auto-formatter black offers an opinionated and deterministic reformatting of your code base. Its main focus lies in providing a uniform code style without the need of configuration throughout its users. Hence, users of black are able to forget about formatting altogether. Also, due to the deterministic approach minimal git diffs with only the relevant changes are guaranteed. You can install the tool as follows: A python file can be formatted with: Adding the flag provides the code modification for review without direct application.\n\nHere are some conventions you should follow to make your code easier to read. You don’t need to explicitly compare a value to True, or None, or 0 – you can just add it to the if statement. See Truth Value Testing for a list of what is considered false. # or check for the opposite # or, since None is considered false, explicitly check for it Don’t use the method. Instead, use syntax, or pass a default argument to . List comprehensions provides a powerful, concise way to work with lists. Generator expressions follows almost the same syntax as list comprehensions but return a generator instead of a list. Creating a new list requires more work and uses more memory. If you are just going to loop through the new list, prefer using an iterator instead. # needlessly allocates a list of all (gpa, name) entires in memory Use list comprehensions when you really need to create a second list, for example if you need to use the result multiple times. If your logic is too complicated for a short list comprehension or generator expression, consider using a generator function instead of returning a list. Never use a list comprehension just for its side effects. Never remove items from a list while you are iterating through it. Possible side effects of modifying the original list¶ Modifying the original list can be risky if there are other variables referencing it. But you can use slice assignment if you really want to do that. # replace the contents of the original list Remember that assignment never creates a new object. If two or more variables refer to the same list, changing one of them changes them all. # Add three to all list members. # a and b refer to the same list object It’s safer to create a new list object and leave the original alone. # assign the variable \"a\" to a new list without changing \"b\" Use keep a count of your place in the list. The function has better readability than handling a counter manually. Moreover, it is better optimized for iterators. Use the syntax to read from files. This will automatically close files for you. The statement is better because it will ensure you always close the file, even if an exception is raised inside the block. When a logical line of code is longer than the accepted limit, you need to split it over multiple physical lines. The Python interpreter will join consecutive lines if the last character of the line is a backslash. This is helpful in some cases, but should usually be avoided because of its fragility: a white space added to the end of the line, after the backslash, will break the code and may have unexpected results. A better solution is to use parentheses around your elements. Left with an unclosed parenthesis on an end-of-line, the Python interpreter will join the next line until the parentheses are closed. The same behavior holds for curly and square braces. \"\"\"For a long time I used to go to bed early. Sometimes, when I had put out my candle, my eyes would close so quickly that I had not even time to say “I’m going to sleep.”\"\"\" \\ \"For a long time I used to go to bed early. Sometimes, \" \"when I had put out my candle, my eyes would close so quickly \" \"that I had not even time to say “I’m going to sleep.”\" However, more often than not, having to split a long logical line is a sign that you are trying to do too many things at the same time, which may hinder readability."
    },
    {
        "link": "https://peps.python.org/pep-0008",
        "document": "This document gives coding conventions for the Python code comprising the standard library in the main Python distribution. Please see the companion informational PEP describing style guidelines for the C code in the C implementation of Python. This document and PEP 257 (Docstring Conventions) were adapted from Guido’s original Python Style Guide essay, with some additions from Barry’s style guide . This style guide evolves over time as additional conventions are identified and past conventions are rendered obsolete by changes in the language itself. Many projects have their own coding style guidelines. In the event of any conflicts, such project-specific guides take precedence for that project.\n\nA Foolish Consistency is the Hobgoblin of Little Minds One of Guido’s key insights is that code is read much more often than it is written. The guidelines provided here are intended to improve the readability of code and make it consistent across the wide spectrum of Python code. As PEP 20 says, “Readability counts”. A style guide is about consistency. Consistency with this style guide is important. Consistency within a project is more important. Consistency within one module or function is the most important. However, know when to be inconsistent – sometimes style guide recommendations just aren’t applicable. When in doubt, use your best judgment. Look at other examples and decide what looks best. And don’t hesitate to ask! In particular: do not break backwards compatibility just to comply with this PEP! Some other good reasons to ignore a particular guideline:\n• When applying the guideline would make the code less readable, even for someone who is used to reading code that follows this PEP.\n• To be consistent with surrounding code that also breaks it (maybe for historic reasons) – although this is also an opportunity to clean up someone else’s mess (in true XP style).\n• Because the code in question predates the introduction of the guideline and there is no other reason to be modifying that code.\n• When the code needs to remain compatible with older versions of Python that don’t support the feature recommended by the style guide.\n\nContinuation lines should align wrapped elements either vertically using Python’s implicit line joining inside parentheses, brackets and braces, or using a hanging indent . When using a hanging indent the following should be considered; there should be no arguments on the first line and further indentation should be used to clearly distinguish itself as a continuation line: # Add 4 spaces (an extra level of indentation) to distinguish arguments from the rest. # Arguments on first line forbidden when not using vertical alignment. # Further indentation required as indentation is not distinguishable. The 4-space rule is optional for continuation lines. # Hanging indents *may* be indented to other than 4 spaces. When the conditional part of an -statement is long enough to require that it be written across multiple lines, it’s worth noting that the combination of a two character keyword (i.e. ), plus a single space, plus an opening parenthesis creates a natural 4-space indent for the subsequent lines of the multiline conditional. This can produce a visual conflict with the indented suite of code nested inside the -statement, which would also naturally be indented to 4 spaces. This PEP takes no explicit position on how (or whether) to further visually distinguish such conditional lines from the nested suite inside the -statement. Acceptable options in this situation include, but are not limited to: # Add a comment, which will provide some distinction in editors # Since both conditions are true, we can frobnicate. # Add some extra indentation on the conditional continuation line. The closing brace/bracket/parenthesis on multiline constructs may either line up under the first non-whitespace character of the last line of list, as in: or it may be lined up under the first character of the line that starts the multiline construct, as in: Tabs should be used solely to remain consistent with code that is already indented with tabs. Limit all lines to a maximum of 79 characters. For flowing long blocks of text with fewer structural restrictions (docstrings or comments), the line length should be limited to 72 characters. Limiting the required editor window width makes it possible to have several files open side by side, and works well when using code review tools that present the two versions in adjacent columns. The default wrapping in most tools disrupts the visual structure of the code, making it more difficult to understand. The limits are chosen to avoid wrapping in editors with the window width set to 80, even if the tool places a marker glyph in the final column when wrapping lines. Some web based tools may not offer dynamic line wrapping at all. Some teams strongly prefer a longer line length. For code maintained exclusively or primarily by a team that can reach agreement on this issue, it is okay to increase the line length limit up to 99 characters, provided that comments and docstrings are still wrapped at 72 characters. The Python standard library is conservative and requires limiting lines to 79 characters (and docstrings/comments to 72). The preferred way of wrapping long lines is by using Python’s implied line continuation inside parentheses, brackets and braces. Long lines can be broken over multiple lines by wrapping expressions in parentheses. These should be used in preference to using a backslash for line continuation. Backslashes may still be appropriate at times. For example, long, multiple -statements could not use implicit continuation before Python 3.10, so backslashes were acceptable for that case: Another such case is with statements. Make sure to indent the continued line appropriately. Should a Line Break Before or After a Binary Operator? For decades the recommended style was to break after binary operators. But this can hurt readability in two ways: the operators tend to get scattered across different columns on the screen, and each operator is moved away from its operand and onto the previous line. Here, the eye has to do extra work to tell which items are added and which are subtracted: # operators sit far away from their operands To solve this readability problem, mathematicians and their publishers follow the opposite convention. Donald Knuth explains the traditional rule in his Computers and Typesetting series: “Although formulas within a paragraph always break after binary operations and relations, displayed formulas always break before binary operations” . Following the tradition from mathematics usually results in more readable code: In Python code, it is permissible to break before or after a binary operator, as long as the convention is consistent locally. For new code Knuth’s style is suggested. Surround top-level function and class definitions with two blank lines. Extra blank lines may be used (sparingly) to separate groups of related functions. Blank lines may be omitted between a bunch of related one-liners (e.g. a set of dummy implementations). Use blank lines in functions, sparingly, to indicate logical sections. Python accepts the control-L (i.e. ^L) form feed character as whitespace; many tools treat these characters as page separators, so you may use them to separate pages of related sections of your file. Note, some editors and web-based code viewers may not recognize control-L as a form feed and will show another glyph in its place. Code in the core Python distribution should always use UTF-8, and should not have an encoding declaration. In the standard library, non-UTF-8 encodings should be used only for test purposes. Use non-ASCII characters sparingly, preferably only to denote places and human names. If using non-ASCII characters as data, avoid noisy Unicode characters like z̯̯͡a̧͎̺l̡͓̫g̹̲o̡̼̘ and byte order marks. All identifiers in the Python standard library MUST use ASCII-only identifiers, and SHOULD use English words wherever feasible (in many cases, abbreviations and technical terms are used which aren’t English). Open source projects with a global audience are encouraged to adopt a similar policy.\n• Imports should usually be on separate lines: It’s okay to say this though:\n• Imports are always put at the top of the file, just after any module comments and docstrings, and before module globals and constants. Imports should be grouped in the following order: You should put a blank line between each group of imports.\n• Absolute imports are recommended, as they are usually more readable and tend to be better behaved (or at least give better error messages) if the import system is incorrectly configured (such as when a directory inside a package ends up on ): However, explicit relative imports are an acceptable alternative to absolute imports, especially when dealing with complex package layouts where using absolute imports would be unnecessarily verbose: Standard library code should avoid complex package layouts and always use absolute imports.\n• When importing a class from a class-containing module, it’s usually okay to spell this: If this spelling causes local name clashes, then spell them explicitly: and use and .\n• Wildcard imports ( ) should be avoided, as they make it unclear which names are present in the namespace, confusing both readers and many automated tools. There is one defensible use case for a wildcard import, which is to republish an internal interface as part of a public API (for example, overwriting a pure Python implementation of an interface with the definitions from an optional accelerator module and exactly which definitions will be overwritten isn’t known in advance). When republishing names this way, the guidelines below regarding public and internal interfaces still apply. Module level “dunders” (i.e. names with two leading and two trailing underscores) such as , , , etc. should be placed after the module docstring but before any import statements except imports. Python mandates that future-imports must appear in the module before any other code except docstrings: \"\"\"This is the example module.\n\nWhen to Use Trailing Commas Trailing commas are usually optional, except they are mandatory when making a tuple of one element. For clarity, it is recommended to surround the latter in (technically redundant) parentheses: When trailing commas are redundant, they are often helpful when a version control system is used, when a list of values, arguments or imported items is expected to be extended over time. The pattern is to put each value (etc.) on a line by itself, always adding a trailing comma, and add the close parenthesis/bracket/brace on the next line. However it does not make sense to have a trailing comma on the same line as the closing delimiter (except in the above case of singleton tuples):\n\nThe naming conventions of Python’s library are a bit of a mess, so we’ll never get this completely consistent – nevertheless, here are the currently recommended naming standards. New modules and packages (including third party frameworks) should be written to these standards, but where an existing library has a different style, internal consistency is preferred. Names that are visible to the user as public parts of the API should follow conventions that reflect usage rather than implementation. There are a lot of different naming styles. It helps to be able to recognize what naming style is being used, independently from what they are used for. The following naming styles are commonly distinguished:\n• (or CapWords, or CamelCase – so named because of the bumpy look of its letters ). This is also sometimes known as StudlyCaps. Note: When using acronyms in CapWords, capitalize all the letters of the acronym. Thus HTTPServerError is better than HttpServerError. There’s also the style of using a short unique prefix to group related names together. This is not used much in Python, but it is mentioned for completeness. For example, the function returns a tuple whose items traditionally have names like , , and so on. (This is done to emphasize the correspondence with the fields of the POSIX system call struct, which helps programmers familiar with that.) The X11 library uses a leading X for all its public functions. In Python, this style is generally deemed unnecessary because attribute and method names are prefixed with an object, and function names are prefixed with a module name. In addition, the following special forms using leading or trailing underscores are recognized (these can generally be combined with any case convention):\n• : weak “internal use” indicator. E.g. does not import objects whose names start with an underscore.\n• : used by convention to avoid conflicts with Python keyword, e.g. :\n• : when naming a class attribute, invokes name mangling (inside class FooBar, becomes ; see below).\n• : “magic” objects or attributes that live in user-controlled namespaces. E.g. , or . Never invent such names; only use them as documented. Never use the characters ‘l’ (lowercase letter el), ‘O’ (uppercase letter oh), or ‘I’ (uppercase letter eye) as single character variable names. In some fonts, these characters are indistinguishable from the numerals one and zero. When tempted to use ‘l’, use ‘L’ instead. Identifiers used in the standard library must be ASCII compatible as described in the policy section of PEP 3131. Modules should have short, all-lowercase names. Underscores can be used in the module name if it improves readability. Python packages should also have short, all-lowercase names, although the use of underscores is discouraged. When an extension module written in C or C++ has an accompanying Python module that provides a higher level (e.g. more object oriented) interface, the C/C++ module has a leading underscore (e.g. ). Class names should normally use the CapWords convention. The naming convention for functions may be used instead in cases where the interface is documented and used primarily as a callable. Note that there is a separate convention for builtin names: most builtin names are single words (or two words run together), with the CapWords convention used only for exception names and builtin constants. Names of type variables introduced in PEP 484 should normally use CapWords preferring short names: , , . It is recommended to add suffixes or to the variables used to declare covariant or contravariant behavior correspondingly: Because exceptions should be classes, the class naming convention applies here. However, you should use the suffix “Error” on your exception names (if the exception actually is an error). (Let’s hope that these variables are meant for use inside one module only.) The conventions are about the same as those for functions. Modules that are designed for use via should use the mechanism to prevent exporting globals, or use the older convention of prefixing such globals with an underscore (which you might want to do to indicate these globals are “module non-public”). Function names should be lowercase, with words separated by underscores as necessary to improve readability. Variable names follow the same convention as function names. mixedCase is allowed only in contexts where that’s already the prevailing style (e.g. threading.py), to retain backwards compatibility. Always use for the first argument to instance methods. Always use for the first argument to class methods. If a function argument’s name clashes with a reserved keyword, it is generally better to append a single trailing underscore rather than use an abbreviation or spelling corruption. Thus is better than . (Perhaps better is to avoid such clashes by using a synonym.) Use the function naming rules: lowercase with words separated by underscores as necessary to improve readability. Use one leading underscore only for non-public methods and instance variables. To avoid name clashes with subclasses, use two leading underscores to invoke Python’s name mangling rules. Python mangles these names with the class name: if class Foo has an attribute named , it cannot be accessed by . (An insistent user could still gain access by calling .) Generally, double leading underscores should be used only to avoid name conflicts with attributes in classes designed to be subclassed. Note: there is some controversy about the use of __names (see below). Constants are usually defined on a module level and written in all capital letters with underscores separating words. Examples include and . Always decide whether a class’s methods and instance variables (collectively: “attributes”) should be public or non-public. If in doubt, choose non-public; it’s easier to make it public later than to make a public attribute non-public. Public attributes are those that you expect unrelated clients of your class to use, with your commitment to avoid backwards incompatible changes. Non-public attributes are those that are not intended to be used by third parties; you make no guarantees that non-public attributes won’t change or even be removed. We don’t use the term “private” here, since no attribute is really private in Python (without a generally unnecessary amount of work). Another category of attributes are those that are part of the “subclass API” (often called “protected” in other languages). Some classes are designed to be inherited from, either to extend or modify aspects of the class’s behavior. When designing such a class, take care to make explicit decisions about which attributes are public, which are part of the subclass API, and which are truly only to be used by your base class. With this in mind, here are the Pythonic guidelines:\n• Public attributes should have no leading underscores.\n• If your public attribute name collides with a reserved keyword, append a single trailing underscore to your attribute name. This is preferable to an abbreviation or corrupted spelling. (However, notwithstanding this rule, ‘cls’ is the preferred spelling for any variable or argument which is known to be a class, especially the first argument to a class method.) Note 1: See the argument name recommendation above for class methods.\n• For simple public data attributes, it is best to expose just the attribute name, without complicated accessor/mutator methods. Keep in mind that Python provides an easy path to future enhancement, should you find that a simple data attribute needs to grow functional behavior. In that case, use properties to hide functional implementation behind simple data attribute access syntax. Note 1: Try to keep the functional behavior side-effect free, although side-effects such as caching are generally fine. Note 2: Avoid using properties for computationally expensive operations; the attribute notation makes the caller believe that access is (relatively) cheap.\n• If your class is intended to be subclassed, and you have attributes that you do not want subclasses to use, consider naming them with double leading underscores and no trailing underscores. This invokes Python’s name mangling algorithm, where the name of the class is mangled into the attribute name. This helps avoid attribute name collisions should subclasses inadvertently contain attributes with the same name. Note 1: Note that only the simple class name is used in the mangled name, so if a subclass chooses both the same class name and attribute name, you can still get name collisions. Note 2: Name mangling can make certain uses, such as debugging and , less convenient. However the name mangling algorithm is well documented and easy to perform manually. Note 3: Not everyone likes name mangling. Try to balance the need to avoid accidental name clashes with potential use by advanced callers. Any backwards compatibility guarantees apply only to public interfaces. Accordingly, it is important that users be able to clearly distinguish between public and internal interfaces. Documented interfaces are considered public, unless the documentation explicitly declares them to be provisional or internal interfaces exempt from the usual backwards compatibility guarantees. All undocumented interfaces should be assumed to be internal. To better support introspection, modules should explicitly declare the names in their public API using the attribute. Setting to an empty list indicates that the module has no public API. Even with set appropriately, internal interfaces (packages, modules, classes, functions, attributes or other names) should still be prefixed with a single leading underscore. An interface is also considered internal if any containing namespace (package, module or class) is considered internal. Imported names should always be considered an implementation detail. Other modules must not rely on indirect access to such imported names unless they are an explicitly documented part of the containing module’s API, such as or a package’s module that exposes functionality from submodules.\n• Code should be written in a way that does not disadvantage other implementations of Python (PyPy, Jython, IronPython, Cython, Psyco, and such). For example, do not rely on CPython’s efficient implementation of in-place string concatenation for statements in the form or . This optimization is fragile even in CPython (it only works for some types) and isn’t present at all in implementations that don’t use refcounting. In performance sensitive parts of the library, the form should be used instead. This will ensure that concatenation occurs in linear time across various implementations.\n• Comparisons to singletons like None should always be done with or , never the equality operators. Also, beware of writing when you really mean if x is not None – e.g. when testing whether a variable or argument that defaults to None was set to some other value. The other value might have a type (such as a container) that could be false in a boolean context!\n• Use operator rather than . While both expressions are functionally identical, the former is more readable and preferred:\n• When implementing ordering operations with rich comparisons, it is best to implement all six operations ( , , , , , ) rather than relying on other code to only exercise a particular comparison. To minimize the effort involved, the decorator provides a tool to generate missing comparison methods. PEP 207 indicates that reflexivity rules are assumed by Python. Thus, the interpreter may swap with , with , and may swap the arguments of and . The and operations are guaranteed to use the operator and the function uses the operator. However, it is best to implement all six operations so that confusion doesn’t arise in other contexts.\n• Always use a def statement instead of an assignment statement that binds a lambda expression directly to an identifier: The first form means that the name of the resulting function object is specifically ‘f’ instead of the generic ‘<lambda>’. This is more useful for tracebacks and string representations in general. The use of the assignment statement eliminates the sole benefit a lambda expression can offer over an explicit def statement (i.e. that it can be embedded inside a larger expression)\n• Derive exceptions from rather than . Direct inheritance from is reserved for exceptions where catching them is almost always the wrong thing to do. Design exception hierarchies based on the distinctions that code catching the exceptions is likely to need, rather than the locations where the exceptions are raised. Aim to answer the question “What went wrong?” programmatically, rather than only stating that “A problem occurred” (see PEP 3151 for an example of this lesson being learned for the builtin exception hierarchy) Class naming conventions apply here, although you should add the suffix “Error” to your exception classes if the exception is an error. Non-error exceptions that are used for non-local flow control or other forms of signaling need no special suffix.\n• Use exception chaining appropriately. should be used to indicate explicit replacement without losing the original traceback. When deliberately replacing an inner exception (using ), ensure that relevant details are transferred to the new exception (such as preserving the attribute name when converting KeyError to AttributeError, or embedding the text of the original exception in the new exception message).\n• When catching exceptions, mention specific exceptions whenever possible instead of using a bare clause: A bare clause will catch SystemExit and KeyboardInterrupt exceptions, making it harder to interrupt a program with Control-C, and can disguise other problems. If you want to catch all exceptions that signal program errors, use (bare except is equivalent to ). A good rule of thumb is to limit use of bare ‘except’ clauses to two cases:\n• If the exception handler will be printing out or logging the traceback; at least the user will be aware that an error has occurred.\n• If the code needs to do some cleanup work, but then lets the exception propagate upwards with . can be a better way to handle this case.\n• When catching operating system errors, prefer the explicit exception hierarchy introduced in Python 3.3 over introspection of values.\n• Additionally, for all try/except clauses, limit the clause to the absolute minimum amount of code necessary. Again, this avoids masking bugs: # Will also catch KeyError raised by handle_value()\n• When a resource is local to a particular section of code, use a statement to ensure it is cleaned up promptly and reliably after use. A try/finally statement is also acceptable.\n• Context managers should be invoked through separate functions or methods whenever they do something other than acquire and release resources: The latter example doesn’t provide any information to indicate that the and methods are doing something other than closing the connection after a transaction. Being explicit is important in this case.\n• Be consistent in return statements. Either all return statements in a function should return an expression, or none of them should. If any return statement returns an expression, any return statements where no value is returned should explicitly state this as , and an explicit return statement should be present at the end of the function (if reachable):\n• Use and instead of string slicing to check for prefixes or suffixes. startswith() and endswith() are cleaner and less error prone:\n• Object type comparisons should always use isinstance() instead of comparing types directly:\n• For sequences, (strings, lists, tuples), use the fact that empty sequences are false:\n• Don’t write string literals that rely on significant trailing whitespace. Such trailing whitespace is visually indistinguishable and some editors (or more recently, reindent.py) will trim them.\n• Don’t compare boolean values to True or False using :\n• Use of the flow control statements / / within the finally suite of a , where the flow control statement would jump outside the finally suite, is discouraged. This is because such statements will implicitly cancel any active exception that is propagating through the finally suite: With the acceptance of PEP 484, the style rules for function annotations have changed.\n• Function annotations should use PEP 484 syntax (there are some formatting recommendations for annotations in the previous section).\n• The experimentation with annotation styles that was recommended previously in this PEP is no longer encouraged.\n• However, outside the stdlib, experiments within the rules of PEP 484 are now encouraged. For example, marking up a large third party library or application with PEP 484 style type annotations, reviewing how easy it was to add those annotations, and observing whether their presence increases code understandability.\n• The Python standard library should be conservative in adopting such annotations, but their use is allowed for new code and for big refactorings.\n• For code that wants to make a different use of function annotations it is recommended to put a comment of the form: near the top of the file; this tells type checkers to ignore all annotations. (More fine-grained ways of disabling complaints from type checkers can be found in PEP 484.)\n• Like linters, type checkers are optional, separate tools. Python interpreters by default should not issue any messages due to type checking and should not alter their behavior based on annotations.\n• Users who don’t want to use type checkers are free to ignore them. However, it is expected that users of third party library packages may want to run type checkers over those packages. For this purpose PEP 484 recommends the use of stub files: .pyi files that are read by the type checker in preference of the corresponding .py files. Stub files can be distributed with a library, or separately (with the library author’s permission) through the typeshed repo . PEP 526 introduced variable annotations. The style recommendations for them are similar to those on function annotations described above:\n• Annotations for module level variables, class and instance variables, and local variables should have a single space after the colon.\n• There should be no space before the colon.\n• If an assignment has a right hand side, then the equality sign should have exactly one space on both sides:\n• Although the PEP 526 is accepted for Python 3.6, the variable annotation syntax is the preferred syntax for stub files on all versions of Python (see PEP 484 for details)."
    },
    {
        "link": "https://builtin.com/data-science/pythonic",
        "document": "Every programming language has its own idioms defined by its users. In the Python community, Pythonic describes code that doesn’t just get the syntax right but uses the language in the way it’s intended to be used. It improves the overall code quality from a maintainability, readability and efficiency perspective. It also creates a pattern of code that allows the entire development team to focus on the true essence of the problem rather than deciphering the code. For a library to be Pythonic is to make it natural for a Python developer to use in their codebase. Remember, code is read more often than it’s written.\n\nBut what does it actually mean by Pythonic? This sounds like a vague concept. How am I going to crack the Python interview by showing them “authentic” Python code? In this article, we’ll examine eight widely promoted Pythonic features that will bring your code to the next level. They are primarily for Python beginners who want to quickly improve their skills, but there are a couple of tips for intermediates and experts, too. I’ll also touch tips for writing a Pythonic library or framework and share some good, free resources for your own self-learning. Here’s what to expect:\n• None What Is PEP8 in Python?\n\nPythonic Code and the Zen of Python\n\nThis article wouldn’t be complete if I didn’t start with “The Zen of Python.” You can find it at any given time by typing . It’s a summary of 19 guiding principles for writing Python code. I would consider it a mindset rather than an actual syntax guideline. Nevertheless, the philosophy in this poem has influenced tons of Python developers globally.\n\nThe examples I’m going to show you later follow this philosophy. Please read it through. I will convey some of the core concepts to you so you are ready for the examples.\n\nMore on PythonAn Introduction to Support Vector Machine (SVM) in Python\n\nThere are three important characteristics for Pythonic code: simplicity, clarity and readability. I put these three characteristics in the same bucket because, taken together, it means writing simple and that everybody understands. You can interpret it in many different ways. In the poem, “flat is better than nested” means don’t have too many sub-categories (modules/packages) in your project. “Sparse is better than dense” means don’t cram too many functions in one line of code, 79-characters rule will break the line anyway. With that in mind, below are some additional tips for writing Pythonic code.\n\n1. Breaking the Rules Can Lead to More Pythonic Code\n\nPython is less strict than other programming languages like in terms of structure. You can write pure procedures like script or object-oriented paradigm like Java, or both. The point is you don’t have to put your code into shoes that aren’t right for you. Adhering to rules too much can result in highly-abstract and boilerplate code.\n\nErrors should not be silently passed. It’s better to fail fast and catch the errors than to silence the error and continue the program. Bugs become harder to debug when they’re far away from the original place, thus raising the exception now instead of later.\n\nAlthough it’s written as a guideline, I feel it’s really hard to achieve this in Python. Python is considered a flexible programming language that’s supported by a large community. This means people can come up with new ideas on the existing solutions everyday. However, the main message it tries to send is that it isn’t worth the effort to learn every possible way. The community has already made some efforts to standardize the formats, which I will talk about in a second.\n\nWhat Is PEP8 in Python?\n\nPython is a flexible language without too many restrictions on the formatting. That’s how PEP8 came into the picture. You are welcome to write Python code any way you want as long as it’s valid. However, using a consistent style makes your code easier to read and maintain. PEP8 provides a rich list of items that are worth checking out.\n\nSome well-known linters like Flake8 and Pylint can spot the issues before you push the code, thus saving review time for your co-workers. Libraries like Black can even automatically fix formatting issues. A common practice is to integrate these tools into your IDE (e.g. vscode) and CI/CD pipeline.\n\n6 Python Features to Know to Write Pythonic Code\n\nPython contains a number of features that allow you to write simpler code. These include:\n\nYou’ve probably seen this question before: “How to swap two bottles of water?” The answer is by getting the third empty bottle. In most languages, you need an extra variable to swap the values.\n\nIn Python, life is easier. You can swap two values like this:\n\nIt looks like magic. The line is called an assignment in which on the right side is an expression, and on the left side is a couple of variables. The expression on the right side is actually a tuple. Don’t believe me? Try this out in a terminal:\n\nParentheses are not really necessary in a tuple.\n\nPython supports multiple assignments, meaning there could be multiple variables on the left side and each of them is assigned to a value in the tuple. This is also called an unpacking assignment. Another example of unpacking assignment is list:\n\nThe outcome would be , .\n\nBy doing so, you can easily, elegantly and naturally assign variables without boilerplate code.\n\nRelated to the previous point, Python allows you to pass multiple arguments to a function without having them defined in the function. An example could be a function that sums up a few numbers, but the size of numbers is unknown.\n\nA naive approach is to create a list variable as the input of the function.\n\nHowever, in Python, you can have an interface without providing a list.\n\nis equal to which is a tuple (an iterable), and the logic inside the function can remain the same.\n\nSimilar to , accepts named arguments and will unpack them into key, value pairs. This is useful when you have a bunch of optional arguments that have different meanings on their own. In this example, a house can be composed of different types of rooms. If you don’t like having too many arguments, you can always provide a dictionary instead.\n\nAnother interesting thing with unpacking is that you can easily merge two lists or a dictionary.\n\nComprehension is cool. That was my first impression of it. Comprehension is used to create data structures in a single instruction instead of multiple operations. A classic example is to convert a for loop into one line of code.\n\nComprehension performs better because it has less operations. There’s no need to execute for every item. In complex functions, comprehension can clearly reduce the line of code and makes it easy for readers to understand. Another approach is to use a Lambda expression. The same expression can be written like this:\n\nBut, don’t force your code to be a one-liner if it creates convoluted expressions. The book Clean Code in Python offers a good example of this. The function receives a list of values and then parses, matches and finally adds them into .\n\nThis is the naive solution with a for loop.\n\nThis is the version with comprehension:\n\nAnother, even more compact version is using the walrus operator. This example pushes the code to an actual one-liner. But this isn’t necessarily better than the second approach.\n\nComprehension can simplify the code and improve the performance, but taking into consideration the readability is also imperative.\n\nThere is more than one way of using underscore in Python. Each type represents different characteristics of the attribute.\n\nBy default, all the attributes of an object are public. There is no private keyword that prevents you from accessing an attribute. Python uses an underscore in front of the function name (e.g. def _build() ) to delimit the interface of an object. Attributes starting with underscore should be respected as private and not be called externally. Private methods/attributes of a class are intended to be called only internally. If the class gets too many internal methods, it could be a sign that this class breaks the single responsibility principle. Perhaps you want to extract some of the responsibilities to other classes.\n\nAnother Pythonic feature with underscore is magic methods. Magic methods are surrounded by double underscores like . Fun fact, according to The Original Hacker’s Dictionary, magic means: “A feature not generally publicized which allows something otherwise impossible.”\n\nThe Python community adopted this term after the Ruby community. Magic methods allow users to have access to the core features of the language to create rich and powerful objects. Being an expert on magic methods levels up your client with clean code. Sounds abstract? Let’s look at an example:\n\nBy overwriting the magic method , the client who uses the class House can compare two houses with , instead of something like .\n\nAnother example is to change the representation of a class. If you print , you will get a Python object with an ID.\n\nWith magic method , the print statement becomes more self-explained. Magic methods hide implementation details from the client, and it gives developers the power to change its original behaviors.\n\nAlthough using underscore is very common, you shouldn’t define attributes with leading double underscores or define your own magic method. It’s not Pythonic and will just confuse your peers.\n\nContext manager is a useful feature that can help you in situations where you want to run things before and after certain actions. Resources management is a good use case for this. You want to make sure files or connections are closed after the processing.\n\nIn Python, you can use two approaches to allocate and release resources:\n\nFor example, I want to open a file, read the content and then close it. This is how it looks like using . statement guarantees that the resources are closed properly no matter what happens.\n\nNonetheless, you can make it more Pythonic using with statement. As you can see, a lot of boilerplate code is eliminated. When you use with statement, you enter a context manager, which means the file will be closed when the block is finished, even if an exception occurred.\n\nHow does that happen? Any context manager consists of two magic methods: and . The with statement will call the method and whatever it returns will be assigned to the variable after as. After the last line of the code in that block finishes, Python will call in which the resource is closed.\n\nLet’s say I want to create a database handler for the backup. In general, we are free to implement a context manager with our own logic. The database should go offline before the backup and restart after the backup. Below are three different ways to implement a context manager.\n\nIn this example, nothing needs to be returned in the sector and this is OK. The sector receives the exceptions raised from the block. You can decide how to handle the exception. If you do nothing, then the exception will be raised to the caller after the resource is properly closed. Or you can handle exceptions in block based on the exception type. But the general rule is not silently swallowing the errors. Another general tip is don’t return True in block unless you know what you are doing. Returning will ignore all the exceptions, and they won’t be raised to the caller.\n\nYou don’t have to create a class each time. Imagine you want to turn existing functions into context managers without refactoring the code too much. In that case, you can make use of the decorator. Decorator is another topic on its own. But what it essentially does is to turn the original function into a generator. Everything before the will be part of , the yielded value becomes the variable after . In this example, nothing needs to be yielded. In general, if you just need a context manager function without preserving too many states, this is a better approach.\n\nThe third option is to create a decorator class. Instead of using the statement, which you still can, you use it as a decorator on top of the function. This has the advantage that you can reuse it as many times as you want by simply applying the decorators to other functions.\n\nIn general, you should at least understand the context manager’s working principle, even if you are a beginner. As an intermediate or expert, get your hands dirty with it and try to create a few context managers from scratch to discover its more nitty gritty.\n\nIn the previous item, I touched upon a concept called generator, which is also a peculiar feature that differentiates Python. Generator is an iterable which has a method defined. But the special thing is, you can only iterate it once because they don’t store all the values in memory.\n\nGenerator is implemented as a function, but instead of using like a regular function, it uses .\n\nYou will see this being used a lot in , as coroutine is essentially a generator. One of its advantages is reducing memory usage, which could have a huge impact on big data sets. Let’s say I want to do some calculations for 1 million records.\n\nThis is how you’d do it before knowing . The problem is you have to store the result of all 1 million records in memory.\n\nThis is an alternative using . The result is only calculated when it’s its turn, saving a lot of memory usage.\n\nGenerator is also the secret behind lazy evaluation.\n\nAs the last line of the Zen of Python, let’s talk about namespace and scope in Python. A namespace is a system in Python to make sure that all the names (attributes, functions, classes, modules) are unique in the program. Namespaces are managed as a dictionary in Python, where the keys are object names and the values are objects themselves.\n\nGenerally speaking, there are four types of namespaces in Python: Python built-in, global, enclosing and local ordered by the hierarchy. This graph is also called the LEGB rule. The interpreter first searches for the name in local, then enclosing, then global, finally in built-in, meaning a name in low level (e.g. Local) will overwrite the same name in higher level (e.g. Enclosing).\n\nHow does this affect our coding? Most of the time, if you just follow LEGB rule, you don’t have to do anything special. Given an example here. What is the output?\n\nAccording to the LEBG rule, the lower level should overwrite the higher level. In function , has a value 3, so calling function will return 3. However, if you just print out as does, you will get 1 because you are currently outside the function and trying to access the global value .\n\nBut if you want to modify a from lower levels, this is possible with keyword. What you need is to add global val at the point where you want to change the global value.\n\nIt’s only a declaration, syntax like is not correct. An alternative is .\n\nLast but not least, I want to show you a Pythonic caveat which you might think is a bug, but is actually a feature. Despite the fact that it’s confusing, it’s still a Pythonic feature that everyone must get along with.\n\nConsider the following example. The function adds food to . is by default an empty list if it isn’t provided. In this example, calling the function twice without providing should expect two lists with one element each.\n\nBut this is what actually happened. The explanation is — the variable is created only once on the definition of the function, which is the first moment this function is called. From that point on, Python interpreter will use the same variable every time the function is called. This means whenever the value is changed, Python will pass it to the next call instead of recreating it with the default value.\n\nThe fix is simple, use as the default sentinel value and assign the actual default value in the body of the function. Because of the namespace and local scope, will be recreated every time it is .\n\nMy rule of thumb is do not mutate mutable default arguments unless you know what you are doing.\n\nMore on PythonGuide to Python Socket Programming\n\nWhat has been discussed so far is all about each individual Python feature. When it comes to writing a Python library or framework, we should also think about how to design a Python API. Besides following common Python idioms, the interface aimed to be used by others is in general smaller and more lightweight than other languages. It’s considered not Pythonic if the library reinvents the wheels too much. Thinking about “only one way to do it,” it’s preferred to install the other third party package into your library.\n\nAnother general tip is, don’t write boilerplate code just for the sake of following design patterns like Java. An example is how to write a singleton in Python.\n\nThere are a lot more to say beyond each item and many other items not included in the article. I hope this can inspire you to revisit your Python code."
    }
]