[
    {
        "link": "https://infosecwriteups.com/game-hacking-101-unleashing-the-power-of-memory-manipulation-2f8b9411674e",
        "document": "Welcome to a comprehensive guide on game hacking, where we explore the fascinating world of gaining an edge in your favorite games through memory manipulation. In this blog post, we’ll demystify the inner workings of game-hacking techniques and provide you with the essential tools, skills, and ethical considerations necessary for successful game-hacking. So, fasten your seatbelts and get ready to dive deep into the captivating realm of game hacking!\n• Unleashing the Power: Exploring the Intricate World of Game Hacking\n• What is Mount and Blade Warband?\n• What is Memory and How to Manipulate Memory3.1 Understanding Memory\n• Behind the Scenes: Understanding Memory Manipulation in Game Hacking\n• Using C++ for Memory Manipulation Code\n• Breaking the Code: Demystifying the Inner Workings of Game Hacking Techniques\n\nUnleashing the Power: Exploring the Intricate World of Game Hacking\n\nIn this section, we delve into the captivating world of game hacking, uncovering its secrets and shedding light on its potential. We’ll explore various techniques and methodologies game hackers employ to gain an edge in their virtual adventures. From memory manipulation to code injection, get ready to unlock a whole new level of understanding as we unravel the complexities and possibilities of game hacking.\n\nWhat is Mount and Blade Warband?\n\nMount and Blade Warband is a popular medieval-themed action role-playing game developed by TaleWorlds Entertainment. Set in a fictional continent called Calradia, the game offers a unique blend of strategic gameplay, immersive combat, and open-world exploration. Players can create their own characters, build armies, engage in epic battles, and even establish their own kingdoms. With its sandbox-style gameplay and a vast array of modding possibilities, Mount and Blade Warband has garnered a dedicated fanbase, making it a captivating choice for those seeking a dynamic and immersive gaming experience in a medieval setting.\n\nWhat is Memory and How to Manipulate Memory\n\nMemory is a fundamental component of a computer system where data and instructions are stored. In the context of game hacking, memory refers to the volatile memory of the game’s process, where important variables, values, and game states reside. By manipulating the memory, we can alter these variables and gain control over various aspects of the game.\n\nVirtual memory is a memory management technique employed by modern operating systems to provide each process with a virtual address space that is independent of the physical memory available in the system. It allows programs to operate as if they have access to a larger amount of memory than what is physically installed. This virtual address space is divided into smaller units called pages, which can be mapped to physical memory or stored on secondary storage devices like hard drives or solid-state drives (SSDs).\n\nWhen a program is executed, it is loaded into the virtual address space, which is typically divided into multiple segments, such as code, data, and stack. The virtual memory system maps the virtual addresses used by the program to physical addresses in the physical memory or secondary storage. This mapping is managed by the operating system’s memory management unit (MMU) in collaboration with the hardware.\n\nVirtual memory allows each process to have its own virtual address space, which can be much larger than the physical memory available in the system. This enables programs to execute and utilize more memory than what is physically installed, improving the system’s ability to run larger and more complex applications.\n\nVirtual memory provides memory isolation between different processes, ensuring that each process has its own dedicated address space. This isolation prevents one process from accessing or modifying the memory of another process, enhancing security and stability. Additionally, virtual memory enables memory protection mechanisms, such as read-only memory regions and no-execution memory areas, to safeguard against unauthorized access and code execution.\n\nVirtual memory allows for efficient memory utilization by storing portions of the program that are not actively being used in secondary storage, such as the hard drive or SSD. This frees up physical memory for processes that require immediate access. The operating system dynamically manages the movement of data between physical memory and secondary storage based on usage patterns, optimizing overall system performance.\n\nVirtual memory facilitates memory sharing between processes. Multiple processes can map the same portion of a file into their virtual address spaces, enabling efficient resource utilization and communication between processes. This is particularly useful for inter-process communication and shared libraries.\n\nVirtual memory, when used effectively, can enhance system performance. However, excessive swapping of data between physical memory and secondary storage, known as thrashing, can lead to performance degradation. To mitigate this, the operating system employs various strategies, such as intelligent page replacement algorithms and pre-fetching techniques, to minimize the frequency of data swaps and optimize memory access.\n\nTo manipulate memory effectively, we need to locate the specific memory addresses associated with the variables we want to modify. Memory addresses act as unique identifiers for each piece of data stored in the game’s memory. We can use memory scanning techniques to search for these addresses based on certain criteria, such as the current value of the variable or its data type.\n\nOnce we’ve identified the memory addresses, we can modify the values stored at those addresses to achieve the desired changes in the game. This can involve increasing resources, adjusting health or stamina levels, or unlocking hidden features. Memory modification techniques typically involve reading the current value from a memory address, performing the necessary calculations or changes, and writing the modified value back to the same address.\n\nIn more complex game-hacking scenarios, we may encounter dynamic memory structures and pointers. Pointers are memory addresses that point to other memory locations. They are commonly used to access dynamically allocated memory or navigate through complex data structures. Understanding pointers and performing dynamic memory analysis allows us to traverse the game’s memory space more effectively and locate the desired variables or structures for manipulation.\n\nBehind the Scenes: Understanding Memory Manipulation in Game Hacking\n\nMemory manipulation lies at the core of many game-hacking techniques. Here, we take you behind the scenes and explore the intricacies of memory manipulation. Discover how to locate and modify specific memory addresses to alter in-game variables, unlock hidden features, and gain an unfair advantage. We’ll cover concepts like static and dynamic memory analysis, pointers, and memory scanning techniques, equipping you with the knowledge to manipulate game memory effectively.\n\nSeveral tools are available to aid in memory manipulation for game hacking. Memory editors or trainers provide a user-friendly interface to scan and modify memory values in real time during gameplay. Debuggers, such as Cheat Engine or OllyDbg, allow for more advanced memory manipulation and dynamic analysis by providing features like breakpoints, memory inspection, and disassembly. These tools simplify the process of locating and manipulating memory addresses, enabling game hackers to make precise and efficient changes.\n\nRemember, game hacking through memory manipulation requires a thorough understanding of the game’s memory structure, programming concepts, and relevant tools. It’s essential to approach memory manipulation responsibly and ethically, ensuring that the changes made enhance your gaming experience without disrupting the intended gameplay or negatively affecting others.\n\nCheat Engine is a popular and powerful memory editing tool widely used in the game hacking community. It allows you to scan, modify, and manipulate memory values in real time, providing you with extensive control over various aspects of a game. Let’s explore how to use Cheat Engine effectively for game hacking.\n\nTo get started, visit the official Cheat Engine website and download the latest version compatible with your operating system. Once downloaded, run the installer and follow the on-screen instructions to install Cheat Engine on your computer.\n\nLaunch Cheat Engine and you’ll be presented with a process selection screen. Click on the computer icon in the top-left corner of the Cheat Engine window to open the process list. Select the process corresponding to the game you want to hack from the list. Make sure the game is running and active before selecting the process.\n\nNow, let’s perform an initial value scan to locate the memory addresses associated with the desired variable in the game. First, identify the variable you want to modify. It could be the player’s health, ammunition count, or any other in-game value you wish to alter.\n\nIn Cheat Engine, enter the current value of the variable in the “Value” field and select the value type from the dropdown menu (e.g., 4 bytes for integer values). Click the “First Scan” button to initiate the scan.\n\nThe initial scan will result in a long list of memory addresses that match the provided value. To narrow down the search, perform actions in the game that cause the variable’s value to change. Once the value has changed, go back to Cheat Engine and enter the new value in the “Value” field.\n\nClick the “Next Scan” button to refine the search. Repeat this process of altering the value in the game and performing subsequent scans until you have a manageable number of memory addresses remaining.\n\nWith the refined list of memory addresses, you can now modify the memory values to affect the gameplay. Double-click on a memory address or select multiple addresses and click the red arrow to add them to the address list at the bottom of the Cheat Engine window.\n\nTo modify a value, double-click on the value column of the selected memory address and enter the desired new value. Once changed, the game will reflect the modified value, giving you an advantage or unlocking new features.\n\nAfter making the desired modifications, you can save your cheat table by clicking the floppy disk icon in the Cheat Engine window. This allows you to reload the cheats whenever you launch the game in the future.\n\nIt’s important to note that game developers actively work on preventing cheating, and many games employ anti-cheat systems. To avoid detection, it’s crucial to exercise caution, use cheat tables responsibly, and stay up-to-date with the latest anti-cheat measures employed by game developers.\n\nCheat Engine is a versatile tool with many advanced features that we haven’t covered in this brief overview. Feel free to explore Cheat Engine’s official documentation and community resources to expand your knowledge and unlock the full potential of this powerful memory editing tool.\n\nRemember to always approach game hacking responsibly, respecting the integrity of the game, and the gaming community.\n\nUsing C++ for Memory Manipulation Code\n\nHere’s a step-by-step guide on how to use Cheat Engine to find out what accesses a particular address:\n\n- Start Cheat Engine and launch the game you want to cheat in.\n\n- In Cheat Engine, click on the “Select a process to open” button (computer icon) in the top-left corner of the Cheat Engine window. It will open a process list.\n\n- Select the process of the game you want to cheat in from the process list and click the “Open” button.\n\n- In the Cheat Engine window, click on the “Scan” button (magnifying glass icon) to open the “Value Scan” window.\n\nIn the “Value” field, enter the memory address you want to investigate and select the appropriate value type (e.g., 4 bytes for integers).\n\n- Click the “First Scan” button. Cheat Engine will search for all instances of the entered value in the game’s memory.\n\n- After the scan is complete, you should see a list of addresses in the left pane of Cheat Engine.\n\n- Double-click on the desired address to add it to the bottom pane.\n\n- Right-click on the added address and select “Find out what accesses this address” from the context menu.\n\n- Cheat Engine will open the “Cheat Engine Disassembler” window, displaying the assembly instructions related to the address you selected.\n\n- You can set breakpoints or step through the code to analyze what accesses or modifies the address.\n\nLet’s break down the given assembly code and explain its functionality:\n\n1. `mov ecx, [ecx + 140f0]`: This instruction moves the value at memory address `[ecx + 140f0]` into the `ecx` register. The `ecx` register is being used as a pointer or address holder.\n\n2. `imul eax, eax, fc8`: This instruction multiplies the value in the `eax` register by the constant value `fc8` (which is in hexadecimal notation). The result is stored back in the `eax` register. This multiplication operation is likely used for some kind of calculation.\n\n3. `mov esi, [ecx + eax + 5d0]`: This instruction moves the value at memory address `[ecx + eax + 5d0]` into the `esi` register. The value being loaded into `esi` is the money value. The memory address is calculated by adding the contents of `ecx` and `eax` registers along with the offset `5d0`.\n\n4. `push 81e208`: This instruction pushes the value `81e208` onto the stack. The purpose of this value is not clear from the given code snippet.\n\n5. `lea ecx, [esp + 18]`: This instruction calculates the effective address of `[esp + 18]` and stores it in the `ecx` register. The `lea` (Load Effective Address) instruction is often used to perform arithmetic calculations to calculate memory addresses.\n\nBased on the provided assembly code, the value of the money is being loaded into the `esi` register from the calculated memory address `[ecx + eax + 5d0]`. The other instructions perform various calculations and memory operations, which may be related to the manipulation of the money value or other game-related operations.\n\nNow, let’s convert the hexadecimal money value, which is represented as “cc0701,” into its decimal equivalent using an online converter like RapidTables’ Hex to Decimal Converter.\n\nConverting “cc0701” from hexadecimal to decimal gives us the value 13371137.\n\nTo manipulate the currency value effectively, we need to determine the `base address` of the game executable, `mb_warband.exe`. Let’s delve deeper into the assembly code and locate the instruction responsible for modifying the `ecx` register because `eax` is 0 so we need ecx:\n\n1. `mov ecx, [ecx + 140f0]`:\n\n This assembly instruction indicates that the `ecx` register is modified using the value at memory address `[ecx + 140f0]`.\n\n2. Further analysis reveals that `ecx` changes at the memory address `mb_warband.exe + 177388` through the instruction `mov ecx, [mb_warband.exe + 4eb300]`.\n\nManipulating the In-Game Currency:\n\nTo manipulate the currency, we need to find the base address of `mb_warband.exe`. Once we have the base address, we can apply offsets to access and modify the desired memory locations.\n\nC++ is a powerful programming language that allows you to create robust and efficient memory manipulation code for game hacking. Let’s explore an example snippet that demonstrates memory manipulation using C++ in the context of Mount and Blade Warband.\n\nThe Windows API is a collection of functions and data structures that allow developers to access and control various aspects of the Windows operating system. It provides an interface for interacting with processes, files, windows, networking, and other system resources. These APIs enable developers to create powerful applications that leverage the capabilities of the underlying operating system.\n\nLet’s examine the provided C++ code snippet and explore its implementation of process handling and snapshot creation using the Windows API:\n\nProcess Handling and Snapshot Creation:\n\n1. The `Memory` constructor takes a `std::string_view` parameter called `processName`, representing the name of the target process.\n\n2. The `::PROCESSENTRY32` structure, named `entry`, is declared and initialized with zero using the `{ }` initializer. This structure contains information about a process, such as its process ID and executable file name.\n\n3. The `dwSize` member of the `entry` structure is set to the size of `::PROCESSENTRY32` to ensure compatibility with the Windows API functions.\n\n4. The `CreateToolhelp32Snapshot` function is called to create a snapshot of the currently running processes. It takes the `TH32CS_SNAPPROCESS` flag as the first parameter, indicating that we want to capture information about processes.\n\n5. The returned snapshot handle is stored in the `snapShot` variable.\n\n6. A `while` loop is used to iterate through each process entry using the `Process32Next` function and the `entry` structure. This function retrieves the next process information from the snapshot.\n\n7. Within the loop, the `compare` function is used to check if the `processName` matches the name of the current process entry (`entry.szExeFile`).\n\n8. If a match is found, the process ID (`entry.th32ProcessID`) is assigned to the `processId` variable.\n\n9. The `OpenProcess` function is called to obtain a handle to the target process using the `PROCESS_ALL_ACCESS` flag, granting full access rights. The resulting handle is stored in the `processHandle` variable.\n\n10. Once the target process is found and the handle is obtained, the loop is exited.\n\n11. Finally, the `CloseHandle` function is called to free the snapshot handle (`snapShot`) and release system resources.\n\nThe core of our approach is a template function called `Read`, which takes a memory address as input and returns the value stored at that address. Let’s dissect the function step by step:\n\n1. Template Declaration:\n\nThe `Read` function is declared as a template function, allowing us to specify the desired type of the value we want to read. The `typename T` syntax introduces the type parameter `T`, which will be resolved at compile-time.\n\n2. Function Signature:\n\nThe function signature is defined as `constexpr const T Read(const std::uintptr_t& address) const noexcept`. Breaking it down:\n\n- `constexpr`: This keyword indicates that the function can be evaluated at compile-time if the necessary conditions are met. It allows for optimization and potentially improves performance.\n\n — `const T`: Specifies that the return type of the function is a constant value of type `T`.\n\n — `const std::uintptr_t& address`: The function takes a reference to a `std::uintptr_t` variable named `address` as its parameter. This parameter represents the memory address we want to read from.\n\n — `const noexcept`: These keywords indicate that the function is marked as const and noexcept, implying that it does not modify the state of the object it belongs to and does not throw exceptions.\n\n3. Variable Initialization:\n\nWithin the function, a variable `value` of type `T` is declared and initialized using zero-initialization. This prepares the variable to store the value read from the memory address.\n\n4. ReadProcessMemory:\n\nThe `ReadProcessMemory` function is called with the following arguments:\n\n- `processHandle`: This variable is assumed to be defined elsewhere and represents the handle to the target process.\n\n — `reinterpret_cast<const void*>(address)`: The memory address is converted to a `const void*` pointer using the `reinterpret_cast` operator. This conversion is necessary because `ReadProcessMemory` expects a pointer to the memory location to read from.\n\n — `&value`: The address of the `value` variable is passed as the destination for the read operation. By providing the address, we enable `ReadProcessMemory` to write the value directly into `value`.\n\n — `sizeof(T)`: The size of the value to read is determined using `sizeof(T)`, where `T` is the type specified when calling the `Read` function. This ensures that the correct number of bytes is read from the process’s memory.\n\n — `NULL`: This argument indicates that no bytes were read. The `ReadProcessMemory` function sets the number of bytes read in this parameter, but since we don’t need that information, we pass `NULL`.\n\n5. Return the Read Value:\n\nAfter the `ReadProcessMemory` call, the `value` variable contains the value read from the specified memory address. The function then returns this value as the result.\n\nThe heart of our approach is a template function named `Write`, which accepts a memory address and a value, and writes the value to the specified memory address. Let’s delve into the function step by step:\n\n1. Template Declaration:\n\nThe `Write` function is declared as a template function, enabling us to specify the type of the value we want to write. The `typename T` syntax introduces the type parameter `T`, which will be resolved at compile-time.\n\n2. Function Signature:\n\nThe function signature is defined as `constexpr void Write(const std::uintptr_t& address, const T& value) const noexcept`. Breaking it down:\n\n- `constexpr`: This keyword indicates that the function can be evaluated at compile-time if the necessary conditions are met. It allows for optimization and potentially improves performance.\n\n — `void`: Specifies that the function does not return any value.\n\n — `const std::uintptr_t& address`: The function takes a reference to a `std::uintptr_t` variable named `address` as the first parameter. This parameter represents the memory address we want to write to.\n\n — `const T& value`: The second parameter is a reference to a `const T` variable named `value`, representing the value we want to write to memory.\n\n — `const noexcept`: These keywords indicate that the function is marked as const and noexcept, indicating that it does not modify the state of the object it belongs to and does not throw exceptions.\n\n3. WriteProcessMemory:\n\nThe `WriteProcessMemory` function is called with the following arguments:\n\n- `processHandle`: This variable is assumed to be defined elsewhere and represents the handle to the target process.\n\n — `reinterpret_cast<void*>(address)`: The memory address is converted to a `void*` pointer using the `reinterpret_cast` operator. This conversion is necessary because `WriteProcessMemory` expects a pointer to the memory location to write to.\n\n — `&value`: The address of the `value` variable is passed as the source for the write operation. By providing the address, we enable `WriteProcessMemory` to read the value directly from `value`.\n\n — `sizeof(T)`: The size of the value to write is determined using `sizeof(T)`, where `T` is the type specified when calling the `Write` function. This ensures that the correct number of bytes is written to the process’s memory.\n\n — `NULL`: This argument indicates that no bytes were written. The `WriteProcessMemory` function sets the number of bytes written in this parameter, but since we don’t need that information, we pass `NULL`.\n\nIn this example, we create an instance of the `Memory` class and specify the game executable “mb_warband.exe”. We retrieve the base address of the game module and perform memory reads and manipulations by adding appropriate offsets to the base address. Finally, we write a new value to a memory address using the `Write` function.\n\nRemember, the provided code is a simplified example for demonstration purposes, and actual memory manipulation code may vary depending on the game and the specific variables you want to modify. It’s essential to understand the game’s memory structure, locate the correct memory addresses, and use caution and responsibility when performing memory manipulations.\n\nAdditionally, it’s crucial to implement a robust and reliable `Memory` class that handles read and write operations appropriately. This might involve using operating system-specific functions or libraries to access and modify the game’s memory.\n\nAlways approach game hacking responsibly, respect the game developers’ efforts, and consider the impact of your actions on the gaming community.\n\nIn the captivating realm of Mount and Blade: Warband, your character’s skills play a crucial role in shaping their destiny. As you embark on epic quests and engage in strategic battles, four key skills will be your steadfast companions: strength, agility, intelligence, and charisma. Each skill represents a unique aspect of your character’s abilities and can greatly influence your gameplay experience. In this blog post, we will explore these essential skills and their impact on your journey through the captivating world of Mount and Blade: Warband.\n\nManipulating character skills requires identifying the memory offsets associated with each skill. These offsets serve as a reference point for Cheat Engine to locate and modify the corresponding values. Here’s a step-by-step guide on finding the offsets for character skills using Cheat Engine:\n\nStart by launching Cheat Engine and selecting the process associated with Mount and Blade: Warband. This will allow Cheat Engine to scan and interact with the game’s memory.\n\nTo begin, open the character screen in the game and take note of the current value for a specific skill. In this example, let’s focus on the “Power” skill. Enter the current value in Cheat Engine and initiate a “First Scan” to search for potential memory addresses associated with the skill.\n\nAfter the initial scan, return to the game and modify the value of the skill. For instance, increase the Power skill by allocating points to it. Then, return to Cheat Engine and perform a subsequent scan, entering the updated value. This process helps narrow down the memory addresses associated with the skill.\n\nIn the provided screenshot, it is evident that the eax register is set to 0, indicating that the edx register becomes instrumental in manipulating character skills. To fully comprehend how the edx register influences skill manipulation, we need to conduct a thorough analysis.\n\nNow, we have discovered a significant breakthrough in our quest for skill manipulation. By understanding the impact of the edx register and its connection to the instruction `mov edx, [mb_warband.exe + 43b300]`, we can focus on finding the base address.\n\nContinue refining the search by repeating steps 2 and 3, altering the value of the skill and performing subsequent scans until only a few memory addresses remain. These remaining addresses are likely to be the offsets for the Power skill.\n\nOur focus will be on two skills as examples: Strength and Agility. The offset for the Strength skill is 0x270, while the offset for the Agility skill is 0x274. The offset represents the memory address where the skill’s value is stored. So we can find the intelligence and charisma offsets too.\n\nOnce you have identified the offset for a skill, you can modify its value in Cheat Engine. Double-click on the offset, enter the desired value for the skill, and see the changes reflected in the game.\n\nBy using Cheat Engine to manipulate character skills, you can enhance your gameplay experience in Mount and Blade: Warband. Whether you want to experiment with different character builds, speed up character progression, or simply have some fun, Cheat Engine provides a versatile tool for customization.\n\nBreaking the Code: Demystifying the Inner Workings of Game Hacking Techniques\n\nIn this game-hacking series, we peel back the layers of game-hacking techniques, unraveling the underlying principles and code that make it all possible. Through clear explanations and illustrative examples, we demystify the intricate workings of various game-hacking methods, such as memory manipulation, code injection, and dynamic analysis. Prepare to gain a deeper understanding of how game hacks operate and the mechanisms behind their functionality.\n\nWhile game hacking can provide thrilling benefits, it’s crucial to understand the ethical boundaries. In this section, we explore the responsible approach to game hacking, discussing the importance of fair play, respect for game developers, and the impact of hacks on the gaming community. We’ll delve into ethical considerations, encouraging readers to use their hacking skills responsibly and consider the implications of their actions.\n\nImplementing an effective anti-cheat system in C++ to prevent memory hacking involves multiple steps. Here’s a general outline of the process:\n\n1. Secure Code Execution: Write your game code with security in mind, using techniques like code obfuscation, encryption, and runtime integrity checks to make it harder for hackers to tamper with the game’s memory.\n\n2. Memory Scanning: Periodically scan the game’s memory for suspicious patterns or modifications. Compare the expected values with the actual values in memory to detect any unauthorized changes.\n\n3. Anti-Debugging Techniques: Implement anti-debugging measures to detect and deter debugging tools commonly used by hackers. This can include checks for debugger presence, breakpoints, or code modification during runtime.\n\n4. Code Signature Verification: Employ techniques to verify the integrity of critical game code or functions, ensuring that they have not been modified or replaced by malicious code.\n\n5. Input Validation: Validate and sanitize user input to prevent potential exploits through buffer overflows, injection attacks, or other memory manipulation techniques.\n\n6. Secure Communication: Protect network communication between the game client and server using encryption and authentication protocols to prevent tampering or unauthorized access.\n\n7. Behavior Analysis: Monitor player behavior for suspicious activities or patterns that may indicate cheating, such as abnormal movement speed or impossible actions. Use heuristics and statistical analysis to identify potential cheaters.\n\n8. Ban and Reporting System: Implement a system for detecting and banning cheaters. Provide players with a means to report suspicious behavior, allowing for manual investigation and subsequent action against confirmed cheaters.\n\nStay tuned for upcoming episodes where we will explore the development of an advanced anti-cheat system written in C++, aiming to safeguard against memory hacking and ensure fair gameplay"
    },
    {
        "link": "https://cheatengine.org",
        "document": "Trouble installing/running Cheat Engine? Check out the known github issue here on how to solve it, or join the cheat engine patreon\n\nDo you wish to mod your games, but you do not like cheating? Then try Runtime Modifier it's not cheating if you call it modding!\n\nRead before download: You must be 18 years or older, or deemed an adult, to install Cheat Engine. Cheat engine is for private and educational purposes only. Before you attach Cheat Engine to a process, please make sure that you are not violating the EULA/TOS of the specific game/application. cheatengine.org does not condone the illegal use of Cheat Engine\n\nFebruary 12 2025:Cheat Engine 7.6 Released for public: (for most people, some might still get 7.5)\n\nJanuary 20 2025:Cheat Engine 7.6 Released for Windows for Patreons (Mac and public will be here soon):\n\nI'm glad to announce the release of Cheat Engine 7.6. It has taken a while but I did manage to cram in a few neat fixes and improvements\n\n My patreon members can get it here\n\n \n\n (The public release is here now as well) \n\n \n\n Please reports bugs and give suggestions to improve Cheat Engine so next version can be even greater!\n\n \n\n Changes:\n\n\n\nFebruary 8 2023:Cheat Engine 7.5 Released for Windows for Patreons (Mac and public will be here soon):\n\nI'm glad to announce the release of Cheat Engine 7.5 which has some really neat improvements over 7.4\n\n My patreon members can get it here\n\n \n\n (The public release will be here any day now. Waiting for the advertisers / network owners to accept it) \n\n \n\n Please reports bugs and give suggestions to improve Cheat Engine so next version can be even greater!\n\n \n\n Changes:\n\n from patreon 7.4.3 to public 7.5:\n\nJanuary 18 2022:Cheat Engine 7.4 Released for Windows and Mac for everyone:\n\nJanuary 2 2022:Cheat Engine 7.4 Released for Windows and Mac for Patreons (public will be here soon):\n\nHappy 2022. To start of this year good here's the official release of Cheat Engine 7.4 \n\n My patreon members can get it here\n\n (The public release will be here any day now. Waiting for the advertisers / network owners to accept it) \n\n \n\n Please reports bugs and give suggestions to improve Cheat Engine.\n\n \n\n Additions and changes:"
    },
    {
        "link": "https://github.com/aydinnyunus/MemoryBlade",
        "document": "Welcome to our comprehensive guide on game hacking, where we explore the fascinating world of gaining an edge in your favorite games through memory manipulation. In this blog post, we'll take you on a journey from a game hacking novice to a skilled pro, demystifying the inner workings of game hacking techniques and providing you with the essential tools, skills, and ethical considerations necessary for successful game hacking. So, fasten your seatbelts and get ready to dive deep into the captivating realm of game hacking!\n• Unleashing the Power: Exploring the Intricate World of Game Hacking\n• What is Mount and Blade Warband?\n• What is Memory and How to Manipulate Memory\n• Behind the Scenes: Understanding Memory Manipulation in Game Hacking\n• Using C++ for Memory Manipulation Code\n• Breaking the Code: Demystifying the Inner Workings of Game Hacking Techniques\n\nIn this section, we delve into the captivating world of game hacking, uncovering its secrets and shedding light on its potential. We'll explore various techniques and methodologies game hackers employ to gain an edge in their virtual adventures. From memory manipulation to code injection, get ready to unlock a whole new level of understanding as we unravel the complexities and possibilities of game hacking.\n\nMount and Blade Warband is a popular medieval-themed action role-playing game developed by TaleWorlds Entertainment. Set in a fictional continent called Calradia, the game offers a unique blend of strategic gameplay, immersive combat, and open-world exploration. Players can create their own character, build armies, engage in epic battles, and even establish their own kingdoms. With its sandbox-style gameplay and a vast array of modding possibilities, Mount and Blade Warband has garnered a dedicated fanbase, making it a captivating choice for those seeking a dynamic and immersive gaming experience in a medieval setting.\n\nMemory is a fundamental component of a computer system where data and instructions are stored. In the context of game hacking, memory refers to the volatile memory of the game's process, where important variables, values, and game states reside. By manipulating the memory, we can alter these variables and gain control over various aspects of the game.\n\nVirtual memory is a memory management technique employed by modern operating systems to provide each process with a virtual address space that is independent of the physical memory available in the system. It allows programs to operate as if they have access to a larger amount of memory than what is physically installed. This virtual address space is divided into smaller units called pages, which can be mapped to physical memory or stored on secondary storage devices like hard drives or solid-state drives (SSDs).\n\nWhen a program is executed, it is loaded into the virtual address space, which is typically divided into multiple segments, such as code, data, and stack. The virtual memory system maps the virtual addresses used by the program to physical addresses in the physical memory or secondary storage. This mapping is managed by the operating system's memory management unit (MMU) in collaboration with the hardware.\n\nVirtual memory allows each process to have its own virtual address space, which can be much larger than the physical memory available in the system. This enables programs to execute and utilize more memory than what is physically installed, improving the system's ability to run larger and more complex applications.\n\nVirtual memory provides memory isolation between different processes, ensuring that each process has its own dedicated address space. This isolation prevents one process from accessing or modifying the memory of another process, enhancing security and stability. Additionally, virtual memory enables memory protection mechanisms, such as read-only memory regions and no-execution memory areas, to safeguard against unauthorized access and code execution.\n\nVirtual memory allows for efficient memory utilization by storing portions of the program that are not actively being used in secondary storage, such as the hard drive or SSD. This frees up physical memory for processes that require immediate access. The operating system dynamically manages the movement of data between physical memory and secondary storage based on usage patterns, optimizing overall system performance.\n\nVirtual memory facilitates memory sharing between processes. Multiple processes can map the same portion of a file into their virtual address spaces, enabling efficient resource utilization and communication between processes. This is particularly useful for inter-process communication and shared libraries.\n\nVirtual memory, when used effectively, can enhance system performance. However, excessive swapping of data between physical memory and secondary storage, known as thrashing, can lead to performance degradation. To mitigate this, the operating system employs various strategies, such as intelligent page replacement algorithms and pre-fetching techniques, to minimize the frequency of data swaps and optimize memory access.\n\nTo manipulate memory effectively, we need to locate the specific memory addresses associated with the variables we want to modify. Memory addresses act as unique identifiers for each piece of data stored in the game's memory. We can use memory scanning techniques to search for these addresses based on certain criteria, such as the current value of the variable or its data type.\n\nOnce we've identified the memory addresses, we can modify the values stored at those addresses to achieve the desired changes in the game. This can involve increasing resources, adjusting health or stamina levels, or unlocking hidden features. Memory modification techniques typically involve reading the current value from a memory address, performing the necessary calculations or changes, and writing the modified value back to the same address.\n\nIn more complex game-hacking scenarios, we may encounter dynamic memory structures and pointers. Pointers are memory addresses that point to other memory locations. They are commonly used to access dynamically allocated memory or navigate through complex data structures. Understanding pointers and performing dynamic memory analysis allows us to traverse the game's memory space more effectively and locate the desired variables or structures for manipulation.\n\nMemory manipulation lies at the core of many game hacking techniques. Here, we take you behind the scenes and explore the intricacies of memory manipulation. Discover how to locate and modify specific memory addresses to alter in-game variables, unlock hidden features, and gain an unfair advantage. We'll cover concepts like static and dynamic memory analysis, pointers, and memory scanning techniques, equipping you with the knowledge to manipulate game memory effectively.\n\nSeveral tools are available to aid in memory manipulation for game hacking. Memory editors or trainers provide a user-friendly interface to scan and modify memory values in real time during gameplay. Debuggers, such as Cheat Engine or OllyDbg, allow for more advanced memory manipulation and dynamic analysis by providing features like breakpoints, memory inspection, and disassembly. These tools simplify the process of locating and manipulating memory addresses, enabling game hackers to make precise and efficient changes.\n\nRemember, game hacking through memory manipulation requires a thorough understanding of the game's memory structure, programming concepts, and relevant tools. It's essential to approach memory manipulation responsibly and ethically, ensuring that the changes made enhance your gaming experience without disrupting the intended gameplay or negatively affecting others.\n\nCheat Engine is a popular and powerful memory editing tool widely used in the game hacking community. It allows you to scan, modify, and manipulate memory values in real time, providing you with extensive control over various aspects of a game. Let's explore how to use Cheat Engine effectively for game hacking.\n\nTo get started, visit the official Cheat Engine website and download the latest version compatible with your operating system. Once downloaded, run the installer and follow the on-screen instructions to install Cheat Engine on your computer.\n\nLaunch Cheat Engine and you'll be presented with a process selection screen. Click on the computer icon in the top-left corner of the Cheat Engine window to open the process list. Select the process corresponding to the game you want to hack from the list. Make sure the game is running and active before selecting the process.\n\nNow, let's perform an initial value scan to locate the memory addresses associated with the desired variable in the game. First, identify the variable you want to modify. It could be the player's health, ammunition count, or any other in-game value you wish to alter.\n\nIn Cheat Engine, enter the current value of the variable in the \"Value\" field and select the value type from the dropdown menu (e.g., 4 bytes for integer values). Click the \"First Scan\" button to initiate the scan.\n\nThe initial scan will result in a long list of memory addresses that match the provided value. To narrow down the search, perform actions in the game that cause the variable's value to change. Once the value has changed, go back to Cheat Engine and enter the new value in the \"Value\" field.\n\nClick the \"Next Scan\" button to refine the search. Repeat this process of altering the value in the game and performing subsequent scans until you have a manageable number of memory addresses remaining.\n\nWith the refined list of memory addresses, you can now modify the memory values to affect the gameplay. Double-click on a memory address or select multiple addresses and click the red arrow to add them to the address list at the bottom of the Cheat Engine window.\n\nTo modify a value, double-click on the value column of the selected memory address and enter the desired new value. Once changed, the game will reflect the modified value, giving you an advantage or unlocking new features.\n\nAfter making the desired modifications, you can save your cheat table by clicking the floppy disk icon in the Cheat Engine window. This allows you to reload the cheats whenever you launch the game in the future.\n\nIt's important to note that game developers actively work on preventing cheating, and many games employ anti-cheat systems. To avoid detection, it's crucial to exercise caution, use cheat tables responsibly, and stay up-to-date with the latest anti-cheat measures employed by game developers.\n\nCheat Engine is a versatile tool with many advanced features that we haven't covered in this brief overview. Feel free to explore Cheat Engine's official documentation and community resources to expand your knowledge and unlock the full potential of this powerful memory editing tool.\n\nRemember to always approach game hacking responsibly, respecting the integrity of the game, and the gaming community.\n\nHere's a step-by-step guide on how to use Cheat Engine to find out what accesses a particular address:\n• Start Cheat Engine and launch the game you want to cheat in.\n• In Cheat Engine, click on the \"Select a process to open\" button (computer icon) in the top-left corner of the Cheat Engine window. It will open a process list.\n• Select the process of the game you want to cheat in from the process list and click the \"Open\" button.\n• In the Cheat Engine window, click on the \"Scan\" button (magnifying glass icon) to open the \"Value Scan\" window. In the \"Value\" field, enter the memory address you want to investigate and select the appropriate value type (e.g., 4 bytes for integers).\n• Click the \"First Scan\" button. Cheat Engine will search for all instances of the entered value in the game's memory.\n• After the scan is complete, you should see a list of addresses in the left pane of Cheat Engine.\n• Double-click on the desired address to add it to the bottom pane.\n• Right-click on the added address and select \"Find out what accesses this address\" from the context menu.\n• Cheat Engine will open the \"Cheat Engine Disassembler\" window, displaying the assembly instructions related to the address you selected.\n• You can set breakpoints or step through the code to analyze what accesses or modifies the address.\n\nLet's break down the given assembly code and explain its functionality:\n• : This instruction moves the value at memory address into the register. The register is being used as a pointer or address holder.\n• : This instruction multiplies the value in the register by the constant value (which is in hexadecimal notation). The result is stored back in the register. This multiplication operation is likely used for some kind of calculation.\n• : This instruction moves the value at memory address into the register. The value being loaded into is the money value. The memory address is calculated by adding the contents of and registers along with the offset .\n• : This instruction pushes the value onto the stack. The purpose of this value is not clear from the given code snippet.\n• : This instruction calculates the effective address of and stores it in the register. The (Load Effective Address) instruction is often used to perform arithmetic calculations to calculate memory addresses.\n\nBased on the provided assembly code, the value of the money is being loaded into the register from the calculated memory address . The other instructions perform various calculations and memory operations, which may be related to the manipulation of the money value or other game-related operations.\n\nNow, let's convert the hexadecimal money value, which is represented as \"cc0701,\" into its decimal equivalent using an online converter like RapidTables' Hex to Decimal Converter.\n\nConverting \"cc0701\" from hexadecimal to decimal gives us the value 13371137.\n\nTo manipulate the currency value effectively, we need to determine the of the game executable, . Let's delve deeper into the assembly code and locate the instruction responsible for modifying the register because is 0 so we need ecx:\n• : This assembly instruction indicates that the register is modified using the value at memory address .\n• Further analysis reveals that changes at the memory address through the instruction .\n\nManipulating the In-Game Currency: To manipulate the currency, we need to find the base address of . Once we have the base address, we can apply offsets to access and modify the desired memory locations.\n\nC++ is a powerful programming language that allows you to create robust and efficient memory manipulation code for game hacking. Let's explore an example snippet that demonstrates memory manipulation using C++ in the context of Mount and Blade Warband.\n\nThe Windows API is a collection of functions and data structures that allow developers to access and control various aspects of the Windows operating system. It provides an interface for interacting with processes, files, windows, networking, and other system resources. These APIs enable developers to create powerful applications that leverage the capabilities of the underlying operating system.\n\nLet's examine the provided C++ code snippet and explore its implementation of process handling and snapshot creation using the Windows API:\n• The constructor takes a parameter called , representing the name of the target process.\n• The structure, named , is declared and initialized with zero using the initializer. This structure contains information about a process, such as its process ID and executable file name.\n• The member of the structure is set to the size of to ensure compatibility with the Windows API functions.\n• The function is called to create a snapshot of the currently running processes. It takes the flag as the first parameter, indicating that we want to capture information about processes.\n• The returned snapshot handle is stored in the variable.\n• A loop is used to iterate through each process entry using the function and the structure. This function retrieves the next process information from the snapshot.\n• Within the loop, the function is used to check if the matches the name of the current process entry ( ).\n• If a match is found, the process ID ( ) is assigned to the variable.\n• The function is called to obtain a handle to the target process using the flag, granting full access rights. The resulting handle is stored in the variable.\n• Once the target process is found and the handle is obtained, the loop is exited.\n• Finally, the function is called to free the snapshot handle ( ) and release system resources.\n\nThe core of our approach is a template function called , which takes a memory address as input and returns the value stored at that address. Let's dissect the function step by step:\n• Template Declaration: The function is declared as a template function, allowing us to specify the desired type of the value we want to read. The syntax introduces the type parameter , which will be resolved at compile-time.\n• Function Signature: The function signature is defined as . Breaking it down:\n• : This keyword indicates that the function can be evaluated at compile-time if the necessary conditions are met. It allows for optimization and potentially improves performance.\n• : Specifies that the return type of the function is a constant value of type .\n• : The function takes a reference to a variable named as its parameter. This parameter represents the memory address we want to read from.\n• : These keywords indicate that the function is marked as const and noexcept, implying that it does not modify the state of the object it belongs to and does not throw exceptions.\n• Variable Initialization: Within the function, a variable of type is declared and initialized using zero-initialization. This prepares the variable to store the value read from the memory address.\n• ReadProcessMemory: The function is called with the following arguments:\n• : This variable is assumed to be defined elsewhere and represents the handle to the target process.\n• : The memory address is converted to a pointer using the operator. This conversion is necessary because expects a pointer to the memory location to read from.\n• : The address of the variable is passed as the destination for the read operation. By providing the address, we enable to write the value directly into .\n• : The size of the value to read is determined using , where is the type specified when calling the function. This ensures that the correct number of bytes is read from the process's memory.\n• : This argument indicates that no bytes were read. The function sets the number of bytes read in this parameter, but since we don't need that information, we pass .\n• Return the Read Value: After the call, the variable contains the value read from the specified memory address. The function then returns this value as the result.\n\nThe heart of our approach is a template function named , which accepts a memory address and a value, and writes the value to the specified memory address. Let's delve into the function step by step:\n• Template Declaration: The function is declared as a template function, enabling us to specify the type of the value we want to write. The syntax introduces the type parameter , which will be resolved at compile-time.\n• Function Signature: The function signature is defined as . Breaking it down:\n• : This keyword indicates that the function can be evaluated at compile-time if the necessary conditions are met. It allows for optimization and potentially improves performance.\n• : Specifies that the function does not return any value.\n• : The function takes a reference to a variable named as the first parameter. This parameter represents the memory address we want to write to.\n• : The second parameter is a reference to a variable named , representing the value we want to write to memory.\n• : These keywords indicate that the function is marked as const and noexcept, indicating that it does not modify the state of the object it belongs to and does not throw exceptions.\n• WriteProcessMemory: The function is called with the following arguments:\n• : This variable is assumed to be defined elsewhere and represents the handle to the target process.\n• : The memory address is converted to a pointer using the operator. This conversion is necessary because expects a pointer to the memory location to write to.\n• : The address of the variable is passed as the source for the write operation. By providing the address, we enable to read the value directly from .\n• : The size of the value to write is determined using , where is the type specified when calling the function. This ensures that the correct number of bytes is written to the process's memory.\n• : This argument indicates that no bytes were written. The function sets the number of bytes written in this parameter, but since we don't need that information, we pass .\n\nIn this example, we create an instance of the class and specify the game executable \"mb_warband.exe\". We retrieve the base address of the game module and perform memory reads and manipulations by adding appropriate offsets to the base address. Finally, we write a new value to a memory address using the function.\n\nRemember, the provided code is a simplified example for demonstration purposes, and actual memory manipulation code may vary depending on the game and the specific variables you want to modify. It's essential to understand the game's memory structure, locate the correct memory addresses, and use caution and responsibility when performing memory manipulations.\n\nAdditionally, it's crucial to implement a robust and reliable class that handles read and write operations appropriately. This might involve using operating system-specific functions or libraries to access and modify the game's memory.\n\nAlways approach game hacking responsibly, respect the game developers' efforts, and consider the impact of your actions on the gaming community.\n\nIn the captivating realm of Mount and Blade: Warband, your character's skills play a crucial role in shaping their destiny. As you embark on epic quests and engage in strategic battles, four key skills will be your steadfast companions: strength, agility, intelligence, and charisma. Each skill represents a unique aspect of your character's abilities and can greatly influence your gameplay experience. In this blog post, we will explore these essential skills and their impact on your journey through the captivating world of Mount and Blade: Warband.\n\nManipulating character skills requires identifying the memory offsets associated with each skill. These offsets serve as a reference point for Cheat Engine to locate and modify the corresponding values. Here's a step-by-step guide on finding the offsets for character skills using Cheat Engine:\n\nStart by launching Cheat Engine and selecting the process associated with Mount and Blade: Warband. This will allow Cheat Engine to scan and interact with the game's memory.\n\nTo begin, open the character screen in the game and take note of the current value for a specific skill. In this example, let's focus on the \"Power\" skill. Enter the current value in Cheat Engine and initiate a \"First Scan\" to search for potential memory addresses associated with the skill.\n\nAfter the initial scan, return to the game and modify the value of the skill. For instance, increase the Power skill by allocating points to it. Then, return to Cheat Engine and perform a subsequent scan, entering the updated value. This process helps narrow down the memory addresses associated with the skill.\n\nIn the provided screenshot, it is evident that the eax register is set to 0, indicating that the edx register becomes instrumental in manipulating character skills. To fully comprehend how the edx register influences skill manipulation, we need to conduct a thorough analysis.\n\nNow, we have discovered a significant breakthrough in our quest for skill manipulation. By understanding the impact of the edx register and its connection to the instruction , we can focus on finding the base address.\n\nContinue refining the search by repeating steps 2 and 3, altering the value of the skill and performing subsequent scans until only a few memory addresses remain. These remaining addresses are likely to be the offsets for the Power skill.\n\nOur focus will be on two skills as examples: Strength and Agility. The offset for the Strength skill is 0x270, while the offset for the Agility skill is 0x274. The offset represents the memory address where the skill's value is stored. So we can find the intelligence and charisma offsets too.\n\nOnce you have identified the offset for a skill, you can modify its value in Cheat Engine. Double-click on the offset, enter the desired value for the skill, and see the changes reflected in the game.\n\nBy using Cheat Engine to manipulate character skills, you can enhance your gameplay experience in Mount and Blade: Warband. Whether you want to experiment with different character builds, speed up character progression, or simply have some fun, Cheat Engine provides a versatile tool for customization.\n\nIn this game hacking series, we peel back the layers of game hacking techniques, unraveling the underlying principles and code that make it all possible. Through clear explanations and illustrative examples, we demystify the intricate workings of various game hacking methods, such as memory manipulation, code injection, and dynamic analysis. Prepare to gain a deeper understanding of how game hacks operate and the mechanisms behind their functionality.\n\nWhile game hacking can provide thrilling benefits, it's crucial to understand the ethical boundaries. In this section, we explore the responsible approach to game hacking, discussing the importance of fair play, respect for game developers, and the impact of hacks on the gaming community. We'll delve into ethical considerations, encouraging readers to use their hacking skills responsibly and consider the implications of their actions.\n\nOne of the greatest challenges in game hacking is evading detection by anti-cheat systems. In this segment, we examine the tactics employed by anti-cheat systems and explore countermeasures to protect your hacks from detection. From understanding the detection mechanisms to implementing stealthy techniques, we'll equip you with the knowledge and strategies to safeguard your hacks and ensure a seamless gaming experience."
    },
    {
        "link": "https://blog.devgenius.io/game-hacking-101-unleashing-the-power-of-memory-manipulation-7fa4e53058fa",
        "document": "Welcome to a comprehensive guide on game hacking, where we explore the fascinating world of gaining an edge in your favorite games through memory manipulation. In this blog post, we’ll demystify the inner workings of game-hacking techniques and provide you with the essential tools, skills, and ethical considerations necessary for successful game-hacking. So, fasten your seatbelts and get ready to dive deep into the captivating realm of game hacking!\n• Unleashing the Power: Exploring the Intricate World of Game Hacking\n• What is Mount and Blade Warband?\n• What is Memory and How to Manipulate Memory3.1 Understanding Memory\n• Behind the Scenes: Understanding Memory Manipulation in Game Hacking\n• Using C++ for Memory Manipulation Code\n• Breaking the Code: Demystifying the Inner Workings of Game Hacking Techniques\n\nUnleashing the Power: Exploring the Intricate World of Game Hacking\n\nIn this section, we delve into the captivating world of game hacking, uncovering its secrets and shedding light on its potential. We’ll explore various techniques and methodologies game hackers employ to gain an edge in their virtual adventures. From memory manipulation to code injection, get ready to unlock a whole new level of understanding as we unravel the complexities and possibilities of game hacking.\n\nWhat is Mount and Blade Warband?\n\nMount and Blade Warband is a popular medieval-themed action role-playing game developed by TaleWorlds Entertainment. Set in a fictional continent called Calradia, the game offers a unique blend of strategic gameplay, immersive combat, and open-world exploration. Players can create their own characters, build armies, engage in epic battles, and even establish their own kingdoms. With its sandbox-style gameplay and a vast array of modding possibilities, Mount and Blade Warband has garnered a dedicated fanbase, making it a captivating choice for those seeking a dynamic and immersive gaming experience in a medieval setting.\n\nWhat is Memory and How to Manipulate Memory\n\nMemory is a fundamental component of a computer system where data and instructions are stored. In the context of game hacking, memory refers to the volatile memory of the game’s process, where important variables, values, and game states reside. By manipulating the memory, we can alter these variables and gain control over various aspects of the game.\n\nVirtual memory is a memory management technique employed by modern operating systems to provide each process with a virtual address space that is independent of the physical memory available in the system. It allows programs to operate as if they have access to a larger amount of memory than what is physically installed. This virtual address space is divided into smaller units called pages, which can be mapped to physical memory or stored on secondary storage devices like hard drives or solid-state drives (SSDs).\n\nWhen a program is executed, it is loaded into the virtual address space, which is typically divided into multiple segments, such as code, data, and stack. The virtual memory system maps the virtual addresses used by the program to physical addresses in the physical memory or secondary storage. This mapping is managed by the operating system’s memory management unit (MMU) in collaboration with the hardware.\n\nVirtual memory allows each process to have its own virtual address space, which can be much larger than the physical memory available in the system. This enables programs to execute and utilize more memory than what is physically installed, improving the system’s ability to run larger and more complex applications.\n\nVirtual memory provides memory isolation between different processes, ensuring that each process has its own dedicated address space. This isolation prevents one process from accessing or modifying the memory of another process, enhancing security and stability. Additionally, virtual memory enables memory protection mechanisms, such as read-only memory regions and no-execution memory areas, to safeguard against unauthorized access and code execution.\n\nVirtual memory allows for efficient memory utilization by storing portions of the program that are not actively being used in secondary storage, such as the hard drive or SSD. This frees up physical memory for processes that require immediate access. The operating system dynamically manages the movement of data between physical memory and secondary storage based on usage patterns, optimizing overall system performance.\n\nVirtual memory facilitates memory sharing between processes. Multiple processes can map the same portion of a file into their virtual address spaces, enabling efficient resource utilization and communication between processes. This is particularly useful for inter-process communication and shared libraries.\n\nVirtual memory, when used effectively, can enhance system performance. However, excessive swapping of data between physical memory and secondary storage, known as thrashing, can lead to performance degradation. To mitigate this, the operating system employs various strategies, such as intelligent page replacement algorithms and pre-fetching techniques, to minimize the frequency of data swaps and optimize memory access.\n\nTo manipulate memory effectively, we need to locate the specific memory addresses associated with the variables we want to modify. Memory addresses act as unique identifiers for each piece of data stored in the game’s memory. We can use memory scanning techniques to search for these addresses based on certain criteria, such as the current value of the variable or its data type.\n\nOnce we’ve identified the memory addresses, we can modify the values stored at those addresses to achieve the desired changes in the game. This can involve increasing resources, adjusting health or stamina levels, or unlocking hidden features. Memory modification techniques typically involve reading the current value from a memory address, performing the necessary calculations or changes, and writing the modified value back to the same address.\n\nIn more complex game-hacking scenarios, we may encounter dynamic memory structures and pointers. Pointers are memory addresses that point to other memory locations. They are commonly used to access dynamically allocated memory or navigate through complex data structures. Understanding pointers and performing dynamic memory analysis allows us to traverse the game’s memory space more effectively and locate the desired variables or structures for manipulation.\n\nBehind the Scenes: Understanding Memory Manipulation in Game Hacking\n\nMemory manipulation lies at the core of many game-hacking techniques. Here, we take you behind the scenes and explore the intricacies of memory manipulation. Discover how to locate and modify specific memory addresses to alter in-game variables, unlock hidden features, and gain an unfair advantage. We’ll cover concepts like static and dynamic memory analysis, pointers, and memory scanning techniques, equipping you with the knowledge to manipulate game memory effectively.\n\nSeveral tools are available to aid in memory manipulation for game hacking. Memory editors or trainers provide a user-friendly interface to scan and modify memory values in real time during gameplay. Debuggers, such as Cheat Engine or OllyDbg, allow for more advanced memory manipulation and dynamic analysis by providing features like breakpoints, memory inspection, and disassembly. These tools simplify the process of locating and manipulating memory addresses, enabling game hackers to make precise and efficient changes.\n\nRemember, game hacking through memory manipulation requires a thorough understanding of the game’s memory structure, programming concepts, and relevant tools. It’s essential to approach memory manipulation responsibly and ethically, ensuring that the changes made enhance your gaming experience without disrupting the intended gameplay or negatively affecting others.\n\nCheat Engine is a popular and powerful memory editing tool widely used in the game hacking community. It allows you to scan, modify, and manipulate memory values in real time, providing you with extensive control over various aspects of a game. Let’s explore how to use Cheat Engine effectively for game hacking.\n\nTo get started, visit the official Cheat Engine website and download the latest version compatible with your operating system. Once downloaded, run the installer and follow the on-screen instructions to install Cheat Engine on your computer.\n\nLaunch Cheat Engine and you’ll be presented with a process selection screen. Click on the computer icon in the top-left corner of the Cheat Engine window to open the process list. Select the process corresponding to the game you want to hack from the list. Make sure the game is running and active before selecting the process.\n\nNow, let’s perform an initial value scan to locate the memory addresses associated with the desired variable in the game. First, identify the variable you want to modify. It could be the player’s health, ammunition count, or any other in-game value you wish to alter.\n\nIn Cheat Engine, enter the current value of the variable in the “Value” field and select the value type from the dropdown menu (e.g., 4 bytes for integer values). Click the “First Scan” button to initiate the scan.\n\nThe initial scan will result in a long list of memory addresses that match the provided value. To narrow down the search, perform actions in the game that cause the variable’s value to change. Once the value has changed, go back to Cheat Engine and enter the new value in the “Value” field.\n\nClick the “Next Scan” button to refine the search. Repeat this process of altering the value in the game and performing subsequent scans until you have a manageable number of memory addresses remaining.\n\nWith the refined list of memory addresses, you can now modify the memory values to affect the gameplay. Double-click on a memory address or select multiple addresses and click the red arrow to add them to the address list at the bottom of the Cheat Engine window.\n\nTo modify a value, double-click on the value column of the selected memory address and enter the desired new value. Once changed, the game will reflect the modified value, giving you an advantage or unlocking new features.\n\nAfter making the desired modifications, you can save your cheat table by clicking the floppy disk icon in the Cheat Engine window. This allows you to reload the cheats whenever you launch the game in the future.\n\nIt’s important to note that game developers actively work on preventing cheating, and many games employ anti-cheat systems. To avoid detection, it’s crucial to exercise caution, use cheat tables responsibly, and stay up-to-date with the latest anti-cheat measures employed by game developers.\n\nCheat Engine is a versatile tool with many advanced features that we haven’t covered in this brief overview. Feel free to explore Cheat Engine’s official documentation and community resources to expand your knowledge and unlock the full potential of this powerful memory editing tool.\n\nRemember to always approach game hacking responsibly, respecting the integrity of the game, and the gaming community.\n\nUsing C++ for Memory Manipulation Code\n\nHere’s a step-by-step guide on how to use Cheat Engine to find out what accesses a particular address:\n\n- Start Cheat Engine and launch the game you want to cheat in.\n\n- In Cheat Engine, click on the “Select a process to open” button (computer icon) in the top-left corner of the Cheat Engine window. It will open a process list.\n\n- Select the process of the game you want to cheat in from the process list and click the “Open” button.\n\n- In the Cheat Engine window, click on the “Scan” button (magnifying glass icon) to open the “Value Scan” window.\n\nIn the “Value” field, enter the memory address you want to investigate and select the appropriate value type (e.g., 4 bytes for integers).\n\n- Click the “First Scan” button. Cheat Engine will search for all instances of the entered value in the game’s memory.\n\n- After the scan is complete, you should see a list of addresses in the left pane of Cheat Engine.\n\n- Double-click on the desired address to add it to the bottom pane.\n\n- Right-click on the added address and select “Find out what accesses this address” from the context menu.\n\n- Cheat Engine will open the “Cheat Engine Disassembler” window, displaying the assembly instructions related to the address you selected.\n\n- You can set breakpoints or step through the code to analyze what accesses or modifies the address.\n\nLet’s break down the given assembly code and explain its functionality:\n\n1. `mov ecx, [ecx + 140f0]`: This instruction moves the value at memory address `[ecx + 140f0]` into the `ecx` register. The `ecx` register is being used as a pointer or address holder.\n\n2. `imul eax, eax, fc8`: This instruction multiplies the value in the `eax` register by the constant value `fc8` (which is in hexadecimal notation). The result is stored back in the `eax` register. This multiplication operation is likely used for some kind of calculation.\n\n3. `mov esi, [ecx + eax + 5d0]`: This instruction moves the value at memory address `[ecx + eax + 5d0]` into the `esi` register. The value being loaded into `esi` is the money value. The memory address is calculated by adding the contents of `ecx` and `eax` registers along with the offset `5d0`.\n\n4. `push 81e208`: This instruction pushes the value `81e208` onto the stack. The purpose of this value is not clear from the given code snippet.\n\n5. `lea ecx, [esp + 18]`: This instruction calculates the effective address of `[esp + 18]` and stores it in the `ecx` register. The `lea` (Load Effective Address) instruction is often used to perform arithmetic calculations to calculate memory addresses.\n\nBased on the provided assembly code, the value of the money is being loaded into the `esi` register from the calculated memory address `[ecx + eax + 5d0]`. The other instructions perform various calculations and memory operations, which may be related to the manipulation of the money value or other game-related operations.\n\nNow, let’s convert the hexadecimal money value, which is represented as “cc0701,” into its decimal equivalent using an online converter like RapidTables’ Hex to Decimal Converter.\n\nConverting “cc0701” from hexadecimal to decimal gives us the value 13371137.\n\nTo manipulate the currency value effectively, we need to determine the `base address` of the game executable, `mb_warband.exe`. Let’s delve deeper into the assembly code and locate the instruction responsible for modifying the `ecx` register because `eax` is 0 so we need ecx:\n\n1. `mov ecx, [ecx + 140f0]`:\n\n This assembly instruction indicates that the `ecx` register is modified using the value at memory address `[ecx + 140f0]`.\n\n2. Further analysis reveals that `ecx` changes at the memory address `mb_warband.exe + 177388` through the instruction `mov ecx, [mb_warband.exe + 4eb300]`.\n\nManipulating the In-Game Currency:\n\nTo manipulate the currency, we need to find the base address of `mb_warband.exe`. Once we have the base address, we can apply offsets to access and modify the desired memory locations.\n\nC++ is a powerful programming language that allows you to create robust and efficient memory manipulation code for game hacking. Let’s explore an example snippet that demonstrates memory manipulation using C++ in the context of Mount and Blade Warband.\n\nThe Windows API is a collection of functions and data structures that allow developers to access and control various aspects of the Windows operating system. It provides an interface for interacting with processes, files, windows, networking, and other system resources. These APIs enable developers to create powerful applications that leverage the capabilities of the underlying operating system.\n\nLet’s examine the provided C++ code snippet and explore its implementation of process handling and snapshot creation using the Windows API:\n\nProcess Handling and Snapshot Creation:\n\n1. The `Memory` constructor takes a `std::string_view` parameter called `processName`, representing the name of the target process.\n\n2. The `::PROCESSENTRY32` structure, named `entry`, is declared and initialized with zero using the `{ }` initializer. This structure contains information about a process, such as its process ID and executable file name.\n\n3. The `dwSize` member of the `entry` structure is set to the size of `::PROCESSENTRY32` to ensure compatibility with the Windows API functions.\n\n4. The `CreateToolhelp32Snapshot` function is called to create a snapshot of the currently running processes. It takes the `TH32CS_SNAPPROCESS` flag as the first parameter, indicating that we want to capture information about processes.\n\n5. The returned snapshot handle is stored in the `snapShot` variable.\n\n6. A `while` loop is used to iterate through each process entry using the `Process32Next` function and the `entry` structure. This function retrieves the next process information from the snapshot.\n\n7. Within the loop, the `compare` function is used to check if the `processName` matches the name of the current process entry (`entry.szExeFile`).\n\n8. If a match is found, the process ID (`entry.th32ProcessID`) is assigned to the `processId` variable.\n\n9. The `OpenProcess` function is called to obtain a handle to the target process using the `PROCESS_ALL_ACCESS` flag, granting full access rights. The resulting handle is stored in the `processHandle` variable.\n\n10. Once the target process is found and the handle is obtained, the loop is exited.\n\n11. Finally, the `CloseHandle` function is called to free the snapshot handle (`snapShot`) and release system resources.\n\nThe core of our approach is a template function called `Read`, which takes a memory address as input and returns the value stored at that address. Let’s dissect the function step by step:\n\n1. Template Declaration:\n\nThe `Read` function is declared as a template function, allowing us to specify the desired type of the value we want to read. The `typename T` syntax introduces the type parameter `T`, which will be resolved at compile-time.\n\n2. Function Signature:\n\nThe function signature is defined as `constexpr const T Read(const std::uintptr_t& address) const noexcept`. Breaking it down:\n\n- `constexpr`: This keyword indicates that the function can be evaluated at compile-time if the necessary conditions are met. It allows for optimization and potentially improves performance.\n\n — `const T`: Specifies that the return type of the function is a constant value of type `T`.\n\n — `const std::uintptr_t& address`: The function takes a reference to a `std::uintptr_t` variable named `address` as its parameter. This parameter represents the memory address we want to read from.\n\n — `const noexcept`: These keywords indicate that the function is marked as const and noexcept, implying that it does not modify the state of the object it belongs to and does not throw exceptions.\n\n3. Variable Initialization:\n\nWithin the function, a variable `value` of type `T` is declared and initialized using zero-initialization. This prepares the variable to store the value read from the memory address.\n\n4. ReadProcessMemory:\n\nThe `ReadProcessMemory` function is called with the following arguments:\n\n- `processHandle`: This variable is assumed to be defined elsewhere and represents the handle to the target process.\n\n — `reinterpret_cast<const void*>(address)`: The memory address is converted to a `const void*` pointer using the `reinterpret_cast` operator. This conversion is necessary because `ReadProcessMemory` expects a pointer to the memory location to read from.\n\n — `&value`: The address of the `value` variable is passed as the destination for the read operation. By providing the address, we enable `ReadProcessMemory` to write the value directly into `value`.\n\n — `sizeof(T)`: The size of the value to read is determined using `sizeof(T)`, where `T` is the type specified when calling the `Read` function. This ensures that the correct number of bytes is read from the process’s memory.\n\n — `NULL`: This argument indicates that no bytes were read. The `ReadProcessMemory` function sets the number of bytes read in this parameter, but since we don’t need that information, we pass `NULL`.\n\n5. Return the Read Value:\n\nAfter the `ReadProcessMemory` call, the `value` variable contains the value read from the specified memory address. The function then returns this value as the result.\n\nThe heart of our approach is a template function named `Write`, which accepts a memory address and a value, and writes the value to the specified memory address. Let’s delve into the function step by step:\n\n1. Template Declaration:\n\nThe `Write` function is declared as a template function, enabling us to specify the type of the value we want to write. The `typename T` syntax introduces the type parameter `T`, which will be resolved at compile-time.\n\n2. Function Signature:\n\nThe function signature is defined as `constexpr void Write(const std::uintptr_t& address, const T& value) const noexcept`. Breaking it down:\n\n- `constexpr`: This keyword indicates that the function can be evaluated at compile-time if the necessary conditions are met. It allows for optimization and potentially improves performance.\n\n — `void`: Specifies that the function does not return any value.\n\n — `const std::uintptr_t& address`: The function takes a reference to a `std::uintptr_t` variable named `address` as the first parameter. This parameter represents the memory address we want to write to.\n\n — `const T& value`: The second parameter is a reference to a `const T` variable named `value`, representing the value we want to write to memory.\n\n — `const noexcept`: These keywords indicate that the function is marked as const and noexcept, indicating that it does not modify the state of the object it belongs to and does not throw exceptions.\n\n3. WriteProcessMemory:\n\nThe `WriteProcessMemory` function is called with the following arguments:\n\n- `processHandle`: This variable is assumed to be defined elsewhere and represents the handle to the target process.\n\n — `reinterpret_cast<void*>(address)`: The memory address is converted to a `void*` pointer using the `reinterpret_cast` operator. This conversion is necessary because `WriteProcessMemory` expects a pointer to the memory location to write to.\n\n — `&value`: The address of the `value` variable is passed as the source for the write operation. By providing the address, we enable `WriteProcessMemory` to read the value directly from `value`.\n\n — `sizeof(T)`: The size of the value to write is determined using `sizeof(T)`, where `T` is the type specified when calling the `Write` function. This ensures that the correct number of bytes is written to the process’s memory.\n\n — `NULL`: This argument indicates that no bytes were written. The `WriteProcessMemory` function sets the number of bytes written in this parameter, but since we don’t need that information, we pass `NULL`.\n\nIn this example, we create an instance of the `Memory` class and specify the game executable “mb_warband.exe”. We retrieve the base address of the game module and perform memory reads and manipulations by adding appropriate offsets to the base address. Finally, we write a new value to a memory address using the `Write` function.\n\nRemember, the provided code is a simplified example for demonstration purposes, and actual memory manipulation code may vary depending on the game and the specific variables you want to modify. It’s essential to understand the game’s memory structure, locate the correct memory addresses, and use caution and responsibility when performing memory manipulations.\n\nAdditionally, it’s crucial to implement a robust and reliable `Memory` class that handles read and write operations appropriately. This might involve using operating system-specific functions or libraries to access and modify the game’s memory.\n\nAlways approach game hacking responsibly, respect the game developers’ efforts, and consider the impact of your actions on the gaming community.\n\nIn the captivating realm of Mount and Blade: Warband, your character’s skills play a crucial role in shaping their destiny. As you embark on epic quests and engage in strategic battles, four key skills will be your steadfast companions: strength, agility, intelligence, and charisma. Each skill represents a unique aspect of your character’s abilities and can greatly influence your gameplay experience. In this blog post, we will explore these essential skills and their impact on your journey through the captivating world of Mount and Blade: Warband.\n\nManipulating character skills requires identifying the memory offsets associated with each skill. These offsets serve as a reference point for Cheat Engine to locate and modify the corresponding values. Here’s a step-by-step guide on finding the offsets for character skills using Cheat Engine:\n\nStart by launching Cheat Engine and selecting the process associated with Mount and Blade: Warband. This will allow Cheat Engine to scan and interact with the game’s memory.\n\nTo begin, open the character screen in the game and take note of the current value for a specific skill. In this example, let’s focus on the “Power” skill. Enter the current value in Cheat Engine and initiate a “First Scan” to search for potential memory addresses associated with the skill.\n\nAfter the initial scan, return to the game and modify the value of the skill. For instance, increase the Power skill by allocating points to it. Then, return to Cheat Engine and perform a subsequent scan, entering the updated value. This process helps narrow down the memory addresses associated with the skill.\n\nIn the provided screenshot, it is evident that the eax register is set to 0, indicating that the edx register becomes instrumental in manipulating character skills. To fully comprehend how the edx register influences skill manipulation, we need to conduct a thorough analysis.\n\nNow, we have discovered a significant breakthrough in our quest for skill manipulation. By understanding the impact of the edx register and its connection to the instruction `mov edx, [mb_warband.exe + 43b300]`, we can focus on finding the base address.\n\nContinue refining the search by repeating steps 2 and 3, altering the value of the skill and performing subsequent scans until only a few memory addresses remain. These remaining addresses are likely to be the offsets for the Power skill.\n\nOur focus will be on two skills as examples: Strength and Agility. The offset for the Strength skill is 0x270, while the offset for the Agility skill is 0x274. The offset represents the memory address where the skill’s value is stored. So we can find the intelligence and charisma offsets too.\n\nOnce you have identified the offset for a skill, you can modify its value in Cheat Engine. Double-click on the offset, enter the desired value for the skill, and see the changes reflected in the game.\n\nBy using Cheat Engine to manipulate character skills, you can enhance your gameplay experience in Mount and Blade: Warband. Whether you want to experiment with different character builds, speed up character progression, or simply have some fun, Cheat Engine provides a versatile tool for customization.\n\nBreaking the Code: Demystifying the Inner Workings of Game Hacking Techniques\n\nIn this game-hacking series, we peel back the layers of game-hacking techniques, unraveling the underlying principles and code that make it all possible. Through clear explanations and illustrative examples, we demystify the intricate workings of various game-hacking methods, such as memory manipulation, code injection, and dynamic analysis. Prepare to gain a deeper understanding of how game hacks operate and the mechanisms behind their functionality.\n\nWhile game hacking can provide thrilling benefits, it’s crucial to understand the ethical boundaries. In this section, we explore the responsible approach to game hacking, discussing the importance of fair play, respect for game developers, and the impact of hacks on the gaming community. We’ll delve into ethical considerations, encouraging readers to use their hacking skills responsibly and consider the implications of their actions.\n\nImplementing an effective anti-cheat system in C++ to prevent memory hacking involves multiple steps. Here’s a general outline of the process:\n\n1. Secure Code Execution: Write your game code with security in mind, using techniques like code obfuscation, encryption, and runtime integrity checks to make it harder for hackers to tamper with the game’s memory.\n\n2. Memory Scanning: Periodically scan the game’s memory for suspicious patterns or modifications. Compare the expected values with the actual values in memory to detect any unauthorized changes.\n\n3. Anti-Debugging Techniques: Implement anti-debugging measures to detect and deter debugging tools commonly used by hackers. This can include checks for debugger presence, breakpoints, or code modification during runtime.\n\n4. Code Signature Verification: Employ techniques to verify the integrity of critical game code or functions, ensuring that they have not been modified or replaced by malicious code.\n\n5. Input Validation: Validate and sanitize user input to prevent potential exploits through buffer overflows, injection attacks, or other memory manipulation techniques.\n\n6. Secure Communication: Protect network communication between the game client and server using encryption and authentication protocols to prevent tampering or unauthorized access.\n\n7. Behavior Analysis: Monitor player behavior for suspicious activities or patterns that may indicate cheating, such as abnormal movement speed or impossible actions. Use heuristics and statistical analysis to identify potential cheaters.\n\n8. Ban and Reporting System: Implement a system for detecting and banning cheaters. Provide players with a means to report suspicious behavior, allowing for manual investigation and subsequent action against confirmed cheaters.\n\nStay tuned for upcoming episodes where we will explore the development of an advanced anti-cheat system written in C++, aiming to safeguard against memory hacking and ensure fair gameplay"
    },
    {
        "link": "https://forum.cheatengine.org/viewtopic.php?t=570083",
        "document": "So if you're here, it's likely because you've been trying out new cheat tables for new games, and \n\n instead of addresses and pointers you see scripts everywhere. You check these scripts, think \n\n \"WTF do these ancient runes mean\", but marvel at the black magic they hold (or some crap like that). \n\n I'm going to teach you what these scripts do, why they're used so often nowadays, and how to make \n\n them yourself. First, I think that a brief history of the stages/techniques used in game hacking \n\n is in order so you know we do this the way we do. \n\n \n\n This tutorial assumes that you have at least a basic understanding of cheat engine. \n\n If you don't know how to find and edit stuff in games at all yet, go somewhere else first. \n\n \n\n \n\n \n\n \n\n The first and most basic type of game hacking most people are familiar with is static RAM editing. \n\n You find an address and whatever tool you're using keeps resetting it to a certain value very quickly \n\n to \"lock\" it there. The Gameshark for the Gameboy and the Action Replay for the SNES worked like this. \n\n These codes were generally short and simple. For example the code to always have the cape in \n\n Super Mario World for the SNES is 7E001902. \n\n \n\n We can break this down into...\n• 7E: Bank of memory to work on. 7E is the RAM bank.\n• 0019: The memory address to edit. This is the SNES so there's not that many possible addresses in RAM!\n• 02: The value to set it to (in this case the cape). The basic idea of just having a single address to edit every time applies on the PC too, but is usually only \n\n useful in very old and/or custom-engine games. Cave Story and Nethack, for example, are PC games that \n\n still use static addresses for the player data. The main downside to this is that if a game doesn't \n\n load it's data into the exact same places each run, then you'll have to rescan every time you play. \n\n \n\n \n\n \n\n \n\n As systems and games got more complex, they stopped holding the same things in the exact same memory \n\n addresses every single time in order to account for varying numbers of players and entities and monsters \n\n and rules in effect. Since the memory locations were shifting around, pointers are used to keep track \n\n of what exists where. This is what most people will be familiar with as more advanced cheating, because \n\n you can use certain methods/tools to find out the pointer paths and then lock/change the final address. \n\n \n\n But even though pointers tend to work after a game has been restarted multiple times, this shares a \n\n downside with just locking the address manually (since that's all that's being done). On the PC, tools \n\n like Cheat Engine can't really \"lock\" an address. What they do is inject/overwrite it with your chosen \n\n value multiple times a second. In many cases this is enough, but if, for example, your character only \n\n has 100 max HP and you take an attack of 115 damage... in most cases you still die. This is because \n\n the game's logic is running much faster than CE can reset the value, so the game realizes that you \n\n died in that split second. Obviously something other than RAM locking is needed to get around this. \n\n \n\n \n\n \n\n \n\n So, given the above example, how would somebody stop dying if they're dealt more damage than they have \n\n health? The code that deals damage in the first place should be edited. This was the idea behind \n\n the old Game Genie devices for the NES, SNES, and such. They edited the ROM reads instead of RAM, \n\n to change some data around to make the game run differently. After all, you don't need to keep \n\n finding and locking your money amount if you edit the game's code so that your money is never \n\n taken away when you buy something! \n\n \n\n \"But Rydian, if this is so much more powerful, why did all the Game Genie codes suck ass? If they could make \n\n us invincible or anything they wanted why did they keep making each apple picked up worth 5 apples instead?\" \n\n This boils down to two big flaws in the original Game Genie's idea and implementation.\n• Without any way to debug/trace what games were doing, making your own codes as a customer is a \n\n shot in the dark. Edit random bytes and see what happens, keep the few positive things as codes, \n\n discard all the crashy/negative things.\n• The Game Genie's codes were encrypted, and it wasn't until a few years later that people would \n\n publicly make converters to allow you to tell the Game Genie to edit arbitrary ROM reads. These two things combined made it so that the only good/targeted codes were from Galoob itself \n\n (or whoever was doing the distribution of the device at the time). Thankfully that's not the case with \n\n the PC. There's all sorts of debugging, tracing, and logging tools available, in fact Cheat Engine \n\n actually has it's own debugger and tons of other tools (that are hidden by default) that are \n\n specifically geared towards making cheats. \n\n \n\n \n\n \n\n \n\n For this example I'm going to be using the original version of Cave Story for the PC (which is freeware, \n\n not to be confused with Cave Story+ or the Wii/3DS releases). \n\n Download it here, and there's a link to the translation patch too. \n\n \n\n The first thing you'll want to do is to start a new game, and get used to the awkward-as-hell controls. \n\n Then you want to launch+attach Cheat Engine and do the usual bit with scanning for the RAM, in this \n\n case we want to find health. Change it to make sure you found the right value. \n\n \n\n \n\n \n\n Next you want to right-click that table entry, and choose \"Find What Writes To This Address\". \n\n That will bring up a new window that logs any bits of code that change that address. Go back to the \n\n game and get hit or something a few times and you'll see one or more entries show up in the list. \n\n \n\n \n\n \n\n Once you see a few things show up, hit the \"stop\" button so the logging stops. Click the entry that \n\n comes up when you get hit (each different type of effect on the health will usually have it's own \n\n entry and they're numbered by how often they happened), then click that \"Show Disassembler\" button \n\n on the right to open up the Memory Viewer window, which is where the magic is. This is a big window, \n\n but right now we're only concerned with the top half of it. Scroll up a bit so the targeted line \n\n is more or less centered. \n\n \n\n \n\n \n\n What we see right there is the actual assembly that makes up the running game. It doesn't matter \n\n which language a game is written in or which engine it runs on. Anything that runs is assembly \n\n one way or the other. For example you don't run C++ code itself, you put C++ code through the \n\n compiler, which turns it into assembly (more or less). Even interpreted languages like Javascript \n\n get turned into assembly when they run. So if you can edit assembly in RAM, then you can edit any \n\n program's behavior, no matter what language it was written in. \n\n \n\n At this point, I suggest you go look at some basic x86 assembly tutorials, or at least a newbie \n\n instruction list, but I will run over some of the very basics you need to know in this instance. \n\n \n\n That \"mov\" instruction that's highlighted is what takes the new calculated health amount and sets \n\n our health address to it. If you look at the bottom of the assembly view, you'll see \"copy memory\", \n\n which describes the \"mov\" command. Any time you have an operation/line highlighted, that little \n\n box will show you what it stands for. \n\n \n\n The syntax is generally (operation) (destination),(source). So for the mov command, it's moving \n\n whatever's in register cx (part of ecx) into memory address 0049E6CC. Sort of like \n\n $currenthealth = $calculatedhealth; in a more modern language. \n\n And the command above that is a subtraction. \n\n \n\n You'll also see things like \"eax\" and \"ecx\" everywhere. These are the x86 registers. You can, \n\n for this type of work, think of a register as the simplest form of a variable there is. It's \n\n actually physical memory housed inside the CPU itself. \n\n \n\n \n\n \n\n So in this case we can see that there's math done to determine the damage, then the game moves \n\n the new health into the current health. So if we want to stop taking damage, we can edit either \n\n of these. If we remove the subtraction, your health is never lowered. If we remove the mov right \n\n after it, then even though the game determines what your new health be, it never \n\n becomes that value. In this case we'll focus on the subtraction. \n\n \n\n The simplest kind of edit we can do is to make one of the operations simply not happen. To do this, \n\n we generally replace the bytes that make up that operation with the bytes that stand for \"do nothing\". \n\n In x86 the \"no operation\" (nop or noop) byte is 90 (in hex). Cheat Engine, being geared for game \n\n cheating, actually has a quick function to do that, which we'll use just for example. \n\n \n\n Right-click the \"sub\" line (right above the targeted mov line) and choose \"Replace With Code That \n\n Does Nothing\". Hit enter for the default on the prompt, and you should see the change. \n\n \n\n \n\n \n\n And when you go back into the game, you shouldn't take any damage from enemies anymore. You can have \n\n 3 max HP and take 5 damage from the spikes in the starting area, and nothing happens. Yay! \n\n \n\n But that was just a quick example to show you the context. You'll rarely be doing that normally, \n\n except for testing. So in the Memory Viewer window again, right-click the edited code and choose \n\n \"Restore with original code\", because we're going to do something else. \n\n \n\n \n\n \n\n \n\n So instead of right-clicking that \"sub\" line and using a built-in function to remove it, we want to write \n\n a script that focuses on that section of code. Highlight the \"sub\" command and his CTRL+A (or go to \n\n Tools - Auto Assemble). In the new window that comes up, go to Template - Cheat Table Framework Code and \n\n then Template - Code Injection (and hit okay on the default). \n\n \n\n This should make Cheat Engine fill in the Auto Assembly window with something that looks like this, \n\n which is the basic framework you need to customize the game's code. I've marked out, in a basic sense, \n\n which each segment does. \n\n \n\n \n\n \n\n So you can see, for this example, the \"originalcode\" section is what we want to edit. It put in the \n\n original code for us automatically, but we can do whatever we want. For now though, what you want to \n\n do is hit File - Assign To Current Cheat Table, then close the existing window. This is important, \n\n do NOT hit the \"execute\" button. Assign it to the cheat table, then re-open it from there, and the \n\n \"execute\" button will be replaced with \"ok\" (which just saves the script). \n\n \n\n Now that the script is saved on the cheat table and we can edit it on and off (by toggling/locking it \n\n like a normal cheat), feel free to replace or modify the original code. For example change the \"sub\" \n\n into an \"add\", or simply comment it out (//thisisacomment), and when you enable the script Cheat Engine \n\n will interpret what you typed (assuming no syntax errors) and make whatever edits you intend for it to. \n\n \n\n The way this works is that Cheat Engine will overwrite the original code with a jump to some new code, \n\n and then include whatever code you want, which then jumps back at the end. This means that you can \n\n insert new code as well, so if you wanted to change the math or logic being done, you generally have \n\n enough room to write a small little assembly routine there to do whatever, so have fun with it. \n\n \n\n \n\n \n\n \n\n \n\n Note: this section assumes that you've messed around with assembly editing in Cheat Engine enough \n\n to have a basic grasp of the concept and know what you're doing. \n\n \n\n So making a script that edits the game code is a great way to get around moving memory addresses. \n\n You don't need to scan for pointers or watch changing addresses when you edit the game code to control \n\n things. But... newer games (especially ones written in .NET and such) don't even load their code in \n\n the same order each time! So we need a way to find where certain code snippets are, and then \n\n reference/edit them. We do this with AOBscans. AOB stands for \"Array of Bytes\", and is just a list of \n\n values in RAM. \n\n \n\n You write a script in the Auto Assembler window (CTRL+A in the memory browser, add it to the table \n\n like before and edit it from there), and here's a very basic AOB script for editing some assembly. \n\n \n\n So if you're here, it's likely because you've been trying out new cheat tables for new games, andinstead of addresses and pointers you see scripts everywhere. You check these scripts, think\"WTF do these ancient runes mean\", but marvel at the black magic they hold (or some crap like that).I'm going to teach you what these scripts do, why they're used so often nowadays, and how to makethem yourself. First, I think that a brief history of the stages/techniques used in game hackingis in order so you knowwe do this the way we do.This tutorial assumes that you have at least a basic understanding of cheat engine.If you don't know how to find and edit stuff in games at all yet, go somewhere else first.The first and most basic type of game hacking most people are familiar with is static RAM editing.You find an address and whatever tool you're using keeps resetting it to a certain value very quicklyto \"lock\" it there. The Gameshark for the Gameboy and the Action Replay for the SNES worked like this.These codes were generally short and simple. For example the code to always have the cape inSuper Mario World for the SNES is 7E001902.We can break this down into...The basic idea of just having a single address to edit every time applies on the PC too, but is usually onlyuseful in very old and/or custom-engine games. Cave Story and Nethack, for example, are PC games thatstill use static addresses for the player data. The main downside to this is that if a game doesn'tload it's data into the exact same places each run, then you'll have to rescan every time you play.As systems and games got more complex, they stopped holding the same things in the exact same memoryaddresses every single time in order to account for varying numbers of players and entities and monstersand rules in effect. Since the memory locations were shifting around, pointers are used to keep trackof what exists where. This is what most people will be familiar with as more advanced cheating, becauseyou can use certain methods/tools to find out the pointer paths and then lock/change the final address.But even though pointers tend to work after a game has been restarted multiple times, this shares adownside with just locking the address manually (since that's all that's being done). On the PC, toolslike Cheat Engine can't really \"lock\" an address. What they do is inject/overwrite it with your chosenvalue multiple times a second. In many cases this is enough, but if, for example, your character onlyhas 100 max HP and you take an attack of 115 damage... in most cases you still die. This is becausethe game's logic is running much faster than CE can reset the value, so the game realizes that youdied in that split second. Obviously something other than RAM locking is needed to get around this.So, given the above example, how would somebody stop dying if they're dealt more damage than they havehealth? The code that deals damage in the first place should be edited. This was the idea behindthe old Game Genie devices for the NES, SNES, and such. They edited the ROM reads instead of RAM,to change some data around to make the game run differently. After all, you don't need to keepfinding and locking your money amount if you edit the game's code so that your money is nevertaken away when you buy something!This boils down to two big flaws in the original Game Genie's idea and implementation.These two things combined made it so that the only good/targeted codes were from Galoob itself(or whoever was doing the distribution of the device at the time). Thankfully that's not the case withthe PC. There's all sorts of debugging, tracing, and logging tools available, in fact Cheat Engineactually has it's own debugger and tons of other tools (that are hidden by default) that arespecifically geared towards making cheats.For this example I'm going to be using the original version of Cave Story for the PC (which is freeware,not to be confused with Cave Story+ or the Wii/3DS releases).The first thing you'll want to do is to start a new game, and get used to the awkward-as-hell controls.Then you want to launch+attach Cheat Engine and do the usual bit with scanning for the RAM, in thiscase we want to find health. Change it to make sure you found the right value.Next you want to right-click that table entry, and choose \"Find What Writes To This Address\".That will bring up a new window that logs any bits of code that change that address. Go back to thegame and get hit or something a few times and you'll see one or more entries show up in the list.Once you see a few things show up, hit the \"stop\" button so the logging stops. Click the entry thatcomes up when you get hit (each different type of effect on the health will usually have it's ownentry and they're numbered by how often they happened), then click that \"Show Disassembler\" buttonon the right to open up the Memory Viewer window, which is where the magic is. This is a big window,but right now we're only concerned with the top half of it. Scroll up a bit so the targeted lineis more or less centered.What we see right there is the actual assembly that makes up the running game. It doesn't matterwhich language a game is written in or which engine it runs on. Anything that runs is assemblyone way or the other. For example you don't run C++ code itself, you put C++ code through thecompiler, which turns it into assembly (more or less). Even interpreted languages like Javascriptget turned into assembly when they run. So if you can edit assembly in RAM, then you can edit anyprogram's behavior, no matter what language it was written in.At this point, I suggest you go look at some basic x86 assembly tutorials, or at least a newbieinstruction list, but I will run over some of the very basics you need to know in this instance.That \"mov\" instruction that's highlighted is what takes the new calculated health amount and setsour health address to it. If you look at the bottom of the assembly view, you'll see \"copy memory\",which describes the \"mov\" command. Any time you have an operation/line highlighted, that littlebox will show you what it stands for.The syntax is generally (operation) (destination),(source). So for the mov command, it's movingwhatever's in register cx (part of ecx) into memory address 0049E6CC. Sort of like$currenthealth = $calculatedhealth; in a more modern language.And the command above that is a subtraction.You'll also see things like \"eax\" and \"ecx\" everywhere. These are the x86 registers. You can,for this type of work, think of a register as the simplest form of a variable there is. It'sactually physical memory housed inside the CPU itself.So in this case we can see that there's math done to determine the damage, then the game movesthe new health into the current health. So if we want to stop taking damage, we can edit eitherof these. If we remove the subtraction, your health is never lowered. If we remove the mov rightafter it, then even though the game determines what your new healthbe, it neverbecomes that value. In this case we'll focus on the subtraction.The simplest kind of edit we can do is to make one of the operations simply not happen. To do this,we generally replace the bytes that make up that operation with the bytes that stand for \"do nothing\".In x86 the \"no operation\" (nop or noop) byte is 90 (in hex). Cheat Engine, being geared for gamecheating, actually has a quick function to do that, which we'll use just for example.Right-click the \"sub\" line (right above the targeted mov line) and choose \"Replace With Code ThatDoes Nothing\". Hit enter for the default on the prompt, and you should see the change.And when you go back into the game, you shouldn't take any damage from enemies anymore. You can have3 max HP and take 5 damage from the spikes in the starting area, and nothing happens. Yay!But that was just a quick example to show you the context. You'll rarely be doing that normally,except for testing. So in the Memory Viewer window again, right-click the edited code and choose\"Restore with original code\", because we're going to do something else.So instead of right-clicking that \"sub\" line and using a built-in function to remove it, we want to writea script that focuses on that section of code. Highlight the \"sub\" command and his CTRL+A (or go toTools - Auto Assemble). In the new window that comes up, go to Template - Cheat Table Framework Code andthen Template - Code Injection (and hit okay on the default).This should make Cheat Engine fill in the Auto Assembly window with something that looks like this,which is the basic framework you need to customize the game's code. I've marked out, in a basic sense,which each segment does.So you can see, for this example, the \"originalcode\" section is what we want to edit. It put in theoriginal code for us automatically, but we can do whatever we want. For now though, what you want todo is hit File - Assign To Current Cheat Table, then close the existing window.Assign it to the cheat table, then re-open it from there, and the\"execute\" button will be replaced with \"ok\" (which just saves the script).Now that the script is saved on the cheat table and we can edit it on and off (by toggling/locking itlike a normal cheat), feel free to replace or modify the original code. For example change the \"sub\"into an \"add\", or simply comment it out (//thisisacomment), and when you enable the script Cheat Enginewill interpret what you typed (assuming no syntax errors) and make whatever edits you intend for it to.The way this works is that Cheat Engine will overwrite the original code with a jump to some new code,and then include whatever code you want, which then jumps back at the end. This means that you caninsert new code as well, so if you wanted to change the math or logic being done, you generally haveenough room to write a small little assembly routine there to do whatever, so have fun with it.Note: this section assumes that you've messed around with assembly editing in Cheat Engine enoughto have a basic grasp of the concept and know what you're doing.So making a script that edits the game code is a great way to get around moving memory addresses.You don't need to scan for pointers or watch changing addresses when you edit the game code to controlthings. But... newer games (especially ones written in .NET and such) don't even load their code inthe same order each time! So we need a way to find where certain code snippets are, and thenreference/edit them. We do this with AOBscans. AOB stands for \"Array of Bytes\", and is just a list ofvalues in RAM.You write a script in the Auto Assembler window (CTRL+A in the memory browser, add it to the tablelike before and edit it from there), and here's a very basic AOB script for editing some assembly. \n\n \n\n In this specific case, it's a \"No Damage\" code for Cave Story. The first thing it does is scan for \n\n certain bytes in RAM in a certain order (using aobscan to find a unique sequence of bytes, known here \n\n as a signature). Then it applies a label (_nodamage) to that found address (sort of like a variable). \n\n Then it acts on that address. In this case I'm using the \"db\" command, which writes specific bytes. \n\n In the \"enable\" section it's writing the bytes \"90 90\", which is nop, remember? Then the disable \n\n section writes the original bytes back (2B C8, which was the sub). \n\n \n\n Instead of using \"db\", you could just write out your assembly normally, but with this kind of simple \n\n replacement you can't add more code than was already there, you're only limited to the number of bytes \n\n that already exist, so I usually just use db to keep it simple and remind myself of the limits. \n\n \n\n \"But wait, what the hell are the bytes at the beginning of the scripts?\" \n\n Well... it's the snippet of code we want to find/target. \n\n \n\n \n\n \n\n If you start with the line of code that you want to edit and then select it and a few more instructions \n\n after it, you can right-click and Copy To Clipboard - Bytes Only (No Addresses). This will copy the \n\n string of bytes for you to paste right into the template (and make sure to change the [DISABLE] section \n\n to put the right new bytes back too). \n\n \n\n So there's a basic and direct AOB assembly replacement script for making minor changes. \n\n \n\n It's very important to remember that when you're manually overwriting bytes like this (without \n\n injection) that the replacement and disable bytes need to account for eachother. \n\n \n\n For example this below code handles it properly... \n\n In this specific case, it's a \"No Damage\" code for Cave Story. The first thing it does is scan forcertain bytes in RAM in a certain order (using aobscan to find a unique sequence of bytes, known hereas a signature). Then it applies a label (_nodamage) to that found address (sort of like a variable).Then it acts on that address. In this case I'm using the \"db\" command, which writes specific bytes.In the \"enable\" section it's writing the bytes \"90 90\", which is nop, remember? Then the disablesection writes the original bytes back (2B C8, which was the sub).Instead of using \"db\", you could just write out your assembly normally, but with this kind of simplereplacement you can't add more code than was already there, you're only limited to the number of bytesthat already exist, so I usually just use db to keep it simple and remind myself of the limits.Well... it's the snippet of code we want to find/target.If you start with the line of code that you want to edit and then select it and a few more instructionsafter it, you can right-click and Copy To Clipboard - Bytes Only (No Addresses). This will copy thestring of bytes for you to paste right into the template (and make sure to change the [DISABLE] sectionto put the right new bytes back too).So there's a basic and direct AOB assembly replacement script for making minor changes.It's very important to remember thatthat the replacement and disable bytes need to account for eachother. \n\n However this below code it just asking for crashes... \n\n \n\n That's because it's not fixing all of the edited bytes, it's not putting things back the way they were. It's \n\n also the reason that stuff is overwritten with 90 (nop, no operation), to keep the same number of bytes \n\n modified. For inserting more code, you'll want to use either the code injection (step 3) or AOB injection \n\n (step 7) template, in which CE allocates your own little code space and shuffles things around for you. \n\n \n\n \n\n \n\n \n\n \n\n So let's say you've made some aobscans for various games. Some of them work just fine, but others stop \n\n enabling after a restart of the game or something. This just means that you need to find better \n\n signatures (the sequence of bytes to search for). The two main things you can do to improve your \n\n signatures is to use wildcards to avoid changing addresses/offsets, and to shift your signature up or \n\n down more and then refer to it with an offset in order to target a more unique string of data. \n\n \n\n For the wildcards, let's take our Cave Story example aobscan and look at it closer. \n\n \n\n \n\n \n\n The bytes I've circled in red are the kinds of things you usually don't want to reference directly. \n\n They're memory addresses that may change from one run to another. (This isn't the case with Cave Story \n\n specifically, but tons of games do this). So in order to avoid referencing that data directly, we'll \n\n just use wildcards. We replace the that can change with a question joe. \n\n \n\n So... \n\n That's because it's not fixing all of the edited bytes, it's not putting things back the way they were. It'salso the reason that stuff is overwritten with 90 (nop, no operation), to keep the same number of bytesmodified. For inserting more code, you'll want to use either the code injection (step 3) or AOB injection(step 7) template, in which CE allocates your own little code space and shuffles things around for you.So let's say you've made some aobscans for various games. Some of them work just fine, but others stopenabling after a restart of the game or something. This just means that you need to find bettersignatures (the sequence of bytes to search for). The two main things you can do to improve yoursignatures is to use wildcards to avoid changing addresses/offsets, and to shift your signature up ordown more and then refer to it with an offset in order to target a more unique string of data.For the wildcards, let's take our Cave Story example aobscan and look at it closer.The bytes I've circled in red are the kinds of things you usually don't want to reference directly.They're memory addresses that may change from one run to another. (This isn't the case with Cave Storyspecifically, but tons of games do this). So in order to avoid referencing that data directly, we'lljust use wildcards. We replace thethat can change with a question joe.So... \n\n \n\n Generally anything that's a small offset (like +2 or +216) isn't going to change, it's the huge things \n\n (four bytes or so) that do change and should be replaced with wildcards. But beware, the more wildcards \n\n you have, the less unique your signature is, so you may need to add more bytes to search for at the \n\n end if you have a lot of wildcards. \n\n \n\n Sometimes you may not be able to find a good signature directly after the code you want to edit. Sometimes \n\n you have the line you want to edit, followed by 4-6 functions that deal with random addresses and numbers \n\n that keep changing. That's okay, you can search ahead of the function you want to work off of too! \n\n \n\n So here's the same code, but using both techniques. \n\n \n\n \n\n \n\n \n\n \n\n \n\n Now that you know the basics of how to edit game code and what an AOB and such is, you can take a much \n\n shorter method to get custom scripts up and running. Make sure that your version of Cheat Engine is at least \n\n 6.4, that's when this feature was included. When you target some code and open up the AA window, this time \n\n go to Template - Cheat Table Framework and then Template - AOB Injection. \n\n \n\n \n\n \n\n It'll ask which address you want the jump on, defaulting to what was highlighted when you opened the AA \n\n window, and this is usually what you want anyways. \n\n \n\n \n\n \n\n Next it'll ask you to name the symbol. Make sure you give it an actual unique name for the table. \n\n \n\n \n\n \n\n Next CE make take a few moments because it'll try to develop and AOB scan that's unique to the code you \n\n targeted, but once it's done it'll present you with a nice AOB injection template. \n\n \n\n \n\n \n\n As before, the orange box indicates the copy of the original game code that will be injected for you to change. \n\n \n\n \n\n \n\n \n\n Once you go off to start making your own things for games, you'll likely run into situations where games use \n\n floats (floating-point numbers) for things. In theory you could use the same sort of techniques here, but the \n\n thing is that a lot of the time the instruction that writes the final value to memory is FSTP. This stands for \n\n loatingpoint oreand op (more or less). This unfortunately means that not only does \n\n the instruction modify the target value, but it also modifies the stack . Stack modification is very important \n\n to keep track of, because an unbalanced stack can cause all sorts of problems or outright crashes in games. \n\n \n\n This basically means that the safest thing to do when you're dealing with floating-point instructions is to avoid \n\n removing them. Unless you're quite familiar with assembly and the stack and such, what you'll want to do is \n\n overwrite the results instead. For example let's say that this is our target function here, an fstp. \n\n \n\n \n\n \n\n Since we need to insert our own code to handle this type of thing, you'll want to use the AOB injection \n\n template like you were shown earlier in this guide. Once you do that, look at the code section as usual... \n\n \n\n \n\n \n\n Now, in order to overwrite the results of the FSTP into the target address, we'll simply add our own instruction \n\n there which will set it to the value we specifically want. The easiest way to do this is with a mov. \n\n \n\n \n\n \n\n And with that, the code shouldn't cause odd problems or crash the game anymore. Generally anything that's a small offset (like +2 or +216) isn't going to change, it's the huge things(four bytes or so) that do change and should be replaced with wildcards. But beware, the more wildcardsyou have, the less unique your signature is, so you may need to add more bytes to search for at theend if you have a lot of wildcards.Sometimes you may not be able to find a good signature directly after the code you want to edit. Sometimesyou have the line you want to edit, followed by 4-6 functions that deal with random addresses and numbersthat keep changing. That's okay, you can search ahead of the function you want to work off of too!So here's the same code, but using both techniques.Now that you know the basics of how to edit game code and what an AOB and such is, you can take a muchshorter method to get custom scripts up and running. Make sure that your version of Cheat Engine is at least6.4, that's when this feature was included. When you target some code and open up the AA window, this timego to Template - Cheat Table Framework and then Template - AOB Injection.It'll ask which address you want the jump on, defaulting to what was highlighted when you opened the AAwindow, and this is usually what you want anyways.Next it'll ask you to name the symbol. Make sure you give it an actual unique name for the table.Next CE make take a few moments because it'll try to develop and AOB scan that's unique to the code youtargeted, but once it's done it'll present you with a nice AOB injection template.As before, the orange box indicates the copy of the original game code that will be injected for you to change.Once you go off to start making your own things for games, you'll likely run into situations where games usefloats (floating-point numbers) for things. In theory you could use the same sort of techniques here, but thething is that a lot of the time the instruction that writes the final value to memory is FSTP. This stands forloatingpointoreandop (more or less). This unfortunately means that not only doesthe instruction modify the target value,. Stack modification is very importantto keep track of, because an unbalanced stack can cause all sorts of problems or outright crashes in games.This basically means that the safest thing to do when you're dealing with floating-point instructions is to avoidremoving them. Unless you're quite familiar with assembly and the stack and such, what you'll want to do isoverwrite the results instead. For example let's say that this is our target function here, an fstp.Since we need to insert our own code to handle this type of thing, you'll want to use the AOB injectiontemplate like you were shown earlier in this guide. Once you do that, look at the code section as usual...Now, in order to overwrite the results of the FSTP into the target address, we'll simply add our own instructionthere which will set it to the value we specifically want. The easiest way to do this is with a mov.And with that, the code shouldn't cause odd problems or crash the game anymore. \n\n\n\nLast edited by Rydian on Thu Oct 29, 2015 7:30 am; edited 5 times in total"
    },
    {
        "link": "https://cs.brown.edu/courses/csci0300/2022/notes/l09.html",
        "document": ""
    },
    {
        "link": "https://docs.oracle.com/cd/E19641-01/802-1948/802-1948.pdf",
        "document": ""
    },
    {
        "link": "https://broman.dev/download/Assembly%20Language%20for%20x86%20Processors%207th%20Edition.pdf",
        "document": ""
    },
    {
        "link": "https://notes.shichao.io/asm",
        "document": "\n• With assembly, the programmer can precisely track the flow of data and execution in a program in a mostly human-readable form.\n• Debuggers will frequently only show program code in assembly language.\n• Assembly language is also the preferred tool for implementing some low-level tasks, such as bootloaders and low-level kernel components. Code written in assembly has less overhead than code written in high-level languages\n• As hardware manufacturers such as Intel and AMD add new features and new instructions to their processors, often times the only way to access those features is to use assembly routines, at least until the major compiler vendors add support for those features.\n\nThe computer cannot read the assembly language that you write. Your assembler will convert the assembly language into a form of binary information called \"machine code\" that your computer uses to perform its operations.\n\nThe basic x86 machine code is dependent only on the processor. The x86 versions of Windows and Linux are obviously built on the x86 machine code. There are a few differences between Linux and Windows programming in x86 Assembly:\n• On a Linux computer, the most popular assemblers are the GAS assembler, which uses the AT&T syntax for writing code, and the Netwide Assembler, also known as NASM, which uses a syntax similar to MASM.\n• On a Windows computer, the most popular assembler is MASM, which uses the Intel syntax.\n• The available software interrupts, and their functions, are different on Windows and Linux.\n• The available code libraries are different on Windows and Linux.\n\nThe term \"x86\" can refer both to an instruction set architecture and to microprocessors which implement it. The name x86 is derived from the fact that many of Intel's early processors had names ending in \"86\".\n\nThe x86 instruction set architecture originated at Intel and has evolved over time by the addition of new instructions as well as the expansion to 64-bits. As of 2009, x86 primarily refers to IA-32 (Intel Architecture, 32-bit) and/or x86-64, the extension to 64-bit computing.\n\nVersions of the x86 instruction set architecture have been implemented by Intel, AMD and several other vendors, with each vendor having its own family of x86 processors.\n• Counter register (CX). Used in shift/rotate instructions and loops.\n• Data register (DX). Used in arithmetic operations and I/O operations.\n• Base register (BX). Used as a pointer to data (located in segment register DS, when in segmented mode).\n• Stack Pointer register (SP). Pointer to the top of the stack.\n• Stack Base Pointer register (BP). Used to point to the base of the stack.\n• Source Index register (SI). Used as a pointer to a source in stream operations.\n• Destination Index register (DI). Used as a pointer to a destination in stream operations.\n\nThe order in which they are listed here is for a reason: it is the same order that is used in a push-to-stack operation, which will be covered later.\n\nAll registers can be accessed in 16-bit, 32-bit and 64-bit modes:\n• 16-bit: the register is identified by its two-letter abbreviation from the list above. For example, 'AX'.\n• 32-bit: the two-letter abbreviation is prefixed with an 'E' (extended). For example, 'EAX'.\n• 64-bit: the two-letter abbreviation is prefixed with an 'R'. For example, 'RAX'.\n\nIt is also possible to address the first four registers (AX, CX, DX and BX) in their size of 16-bit as two 8-bit halves:\n• The least significant byte (LSB), or low half, is identified by replacing the 'X' with an 'L'. & The most significant byte (MSB), or high half, uses an 'H' instead.\n\nFor example, CL is the LSB of the counter register, whereas CH is its MSB.\n\nThe following table summarizes five ways to access the accumulator, counter, data and base registers: 64-bit, 32-bit, 16-bit, 8-bit LSB, and 8-bit MSB:\n• F Segment (FS). Pointer to more extra data ('F' comes after 'E').\n• G Segment (GS). Pointer to still more extra data ('G' comes after 'F').\n\nMost applications on most modern operating systems (FreeBSD, Linux or Microsoft Windows) use a memory model that points nearly all segment registers to the same place and uses paging instead, effectively disabling their use. Typically the use of FS or GS is an exception to this rule, instead being used to point at thread-specific data.\n\nThe EFLAGS is a 32-bit register used as a collection of bits representing Boolean values to store the results of operations and the state of the processor.\n\nThe bits named 0 and 1 are reserved bits and shouldn't be modified.\n\nThe different use of these flags are:\n• 0 CF : Carry Flag. Set if the last arithmetic operation carried (addition) or borrowed (subtraction) a bit beyond the size of the register. This is then checked when the operation is followed with an add-with-carry or subtract-with-borrow to deal with values too large for just one register to contain.\n• 2 PF : Parity Flag. Set if the number of set bits in the least significant byte is a multiple of 2.\n• 6 ZF : Zero Flag. Set if the result of an operation is Zero (0).\n• 7 SF : Sign Flag. Set if the result of an operation is negative.\n• 9 IF : Interruption Flag. Set if interrupts are enabled.\n• 10 DF : Direction Flag. Stream direction. If set, string operations will decrement their pointer rather than incrementing it, reading memory backwards.\n• 11 OF : Overflow Flag. Set if signed arithmetic operations result in a value too large for the register to contain.\n• 14 NT : Nested Task flag. Controls chaining of interrupts. Set if the current process is linked to the next process.\n• 18 AC : Alignment Check. Set if alignment checking of memory references is done.\n• 20 VIP : Virtual Interrupt Pending flag. Set if an interrupt is pending.\n• 21 ID : Identification Flag. Support for CPUID instruction if can be set.\n\nThe EIP register contains the address of the next instruction to be executed if no branching is done.\n\nEIP can only be read through the stack after a instruction.\n\nThe x86 architecture is little-endian, meaning that multi-byte values are written least significant byte first. (This refers only to the ordering of the bytes, not to the bits.)\n\nThe 32 bit value B3B2B1B0 on an x86 would be represented in memory as:\n\nThe 32 bits double word 0x1BA583D4 (the 0x denotes hexadecimal) would be written in memory as:\n\nThis will be seen as when doing a memory dump.\n\nTwo's complement is the standard way of representing negative integers in binary. The sign is changed by inverting all of the bits and adding one.\n\nThe addressing mode indicates how the operand is presented.\n\nOperand address R is in the address field.\n\nAactual value is in the field.\n\nOperand address is in the address field.\n\nField points to a register that contains the operand address.\n\nThe registers used for indirect addressing are BX, BP, SI, DI\n\nFor example, if we are talking about an array, BX contains the address of the beginning of the array, and DI contains the index into the array.\n\n64-bit x86 adds 8 more general-purpose registers, named R8, R9, R10 and so on up to R15. It also introduces a new naming convention that must be used for these new registers and can also be used for the old ones (except that AH, CH, DH and BH have no equivalents). In the new convention:\n• R8, R9, R10, R11, R12, R13, R14, R15 are the new registers and have no other names.\n• R0D~R15D are the lowermost 32 bits of each register. For example, R0D is EAX.\n• R0W~R15W are the lowermost 16 bits of each register. For example, R0W is AX.\n• R0L~R15L are the lowermost 8 bits of each register. For example, R0L is AL.\n\nThe stack is a Last In First Out (LIFO) data structure; data is pushed onto it and popped off of it in the reverse order.\n\nNow the stack has $006A, $F79A, and $1124.\n\nDo some stuff. The function is not forced to save the registers it uses, hence us saving them.\n\nThe stack has two common uses:\n• Passing arguments to functions or procedures and also keeping track of control flow when the instruction is used.\n\nReal Mode is a holdover from the original Intel 8086. The Intel 8086 accessed memory using 20-bit addresses. But, as the processor itself was 16-bit, Intel invented an addressing scheme that provided a way of mapping a 20-bit addressing space into 16-bit words. Today's x86 processors start in the so-called Real Mode, which is an operating mode that mimics the behavior of the 8086, with some very tiny differences, for backwards compatibility.\n\nIf programming in a modern operating system (such as Linux, Windows), you are basically programming in flat 32-bit mode. Any register can be used in addressing, and it is generally more efficient to use a full 32-bit register instead of a 16-bit register part. Additionally, segment registers are generally unused in flat mode, and it is generally a bad idea to touch them.\n\nUsing a 32-bit register to address memory, the program can access (almost) all of the memory in a modern computer. For earlier processors (with only 16-bit registers) the segmented memory model was used. The 'CS', 'DS', and 'ES' registers are used to point to the different chunks of memory. For a small program (small model) the CS=DS=ES. For larger memory models, these 'segments' can point to different locations.\n\nWhen writing code, it is very helpful to use some comments explaining what is going on. A comment is a section of regular text that the assembler ignores when turning the assembly code into the machine code. In assembly comments are usually denoted with a semicolon \";\", although GAS uses \"#\" for single line comments and \"/ ... /\" for multi-line comments.\n\nStrictly speaking, assembly has no predefined data types like higher-level programming languages. Any general purpose register can hold any sequence of two or four bytes, whether these bytes represent numbers, letters, or other data. In the same way, there are no concrete types assigned to blocks of memory; you can assign to them whatever value you like.\n\nThat said, one can group data in assembly into two categories: integer and floating point. While you could load a floating point value into a register and treat it like an integer, the results would be unexpected, so it is best to keep them separate.\n\nAn integer represents a whole number, either positive or negative.\n• Under the 8086 architecture, it originally came in 8-bit and 16-bit sizes, which served the most basic operations.\n• Later, starting with the 80386, the data bus was expanded to support 32-bit operations and thus allow operations on integers of that size.\n• The newest systems under the x86 architecture support 64-bit instructions; however, this requires a 64-bit operating system for optimal effect.\n\nSome assembly instructions behave slightly differently in regards to the sign bit; as such, there is a minor distinction between signed and unsigned integers.\n\nFloating point numbers are used to approximate the real numbers that usually contain digits before and after the decimal point (like π, 3.14159...). Unlike integers where the decimal point is understood to be after all digits, in floating point numbers the decimal point floats anywhere in the sequence of digits. The precision of floating point numbers is limited and thus a number like π can only be represented approximately.\n\nOriginally, floating point was not part of the main processor, requiring the use of emulating software. However, there were floating point coprocessors that allowed operations on this data-type, and starting with the 486DX, were integrated directly with the CPU.\n\nAs such, floating point operations are not necessarily compatible with all processors. If you need to perform this type of arithmetic, you may want to use a software library as a backup code path.\n\nInstructions that take no operands:\n\nInstructions that take 2 operands. Notice how the format of the instruction is different for different assemblers.\n\nInstructions that take 3 operands. Notice how the format of the instruction is different for different assemblers.\n\nSome instructions require the use of suffixes to specify the size of the data which will be the subject of the operation, such as:\n\nAn example of the usage with the instruction on a 32-bit architecture, GAS syntax:\n\nThe instruction copies the operand into the operand.\n\nModified flags: No FLAGS are modified by this instruction.\n\nThe instruction swaps the operand with the dest operand. It's like doing three move operations: from dest to a temporary (another register), then from to dest, then from the temporary to , except that no register needs to be reserved for temporary storage.\n\nIf one of the operands is a memory address, then the operation has an implicit prefix, that is, the exchange operation is atomic. This can have a large performance penalty.\n\nIt's also worth noting that the common (no op) instruction, , is the opcode for .\n• None\n• Memory (only one operand can be in memory: the other must be a register)\n\nModified flags: No FLAGS are modified by this instruction.\n\nAlmost all programming languages have the ability to change the order in which statements are evaluated, and assembly is no exception. The instruction pointer (EIP) register contains the address of the next instruction to be executed. To change the flow of control, the programmer must be able to modify the value of EIP. This is where control flow functions come in.\n\nPerforms a bit-wise logical AND on and the result of which we will refer to as Temp and sets the ZF (zero), SF (sign) and PF (parity) flags based on . is then discarded.\n\nPushes the address of the next opcode onto the top of the stack, and jumps to the specified location. This is used mostly for subroutines.\n\nLoads the next value on the stack into EIP, and then pops the specified number of bytes off the stack. If is not supplied, the instruction will not pop any values off the stack after returning.\n\nThe loop instruction decrements ECX and jumps to the address specified by arg unless decrementing ECX caused its value to become zero. For example:\n\ncreates a stack frame with the specified amount of space allocated on the stack.\n\ndestroys the current stack frame, and restores the previous frame. Using Intel syntax this is equivalent to:\n\nHalts the processor. Execution will be resumed after processing next hardware interrupt, unless IF is cleared.\n\nNo operation. This instruction doesn't do anything, but wastes an instruction cycle in the processor. This instruction is often represented as an XCHG operation with the operands EAX and EAX.\n\nWaits for the FPU to finish its last calculation.\n\nThis instruction decrements the stack pointer and stores the data specified as the argument into the location pointed to by the stack pointer.\n\nThis instruction loads the data stored in the location pointed to by the stack pointer into the argument specified and then increments the stack pointer.\n\nInterrupts are special routines that are defined on a per-system basis. This means that the interrupts on one system might be different from the interrupts on another system. Therefore, it is usually a bad idea to rely heavily on interrupts when you are writing code that needs to be portable.\n\nThis instruction issues the specified interrupt. For instance:\n\nThere are 3 types of interrupts: Hardware Interrupts, Software Interrupts and Exceptions.\n\nHardware interrupts are triggered by hardware devices. Hardware interrupts are typically asynchronous: their occurrence is unrelated to the instructions being executed at the time they are raised.\n\nSoftware interrupts are usually used to transfer control to a function in the operating system kernel. Software interrupts are triggered by the instruction . For example, the instruction triggers interrupt . The processor then stops the current program, and jumps to the code to handle interrupt 14. When interrupt handling is complete, the processor returns flow to the original program.\n\nExceptions are caused by exceptional conditions in the code which is executing, for example an attempt to divide by zero or access a protected memory area. The processor will detect this problem, and transfer control to a handler to service the exception. This handler may re-execute the offending code after changing some value (for example, the zero dividend), or if this cannot be done, the program causing the exception may be terminated.\n\nSyscalls are the interface between user programs and the Linux kernel. They are used to let the kernel perform various system tasks, such as file access, process management and networking. In the C programming language, you would normally call a wrapper function which executes all required steps or even use high-level features such as the standard IO library.\n\nOn Linux, there are several ways to make a syscall. This page will focus on making syscalls by calling a software interrupt using (x86 and x86_64) or (x86_64). This is an easy and intuitive method of making syscalls in assembly-only programs.\n\nTo make a syscall using an interrupt, you have to pass all required information to the kernel by copying them into general purpose registers. Each syscall has a fixed number (note the numbers differ between and in the following text). You specify the syscall by writing the number into the / register and pass the parameters by writing them in the appropriate registers before making the actual calls. Parameters are passed in the order they appear in the function signature of the corresponding C wrapper function.\n\nAfter everything is set up correctly, you call the interrupt using or and the kernel performs the task.\n\nThe return or error value of a syscall is written to or .\n\nThe kernel uses its own stack to perform the actions. The user stack is not touched in any way.\n\nOn both Linux x86 and Linux x86_64 systems you can make a syscall by calling interrupt 0x80 using the command. Parameters are passed by setting the general purpose registers as following:\n\nThe return value is in the register.\n\nThe syscall numbers are described in the Linux source file arch/x86/include/asm/unistd_32.h.\n\nAll registers are preserved during the syscall.\n\nThe x86_64 architecture introduced a dedicated instruction to make a syscall. It does not access the interrupt descriptor table and is faster. Parameters are passed by setting the general purpose registers as following:\n\nThe syscall numbers are described in the Linux source file arch/x86/include/asm/unistd_64.h.\n\nThe return value is in the register.\n\nAll registers, except and , are preserved during the syscall.\n\nThis example will write the text \"Hello World\" to stdout using the syscall and quit the program using the syscall.\n\nThe following is the C program of this example:\n\nBoth of the assembly examples start alike: a string stored in the data segment and as a global symbol.\n\nAs defined in , the syscall numbers for and are:\n\nThe parameters are passed exactly as one would in a C program, using the correct registers. After everything is set up, the syscall is made using .\n\nIn , the syscall numbers are defined as following:\n\nParameters are passed just like in the example, except that the order of the registers is different. The syscall is made using ."
    },
    {
        "link": "https://web.stanford.edu/class/cs107/guide/x86-64.html",
        "document": "x86-64 (also known as just x64 and/or AMD64) is the 64-bit version of the x86/IA32 instruction set. Below is our overview of its features that are relevant to CS107. There is more extensive coverage on these topics in Chapter 3 of the B&O textbook. See also our x86-64 sheet for a compact reference.\n\nThe table below lists the commonly used registers (sixteen general-purpose plus two special). Each register is 64 bits wide; the lower 32-, 16- and 8-bit portions are selectable by a pseudo-register name. Some registers are designated for a certain purpose, such as being used as the stack pointer or for the return value from a function. Other registers are all-purpose, but have a conventional use depending on whether caller-owned or callee-owned. If the function calls , we refer to as the caller and as the callee. For example, the registers used for the first 6 arguments and return value are all callee-owned. The callee can freely use those registers, overwriting existing values without taking any precautions. If holds a value the caller wants to retain, the caller must copy the value to a \"safe\" location before making a call. The callee-owned registers are ideal for scratch/temporary use by the callee. In contrast, if the callee intends to use a caller-owned register, it must first preserve its value and restore it before exiting the call. The caller-owned registers are used for local state of the caller that needs to preserved across further function calls.\n\nTrue to its CISC nature, x86-64 supports a variety of addressing modes. An addressing mode is an expression that calculates an address in memory to be read/written to. These expressions are used as the source or destination for a instruction and other instructions that access memory. The code below demonstrates how to write the immediate value 1 to various memory locations in an example of each of the available addressing modes:\n\nA note about instruction suffixes: many instructions have a suffix ( , , , or ) which indicates the bitwidth of the operation (1, 2, 4, or 8 bytes, respectively). The suffix is often elided when the bitwidth can be determined from the operands. For example, if the destination register is , it must be 4 bytes, if it must be 2 bytes, and would be 1 byte. A few instructions such as and have two suffixes: the first is for the source operand, the second for the destination. For example, moves a 1-byte source value to a 4-byte destination.\n\nWhen the destination is a sub-register, only those specific bytes in the sub-register are written with one broad exception: a 32-bit instruction zeroes the high order 32 bits of the destination register.\n\nBy far most frequent instruction you'll encounter is in one of its its multi-faceted variants. Mov copies a value from source to destination. The source can be an immediate value, a register, or a memory location (expressed using one of the addressing mode expressions from above). The destination is either a register or a memory location. At most one of source or destination can be memory. The suffix (b, w, l, or q) indicates how many bytes are being copied (1, 2, 4, or 8 respectively). For the (load effective address) instruction, the source operand is a memory location (using an addressing mode from above) and it copies the calculated source address to destination. Note that does not dereference the source address, it simply calculates its location. This means is nothing more than an arithmetic operation and commonly used to calculate the value of simple linear combinations that have nothing to do with memory locations!\n\nThe instruction copies the same number of bytes from one location to another. In situations where the move is copying a smaller bitwidth to a larger, the and variants are used to specify how to fill the additional bytes, either sign-extend or zero-fill.\n\nA special case to note is that a to write a 32-bit value into a register also zeroes the upper 32 bits of the register by default, i.e does an implicit zero-extend to bitwidth q. This explains use of instructions such as that look odd/redundant, but are, in fact, being used to zero-extend from 32 to 64. Given this default behavior, there is no need for an explicit instruction. To instead sign-extend from 32-bit to 64-bit, there is an instruction.\n\nThe instruction is a specialized that operates on . This no-operand instruction does sign-extension in-place on ; source bitwidth is l, destination bitwidth is q.\n\nThe binary operations are generally expressed in a two-operand form where the second operand is both a source to the operation and the destination. The source can be an immediate constant, register, or memory location. The destination must be either register or memory. At most one of source or destination can be memory. The unary operations have one operand which is both source and destination, which can be either register or memory. Many of the arithmetic instructions are used for both signed and unsigned types, i.e. there is not a signed add and unsigned add, the same instruction is used for both. Where needed, the condition codes set by the operation can be used to detect the different kinds of overflow.\n\nBranches and other use of condition codes\n\nThe special register stores a set of boolean flags called the condition codes. Most arithmetic operations update those codes. A conditional jump reads the condition codes to determine whether to take the branch or not. The condition codes include ZF (zero flag), SF (sign flag), OF (overflow flag, signed), and CF (carry flag, unsigned). For example, if the result was zero, the ZF is set, if a operation overflowed (into sign bit), OF is set.\n\nThe general pattern for all branches is to execute a or operation to set the flags followed by a jump instruction variant that reads the flags to determine whether to take the branch or continue on. The operands to a or are immediate, register, or memory location (with at most one memory operand). There are 32 variants of conditional jump, several of which are synonyms. Here are some example branch instructions.\n\nThere are two other families of instructions that read/react to the current condition codes. The instructions set a destination register to 0 or 1 according to the status of condition . The instructions will conditionally execute a move based on whether condition holds. The is a placeholder for any of the conditional variants: , , , , etc.\n\nFor the instruction, the destination must be a single-byte sub-register (e.g. for the low byte of ). For the instructions, both the source and destination must be registers.\n\nThe register is used as the \"stack pointer\"; and are used to add/remove values from the stack. The instruction takes one operand: an immediate, a register, or a memory location. Push decrements and copies the operand to be tompost on the stack. The instruction takes one operand, the destination register. Pop copies the topmost value to destination and increments . It is also valid to directly adjust to add/remove an entire array or a collection of variables with a single operation. Note the stack grows downward (toward lower addresses).\n\nCall/return are used to transfer control between functions. The instruction takes one operand, the address of the function being called. It pushes the return address (current value of , which is the next instruction after the call) onto the stack and then jumps to the address of the function being called. The instruction pops the return address from the stack into , thus resuming at the saved return address.\n\nTo set up for a call, the caller puts the first six arguments into registers , , , , , and (any additional arguments are pushed onto the stack) and then executes the instruction.\n\nWhen callee finishes, it writes the return value (if any) to , cleans up the stack, and use instruction to return control to the caller.\n\nThe target for a branch or call instruction is most typically an absolute address that was determined at compile-time. However there are cases where the target is not known until runtime, such as a statement compiled into a jump table or when invoking a function pointer. For these, the target address is computed and stored in a register and the branch/call variant is used or to read the target address from the specified register.\n\nThe debugger has many features that allow you to trace and debug code at the assembly level. You can print the value in a register by prefixing its name with or use the command to dump the values of all registers:\n\nThe command will print the disassembly for a function by name. The command supports an format which interprets the contents of a memory address as an encoded instruction.\n\nYou can set a breakpoint at a particular assembly instruction by its direct address or offset within a function\n\nYou can advance by instruction (instead of source line) using the and commands."
    }
]