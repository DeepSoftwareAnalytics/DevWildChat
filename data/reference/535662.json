[
    {
        "link": "https://doc.rust-lang.org/std/keyword.mod.html",
        "document": "Use to create new modules to encapsulate code, including other modules:\n\nLike s and s, a module and its content are private by default, inaccessible to code outside of the module.\n\nTo learn more about allowing access, see the documentation for the keyword."
    },
    {
        "link": "https://doc.rust-lang.org/book/ch07-02-defining-modules-to-control-scope-and-privacy.html",
        "document": "In this section, we’ll talk about modules and other parts of the module system, namely paths, which allow you to name items; the keyword that brings a path into scope; and the keyword to make items public. We’ll also discuss the keyword, external packages, and the glob operator.\n\nBefore we get to the details of modules and paths, here we provide a quick reference on how modules, paths, the keyword, and the keyword work in the compiler, and how most developers organize their code. We’ll be going through examples of each of these rules throughout this chapter, but this is a great place to refer to as a reminder of how modules work.\n• Start from the crate root: When compiling a crate, the compiler first looks in the crate root file (usually src/lib.rs for a library crate or src/main.rs for a binary crate) for code to compile.\n• Declaring modules: In the crate root file, you can declare new modules; say you declare a “garden” module with . The compiler will look for the module’s code in these places:\n• Inline, within curly brackets that replace the semicolon following\n• Declaring submodules: In any file other than the crate root, you can declare submodules. For example, you might declare in src/garden.rs. The compiler will look for the submodule’s code within the directory named for the parent module in these places:\n• Inline, directly following , within curly brackets instead of the semicolon\n• Paths to code in modules: Once a module is part of your crate, you can refer to code in that module from anywhere else in that same crate, as long as the privacy rules allow, using the path to the code. For example, an type in the garden vegetables module would be found at .\n• Private vs. public: Code within a module is private from its parent modules by default. To make a module public, declare it with instead of . To make items within a public module public as well, use before their declarations.\n• The keyword: Within a scope, the keyword creates shortcuts to items to reduce repetition of long paths. In any scope that can refer to , you can create a shortcut with and from then on you only need to write to make use of that type in the scope.\n\nHere, we create a binary crate named that illustrates these rules. The crate’s directory, also named , contains these files and directories:\n\nThe crate root file in this case is src/main.rs, and it contains:\n\nThe line tells the compiler to include the code it finds in src/garden.rs, which is:\n\nHere, means the code in src/garden/vegetables.rs is included too. That code is:\n\nNow let’s get into the details of these rules and demonstrate them in action!\n\nModules let us organize code within a crate for readability and easy reuse. Modules also allow us to control the privacy of items because code within a module is private by default. Private items are internal implementation details not available for outside use. We can choose to make modules and the items within them public, which exposes them to allow external code to use and depend on them.\n\nAs an example, let’s write a library crate that provides the functionality of a restaurant. We’ll define the signatures of functions but leave their bodies empty to concentrate on the organization of the code rather than the implementation of a restaurant.\n\nIn the restaurant industry, some parts of a restaurant are referred to as front of house and others as back of house. Front of house is where customers are; this encompasses where the hosts seat customers, servers take orders and payment, and bartenders make drinks. Back of house is where the chefs and cooks work in the kitchen, dishwashers clean up, and managers do administrative work.\n\nTo structure our crate in this way, we can organize its functions into nested modules. Create a new library named by running . Then enter the code in Listing 7-1 into src/lib.rs to define some modules and function signatures; this code is the front of house section.\n\nWe define a module with the keyword followed by the name of the module (in this case, ). The body of the module then goes inside curly brackets. Inside modules, we can place other modules, as in this case with the modules and . Modules can also hold definitions for other items, such as structs, enums, constants, traits, and—as in Listing 7-1—functions.\n\nBy using modules, we can group related definitions together and name why they’re related. Programmers using this code can navigate the code based on the groups rather than having to read through all the definitions, making it easier to find the definitions relevant to them. Programmers adding new functionality to this code would know where to place the code to keep the program organized.\n\nEarlier, we mentioned that src/main.rs and src/lib.rs are called crate roots. The reason for their name is that the contents of either of these two files form a module named at the root of the crate’s module structure, known as the module tree.\n\nListing 7-2 shows the module tree for the structure in Listing 7-1.\n\nThis tree shows how some of the modules nest inside other modules; for example, nests inside . The tree also shows that some modules are siblings, meaning they’re defined in the same module; and are siblings defined within . If module A is contained inside module B, we say that module A is the child of module B and that module B is the parent of module A. Notice that the entire module tree is rooted under the implicit module named .\n\nThe module tree might remind you of the filesystem’s directory tree on your computer; this is a very apt comparison! Just like directories in a filesystem, you use modules to organize your code. And just like files in a directory, we need a way to find our modules."
    },
    {
        "link": "https://reddit.com/r/rust/comments/htzkq7/clear_explanation_of_rusts_module_system",
        "document": "Create your account and connect with a world of communities.\n\nBy continuing, you agree to our\n\nand acknowledge that you understand the"
    },
    {
        "link": "https://tangramvision.com/blog/making-great-docs-with-rustdoc",
        "document": "At Tangram Vision, One of the things we've come to love about Rust is the tight integration of the tooling and ecosystem. Rustdoc, the official documentation system, is no exception to this; it's simple to use, creates beautiful pages, and makes documentation a joy.\n\nWe take documentation seriously. Documentation is for many the first entry point into the code, and good documentation is a primary driver of code adoption (along with functionality). This left us wondering: what *are* the best practices for making quality Rust documentation via Rustdoc? Through the course of our research, we found a couple of key resources that the community has provided:\n\n- [The rustdoc book](https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html): A great place to start if you're looking to learn how to write documentation in your crates.\n\n- [RFC 505: API Comment Conventions](https://rust-lang.github.io/rfcs/0505-api-comment-conventions.html) and [RFC 1574: More API Documentation Conventions](https://rust-lang.github.io/rfcs/1574-more-api-documentation-conventions.html): Explanations on how the [core Rust team](https://www.rust-lang.org/governance/teams/core) documents the standard library and language interfaces.\n\nHowever, while these are useful resources, we felt that a more approachable guide to crate documentation would be helpful to those starting out with their own crates. Through the course of this article, we'll find that Rust's crate+module structure naturally facilitates great documentation creation; we simply play to Rust's strengths.\n\nNote: this guide is about achieving **good documentation quality**. It does not lay out any technical or formatting guidelines. For instance, we internally wrap our documentation at 120 characters a line... but a 120-character line limit won't do much to improve bad docs.\n\nWe assume a bit of knowledge with rustdocs below. If you are unfamiliar with the program, we encourage you to read the rustdoc book linked above as a primer.\n\nHere at [Tangram Vision](https://www.tangramvision.com), we structure our documentation around two ideas:\n\n- *What*: Explaining what was built\n\n- *How*: Explaining how to use it\n\nAnything beyond this is generally not helpful, for one singular reason: our documentation assumes that our users know Rust. We believe this assumption is critical to creating good documentation around the What and How. The docs should rarely discuss *why* a decision was made, unless that decision goes against intuition; instead, the docs only explain how to capitalize on that decision in one's own code.\n\nThis guideline of User Knowledge naturally leads us to another rule: *Keep It Short.* The aim is to be succinct by telling the user the What and the How in as little time as possible. This often means using simple, active language and avoiding technical jargon. If a longer discussion is needed, make sure to put the What and the How first, and the discussion after.\n\nBoth the What and the How can be seen at all levels of documentation in Rust. We'll see how best to organize that in a large repository below while maintaining consistent style and language.\n\nThere's a natural top-down pattern to follow for Rust documentation. The top level `lib.rs` or `main.rs` is the first things users see, so it's the perfect spot to introduce the big What ideas. As the documentation gets more into the weeds, from modules to types to functions, documentation shifts more to the How. We'll see this play out as we discuss the different levels below.\n\nWe have added relevant links to our own documentation in the [realsense-rust](https://gitlab.com/tangram-vision-oss/realsense-rust) crate maintained by Tangram Vision OSS. Check these out for added context.\n\nThe crate documentation in `lib.rs` or `main.rs` should describe the purpose of the crate (the big What) alongside instructions and examples for getting started (the big How). This is a place for big ideas, since the details will come later in the lower levels. Any counter-intuitive design decisions or common gotchas should also be documented here, but remember: the What and the How always come first, and discussion follows.\n\nNotice how the first sections are\n\n...all explaining the big What and How. The documentation goes into more detail afterwards, with headings like \"Architecture & Guiding Principles\", \"Prefer Rust-native types to types used through the FFI\", etc. However, these sections are there only to explain the *non-intuitive* design decisions that go behind creating an FFI interface like this one. For those that don't care, the What and How are presented first, front and center.\n\nModules should contain more direct documentation than the crate itself. The focus again should be on describing the types found in that module and how they interact with the rest of the crate. From this alone, users should understand the Why, i.e. why they would reach for a module from your crate.\n\nThis can get a bit trickier with sub-modules. Avoid deeply nested sub-modules, since they complicate the structure of a crate. Modules with sub-modules more than two layers deep can probably be flattened out. Exceptions exist, but if this layering is needed, it makes sense to add a **Why** discussion to explain what made this necessary.\n\nTypes are our primary way of defining abstraction and ontological separations in our code. Documentation here should focus on:\n\n- Construction of the type (when and how, if users are allowed to construct their own).\n\n- Destruction / dropping the type → what happens when you drop a value of a given type? If you don't implement the `Drop` trait, then this is probably OK to ignore.\n\n- Performance characteristics of the type, if it is a data structure.\n\nAs one can see, the documentation naturally de-emphasizes the What and builds on the How as we go down. Again, counter-intuitive or non-obvious cases might have a Why, but the What and the How together should suffice.\n\nThe last thing to document is functions and associated functions (functions in `impl` blocks). This could include constructors, mutable functions, or data returned by accessors on a type or types. Semantic and code examples are especially welcome here because they describe the How in practical terms.\n\nCrate and module level documentation can be broken down into multiple sections with heading levels 1 (`#` in markdown), 2 (`##`), and 3 (`###`). As you move towards documenting types and functions, aim to be as flat as possible; only use heading level 1 if a section is needed.\n\nThese headings are ordered below (in our humble opinion) according to their usefulness for the user in conveying the What and the How for a Rust crate. It's important to note that not all headings need to be present at all times. If it doesn't make sense, don't add it, since it just increases the cognitive burden on the user.\n\nExamples are, by far, the easiest and most concise way to convey How. They are welcome at all levels: module, type, function, or crate. Write examples for both common use cases and corner cases, like with `Error` or `None` results.\n\nExamples in `rustdoc` documentation will compile and run as doc-tests. This is an **important point**: all code in the documentation will actually compile and run! This means they automatically provide users with starting point for understanding. This is one of Rustdoc's greatest strengths, and it should be utilized whenever possible.\n\na frame of reference for the HowMake these examples functional code whenever possible. If this is *not* possible, e.g. with an example explaining improper usage, tha frame of reference for the Howen use the heading `text` or `ignore` next to the code block:\n\n```rust\n\n/// # Examples\n\n///\n\n/// ```ignore\n\n/// let bummer = this_code_wont_work(); // but it's an illustrative example.\n\n/// ```\n\n```\n\nNotice the heading is \"Examples\", plural. Be consistent with the plurality here. Even if there is only one example, the consistency helps with searching.\n\nAt their best, Errors help a user understand why a certain action is prevented by the crate and how to respond to it. It's a rare instance where explaining the *Why* is not just encouraged, but necessary for proper use.\n\nAt a function level, this section is only needed if that function returns a `Result` type. In this case, it describes the type returned and when the error should be expected, e.g. an invalid internal state, Foreign Function Interface (FFI) interactions, bad arguments, etc.\n\nMake errors actionable by either passing them to a higher level function or allowing a reaction from the caller. It is easier for users to understand how they got there in the first place by writing error types with reaction in mind. Moreover, if a caller can't act on an error, then there's not a strong reason to present it in the first place.\n\nFirst and foremost: Try to minimize unsafe interfaces where possible. Rust is a language built on memory safety, and violating this tenet should only be done with conscious intention. The Safety section should convey that intention.\n\nWhen documenting Safety, be explicit about what is \"unsafe\" about the interface and explain best practices for its use with safe code. If possible, try to specify undefined behavior if an unsafe interface will leave your program in an undefined state.\n\nUse this section if a function can `panic!`. Complete coverage would aim to document any and all calls to `.unwrap()`, `debug_assert!`, etc.\n\nComplete coverage is a good goal to aim for, but realize that a `panic!` call isn't always necessary. Many cases can be guarded against with small code changes. Returning `Result` types can avoid this entirely in exchange for better error handling. Low-level FFI calls can unwrap and `panic!` if passed a null pointer; yet this can be prevented if you start with `NonNull<t>` as the input, making an `unwrap()` call superfluous. </t>\n\nIn any case, you should aim to have all error cases implemented whenever possible. If there is a case that can cause a `panic!`, list it in the docs.\n\nInclude a Lifetimes section if a type or function has special lifetime considerations that need to be taken into consideration by the user. Most of the time, a lifetime itself doesn't need describing; again, always assume users know Rust. Rather, this section should explain why the lifetime has been modeled in a certain way.\n\nRule of thumb: If you only have one lifetime (explicit or implicit), it probably doesn't need documentation.\n\n```rust\n\n/// Wrapper type for an underlying C-FFI pointer\n\n/// \n\n/// # Lifetimes\n\n///\n\n/// The underlying pointer is generated from some C-FFI.\n\n///\n\n/// Adding a lifetime that only references phantom data may seem strange\n\n/// and artificial. However, enforcing this lifetime is useful because\n\n/// the C API may have undefined behavior or odd semantics outside of\n\n/// whatever \"assumed\" lifetime the library writers intended. We make\n\n/// this explicit in Rust with the hope of preventing mistakes in using\n\n/// this API. \n\n/// \n\npub struct SomeType<'a> {</'a>\n\n /// Pointer to data from a C-FFI\n\n ///\n\n /// We need to store this as NonNull because its use in the C API\n\n /// is covariant.\n\n pointer: std::ptr::NonNull<std::os::raw::c_void>,</std::os::raw::c_void>\n\n /// Phantom to annotate this type with an explicit lifetime.\n\n ///\n\n /// See type documentation for why this is done.\n\n _phantom: std::marker::PhantomData<&'a ()=\"\">,</&'a>\n\n}\n\n```\n\nThe above example shows one instance in where a (single) strange lifetime is applied to enforce Rust's lifetime rules on a type. The lifetime *seems* superfluous, but may exist because there is some implicit assumption in C that is being made more explicit here.\n\nAvoid listing arguments explicitly. Instead, names and types themselves should adequately describe arguments and their relationships.\n\nThat being said, an `# Arguments` section can make sense if there is a non-obvious assumption about the arguments or their types that needs to be made explicit, like if passing in certain values for a type invokes *undefined behaviour.* In such a case, an `# Arguments` or `# Generic Arguments` section is useful to clarify that care is needed when passing in data.\n\nFor generic arguments that may require trait bounds, \"document\" these by adding `where` clauses to your function or type. This is much more descriptive and useful, and has the added benefit of your compiler doing some of the work to validate these bounds for you.\n\nTake a look at [the standard library](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.reserve) for examples of good argument names and types.\n\nThe below points deserve to be noted, but don't necessarily fit into any specific framework.\n\nTraits are trickier than regular types and associated functions. Since a trait can be applied to multiple types (even those outside of its crate), don't document implementations of a trait. Instead, document the trait itself.\n\n```rust\n\n/// A trait providing methods for adding different types of numbers to a type.\n\npub trait NumberAdder {\n\n /// Adds an integer to the type\n\n fn add_integer(&mut self, number: i32);\n\n/// Adds a float to the type\n\n fn add_float(&mut self, number: f32);\n\n}\n\n```\n\n```rust\n\nimpl NumberAdder for Foo {\n\n /// Adds an integer to Foo\n\n fn add_integer(&mut self, number: i32) {\n\n // ...\n\n }\n\nTraits are used primarily in generic code, so users will look at the trait itself to understand the interfaces. Any two types implementing the same trait should share common functionality; if two implementations of a trait require vastly differing documentation, the trait itself may not be modeled correctly.\n\n## References Should Always Be Links\n\nWhenever a reference is made, whether it be to another part of the documentation, a website, a paper, or another crate: add a link to it. This applies even when referencing a common type found in the standard library (e.g. `String`, `Vec`, etc.).\n\nLinking to other parts of the documentation avoids repeating information. It is also an easy way to point to higher level architecture decisions that might affect the lower level documentation.\n\n```rust\n\n/// See [`String`](std::string::String) documentation for more details.\n\n```\n\nWe've worked hard at [Tangram Vision](https://www.tangramvision.com) to follow our own guidelines and create world-class Rust documentation. You can read the fruits of our labor by visiting any of the repositories at our [Open-Source software group](https://gitlab.com/tangram-vision-oss). The [RealSense Rust](https://gitlab.com/tangram-vision-oss/realsense-rust) package that we maintain is some of our most complete documentation, and acts a good starting point.\n\nMost of these examples come in the form:\n\n```rust\n\n/// Summary line -> what is this\n\n///\n\n/// Longer description of what is returned, or semantics regarding the type.\n\n/// ...\n\n///\n\n/// # Examples\n\n///\n\n/// ```\n\n/// <some-rust-code></some-rust-code>\n\n/// ```\n\n```\n\n```rust\n\n/// Type for describing errors that result from trying to set an option \n\n/// on a sensor.\n\n#[derive(Debug)]\n\npub enum SetOptionError {\n\n /// The option is not supported on the sensor.\n\n OptionNotSupported,\n\n /// The option is supported on the sensor but is immutable.\n\n OptionIsImmutable,\n\n /// Setting the option failed due to an internal exception.\n\n ///\n\n /// See the enclosed string for a reason why the internal exception occurred.\n\n CouldNotSetOption(String),\n\n}\n\n```\n\n```rust\n\n/// Sets a `value` for the provided `option` in `self`. \n\n/// \n\n/// Returns `Ok(())` on success, otherwise returns an error.\n\n///\n\n/// # Errors\n\n/// \n\n/// Returns [`OptionNotSupported`](SetOptionError::OptionNotSupported) if the\n\n/// option is not supported on this sensor.\n\n///\n\n/// Returns [`OptionIsImmutable`](SetOptionError::OptionIsImmutable) if the\n\n/// option is supported but is immutable.\n\n///\n\n/// Returns [`CouldNotSetOption`](SetOptionError::CouldNotSetOption) if the\n\n/// option could not be set due to an internal exception.\n\n///\n\n/// # Examples\n\n/// \n\n/// ```\n\n/// let option = SomeOption::Foo;\n\n/// let value = 100.5;\n\n/// \n\n/// match sensor.set_option(option, value) {\n\n/// Ok(()) => {\n\n/// println!(\"Success!\");\n\n/// }\n\n/// Err(SetOptionError::OptionNotSupported) => {\n\n/// println!(\"This option isn't supported, try another one!\");\n\n/// }\n\n/// Err(SetOptionError::OptionIsImmutable) => {\n\n/// println!(\"This option is immutable, we can't set it!\");\n\n/// }\n\n/// _ => {\n\n/// panic!();\n\n/// }\n\n/// }\n\n/// ```\n\npub fn set_option(\n\n &self,\n\n option: SomeOption,\n\n value: f32,\n\n) -> Result<(), setoptionerror=\"\"> {</(),>\n\n // implementation here\n\n unimplemented!();\n\n}\n\n```\n\n```rust\n\n/// Get the value associated with the provided Rs2Option for the sensor.\n\n///\n\n/// # Arguments\n\n///\n\n/// - `option` - The option key that we want the associated value of.\n\n///\n\n/// # Returns\n\n///\n\n/// An f32 value corresponding to that option within the librealsense2 library, \n\n/// or None if the option is not supported.\n\n///\n\npub fn get_option(&self, option: Rs2Option) -> Option<f32>;</f32>\n\n```\n\nWhy is this bad?\n\n1. The Arguments section is superfluous, since the names and types of the arguments make their use self-evident. See the Arguments section above.\n\n2. The `# Returns` section isn't needed at all. First off, \"Returns\" should not be a header category; this information can be more concisely expressed in the function summary. Secondly, the return type that is there (`Option<f32>`) makes the possible return values clear already to the user. </f32>\n\nA more correct way to write this example would be:\n\n```rust\n\n/// Get the value associated with the provided `option` for the sensor,\n\n/// or `None` if no such value exists.\n\npub fn get_option(&self, option: Rs2Option) -> Option<f32>;</f32>\n\n```"
    },
    {
        "link": "https://doc.rust-lang.org/reference/items/modules.html",
        "document": "A module is a container for zero or more items.\n\nA module item is a module, surrounded in braces, named, and prefixed with the keyword . A module item introduces a new, named module into the tree of modules making up a crate.\n\nAn example of a module:\n\nModules are defined in the type namespace of the module or block where they are located.\n\nIt is an error to define multiple items with the same name in the same namespace within a module. See the scopes chapter for more details on restrictions and shadowing behavior.\n\nThe keyword is syntactically allowed to appear before the keyword, but it is rejected at a semantic level. This allows macros to consume the syntax and make use of the keyword, before removing it from the token stream.\n\nA module without a body is loaded from an external file. When the module does not have a attribute, the path to the file mirrors the logical module path.\n\nAncestor module path components are directories, and the module’s contents are in a file with the name of the module plus the extension. For example, the following module structure can have this corresponding filesystem structure:\n\nModule filenames may also be the name of the module as a directory with the contents in a file named within that directory. The above example can alternately be expressed with ’s contents in a file named . It is not allowed to have both and .\n\nThe directories and files used for loading external file modules can be influenced with the attribute.\n\nFor attributes on modules not inside inline module blocks, the file path is relative to the directory the source file is located. For example, the following code snippet would use the paths shown based on where it is located:\n\nFor attributes inside inline module blocks, the relative location of the file path depends on the kind of source file the attribute is located in. “mod-rs” source files are root modules (such as or ) and modules with files named . “non-mod-rs” source files are all other module files. Paths for attributes inside inline module blocks in a mod-rs file are relative to the directory of the mod-rs file including the inline module components as directories. For non-mod-rs files, it is the same except the path starts with a directory with the name of the non-mod-rs module. For example, the following code snippet would use the paths shown based on where it is located:\n\nAn example of combining the above rules of attributes on inline modules and nested modules within (applies to both mod-rs and non-mod-rs files):\n\nModules, like all items, accept outer attributes. They also accept inner attributes: either after for a module with a body, or at the beginning of the source file, after the optional BOM and shebang.\n\nThe built-in attributes that have meaning on a module are , , , the lint check attributes, , and . Modules also accept macro attributes."
    },
    {
        "link": "https://doc.rust-lang.org/cargo",
        "document": "Cargo is the Rust package manager. Cargo downloads your Rust package’s dependencies, compiles your packages, makes distributable packages, and uploads them to crates.io, the Rust community’s package registry. You can contribute to this book on GitHub.\n\nTo get started with Cargo, install Cargo (and Rust) and set up your first crate.\n\nThe guide will give you all you need to know about how to use Cargo to develop Rust packages.\n\nThe reference covers the details of various areas of Cargo.\n\nThe commands will let you interact with Cargo using its command-line interface.\n• Changelog — Detailed notes about changes in Cargo in each release.\n• Rust documentation website — Links to official Rust documentation and tools."
    },
    {
        "link": "https://doc.rust-lang.org/rust-by-example/cargo/deps.html",
        "document": "Most programs have dependencies on some libraries. If you have ever managed dependencies by hand, you know how much of a pain this can be. Luckily, the Rust ecosystem comes standard with ! can manage dependencies for a project.\n\nFor the rest of this chapter, let's assume we are making a binary, rather than a library, but all of the concepts are the same.\n\nAfter the above commands, you should see a file hierarchy like this:\n\nThe is the root source file for your new project -- nothing new there. The is the config file for for this project. If you look inside it, you should see something like this:\n\nThe field under determines the name of the project. This is used by if you publish the crate (more later). It is also the name of the output binary when you compile.\n\nThe field is a crate version number using Semantic Versioning.\n\nThe field is a list of authors used when publishing the crate.\n\nThe section lets you add dependencies for your project.\n\nFor example, suppose that we want our program to have a great CLI. You can find lots of great packages on crates.io (the official Rust package registry). One popular choice is clap. As of this writing, the most recent published version of is . To add a dependency to our program, we can simply add the following to our under : . And that's it! You can start using in your program.\n\nalso supports other types of dependencies. Here is just a small sampling:\n\nis more than a dependency manager. All of the available configuration options are listed in the format specification of .\n\nTo build our project we can execute anywhere in the project directory (including subdirectories!). We can also do to build and run. Notice that these commands will resolve all dependencies, download crates if needed, and build everything, including your crate. (Note that it only rebuilds what it has not already built, similar to ).\n\nVoila! That's all there is to it!"
    },
    {
        "link": "https://doc.rust-lang.org/cargo/guide/dependencies.html",
        "document": "crates.io is the Rust community’s central package registry that serves as a location to discover and download packages. is configured to use it by default to find requested packages.\n\nTo depend on a library hosted on crates.io, add it to your .\n\nIf your doesn’t already have a section, add that, then list the crate name and version that you would like to use. This example adds a dependency on the crate:\n\nThe version string is a SemVer version requirement. The specifying dependencies docs have more information about the options you have here.\n\nIf you also wanted to add a dependency on the crate, you would not need to add for each crate listed. Here’s what your whole file would look like with dependencies on the and crates:\n\nRe-run , and Cargo will fetch the new dependencies and all of their dependencies, compile them all, and update the :\n\ncontains the exact information about which revision was used for all of these dependencies.\n\nNow, if gets updated, you will still build with the same revision until you choose to run .\n\nYou can now use the library in ."
    },
    {
        "link": "https://docs.archway.io/developers/managing-dependencies",
        "document": "Read more about Cargo in the official Cargo Book\n\nHere's an overview of some common Cargo commands used in Archway projects:\n• : Compiles your project and its dependencies. Use to compile with optimizations for a production build.\n• : Runs tests for your project and its dependencies.\n• : Updates your project's dependencies according to the specified version ranges in the Cargo.toml file.\n\nCargo workspaces help manage multiple related projects within a single repository. To create and configure a workspace, add a workspace section to the Cargo.toml file, and list the project paths under the members key.\n\nThe Cargo.toml file at the root of an Archway project is called its manifest, and contains all of the metadata Cargo needs to compile the smart contract project and its dependencies. Every manifest file consists of one or more sections.\n\nThe following sections are some examples commonly found in Archway projects:\n• - The first section in a Cargo.toml is always and must include the metadata properties name and version\n• - This section is for setting your build profile. Cargo has 4 built-in profiles: dev, release, test, and bench.\n• - This section is part of the cargo-run-script module, it's where scripts are defined. If you are familiar with node, cargo-run-script brings the npm run functionality to the Rust and Cargo ecosystem\n• - Use this section for defining your project's dependencies for compilation and releases\n• - Use this section for defining your project's dependencies for examples, tests, and benchmarks\n\nCheck the Cargo book for the full list of possible sections and valid properties.\n\nCargo bakes in the concept of Semantic Versioning. It is configured to look for dependencies on crates.io by default. Only the name and a version string are required in this case.\n\nIt's recommended to follow CosmWasm development and release schedule. As fixes or new features become available, it could be advantageous or critical to update your project dependencies.\n\nThe only challenging aspect of this process is that your dependencies may have their own dependencies. If you encounter a compilation error after updating a dependency, it is likely due to a change or addition in a sub-dependency.\n\nHere's an older version of the Cargo.toml for the Increment code template:\n\nTo update the Increment Cargo.toml to use cosmwasm-std version 1.0.0-beta5, the above file becomes:\n\n# Those files are rust-optimizer artifacts. You might want to commit them for convenience but they should not be part of the source code publication. # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html # use library feature to disable all instantiate/execute/query exports\n\nAs you probably noticed, the above two examples are nearly identical, but all packages listed in the dependencies section have been changed.\n\nChanging dependencies produces different wasm output (even when there's no substantive change to the contract source code). However, it's possible to update even a deployed contract.\n\nMigrating a contract will retain its address but associate it with a new Code ID.\n\nFor example you can launch:\n\nand replace the values < contract-address>, < new-code-is>, and {\"entrypoint\":\"value\"} (which is the instantiation constructor)."
    },
    {
        "link": "https://medium.com/rustycrab/getting-started-with-cargo-rusts-essential-package-manager-85f5902c521e",
        "document": "Cargo is a command-line tool that ships with the standard installation of Rust. You can verify its installation with command. It should print its version like below.\n\nSo the question is, what can Cargo do? Let’s go through its capabilities one at a time.\n\nCargo can manage a project for us. For Cargo to work efficiently and intelligently, it needs a file at the root of the project directory. This file contains important project information such as the project’s name, version, a list of dependencies the project relies on, and other configuration settings. In the Rust universe, a project with “Cargo.toml” is called a crate.\n\nInstead of creating the file ourselves, we can ask Cargo to create a brand new project (crate) for us. We do this by using the command:\n\nThis command creates a directory in the location where it was run and places a file inside it. The file looks like the following:\n\nIn the section, it defines crate-related information such as the name of the crate, its version, and the Rust edition it uses. The section is where Cargo manages the crate’s dependencies. It’s empty at the moment since our crate doesn’t depend on any external crates yet.\n\nAlong with , Cargo also creates file. This happens because when we use command, Cargo also initializes a Git repository in the directory. If we don’t want Cargo to initialize a git repository, we can use the flag with value.\n\nIf you want to initialize a different VCS (Version Control System) repository instead of , which is the default for the flag (when you don’t provide it), you can specify another option, such as , , etc. You can also configure Cargo to always use or another VCS value by default when creating or initializing a new project. This can be done using the global Cargo configuration file, which is located at on Unix systems. The file might look like the following:\n\nIf you would like to provide a different crate name than the directory name, you can use the flag, like this: . This will create a directory with a file inside it, but the crate name will be set to .\n\nIf you already have a directory and want to initialize a Cargo project inside it, you can do so by running the command within that directory. This command will generate the same file, using the directory name as the crate name unless you provide the flag. If the directory name contains invalid characters, such as uppercase letters or hyphens, Cargo will automatically remove them from the crate name. You can also use the and flags with , just like with the command.\n\nAdditionally, you will find a directory inside the crate. This is where the source code ( files) of the crate will reside. If you look inside this directory, you’ll find a file with some boilerplate code that Cargo has generated for us. The file is the entry point of our program. It contains the following code:\n\nThis looks exactly the same as our Hello World program from the previous lesson. As we learned in that lesson, the function is a special function in Rust as it’s the first function that Rust executes. Similarly, is a special file in Rust. It is the file that Rust looks for in the crate to execute the function.\n\nNow comes the question, how do we run this program? If you remember from the previous lesson, we used the command to compile our Rust program into machine code and then executed the binary file. With Cargo, it’s even simpler. Cargo provides the subcommand to run our crate, and it automatically takes care of locating the file (which by default is inside ).\n\nWhen we run the command, Cargo starts compiling the crate using the command. In the output, it displays the name and version of the crate, as well as the location of the project on the disk. In the second line of the output, it shows that the compilation was done using the development profile, which compiles code faster but produces unoptimized code and includes debug information such as line numbers and variable names to make debugging easier. The compiled binary file will be stored inside the directory (relative to the crate directory). We’ll discuss the directory in the next section.\n\nAfter that, Cargo shows that it’s running the compiled binary located at . Just like how we executed a compiled Rust binary file in the previous lesson, does the same. It outputs the text since that’s what the function is doing.\n\nAs we learned, Cargo utilizes Rust’s compiler to compile Rust code, but its responsibilities extend to managing the builds. The command we used earlier actually performs two tasks. First, it runs the command, which compiles the code and produces the binary file. The second task is to execute this binary file (which outputs the text).\n\nLet’s remove the directory from our project and run the command.\n\nThe command compiles the crate and generates a binary executable file inside . If you look inside this directory, you will find the file (or if you are on Windows), since our crate is named . You can now run this file manually.\n\nNow, let’s build it one more time using the same command.\n\nHuh! Notice that it doesn’t output the message anymore. What’s happening? Cargo uses incremental compilation, meaning it only recompiles the parts of your code that have changed, instead of rebuilding the entire project every time you make a small modification. This is useful during development because it speeds up builds, although it can sometimes result in a slightly less optimized binary. These incremental build artifacts are stored in the directory.\n\nCargo also employs a fingerprinting system to decide whether or not to recompile a crate, storing these fingerprints in the directory. It computes the fingerprint based on the source file contents, dependencies, build configurations (such as build flags, profiles, etc.), and compiler settings (such as optimization level, debug info, etc.). If none of these elements have changed, Cargo skips recompilation. That’s exactly what’s happening here. On subsequent commands, Cargo doesn’t recompile the crate because there are no changes to the source code, dependencies (which we don’t have yet), or build configurations.\n\nHence the executable binary file at never recompiles. The reason Cargo places the file inside the directory is because the default build profile used with the command is . A build profile in Rust is a set of predefined compilation settings in Cargo that control optimization levels, debug information, and other compiler behaviors to suit different stages of development or production. Cargo comes with and profiles built in.\n\nFor profile, the optimization level is ( ) which basically means no binary optimization, it generates debug information ( ) and uses incremental builds ( ). On the other hand, the profile has highest optimization level ( ), it doesn’t output debug information ( ) and doesn’t use incremental builds ( ).\n\nIf you want to produce builds for release, such as when distributing your software or running it in a production environment, you should use the profile. To use the profile, simply add the flag to the or command.\n\nWith the profile, Cargo outputs the compiled binary file at , along with other files inside the directory.\n\nIf you would like to modify the configuration of the or profile, you can do so by using the or section in the file, as shown below:\n\nWith this change, we configure the profile to use incremental builds. This will make release builds faster since the entire crate doesn’t need to be recompiled. However, this comes at the cost of generating a less optimized binary, which may not run as fast.\n\nApart from the , , and settings, there are many more fields in a Cargo profile that can be configured. You can view the full list here. Instead of modifying an existing profile, you can also define a custom profile in the file.\n\nIn this example, we inherit all settings from the profile and override the to produce an optimized binary during development. To use this custom profile, you need to pass the flag with the or command.\n\nThis will create an optimized binary, as indicated in the output logs, but injecting the debug information since the new profile inherits from the profile, which has set to . The binary will be placed inside the directory.\n\nWhen working on a real-world project, we want to focus on writing code that addresses the business logic specific to our project requirements. For low-level tasks such as creating/managing network traffic, handling disk operations, or image processing — or even for high-level tasks like date and time manipulation — we can rely on open-source or proprietary software libraries.\n\nLike NPM for Node.js or Maven for Java, Cargo uses the crates.io registry to host Rust crates. Anyone can upload or download crates from this registry using commands. But before we move on to installing a crate from , let’s first understand how to import a crate into our program and use it.\n\nIn the we still gonna use our good old Hello World program but we have a new statement at the top of the file. The statement imports the macro from crate. The crate (also called Rust standard library) comes with standard Rust installation, so we don’t need to install it manually using Cargo.\n\nThe keyword in Rust brings something from a package into scope. A scope could be a file or a module (we will discuss modules in a separate lesson). We use the notation to access elements inside a package. For example, here we are accessing the macro from the crate. The statement brings the macro into scope, allowing us to use directly. If you prefer not to bring into scope, you could also use , but the former is simpler.\n\nBut hang on, earlier we didn’t have to write the statement at the top of the file. So what’s going on?\n\nThe answer is the prelude. A prelude is a collection of commonly used functions, macros, types, and traits from the crate that are automatically brought into scope by Rust, so we don’t need to explicitly use the statement for them. The macro is part of the prelude, which is why we didn’t have to bring it into scope manually in earlier examples.\n\nLet’s do something interesting that is not part of the prelude.\n\nIn the program above, we are bringing the module into scope. A module in Rust is a way to group related code (such as functions) into a namespace to organize functionality and avoid naming conflicts. The module contains functions that let us read or write files on disk easily. Here, we are using the function from the fs module to read a file’s content from the disk as a human-readable string.\n\nThe function returns a enum (which can contain either the file content as a string or an error), which is why we call the function to ignore the error and get the string content. We store this content inside the variable, which we define using the keyword. Then, we print this content to the screen using the macro. The part in the macro substitutes the content of the variable.\n\nNow, let’s use a crate that doesn’t come with Rust’s standard installation. Working with dates in Rust can be quite difficult since the Rust standard library ( ) doesn’t provide direct support for formatting or handling human-readable dates. One crate that makes this easier is . You can visit its documentation on . The current version, as of writing this lesson, is .\n\nThere are two ways we can download this crate using Cargo. The first way is to manually add under the section of the file:\n\nRust provides great IDE support. As soon as we add this entry to , it automatically downloads and installs the crate.\n\nThe second way is to use the command, which allows us to install a crate directly from the command line without manually modifying . For example:\n\nAfter the successful installation, this command also modifies the file to include the entry under [dependencies].\n\nCargo generates a file to track the exact versions of dependencies and indirect dependencies (dependencies of dependencies) to ensure that builds are reproducible. You should always check in this file to your version control system (VCS), so that Cargo can use it to download the exact versions of dependencies on your team members’ devices, CI/CD platforms, or production environments.\n\nYou don’t need to run a separate command to install dependencies. Cargo automatically downloads and installs the dependencies listed in with the help of when you run or .\n\nNow that the crate is downloaded and ready to be used, let’s write a simple program to make use of it. We will create a program to print the current date in a human-readable format. Achieving this with Rust’s standard library can be quite difficult, so let’s see how can help us out.\n\nTo get the current local datetime using , we need to call the associated function provided by the struct (we will talk about structs in a separate lesson). Since Rust doesn’t know where is located, we need to bring it into scope using the statement (we could also use without bringing it into scope). The expression returns a struct, which we then store in the variable. The struct has a method that takes a string template and returns a human-readable date accordingly.\n\nCargo follows the Semantic Versioning (SemVer) strategy to download and manage dependencies. When you use the command or manually add dependencies in , Cargo retrieves those dependencies from and installs them according to the version constraints you specify, along with any indirect dependencies that those crates require. Cargo keeps track of the exact versions installed in the file to ensure reproducible builds. You can use the command to visualize the dependency graph of your project.\n\nLet’s see how Cargo resolves dependencies with an example. Suppose our crate depends on a hypothetical crate, , and every possible version of exists on the registry. In this case, Cargo will download version ( ), as that is the highest compatible version it can download according to SemVer rules, ensuring no breaking changes are introduced.\n\nNow let’s say that our crate depends on and , and they internally depend on and , respectively. Cargo will attempt to use the highest compatible version of for both and , which could be . However, if our crate directly depends on , this would create a conflict because Cargo cannot resolve both and versions simultaneously. In this case, Cargo would give us an error due to the version incompatibility.\n\nThe recommended solution is to update dependencies to the latest or an appropriate version. You can also rename a dependency in so that two versions of the same crate can act as different crates, but this should be avoided unless absolutely necessary. You can read more about this here.\n\nCargo also allows us to publish crates to crates.io. Since we are working on a project created by Cargo, which is itself a crate, publishing it to is as simple as running and . However, the important part isn’t the publishing process, but rather how we structure the project, what we expose, and how we write the documentation. Towards the end of our Rust learning journey, we will work on a couple of crates and publish them on .\n\nCargo can also generate documentation for our projects using documentation comments, or doc comments ( ). Cargo supports Markdown, which means we can use Markdown syntax within our documentation comments. Let’s modify our earlier example and add some doc comments.\n\nHere, we have extracted the date formatting logic into its own function . This function takes an argument of type and returns a human-readable text so that we can print it to using the macro we are familiar with. Logically, nothing major has changed, but we added some doc comments to the function.\n\nBy using , we instruct Cargo to treat the comments as documentation that will be included when generating docs for the project. First, we provide a summary of what the function does. Then, in the section, we describe the parameters of the function. Optionally, we can add a section to explain what the function returns (if applicable). We also give an example of how to use the function in the section. Since Cargo documentation supports Markdown, we are free to use it wherever necessary, though there is a general convention you can follow, as described in the Rust documentation guide.\n\nThis documentation is also utilized by IDEs to provide in-line information about what a function (or other items) are supposed to do, offering clear insights without needing to navigate to the official documentation of the crate. Since I’m using VSCode, here’s how the function appears in the IDE:"
    }
]