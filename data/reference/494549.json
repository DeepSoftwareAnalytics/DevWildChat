[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilitychange_event",
        "document": "The event doesn't include the document's updated visibility status, but you can get that information from the document's property.\n\nThis event fires with a of when a user navigates to a new page, switches tabs, closes the tab, minimizes or closes the browser, or, on mobile, switches from the browser to a different app. Transitioning to is the last event that's reliably observable by the page, so developers should treat it as the likely end of the user's session (for example, for sending analytics data).\n\nThe transition to is also a good point at which pages can stop making UI updates and stop any tasks that the user doesn't want to have running in the background."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API",
        "document": "The Page Visibility API provides events you can watch for to know when a document becomes visible or hidden, as well as features to look at the current visibility state of the page. This is especially useful for saving resources and improving performance by letting a page avoid performing unnecessary tasks when the document isn't visible.\n\nWhen the user minimizes the window, switches to another tab, or the document is entirely obscured by another window, the API sends a event to let listeners know the state of the page has changed. You can detect the event and perform some actions or behave differently. For example, if your web app is playing a video, it can pause the video when the user puts the tab into the background, and resume playback when the user returns to the tab. The user doesn't lose their place in the video, the video's soundtrack doesn't interfere with audio in the new foreground tab, and the user doesn't miss any of the video in the meantime. Visibility states of an are the same as the parent document. Hiding an using CSS properties (such as ) doesn't trigger visibility events or change the state of the document contained within the frame.\n\nLet's consider a few use cases for the Page Visibility API.\n• A site has an image carousel that shouldn't advance to the next slide unless the user is viewing the page\n• An application showing a dashboard of information doesn't want to poll the server for updates when the page isn't visible\n• A site wants to switch off sounds when a device is in standby mode (user pushes power button to turn screen off) Developers have historically used imperfect proxies to detect this. For example, watching for and events on the window helps you know when your page is not the active page, but it does not tell you that your page is actually hidden to the user. The Page Visibility API addresses this. Note: While and will tell you if the user switches windows, it doesn't necessarily mean it's hidden. Pages only become hidden when the user switches tabs or minimizes the browser window containing the tab.\n\nSeparately from the Page Visibility API, user agents typically have a number of policies in place to mitigate the performance impact of background or hidden tabs. These may include:\n• Most browsers stop sending callbacks to background tabs or hidden s in order to improve performance and battery life.\n• Timers such as are throttled in background/inactive tabs to help improve performance. See Reasons for delays longer than specified for more details.\n• Browsers implement budget-based background timeout throttling. This operates in a similar way across modern browsers, with the details being as follows:\n• In Firefox, windows in background tabs each have their own time budget in milliseconds — a max and a min value of +50 ms and -150 ms, respectively. Chrome is very similar except that the budget is specified in seconds.\n• Windows are subjected to throttling after 30 seconds, with the same throttling delay rules as specified for window timers (again, see Reasons for delays longer than specified). In Chrome, this value is 10 seconds.\n• Timer tasks are only permitted when the budget is non-negative.\n• Once a timer's code has finished running, the duration of time it took to execute is subtracted from its window's timeout budget.\n• The budget regenerates at a rate of 10 ms per second, in both Firefox and Chrome. Some processes are exempt from this throttling behavior. In these cases, you can use the Page Visibility API to reduce the tabs' performance impact while they're hidden.\n• Tabs which are playing audio are considered foreground and aren't throttled.\n• Tabs running code that's using real-time network connections (WebSockets and WebRTC) go unthrottled in order to avoid closing these connections timing out and getting unexpectedly closed.\n• IndexedDB processes are also left unthrottled in order to avoid timeouts.\n\nThe Page Visibility API adds the following properties to the interface: Returns if the page is in a state considered to be hidden to the user, and otherwise. A string indicating the document's current visibility state. Possible values are: The page content may be at least partially visible. In practice this means that the page is the foreground tab of a non-minimized window. The page's content is not visible to the user, either due to the document's tab being in the background or part of a window that is minimized, or because the device's screen is off."
    },
    {
        "link": "https://developer.mozilla.org/en-US/blog/using-the-page-visibility-api",
        "document": "Checking document visibility gives you insight into how visitors are interacting with your pages and can provide hints about the status of your applications. The Page Visibility API lets you find out the visibility of a page and set up event listeners to do something when page visibility changes. Let's look at what page visibility means, how you can use this API, and some common pitfalls to avoid.\n\nInitially, the Page Visibility API was developed as a independent specification, but it's been incorporated directly into the HTML spec under Page visibility. This API exposes a way to determine a document's visibility state so you can check if a web page is \"visible\" or \"hidden\". This sounds straightforward, but pages can be \"hidden\" in several different ways. A page is \"hidden\" if the browser window with the page is minimized, if it's completely obscured by another application, or the user switches to another tab. Page visibility also changes to \"hidden\" if the operating system's screen lock is activated, so mobile device behavior is also taken into consideration. By contrast, a page remains \"visible\" even when it's partially visible on the screen.\n\nHow to check page visibility changes You can check the visibility of a document using , which will return either or . Alternatively, you can check the value of the Boolean property: In practice, it's convenient to use the event so you can trigger logic when the visibility state of a page changes instead of checking the visibility manually: When the state changes, you can check the page visibility and then do something depending on the result: document.addEventListener(\"visibilitychange\", () => { if (document.hidden) { // do something if the page visibility changes to hidden } else { // do something if the page visibility changes to visible } }); It's worth noting that there's no , so if you're only interested in that state, you can use (or ): document.addEventListener(\"visibilitychange\", () => { if (document.visibilityState === \"visible\") { // The page is visible again! } });\n\nThe ability to determine page visibility opens up the opportunity to stop doing something when the visitor is no longer viewing the page. This capability is really powerful considering that it allows us to manage client (or even server) resources in a conscious way. When it comes to managing resources, browsers play a significant role in this with features like tab unloading and optimizing what background tabs are doing. We can still shift the solution left by looking at how we build web applications. This allows us to include checks for efficiency earlier in the development cycle or make conscious performance improvements in areas that browsers don't automatically handle. There's an excellent opportunity to use smaller bitrate video, or to throttle or pause network activity if regular real-time communication (WebSockets and WebRTC) happens with a server. IndexedDB processes can be optimized as browsers don't throttle these connections to avoid timeouts. You can find more information about what browsers handle in the \"Policies in place to aid background page performance\" section on the Page Visibility API page.\n\nWhen the page changes from to , we could assume that a visitor has returned to our page, so we can restart anything that we may have paused when the page was hidden. However, there are a few logical traps, especially concerning media, that you could fall into. Therefore, you need to be careful when resuming actions in such cases. We'll look at examples of this in detail in the next section.\n\nGiving people control over when to start, resume, and skip media is essential for the usability of your pages, so this API should be used with caution to ensure your visitors have agency while browsing. You also shouldn't presume that visitors want media to be paused automatically when a page is hidden. Exposing a user preference or allowing visitors to opt-in to this kind of functionality is highly recommended. There used to be a code snippet on MDN on the page that was a good example of how this API can cause usability issues. Can you spot what the problem is in the JavaScript code below? In the HTML, there is an element with controls visible so the user can start and stop the media. In JavaScript, we're looking at the event and doing the following:\n• If the page is hidden, pause the audio.\n• If the page is shown, play the audio. This sounds reasonable at first, but we encounter issues such as audio autoplaying when the user switches to another tab and back again or when restoring a browser window after it's been minimized. The point is that page visibility may toggle between and without the user ever interacting with the element. This situation becomes even more surprising and distracting if the element is located below the page fold and is not visible when the page loads. You might unintentionally prompt your users to search for tabs where audio is playing and lead them to a place where it's not obvious what is playing, which can be extremely frustrating. To avoid usability issues, it's always a good idea to see if people have interacted with the media before resuming playback. One way of doing this is to store the state of the audio player when the page is hidden. When the page visibility changes to again, we resume media playback only if it was playing when the page was hidden. Let's modify the event listener to store the audio state on page hide. A boolean variable is sufficient for this purpose; we can set it when the document's visibility changes to : // Initialize as false; we're not auto playing audio when the page loads let playingOnHide = false; document.addEventListener(\"visibilitychange\", () => { if (document.hidden) { // Page changed to \"hidden\" state, store if audio playing playingOnHide = !audio.paused; // Pause audio if page is hidden audio.pause(); } }); As with , there is no state, so we have to check (not paused) instead. That means the Boolean can be set to whatever the value of is on page hide, and we're pretty much done. The only other state the visibility of the page can be is , so in the statement, we handle the playing logic: let playingOnHide = false; document.addEventListener(\"visibilitychange\", () => { if (document.hidden) { playingOnHide = !audio.paused; audio.pause(); } else { // Page became visible! Resume playing if audio was \"playing on hide\" if (playingOnHide) { audio.play(); } } }); The finished code looks like this with a neat little gate for checking the audio state on page hide: const audio = document.querySelector(\"audio\"); let playingOnHide = false; document.addEventListener(\"visibilitychange\", () => { if (document.hidden) { playingOnHide = !audio.paused; audio.pause(); } else { if (playingOnHide) { audio.play(); } } });\n\nI hope you enjoyed this post about page visibility and why I think it opens up interesting opportunities for resource management, analytics, UX, and other use cases. I'm looking forward to hearing your thoughts on different ways to use this API and what other efficiency gains developers can make use of that browsers don't handle well. Are there any other patterns that developers should avoid when using this API? Feel free to get in touch with us and let us know what you think or if I've missed something!"
    },
    {
        "link": "https://stackoverflow.com/questions/77991557/browser-visibilitychange-event-no-longer-fired-on-page-navigation",
        "document": "The MDN docs say that the event\n\nWhile I recall having experience with this being true, it looks like it isn't anymore (at least not on either Chrome or Firefox). I'm currently on desktop Chrome Version 121.0.6167.160\n\nTo reproduce, if I look at the end-of-session analytics example and basically copy-paste the function into the browser console like\n\nthen I'll see \"hidden\" and \"visible\" logged to the console as I switch between open tabs. However, if I then click a random link that takes me to another page, nothing is logged and so I'm left to assume that the visibilitychange event is not firing in this case (the preserve-log option is checked in the dev console).\n\nAnd just as an ultra-sanity check, the same behavior happens if I replace the console log with an actual sendbeacon request.\n\nIt sounds unlikely that a browser bug was pushed since it's happening in both chrome and firefox, so what am I missing / not understanding here?"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilityState",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 .\n\nThe read-only property returns the visibility of the document. It can be used to check whether the document is in the background or in a minimized window, or is otherwise not visible to the user.\n\nWhen the value of this property changes, the event is sent to the .\n\nThe property provides an alternative way to determine whether the page is hidden."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilitychange_event",
        "document": "The event doesn't include the document's updated visibility status, but you can get that information from the document's property.\n\nThis event fires with a of when a user navigates to a new page, switches tabs, closes the tab, minimizes or closes the browser, or, on mobile, switches from the browser to a different app. Transitioning to is the last event that's reliably observable by the page, so developers should treat it as the likely end of the user's session (for example, for sending analytics data).\n\nThe transition to is also a good point at which pages can stop making UI updates and stop any tasks that the user doesn't want to have running in the background."
    },
    {
        "link": "https://developer.mozilla.org/en-US/blog/using-the-page-visibility-api",
        "document": "Checking document visibility gives you insight into how visitors are interacting with your pages and can provide hints about the status of your applications. The Page Visibility API lets you find out the visibility of a page and set up event listeners to do something when page visibility changes. Let's look at what page visibility means, how you can use this API, and some common pitfalls to avoid.\n\nInitially, the Page Visibility API was developed as a independent specification, but it's been incorporated directly into the HTML spec under Page visibility. This API exposes a way to determine a document's visibility state so you can check if a web page is \"visible\" or \"hidden\". This sounds straightforward, but pages can be \"hidden\" in several different ways. A page is \"hidden\" if the browser window with the page is minimized, if it's completely obscured by another application, or the user switches to another tab. Page visibility also changes to \"hidden\" if the operating system's screen lock is activated, so mobile device behavior is also taken into consideration. By contrast, a page remains \"visible\" even when it's partially visible on the screen.\n\nHow to check page visibility changes You can check the visibility of a document using , which will return either or . Alternatively, you can check the value of the Boolean property: In practice, it's convenient to use the event so you can trigger logic when the visibility state of a page changes instead of checking the visibility manually: When the state changes, you can check the page visibility and then do something depending on the result: document.addEventListener(\"visibilitychange\", () => { if (document.hidden) { // do something if the page visibility changes to hidden } else { // do something if the page visibility changes to visible } }); It's worth noting that there's no , so if you're only interested in that state, you can use (or ): document.addEventListener(\"visibilitychange\", () => { if (document.visibilityState === \"visible\") { // The page is visible again! } });\n\nThe ability to determine page visibility opens up the opportunity to stop doing something when the visitor is no longer viewing the page. This capability is really powerful considering that it allows us to manage client (or even server) resources in a conscious way. When it comes to managing resources, browsers play a significant role in this with features like tab unloading and optimizing what background tabs are doing. We can still shift the solution left by looking at how we build web applications. This allows us to include checks for efficiency earlier in the development cycle or make conscious performance improvements in areas that browsers don't automatically handle. There's an excellent opportunity to use smaller bitrate video, or to throttle or pause network activity if regular real-time communication (WebSockets and WebRTC) happens with a server. IndexedDB processes can be optimized as browsers don't throttle these connections to avoid timeouts. You can find more information about what browsers handle in the \"Policies in place to aid background page performance\" section on the Page Visibility API page.\n\nWhen the page changes from to , we could assume that a visitor has returned to our page, so we can restart anything that we may have paused when the page was hidden. However, there are a few logical traps, especially concerning media, that you could fall into. Therefore, you need to be careful when resuming actions in such cases. We'll look at examples of this in detail in the next section.\n\nGiving people control over when to start, resume, and skip media is essential for the usability of your pages, so this API should be used with caution to ensure your visitors have agency while browsing. You also shouldn't presume that visitors want media to be paused automatically when a page is hidden. Exposing a user preference or allowing visitors to opt-in to this kind of functionality is highly recommended. There used to be a code snippet on MDN on the page that was a good example of how this API can cause usability issues. Can you spot what the problem is in the JavaScript code below? In the HTML, there is an element with controls visible so the user can start and stop the media. In JavaScript, we're looking at the event and doing the following:\n• If the page is hidden, pause the audio.\n• If the page is shown, play the audio. This sounds reasonable at first, but we encounter issues such as audio autoplaying when the user switches to another tab and back again or when restoring a browser window after it's been minimized. The point is that page visibility may toggle between and without the user ever interacting with the element. This situation becomes even more surprising and distracting if the element is located below the page fold and is not visible when the page loads. You might unintentionally prompt your users to search for tabs where audio is playing and lead them to a place where it's not obvious what is playing, which can be extremely frustrating. To avoid usability issues, it's always a good idea to see if people have interacted with the media before resuming playback. One way of doing this is to store the state of the audio player when the page is hidden. When the page visibility changes to again, we resume media playback only if it was playing when the page was hidden. Let's modify the event listener to store the audio state on page hide. A boolean variable is sufficient for this purpose; we can set it when the document's visibility changes to : // Initialize as false; we're not auto playing audio when the page loads let playingOnHide = false; document.addEventListener(\"visibilitychange\", () => { if (document.hidden) { // Page changed to \"hidden\" state, store if audio playing playingOnHide = !audio.paused; // Pause audio if page is hidden audio.pause(); } }); As with , there is no state, so we have to check (not paused) instead. That means the Boolean can be set to whatever the value of is on page hide, and we're pretty much done. The only other state the visibility of the page can be is , so in the statement, we handle the playing logic: let playingOnHide = false; document.addEventListener(\"visibilitychange\", () => { if (document.hidden) { playingOnHide = !audio.paused; audio.pause(); } else { // Page became visible! Resume playing if audio was \"playing on hide\" if (playingOnHide) { audio.play(); } } }); The finished code looks like this with a neat little gate for checking the audio state on page hide: const audio = document.querySelector(\"audio\"); let playingOnHide = false; document.addEventListener(\"visibilitychange\", () => { if (document.hidden) { playingOnHide = !audio.paused; audio.pause(); } else { if (playingOnHide) { audio.play(); } } });\n\nI hope you enjoyed this post about page visibility and why I think it opens up interesting opportunities for resource management, analytics, UX, and other use cases. I'm looking forward to hearing your thoughts on different ways to use this API and what other efficiency gains developers can make use of that browsers don't handle well. Are there any other patterns that developers should avoid when using this API? Feel free to get in touch with us and let us know what you think or if I've missed something!"
    },
    {
        "link": "https://stackoverflow.com/questions/28993157/visibilitychange-event-is-not-triggered-when-switching-program-window-with-altt",
        "document": "Here's a roundup post I wrote for this issue and a workaround in pure JavaScript to solve the encountered problems.\n\nEdited to include a copy of the sourced blog post:\n\nIn any kind of javascript application we develop there may be a feature or any change in the application which reacts according to the current user visibility state, this could be to pause a playing video when the user ALT+TABs to a different window, tracking stats about how the users interact with our application, how often does him switch to a different tab, how long does it take him to return and a lot of performance improvements that can benefit from this kind of API.\n\nThe Page Visibility API provides us with two top-level attributes: document.hidden (boolean) and document.visibilityState (which could be any of these strings: “hidden”, “visible”, “prerender”, “unloaded”). This would not be not good enough without an event we could listen to though, that’s why the API also provides the useful visibilitychange event.\n\nSo, here’s a basic example on how we could take action on a visibility change:\n\nWe could also check for document.visibilityState value.\n\nSome of the implementations on some browsers still need that the attributes or even the event name is vendor-prefixed, this means we may need to listen to the msvisibilitychange event or check for the document.webkitHidden or the document.mozHidden attributes. In order to do so, we should check if any vendor-prefixed attribute is set, and once we know which one is the one used in the current browser (only if there’s the need for a prefix), we can name the event and attributes properly.\n\nHere’s an example approach on how to handle these prefixes:\n\nOther issues There is a challenging issue around the “Page Visibility” definition: how to determine if the application is visible or not if the window focus is lost for another window, but not the actual visibility on the screen? what about different kinds of visibility lost, like ALT+TAB, WIN/MAC key (start menu / dash), taskbar/dock actions, WIN+L (lock screen), window minimize, window close, tab switching. What about the behaviour on mobile devices?\n\nThere’s lots of ways in which we may lose or gain visibility and a lot of possible interactions between the browser and the OS, therefore I don’t think there’s a proper and complete “visible page” definition in the W3C spec. This is the definition we get for the document.hidden attribute:\n\nHIDDEN ATTRIBUTE On getting, the hidden attribute MUST return true if the Document contained by the top level browsing context (root window in the browser’s viewport) [HTML5] is not visible at all. The attribute MUST return false if the Document contained by the top level browsing context is at least partially visible on at least one screen.\n\nIf the defaultView of the Document is null, on getting, the hidden attribute MUST return true.\n\nTo accommodate accessibility tools that are typically full screen but still show a view of the page, when applicable, this attribute MAY return false when the User Agent is not minimized but is fully obscured by other applications.\n\nI’ve found several inconsistencies on when the event is actually fired, for example (Chrome 41.0.2272.101 m, on Windows 8.1) the event is not fired when I ALT+TAB to a different window/program nor when I ALT+TAB again to return, but it IS fired if I CTRL+TAB and then CTRL+SHIFT+TAB to switch between browser tabs. It’s also fired when I click on the minimize button, but it’s not fired if the window is not maximized and I click my editor window which is behing the browser window. So the behaviour of this API and it’s different implementations are still obscure.\n\nA workaround for this, is to compensate taking advantage of the better implemented focus and blur events, and making a custom approach to the whole “Page Visibility” issue using an internal flag to prevent multiple executions, this is what I’ve come up with:\n\nI welcome any feedback on this workaround. Some other great sources for ideas on this subject:\n\nUsing the Page Visibility API Using PC Hardware more efficiently in HTML5: New Web Performance APIs, Part 2 Introduction to the Page Visibility API Conclusion The technologies of the web are continuously evolving, we’re still recovering from a dark past where tables where the markup king, where semantics didn’t mattered, and they weren’t any standards around how a browser should render a page.\n\nIt’s important we push these new standards forward, but sometimes our development requirements make us still need to adapt to these kind of transitions, by handling vendor prefixes, testing in different browsers and differents OSs or depend on third-party tools to properly identify this differences.\n\nWe can only hope for a future where the W3C specifications are strictly revised, strictly implemented by the browser developer teams, and maybe one day we will have a common standard for all of us to work with.\n\nAs for the Page Visibility API let’s just kinda cite George Berkeley and say that:"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API",
        "document": "The Page Visibility API provides events you can watch for to know when a document becomes visible or hidden, as well as features to look at the current visibility state of the page. This is especially useful for saving resources and improving performance by letting a page avoid performing unnecessary tasks when the document isn't visible.\n\nWhen the user minimizes the window, switches to another tab, or the document is entirely obscured by another window, the API sends a event to let listeners know the state of the page has changed. You can detect the event and perform some actions or behave differently. For example, if your web app is playing a video, it can pause the video when the user puts the tab into the background, and resume playback when the user returns to the tab. The user doesn't lose their place in the video, the video's soundtrack doesn't interfere with audio in the new foreground tab, and the user doesn't miss any of the video in the meantime. Visibility states of an are the same as the parent document. Hiding an using CSS properties (such as ) doesn't trigger visibility events or change the state of the document contained within the frame.\n\nLet's consider a few use cases for the Page Visibility API.\n• A site has an image carousel that shouldn't advance to the next slide unless the user is viewing the page\n• An application showing a dashboard of information doesn't want to poll the server for updates when the page isn't visible\n• A site wants to switch off sounds when a device is in standby mode (user pushes power button to turn screen off) Developers have historically used imperfect proxies to detect this. For example, watching for and events on the window helps you know when your page is not the active page, but it does not tell you that your page is actually hidden to the user. The Page Visibility API addresses this. Note: While and will tell you if the user switches windows, it doesn't necessarily mean it's hidden. Pages only become hidden when the user switches tabs or minimizes the browser window containing the tab.\n\nSeparately from the Page Visibility API, user agents typically have a number of policies in place to mitigate the performance impact of background or hidden tabs. These may include:\n• Most browsers stop sending callbacks to background tabs or hidden s in order to improve performance and battery life.\n• Timers such as are throttled in background/inactive tabs to help improve performance. See Reasons for delays longer than specified for more details.\n• Browsers implement budget-based background timeout throttling. This operates in a similar way across modern browsers, with the details being as follows:\n• In Firefox, windows in background tabs each have their own time budget in milliseconds — a max and a min value of +50 ms and -150 ms, respectively. Chrome is very similar except that the budget is specified in seconds.\n• Windows are subjected to throttling after 30 seconds, with the same throttling delay rules as specified for window timers (again, see Reasons for delays longer than specified). In Chrome, this value is 10 seconds.\n• Timer tasks are only permitted when the budget is non-negative.\n• Once a timer's code has finished running, the duration of time it took to execute is subtracted from its window's timeout budget.\n• The budget regenerates at a rate of 10 ms per second, in both Firefox and Chrome. Some processes are exempt from this throttling behavior. In these cases, you can use the Page Visibility API to reduce the tabs' performance impact while they're hidden.\n• Tabs which are playing audio are considered foreground and aren't throttled.\n• Tabs running code that's using real-time network connections (WebSockets and WebRTC) go unthrottled in order to avoid closing these connections timing out and getting unexpectedly closed.\n• IndexedDB processes are also left unthrottled in order to avoid timeouts.\n\nThe Page Visibility API adds the following properties to the interface: Returns if the page is in a state considered to be hidden to the user, and otherwise. A string indicating the document's current visibility state. Possible values are: The page content may be at least partially visible. In practice this means that the page is the foreground tab of a non-minimized window. The page's content is not visible to the user, either due to the document's tab being in the background or part of a window that is minimized, or because the device's screen is off."
    },
    {
        "link": "https://blog.sachinchaurasiya.dev/how-the-page-visibility-api-improves-web-performance-and-user-experience",
        "document": "Making web applications fast and user-friendly is very important today. One useful tool for this is the Page Visibility API. This API tells developers if a web page is visible to the user or hidden in the background. It helps manage resources better and improve user interactions. In this article, we'll look at what the Page Visibility API is, why it matters, how to use it, some example use cases, and how to integrate it with ReactJS.\n\nWhat is the Page Visibility API?\n\nThe Page Visibility API is a web tool that lets developers check if a web page is visible or hidden. It has properties and events that notify when a page becomes visible or hidden, so developers can change how the app behaves.\n• None : This property shows if the document is visible or not. Possible values include:\n• None : The page is visible to the user.\n• None : The page is not visible to the user.\n• None Event: This event occurs whenever the document's visibility state changes.\n\nWhy Use the Page Visibility API?\n\nWhen a web page is not visible, it's smart to reduce or stop heavy tasks like animations, video playback, or data polling. This saves CPU and battery life, especially on mobile devices.\n\nBy knowing when a user is not looking at the page, you can pause things like video playback or game animations. This way, the user won't miss any content. When the user comes back, you can resume these activities, making the experience smooth.\n\nTracking visibility changes helps gather more accurate usage data. Knowing when users switch tabs or minimize windows provides better insights into user behavior.\n\nHow to Use the Page Visibility API?\n\nUsing the Page Visibility API in plain JavaScript is simple. Here’s a basic example\n\nIn this example, an event listener is attached to the event. Depending on the visibility state, appropriate actions are taken.\n\nUsing the Page Visibility API with ReactJS\n\nTo use the Page Visibility API in a React application, you can create a custom hook that encapsulates the logic.\n\nYou can then use this custom hook within a React component\n\nThis approach ensures that your React components can respond to visibility changes efficiently, improving the overall user experience.\n\nPlatforms like YouTube and Netflix use the Page Visibility API to pause videos when users switch tabs or minimize the browser. This way, users don't miss any content and it saves bandwidth and system resources.\n\nOnline games can pause the game when the tab is not active. This prevents users from losing progress or missing important events in the game. It also helps save system resources and improve performance.\n\nWeb applications that often fetch data from a server can slow down or stop polling when the page is not visible. This cuts down on unnecessary network requests and uses resources more efficiently.\n\nWhen using the Page Visibility API, make sure that any paused activities resume efficiently. Avoid unnecessary state changes and resource loading to maintain good performance.\n\nAlways include error-handling mechanisms to manage unexpected issues or browser limitations. This helps maintain a smooth user experience, even in rare cases.\n\nConsider letting users know when activities are paused because of visibility changes, especially for important tasks like video calls or gaming. This transparency can boost user trust and satisfaction.\n\nThe Page Visibility API helps make web apps better by adjusting to the user's focus. With this API, developers can improve performance, enhance user experience, and get accurate analytics. Whether you're using plain JavaScript or React, the Page Visibility API is very useful for modern web development.\n\nThat's all for this topic. Thank you for reading! If you found this article helpful, please consider liking, commenting, and sharing it with others.\n• None Can I use: Browser Support for Page Visibility API"
    }
]