[
    {
        "link": "https://stackoverflow.com/questions/40449434/mocking-globals-in-jest",
        "document": "Is there any way in Jest to mock global objects, such as , or *? I've pretty much given up on this, and left it up to a series of mockable utility methods. For example:\n\nTesting this tiny function is simple, but crufty and not deterministic at all. I can get 75% of the way there, but this is about as far as I can go:\n\nOn the other hand, if I am okay with this indirection, I can now access via these utilities:\n\n...and deterministically test like this...\n\nOut of all the testing frameworks I've used, Jest feels like the most complete solution, but any time I write awkward code just to make it testable, I feel like my testing tools are letting me down.\n\nIs this the only solution or do I need to add Rewire?"
    },
    {
        "link": "https://jestjs.io/docs/jest-object",
        "document": "The object is automatically in scope within every test file. The methods in the object help create mocks and let you control Jest's overall behavior. It can also be imported explicitly by via .\n\nAfter is called, all s will return the real versions of each module (rather than a mocked version).\n\nThis is usually useful when you have a scenario where the number of dependencies you want to mock is far less than the number of dependencies that you don't. For example, if you're writing a test for a module that uses a large number of dependencies that can be reasonably classified as \"implementation details\" of the module, then you likely do not want to mock them.\n\nExamples of dependencies that might be considered \"implementation details\" are things ranging from language built-ins (e.g. methods) to highly common utility methods (e.g. , , array utilities, etc) and entire libraries like .\n\nGiven the name of a module, use the automatic mocking system to generate a mocked version of the module for you.\n\nThis is useful when you want to create a manual mock that extends the automatic mock's behavior:\n\nThis is how will mock the following data types:\n\nCreates a new mock function. The new function has no formal parameters and when called will return . This functionality also applies to functions.\n\nCreates a new class. The interface of the original class is maintained, all of the class member functions and properties will be mocked.\n\nCreates a new deeply cloned object. The object keys are maintained and their values are mocked.\n\nCreates a new property with the same primitive value as the original property.\n\nMocks a module with an auto-mocked version when it is being required. and are optional. For example:\n\nThe second argument can be used to specify an explicit module factory that is being run instead of using Jest's automocking feature:\n\nWhen using the parameter for an ES6 module with a default export, the property needs to be specified. This property is normally generated by Babel / TypeScript, but here it needs to be set manually. When importing a default export, it's an instruction to import the property named from the export object:\n\nThe third argument can be used to create virtual mocks – mocks of modules that don't exist anywhere in the system:\n\nModules that are mocked with are mocked only for the file that calls . Another file that imports the module will get the original implementation even if it runs after the test file that mocks the module.\n\nSee TypeScript Usage chapter of Mock Functions page for documentation.\n\nSee TypeScript Usage chapter of Mock Functions page for documentation.\n\nIndicates that the module system should never return a mocked version of the specified module from (e.g. that it should always return the real module).\n\nThe most common use of this API is for specifying the module a given test intends to be testing (and thus doesn't want automatically mocked).\n\nIndicates that the module system should never return a mocked version of the specified module and its dependencies.\n\nWhen using , calls to will automatically be hoisted to the top of the code block. Use this method if you want to explicitly avoid this behavior.\n\nOne example when this is useful is when you want to mock a module differently within the same file:\n\nUsing with ES6 imports requires additional steps. Follow these if you don't want to use in your tests:\n• We have to specify the property (see the API for more information).\n• Static ES6 module imports are hoisted to the top of the file, so instead we have to import them dynamically using .\n• Finally, we need an environment which supports dynamic importing. Please see Using Babel for the initial setup. Then add the plugin babel-plugin-dynamic-import-node, or an equivalent, to your Babel config to enable dynamic importing in Node.\n\nWhen using , calls to will automatically be hoisted to the top of the code block. Use this method if you want to explicitly avoid this behavior.\n\nExplicitly supplies the mock object that the module system should return for the specified module.\n\nOn occasion, there are times where the automatically generated mock the module system would normally provide you isn't adequate enough for your testing needs. Normally under those circumstances you should write a manual mock that is more adequate for the module in question. However, on extremely rare occasions, even a manual mock isn't suitable for your purposes and you need to build the mock yourself inside your test.\n\nIn these rare scenarios you can use this API to manually fill the slot in the module system's mock-module registry.\n\nReturns the actual module instead of a mock, bypassing all checks on whether the module should receive a mock implementation or not.\n\nReturns a mock module instead of the actual module, bypassing all checks on whether the module should be required normally or not.\n\nResets the module registry - the cache of all required modules. This is useful to isolate modules where local state might conflict between tests.\n\ngoes a step further than and creates a sandbox registry for the modules that are loaded inside the callback function. This is useful to isolate specific modules for every test so that local module state doesn't conflict between tests.\n\nis the equivalent of , but for async callbacks. The caller is expected to the completion of .\n\nDetermines if the given function is a mocked function.\n\nReplace with a . The property must already exist on the object. The same property might be replaced multiple times. Returns a Jest replaced property.\n\nCreates a mock function similar to but also tracks calls to . Returns a Jest mock function.\n\nSince Jest 22.1.0+, the method takes an optional third argument of that can be either or , which proves to be useful when you want to spy on a getter or a setter, respectively.\n\nSee TypeScript Usage chapter of Mock Functions page for documentation.\n\nSee TypeScript Usage chapter of Mock Functions page for documentation.\n\nClears the , , and properties of all mocks. Equivalent to calling on every mocked function.\n\nResets the state of all mocks. Equivalent to calling on every mocked function.\n\nRestores all mocks and replaced properties back to their original value. Equivalent to calling on every mocked function and on every replaced property. Beware that only works for mocks created with and properties replaced with ; other mocks will require you to manually restore them.\n\nInstructs Jest to use fake versions of the global date, performance, time and timer APIs. Fake timers implementation is backed by .\n\nFake timers will swap out , , , , , , , , with an implementation that gets its time from the fake clock.\n\nIn Node environment , and in JSDOM environment , , , will be replaced as well.\n\nCalling will use fake timers for all tests within the file, until original timers are restored with .\n\nYou can call or from anywhere: top level, inside an block, etc. Keep in mind that this is a global operation and will affect other tests within the same file. Calling once again in the same test file would reset the internal state (e.g. timer count) and reinstall fake timers using the provided options:\n\nInstructs Jest to restore the original implementations of the global date, performance, time and timer APIs. For example, you may call inside hook to restore timers after each test:\n\nExhausts the micro-task queue (usually interfaced in node via ).\n\nWhen this API is called, all pending micro-tasks that have been queued via will be executed. Additionally, if those micro-tasks themselves schedule new micro-tasks, those will be continually exhausted until there are no more micro-tasks remaining in the queue.\n\nExhausts both the macro-task queue (i.e., all tasks queued by , , and ) and the micro-task queue (usually interfaced in node via ).\n\nWhen this API is called, all pending macro-tasks and micro-tasks will be executed. If those tasks themselves schedule new tasks, those will be continually exhausted until there are no more tasks remaining in the queue.\n\nThis is often useful for synchronously executing setTimeouts during a test in order to synchronously assert about some behavior that would only happen after the or callbacks executed. See the Timer mocks doc for more information.\n\nAsynchronous equivalent of . It allows any scheduled promise callbacks to execute before running the timers.\n\nExecutes only the macro task queue (i.e. all tasks queued by or and ).\n\nWhen this API is called, all timers are advanced by milliseconds. All pending \"macro-tasks\" that have been queued via or , and would be executed within this time frame will be executed. Additionally, if those macro-tasks schedule new macro-tasks that would be executed within the same time frame, those will be executed until there are no more macro-tasks remaining in the queue, that should be run within milliseconds.\n\nAsynchronous equivalent of . It allows any scheduled promise callbacks to execute before running the timers.\n\nExecutes only the macro-tasks that are currently pending (i.e., only the tasks that have been queued by or up to this point). If any of the currently pending macro-tasks schedule new macro-tasks, those new tasks will not be executed by this call.\n\nThis is useful for scenarios such as one where the module being tested schedules a whose callback schedules another recursively (meaning the scheduling never stops). In these scenarios, it's useful to be able to run forward in time by a single step at a time.\n\nAsynchronous equivalent of . It allows any scheduled promise callbacks to execute before running the timers.\n\nAdvances all timers by the needed milliseconds so that only the next timeouts/intervals will run.\n\nOptionally, you can provide , so it will run amount of next timeouts/intervals.\n\nAsynchronous equivalent of . It allows any scheduled promise callbacks to execute before running the timers.\n\nRemoves any pending timers from the timer system.\n\nThis means, if any timers have been scheduled (but have not yet executed), they will be cleared and will never have the opportunity to execute in the future.\n\nReturns the number of fake timers still left to run.\n\nReturns the time in ms of the current clock. This is equivalent to if real timers are in use, or if is mocked. In other cases (such as legacy timers) it may be useful for implementing custom mocks of , , etc.\n\nSet the current system time used by fake timers. Simulates a user changing the system clock while your program is running. It affects the current time but it does not in itself cause e.g. timers to fire; they will fire exactly as they would have done without the call to .\n\nWhen mocking time, will also be mocked. If you for some reason need access to the real current time, you can invoke this function.\n\nEvery time Jest runs a seed value is randomly generated which you could use in a pseudorandom number generator or anywhere else.\n\nReturns if test environment has been torn down.\n\nRuns failed tests n-times until they pass or until the max number of retries is exhausted.\n\nIf option is enabled, error(s) that caused the test to fail will be logged to the console.\n\nSet the default timeout interval (in milliseconds) for all tests and before/after hooks in the test file. This only affects the test file from which this function is called. The default timeout interval is 5 seconds if this method is not called."
    },
    {
        "link": "https://jestjs.io/docs/api",
        "document": "In your test files, Jest puts each of these methods and objects into the global environment. You don't have to require or import anything to use them. However, if you prefer explicit imports, you can do .\n\nRuns a function after all the tests in this file have completed. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.\n\nOptionally, you can provide a (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.\n\nThis is often useful if you want to clean up some global setup state that is shared across tests.\n\nHere the ensures that is called after all tests run.\n\nIf is inside a block, it runs at the end of the describe block.\n\nIf you want to run some cleanup after every test instead of after all tests, use instead.\n\nRuns a function after each one of the tests in this file completes. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.\n\nOptionally, you can provide a (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.\n\nThis is often useful if you want to clean up some temporary state that is created by each test.\n\nHere the ensures that is called after each test runs.\n\nIf is inside a block, it only runs after the tests that are inside this describe block.\n\nIf you want to run some cleanup just once, after all of the tests run, use instead.\n\nRuns a function before any of the tests in this file run. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running tests.\n\nOptionally, you can provide a (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.\n\nThis is often useful if you want to set up some global state that will be used by many tests.\n\nHere the ensures that the database is set up before tests run. If setup was synchronous, you could do this without . The key is that Jest will wait for a promise to resolve, so you can have asynchronous setup as well.\n\nIf is inside a block, it runs at the beginning of the describe block.\n\nIf you want to run something before every test instead of before any test runs, use instead.\n\nRuns a function before each of the tests in this file runs. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running the test.\n\nOptionally, you can provide a (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.\n\nThis is often useful if you want to reset some global state that will be used by many tests.\n\nHere the ensures that the database is reset for each test.\n\nIf is inside a block, it runs for each test in the describe block.\n\nIf you only need to run some setup code once, before any tests run, use instead.\n\ncreates a block that groups together several related tests. For example, if you have a object that is supposed to be delicious but not sour, you could test it with:\n\nThis isn't required - you can write the blocks directly at the top level. But this can be handy if you prefer your tests to be organized into groups.\n\nYou can also nest blocks if you have a hierarchy of tests:\n\nUse if you keep duplicating the same test suites with different data. allows you to write the test suite once and pass data in.\n\nis available with two APIs:\n• : of Arrays with the arguments that are passed into the for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. .\n• : the title of the test suite.\n• Generate unique test titles by positionally injecting parameters with formatting:\n• - single percent sign ('%'). This does not consume an argument.\n• Or generate unique test titles by injecting properties of test case object with\n• To inject nested object values use you can supply a keyPath i.e. (only works for \"own\" properties, e.g. wouldn't work) (only works for \"own\" properties, e.g. wouldn't work)\n• You can use to inject the index of the test case\n• You cannot use with the formatting except for\n• : the suite of tests to be run, this is the function that will receive the parameters in each row as function arguments.\n• Optionally, you can provide a (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.\n• :\n• First row of variable name column headings separated with\n• One or more subsequent rows of data supplied as template literal expressions using syntax.\n• : the title of the test suite, use to inject test data into the suite title from the tagged template expressions, and for the index of the row.\n• To inject nested object values use you can supply a keyPath i.e. (only works for \"own\" properties, e.g. wouldn't work)\n• : the suite of tests to be run, this is the function that will receive the test data object.\n• Optionally, you can provide a (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.\n\nAlso under the alias:\n\nYou can use if you want to run only one describe block:\n\nAlso under the aliases: and\n\nUse if you want to only run specific tests suites of data driven tests.\n\nis available with two APIs:\n\nAlso under the alias:\n\nYou can use if you do not want to run the tests of a particular block:\n\nUsing is often a cleaner alternative to temporarily commenting out a chunk of tests. Beware that the block will still run. If you have some setup that also should be skipped, do it in a or block.\n\nAlso under the aliases: and\n\nUse if you want to stop running a suite of data driven tests.\n\nis available with two APIs:\n\nAlso under the alias:\n\nAll you need in a test file is the method which runs a test. For example, let's say there's a function that should be zero. Your whole test could be:\n\nThe first argument is the test name; the second argument is a function that contains the expectations to test. The third argument (optional) is (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.\n\nIf a promise is returned from , Jest will wait for the promise to resolve before letting the test complete. For example, let's say returns a promise that is supposed to resolve to a list that has in it. You can test this with:\n\nEven though the call to will return right away, the test doesn't complete until the promise resolves. For more details, see Testing Asynchronous Code page.\n\nAlso under the alias:\n\nUse if you want the test to run concurrently.\n\nThe first argument is the test name; the second argument is an asynchronous function that contains the expectations to test. The third argument (optional) is (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.\n\nAlso under the alias:\n\nUse if you keep duplicating the same test with different data. allows you to write the test once and pass data in, the tests are all run asynchronously.\n\nis available with two APIs:\n• : of Arrays with the arguments that are passed into the test for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e.\n• : the title of the test block.\n• Generate unique test titles by positionally injecting parameters with formatting:\n• - single percent sign ('%'). This does not consume an argument.\n• : the test to be run, this is the function that will receive the parameters in each row as function arguments, this will have to be an asynchronous function.\n• Optionally, you can provide a (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.\n• :\n• First row of variable name column headings separated with\n• One or more subsequent rows of data supplied as template literal expressions using syntax.\n• : the title of the test, use to inject test data into the test title from the tagged template expressions.\n• To inject nested object values use you can supply a keyPath i.e. (only works for \"own\" properties, e.g. wouldn't work)\n• : the test to be run, this is the function that will receive the test data object, this will have to be an asynchronous function.\n• Optionally, you can provide a (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.\n\nAlso under the alias:\n\nUse if you want to only run specific tests with different test data concurrently.\n\nis available with two APIs:\n\nAlso under the alias:\n\nUse if you want to stop running a collection of asynchronous data driven tests.\n\nis available with two APIs:\n\nAlso under the alias: and\n\nUse if you keep duplicating the same test with different data. allows you to write the test once and pass data in.\n\nis available with two APIs:\n• : of Arrays with the arguments that are passed into the test for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e.\n• : the title of the test block.\n• Generate unique test titles by positionally injecting parameters with formatting:\n• - single percent sign ('%'). This does not consume an argument.\n• Or generate unique test titles by injecting properties of test case object with\n• To inject nested object values use you can supply a keyPath i.e. (only works for \"own\" properties, e.g. wouldn't work)\n• You can use to inject the index of the test case\n• You cannot use with the formatting except for\n• : the test to be run, this is the function that will receive the parameters in each row as function arguments.\n• Optionally, you can provide a (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.\n• :\n• First row of variable name column headings separated with\n• One or more subsequent rows of data supplied as template literal expressions using syntax.\n• : the title of the test, use to inject test data into the test title from the tagged template expressions.\n• To inject nested object values use you can supply a keyPath i.e. (only works for \"own\" properties, e.g. wouldn't work)\n• : the test to be run, this is the function that will receive the test data object.\n• Optionally, you can provide a (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.\n\nAlso under the alias:\n\nUse when you are writing a test and expecting it to fail. These tests will behave the other way normal tests do. If test will throw any errors then it will pass. If it does not throw it will fail.\n\nAlso under the alias: and\n\nYou can also run multiple tests at once by adding after .\n\nAlso under the aliases: ,\n\nUse if you want to only run a specific failing test.\n\nAlso under the aliases: , ,\n\nUse if you want to skip running a specific failing test.\n\nAlso under the aliases: , and\n\nWhen you are debugging a large test file, you will often only want to run a subset of tests. You can use to specify which tests are the only ones you want to run in that test file.\n\nOptionally, you can provide a (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.\n\nFor example, let's say you had these tests:\n\nOnly the \"it is raining\" test will run in that test file, since it is run with .\n\nUsually you wouldn't check code using into source control - you would use it for debugging, and remove it once you have fixed the broken tests.\n\nAlso under the aliases: , , and\n\nUse if you want to only run specific tests with different test data.\n\nis available with two APIs:\n\nAlso under the aliases: , , and\n\nWhen you are maintaining a large codebase, you may sometimes find a test that is temporarily broken for some reason. If you want to skip running this test, but you don't want to delete this code, you can use to specify some tests to skip.\n\nFor example, let's say you had these tests:\n\nOnly the \"it is raining\" test will run, since the other test is run with .\n\nYou could comment the test out, but it's often a bit nicer to use because it will maintain indentation and syntax highlighting.\n\nAlso under the aliases: , , , , and\n\nUse if you want to stop running a collection of data driven tests.\n\nis available with two APIs:\n\nAlso under the alias:\n\nUse when you are planning on writing tests. These tests will be highlighted in the summary output at the end so you know how many tests you still need todo.\n\nThe modifier offers few different ways to define a table of the test cases. Some of the APIs have caveats related with the type inference of the arguments which are passed to or callback functions. Let's take a look at each of them.\n\nThe array of objects API is most verbose, but it makes the type inference a painless task. A can be inlined:\n\nThe array of arrays style will work smoothly with inlined tables:\n\nHowever, if a table is declared as a separate variable, it must be typed as an array of tuples for correct type inference (this is not needed only if all elements of a row are of the same type):\n\nIf all values are of the same type, the template literal API will type the arguments correctly:\n\nOtherwise it will require a generic type argument:"
    },
    {
        "link": "https://dev.to/htho/jest-recap-safely-mock-properties-and-methods-of-global-objects-3ph8",
        "document": "\n• You want to avoid that overridden/mocked properties/methods affect other tests.\n• For local objects (created and owned by this test) you can (and should) use\n• For global objects you should use\n• Make sure is called in an hook.\n\nIn a perfect codebase there is no need to manipulate global objects, but codebases are messy - and so is testing.\n\nWhat you want to avoid at all costs, is for one test to affect the other. Tests should be meaningful regardless of their order or if some tests are skipped.\n\nA naive approach to mock values is to just set the properties to whatever value you need in your test.\n\n This is fine as long as you change values in local objects owned (created by) this specific test:\n\n\n\nIf you do that for global objects, it gets messy:\n\n\n\nThis is what was made for:\n\n\n\nMethods can be mocked similar to properties.\n\n\n\nIf you use on global objects, your tests may depend on each other and loose their meaning:\n\n\n\nHow should we mock methods in global objects? That is what is good for:\n\n\n\nYou Must Clean up\n\nIf you want to be sure all tests find the system in the same (fresh, clean) state, you need to restore the state of mocks after each test.\n\nThe simplest solution is to set the configuration property.\n\nThe most straight forward option is to call in the\n\nHow to Mock Something for all Tests\n\nSometimes you want to Mock things for all tests in a file. If you use and on the top-level or in a block, all Mocks will be reset after the first test is executed.\n\nOn the top-level you can safely override properties and methods, without and .\n\nIf you want to Mock things only for a block, you need to make these calls in a hook."
    },
    {
        "link": "https://vitest.dev/guide/mocking",
        "document": "When writing tests it's only a matter of time before you need to create a \"fake\" version of an internal — or external — service. This is commonly referred to as mocking. Vitest provides utility functions to help you out through its helper. You can import it from or access it globally if configuration is enabled.\n\nIf you are not familiar with , or methods, check the API section first.\n\nSometimes you need to be in control of the date to ensure consistency when testing. Vitest uses package for manipulating timers, as well as system date. You can find more about the specific API in detail here.\n\nMocking functions can be split up into two different categories; spying & mocking.\n\nSometimes all you need is to validate whether or not a specific function has been called (and possibly which arguments were passed). In these cases a spy would be all we need which you can use directly with (read more here).\n\nHowever spies can only help you spy on functions, they are not able to alter the implementation of those functions. In the case where we do need to create a fake (or mocked) version of a function we can use (read more here).\n\nWe use Tinyspy as a base for mocking functions, but we have our own wrapper to make it compatible. Both and share the same methods, however only the return result of is callable.\n\nYou can mock global variables that are not present with or by using helper. It will put the value of the global variable into a object.\n\nMock modules observe third-party-libraries, that are invoked in some other code, allowing you to test arguments, output or even redeclare its implementation.\n\nSee the API section for a more in-depth detailed API description.\n\nIf your code is importing a mocked module, without any associated file or for this module, Vitest will mock the module itself by invoking it and mocking every export.\n• All arrays will be emptied\n• All primitives and collections will stay the same\n• All objects will be deeply cloned\n• All instances of classes and their prototypes will be deeply cloned\n\nVitest supports mocking Vite virtual modules. It works differently from how virtual modules are treated in Jest. Instead of passing down to a function, you need to tell Vite that module exists otherwise it will fail during parsing. You can do that in several ways:\n\nThe benefit of the second approach is that you can dynamically create different virtual entrypoints. If you redirect several virtual modules into a single file, then all of them will be affected by , so make sure to use unique identifiers.\n\nBeware that it is not possible to mock calls to methods that are called inside other methods of the same file. For example, in this code:\n\nIt is not possible to mock the method from the outside because it is referenced directly. So this code will have no effect on the call inside (but it will affect the call in other modules):\n\nYou can confirm this behaviour by providing the implementation to the method directly:\n\nThis is the intended behaviour. It is usually a sign of bad code when mocking is involved in such a manner. Consider refactoring your code into multiple files or improving your application architecture by using techniques such as dependency injection.\n\nMocking the file system ensures that the tests do not depend on the actual file system, making the tests more reliable and predictable. This isolation helps in avoiding side effects from previous tests. It allows for testing error conditions and edge cases that might be difficult or impossible to replicate with an actual file system, such as permission issues, disk full scenarios, or read/write errors.\n\nVitest doesn't provide any file system mocking API out of the box. You can use to mock the module manually, but it's hard to maintain. Instead, we recommend using to do that for you. creates an in-memory file system, which simulates file system operations without touching the actual disk. This approach is fast and safe, avoiding any potential side effects on the real file system.\n\nTo automatically redirect every call to , you can create and files at the root of your project:\n\nBecause Vitest runs in Node, mocking network requests is tricky; web APIs are not available, so we need something that will mimic network behavior for us. We recommend Mock Service Worker to accomplish this. It allows you to mock , and network requests, and is framework agnostic.\n\nMock Service Worker (MSW) works by intercepting the requests your tests make, allowing you to use it without changing any of your application code. In-browser, this uses the Service Worker API. In Node.js, and for Vitest, it uses the library. To learn more about MSW, read their introduction\n\nYou can use it like below in your setup file\n\nThere is much more to MSW. You can access cookies and query parameters, define mock error responses, and much more! To see all you can do with MSW, read their documentation.\n\nWhen we test code that involves timeouts or intervals, instead of having our tests wait it out or timeout, we can speed up our tests by using \"fake\" timers that mock calls to and .\n\nSee the API section for a more in depth detailed API description.\n\nYou can mock an entire class with a single call - since all classes are also functions, this works out of the box. Beware that currently Vitest doesn't respect the keyword so the is always in the body of a function.\n\nWe can re-create this class with ES5 functions:\n\nNow, when we create a new instance of the class its method (alongside ) is already mocked:\n\nWe can reassign the return value for a specific instance:\n\nTo mock the property, we can use the method. This makes it possible to use spy assertions on the mocked property:\n• Example with and :\n\nSpy on an object returned from a function ​\n\nTo mock 's time, you can use helper function. This value will not automatically reset between different tests.\n\nBeware that using also changes the 's time.\n\nYou can set global variable by assigning a value to or using helper. When using , it will not automatically reset between different tests, unless you enable config option or call .\n• To change environmental variable, you can just assign a new value to it.\n• If you want to automatically reset the value(s), you can use the helper with the config option enabled (or call manually in a hook):"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Blob",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020 . * Some parts of this feature may have varying levels of support.\n\nNote: This feature is available in Web Workers. The interface represents a blob, which is a file-like object of immutable, raw data; they can be read as text or binary data, or converted into a so its methods can be used for processing the data. Blobs can represent data that isn't necessarily in a JavaScript-native format. The interface is based on , inheriting blob functionality and expanding it to support files on the user's system.\n\nTo construct a from other non-blob objects and data, use the constructor. To create a blob that contains a subset of another blob's data, use the method. To obtain a object for a file on the user's file system, see the documentation. The APIs accepting objects are also listed in the documentation.\n\nReturns a promise that resolves with an containing the entire contents of the as binary data. Returns a promise that resolves with an containing the contents of the . Returns a new object containing the data in the specified range of bytes of the blob on which it's called. Returns a that can be used to read the contents of the . Returns a promise that resolves with a string containing the entire contents of the interpreted as UTF-8 text.\n\nThe following example creates a JavaScript typed array and creates a new containing the typed array's data. It then calls to convert the blob into a URL. <p> This example creates a typed array containing the ASCII codes for the space character through the letter Z, then converts it to an object URL. A link to open that object URL is created. Click the link to see the decoded object URL. </p> The main piece of this code for example purposes is the function, which creates a from the given typed array and returns an object URL for it. Having converted the data into an object URL, it can be used in a number of ways, including as the value of the element's attribute (assuming the data contains an image, of course). function showViewLiveResultButton() { if (window.self !== window.top) { // Ensure that if our document is in a frame, we get the user // to first open it in its own tab or window. Otherwise, this // example won't work. const p = document.querySelector(\"p\"); p.textContent = \"\"; const button = document.createElement(\"button\"); button.textContent = \"View live result of the example code above\"; p.append(button); button.addEventListener(\"click\", () => window.open(location.href)); return true; } return false; } if (!showViewLiveResultButton()) { function typedArrayToURL(typedArray, mimeType) { return URL.createObjectURL( new Blob([typedArray.buffer], { type: mimeType }), ); } const bytes = new Uint8Array(59); for (let i = 0; i < 59; i++) { bytes[i] = 32 + i; } const url = typedArrayToURL(bytes, \"text/plain\"); const link = document.createElement(\"a\"); link.href = url; link.innerText = \"Open the array URL\"; document.body.appendChild(link); }"
    },
    {
        "link": "https://learn.microsoft.com/en-us/azure/storage/blobs/storage-blob-download-javascript",
        "document": "This article shows how to download a blob using the Azure Storage client library for JavaScript. You can download blob data to various destinations, including a local file path, stream, or text string.\n• The examples in this article assume you already have a project set up to work with the Azure Blob Storage client library for JavaScript. To learn about setting up your project, including package installation, importing modules, and creating an authorized client object to work with data resources, see Get started with Azure Blob Storage and JavaScript.\n• The authorization mechanism must have permissions to perform a download operation. To learn more, see the authorization guidance for the following REST API operation:\n\nYou can use any of the following methods to download a blob:\n• BlobClient.downloadToBuffer (only available in Node.js runtime)\n• BlobClient.downloadToFile (only available in Node.js runtime)\n\nThe following example downloads a blob by using a file path with the BlobClient.downloadToFile method. This method is only available in the Node.js runtime:\n\nThe following example downloads a blob by creating a Node.js writable stream object and then piping to that stream with the BlobClient.download method.\n\nThe following Node.js example downloads a blob to a string with BlobClient.download method. In Node.js, blob data returns in a .\n\nIf you're working with JavaScript in the browser, blob data returns in a promise blobBody. To learn more, see the example usage for browsers at BlobClient.download.\n\nTo learn more about how to download blobs using the Azure Blob Storage client library for JavaScript, see the following resources.\n• None Download to file for JavaScript or TypeScript\n• None Download to stream for JavaScript or TypeScript\n• None Download to string for JavaScript or TypeScript\n\nThe Azure SDK for JavaScript contains libraries that build on top of the Azure REST API, allowing you to interact with REST API operations through familiar JavaScript paradigms. The client library methods for downloading blobs use the following REST API operation:\n• This article is part of the Blob Storage developer guide for JavaScript/TypeScript. To learn more, see the full list of developer guide articles at Build your JavaScript/TypeScript app."
    },
    {
        "link": "https://stackoverflow.com/questions/6076047/create-a-download-link-from-a-blob-url",
        "document": "In a Google chrome extension I am working on, a file is downloaded from a server with an . This file contains some binary data which are stored in an object. In order to provide the possibility to download this file I am using the API.\n\nIt is working fine; except that the filename is an opaque UUID like . Is there any way to force this filename to something more user-friendly?"
    },
    {
        "link": "https://stackoverflow.com/questions/11876175/how-to-get-a-file-or-blob-from-an-object-url",
        "document": "The problem with fetching the blob URL again is that this will create a full copy of the Blob's data, and so instead of having it only once in memory, you'll have it twice. With big Blobs this can blow your memory usage quite quickly.\n\nIt's rather unfortunate that the File API doesn't give us access to the currently linked Blobs, certainly they thought web-authors should store that Blob themselves at creation time anyway, which is true:\n\nThe best here is to store the object you used when creating the blob:// URL.\n\nIf you are afraid this would prevent the Blob from being Garbage Collected, you're right, but so does the blob:// URL in the first place, until you revoke it. So holding yourself a pointer to that Blob won't change a thing.\n\nBut for those who aren't responsible for the creation of the blob:// URI (e.g because a library made it), we can still fill that API hole ourselves by overriding the default URL.createObjectURL and URL.revokeObjectURL methods so that they do store references to the object passed.\n\nBe sure to call this function before the code that does generate the blob:// URI is called.\n\nAnd an other advantage is that it can even retrieve MediaSource objects, while the fetching solutions would just err in that case."
    },
    {
        "link": "https://flexiple.com/javascript/download-flle-using-javascript",
        "document": "JavaScript provides the ability to trigger file downloads from a web page using the `Blob` object and the `URL.createObjectURL` method to download a file using JavaScript, developers often employ specific techniques. JavaScript creates a `Blob` object, encapsulating the file data. JavaScript then generates a URL for this `Blob` object using `URL.createObjectURL`. The next step involves creating an anchor (`<a>`) tag dynamically via JavaScript. JavaScript sets the `href` attribute of this anchor tag to the blob URL. JavaScript also needs to set the `download` attribute on the anchor tag, specifying the filename. After configuring the anchor tag, JavaScript adds this element to the document body. To initiate the download, JavaScript simulates a click on the anchor tag via the `click()` method. Once the download starts, JavaScript removes the anchor tag from the document to clean up the DOM. This method ensures that the file download process is seamless and user-initiated actions are minimal.\n\nUsing the `<a>` tag with the download attribute allows for the straightforward downloading of files in JavaScript. Developers specify the path to the file in the `href` attribute of the `<a>` tag. The `download` attribute prompts the browser to download the file rather than navigating to it. The value of the `download` attribute can set the filename for the downloaded file.\n\nHere is an example of how to use the `<a>` tag with the download attribute:\n\nIn this code, the `<a>` tag points to a PDF file located at the specified path. The `download` attribute renames the file to \"CustomFileName.pdf\" upon downloading. Users click on the link to initiate the download process. The browser handles the download operation without requiring any additional JavaScript code.\n\nFor dynamic file generation or when file URLs are not static, JavaScript can dynamically set the `href` attribute. Web developers achieve this by manipulating the DOM using JavaScript. Here is an example where JavaScript sets the `href` attribute:\n\nThis JavaScript snippet assumes that there is an element with an ID of 'downloadLink'. JavaScript updates this element's `href` attribute with a new file path. When users click the link, the browser downloads the file specified in the updated `href` attribute.\n\nIn scenarios where files are generated on the fly, such as a server-side script outputting data in response to a request, the `download` attribute still functions effectively. The server script generates the file, and the `<a>` tag with the `download` attribute instructs the browser to download the file. Here is an HTML snippet for such a scenario:\n\nIn this example, the link points to a PHP script that generates a file. The `download` attribute ensures that the output of the script is downloaded as \"GeneratedFile.txt\". This method is particularly useful for web applications that need to provide users with dynamically generated data files.\n\nUsing Blob to download files in JavaScript involves creating a Blob object and using it to generate a URL for the file. Define the content of the file as a string or an array of strings. For instance, create a Blob object from textual data:\n\nCreate a URL for the Blob object using the URL.createObjectURL method. This method turns Blob into a URL that the browser can use as a file source:\n\nTo initiate the download, create an anchor (`<a>`) element and set its `href` attribute to the URL created from the Blob. Specify the desired filename using the `download` attribute of the anchor element:\n\nAfter triggering the download, it's important to release the created Blob URL to free up memory. JavaScript performs this action using URL.revokeObjectURL:\n\nJavaScript ensures the process is straightforward and avoids memory leaks by removing the URL after the download. This method works in all modern browsers and provides a powerful way to handle file downloads directly from JavaScript applications. Ensure the MIME type in the Blob constructor matches the file content for optimal results. JavaScript handles different data types, allowing developers to customize the Blob content based on application needs. This approach ensures users receive the correct file type upon downloading.\n\nTo download a file using JavaScript, incorporate specific functions and methods related to web development. Employ the `XMLHttpRequest` or `fetch` method to handle the file retrieval process from the server. Ensure proper error handling is in place to manage any issues that arise during the download. The download operation concludes successfully when the file is saved to the user's system. Use this JavaScript functionality to enhance user experience on web applications by allowing efficient and secure file downloads. Remember to test the file download feature thoroughly to ensure reliability and performance, if security and user requirements are met."
    }
]