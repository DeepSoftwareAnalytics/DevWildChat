[
    {
        "link": "https://stackoverflow.com/questions/43679471/nasm-modifying-a-string",
        "document": "fails because a is four bytes long, but is five bytes long. There is nothing strange about that, the assembler is telling you precisely what is wrong, and it even says it in two different ways: \"character constant too long\" and \"dword data exceeds bounds\". You just can't fit 5 bytes into a place that can only hold 4 bytes.\n\nfails apparently because is a , not a , and if you somehow managed to shoehorn 8 bytes into it you would probably be corrupting the memory immediately following it.\n\nI guess the confusion stems from the fact that the sample code you found has , which is perhaps making you believe that you can fit that entire text in a . I don't know why they used , it seems to me that they should have used . The only reason why they were able to do that is because the assembler allows this kind of hack, but in order for their sample code to be understandable and intuitive, they should have used , because that's what you are declaring there: a sequence of bytes.\n\nIn any case, the directive has nothing to do with the instruction. The directive is declaring an arbitrary-length sequence of s. The instruction can copy a fixed amount of bytes: either a single byte, or two bytes (a ) or four bytes (a ). (Or perhaps even eight bytes, a , if there are any instructions that can somehow specify a quad-word operand, though I cannot think of any right now.) The assembler probably performs some rudimentary type checking, making sure that the target quantity is of a type suitable to receive the source quantity, and the check passes, since has been defined with , and the quantity being stored is given as a .\n\nSo, the instruction is actually a hack: it packs the four characters you gave it into a DWORD, and stores that in . has been defined with , so it is of the correct type, so the hack works. However, only four characters can be packed in a DWORD, that's why 'Nuhas' does not work. Also, you cannot do and expect to work, because there is no instruction that will move an immediate qword, since the instruction set that you are working with is 32-bit. (You could do that with a 64-bit instruction set.)"
    },
    {
        "link": "http://streetinfo.lu/computing/programming/dos/dos_nasm.html",
        "document": "The Netwide Assembler (NASM) is an an assembler for the x86 CPU architecture portable to nearly every modern platform, and with code generation for many platforms old and new. The good news for DOS nostalgics is that the NASM team continues to support DOS, so the latest version of NASM is available for this operating system. You can download NASM from the developers' website; be sure to pick the (latest) release for DOS.\n\nThe intention of this tutorial is primarily to show how to use NASM to build 16-bit real mode and protected mode programs on DOS. As the tutorial includes general information about assembly programming, and some largely commented sample programs, it may also be seen as a starting point for assembly newbies to create their own programs (without really being an introduction to the NASM assembly programming language). The program samples have been build and tested on FreeDOS 1.3 RC5, using NASM 2.16.0.1. The tutorial should also apply to MS-DOS or other DOS operating systems. To note, that the protected mode executables, build here, also run on the first Windows releases and in Command Prompt of the following ones (at least until Windows 2000 included). Use the following link to download the source code of the sample programs.\n\nThe NASM download is a ZIP archive (in my case: nasm-2.16.01-dos.zip). I unpacked it on my Windows 10 and created an ISO to get the files onto my FreeDOS VMware virtual machine. On FreeDOS, I created the directory C:\\NASM and copied all files from the CD to there. The screenshot shows the content of the NASM directory. The assembler executable is called NASM.EXE.\n\nBefore starting to try out the assembler, here some important facts to know about assembly programming:\n• Assembly language (or assembler language) is any low-level programming language in which there is a very strong correspondence between the instructions in the language and the architecture's machine code instructions. Assembly language usually has one statement per machine instruction. Because assembly depends on the machine code instructions, each assembly language is specific to a particular computer architecture. The family of represents decades of advances on the original Intel 8086 architecture. In addition to there being several different dialects based on the assembler used, additional processor instructions, registers and other features have been added over the years while still remaining backwards compatible to the 16-bit assembly used in the 1980s.\n• There are a variety of x86 assemblers. Most of them, as for example, Intel assembler, Microsoft Assembler (MASM), Netwide Assembler (NASM), Borland's Turbo Assembler (TASM) use the so-called , rather different from the , used for example by the AT&T assembler (AS), the GNU assembler (GAS), and also often used with inline assembly. The syntax used by this first group of assemblers is based on the specifications defined by Intel, but there are also simplifications of the syntax rules or syntax extensions specific to one or another of the assemblers. This means that if you have written a program that, assembled with MASM, didn't produce any errors, don't be surprised if using NASM you'll get lots of syntax error messages.\n• With the assembly as input, the assembler produces an , that (normally) has to be passed to a to create the executable. Object files may have , and we'll have to tell the assembler which of them it should produce. Here is an overview:\n• : This format does not produce object files, but generates nothing in the output file except the code you wrote. Such \"pure binary\" files are used by DOS .COM executables and .SYS device drivers. Pure binary output is also useful for operating system and boot loader development. We will use the bin format when creating 16-bit real mode executables.\n• : This format is the one produced by MASM and TASM, which is typically fed to 16-bit DOS linkers to produce .EXE files. It is also the format used by OS/2. NASM has also full support for the 32-bit extensions to this format. We will use the obj format when creating 16-bit protected mode executables.\n• : This output type produces COFF object files suitable for linking with the DJGPP linker. We would use them if we wanted to create DJGPP based 32-bit programs for DOS.\n• and are used on newer operating systems.\n• An assembly program may be subdivided into several . In some object file formats, the number and names of sections are fixed; in others, the user may make up as many as they wish. A section also represents the part of the output file where the code you write will be assembled into, and the code being loaded into memory for execution, also represents a given memory . Usually, we consider the following :\n• The is used for keeping the actual code (assembly instructions).\n• The is used for declaring initialized data or constants.\n• The is used for declaring variables (uninitialized data). There are also three :\n• The is represented by the text section. This defines an area in memory that stores the instruction codes.\n• The is represented by the data and the bss sections. The data section is used to declare the memory region where data elements are stored for the program. This section cannot be expanded after the data elements are declared, and it remains static throughout the program. The bss section is also a static memory section that contains buffers for data to be declared later in the program. This buffer memory is zero-filled.\n• The is a memory area that will contain data values passed to functions and procedures within the program.\n• There is a fundamental difference between assembly and higher-order language programming. With the latter ones, the programmer has not to care at all what the CPU does when a given statement is executed, nor (at least in most cases), where in memory the code is executed and where the data used is stored. Using assembly, a basic knowledge of the computer hardware, in particular the is required. This is obvious, because in some sense you directly give the CPU the order to execute a given machine instruction. Machine instructions (normally) require the usage of one of the internal of the CPU (for example to load a value from memory into, to store its content to some memory location, to add the value from another register or memory location), so our assembly instructions will mostly be to \"do something\" with a register or its content. Also, any data used by these instructions is located at a given . The assembly language allows us to use variables, what seems to be the same as in higher-order languages. However, these variables are only a convenience to refer to a given memory area; they do not include any information about what type (character, number...) the data is, nor about the value's length. What the content of given successive memory addresses actually represents is under the full control and responsibility of the programmer!\n• Arithmetic operations (mostly) require numbers in representation. If the number is to be considered as signed or unsigned depends on the programmer. Numbers read from the keyboard are , and numbers output to the screen have also to be in ASCII format. So, all number input/output operations requires some kind of conversion.\n\nThese long theoretical considerations may be annoying, but I think that you really have to know and understand these basic concepts if you want to create assembly programs...\n\nOn a x86 32-bit DOS system, there are three kinds of executables that we can create with NASM:\n• programs. This is the easiest way to create DOS programs with NASM; we even don't need a linker. Be aware, however, that with programs running in real mode, you can do \"all you want\"; there is no protection of deleting data or overwriting the code of some TSR or driver loaded or DOS itself. Such programs will be discussed in the next section.\n• programs. This requires a linker to transform the object code into an executable. Protected mode programs may not be able to do what you want, if you have have to access the computer hardware. On the other hand, they are safer than real mode programs and you can safely run them in Command Prompt of older Windows releases. I will talk about them in the section following the discussion of the real mode programs.\n• programs. Working with 32 bits may largely increase the possibilities. To create such programs on DOS, we need an extender such as DJGPP. If you want to learn to build 32-bit protected mode NASM programs on DOS, please have a look at my tutorial 32-bit assembly programming using NASM and GCC.\n\nReal mode, also called real address mode, is an operating mode of all x86-compatible CPUs. The mode gets its name from the fact that addresses in real mode always correspond to real locations in memory. Real mode is characterized by a 20-bit segmented memory address space (giving 1 MB of addressable memory, that the real mode program has to share with the programs and drivers already there) and unlimited direct software access to all addressable memory, I/O addresses and peripheral hardware. Real mode provides no support for memory protection, multitasking, or code privilege levels. For details, have a look at the following Wikipedia article.\n\nHere is the code of HELLO1.ASM, a simple real mode \"Hello World\" program.\n\nSome general notes concerning this code:\n• Like most assemblers, each NASM source line contains (unless it is a macro, a preprocessor directive or an assembler directive) some combination of the four fields: . NASM allows a totally free-format coding, thus a label has not to start at column 1 and an instruction may start at column 1. For readability, a fixed format with, for example instructions starting at column 9 and operands starting at column 17 is recommendable. Labels may but mustn't be terminated by a colon (:). Comments are preceded by a semicolon (;).\n• Real mode programs (more exactly: the object format) require the directive to specify the origin address which NASM will assume the program begins at, when it is loaded into memory. A good value for the program origin is . The \"h\" placed after a number means that this is a hexadecimal value (another possibility to represent hexadecimal numbers is to place \"0x\" in front of them, as 0x21 and 0x4c00 in the code above.\n• The object format requires the three , we spoke about before. They are defined by the directive , and their names are respectively , , and . The text section has to begin with the label.\n• Assembly programs have access to the BIOS and operating system functions by using . In DOS programs, we can use the instruction to call the DOS functions for keyboard input, screen output or termination of the program. For details, cf. Using interrupts to call DOS functions.\n• To declare (in the section), we mostly use the pseudo-instruction . In the program code above, this instruction initializes a memory area of 15 bytes at the beginning of the section; the 15 succeeding memory locations will contain the ASCII characters corresponding to the \"hello, world\" string, followed by the bytes 0Dh and 0Ah (hexadecimal values for decimal 13 and 10, actually representing a carriage-return + linefeed) and the byte 24h (hexadecimal ASCII code for the dollar sign). Note, that for the assembler, all this memory content is just \"some byte of data\", that only becomes a number, or a character, or whatever, when the programmer decides so! Also to note that there are similar pseudo-instruction to reserve a word (2 bytes): , or a double-word (4 bytes): (floating point numbers may be initialized using , , or ).\n• No example in the code above, but lets mention it here: To declare , we mostly use the pseudo-instruction , followed by the number of bytes to be reserved. Similarly as for , you can also use , , etc.\n• The data in our section above is preceded by a that I called \"hello\". This variable-label is similar to a variable in higher-order programming languages, but without telling anything about the variable's type (it's the programmer who decides what each byte actually represents), nor its length (number of bytes). In fact the label \"hello\" refers to the memory address of the first byte of data declared with the pseudo-instruction. For details, cf. CPU registers and memory addresses.\n\nNASM.EXE has a whole bunch of command line parameters. Two of them are of particular interest for us. First of all, we have to indicate the format of the output produced by the assembler (flat-form binary in our case). This is done by using -f bin. With bin, the output actually is a real mode executable rather than an object file and to create a file with .com extension, we'll have to indicate the name of the assembler output, using -o <filename>.com. The command to assemble HELLO1.ASM in order to create a 16bit real mode DOS executable is as follows:\n\n nasm -f bin hello1.asm -o hello1.com\n\nThe screenshot below shows the execution of this command (no output if there aren't any errors or warnings), a directory listing with the source and executable (note that HELLO1.COM is only 27 bytes!), and the execution of the program (displaying the text \"hello, world\").\n\nProtected mode, also called protected virtual address mode, is an operational mode of x86-compatible CPUs that allows system software to use features such as segmentation, virtual memory, paging and safe multi-tasking designed in order to increase an operating system's control over application software. For details, have a look at the following Wikipedia article.\n\nHere is HELLO2.ASM, the protected mode version of our \"Hello World\" program from above.\n\nComparing with the code of our program with bin output, we note the following differences:\n• As protected mode programs use virtual memory, you haven't and you can't specify an origin, where to load the program, so there is directive.\n• Instead of defining three sections, we'll have to define three . These are introduced by the directive and respectively called (as seen further up in the text): , , and (I'm not sure if you must use these names...).\n• It is mandatory to define a area. In the example above the segment called \"stack\" is defined as type \"stack\" (second \"stack\" of the directive) and we reserve 64 bytes of uninitialized space for it. The label points to the area (note that a label without ending colon placed in an otherwise empty line produces an assembler warning).\n• The code section must begin with special symbol , what means that this memory location will be the into the resulting executable file.\n• Before adding your own code, some has to be done. The corresponding code sets up DS to point to the data segment, and initializes SS and SP to point to the top of the provided stack. Don't bother about this code; just copy it to your sources...\n\nAs said above, to create our 16-bit protected mode .exe file, we'll have to tell the assembler to create a Microsoft OMF object file. This is done, by setting the command line parameter -f obj. No need to use the -o parameter in this case: the default name of the output file is identical to the assembler source file name, with an extension of .obj. So, for the program HELLO2.ASM, the command to assemble it is as follows:\n\n nasm -f obj hello2.asm\n\nAs a difference with before, the assembler output is object code that cannot be executed without being treated by a linker. The NASM download archive doesn't include a linker, so we'll have to find one somewhere else.\n\nThere are several 16-bit linkers for DOS available free of charge. The most commonly used are probably ALINK and QLINK. Both require the presence of a DPMI host. An alternative (used by myself when creating the samples in this tutorial), is to use the linker included with MASM. I actually use the one included with MASM 6.11, that you can download from the WinWorld website. For your convenience, I placed a copy of LINK.EXE on my site.\n\nTo link our HELLO2.OBJ file in order to create an executable called HELLO2.EXE, run the command\n\n link hello2.obj,hello2.exe\n\n where you can omit the second parameter, because first, it's the default used by the linker and second, you'll be asked for the name (and some other info when you link the object).\n\nThe screenshot below shows the linkage of HELLO2.OBJ (as you can see, Run File is automatically set to HELLO2.EXE; just hit ENTER to accept the default, as you can do for the other items asked), a directory listing with source, object and executable file (note that HELLO2.EXE is lots bigger in size than the real mode HELLO1.COM created before), and finally the execution of HELLO2.EXE.\n\nNote: I think that you haven't to worry about the real mode warning issued by LINK.EXE. If you want to prevent it, start your FreeDOS system using HIMEMX.EXE (+ JEMM386.EXE) instead of JEMMEX.EXE as memory driver (add a menu option to your FDCONFIG.SYS, if you don't already have...).\n\nThe aim of DOS batch files is to make life easier, defining several DOS commands in a file, that you can run as a shell script. My NASM.BAT has for objective the creation of either a real mode, or a protected mode executable, starting from an assembly source file <filename>.asm. The batch file awaits 2 command line parameters: the first one to define what kind of executable you want to create (-r for a real mode program, -p for a protected mode program), the second one being the name of the assembly source file without file extension. The executable produced will be called <filename>.com, or <filename>.exe, depending on the first parameter. Here is the content of my file:\n\n@echo off\n\n if \"%1\"==\"-r\" set _MODE=real\n\n if \"%1\"==\"-p\" set _MODE=protected\n\n set _PROG=%2\n\n if \"%_MODE%\"==\"\" goto NoMode\n\n if \"%_PROG%\"==\"\" goto NoProg\n\n if \"%_MODE%\"==\"protected\" goto Prot\n\n :Real\n\n if exist %_PROG%.com del %_PROG%.com\n\n c:\n\nasm\n\nasm.exe -f bin %_PROG%.asm -o %_PROG%.com\n\n goto End\n\n :Prot\n\n if exist %_PROG%.obj del %_PROG%.obj\n\n if exist %_PROG%.exe del %_PROG%.exe\n\n c:\n\nasm\n\nasm.exe -f obj %_PROG%.asm\n\n if not exist %_PROG%.obj goto End\n\n c:\\masm611\\bin\\link.exe %_PROG%.obj,%_PROG%.exe\n\n goto End\n\n :NoMode\n\n echo Invalid or missing mode\n\n goto Usage\n\n :NoProg\n\n echo Missing file name\n\n :Usage\n\n echo Usage: nasm -r|-p asm-file-name\n\n :End\n\n set _MODE=\n\n set _PROG=\n\nNote: The paths c:\n\nasm\n\nasm.exe and c:\\masm611\\bin\\link.exe correspond to where NASM and MASM were installed on my system. You'll eventually have to adapt them (or add the directories containing the files to your PATH environment variable, or copy the two files to your c:\\freedos\\bin directory).\n\nInterrupts are signals generated by the computer every time a certain event occurs. Hardware interrupts are triggered by hardware devices such as the network or sound card. Software interrupts may be triggered from within an assembly program using the INT instruction. The interrupts are numbered from 0x00 to 0xFF and each have a special function (most are unused) and their effect is that the normal program execution is suspended, and the control being transferred to a so-called interrupt handler. This a portion of code to be executed when this specific interrupt occurs. As an example, interrupt 09h (IRQ1) is a keyboard interrupt. It is called each time a key on the keyboard is pressed and the corresponding handler (part of the BIOS) reads the value of the key pressed and puts into the keyboard buffer. Beside this, some special keys or key combinations induce some supplementary action, as for example Shift+PrtScr that triggers interrupt 05h (sending the screen content to the printer), or CTRL+ALT+DEL that makes a direct call to address 0FFFFh:00h (reboot of the system).\n\nHere an overview of some of the x86 interrupts:\n\nMS-DOS (as other DOS systems, including FreeDOS) provides many common services through interrupt 21h. Entire books have been written about the variety of functions available. Here just a description of six of them. The general way to proceed (for the functions described) is the following:\n• Load the data or its starting address (if there is any data) into the register.\n• Load the function code into the (depending on it's 1 or 2 bytes).\n• Execute the instruction to call the DOS function.\n• Access the return data (if there is any) in the register resp. from the that we indicated when calling the function.\n\nThe DOS exit function terminates the program that calls it and returns to the DOS prompt. Here how to call it:\n\n mov ax, 4c00h\n\n int 21h\n\n No data to pass to the function, nor any data returned. Just load AX with the function code 4c00h. We have this code in our two \"Hello World\" programs, and we will also have it in the other samples.\n\nThe DOS write-character function writes a character to the screen. Here how to call it:\n\n mov dl, ...\n\n mov ax, 02h\n\n int 21h\n\n The DL register has to contain the character (i.e. its ASCII code) to be displayed. We can load the character as a constant, from another register or from memory (cf. further down in the text); there is no data returned.\n\nThe DOS write-string function writes a string (sequence of characters) to the screen. Here how to call it:\n\n mov dx, <address>\n\n mov ah, 09h\n\n int 21h\n\n The DL register has to contain the address of the first character (i.e. its ASCII code) to be displayed. The display on the screen starts with the character at this address and continues with the characters at the successive memory locations until the dollar symbol ($) is found (this character not being displayed). After the display of the last character, the cursor stays in the same line at its current position, except if the last two characters were the ASCII codes 0Dh (13) followed by 0AH (10), which code for a carriage return + linefeed (new line indicator on DOS and Windows systems). There is no data return. We have now the knowledge to understand, how the display in the two \"Hello World\" programs works: mov dx, hello loads the DX register with the address referred to by the variable \"hello\", i.e. the character \"h\" of the \"hello, world\" string. This \"h\" and the following characters are displayed on the screen; display ends with the character preceding the dollar symbol. As the last two characters send to the screen were 0Dh followed by 0Ah, a carriage-return + linefeed is performed and the cursor is moved to the beginning of the next line.\n\nThe DOS read-character function reads a character from the keyboard. Here how to call it:\n\n mov ah, 01h\n\n int 21h\n\n This function has no input data; the return data is the ASCII code of the character pressed on the keyboard in the AL register. Besides reading the character, the character is also echoed (displayed onto the screen).\n\nThe DOS read-character (no echo) function also reads a character from the keyboard. Here how to call it:\n\n mov ah, 08h\n\n int 21h\n\n The function works the same way as the one described before, except that the character is not displayed onto the screen.\n\nThe DOS read-string function reads a string (sequence of characters terminated by the ENTER key) from the keyboard. Here how to call it:\n\n mov dx, <address>\n\n mov ah, 0ah\n\n int 21h\n\n This is a little bit more complicated... The DX register has to be loaded with the address of the buffer, where the string (sequence of ASCII codes) will be placed. However, first we have to indicate the maximum string length the input may have (1 to 255). This value has to be stored by the programmer at the address passed as input to the function (start of the buffer, offset +0) and must equal the maximum number of characters that the user may enter plus 1 (the carriage-return code 0Dh will be returned as last character). As we don't know how many characters the user actually enters, the actual string length has to be returned by the function. It will be stored at the memory location immediately following the buffer start (offset +1). To note that the count returned only equals the string data length (the carriage-return will be stored in the buffer, but it will not be included in the count of characters entered). Finally, as the two first locations of the buffer are used for the counters, the string data entered starts at offset +2.\n\nTo illustrate how to use the DOS read-string function, lets write a \"Hello User\" program. We first ask the user for their name, then send the greeting \"Hello <name>!\" to the screen. Here is the code of the HELLO3.ASM sample:\n\nsegment code\n\n ..start:\n\n \n\n mov ax, data\n\n mov ds, ax\n\n mov ax, stack\n\n mov ss, ax\n\n mov sp, stacktop\n\n \n\n mov dx, qname\n\n mov ah, 9\n\n int 0x21\n\n \n\n mov dx, buffer\n\n mov ah, 0x0a\n\n int 0x21\n\n \n\n lea esi, [buffer + 2]\n\n mov cl, [buffer + 1]\n\n lea edi, [hname]\n\n copychar:\n\n mov bl, [esi]\n\n mov [edi], bl\n\n inc esi\n\n inc edi\n\n dec cl\n\n test cl, cl\n\n jnz copychar\n\n mov byte [edi], '!'\n\n mov byte [edi + 1], 13\n\n mov byte [edi + 2], 10\n\n mov byte [edi + 3], '$'\n\n mov dx, hello\n\n mov ah, 9\n\n int 0x21\n\n \n\n mov ax, 0x4c00\n\n int 0x21\n\n segment data\n\n maxlen equ 20\n\n buffer db maxlen + 1\n\n resb maxlen + 2\n\n qname db 'What is your name? ', '$'\n\n hello db 13, 10, 'Hello '\n\n hname resb maxlen\n\n resb 4\n\n segment stack stack\n\n resb 64\n\n stacktop:\n\nLets begin by having a look at the data segment. The pseudo-instruction EQU declares a constant. Assembly constants are as in higher-order programming languages: they can't be changed by the program and the assembler simply replaces all occurrences of them by the value they have been assigned. Our constant maxlen = 20 is the maximum length of the user name (an arbitrarily chosen value; if we don't want to set a length limit, we can use maxlen = 255).\n\n\"qname\" references the memory area where we have stored the string to ask the user for their name. Be sure not to forget the terminal dollar character if you use interrupt 21h to display a string on the screen (just try out what happens if you do...)! Note that the string is not followed by the characters 0Dh 0Ah; there will be no carriage-return + linefeed, the cursor will stay at the position after the last character displayed (and it's here that the name entered by the user will be displayed).\n\n\"hello\" references the memory area for our greeting message. This area starts with some initialized data (a carriage-return + linefeed and the string \"Hello \"), followed by 20 bytes reserved for the name entered by the user and 4 further bytes of uninitialized space. Do you have an idea what they are for?\n\n\"buffer\" references the memory area that will be used for the user input. As we saw when describing the DOS read-string function, the first byte of this area has to contain the maximum number of characters that the user may enter; in our case the length of the name + the carriage-return = maxlen + 1 (21). The remaining space of the buffer will be filled in by the DOS function. Remember that the first byte of the return data is the actual string length, and that the carriage-return is returned as last character. So, the length of the area of uninitialized data that we have to reserve is 1 + (maxlen + 1) = maxlen + 2 (22).\n\nNow, the code segment. After the initialization that has to be done in order to create an OBJ output file, we display the \"What is your name? \" string on the screen. This is done by loading the address of the first byte of the string (\"qname\") into DX, loading AH with 0Ah, the code of the DOS read-string function and calling INT 21h. We then want the user to enter their name. As we saw before, in order to use INT 21h, DX has to be loaded with the memory address of the first byte of the buffer area (\"buffer\") and AH has to be loaded with 0Ah, the code of the DOS write-string function. Program execution is suspended until the user hits the ENTER key (hitting CTRL+C = CTRL+Break will trigger interrupt 1Bh, the program will be aborted and the system will return to the DOS prompt). When the program execution resumes, our buffer will have been filled with the function return data. In order to display the greeting message, we'll have to copy the user name from the buffer to the memory area referred to by the variable \"hname\". This copy will be done byte by byte. As we will use the DOS write-string function to display the greeting, we'll have to add at least one character (the dollar symbol) to the output string. I will explain the code of all this data movement in the next section. The display itself is done as before (DX having to be loaded with address of the first byte of the greeting message, i.e. \"hello\"). Finally, we terminate the program by calling the DOS exit function.\n\nTo speed up the processor operations, the processor includes some internal memory storage locations, called registers. The registers store data elements for processing without having to access the memory. A x86 processor has a whole bunch of registers and I will only mention some of them here. If you are serious about assembly programming, you might want to have a look at NASM Assembly - Registers at the tutorialspoint website for details.\n\nThere are four 32-bit data registers that are used for arithmetic, logical, and other operations. These 32-bit registers can be used in three ways:\n• The lower halves of the 32-bit registers can be used as four : AX, BX, CX and DX.\n• Lower and higher halves of the four 16-bit registers mentioned above can be used as eight : AH, AL, BH, BL, CH, CL, DH, and DL.\n\nFor most operations, you can use any of the 4 (resp. 8) registers as you want. However, each of them has also specific functions. AX is the primary accumulator; it is used in input/output and most arithmetic instructions. For example, in multiplication operation (assembly instruction with a single operand), one of the multiplication operands has always to be stored in EAX, AX or AL (according to the size of the operand). BX is called the base register; it is the only general-purpose register which may be used for indirect addressing. For example, the instruction MOV [BX], AX causes the contents of AX to be stored in the memory location whose address is given in BX. CX is known as the count register, as the ECX, CX registers store the loop count in iterative operations (looping, shift and rotate, and string instructions). DX is known as the data register. It is used in input/output operations, and also (together with AX) for multiplication and division operations involving large values.\n\nThe 32-bit index registers, ESI and EDI, and their 16-bit rightmost portions SI and DI, are mostly used for indexed addressing. E.g.: the instruction MOV BL, [ESI + NUMLEN + 3] causes the contents of the memory location defined by the address given by the value in ESI + the value of the constant \"numlen\" + 1 to be stored in register BL. In string operations, SI is used as source index, and DI is used as destination index.\n\nThe status register, or flags register, is a collection of 1-bit values which reflect the current state of the processor and the results of recent operations. Many instructions change the status of the flags and some other conditional instructions test the value of the flags to take the control flow to another location. Here are some common flag bits:\n\nMost of the time you will not have to deal with the flags register explicitly; instead, you will execute one of the conditional branch instructions, Jcc, where cc is a mnemonic condition code, as in the following table:\n\nMost assembly language instructions require operands to be processed. An operand address provides the location, where the data to be processed is stored. When an instruction requires two operands, the first operand is generally the destination, which contains data in a register or memory location and the second operand is the source. The source contains either the data to be delivered itself (immediate addressing) or the address (in a register or in memory) of the data. Generally, the source data remains unaltered after the operation. There are three basic modes of addressing: register addressing, immediate addressing, and memory addressing.\n\nIn the register addressing mode, the operand is contained in a register. Depending upon the instruction, the register may be the first operand, the second operand or both. As processing data between registers does not involve memory, it provides fastest processing of data. Some examples:\n\n mov dx, qname\n\n mov ah, 9\n\n add al, bl\n\n add bl, al\n\n In the first two examples (from our HELLO3.ASM program), the register is the first operand, i.e. a destination; the address referred to by the variable \"qname\" is moved to the DX register, and the constant value 9 is moved to AH. In the third and fourth examples, both operands are registers; in both cases the values in registers AL and BL are added. In the third example, the result is stored in AL, in the fourth example, it is stored in BL.\n\nIn the immediate addressing mode, the operand is a constant value or an expression. When an instruction with two operands uses immediate addressing, the first operand is normally a register, and the second operand is an immediate constant. If labels are used, labels declared with EQU indicate a value, labels declared otherwise refer to an address. The first two examples above use immediate addressing. In the first example, the immediate operand is the address referred to by \"qname\", in the second example, the immediate operand is the number 9.\n\nIn the memory addressing mode, the operand is a value stored in memory. The memory operand may be the first operand, or the second operand, but not both (the other operand normally being a register). Operands specified in a memory-addressing mode require access to the main memory, usually to the data segment. As a result, they tend to be slower than either of the two previous addressing modes.\n\nTo locate a data item in the data segment, we need two components: the data segment start address and an offset value within the segment. The start address of the segment is typically found in the special purpose DS register. The offset value is often called the effective address.\n\nThere are various memory-addressing modes, differing in the way how the offset value of the data is specified. In the direct addressing mode, the offset value is specified directly as part of the instruction. In an assembly language program, this value is usually indicated by the variable name of the data item. The assembler will translate this name into its associated offset value during the assembly process. To facilitate this translation, the assembler maintains a symbol table. The symbol table stores the offset values of all variables in the assembly language program. Examples from our HELLO3.ASM program:\n\n lea edi, [hname]\n\n mov cl, [buffer + 1]\n\n lea esi, [buffer + 2]\n\n The first example loads the effective address of the variable \"hname\" into the EDI register. The second example loads the effective address corresponding to the memory location referred to by the variable \"buffer\" + 1 byte, i.e. the memory address located at an offset of +1 with respect to \"buffer\". If you consider what I said concerning the keyboard buffer, the instruction MOV CL, [BUFFER + 1] loads the CL register with the number of characters actually entered by the user. The third example loads the ESI register with the effective address immediately following the one in example 2 (memory location with offset +2 with respect to \"buffer\"), that actually is the memory location containing the first character entered by the user. Important: As a difference with what you may read on some Internet sites or in some assembly manuals, with NASM, the usage of square brackets with effective addresses is mandatory!\n\nIn the indirect addressing mode, the operand stored in memory is not coded (as address or variable) in the assembly instruction, but the operand's address is loaded into an index register (ESI, EDI, SI, DI; you can also use EBX and BX) and this register is used in the instruction to designate the memory operand. As this operand actually is the value stored at the address contained in the index register and not the value in the index register, the index register has to be put between square brackets. Examples from HELLO3.ASM:\n\n mov bl, [esi]\n\n mov [edi], bl\n\n In the first example, the content of the address contained in ESI is moved into the BL register (as BL is an 8-bit register, 1 byte will be moved). In the second example, the content of BL is moved into the address contained in EDI. With the two instructions together, we actually move one byte of data from one memory location to another. And in our sample program, by incrementing the address in ESI and EDI and repeating the move, we can copy the name entered by the user from the keyboard buffer area to the \"hname\" area in our output string.\n\nI said above that immediate addressing is normally used with a register as first operand, and that in memory addressing mode, one of the operands is normally a register. NASM also allows to use a constant value with memory addressing. However, this presents a problem. If a register is involved, we know the size of the second operand, actually equal to the size of the register. Thus, moving a constant to DL will move one byte, moving it to DX will move 2 bytes. But if the destination is a memory address? How does the assembler know how many bytes we want to move to this, and possibly the following addresses? It can't know it for sure, and that's why we explicitly tell it by using a type specifier. These specifiers are: BYTE (1 byte), WORD (2 bytes), DWORD (4 bytes), QWORD (8 bytes), and TBYTE (10 bytes). Examples from our HELLO3.ASM program:\n\n mov byte [edi + 1], 13\n\n mov byte [edi + 2], 10\n\n mov byte [edi + 3], '$'\n\n In all three examples, we move one single byte. In fact, there are three bytes that are moved to 3 successive memory locations. Do you recognize the byte sequence? Carriage-return + linefeed, followed by a dollar symbol to terminate the memory area containing a string that will be written to the screen using DOS interrupt 21h.\n\nA final point, that has to be discussed before we return to our HELLO3.ASM program, is the way, how data is stored in memory. Data has essentially 4 sources: user input via the keyboard, constants and declared variables in the assembly program, result of some computation (and data read from a file). Keyboard input always produces ASCII codes (and screen output always has to be ASCII codes), independently if a character, string or number is entered. In an assembly program, a character value is stored as an ASCII character, a string as a sequence of ASCII characters, stored at successive memory addresses. All integer numbers, used in an assembly program, are stored in hexadecimal format, independently if they are written as hexadecimal, decimal or otherwise (except for a string representation). Integer computations, like arithmetic or logical operations normally await hexadecimal numbers as input, and generate as result a hexadecimal number. If the integers have to be treated as signed or not depends on the programmer. Floating point numbers have their own format. Some examples from our HELLO3.ASM program):\n\n maxlen equ 20\n\n buffer db maxlen + 1\n\n hello db 13, 10, 'Hello '\n\n The first example doesn't store anything in memory; the constant will be replaced by its value: 20 -> 14h.\n\n In the second example the value 21 -> 15h will be stored at address \"buffer\" (more exactly with an offset +\"buffer\" with respect to the content of the DS register).\n\n The third example stores a sequence of bytes at address \"hello\" and following: 13 -> 0Dh, 10 -> 0Ah, Hello + space -> 48h 65h 6Ch 6Ch 6Fh 20h.\n\nThings become a little bit more complicated when storing multibyte data. This applies when moving the content of 16- or 32-bit registers to memory, or declaring variables with DW, DD, etc. In fact, there are two ways to store this data, two completely different byte-ordering schemes possible: Either, the processor stores the most significant byte before the least significant one, or it stores it after it. In both cases, the memory area has to be referred to by specifying the lowest memory address. With a word (2 bytes) of data, the MSB is stored at this address and the LSB at the following one, in the case of CPUs that use big-endian byte ordering. In the case of CPUs that use little-endian byte ordering (as do x86 CPUs), it's the LSB that is stored at the lowest address (the one referred to by the variable), and the MSB that is stored at the following one.\n\nLets see an example. Consider the following code:\n\n num resb 2\n\n mov ax, 25159\n\n mov [num], ax\n\n 25159 decimal is 6247h hexadecimal, so a word-size number will be stored at memory locations num and num+1. With little-endian byte ordering, the LSB is stored at the lowest address (the one referred to by the variable). Thus, our data in memory will be as follows: byte 47h stored at address num and byte 62h stored at address num+1.\n\nHere an example with a negative number.:\n\n num dw -29255\n\n -29255 decimal is 8DB9h hexadecimal, and will be stored as follows: byte B9h stored at address num and byte 8Dh stored at address num+1.\n\nAnd an example with a double-word.:\n\n num dd 542803535\n\n 542803535 decimal is the 32-bit hexadecimal 205A864Fh hexadecimal, and will be stored as: 4Fh at address num, 86h at num+1, 5Ah at num+2, and 20h at num+3.\n\nSo, we have now all the necessary knowledge to understand how, in our HELLO3.ASM program, the name entered by the user is moved to the corresponding area within the greeting output string. We will not use the x86 string instructions, but will do the move byte by byte. First we initialize our copy routine with the code\n\n lea esi, [buffer + 2]\n\n lea edi, [hname]\n\n mov cl, [buffer + 1]\n\n We load the index register ESI with the address of the first character of the name entered by the user (remember that the keyboard input returned by the DOS read-string function starts within the buffer at the offset +2), and the index register EDI with the address within the output string area where the first character of the name has to be placed. As we will copy the name byte by byte, we need a loop counter. Here, we use the register CL, that we initialize with the length of the name (that has been stored into the buffer area at offset +1 by the DOS read-string function).\n\nNote: Maybe you wonder what's about this LEA instruction used here. LEA means \"load effective address\" and is nothing else than a special kind of MOV. In fact, both instructions do exactly the same, however, when using MOV, the move is done during assembly time, whereas when using LEA, the move is done during runtime. This allows to use instructions like, for example, LEA EBX,[array + ESI] to load EBX with the address of an element of \"array\", whose index is in the ESI register. Note, that when using a register's content to compute an address, you cannot use MOV. The instruction MOV EBX,[array + ESI] is not permitted, because at assembly time, the value in ESI might not be known. Why the second operand of the LEA instruction is placed between square brackets, no idea. It seems not logical to me, as it's an address (and not the content at an address) that is loaded. But, it's this way that you find it in NASM manuals and NASM source code examples.\n\nHere is the code of the loop that copies the name:\n\n copychar:\n\n mov bl, [esi]\n\n mov [edi], bl\n\n inc esi\n\n inc edi\n\n dec cl\n\n test cl, cl\n\n jnz copychar\n\n We copy the byte from the source address (stored in ESI) to the destination address (stored in EDI). Then we increment the two index registers, that thus point to the next address within the source resp. destination area. For each byte copied, we decrement the counter (BL register). The loop is terminated when the counter is zero (the TEST instruction used here does a logic AND of its two operators, without changing the destination operand, but setting the flags; the zero flag will only be set here if the value in CL is 0).\n\nThe following lines of HELLO3.ASM are easy to understand. We add some further characters to the output string (an exclamation mark and a carriage-return + linefeed), then we add, and this is really important as you should know, the dollar symbol to terminate the output string (note the usage of the type specifier BYTE in these moves of an immediate addressing mode operand to a memory location), and finally we load DX with the address of the output string (and AH with function code 09h) to display the greeting message, calling the DOS write-string function.\n\nAs, besides showing how to use NASM on DOS, the purpose of this tutorial also is to give people, who want to learn the assembly programming language, some basic knowledge in order to create their own assembly programs, it's obvious that it has to contain some details concerning numbers and how to process them. I said above that all keyboard input and screen output is in ASCII format. I also said that the arithmetic and logical expressions normally use numbers in hexadecimal format. One way to work with integers would thus be to convert the input operands from ASCII to hexadecimal numbers, to perform the calculations and to convert the results from hexadecimal numbers to ASCII in order to display them onto the screen. This way to proceed is not covered in this tutorial. If you seriously preview to write assembly language programs performing calculations, you should download one of the assembly books available on the Internet; there are chances that you'll find the code of such conversion routines in most of them.\n\nInstead of converting the numbers from ASCII to hexadecimal number and vice-versa, the tutorial shows how you can do calculations on integers as they are when entered from the keyboard, i.e. integers in ASCII representation. The x86 processor includes instructions to perform ASCII arithmetic operations. In short (and without discussing the details how this actually works), it's using the ASCII codes of two integer digits as operands, using the standard addition, subtraction. multiplication, or division operators to calculate the result, that then has to be adjusted using the corresponding ASCII adjust instruction (that will give a result in ASCII representation, ready to be displayed on the screen).\n\nThe following table shows the x86 arithmetic instructions and the corresponding ASCII adjust instructions.\n\nASCII addition: As the ASCII adjust instructions require the usage of the AX register, a typical ASCII addition (with 2 1-digit operands) consists in the following:\n• Making sure that the AH register is cleared.\n• Moving the first operand to AL.\n• Adding the second operand (register, immediate, or memory addressing) to AL (result in AL).\n• Doing the ASCII adjust after addition (result as unpacked BCD representation in AX).\n• Converting the unpacked BCD to ASCII (for example, using ).\n\nThe result is two bytes in size, the MSB either being 30h or 31h (ASCII codes of characters 0 resp. 1). In this latter case, there had been a: the carry flag is set and can be used with the(add with carry) instruction in order to performon multibyte operands, using a loop (cf. next section).\n\nNote: Unpacked BCD (binary coded decimal) is an integer representation, where each digit of the decimal number is represented by the corresponding hexadecimal number. Examples for a 2-byte unpacked BCD: 8 = 0008h, 12 = 0102h.\n\nASCII subtraction: It works the same way as ASCII addition. If there is a borrow, the carry flag is set and can be used with the SBB (subtract with borrow) instruction in order to perform ASCII subtractions on multibyte operands, using a loop.\n\nIf you do these calculations for the operation 3 - 9, the AAS instruction will give the result AX = FF04h and after conversion from BCD to ASCII, AL = 34h, ASCII code for the character '4'. The number is recognized as negative, as the AAS instruction has set the carry flag. The result itself is obviously not what it should be. So, another way has to be used to perform subtractions with a negative result. On the other hand, the result obtained is useful with multibyte operands subtractions with a borrow. In the subtraction 53 - 29, for example, the first loop iteration gives 3 - 9 -> AL = 34h (cf. above) and the second one (we use SBB and the carry has been set because of the borrow) gives 5 - 2 - 1 -> AL = 32h. The result of the operation is thus 3234h. These are the ASCII codes for '2' and '4', and 24 is well the correct result of the subtraction.\n\nASCII multiplication: The AAM instruction is used to adjust the result of a MUL instruction. Note that MUL has only one operand; for byte multiplication, the other operand must be a value in the AL register, the result is a word that will be stored in AX (in the case of a word multiplication, one operand must be in AX; the result will be a double word with its MSW stored in DX and its LSW stored in AX). Not necessary here to clear the AH register. On the other hand, multiplication should not be performed on ASCII numbers; use unpacked BCD operands instead. This means that for two numbers entered from the keyboard, we'll have to convert them from ASCII to unpacked BCD: 30h -> 00h, 31h -> 01h, ... We'll have to mask off the upper four bits of the number in ASCII representation (what may be done by an AND operation of the register containing the operand and 0Fh).\n\nMultiplication example:\n\n mov al, ’3’ \n\n mov bl, ’9’ \n\n and al, 0fh \n\n and bl, 0fh \n\n mul bl \n\n aam \n\n or ax, 3030h\n\nSo, we have now all the necessary knowledge to understand the CALC.ASM sample. The program allows to add, subtract and multiply two 1-digit positive integers (no calculation if the subtraction result is negative). The user is asked for an operation string of the form <operand1><operator><operand2>, where <operand1> and <operand2> are numbers from 0 to 9 (no validity check done), and <operator> is one of the symbols '+', '-', and '*'. Here is the code:\n\nsegment code\n\n ..start:\n\n \n\n mov ax, data\n\n mov ds, ax\n\n mov ax, stack\n\n mov ss, ax\n\n mov sp, stacktop\n\n \n\n mov dx, stitle\n\n mov ah, 9\n\n int 21h\n\n \n\n mov dx, sop\n\n mov ah, 9\n\n int 21h\n\n \n\n mov dx, buffer\n\n mov ah, 0ah\n\n int 21h\n\n mov al, [buffer + 2] \n\n mov ah, 0\n\n mov bl, [buffer + 4] \n\n mov cl, [buffer + 3] \n\n \n\n cmp cl, '+'\n\n je addition\n\n cmp cl, '-'\n\n je subtraction\n\n cmp cl, '*'\n\n je multiplication\n\n \n\n mov dx, serr\n\n mov ah, 9\n\n int 0x21\n\n jmp exit\n\n \n\n addition:\n\n add al, bl\n\n aaa\n\n jmp result\n\n \n\n subtraction:\n\n cmp al, bl\n\n jl negative\n\n sub al, bl\n\n aas\n\n jmp result\n\n negative:\n\n mov dx, sneg\n\n mov ah, 9\n\n int 21h\n\n jmp exit\n\n \n\n multiplication:\n\n and al, 0fh\n\n and bl, 0fh\n\n mul bl\n\n aam\n\n \n\n result:\n\n or ax, 3030h\n\n mov [res], ah\n\n mov [res + 1], al\n\n mov dx, sresult\n\n mov ah, 9\n\n int 21h\n\n \n\n exit:\n\n mov ax, 0x4c00\n\n int 21h\n\n segment data\n\n stitle db 'Addition, subtraction, and multiplication', 13, 10\n\n db 'of two 1-digit positive integers', 13, 10, '$'\n\n sop db 'Operation ? ', '$'\n\n serr db 13, 10, 'Unknown operator!', 13, 10, '$'\n\n sneg db 13, 10, 'Result is negative', 13, 10, '$'\n\n buffer db 4\n\n resb 5\n\n sresult db 13, 10, 'Result = '\n\n res resb 2\n\n db 13, 10, '$'\n\n segment stack stack\n\n resb 64\n\n stacktop:\n\nI think that the code of this program shouldn't be to difficult to understand. We read the operation from the keyboard and move the first operand to AL, the second operand to BL and the operator to CL (remember that user input in the buffer starts with offset +2). We then check which operator has to to be used. The instruction CMP compares two values and sets the flags according to the comparison result; here we use the JE (jump if equal) instruction to branch to the label corresponding to the operation that we want to perform. If the operator is unknown, we display an error message. Addition and multiplication are done as explained above. The same for subtraction, but only after having tested if the result is well positive; we compare the two operands using CMP and use a JL (jump if less) to branch to the \"negative\" label (display of the message \"Result is negative\" instead of doing the subtraction). All 3 operations lead to the label \"result\" where we convert the BCD value in AX to ASCII, then move the operation result to the corresponding area within the output string. Note that we don't move AX as a whole, but move AL and AH separately; this is necessary because the little-endian byte ordering used by the x86 CPUs would inverse the two bytes! And finally we display the result string calling the DOS write-string function.\n\nThe sample program CALC2.ASM included in the download archive is identical to CALC.ASM, except that user input, calculation and the display of the result is placed within a loop. This allows to do successive calculations without leaving the program. The simplest way to leave the loop (and then terminate the program) is to do so if the user hasn't entered any operation (just hit the ENTER key). This can, for example be done by the following code (\"exit\" being the label referring to the address where the program termination code starts)\n\n mov al, [buffer + 1]\n\n cmp al, 0\n\n je exit\n\n All we have to do is to check if the number of characters entered by the user (this value has been placed into the keyboard buffer at offset +1 by the DOS read-string function) is zero and if so exit the loop and terminate the program.\n\nHere is the code of sample CALC3.ASM, which is a further extension of our simple calculation programs: If a subtraction has a negative result, instead of displaying a message, we do the calculation and display the negative result.\n\nsegment code\n\n ..start:\n\n \n\n mov ax, data\n\n mov ds, ax\n\n mov ax, stack\n\n mov ss, ax\n\n mov sp, stacktop\n\n \n\n mov dx, stitle\n\n mov ah, 9\n\n int 21h\n\n \n\n loop:\n\n mov dx, sop\n\n mov ah, 9\n\n int 21h\n\n \n\n mov dx, buffer\n\n mov ah, 0ah\n\n int 21h\n\n \n\n mov al, [buffer + 1]\n\n cmp al, 0\n\n je exit\n\n \n\n mov al, [buffer + 2] \n\n mov ah, 0\n\n mov bl, [buffer + 4] \n\n mov cl, [buffer + 3] \n\n \n\n cmp cl, '+'\n\n je addition\n\n cmp cl, '-'\n\n je subtraction\n\n cmp cl, '*'\n\n je multiplication\n\n \n\n mov dx, serr\n\n mov ah, 9\n\n int 0x21\n\n jmp loop\n\n \n\n addition:\n\n mov byte [res], ' '\n\n add al, bl\n\n aaa\n\n jmp result\n\n \n\n subtraction:\n\n mov byte [res], ' '\n\n cmp al, bl\n\n jge subtract\n\n mov cl, al\n\n mov al, bl\n\n mov bl, cl\n\n mov byte [res], '-'\n\n subtract:\n\n sub al, bl\n\n aas\n\n jmp result\n\n \n\n multiplication:\n\n mov byte [res], ' '\n\n and al, 0fh\n\n and bl, 0fh\n\n mul bl\n\n aam\n\n \n\n result:\n\n or ax, 3030h\n\n mov [res + 1], ah\n\n mov [res + 2], al\n\n mov dx, sresult\n\n mov ah, 9\n\n int 21h\n\n jmp loop\n\n \n\n exit:\n\n mov ax, 0x4c00\n\n int 21h\n\n segment data\n\n stitle db 'Addition, subtraction, and multiplication', 13, 10\n\n db 'of two 1-digit positive integers', 13, 10, '$'\n\n sop db 'Operation ? ', '$'\n\n serr db 13, 10, 'Unknown operator!', 13, 10, '$'\n\n buffer db 4\n\n resb 5\n\n sresult db 13, 10, 'Result = '\n\n res resb 3\n\n db 13, 10, '$'\n\n segment stack stack\n\n resb 64\n\n stacktop:\n\nLets have a look at the code. First of all, our output number now has a length of 3 characters: the sign plus two number digits; so, we have to reserve 3 bytes for the variable \"res\" (vs. 2 bytes in CALC.ASM). The first part of the code is identical to the one in CALC.ASM, except that I use a loop for successive calculations, as described for CALC2.ASM. Addition and multiplication are the same as in CALC.ASM, except that we have to consider the sign of the result; always positive, we move a space to \"res\" offset +0. The code for the subtraction is different, of course. Doing calculations with negative numbers does not necessarily mean that we have to use negative hexadecimals. As in this case, where the subtraction a - b, with a < b, can be calculated as b - a (and moving a minus sign to the first byte of the result area). And that's what's done in this program: I check if the first operand is less than the second one. If no, I just do the subtraction (I assumed the result to be positive and moved a space to the \"sign location\" before doing the compare); if yes, I simply swap the operands (and move a '-' to the \"sign location\"), then jump to the standard subtraction code. The display of the result is the same as in CALC.ASM, but the moves have to be adapted. Because of the sign, the MSB has now to be moved to a location with offset +1, the LSB to a location with offset +2 (vs. offset +0 and +1 in CALC.ASM).\n\nBeing able to do arithmetic operations on 1-digit numbers doesn't take us really far, so some hints concerning arithmetic operations with integers with more than 1 digit should not be missing in the tutorial.\n\nThe sample ADD6.ASM asks for two 6-digit positive integers and outputs their sum (as a 7-digit positive integer) onto the screen. As for the programs before, there is no numeric validity check, and the user has to enter the full 6 digits (i.e. has to enter the leading zeros), and the result is always displayed as a 7-digit number (i.e. is displayed with the leading zeros). It should not be to difficult to adapt the program for subtraction; multiplication would probably need a bigger effort. One nice thing in this program: The definition of a constant with the number length (number of digits) and the usage of this constant to calculate offsets (instead of using numeric literals) allows to adapt the code for the addition of two positive integers of any size (less than 256 digits, of course) by changing one single line in the source. Here is the code:\n\nsegment code\n\n ..start:\n\n \n\n mov ax, data\n\n mov ds, ax\n\n mov ax, stack\n\n mov ss, ax\n\n mov sp, stacktop\n\n \n\n loop:\n\n mov dx, snum1\n\n mov ah, 09h\n\n int 21h\n\n \n\n mov dx, num1\n\n mov ah, 0ah\n\n int 21h\n\n mov al, [num1 + 1]\n\n cmp al, 0\n\n je exit \n\n \n\n mov dx, snum2\n\n mov ah, 09h\n\n int 21h\n\n \n\n mov dx, num2\n\n mov ah, 0ah\n\n int 21h\n\n \n\n lea esi, [num1 + numlen + 1]\n\n lea edi, [res + numlen]\n\n mov cl, numlen\n\n clc\n\n pushf\n\n digit:\n\n mov al, [esi] \n\n mov ah, 0\n\n mov bl, [esi + numlen + 3] \n\n popf\n\n adc al, bl\n\n aaa\n\n pushf\n\n or ax, 3030h\n\n mov [edi], al\n\n dec esi\n\n dec edi\n\n dec cl\n\n jnz digit\n\n mov [edi], ah\n\n popf\n\n \n\n mov dx, sresult\n\n mov ah, 09h\n\n int 21h\n\n jmp loop\n\n \n\n exit:\n\n mov ax, 0x4c00\n\n int 21h\n\n segment data\n\n numlen equ 6\n\n stitle db 13, 10, 'Addition, of two 6-digit positive integers', '$'\n\n snum1 db 13, 10, 'First number ? ', '$'\n\n snum2 db 13, 10, 'Second number ? ', '$'\n\n sresult db 13, 10, 'Result = '\n\n res resb numlen + 1\n\n db 13, 10, '$'\n\n num1 db numlen + 1\n\n resb numlen + 2\n\n num2 db numlen + 1\n\n resb numlen + 2\n\n segment stack stack\n\n resb 64\n\n stacktop:\n\nThe program consists of a loop that reads the two operands, does the addition and displays the result. The loop (and the program) is terminated if the user enters no data (just hits ENTER) when asked for the first operand. The 2 operands are read into the two keyboard input buffers \"num1\" and \"num2\". The value at offset +1 in the \"num1\" buffer area is the length of the first operand read; testing if this value is 0 allows to exit the loop if the user didn't enter any data for the first operand.\n\nDoing a multibyte addition is performing a loop, where each iteration does the addition of two 1-digit operands (this is what we did in the program samples before), starting with the LSB and continuing until all digits have been processed. The important thing here is to consider the possible carry: if a 1-digit operands addition produces a carry, it has to be added when adding the following two 1-digit operands. The obvious problem that occurs here is that the operations after the addition can (and will) modify the carry flag, and we loose its value. This means that after a 1-digit operands addition has been done, we have to save the carry flag, in order to be able to add it when performing the following 1-digit operands addition. The method used here is probably the easiest way to save the value of any flag: push the flag register onto the stack and pop it back when you need the flag values from before.\n\nLets have a look at the loop initialization code:\n\n lea esi, [num1 + numlen + 1]\n\n lea edi, [res + numlen]\n\n mov cl, numlen\n\n clc\n\n pushf\n\n We load ESI with the address of the first operand (using offsets, we will also use ESI to point to the second operand), and EDI with the address of the addition result. CL is loaded with the loop counter variable, i.e. the number of the operands' digits. To do the multibyte addition, we must proceed from LSB to MSB, so starting with the last digit of the operands and writing the corresponding sum digit to the last digit location of the result area. With the first digit located at offset +0, the nth digit is located at an offset of +(n-1). As the operands have numlen digits and the first digit in the \"num1\" buffer has an offset of +2, the address of the last digit of operand 1 is given by num1 + 2 + (numlen - 1) = num1 + numlen + 1. The result area is one digit longer than the operands' length (numlem + 1), so the address of the last digit of the result is given by res + [(numlen + 1) - 1] = res + numlen.\n\n The last two lines of the code above concern the carry. As within the loop we pop the flags register before doing the 1-digit operands addition, we have to push it onto the stack here; this is done using the instruction PUSHF. To be sure that the carry is zero for the first addition, we perform a CLC (clear carry) before pushing the register.\n\nThe addition of the two 1-digit operands is similar as in the programs before (as we have to consider the carry of the preceding addition, we must use the instruction ADC instead of ADD): We load one operand into AL, the other in BL, add the two (+ the carry) with the result in AL, then perform the AAA and OR AX, 3030h, and finally store AL to its correct position within the \"res\" variable area. The address of the first operand's digit is contained in ESI, the corresponding result digit's address in EDI. Concerning the address of the second operand's digit, we will compute it by adding a given offset to the address of the first operand's digit (content of ESI). If you look at the data segment, you can see that the two numbers' buffer areas succeed to each other, the buffer of the first operand ending with 1 extra location for the carriage-return, the buffer of the second operand beginning with two extra locations for the maximum resp. actual string length. Beside the extra locations, the offset depends on the operands' size (number of digits), declared by the constant \"numlen\". The second operand's address is thus given by ESI + numlen + 1 + 2 = ESI + numlen + 3.\n\nThe carry, that we need to consider in our ADC instruction is the one set (or not) by AAA, thus it is immediately after this instruction that we have to save it (using PUSHF to push the flags register onto the stack). And to use this carry with the ADC of the next digit, we restore it with a POPF immediately before the addition instruction.\n\nFinally, we have to point the indexes to the next operand's and result's digit; this is done by decrementing the values in ESI and EDI (decrementing, because we add the digits from LSB to MSB). We also decrement the loop counter (number of digits that remain to process). And we continue looping until this counter is zero.\n\nTwo things that have to be done when the loop is terminated. First, we haven't yet considered the carry of the MSB digits addition (case where the result is greater that 999999). As we saw when discussing the 1-digit operands ASCII addition, the addition result will be in AX, so AH will contain the correct value (30h or 31h), if there has been a carry or not. Thus, we can use the instruction MOV [EDI], AH to fill in the MSB of the result (EDI having been decremented after the last addition points now to the first location within the result's memory area, i.e. the location where we want to store AH).\n\nA final sample to terminate this tutorial. The program FIBO.ASM doesn't contain any new assembly language elements, but it is interesting, because it solves a problem that is stated in lots of programming language manuals: the calculation of the Fibonacci series. These are a series of numbers defined by the function f(n) = n-2 + n-1, with f(0) = 0 and f(1) = 1. FIBO.ASM calculates and displays the first 20 numbers of the series, as shown on the screenshot below.\n\nI think that with the knowledge that you have acquired when working through this tutorial, it should not be to difficult to understand the code of FIBO.ASM, shown here, without further explanations.\n\nsegment code\n\n ..start:\n\n \n\n mov ax, data\n\n mov ds, ax\n\n mov ax, stack\n\n mov ss, ax\n\n mov sp, stacktop\n\n \n\n lea esi, [series + 3]\n\n mov ch, count - 2\n\n loop:\n\n mov cl, 4\n\n clc\n\n pushf\n\n fdigit:\n\n mov al, [esi]\n\n mov ah, 0\n\n mov bl, [esi + 4]\n\n popf\n\n adc al, bl\n\n aaa\n\n pushf\n\n or ax, 3030h\n\n mov [esi + 8], al\n\n dec esi\n\n dec cl\n\n jnz fdigit\n\n popf\n\n add esi, 8\n\n dec ch\n\n jnz loop\n\n \n\n lea esi, [series]\n\n mov ch, count\n\n display:\n\n mov cl, 4\n\n lea edi, [sfib]\n\n ddigit:\n\n mov bl, [esi]\n\n mov [edi], bl\n\n inc esi\n\n inc edi\n\n dec cl\n\n jnz ddigit\n\n mov dx, sfib\n\n mov ah, 9\n\n int 0x21\n\n dec ch\n\n jnz display\n\n \n\n exit:\n\n mov ax, 0x4c00\n\n int 21h\n\n segment data\n\n count equ 20\n\n series db '0000'\n\n db '0001'\n\n times count - 2 resb 4\n\n sfib resb 4\n\n db 13, 10, '$'\n\n segment stack stack\n\n resb 64\n\n stacktop:\n\nI hope that following this tutorial, you got everything you need to create 16-bit real mode and 16-bit protected mode assembly programs on DOS using NASM, and that the sample programs shown with my explanations and comments has given you a base for developing your own assembly programs. If you are serious in 16-bit assembly programming, the manual Introduction to Assembly Programming - For Pentium and RISC Processors, Sivarama P. Dandamudi, © 2005, 1998 Springer Science+Business Media, Inc. might be really helpful. It contains a comprehensive introduction to basic computer organization, the Pentium Processor, and the x86 assembly language, including a lots of code and sample programs, that you can use as a base for your own assembly projects. The manual is available as PDF document on the Internet...\n\nIf you find this text helpful, please, support me and this website by signing my guestbook."
    },
    {
        "link": "https://leopard-adc.pepas.com/documentation/DeveloperTools/nasm/nasmdoc4.html",
        "document": "NASM contains a powerful macro processor, which supports conditional assembly, multi-level file inclusion, two forms of macro (single-line and multi-line), and a `context stack' mechanism for extra macro power. Preprocessor directives all begin with a sign.\n\nThe preprocessor collapses all lines which end with a backslash (\\) character into a single line. Thus:\n\nwill work like a single-line macro without the backslash-newline sequence.\n\nSingle-line macros are defined using the preprocessor directive. The definitions work in a similar way to C; so you can do things like\n\nwhich will expand to\n\nWhen the expansion of a single-line macro contains tokens which invoke another macro, the expansion is performed at invocation time, not at definition time. Thus the code\n\nwill evaluate in the expected way to , even though the macro wasn't defined at the time of definition of .\n\nMacros defined with are case sensitive: after , only will expand to : or will not. By using instead of (the `i' stands for `insensitive') you can define all the case variants of a macro at once, so that would cause , , , and so on all to expand to .\n\nThere is a mechanism which detects when a macro call has occurred as a result of a previous expansion of the same macro, to guard against circular references and infinite loops. If this happens, the preprocessor will only expand the first occurrence of the macro. Hence, if you code\n\nthe macro will expand once, becoming , and will then expand no further. This behaviour can be useful: see section 8.1 for an example of its use.\n\nYou can overload single-line macros: if you write\n\nthe preprocessor will be able to handle both types of macro call, by counting the parameters you pass; so will become whereas will become . However, if you define\n\nthen no other definition of will be accepted: a macro with no parameters prohibits the definition of the same name as a macro with parameters, and vice versa.\n\nThis doesn't prevent single-line macros being redefined: you can perfectly well define a macro with\n\nand then re-define it later in the same source file with\n\nThen everywhere the macro is invoked, it will be expanded according to the most recent definition. This is particularly useful when defining single-line macros with (see section 4.1.5).\n\nYou can pre-define single-line macros using the `-d' option on the NASM command line: see section 2.1.12.\n\nTo have a reference to an embedded single-line macro resolved at the time that it is embedded, as opposed to when the calling macro is expanded, you need a different mechanism to the one offered by . The solution is to use , or it's case-insensitive counterpart .\n\nSuppose you have the following code:\n\nIn this case, is equal to 0, and is equal to 1. This is because, when a single-line macro is defined using , it is expanded only when it is called. As expands to , the expansion will be the current value of . The first time it is called that is 0, and the second time it is 1.\n\nIf you wanted to expand to the value assigned to the embedded macro at the time that was defined, you need to change the above code to use .\n\nNow, each time that is called, it expands to 1, as that is what the embedded macro expanded to at the time that was defined.\n\nIndividual tokens in single line macros can be concatenated, to produce longer tokens for later processing. This can be useful if there are several similar macros that perform similar functions.\n\nAs an example, consider the following:\n\nNow, if we need to access the elements of tBIOSDA in different places, we can end up with:\n\nThis will become pretty ugly (and tedious) if used in many places, and can be reduced in size significantly by using the following macro:\n\nNow the above code can be written as:\n\nUsing this feature, we can simplify references to a lot of macros (and, in turn, reduce typing errors).\n\nSingle-line macros can be removed with the command. For example, the following sequence:\n\nwill expand to the instruction , since after the macro is no longer defined.\n\nMacros that would otherwise be pre-defined can be undefined on the command-line using the `-u' option on the NASM command line: see section 2.1.13.\n\nAn alternative way to define single-line macros is by means of the command (and its case-insensitive counterpart , which differs from in exactly the same way that differs from ).\n\nis used to define single-line macros which take no parameters and have a numeric value. This value can be specified in the form of an expression, and it will be evaluated once, when the directive is processed.\n\nLike , macros defined using can be re-defined later, so you can do things like\n\nto increment the numeric value of a macro.\n\nis useful for controlling the termination of preprocessor loops: see section 4.5 for an example of this. Another use for is given in section 7.4 and section 8.1.\n\nThe expression passed to is a critical expression (see section 3.8), and must also evaluate to a pure number (rather than a relocatable reference such as a code or data address, or anything involving a register).\n\nIt's often useful to be able to handle strings in macros. NASM supports two simple string handling macro operators from which more complex operations can be constructed.\n\nThe macro is like macro in that it creates (or redefines) a numeric value to a macro. The difference is that with , the numeric value is the length of a string. An example of the use of this would be:\n\nIn this example, would receive the value 8, just as if an had been used. In this example, was a literal string but it could also have been a single-line macro that expands to a string, as in the following example:\n\nAs in the first case, this would result in being assigned the value of 8.\n\nIndividual letters in strings can be extracted using . An example of its use is probably more useful than the description:\n\nIn this example, mychar gets the value of 'y'. As with (see section 4.2.1), the first parameter is the single-line macro to be created and the second is the string. The third parameter specifies which character is to be selected. Note that the first index is 1, not 0 and the last index is equal to the value that would assign given the same string. Index values out of range result in an empty string.\n\nMulti-line macros are much more like the type of macro seen in MASM and TASM: a multi-line macro definition in NASM looks something like this.\n\nThis defines a C-like function prologue as a macro: so you would invoke the macro with a call such as\n\nwhich would expand to the three lines of code\n\nThe number after the macro name in the line defines the number of parameters the macro expects to receive. The use of inside the macro definition refers to the first parameter to the macro call. With a macro taking more than one parameter, subsequent parameters would be referred to as , and so on.\n\nMulti-line macros, like single-line macros, are case-sensitive, unless you define them using the alternative directive .\n\nIf you need to pass a comma as part of a parameter to a multi-line macro, you can do that by enclosing the entire parameter in braces. So you could code things like\n\nAs with single-line macros, multi-line macros can be overloaded by defining the same macro name several times with different numbers of parameters. This time, no exception is made for macros with no parameters at all. So you could define\n\nto define an alternative form of the function prologue which allocates no local stack space.\n\nSometimes, however, you might want to `overload' a machine instruction; for example, you might want to define\n\nso that you could code\n\nOrdinarily, NASM will give a warning for the first of the above two lines, since is now defined to be a macro, and is being invoked with a number of parameters for which no definition has been given. The correct code will still be generated, but the assembler will give a warning. This warning can be disabled by the use of the command-line option (see section 2.1.18).\n\nNASM allows you to define labels within a multi-line macro definition in such a way as to make them local to the macro call: so calling the same macro multiple times will use a different label each time. You do this by prefixing to the label name. So you can invent an instruction which executes a if the flag is set by doing this:\n\nYou can call this macro as many times as you want, and every time you call it NASM will make up a different `real' name to substitute for the label . The names NASM invents are of the form , where the number 2345 changes with every macro call. The prefix prevents macro-local labels from interfering with the local label mechanism, as described in section 3.9. You should avoid defining your own labels in this form (the prefix, then a number, then another period) in case they interfere with macro-local labels.\n\nOccasionally it is useful to define a macro which lumps its entire command line into one parameter definition, possibly after extracting one or two smaller parameters from the front. An example might be a macro to write a text string to a file in MS-DOS, where you might want to be able to write\n\nNASM allows you to define the last parameter of a macro to be greedy, meaning that if you invoke the macro with more parameters than it expects, all the spare parameters get lumped into the last defined one along with the separating commas. So if you code:\n\nthen the example call to above will work as expected: the text before the first comma, , is used as the first macro parameter and expanded when is referred to, and all the subsequent text is lumped into and placed after the .\n\nThe greedy nature of the macro is indicated to NASM by the use of the sign after the parameter count on the line.\n\nIf you define a greedy macro, you are effectively telling NASM how it should expand the macro given any number of parameters from the actual number specified up to infinity; in this case, for example, NASM now knows what to do when it sees a call to with 2, 3, 4 or more parameters. NASM will take this into account when overloading macros, and will not allow you to define another form of taking 4 parameters (for example).\n\nOf course, the above macro could have been implemented as a non-greedy macro, in which case the call to it would have had to look like\n\nNASM provides both mechanisms for putting commas in macro parameters, and you choose which one you prefer for each macro definition.\n\nSee section 5.2.1 for a better way to write the above macro.\n\nNASM also allows you to define a multi-line macro with a range of allowable parameter counts. If you do this, you can specify defaults for omitted parameters. So, for example:\n\nThis macro (which makes use of the macro defined in section 4.3.3) can be called with an explicit error message, which it will display on the error output stream before exiting, or it can be called with no parameters, in which case it will use the default error message supplied in the macro definition.\n\nIn general, you supply a minimum and maximum number of parameters for a macro of this type; the minimum number of parameters are then required in the macro call, and then you provide defaults for the optional ones. So if a macro definition began with the line\n\nthen it could be called with between one and three parameters, and would always be taken from the macro call. , if not specified by the macro call, would default to , and if not specified would default to .\n\nYou may omit parameter defaults from the macro definition, in which case the parameter default is taken to be blank. This can be useful for macros which can take a variable number of parameters, since the token (see section 4.3.5) allows you to determine how many parameters were really passed to the macro call.\n\nThis defaulting mechanism can be combined with the greedy-parameter mechanism; so the macro above could be made more powerful, and more useful, by changing the first line of the definition to\n\nThe maximum parameter count can be infinite, denoted by . In this case, of course, it is impossible to provide a full set of default parameters. Examples of this usage are shown in section 4.3.6.\n\nFor a macro which can take a variable number of parameters, the parameter reference will return a numeric constant giving the number of parameters passed to the macro. This can be used as an argument to (see section 4.5) in order to iterate through all the parameters of a macro. Examples are given in section 4.3.6.\n\nUnix shell programmers will be familiar with the shell command, which allows the arguments passed to a shell script (referenced as , and so on) to be moved left by one place, so that the argument previously referenced as becomes available as , and the argument previously referenced as is no longer available at all.\n\nNASM provides a similar mechanism, in the form of . As its name suggests, it differs from the Unix in that no parameters are lost: parameters rotated off the left end of the argument list reappear on the right, and vice versa.\n\nis invoked with a single numeric argument (which may be an expression). The macro parameters are rotated to the left by that many places. If the argument to is negative, the macro parameters are rotated to the right.\n\nSo a pair of macros to save and restore a set of registers might work as follows:\n\nThis macro invokes the instruction on each of its arguments in turn, from left to right. It begins by pushing its first argument, , then invokes to move all the arguments one place to the left, so that the original second argument is now available as . Repeating this procedure as many times as there were arguments (achieved by supplying as the argument to ) causes each argument in turn to be pushed.\n\nNote also the use of as the maximum parameter count, indicating that there is no upper limit on the number of parameters you may supply to the macro.\n\nIt would be convenient, when using this macro, to have a equivalent, which didn't require the arguments to be given in reverse order. Ideally, you would write the macro call, then cut-and-paste the line to where the pop needed to be done, and change the name of the called macro to , and the macro would take care of popping the registers in the opposite order from the one in which they were pushed.\n\nThis can be done by the following definition:\n\nThis macro begins by rotating its arguments one place to the right, so that the original last argument appears as . This is then popped, and the arguments are rotated right again, so the second-to-last argument becomes . Thus the arguments are iterated through in reverse order.\n\nNASM can concatenate macro parameters on to other text surrounding them. This allows you to declare a family of symbols, for example, in a macro definition. If, for example, you wanted to generate a table of key codes along with offsets into the table, you could code something like\n\nwhich would expand to\n\nYou can just as easily concatenate text on to the other end of a macro parameter, by writing .\n\nIf you need to append a digit to a macro parameter, for example defining labels and when passed the parameter , you can't code because that would be taken as the eleventh macro parameter. Instead, you must code , which will separate the first (giving the number of the macro parameter) from the second (literal text to be concatenated to the parameter).\n\nThis concatenation can also be applied to other preprocessor in-line objects, such as macro-local labels (section 4.3.2) and context-local labels (section 4.7.2). In all cases, ambiguities in syntax can be resolved by enclosing everything after the sign and before the literal text in braces: so concatenates the text to the end of the real name of the macro-local label . (This is unnecessary, since the form NASM uses for the real names of macro-local labels means that the two usages and would both expand to the same thing anyway; nevertheless, the capability is there.)\n\nNASM can give special treatment to a macro parameter which contains a condition code. For a start, you can refer to the macro parameter by means of the alternative syntax , which informs NASM that this macro parameter is supposed to contain a condition code, and will cause the preprocessor to report an error message if the macro is called with a parameter which is not a valid condition code.\n\nFar more usefully, though, you can refer to the macro parameter by means of , which NASM will expand as the inverse condition code. So the macro defined in section 4.3.2 can be replaced by a general conditional-return macro like this:\n\nThis macro can now be invoked using calls like , which will cause the conditional-jump instruction in the macro expansion to come out as , or which will make the jump a .\n\nThe macro-parameter reference is quite happy to interpret the arguments and as valid condition codes; however, will report an error if passed either of these, because no inverse condition code exists.\n\nWhen NASM is generating a listing file from your program, it will generally expand multi-line macros by means of writing the macro call and then listing each line of the expansion. This allows you to see which instructions in the macro expansion are generating what code; however, for some macros this clutters the listing up unnecessarily.\n\nNASM therefore provides the qualifier, which you can include in a macro definition to inhibit the expansion of the macro in the listing file. The qualifier comes directly after the number of parameters, like this:\n\nOr like this:\n\nSimilarly to the C preprocessor, NASM allows sections of a source file to be assembled only if certain conditions are met. The general syntax of this feature looks like this:\n\nThe clause is optional, as is the clause. You can have more than one clause as well.\n\nBeginning a conditional-assembly block with the line will assemble the subsequent code if, and only if, a single-line macro called is defined. If not, then the and blocks (if any) will be processed instead.\n\nFor example, when debugging a program, you might want to write code such as\n\nThen you could use the command-line option to create a version of the program which produced debugging messages, and remove the option to generate the final release version of the program.\n\nYou can test for a macro not being defined by using instead of . You can also test for macro definitions in blocks by using and .\n\nThe directive operates in the same way as the directive, except that it checks for the existence of a multi-line macro.\n\nFor example, you may be working with a large project and not have control over the macros in a library. You may want to create a macro with one name if it doesn't already exist, and another name if one with that name does exist.\n\nThe is considered true if defining a macro with the given name and number of arguments would cause a definitions conflict. For example:\n\nThis will create the macro \"MyMacro 1-3\" if no macro already exists which would conflict with it, and emits a warning if there would be a definition conflict.\n\nYou can test for the macro not existing by using the instead of . Additional tests can be performed in blocks by using and .\n\nThe conditional-assembly construct will cause the subsequent code to be assembled if and only if the top context on the preprocessor's context stack has the name . As with , the inverse and forms , and are also supported.\n\nFor more details of the context stack, see section 4.7. For a sample use of , see section 4.7.5.\n\nThe conditional-assembly construct will cause the subsequent code to be assembled if and only if the value of the numeric expression is non-zero. An example of the use of this feature is in deciding when to break out of a preprocessor loop: see section 4.5 for a detailed example.\n\nThe expression given to , and its counterpart , is a critical expression (see section 3.8).\n\nextends the normal NASM expression syntax, by providing a set of relational operators which are not normally available in expressions. The operators , , , , and test equality, less-than, greater-than, less-or-equal, greater-or-equal and not-equal respectively. The C-like forms and are supported as alternative forms of and . In addition, low-priority logical operators , and are provided, supplying logical AND, logical XOR and logical OR. These work like the C logical operators (although C has no logical XOR), in that they always return either 0 or 1, and treat any non-zero input as 1 (so that , for example, returns 1 if exactly one of its inputs is zero, and 0 otherwise). The relational operators also return 1 for true and 0 for false.\n\nThe construct will cause the subsequent code to be assembled if and only if and , after expanding single-line macros, are identical pieces of text. Differences in white space are not counted.\n\nis similar to , but is case-insensitive.\n\nFor example, the following macro pushes a register or number on the stack, and allows you to treat as a real register:\n\nLike most other constructs, has a counterpart , and negative forms and . Similarly, has counterparts , and .\n\nSome macros will want to perform different tasks depending on whether they are passed a number, a string, or an identifier. For example, a string output macro might want to be able to cope with being passed either a string constant or a pointer to an existing string.\n\nThe conditional assembly construct , taking one parameter (which may be blank), assembles the subsequent code if and only if the first token in the parameter exists and is an identifier. works similarly, but tests for the token being a numeric constant; tests for it being a string.\n\nFor example, the macro defined in section 4.3.3 can be extended to take advantage of in the following fashion:\n\nThen the macro can cope with being called in either of the following two ways:\n\nIn the first, is used as the address of an already-declared string, and is used as its length; in the second, a string is given to the macro, which therefore declares it itself and works out the address and length for itself.\n\nNote the use of inside the : this is to detect whether the macro was passed two arguments (so the string would be a single string constant, and would be adequate) or more (in which case, all but the first two would be lumped together into , and would be required).\n\nThe usual , and versions exist for each of , and .\n\nThe preprocessor directive will cause NASM to report an error if it occurs in assembled code. So if other users are going to try to assemble your source files, you can ensure that they define the right macros by means of code like this:\n\nThen any user who fails to understand the way your code is supposed to be assembled will be quickly warned of their mistake, rather than having to wait until the program crashes on being run and then not knowing what went wrong.\n\nNASM's prefix, though useful, cannot be used to invoke a multi-line macro multiple times, because it is processed by NASM after macros have already been expanded. Therefore NASM provides another form of loop, this time at the preprocessor level: .\n\nThe directives and ( takes a numeric argument, which can be an expression; takes no arguments) can be used to enclose a chunk of code, which is then replicated as many times as specified by the preprocessor:\n\nThis will generate a sequence of 64 instructions, incrementing every word of memory from to .\n\nFor more complex termination conditions, or to break out of a repeat loop part way along, you can use the directive to terminate the loop, like this:\n\nThis produces a list of all the Fibonacci numbers that will fit in 16 bits. Note that a maximum repeat count must still be given to . This is to prevent the possibility of NASM getting into an infinite loop in the preprocessor, which (on multitasking or multi-user systems) would typically cause all the system memory to be gradually used up and other applications to start crashing.\n\nUsing, once again, a very similar syntax to the C preprocessor, NASM's preprocessor lets you include other source files into your code. This is done by the use of the directive:\n\nwill include the contents of the file into the source file containing the directive.\n\nInclude files are searched for in the current directory (the directory you're in when you run NASM, as opposed to the location of the NASM executable or the location of the source file), plus any directories specified on the NASM command line using the option.\n\nThe standard C idiom for preventing a file being included more than once is just as applicable in NASM: if the file has the form\n\nthen including the file more than once will not cause errors, because the second time the file is included nothing will happen because the macro will already be defined.\n\nYou can force a file to be included even if there is no directive that explicitly includes it, by using the option on the NASM command line (see section 2.1.11).\n\nHaving labels that are local to a macro definition is sometimes not quite powerful enough: sometimes you want to be able to share labels between several macro calls. An example might be a ... loop, in which the expansion of the macro would need to be able to refer to a label which the macro had defined. However, for such a macro you would also want to be able to nest these loops.\n\nNASM provides this level of power by means of a context stack. The preprocessor maintains a stack of contexts, each of which is characterised by a name. You add a new context to the stack using the directive, and remove one using . You can define labels that are local to a particular context on the stack.\n\nThe directive is used to create a new context and place it on the top of the context stack. requires one argument, which is the name of the context. For example:\n\nThis pushes a new context called on the stack. You can have several contexts on the stack with the same name: they can still be distinguished.\n\nThe directive , requiring no arguments, removes the top context from the context stack and destroys it, along with any labels associated with it.\n\nJust as the usage defines a label which is local to the particular macro call in which it is used, the usage is used to define a label which is local to the context on the top of the context stack. So the and example given above could be implemented by means of:\n\nand invoked by means of, for example,\n\nwhich would scan every fourth byte of a string in search of the byte in .\n\nIf you need to define, or access, labels local to the context below the top one on the stack, you can use , or for the context below that, and so on.\n\nNASM also allows you to define single-line macros which are local to a particular context, in just the same way:\n\nwill define the single-line macro to be local to the top context on the stack. Of course, after a subsequent , it can then still be accessed by the name .\n\nIf you need to change the name of the top context on the stack (in order, for example, to have it respond differently to ), you can execute a followed by a ; but this will have the side effect of destroying all context-local labels and macros associated with the context that was just popped.\n\nNASM provides the directive , which replaces a context with a different name, without touching the associated macros and labels. So you could replace the destructive code\n\n4.7.5 Example Use of the Context Stack: Block IFs\n\nThis example makes use of almost all the context-stack features, including the conditional-assembly construct , to implement a block IF statement as a set of macros.\n\nThis code is more robust than the and macros given in section 4.7.2, because it uses conditional assembly to check that the macros are issued in the right order (for example, not calling before ) and issues a if they're not.\n\nIn addition, the macro has to be able to cope with the two distinct cases of either directly following an , or following an . It achieves this, again, by using conditional assembly to do different things depending on whether the context on top of the stack is or .\n\nThe macro has to preserve the context on the stack, in order to have the referred to by the macro be the same as the one defined by the macro, but has to change the context's name so that will know there was an intervening . It does this by the use of .\n\nA sample usage of these macros might look like:\n\nThe block- macros handle nesting quite happily, by means of pushing another context, describing the inner , on top of the one describing the outer ; thus and always refer to the last unmatched or .\n\nNASM defines a set of standard macros, which are already defined when it starts to process any source file. If you really need a program to be assembled with no pre-defined macros, you can use the directive to empty the preprocessor of everything but context-local preprocessor variables and single-line macros.\n\nMost user-level assembler directives (see chapter 5) are implemented as macros which invoke primitive directives; these are described in chapter 5. The rest of the standard macro set is described here.\n\nThe single-line macros , , and expand to the major, minor, subminor and patch level parts of the version number of NASM being used. So, under NASM 0.98.32p1 for example, would be defined to be 0, would be defined as 98, would be defined to 32, and would be defined as 1.\n\nThe single-line macro expands to a dword integer representing the full version number of the version of nasm being used. The value is the equivalent to , , and concatenated to produce a single doubleword. Hence, for 0.98.32p1, the returned number would be equivalent to:\n\nNote that the above lines are generate exactly the same code, the second line is used just to give an indication of the order that the separate values will be present in memory.\n\nThe single-line macro expands to a string which defines the version number of nasm being used. So, under NASM 0.98.32 for example,\n\n4.8.4 and : File Name and Line Number\n\nLike the C preprocessor, NASM allows the user to find out the file name and line number containing the current instruction. The macro expands to a string constant giving the name of the current input file (which may change through the course of assembly if directives are used), and expands to a numeric constant giving the current line number in the input file.\n\nThese macros could be used, for example, to communicate debugging information to a macro, since invoking inside a macro definition (either single-line or multi-line) will return the line number of the macro call, rather than definition. So to determine where in a piece of code a crash is occurring, for example, one could write a routine , which is passed a line number in and outputs something like `line 155: still here'. You could then write a macro\n\nand then pepper your code with calls to until you find the crash point.\n\nThe core of NASM contains no intrinsic means of defining data structures; instead, the preprocessor is sufficiently powerful that data structures can be implemented as a set of macros. The macros and are used to define a structure data type.\n\ntakes one parameter, which is the name of the data type. This name is defined as a symbol with the value zero, and also has the suffix appended to it and is then defined as an giving the size of the structure. Once has been issued, you are defining the structure, and should define fields using the family of pseudo-instructions, and then invoke to finish the definition.\n\nFor example, to define a structure called containing a longword, a word, a byte and a string of bytes, you might code\n\nThe above code defines six symbols: as 0 (the offset from the beginning of a structure to the longword field), as 4, as 6, as 7, as 39, and itself as zero.\n\nThe reason why the structure type name is defined at zero is a side effect of allowing structures to work with the local label mechanism: if your structure members tend to have the same names in more than one structure, you can define the above structure like this:\n\nThis defines the offsets to the structure fields as , , and .\n\nNASM, since it has no intrinsic structure support, does not support any form of period notation to refer to the elements of a structure once you have one (except the above local-label notation), so code such as is not valid. is a constant just like any other constant, so the correct syntax is or .\n\nHaving defined a structure type, the next thing you typically want to do is to declare instances of that structure in your data segment. NASM provides an easy way to do this in the mechanism. To declare a structure of type in a program, you code something like this:\n\nThe function of the macro is to make use of the prefix to advance the assembly position to the correct point for the specified structure field, and then to declare the specified data. Therefore the structure fields must be declared in the same order as they were specified in the structure definition.\n\nIf the data to go in a structure field requires more than one source line to specify, the remaining source lines can easily come after the line. For example:\n\nDepending on personal taste, you can also omit the code part of the line completely, and start the structure field on the next line:\n\nThe and macros provides a convenient way to align code or data on a word, longword, paragraph or other boundary. (Some assemblers call this directive .) The syntax of the and macros is\n\nBoth macros require their first argument to be a power of two; they both compute the number of additional bytes required to bring the length of the current section up to a multiple of that power of two, and then apply the prefix to their second argument to perform the alignment.\n\nIf the second argument is not specified, the default for is , and the default for is . So if the second argument is specified, the two macros are equivalent. Normally, you can just use in code and data sections and in BSS sections, and never need the second argument except for special purposes.\n\nand , being simple macros, perform no error checking: they cannot warn you if their first argument fails to be a power of two, or if their second argument generates more than one byte of code. In each of these cases they will silently do the wrong thing.\n\n(or with a second argument of ) can be used within structure definitions:\n\nThis will ensure that the structure members are sensibly aligned relative to the base of the structure.\n\nA final caveat: and work relative to the beginning of the section, not the beginning of the address space in the final executable. Aligning to a 16-byte boundary when the section you're in is only guaranteed to be aligned to a 4-byte boundary, for example, is a waste of effort. Again, NASM does not check that the section's alignment characteristics are sensible for the use of or .\n\nThe following preprocessor directives may only be used when TASM compatibility is turned on using the command line switch (This switch is described in section 2.1.17.)\n\nThe directive is used to simplify the handling of parameters passed on the stack. Stack based parameter passing is used by many high level languages, including C, C++ and Pascal.\n\nWhile NASM comes with macros which attempt to duplicate this functionality (see section 7.4.5), the syntax is not particularly convenient to use and is not TASM compatible. Here is an example which shows the use of without any external macros:\n\nThis is similar to the procedure defined in section 7.4.5 and adds the value in i to the value pointed to by j_ptr and returns the sum in the ax register. See section 4.7.1 for an explanation of and and the use of context stacks.\n\nThe directive is used in conjunction with the (see section 4.9.1) and the (see section 4.9.3) directives. It tells NASM the default size to use for subsequent and directives. The directive takes one required argument which is one of , or .\n\nThis form causes NASM to use stack-based parameter addressing relative to and it assumes that a near form of call was used to get to this label (i.e. that is on the stack).\n\nThis form uses to do stack-based parameter addressing and assumes that a far form of call was used to get to this address (i.e. that and are on the stack).\n\nThis form also uses to address stack parameters, but it is different from because it also assumes that the old value of bp is pushed onto the stack (i.e. it expects an instruction). In other words, it expects that , and are on the top of the stack, underneath any local space which may have been allocated by . This form is probably most useful when used in combination with the directive (see section 4.9.3).\n\nThe directive is used to simplify the use of local temporary stack variables allocated in a stack frame. Automatic local variables in C are an example of this kind of variable. The directive is most useful when used with the (see section 4.9.2 and is also compatible with the directive (see section 4.9.1). It allows simplified reference to variables on the stack which have been allocated typically by using the instruction (see section B.4.65 for a description of that instruction). An example of its use is the following:\n\nThe variable is used internally by the directive and must be defined within the current context before the directive may be used. Failure to do so will result in one expression syntax error for each variable declared. It then may be used in the construction of an appropriately sized ENTER instruction as shown in the example.\n\nNASM also has preprocessor directives which allow access to information from external sources. Currently they include:\n\nThe following preprocessor directive is supported to allow NASM to correctly handle output of the cpp C language preprocessor.\n• enables NAsM to correctly handle the output of the cpp C language preprocessor (see section 4.10.1).\n• enables NASM to read in the value of an environment variable, which can then be used in your program (see section 4.10.2).\n\nThe directive is used to notify NASM that the input line corresponds to a specific line number in another file. Typically this other file would be an original source file, with the current NASM input being the output of a pre-processor. The directive allows NASM to output messages which indicate the line number of the original source file, instead of the file that is being read by NASM.\n\nThis preprocessor directive is not generally of use to programmers, by may be of interest to preprocessor authors. The usage of the preprocessor directive is as follows:\n\nIn this directive, indentifies the line of the original source file which this line corresponds to. is an optional parameter which specifies a line increment value; each line of the input file read in is considered to correspond to lines of the original source file. Finally, is an optional parameter which specifies the file name of the original source file.\n\nAfter reading a preprocessor directive, NASM will report all file name and line numbers relative to the values specified therein.\n\nThe directive makes it possible to read the value of an environment variable at assembly time. This could, for example, be used to store the contents of an environment variable into a string, which could be used at some other point in your code.\n\nFor example, suppose that you have an environment variable , and you want the contents of to be embedded in your program. You could do that as follows:\n\nAt the time of writing, this will generate an \"unterminated string\" warning at the time of defining \"quote\", and it will add a space before and after the string that is read in. I was unable to find a simple workaround (although a workaround can be created using a multi-line macro), so I believe that you will need to either learn how to create more complex macros, or allow for the extra spaces if you make use of this feature in that way."
    },
    {
        "link": "https://usna.edu/Users/cs/norine/spring24/SI459/resources/X86NasmBook.pdf",
        "document": ""
    },
    {
        "link": "https://userpages.cs.umbc.edu/chang/cs313.f12/nasmdoc/html/nasmdoc0.html",
        "document": "This manual documents NASM, the Netwide Assembler: an assembler targetting the Intel x86 series of processors, with portable source.\n\nChapter 1: Introduction\n\n Section 1.1: What Is NASM?\n\n Section 1.1.1: Why Yet Another Assembler?\n\n Section 1.1.2: License Conditions\n\n Section 1.2: Contact Information\n\n Section 1.3: Installation\n\n Section 1.3.1: Installing NASM under MS-DOS or Windows\n\n Section 1.3.2: Installing NASM under Unix\n\n\n\nChapter 2: Running NASM\n\n Section 2.1: NASM Command-Line Syntax\n\n Section 2.1.1: The Option: Specifying the Output File Name\n\n Section 2.1.2: The Option: Specifying the Output File Format\n\n Section 2.1.3: The Option: Generating a Listing File\n\n Section 2.1.4: The Option: Generate Makefile Dependencies\n\n Section 2.1.5: The Option: Generate Makefile Dependencies\n\n Section 2.1.6: The Option: Set Makefile Dependency File\n\n Section 2.1.7: The Option: Assemble and Generate Dependencies\n\n Section 2.1.8: The Option: Dependency Target Name\n\n Section 2.1.9: The Option: Dependency Target Name (Quoted)\n\n Section 2.1.10: The Option: Emit phony targets\n\n Section 2.1.11: The Option: Selecting a Debug Information Format\n\n Section 2.1.12: The Option: Enabling Debug Information.\n\n Section 2.1.13: The Option: Selecting an Error Reporting Format\n\n Section 2.1.14: The Option: Send Errors to a File\n\n Section 2.1.15: The Option: Send Errors to \n\n Section 2.1.16: The Option: Include File Search Directories\n\n Section 2.1.17: The Option: Pre-Include a File\n\n Section 2.1.18: The Option: Pre-Define a Macro\n\n Section 2.1.19: The Option: Undefine a Macro\n\n Section 2.1.20: The Option: Preprocess Only\n\n Section 2.1.21: The Option: Don't Preprocess At All\n\n Section 2.1.22: The Option: Specifying Multipass Optimization\n\n Section 2.1.23: The Option: Enable TASM Compatibility Mode\n\n Section 2.1.24: The and Options: Enable or Disable Assembly Warnings\n\n Section 2.1.25: The Option: Display Version Info\n\n Section 2.1.26: The Option: Display Available Debug Info Formats\n\n Section 2.1.27: The and Options.\n\n Section 2.1.28: The Environment Variable\n\n Section 2.2: Quick Start for MASM Users\n\n Section 2.2.1: NASM Is Case-Sensitive\n\n Section 2.2.2: NASM Requires Square Brackets For Memory References\n\n Section 2.2.3: NASM Doesn't Store Variable Types\n\n Section 2.2.4: NASM Doesn't \n\n Section 2.2.5: NASM Doesn't Support Memory Models\n\n Section 2.2.6: Floating-Point Differences\n\n Section 2.2.7: Other Differences\n\n\n\nChapter 3: The NASM Language\n\n Section 3.1: Layout of a NASM Source Line\n\n Section 3.2: Pseudo-Instructions\n\n Section 3.2.1: and Friends: Declaring Initialized Data\n\n Section 3.2.2: and Friends: Declaring Uninitialized Data\n\n Section 3.2.3: : Including External Binary Files\n\n Section 3.2.4: : Defining Constants\n\n Section 3.2.5: : Repeating Instructions or Data\n\n Section 3.3: Effective Addresses\n\n Section 3.4: Constants\n\n Section 3.4.1: Numeric Constants\n\n Section 3.4.2: Character Strings\n\n Section 3.4.3: Character Constants\n\n Section 3.4.4: String Constants\n\n Section 3.4.5: Unicode Strings\n\n Section 3.4.6: Floating-Point Constants\n\n Section 3.4.7: Packed BCD Constants\n\n Section 3.5: Expressions\n\n Section 3.5.1: : Bitwise OR Operator\n\n Section 3.5.2: : Bitwise XOR Operator\n\n Section 3.5.3: : Bitwise AND Operator\n\n Section 3.5.4: and : Bit Shift Operators\n\n Section 3.5.5: and : Addition and Subtraction Operators\n\n Section 3.5.6: , , , and : Multiplication and Division\n\n Section 3.5.7: Unary Operators\n\n Section 3.6: and \n\n Section 3.7: : Inhibiting Optimization\n\n Section 3.8: Critical Expressions\n\n Section 3.9: Local Labels\n\n\n\nChapter 4: The NASM Preprocessor\n\n Section 4.1: Single-Line Macros\n\n Section 4.1.1: The Normal Way: \n\n Section 4.1.2: Resolving : \n\n Section 4.1.3: Macro Indirection: \n\n Section 4.1.4: Concatenating Single Line Macro Tokens: \n\n Section 4.1.5: The Macro Name Itself: and \n\n Section 4.1.6: Undefining Single-Line Macros: \n\n Section 4.1.7: Preprocessor Variables: \n\n Section 4.1.8: Defining Strings: \n\n Section 4.1.9: Defining Tokens: \n\n Section 4.2: String Manipulation in Macros\n\n Section 4.2.1: Concatenating Strings: \n\n Section 4.2.2: String Length: \n\n Section 4.2.3: Extracting Substrings: \n\n Section 4.3: Multi-Line Macros: \n\n Section 4.3.1: Overloading Multi-Line Macros\n\n Section 4.3.2: Macro-Local Labels\n\n Section 4.3.3: Greedy Macro Parameters\n\n Section 4.3.4: Macro Parameters Range\n\n Section 4.3.5: Default Macro Parameters\n\n Section 4.3.6: : Macro Parameter Counter\n\n Section 4.3.7: : Label Preceeding Macro\n\n Section 4.3.8: : Rotating Macro Parameters\n\n Section 4.3.9: Concatenating Macro Parameters\n\n Section 4.3.10: Condition Codes as Macro Parameters\n\n Section 4.3.11: Disabling Listing Expansion\n\n Section 4.3.12: Undefining Multi-Line Macros: \n\n Section 4.4: Conditional Assembly\n\n Section 4.4.1: : Testing Single-Line Macro Existence\n\n Section 4.4.2: : Testing Multi-Line Macro Existence\n\n Section 4.4.3: : Testing the Context Stack\n\n Section 4.4.4: : Testing Arbitrary Numeric Expressions\n\n Section 4.4.5: and : Testing Exact Text Identity\n\n Section 4.4.6: , , : Testing Token Types\n\n Section 4.4.7: : Test for a Single Token\n\n Section 4.4.8: : Test for Empty Expansion\n\n Section 4.4.9: : Test If Environment Variable Exists\n\n Section 4.5: Preprocessor Loops: \n\n Section 4.6: Source Files and Dependencies\n\n Section 4.6.1: : Including Other Files\n\n Section 4.6.2: : Search the Include Path\n\n Section 4.6.3: : Add Dependent Files\n\n Section 4.6.4: : Include Standard Macro Package\n\n Section 4.7: The Context Stack\n\n Section 4.7.1: and : Creating and Removing Contexts\n\n Section 4.7.2: Context-Local Labels\n\n Section 4.7.3: Context-Local Single-Line Macros\n\n Section 4.7.4: Context Fall-Through Lookup\n\n Section 4.7.5: : Renaming a Context\n\n Section 4.7.6: Example Use of the Context Stack: Block IFs\n\n Section 4.8: Stack Relative Preprocessor Directives\n\n Section 4.8.1: Directive\n\n Section 4.8.2: Directive\n\n Section 4.8.3: Directive\n\n Section 4.9: Reporting User-Defined Errors: , , \n\n Section 4.10: Other Preprocessor Directives\n\n Section 4.10.1: Directive\n\n Section 4.10.2: : Read an environment variable.\n\n Section 4.11: Comment Blocks: \n\n Section 4.12: Standard Macros\n\n Section 4.12.1: NASM Version Macros\n\n Section 4.12.2: : NASM Version ID\n\n Section 4.12.3: : NASM Version string\n\n Section 4.12.4: and : File Name and Line Number\n\n Section 4.12.5: : Current BITS Mode\n\n Section 4.12.6: : Current Output Format\n\n Section 4.12.7: Assembly Date and Time Macros\n\n Section 4.12.8: package : Package Include Test\n\n Section 4.12.9: : Assembly Pass\n\n Section 4.12.10: and : Declaring Structure Data Types\n\n Section 4.12.11: , and : Declaring Instances of Structures\n\n Section 4.12.12: and : Data Alignment\n\n Section 4.12.13: : Section Alignment\n\n\n\nChapter 6: Assembler Directives\n\n Section 6.1: : Specifying Target Processor Mode\n\n Section 6.1.1: & : Aliases for BITS\n\n Section 6.2: : Change the assembler defaults\n\n Section 6.3: or : Changing and Defining Sections\n\n Section 6.3.1: The Macro\n\n Section 6.4: : Defining Absolute Labels\n\n Section 6.5: : Importing Symbols from Other Modules\n\n Section 6.6: : Exporting Symbols to Other Modules\n\n Section 6.7: : Defining Common Data Areas\n\n Section 6.8: : Defining CPU Dependencies\n\n Section 6.9: : Handling of floating-point constants\n\n\n\nChapter 7: Output Formats\n\n Section 7.1: : Flat-Form Binary Output\n\n Section 7.1.1: : Binary File Program Origin\n\n Section 7.1.2: Extensions to the Directive\n\n Section 7.1.3: Multisection Support for the Format\n\n Section 7.1.4: Map Files\n\n Section 7.2: : Intel Hex Output\n\n Section 7.3: : Motorola S-Records Output\n\n Section 7.4: : Microsoft OMF Object Files\n\n Section 7.4.1: Extensions to the Directive\n\n Section 7.4.2: : Defining Groups of Segments\n\n Section 7.4.3: : Disabling Case Sensitivity in Output\n\n Section 7.4.4: : Importing DLL Symbols\n\n Section 7.4.5: : Exporting DLL Symbols\n\n Section 7.4.6: : Defining the Program Entry Point\n\n Section 7.4.7: Extensions to the Directive\n\n Section 7.4.8: Extensions to the Directive\n\n Section 7.5: : Microsoft Win32 Object Files\n\n Section 7.5.1: Extensions to the Directive\n\n Section 7.5.2: : Safe Structured Exception Handling\n\n Section 7.6: : Microsoft Win64 Object Files\n\n Section 7.6.1: : Writing Position-Independent Code\n\n Section 7.6.2: : Structured Exception Handling\n\n Section 7.7: : Common Object File Format\n\n Section 7.8: and : Mach Object File Format\n\n Section 7.9: , , : Executable and Linkable Format Object Files\n\n Section 7.9.1: ELF specific directive \n\n Section 7.9.2: Extensions to the Directive\n\n Section 7.9.3: Position-Independent Code: Special Symbols and \n\n Section 7.9.4: Thread Local Storage: Special Symbols and \n\n Section 7.9.5: Extensions to the Directive\n\n Section 7.9.6: Extensions to the Directive \n\n Section 7.9.7: 16-bit code and ELF \n\n Section 7.9.8: Debug formats and ELF \n\n Section 7.10: : Linux Object Files\n\n Section 7.11: : NetBSD/FreeBSD/OpenBSD Object Files\n\n Section 7.12: : Minix/Linux Object Files\n\n Section 7.13: : Relocatable Dynamic Object File Format\n\n Section 7.13.1: Requiring a Library: The Directive\n\n Section 7.13.2: Specifying a Module Name: The Directive\n\n Section 7.13.3: Extensions to the Directive\n\n Section 7.13.4: Extensions to the Directive\n\n Section 7.14: : Debugging Format\n\n\n\nChapter 8: Writing 16-bit Code (DOS, Windows 3/3.1)\n\n Section 8.1: Producing Files\n\n Section 8.1.1: Using the Format To Generate Files\n\n Section 8.1.2: Using the Format To Generate Files\n\n Section 8.2: Producing Files\n\n Section 8.2.1: Using the Format To Generate Files\n\n Section 8.2.2: Using the Format To Generate Files\n\n Section 8.3: Producing Files\n\n Section 8.4: Interfacing to 16-bit C Programs\n\n Section 8.4.1: External Symbol Names\n\n Section 8.4.2: Memory Models\n\n Section 8.4.3: Function Definitions and Function Calls\n\n Section 8.4.4: Accessing Data Items\n\n Section 8.4.5: : Helper Macros for the 16-bit C Interface\n\n Section 8.5: Interfacing to Borland Pascal Programs\n\n Section 8.5.1: The Pascal Calling Convention\n\n Section 8.5.2: Borland Pascal Segment Name Restrictions\n\n Section 8.5.3: Using With Pascal Programs\n\n\n\nChapter 9: Writing 32-bit Code (Unix, Win32, DJGPP)\n\n Section 9.1: Interfacing to 32-bit C Programs\n\n Section 9.1.1: External Symbol Names\n\n Section 9.1.2: Function Definitions and Function Calls\n\n Section 9.1.3: Accessing Data Items\n\n Section 9.1.4: : Helper Macros for the 32-bit C Interface\n\n Section 9.2: Writing NetBSD/FreeBSD/OpenBSD and Linux/ELF Shared Libraries\n\n Section 9.2.1: Obtaining the Address of the GOT\n\n Section 9.2.2: Finding Your Local Data Items\n\n Section 9.2.3: Finding External and Common Data Items\n\n Section 9.2.4: Exporting Symbols to the Library User\n\n Section 9.2.5: Calling Procedures Outside the Library\n\n Section 9.2.6: Generating the Library File\n\n\n\nChapter 10: Mixing 16 and 32 Bit Code\n\n Section 10.1: Mixed-Size Jumps\n\n Section 10.2: Addressing Between Different-Size Segments\n\n Section 10.3: Other Mixed-Size Instructions\n\n\n\nChapter 11: Writing 64-bit Code (Unix, Win64)\n\n Section 11.1: Register Names in 64-bit Mode\n\n Section 11.2: Immediates and Displacements in 64-bit Mode\n\n Section 11.3: Interfacing to 64-bit C Programs (Unix)\n\n Section 11.4: Interfacing to 64-bit C Programs (Win64)\n\n\n\nChapter 12: Troubleshooting\n\n Section 12.1: Common Problems\n\n Section 12.1.1: NASM Generates Inefficient Code\n\n Section 12.1.2: My Jumps are Out of Range\n\n Section 12.1.3: Doesn't Work\n\n Section 12.1.4: Doesn't Work\n\n Section 12.2: Bugs\n\n\n\nAppendix A: Ndisasm\n\n Section A.1: Introduction\n\n Section A.2: Getting Started: Installation\n\n Section A.3: Running NDISASM\n\n Section A.3.1: COM Files: Specifying an Origin\n\n Section A.3.2: Code Following Data: Synchronisation\n\n Section A.3.3: Mixed Code and Data: Automatic (Intelligent) Synchronisation \n\n Section A.3.4: Other Options\n\n Section A.4: Bugs and Improvements\n\n\n\nAppendix B: Instruction List\n\n Section B.1: Introduction\n\n Section B.1.1: Special instructions...\n\n Section B.1.2: Conventional instructions\n\n Section B.1.3: Katmai Streaming SIMD instructions (SSE -- a.k.a. KNI, XMM, MMX2)\n\n Section B.1.4: Introduced in Deschutes but necessary for SSE support\n\n Section B.1.5: XSAVE group (AVX and extended state)\n\n Section B.1.6: Generic memory operations\n\n Section B.1.7: New MMX instructions introduced in Katmai\n\n Section B.1.8: AMD Enhanced 3DNow! (Athlon) instructions\n\n Section B.1.9: Willamette SSE2 Cacheability Instructions\n\n Section B.1.10: Willamette MMX instructions (SSE2 SIMD Integer Instructions)\n\n Section B.1.11: Willamette Streaming SIMD instructions (SSE2)\n\n Section B.1.12: Prescott New Instructions (SSE3)\n\n Section B.1.13: VMX Instructions\n\n Section B.1.14: Extended Page Tables VMX instructions\n\n Section B.1.15: Tejas New Instructions (SSSE3)\n\n Section B.1.16: AMD SSE4A\n\n Section B.1.17: New instructions in Barcelona\n\n Section B.1.18: Penryn New Instructions (SSE4.1)\n\n Section B.1.19: Nehalem New Instructions (SSE4.2)\n\n Section B.1.20: Intel SMX\n\n Section B.1.21: Geode (Cyrix) 3DNow! additions\n\n Section B.1.22: Intel new instructions in ???\n\n Section B.1.23: Intel AES instructions\n\n Section B.1.24: Intel AVX AES instructions\n\n Section B.1.25: Intel AVX instructions\n\n Section B.1.26: Intel Carry-Less Multiplication instructions (CLMUL)\n\n Section B.1.27: Intel AVX Carry-Less Multiplication instructions (CLMUL)\n\n Section B.1.28: Intel Fused Multiply-Add instructions (FMA)\n\n Section B.1.29: Intel post-32 nm processor instructions\n\n Section B.1.30: VIA (Centaur) security instructions\n\n Section B.1.31: AMD Lightweight Profiling (LWP) instructions\n\n Section B.1.32: AMD XOP and FMA4 instructions (SSE5)\n\n Section B.1.33: Intel AVX2 instructions\n\n Section B.1.34: Transactional Synchronization Extensions (TSX)\n\n Section B.1.35: Intel BMI1 and BMI2 instructions\n\n Section B.1.36: Systematic names for the hinting nop instructions\n\n\n\nAppendix C: NASM Version History\n\n Section C.1: NASM 2 Series\n\n Section C.1.1: Version 2.10.04\n\n Section C.1.2: Version 2.10.03\n\n Section C.1.3: Version 2.10.02\n\n Section C.1.4: Version 2.10.01\n\n Section C.1.5: Version 2.10\n\n Section C.1.6: Version 2.09.10\n\n Section C.1.7: Version 2.09.09\n\n Section C.1.8: Version 2.09.08\n\n Section C.1.9: Version 2.09.07\n\n Section C.1.10: Version 2.09.06\n\n Section C.1.11: Version 2.09.05\n\n Section C.1.12: Version 2.09.04\n\n Section C.1.13: Version 2.09.03\n\n Section C.1.14: Version 2.09.02\n\n Section C.1.15: Version 2.09.01\n\n Section C.1.16: Version 2.09\n\n Section C.1.17: Version 2.08.02\n\n Section C.1.18: Version 2.08.01\n\n Section C.1.19: Version 2.08\n\n Section C.1.20: Version 2.07\n\n Section C.1.21: Version 2.06\n\n Section C.1.22: Version 2.05.01\n\n Section C.1.23: Version 2.05\n\n Section C.1.24: Version 2.04\n\n Section C.1.25: Version 2.03.01\n\n Section C.1.26: Version 2.03\n\n Section C.1.27: Version 2.02\n\n Section C.1.28: Version 2.01\n\n Section C.1.29: Version 2.00\n\n Section C.2: NASM 0.98 Series\n\n Section C.2.1: Version 0.98.39\n\n Section C.2.2: Version 0.98.38\n\n Section C.2.3: Version 0.98.37\n\n Section C.2.4: Version 0.98.36\n\n Section C.2.5: Version 0.98.35\n\n Section C.2.6: Version 0.98.34\n\n Section C.2.7: Version 0.98.33\n\n Section C.2.8: Version 0.98.32\n\n Section C.2.9: Version 0.98.31\n\n Section C.2.10: Version 0.98.30\n\n Section C.2.11: Version 0.98.28\n\n Section C.2.12: Version 0.98.26\n\n Section C.2.13: Version 0.98.25alt\n\n Section C.2.14: Version 0.98.25\n\n Section C.2.15: Version 0.98.24p1\n\n Section C.2.16: Version 0.98.24\n\n Section C.2.17: Version 0.98.23\n\n Section C.2.18: Version 0.98.22\n\n Section C.2.19: Version 0.98.21\n\n Section C.2.20: Version 0.98.20\n\n Section C.2.21: Version 0.98.19\n\n Section C.2.22: Version 0.98.18\n\n Section C.2.23: Version 0.98.17\n\n Section C.2.24: Version 0.98.16\n\n Section C.2.25: Version 0.98.15\n\n Section C.2.26: Version 0.98.14\n\n Section C.2.27: Version 0.98.13\n\n Section C.2.28: Version 0.98.12\n\n Section C.2.29: Version 0.98.11\n\n Section C.2.30: Version 0.98.10\n\n Section C.2.31: Version 0.98.09\n\n Section C.2.32: Version 0.98.08\n\n Section C.2.33: Version 0.98.09b with John Coffman patches released 28-Oct-2001\n\n Section C.2.34: Version 0.98.07 released 01/28/01\n\n Section C.2.35: Version 0.98.06f released 01/18/01\n\n Section C.2.36: Version 0.98.06e released 01/09/01\n\n Section C.2.37: Version 0.98p1\n\n Section C.2.38: Version 0.98bf (bug-fixed)\n\n Section C.2.39: Version 0.98.03 with John Coffman's changes released 27-Jul-2000\n\n Section C.2.40: Version 0.98.03\n\n Section C.2.41: Version 0.98\n\n Section C.2.42: Version 0.98p9\n\n Section C.2.43: Version 0.98p8\n\n Section C.2.44: Version 0.98p7\n\n Section C.2.45: Version 0.98p6\n\n Section C.2.46: Version 0.98p3.7\n\n Section C.2.47: Version 0.98p3.6\n\n Section C.2.48: Version 0.98p3.5\n\n Section C.2.49: Version 0.98p3.4\n\n Section C.2.50: Version 0.98p3.3\n\n Section C.2.51: Version 0.98p3.2\n\n Section C.2.52: Version 0.98p3-hpa\n\n Section C.2.53: Version 0.98 pre-release 3\n\n Section C.2.54: Version 0.98 pre-release 2\n\n Section C.2.55: Version 0.98 pre-release 1\n\n Section C.3: NASM 0.9 Series\n\n Section C.3.1: Version 0.97 released December 1997\n\n Section C.3.2: Version 0.96 released November 1997\n\n Section C.3.3: Version 0.95 released July 1997\n\n Section C.3.4: Version 0.94 released April 1997\n\n Section C.3.5: Version 0.93 released January 1997\n\n Section C.3.6: Version 0.92 released January 1997\n\n Section C.3.7: Version 0.91 released November 1996\n\n Section C.3.8: Version 0.90 released October 1996"
    },
    {
        "link": "https://stackoverflow.com/questions/4364692/finding-substring-in-assembly",
        "document": "I'm wondering if there is a more efficient method to finding a substring in assembly then what I am currently planning to do.\n\nI know the string instruction \"scansb/scasw/scads\" can compare a value in EAX to a value addressed by EDI. However, as far as I understand, I can only search for one character at a time using this methodology.\n\nSo, if I want to find the location of \"help\" in string \"pleasehelpme\", I could use scansb to find the offset of the h, then jump to another function where I compare the remainder. If the remainder isn't correct, I jump back to scansb and try searching again, this time after the previous offset mark.\n\nHowever, I would hate to do this and then discover there is a more efficient method. Any advice? Thanks in advance"
    },
    {
        "link": "https://stackoverflow.com/questions/35631422/finding-substring-in-string-without-using-library-function",
        "document": "Below is the code template and under /* write your code here */ is my own code. The template should be correct but there is sth wrong with my code.\n\nMy algorithm is to iterate through str until finding the null character. Then compare each character, if they are the same then iterate through both str and sub, otherwise set continue to iterate through str and reset to the first character of substr."
    },
    {
        "link": "https://forum.nasm.us/index.php?topic=2237.0",
        "document": "I've been doing a project for a while in NASM \n\n\n\nThe specific file where all this goes on is \n\n\n\n %macro sub_string 2\n\n ;%1 = param to find\n\n ;%2 = param to search\n\n %strlen %%l1 %1\n\n %strlen %%l2 %2\n\n %assign _pos 0\n\n %if %%l1 <= %%l2\n\n %assign _pos %%l2 + 1 - %%l1\n\n %rep _pos\n\n %substr %%ss2 %2 _pos, %%l1\n\n %ifidn %%ss2, %1\n\n %exitrep\n\n %else\n\n %assign _pos _pos - 1\n\n %endif\n\n %endrep\n\n %endif\n\n %endmacro\n\n\n\nI use it to return the position of a substring within another string, or 0 if not found.\n\n\n\nIs this the best I can do ? Speed wise ? Is there a better way, maybe request that some similar function be added to NASM perhaps ?\n\n\n\nI also find myself doing a lot of list searches constructed from single line macros, so tending to build a list with a prefix and using an %assign as the list element. So for instance pushing a token in the token parser I do.\n\n\n\n %macro push_token 2\n\n %deftok %%t %1\n\n %xdefine _token_%[_token_sp] %%t\n\n %assign _token_type_%[_token_sp] %2\n\n %assign _token_sp _token_sp + 1\n\n %endmacro\n\n\n\n_token_sp is the last value etc and to enumerate through, something like this.\n\n\n\n %macro print_token_list 0\n\n %assign %%n 0\n\n %rep _token_sp\n\n %warning token %%n: n: _token_%[%%n] t:_token_type_%[%%n]\n\n %assign %%n %%n + 1\n\n %endrep\n\n %endmacro\n\n\n\nAgain, am I missing a trick here ? Is there a way to express a list in a better faster way ?\n\n\n\nMay I just say I think NASM is great Best assembler I've ever used, first one I've written a compiler in the macro preprocessor with anyways.\n\n\n\nRegards to all\n\n\n\nChris\n\n\n\n------\n\nChris Hinsley Hi folks, new member here, but not new to assembler coding.I've been doing a project for a while in NASM https://github.com/vygr/Asm-Kernel , and inside the complied C/C++ like language, created wth macros, for app level coding I'm thrashing a substring search and a few related macros while doing the token parsing and register allocation phases.The specific file where all this goes on is https://github.com/vygr/Asm-Kernel/blob/master/inc/code.inc , and the function that get's thrashed a lot is this:%macro sub_string 2;%1 = param to find;%2 = param to search%strlen %%l1 %1%strlen %%l2 %2%assign _pos 0%if %%l1 <= %%l2%assign _pos %%l2 + 1 - %%l1%rep _pos%substr %%ss2 %2 _pos, %%l1%ifidn %%ss2, %1%exitrep%else%assign _pos _pos - 1%endif%endrep%endif%endmacroI use it to return the position of a substring within another string, or 0 if not found.Is this the best I can do ? Speed wise ? Is there a better way, maybe request that some similar function be added to NASM perhaps ?I also find myself doing a lot of list searches constructed from single line macros, so tending to build a list with a prefix and using an %assign as the list element. So for instance pushing a token in the token parser I do.%macro push_token 2%deftok %%t %1%xdefine _token_%[_token_sp] %%t%assign _token_type_%[_token_sp] %2%assign _token_sp _token_sp + 1%endmacro_token_sp is the last value etc and to enumerate through, something like this.%macro print_token_list 0%assign %%n 0%rep _token_sp%warning token %%n: n: _token_%[%%n] t:_token_type_%[%%n]%assign %%n %%n + 1%endrep%endmacroAgain, am I missing a trick here ? Is there a way to express a list in a better faster way ?May I just say I think NASM is greatBest assembler I've ever used, first one I've written a compiler in the macro preprocessor with anyways.Regards to allChris------Chris Hinsley\n\nIn order to give a little context, and for those that don't want to click on my project link and have a look. Here is an example of the Network load monitor app, written in the c++'ish compiled script.\n\n\n\n%include 'inc/func.inc'\n\n%include 'inc/mail.inc'\n\n%include 'inc/gui.inc'\n\n%include 'class/class_window.inc'\n\n%include 'class/class_flow.inc'\n\n%include 'class/class_button.inc'\n\n%include 'class/class_progress.inc'\n\n%include 'class/class_string.inc'\n\n%include 'tests/gui/gui1/app.inc'\n\n\n\n;;;;;;;;;;;\n\n; test code\n\n;;;;;;;;;;;\n\n\n\n fn_function tests/gui/gui1/app\n\n\n\n ptr window\n\n ptr window_panel\n\n ptr panel\n\n uint cpu_total\n\n uint cpu_count\n\n pptr task_progress\n\n\n\n ptr msg\n\n ulong select1\n\n ulong select2\n\n ulong mailbox\n\n pulong task_mailboxes\n\n struct task_mailbox, ml_mailbox\n\n\n\n ptr string\n\n ptr progress\n\n int width\n\n int height\n\n ulong owner\n\n\n\n ;init app vars\n\n push_scope\n\n\n\n ;create my window\n\n static_call window, create, {}, {window}\n\n static_call window, get_panel, {window}, {window_panel}\n\n static_call string, create_from_cstr, {\"Network Task Monitor\"}, {string}\n\n static_call window, set_title, {window, string}\n\n static_call string, create_from_cstr, {\"Status Text\"}, {string}\n\n static_call window, set_status, {window, string}\n\n\n\n ;add my panel\n\n static_call flow, create, {}, {panel}\n\n static_call flow, set_flow_flags, {panel, flow_flag_down | flow_flag_fillw}\n\n static_call flow, add_back, {panel, window_panel}\n\n\n\n ;allocate array for progress bars\n\n static_call sys_cpu, total, {}, {cpu_total}\n\n static_call sys_mem, alloc, {cpu_total * long_size}, {task_progress, _}\n\n\n\n ;add num cpus progress bars to my app panel\n\n assign {0}, {cpu_count}\n\n loop_start\n\n static_call progress, create, {}, {progress}\n\n static_call progress, set_max, {progress, 48}\n\n static_call progress, set_color, {progress, 0xff00ff00}\n\n static_call progress, add_back, {progress, panel}\n\n assign {progress}, {task_progress[cpu_count * long_size]}\n\n assign {cpu_count + 1}, {cpu_count}\n\n loop_until {cpu_count == cpu_total}\n\n\n\n ;set to pref size\n\n method_call window, pref_size, {window}, {width, height}\n\n static_call window, change, {window, 32, 32, width, height}\n\n\n\n ;set owner\n\n static_call sys_task, tcb, {}, {owner}\n\n static_call window, set_owner, {window, owner}\n\n\n\n ;add to screen and dirty\n\n static_call gui_gui, add, {window}\n\n static_call window, dirty_all, {window}\n\n\n\n ;allocate array for child mailbox ID's\n\n static_call sys_mem, alloc, {cpu_total * mailbox_id_size}, {task_mailboxes, _}\n\n\n\n ;open global farm\n\n static_call sys_task, open_global, {\"tests/gui/gui1/child\", task_mailboxes, cpu_total}\n\n\n\n ;init task mailbox\n\n static_call sys_mail, mailbox, {&task_mailbox}\n\n\n\n ;set up mailbox select array\n\n static_call sys_task, mailbox, {}, {select1, _}\n\n assign {&task_mailbox}, {select2}\n\n\n\n ;app event loop\n\n loop_start\n\n ;new round of samples ?\n\n if {cpu_count == cpu_total}\n\n ;send out sample commands\n\n loop_start\n\n assign {cpu_count - 1}, {cpu_count}\n\n static_call sys_mail, alloc, {}, {msg}\n\n assign {1}, {msg->sample_mail_command}\n\n assign {sample_mail_size}, {msg->ml_msg_length}\n\n assign {task_progress[cpu_count * long_size]}, {msg->sample_mail_progress}\n\n assign {task_mailboxes[cpu_count * mailbox_id_size].mb_mbox}, {msg->ml_msg_dest.mb_mbox}\n\n assign {task_mailboxes[cpu_count * mailbox_id_size].mb_cpu}, {msg->ml_msg_dest.mb_cpu}\n\n assign {select2}, {msg->sample_mail_reply_id.mb_mbox}\n\n static_call sys_cpu, id, {}, {msg->sample_mail_reply_id.mb_cpu}\n\n static_call sys_mail, send, {msg}\n\n loop_until {!cpu_count}\n\n endif\n\n\n\n ;select on 2 mailboxes\n\n static_call sys_mail, select, {&select1, 2}, {mailbox}\n\n static_call sys_mail, read, {mailbox}, {msg}\n\n\n\n ;which mailbox had mail ?\n\n if {mailbox == select1}\n\n ;dispatch event to view\n\n method_call view, event, {msg->ev_data_view, msg}\n\n else\n\n ;update progress bar\n\n static_call progress, set_val, {msg->sample_mail_progress, msg->sample_mail_task_count}\n\n static_call progress, dirty, {msg->sample_mail_progress}\n\n\n\n ;count up replies\n\n assign {cpu_count + 1}, {cpu_count}\n\n endif\n\n\n\n ;free event message\n\n static_call sys_mem, free, {msg}\n\n\n\n ;be friendly\n\n static_call sys_task, yield\n\n loop_end\n\n\n\n ;wait for outstanding replys\n\n loop_while {cpu_count != cpu_total}\n\n static_call sys_mail, read, {select2}, {msg}\n\n static_call sys_mem, free, {msg}\n\n assign {cpu_count + 1}, {cpu_count}\n\n loop_end\n\n\n\n ;send out exit commands\n\n loop_start\n\n assign {cpu_count - 1}, {cpu_count}\n\n static_call sys_mail, alloc, {}, {msg}\n\n assign {0}, {msg->sample_mail_command}\n\n assign {sample_mail_size}, {msg->ml_msg_length}\n\n assign {task_mailboxes[cpu_count * mailbox_id_size].mb_mbox}, {msg->ml_msg_dest.mb_mbox}\n\n assign {task_mailboxes[cpu_count * mailbox_id_size].mb_cpu}, {msg->ml_msg_dest.mb_cpu}\n\n static_call sys_mail, send, {msg}\n\n loop_until {!cpu_count}\n\n\n\n ;free arrays\n\n static_call sys_mem, free, {task_mailboxes}\n\n static_call sys_mem, free, {task_progress}\n\n\n\n ;deref window\n\n static_call window, deref, {window}\n\n\n\n pop_scope\n\n vp_ret\n\n\n\n fn_function_end\n\n\n\nAnd this is the child process source that gets launched by that with the open_global call.\n\n\n\n%include 'inc/func.inc'\n\n%include 'tests/gui/gui1/app.inc'\n\n\n\n;;;;;;;;;;;\n\n; test code\n\n;;;;;;;;;;;\n\n\n\n fn_function tests/gui/gui1/child\n\n ;monitor task\n\n\n\n ptr msg\n\n\n\n push_scope\n\n loop_start\n\n ;read mail command\n\n static_call sys_mail, mymail, {}, {msg}\n\n breakif {!msg->sample_mail_command}\n\n\n\n ;sample command\n\n static_call sys_task, count, {}, {msg->sample_mail_task_count}\n\n assign {msg->sample_mail_reply_id.mb_mbox}, {msg->ml_msg_dest.mb_mbox}\n\n assign {msg->sample_mail_reply_id.mb_cpu}, {msg->ml_msg_dest.mb_cpu}\n\n static_call sys_mail, send, {msg}\n\n\n\n ;be friendly\n\n static_call sys_task, yield\n\n loop_end\n\n static_call sys_mem, free, {msg}\n\n\n\n pop_scope\n\n vp_ret\n\n\n\n fn_function_end\n\n\n\nRegards\n\n\n\nChris\n\n« Reply #8 on: May 26, 2016, 08:14:56 AM » \n\n\n\nvygr,\n\nWelcome to the forum! Frank mentioned something called NASMX, it's a general purpose macro package providing high level constructs and quite a bit of abstraction for the purpose of cross platform programming in NASM. NASMX does include a bunch of macros like nx_strstr, \n\n\n\nWarning: Going off-topic here \n\n\n\nHowever, there is something else that NASMX has that your code \"insinuates\" that you may want/need... A simple, but EXTREMELY POWERFUL type system. The type system you've implemented look a lot like what I did on the original version of NASMX which does indeed provides a good system for user-defined types, NASMX goes quite a bit beyond that (it even supports union types).\n\n\n\nWith NASMX, we take the approach of collecting as much information as possible as early as we can, and generate code as late as possible. The method your using is much more direct, which is good for it's ability to reduce compile-time overhead. However, you'll have a hard time trying to implement advanced types like union with the direct method. In fact, NASMX would probably still be using the more direct method if we weren't so determined to support union's. The compile-time overhead will be a major factor in whether or not you might want to implement a NASMX like type system, you're code is already doing much more work than NASMX does by providing code generation for an evaluator, it might not be worth it to create all the extra symbols (using up more memory at compile-time).\n\n\n\nTo give you a quick run-through of the NASMX type system.. At the top of \n\n\n\n Hey Frank, sorry that I'm not as active as I probably should be, my Internet connectivity is questionable at best.vygr,Welcome to the forum! Frank mentioned something called NASMX, it's a general purpose macro package providing high level constructs and quite a bit of abstraction for the purpose of cross platform programming in NASM. NASMX does include a bunch of macros like nx_strtok and some general HL macros ... but the ones you've got are good enough on their own and I doubt you would gain much more insight from NASMX.Going off-topic hereHowever, there is something else that NASMX has that your code \"insinuates\" that you may want/need... A simple, but EXTREMELY POWERFUL type system. The type system you've implemented look a lot like what I did on the original version of NASMX which does indeed provides a good system for user-defined types, NASMX goes quite a bit beyond that (it even supports union types).With NASMX, we take the approach of collecting as much information as possible as early as we can, and generate code as late as possible. The method your using is much more direct, which is good for it's ability to reduce compile-time overhead. However, you'll have a hard time trying to implement advanced types like union with the direct method. In fact, NASMX would probably still be using the more direct method if we weren't so determined to support union's. The compile-time overhead will be a major factor in whether or not you might want to implement a NASMX like type system, you're code is already doing much more work than NASMX does by providing code generation for an evaluator, it might not be worth it to create all the extra symbols (using up more memory at compile-time).To give you a quick run-through of the NASMX type system.. At the top of ]NASMX.INC we define a bunch of symbols that for the built-in types and registers. Later some type specific classifications are defined for the built-ins and a few symbols are created for identification of user-types. Afterwards, we create some aliases that C users tend to like better. All these definitions have a purpose. They make our built-in types act the same way that our user-types will eventually act. This means we can create these macros and use them on both user-defined types and built-in types. The rest of the type system starts here and runs on until the nx_isalnum macro.\n\n« Reply #9 on: May 26, 2016, 11:15:55 AM » \n\n\n\nDo you think that a request, or a patch to add a %search built in would be worthwhile to the powers that be in NASM dev ? It would sure be a lot faster.\n\n\n\nI'll take a look over the type system code, I currently have a simple, but as you say effective, type system for the evaluator, currently it just uses a string to indicate the type and address needs like pointer to pointer to... 'ppppI' for example. In the expression compiler as things are dereferenced the first char gets stripped off and the virtual register slot re-tagged with the remains. I hold all the generated instructions in an output buffer and run a simple optimize pass to convert references into copies and migrate constants, again, simple stuff but leaves the app level script code looking less embarrassing than it would otherwise \n\n\n\nOne thing I was going to do is to eventually emit an ARM and VP byte code form of my dynamic bound function format using NASM as purely a macro processor. Any thoughts on that ? Is there ever going to be ARM instruction support in NASM ?\n\n\n\nBest regards\n\n\n\nChris Hi Bryant, thanks for the reply. Was beginning to hear tumble weed at my endDo you think that a request, or a patch to add a %search built in would be worthwhile to the powers that be in NASM dev ? It would sure be a lot faster.I'll take a look over the type system code, I currently have a simple, but as you say effective, type system for the evaluator, currently it just uses a string to indicate the type and address needs like pointer to pointer to... 'ppppI' for example. In the expression compiler as things are dereferenced the first char gets stripped off and the virtual register slot re-tagged with the remains. I hold all the generated instructions in an output buffer and run a simple optimize pass to convert references into copies and migrate constants, again, simple stuff but leaves the app level script code looking less embarrassing than it would otherwiseOne thing I was going to do is to eventually emit an ARM and VP byte code form of my dynamic bound function format using NASM as purely a macro processor. Any thoughts on that ? Is there ever going to be ARM instruction support in NASM ?Best regardsChris\n\n« Reply #11 on: May 27, 2016, 02:49:25 AM » Quote from: vygr on May 26, 2016, 11:15:55 AM Hi Bryant, thanks for the reply. Was beginning to hear tumble weed at my end \n\nI live in a rural area, Internet access is a luxury not always available. I try to connect as often as I can. \n\n\n\n Quote from: vygr on May 26, 2016, 11:15:55 AM Do you think that a request, or a patch to add a %search built in would be worthwhile to the powers that be in NASM dev ? It would sure be a lot faster. \n\nI think some side effects to %substr itself would be a nice addition. I've not really dug into NASM source code in a long time, but maybe NASM could be updated to return the index of the last substing found in a built-in symbol. I think a feature like that would be kinda nice.\n\n\n\n Quote from: vygr on May 26, 2016, 11:15:55 AM I'll take a look over the type system code, I currently have a simple, but as you say effective, type system for the evaluator, currently it just uses a string to indicate the type and address needs like pointer to pointer to... 'ppppI' for example. In the expression compiler as things are dereferenced the first char gets stripped off and the virtual register slot re-tagged with the remains. I hold all the generated instructions in an output buffer and run a simple optimize pass to convert references into copies and migrate constants, again, simple stuff but leaves the app level script code looking less embarrassing than it would otherwise \n\nYeah, that's one of the downsides to using macros that generate symbols, every time they are used they increase the overall compile time overhead.\n\n\n\n Quote from: vygr on May 26, 2016, 11:15:55 AM One thing I was going to do is to eventually emit an ARM and VP byte code form of my dynamic bound function format using NASM as purely a macro processor. Any thoughts on that ? Is there ever going to be ARM instruction support in NASM ? \n\nARM support is something that a lot of people have asked for but never has seen the light of day. That said, I remember (a long time ago) there was something called NARM (a NASM port for ARM) though it was of a much older version of NASM and the developer's abandoned it long ago. I live in a rural area, Internet access is a luxury not always available. I try to connect as often as I can.I think some side effects to %substr itself would be a nice addition. I've not really dug into NASM source code in a long time, but maybe NASM could be updated to return the index of the last substing found in a built-in symbol. I think a feature like that would be kinda nice.Yeah, that's one of the downsides to using macros that generate symbols, every time they are used they increase the overall compile time overhead.ARM support is something that a lot of people have asked for but never has seen the light of day. That said, I remember (a long time ago) there was something called NARM (a NASM port for ARM) though it was of a much older version of NASM and the developer's abandoned it long ago.\n\n\n\n\n\nI will look into a patch for NASM to add %search later once I hit my patience limit with my compile times. I'm fairly sure that the feature would be accepted, it harms nothing and can benefit NASM developers.\n\n\n\nEven without direct support for ARM, I'm sure that you can get NASM to emit ARM code just building up the opcodes ones self with 'db''s. A pain to do the jump offsets yourself but not impossible. There are assemblers of old that did just that, they only ever allowed you to produce 'db's as the output, but they had enough that you could produce code for multiple targets with the correct macros packs.\n\n\n\nHeck if all else fails, I'll have to add writing an assembler to my list \n\n\n\nRegards\n\n\n\nChris Even if %substr did emit some side effects it still wouldn't do this job. %substr just lets you create a sub string of an existing string, dons't do anything that you could use to search for the presence of a string within a string. You can construct a function to do that using %substr but it ends up slow because you have to create a new symbol and copy the contents for every positional test you perform, slow slow slow.I will look into a patch for NASM to add %search later once I hit my patience limit with my compile times. I'm fairly sure that the feature would be accepted, it harms nothing and can benefit NASM developers.Even without direct support for ARM, I'm sure that you can get NASM to emit ARM code just building up the opcodes ones self with 'db''s. A pain to do the jump offsets yourself but not impossible. There are assemblers of old that did just that, they only ever allowed you to produce 'db's as the output, but they had enough that you could produce code for multiple targets with the correct macros packs.Heck if all else fails, I'll have to add writing an assembler to my listRegardsChris"
    },
    {
        "link": "https://geeksforgeeks.org/string-manipulation-instructions-8086-microprocessor",
        "document": "In this Article, We will be going through the String Manipulation Instruction, We will start our Article with the Introduction of the String Manipulation Instruction in the 8086, Then We will go through the different String Manipulation Instructions with some Examples, and At last, we will conclude our Article with Some FAQs.\n\nWhat are String Manipulation Instructions in 8086 microprocessors?\n\nString Manipulation Instructions in the 8086 microprocessor architecture are the set of Instructions that are used to manipulate strings in memory. The String manipulation Instructions offer different functionality such as copying, Searching, and Modifying Strings of data. Key String manipulation instruction in 8086 instruction sets includes different instructions such as MOVSB, CMPSB, SCASB, LODSB, STOSB, and other instructions which are going to be discussed further.\n\nThe string is a series of data bytes or words available in memory at consecutive locations. It is either referred as byte string or a word string. Their memory is always allocated in a sequential order. Instructions used to manipulate strings are called string manipulation instructions. Following is the table showing the list of string manipulation instructions:\n\nrepeat the given instruction while CX = 0 repeat the given instruction while ZF = 1 repeat the given instruction while CX != 0 repeat the given instruction while ZF = 0 moves contents of byte given by DS:SI into ES:DI moves contents of word given by DS:SI into ES:DI moves contents of double word given by DS:SI into ES:DI moves the byte at address DS:SI into AL; SI is incr/decr by 1 moves the word at address DS: SI into AX; SI is incr/decr by 2 moves the double word at address DS:SI into EAX; SI is incr/decr by 4 moves contents of AL to byte address given by ES:DI; DI is incr/dec by 1 moves the contents of AX to the word address given by ES:DI; DI is incr/decr by 2 moves contents of EAX to the DOUBLE WORD address given by ES:DI; DI is incr/decr by 4 compares byte at ES:DI with AL and sets flags according to result compares word at ES:DI with AX and sets flags compares double word at ES:DI with EAX and sets flags compares byte at ES:DI with byte at DS:SI and sets flags compares word at ES:DI with word at DS:SI and sets flags compares double word at ES:DI with double word at DS:SI and sets flags\n\nGiven below are some Examples of the String manipulation instructions in 8086 microprocessor\n\nExample of REP with MOVSB Instruction\n\nExample of REPE With CMPSB Instruction\n\nMOV AX, SEG_STRING1 Move the segment address of STRING1 to AX \n\n\n\n MOV AX, SEG_STRING2 Move the segment address of STRING2 to AX \n\n\n\n MOV SI, OFFSET_STRING1 Move the offset of STRING1 to SI \n\n MOV DI, OFFSET_STRING2 Move the offset of STRING2 to DI \n\n MOV CX, 020H Move the length of the strings to CX \n\n \n\n REPE CMPSB Compare the 020H bytes of STRING1 and STRING2,While they are Equal, \n\n If mismatch is found modify the flags and proceed with further Execution \n\n\n\n NOTE: If Both Strings are Equal,CX becomes ZERO,the ZF is set otherwise ZF is reset \n\n\n\nExample of REPNE With SCASW Instruction\n\nMOV CX, 10 Set CX to the number of bytes to be read \n\n MOV SI, OFFSET_STR Set SI to point to the start of the string \n\n MOV DI, OFFSET_BUF Set DI to point to the destination buffer \n\n \n\n\n\n\n\n LODSB Load a byte from the memory location pointed to by SI into AL, and increment SI \n\n STOSB Store the byte in AL at the memory location pointed to by DI, and increment DI \n\n LOOP READ_LOOP Decrement CX and loop back if CX is not zero \n\n \n\n\n\n\n\n\n\nIn this Article, We have gone through the String manipulation in the 8086 microprocessor which provides efficiently handling operations on strings of data stored in the memory. These instructions enable us to copying, searching and comparing Function in the memory. Also we have gone through the different examples of the Instructions which provides us the clear understanding of the String manipulation instructions set.\n\nHow are string manipulation instructions used in assembly language programming?\n\nWhat are some examples of string manipulation instructions in the 8086 microprocessor?"
    },
    {
        "link": "https://reddit.com/r/asm/comments/1ah95zv/how_do_string_variables_work_in_assembly",
        "document": "in case of integer variables , something like int a = 7 would be translated into something like :\n\nin the same way , what does something like string text = \"hello\" translate to ?"
    }
]