[
    {
        "link": "https://github.com/FreyrSCADA/DNP3",
        "document": "Distributed Network Protocol 3 ( DNP3 ) is a set of communications protocols used between components in process automation systems. Its main use is in utilities such as electric and water companies.\n\nUsage in other industries is not common. It was developed for communications between various types of data acquisition and control equipment. It plays a crucial role in SCADA systems, where it is used by SCADA Master Stations (a.k.a. Control Centers), Remote Terminal Units (RTUs), and Intelligent Electronic Devices (IEDs). It is primarily used for communications between a master station and RTUs or IEDs.\n\nDNP3 Protocol - (Outstation) Server Simulator, Client (Master) Simulator, Windows and Linux (ARM) - C, C++, C# .NET Programming\n• DNP3 Source Code Windows C C++ C# .net Linux Arm POSIX C C++\n• DNP3 Windows C C++ C# .NET Programming\n\nIn the Development Bundle, We included DNP3 Outstation Server Simulator, Master Client Simulator, Windows ( C, C++, C# Programming ), Linux (POSIX C , C++) SDK, Source code available\n\nThe most complete implementation of DNP3 protocol standard including File transfer.\n\nLow memory footprint, easy start on any hardware platform, can operate with or without an operating system, delivered as a source code,\n\nhigh configurability allows to use required features only, royalty-free licensing.\n• Written in ANSI-Standard C Source Code, under a strict corporate coding standard, and supports C++, C#\n• Provides a simple method for systems integrators and OEMs to utilize standard tools to implement their systems\n• For Linux Platform, Protocol Stack written using only POSIX-compliant system calls and libraries.\n• support C, C++, C# languages\n• Our stacks are fully compliant with \"POSIX\" and tested in ubuntu, feroda, Debian, QNX, Linux Embedded OS and Various Cross compiler tool chains.\n• APIs are designed to be very easy to use and flexible\n\nIn this License model, We deliver complete source code of the protocol implementation according to the customer specified operating system(Windows, Linux, QNX...).\n\nCustomer may embed the library into unlimited copies of Multiple end-use products for worldwide manufacturing, branding and distribution. Original equipment manufacturers choose this model. They usually have multiple products in their pipeline.\n\nIn this License model, We deliver Dynamic/ Static compiled library (dll / lib) of the protocol implementation according to the customer specified operating system(Windows, Linux, QNX...).\n\nCustomer may embed the library into unlimited copies of Multiple end-use products for worldwide manufacturing, branding and distribution. Original equipment manufacturers choose this model. They usually have multiple products in their pipeline.\n\nAdd up to 50 server node in the simulator. Every server node will work independently.\n\nThe user can update the monitoring Point information.The following parameters can change Value and quality bits.\n\nAn Annual License allows the customer to use the licensed software for one year, download updates and request technical support. At the end of the year the customer must renew their term license to continue using the software. In this License model, FreyrSCADA deliver Simulator Installer for Windows Operating System. The Customer can use the software company wide. Customer can install the software in many systems. There is no restriction like Hardware key (Dongle) and software key.\n\nA Perpetual License allows the customer to purchase a license to use the software forever. The Perpetual License also comes with an annual renewal fee that enables the customer to update the software to the latest version. In this License model, FreyrSCADA deliver Simulator Installer for Windows Operating System. The Customer can use the software company wide. Customer can install the software in many systems. There is no restriction like Hardware key (Dongle) and software key. For Unlimited year license, after a year, you will have the option to renew the Maintenance Plan to continue receiving technical support and upgrades. The renewal price after a year is 10% of the product list price at the time of renewal (optional). Without renew the AMC also the software works. But for technical support and upgrades, the customer has an option for AMC.\n\nAdd up to 50 Client node in the simulator. Every Client node will work independently.\n\nAn Annual License allows the customer to use the licensed software for one year, download updates and request technical support. At the end of the year the customer must renew their term license to continue using the software. In this License model, FreyrSCADA deliver Simulator Installer for Windows Operating System. The Customer can use the software company wide. Customer can install the software in many systems. There is no restriction like Hardware key (Dongle) and software key.\n\nA Perpetual License allows the customer to purchase a license to use the software forever. The Perpetual License also comes with an annual renewal fee that enables the customer to update the software to the latest version. In this License model, FreyrSCADA deliver Simulator Installer for Windows Operating System. The Customer can use the software company wide. Customer can install the software in many systems. There is no restriction like Hardware key (Dongle) and software key. For Unlimited year license, after a year, you will have the option to renew the Maintenance Plan to continue receiving technical support and upgrades. The renewal price after a year is 10% of the product list price at the time of renewal (optional). Without renew the AMC also the software works. But for technical support and upgrades, the customer has an option for AMC.\n\nDNP3 Demo Win DLL includes simple (Server & Client C programs )example using a Command window and command line inputs.\n\nThe source code will allow you to quickly compile your own examples with the features of your existing development environment to work with our DNP3 DLL.\n\nWe used Visual studio compiler to create the dll, sample test projects.\n\nThis evaluation package allows you to:\n\nStudy the source code of the DNP3 examples provided\n\nCreate your own DNP3 programs and test with leading test tools like (ASE,...)\n\nYou can use the source code of the application examples and modify them according to your needs.\n\nDNP3 Demo Linux Shared Library includes simple (Server & Client C programs )example using a Command window and command line inputs.\n\nThe source code will allow you to quickly compile your own examples with the features of your existing development environment to work with our DNP3 library.\n\nWe used gcc compiler to create the Shared Library, sample test projects.\n\nThis evaluation package allows you to:\n\nStudy the source code of the DNP3 examples provided\n\nCreate your own DNP3 programs and test with leading test tools like (ASE,...)\n\nYou can use the source code of the application examples and modify them according to your needs.\n\nSupports Embedded Linux (ARM, Coldfire, Power PC), Ubuntu Linux(X86, X86-64), Fedora, CentOS, Red Hat...(All Posix Compliant Operating Systems) gcc - Any IDE supports C & C++ Programming\n\nIn the Development Bundle, We included DNP3 Outstation Server Simulator, Master Client Simulator, Windows ( C, C++, C# Programming ), Linux (POSIX C , C++) SDK, Source code available"
    },
    {
        "link": "https://groups.google.com/g/open-dnp3/c/XG87fyn6Bes",
        "document": "Sign in to reply to author You do not have permission to delete messages in this group Either email addresses are anonymous for this group or you need the view member email addresses permission to view the original message If we had socket-to-VTO support in the stack then creating the dnp3tun application wouldn't be very hard, it could connect to the one exposed socket on the local side, wrap the locally received data with some routing structure and then the remote dnp3tun router would unpack and send that data to the correct port. The VTO structure just doesn't have enough data to fully wrap the IP protocol, there is only 16 (32?) bits of addressing using the index, you need atleast 48 bits to encode an IP address:port combination. I responded to your specific questions below: wrote:\n\n Thanks for the explanation! Any help you can give on identifying the original port work would be extremely appreciated. The entire IPv4 packet received from the client socket side (outstation) would be encoded into an HTTP request and then sent over HTTP to the concentrator (master) on the other side. The master would then decode the HTTP request and pass on the IPv4 packet to its final destination. The actual application (VPN tunnel) is decoupled from the two underlying libraries (curl's HTTP implementation and Linux's network sockets implementation.) A similar system (dnp3tun, if you will?) might provided similar benefits, whereby standard IP protocols like SSH and HTTP could be used across a DNP3 network backbone. And Linux applications could use the standard TUN/TAP virtual networking device to quickly and easily add support to existing network daemons for DNP3 through this tunnel/router system. I agree with you that a \"router\" component is needed, but have further questions about what it might look like. In my mind, this \"router\" component is very similar to htun, a Linux application ( http://linux.softpedia.com/get/System/Networking/HTun-14751.shtml ). htun uses two libraries external to itself — curl and sockets — to create an HTTP-based VPN tunnel from the client to the server.The entire IPv4 packet received from the client socket side (outstation) would be encoded into an HTTP request and then sent over HTTP to the concentrator (master) on the other side. The master would then decode the HTTP request and pass on the IPv4 packet to its final destination. The actual application (VPN tunnel) is decoupled from the two underlying libraries (curl's HTTP implementation and Linux's network sockets implementation.) A similar system (dnp3tun, if you will?) might provided similar benefits, whereby standard IP protocols like SSH and HTTP could be used across a DNP3 network backbone. And Linux applications could use the standard TUN/TAP virtual networking device to quickly and easily add support to existing network daemons for DNP3 through this tunnel/router system. A little bit of protocol framing might be required to ensure that fragmented packets are reassembled properly before being forwarded. HTTP provided that implicitly in the htun example above, but we can develop that higher-level control protocol later. Three questions that come to mind out of our discussion at this point:\n• Is the implementation of the socket-to-VTO router component something that is best done outside or inside of the DNP3 library? On Mon, Apr 18, 2011 at 9:13 AM, Chris Vergeswrote: I think inside, that way the stack is self contained and works to tunnel single ports on any device with IP port support (UDP could also work).\n• If outside, then are there any special API hooks in the DNP3 library needed by the router? If not using sockets we would need a different IPC communication method to shunt the data into and out of the stack. Could be done as well as sockets if necessary for performance reasons, though the nature of DNP3 is always going to be a bigger bottleneck than that.\n• Are there any \"standards\" (de facto or de jure) in this area that we should be keeping in mind, such as DNP3 addressing conventions, IP-to-DNP3 address mappings, etc.? You need to keep in mind that DNP is usually deployed in hardened environments with regulatory and technical requirements to minimize access. VTO is not commonly implemented or enabled because of those risks, but when it is enabled, there is a very specific set of ports that are available for VTO. Probably the most common use case was hooking up VTO to a physical serial port for remote management. So the VTO index which we would think of as representing the port doesn't need to have any relation to the IP or serial port we are tunneling to. The mapping between IP and DNP3 indexes is therefore manually done and agreed upon when the device is commissioned. That sounds pretty neat, not something I would have thought to try. It may be the wrong way to attack the issue at first, fundamentally we need some sort of inter-process-communication to get the data and connect/disconnect signals into the DNP3 stack so it can be packaged as VTO and sent down the line. Then we have to use some IPC to get that data back out to appropriate place on the other side of the connection. I think sockets are the simplest and most useful, they are well supported on nearly every platform. The semantics are also very similar, its a bi-direction stream of data that can't instantly report sending failures but if the connection stays up the data will be received in order.\n\nSign in to reply to author You do not have permission to delete messages in this group Either email addresses are anonymous for this group or you need the view member email addresses permission to view the original message \n\n \n\nAnswers below. \n\n > I'm still working my way through the various classes in the DNP3 directory \n\n> so that I know how to implement the VTO feature. Here's what I have so far \n\n> in the way of understanding: (don't worry, it'll be short!) \n\n> \n\n> class APDU \n\n > * This class represents a DNP3 Application Layer message. \n\n> * WriteIndexed() seems to be the proper one to use for sending Group112VarX \n\n> and Group113VarX objects. \n\n \n\nThis is where my memory starts slipping. I just talked to Sam and he \n\nrecalls that the index encoded the \"port\" of the VTO object, and the \n\nvariation encoded the length (0-255). I believe that WriteIndexed() \n\nis the correct function, but you'll have to do some unit testing here \n\nand comparison to the protocol specification. \n\n \n\n> class ObjectBase \n\n> * Get() creates the Group112VarX and Group113VarX objects, used by class \n\n> APDU. \n\n \n\nI'm not sure if you need this function or not. Just use the existing \n\nread/write handler for existing objects as a guide. \n\n > * This class writes a byte stream from the application of arbitrary length \n\n> to an APDU instance. \n\n> * The stream is split into segments of at most 255 characters. The minimum \n\n > size can vary from 0 to aReservedOctetCount, as determined by the available \n\n> space in the APDU instance. (Unclear how to ensure that aReservedOctetCount \n\n> is made available if a VTO transmission is pending.) \n\n \n\n I think that aReservedOctetCount might be better as a Slave/Master \n\nconfiguration parameter (Minimum amount from ANY VTO stream to put \n\ninto each APDU). It will be really hard to do this on a per stream \n\nbasis. \n\n \n\n> * Package each segment into a Group112VarX (if VtoMasterWriter) or \n\n > * This class notifies the implementing application of newly received data. \n\n> * The application should then do whatever it needs with the data, though it \n\n > should do it quickly, as this blocks other DNP3 functions from being \n\n> processed. \n\n> class Master \n\n > * Master::ProcessDataResponse() seems to process a received class APDU \n\n> instance. \n\n> * Various other functions like Master::OnUnsolResponse() seem to trigger \n\n > other paths, unclear if they eventually converge back to \n\n> Master::ProcessDataResponse(). \n\n \n\n I believe that all of those functions return to ProcessDataResponse. \n\nThis is where you'll read the VTO objects out of the APDU and convert \n\nthem to array[byte]. \n\n \n\n> class Slave \n\n> * Slave::Send() and Slave::SendUnsolicited() are used to tell class AppLayer \n\n > * Slave::CreateResponseContext() appears to create a class APDU instance, \n\n > perhaps usable by class VtoSlaveWriter? (Does this mean that Slave->Master \n\n> communications will be VTO-packets-only ‹ this is, the APDU instance will \n\n> only hold VTO objects, no other types?) \n\n \n\n No, the responses from the slave (either polled or unsolicted) will \n\ncontain a mixture of measurement data and VTO objects. The exact \n\nmixture will be a function of: \n\n \n\n1) VTO ReserverOctetCount \n\n2) Events/VTO available \n\n3) Maximum size of an APDU \n\n \n\n> * How does the class Slave instance receive VTO data? \n\n > OK, to be fair, a little longer than I first estimated. :-) \n\n \n\n Masters write VTO objects to the outstation using the FC_WRITE \n\nfunction. You'd have to add a handler here: \n\n \n\nhttps://github.com/gec/dnp3/blob/master/DNP3/Slave.cpp#L301 \n\n \n\n> \n\n> Thanks! \n\n> Chris \n\n> Hi Chris,Answers below.> * This class represents a DNP3 Application Layer message.> * WriteIndexed() seems to be the proper one to use for sending Group112VarX> and Group113VarX objects.This is where my memory starts slipping. I just talked to Sam and herecalls that the index encoded the \"port\" of the VTO object, and thevariation encoded the length (0-255). I believe that WriteIndexed()is the correct function, but you'll have to do some unit testing hereand comparison to the protocol specification.> class ObjectBase> * Get() creates the Group112VarX and Group113VarX objects, used by class> APDU.I'm not sure if you need this function or not. Just use the existingread/write handler for existing objects as a guide.> * This class writes a byte stream from the application of arbitrary length> to an APDU instance.> * The stream is split into segments of at most 255 characters. The minimumI think that aReservedOctetCount might be better as a Slave/Masterconfiguration parameter (Minimum amount from ANY VTO stream to putinto each APDU). It will be really hard to do this on a per streambasis.> * Package each segment into a Group112VarX (if VtoMasterWriter) or> * This class notifies the implementing application of newly received data.> * The application should then do whatever it needs with the data, though it> * Master::ProcessDataResponse() seems to process a received class APDU> instance.> * Various other functions like Master::OnUnsolResponse() seem to triggerI believe that all of those functions return to ProcessDataResponse.This is where you'll read the VTO objects out of the APDU and convertthem to array[byte].> class Slave> * Slave::Send() and Slave::SendUnsolicited() are used to tell class AppLayer> * Slave::CreateResponseContext() appears to create a class APDU instance,No, the responses from the slave (either polled or unsolicted) willcontain a mixture of measurement data and VTO objects. The exactmixture will be a function of:1) VTO ReserverOctetCount2) Events/VTO available3) Maximum size of an APDU> * How does the class Slave instance receive VTO data?Masters write VTO objects to the outstation using the FC_WRITEfunction. You'd have to add a handler here:> Thanks!> Chris\n\nSign in to reply to author You do not have permission to delete messages in this group Either email addresses are anonymous for this group or you need the view member email addresses permission to view the original message Thanks for the response! Addition follow up inline as well ... >On Apr 22, 6:14 pm, Chris Verges <chris.ver...@gmail.com> wrote:\n\n>> Hi Adam,\n\n>>\n\n>> I'm still working my way through the various classes in the DNP3\n\n>>directory\n\n>> so that I know how to implement the VTO feature. Here's what I have so\n\n>>far\n\n>> in the way of understanding: (don't worry, it'll be short!)\n\n>>\n\n>> class APDU\n\n>> * This class represents a DNP3 Application Layer message.\n\n>> * WriteIndexed() seems to be the proper one to use for sending\n\n>>Group112VarX\n\n>> and Group113VarX objects.\n\n>\n\n>This is where my memory starts slipping. I just talked to Sam and he\n\n>recalls that the index encoded the \"port\" of the VTO object, and the\n\n>variation encoded the length (0-255). I believe that WriteIndexed()\n\n>is the correct function, but you'll have to do some unit testing here\n\n>and comparison to the protocol specification. Let's get clear on terminology, since \"port\" seems to be overloaded\n\nalready. :-) As I understand it, a \"port\" in the GEC library is a\n\nphysical layer connection, such as a serial port or a TCP port. A\n\n\"virtual channel\" in the DNP3 specification is similar to a TCP or UDP\n\nport, allowing for multiplexing of the VTO mechanism. Does this match\n\nwith your understanding? If so, then I agree with your explanation if we\n\nchange \"port\" to \"virtual channel.\" >>class ObjectBase\n\n>> * Get() creates the Group112VarX and Group113VarX objects, used by class\n\n>> APDU.\n\n>\n\n>I'm not sure if you need this function or not. Just use the existing\n\n>read/write handler for existing objects as a guide. OK. Where can I find an example of this existing mechanism? >> class IVtoWriter, class VtoMasterWriter, and class VtoSlaveWriter\n\n>> * This class writes a byte stream from the application of arbitrary\n\n>>length\n\n>> to an APDU instance.\n\n>> * The stream is split into segments of at most 255 characters. The\n\n>>minimum\n\n>> size can vary from 0 to aReservedOctetCount, as determined by the\n\n>>available\n\n>> space in the APDU instance. (Unclear how to ensure that\n\n>>aReservedOctetCount\n\n>> is made available if a VTO transmission is pending.)\n\n>\n\n>I think that aReservedOctetCount might be better as a Slave/Master\n\n>configuration parameter (Minimum amount from ANY VTO stream to put\n\n>into each APDU). It will be really hard to do this on a per stream\n\n>basis. Agreed. I will change the MasterConfig and SlaveConfig objects to reflect\n\nthis. >>* Package each segment into a Group112VarX (if VtoMasterWriter) or\n\n>> Group113VarX (if VtoSlaveWriter) instance.\n\n>> class IVtoCallbacks\n\n>> * This class notifies the implementing application of newly received\n\n>>data.\n\n>> * The application should then do whatever it needs with the data,\n\n>>though it\n\n>> should do it quickly, as this blocks other DNP3 functions from being\n\n>> processed.\n\n>> class Master\n\n>> * Master::ProcessDataResponse() seems to process a received class APDU\n\n>> instance.\n\n>> * Various other functions like Master::OnUnsolResponse() seem to trigger\n\n>> other paths, unclear if they eventually converge back to\n\n>> Master::ProcessDataResponse().\n\n>\n\n>I believe that all of those functions return to ProcessDataResponse.\n\n>This is where you'll read the VTO objects out of the APDU and convert\n\n>them to array[byte]. OK. Master::ProcessDataResponse() will be the main change location, then. >>class Slave\n\n>> * Slave::Send() and Slave::SendUnsolicited() are used to tell class\n\n>>AppLayer\n\n>> to write the class APDU instance.\n\n>> * Slave::CreateResponseContext() appears to create a class APDU\n\n>>instance,\n\n>> perhaps usable by class VtoSlaveWriter? (Does this mean that\n\n>>Slave->Master\n\n>> communications will be VTO-packets-only ‹ this is, the APDU instance\n\n>>will\n\n>> only hold VTO objects, no other types?)\n\n>\n\n>No, the responses from the slave (either polled or unsolicted) will\n\n>contain a mixture of measurement data and VTO objects. The exact\n\n>mixture will be a function of:\n\n>\n\n>1) VTO ReserverOctetCount\n\n>2) Events/VTO available\n\n>3) Maximum size of an APDU\n\n>\n\n>> * How does the class Slave instance receive VTO data?\n\n>\n\n >Masters write VTO objects to the outstation using the FC_WRITE\n\n>function. You'd have to add a handler here:\n\n>\n\n>https://github.com/gec/dnp3/blob/master/DNP3/Slave.cpp#L301 Sounds good! So I'll need to add some case(MACRO_DNP_RADIX(112,0))\n\nstatements or the proper equivalent to the Slave::HandleWrite() function."
    },
    {
        "link": "https://sites.google.com/view/dnp3",
        "document": "DNP3 Protocol (Distributed Network Protocol) is a set of communications protocols used between components in process automation systems. Its main use is in utilities such as electric and water companies.\n\nUsage in other industries is not common. It was developed for communications between various types of data acquisition and control equipment. It plays a crucial role in SCADA systems, where it is used by SCADA Master Stations (a.k.a. Control Centers), Remote Terminal Units (RTUs), and Intelligent Electronic Devices (IEDs). It is primarily used for communications between a master station and RTUs or IEDs.\n\n- Quote from Wikipedia page on DNP3"
    },
    {
        "link": "https://sourceforge.net/projects/dnp3-windows-development-sdk",
        "document": "FactoryTalk® Optix™ is a new visualization platform that accelerates value delivery with modern technologies, innovative designs and scalable deployment options. FactoryTalk Optix can help improve your process, efficiency and deliverables – in one easy to access tool. Take advantage of new..."
    },
    {
        "link": "https://dnp3-linux-development-sdk.sourceforge.io",
        "document": "DNP3 (Distributed Network Protocol) is a set of communications protocols used between components in process automation systems. Its main use is in utilities such as electric and water companies. \n\n\n\n\n\n Usage in other industries is not common. It was developed for communications between various types of data acquisition and control equipment. It plays a crucial role in SCADA systems, where it is used by SCADA Master Stations (a.k.a. Control Centers), Remote Terminal Units (RTUs), and Intelligent Electronic Devices (IEDs).\n\n\n\n It is primarily used for communications between a master station and RTUs or IEDs.\n\nFreyrSCADA DNP3 Protocol Demo Linux Shared Library includes simple (Server and Client C programs )example using a Command window and command line inputs.\n\n \n\n The source code will allow you to quickly compile your own examples with the features of your existing development environment to work with our DNP3 Protocol library.\n\n \n\n FreyrSCADA DNP3 Protocol Linux SDK contains Shared Library(.a) (precompiled library), Static link lib, Demo Server and Client programs, CodeBlock Demo console project files, Doxygen .\n\n \n\n We used gcc compiler to create the Shared Library, sample test projects.\n\n gcc Compiler Version: gcc 4.6.3 - i686."
    },
    {
        "link": "http://discussions.gridprotectionalliance.org/t/how-to-setup-dnp3-device/347",
        "document": "DNP3 (IEEE-1815) protocol stack. Modern C++ with bindings for .NET and Java. - GitHub - dnp3/opendnp3: DNP3 (IEEE-1815) protocol stack. Modern C++ with bindings for .NET and Java."
    },
    {
        "link": "https://docs.stepfunc.io/dnp3/0.9.0/guide/docs/examples/summary",
        "document": "The source repository contains example programs that may be compiled and run interactively. Each program demonstrates the usage of various API features by reading console input from the user.\n\nAs you read through the examples, you may notice blocks of code surrounded by tags.\n\nThese blocks of code are pulled from the example programs and used as snippets in this guide. This ensures that all of the snippets that you encounter when reading the documentation are always syntactically valid as they extracted from working programs.\n\nThe following links redirect to language-specific examples for the current version on Github:"
    },
    {
        "link": "https://github.com/dnp3/opendnp3",
        "document": "This project will reach end-of-life on September 1st, 2022. On this date:\n• This repository will be archived, making it read-only.\n• The Google Group will be locked, but will remain publicly searchable.\n• The project homepage, this README, and group will be updated to indicate that the project is end-of-life.\n\nWe will consider bug fixes from the community or support requests from existing customers up until this date.\n\nPlease make appropriate plans if you are using this library in production, e.g.:\n• Dedicate personnel to maintaining your own internal copy of the library.\n• Consider a commercial library such as the one offered by Step Function I/O.\n\nYou can read about this decision in these blog posts:\n\nOpendnp3 is a portable, scalable, and rigorously tested implementation of the DNP3 protocol stack written in C++11. The library is designed for high-performance applications like many concurrent TCP sessions or huge device simulations. It also embeds with a small footprint on Linux.\n\nThe documentation can be found on the project homepage.\n\nIf you want to help contribute to the official guide its in this repo.\n\nLicensed under the terms of the Apache 2.0 License."
    },
    {
        "link": "https://files.realpars.com/siemens/manuals/PGH_TC-DNP3_76.pdf",
        "document": ""
    },
    {
        "link": "https://atop.com.cn/atop/mw/cufiles/files/download/eNode_designer/User_manual/eNode%20Designer%20User%20Manual%20DNP3%20Atop%20v1_3.pdf",
        "document": ""
    }
]