[
    {
        "link": "https://registry.khronos.org/OpenGL/specs/es/3.2/es_spec_3.2.pdf",
        "document": ""
    },
    {
        "link": "https://registry.khronos.org/OpenGL/specs/es/3.2/es_spec_3.2.withchanges.pdf",
        "document": ""
    },
    {
        "link": "https://docs.nvidia.com/drive/archive/5.1.6.0L/nvvib_docs/DRIVE_OS_Linux_SDK_Development_Guide/baggage/es_spec_3.2.withchanges.pdf",
        "document": ""
    },
    {
        "link": "https://developer.android.com/develop/ui/views/graphics/opengl/about-opengl",
        "document": "Android includes support for high performance 2D and 3D graphics with the Open Graphics Library (OpenGL®), specifically, the OpenGL ES API. OpenGL is a cross-platform graphics API that specifies a standard software interface for 3D graphics processing hardware. OpenGL ES is a flavor of the OpenGL specification intended for embedded devices. Android supports several versions of the OpenGL ES API:\n• OpenGL ES 2.0 - This API specification is supported by Android 2.2 (API level 8) and higher.\n• OpenGL ES 3.0 - This API specification is supported by Android 4.3 (API level 18) and higher.\n• OpenGL ES 3.1 - This API specification is supported by Android 5.0 (API level 21) and higher.\n• OpenGL ES 3.2 - This API specification is supported by Android 7.0 (API level 24) and higher.\n\nCaution: Regardless of the Android platform version, a device cannot support the OpenGL ES 3.0 API unless the device manufacturer provides an implementation of this graphics pipeline. If you specify in the manifest that OpenGL ES 3.0 is required, you can be sure that that version will be present on the device. If you specify that a lower-level version is required but you want to use 3.0 features if they're available, you should check at run time to see what version of OpenGL the device supports. For information on how to do this, see Checking OpenGL ES version.\n\nNote: Android includes support for OpenGL ES 1.0 and 1.1, but these versions of the API are deprecated and shouldn't be used by modern applications.\n\nNote: The specific API provided by the Android framework is similar to the J2ME JSR239 OpenGL ES API, but isn't identical. If you are familiar with J2ME JSR239 specification, be alert for variations.\n\nAndroid supports OpenGL both through its framework API and the Native Development Kit (NDK). This topic focuses on the Android framework interfaces. For more information about the NDK, see the Android NDK.\n\nThere are two foundational classes in the Android framework that let you create and manipulate graphics with the OpenGL ES API: and . If your goal is to use OpenGL in your Android application, understanding how to implement these classes in an activity should be your first objective.\n\nOnce you have established a container view for OpenGL ES using and , you can begin calling OpenGL APIs using the following classes:\n• OpenGL ES 2.0 API Class\n• - This package provides the interface to OpenGL ES 2.0 and is available starting with Android 2.2 (API level 8).\n• OpenGL ES 3.0/3.1/3.2 API Packages\n• - This package provides the interface to the OpenGL ES 3.0/3.1 classes. Version 3.0 is available starting with Android 4.3 (API level 18). Version 3.1 is available starting with Android 5.0 (API level 21). Version 3.2 is available starting with Android 7.0 (API level 24).\n\nIf you want to start building an app with OpenGL ES right away, follow the Displaying graphics with OpenGL ES class.\n\nIf your application uses OpenGL features that are not available on all devices, you must include these requirements in your AndroidManifest.xml file. Here are the most common OpenGL manifest declarations:\n• OpenGL ES version requirements - If your application requires a specific version of OpenGL ES, you must declare that requirement by adding the following settings to your manifest as shown below. <!-- Tell the system this app requires OpenGL ES 2.0. --> <uses-feature android:glEsVersion=\"0x00020000\" android:required=\"true\" /> Adding this declaration causes Google Play to restrict your application from being installed on devices that do not support OpenGL ES 2.0. If your application is exclusively for devices that support OpenGL ES 3.0, you can also specify this in your manifest: <!-- Tell the system this app requires OpenGL ES 3.0. --> <uses-feature android:glEsVersion=\"0x00030000\" android:required=\"true\" /> <!-- Tell the system this app requires OpenGL ES 3.1. --> <uses-feature android:glEsVersion=\"0x00030001\" android:required=\"true\" /> <!-- Tell the system this app requires OpenGL ES 3.2. --> <uses-feature android:glEsVersion=\"0x00030002\" android:required=\"true\" /> Note: The OpenGL ES 3.x API is backwards-compatible with the 2.0 API, which means you can be more flexible with your implementation of OpenGL ES in your application. By declaring the OpenGL ES 2.0 API as a requirement in your manifest, you can use that API version as a default, check for the availability of the 3.x API at run time and then use OpenGL ES 3.x features if the device supports it. For more information about checking the OpenGL ES version supported by a device, see Checking OpenGL ES version.\n• Texture compression requirements - If your application uses texture compression formats, you must declare the formats your application supports in your manifest file using . For more information about available texture compression formats, see Texture compression support. Declaring texture compression requirements in your manifest hides your application from users with devices that do not support at least one of your declared compression types. For more information on how Google Play filtering works for texture compressions, see the Google Play and texture compression filtering section of the documentation.\n\nOne of the basic problems in displaying graphics on Android devices is that their screens can vary in size and shape. OpenGL assumes a square, uniform coordinate system and, by default, happily draws those coordinates onto your typically non-square screen as if it is perfectly square.\n\nThe illustration above shows the uniform coordinate system assumed for an OpenGL frame on the left, and how these coordinates actually map to a typical device screen in landscape orientation on the right. To solve this problem, you can apply OpenGL projection modes and camera views to transform coordinates so your graphic objects have the correct proportions on any display.\n\nIn order to apply projection and camera views, you create a projection matrix and a camera view matrix and apply them to the OpenGL rendering pipeline. The projection matrix recalculates the coordinates of your graphics so that they map correctly to Android device screens. The camera view matrix creates a transformation that renders objects from a specific eye position.\n\nProjection and camera view in OpenGL ES 2.0 and higher\n\nIn the ES 2.0 and 3.0 APIs, you apply projection and camera view by first adding a matrix member to the vertex shaders of your graphics objects. With this matrix member added, you can then generate and apply projection and camera viewing matrices to your objects.\n• Add matrix to vertex shaders - Create a variable for the view projection matrix and include it as a multiplier of the shader's position. In the following example vertex shader code, the included member allows you to apply projection and camera viewing matrices to the coordinates of objects that use this shader. // This matrix member variable provides a hook to manipulate // the coordinates of objects that use this vertex shader. // The matrix must be included as part of gl_Position // Note that the uMVPMatrix factor *must be first* in order // for the matrix multiplication product to be correct. // This matrix member variable provides a hook to manipulate // the coordinates of objects that use this vertex shader. // The matrix must be included as part of gl_Position // Note that the uMVPMatrix factor *must be first* in order // for the matrix multiplication product to be correct. Note: The example above defines a single transformation matrix member in the vertex shader into which you apply a combined projection matrix and camera view matrix. Depending on your application requirements, you may want to define separate projection matrix and camera viewing matrix members in your vertex shaders so you can change them independently.\n• Access the shader matrix - After creating a hook in your vertex shaders to apply projection and camera view, you can then access that variable to apply projection and camera viewing matrices. The following code shows how to modify the method of a implementation to access the matrix variable defined in the vertex shader above.\n• Create projection and camera viewing matrices - Generate the projection and viewing matrices to be applied the graphic objects. The following example code shows how to modify the and methods of a implementation to create camera view matrix and a projection matrix based on the screen aspect ratio of the device.\n• Apply projection and camera viewing matrices - To apply the projection and camera view transformations, multiply the matrices together and then set them into the vertex shader. The following example code shows how modify the method of a implementation to combine the projection matrix and camera view created in the code above and then apply it to the graphic objects to be rendered by OpenGL.\n\nFor a complete example of how to apply projection and camera view with OpenGL ES 2.0, see the Displaying graphics with OpenGL ES class.\n\nIn OpenGL, the face of a shape is a surface defined by three or more points in three-dimensional space. A set of three or more three-dimensional points (called vertices in OpenGL) have a front face and a back face. How do you know which face is front and which is the back? Good question. The answer has to do with winding, or, the direction in which you define the points of a shape.\n\nFigure 1. Illustration of a coordinate list which translates into a counterclockwise drawing order.\n\nIn this example, the points of the triangle are defined in an order such that they are drawn in a counterclockwise direction. The order in which these coordinates are drawn defines the winding direction for the shape. By default, in OpenGL, the face which is drawn counterclockwise is the front face. The triangle shown in Figure 1 is defined so that you are looking at the front face of the shape (as interpreted by OpenGL) and the other side is the back face.\n\nWhy is it important to know which face of a shape is the front face? The answer has to do with a commonly used feature of OpenGL, called face culling. Face culling is an option for the OpenGL environment which allows the rendering pipeline to ignore (not calculate or draw) the back face of a shape, saving time, memory and processing cycles:\n\nIf you try to use the face culling feature without knowing which sides of your shapes are the front and back, your OpenGL graphics are going to look a bit thin, or possibly not show up at all. So, always define the coordinates of your OpenGL shapes in a counterclockwise drawing order.\n\nNote: It is possible to set an OpenGL environment to treat the clockwise face as the front face, but doing so requires more code and is likely to confuse experienced OpenGL developers when you ask them for help. So don’t do that.\n\nThe OpenGL ES 1.0 and 1.1 API specifications have been supported since Android 1.0. Graphics programming with OpenGL ES 1.0/1.1 API is significantly different than using the 2.0 and higher versions. OpenGL ES 2.0 is supported by all Android devices beginning with Android 2.2 (API level 8) and is the earliest version recommended for new applications being developed with OpenGL ES. OpenGL ES 3.0 is supported with Android 4.3 (API level 18) and higher, on devices that provide an implementation of the OpenGL ES 3.0 API. For information about the relative number of Android-powered devices that support a given version of OpenGL ES, see the OpenGL ES version dashboard.\n\nYou should carefully consider the graphics requirements and choose the API version that works best for your application. For more information, see Choosing an OpenGL API version.\n\nThe OpenGL ES 3.0 API provides additional features and better performance than the 2.0 API and is also backward compatible. This means that you can potentially write your application targeting OpenGL ES 2.0 and conditionally include OpenGL ES 3.0 graphics features if they are available. For more information on checking for availability of the 3.0 API, see Checking OpenGL ES version\n\nTexture compression can significantly increase the performance of your OpenGL application by reducing memory requirements and making more efficient use of memory bandwidth. The Android framework provides support for the ETC1 compression format as a standard feature, including a utility class and the compression tool (located in the Android SDK at ). For an example of an Android application that uses texture compression, see the code sample in Android SDK ( ).\n\nThe ETC1 format is supported by all Android devices that support OpenGL ES 2.0 or higher.\n\nNote: The ETC1 texture compression format does not support textures with a transparency (alpha channel). If your application requires textures with transparency, you should investigate other texture compression formats available on your target devices. A method of rendering alpha channel textures using ETC1 is to bind two ETC1 texture objects: the first with color data, the second with alpha channel data and then combine the values from the two textures in the fragment shader.\n\nThe ETC2/EAC texture compression formats are guaranteed to be available when using the OpenGL ES 3.0 API. This texture format offers excellent compression ratios with high visual quality and the format also supports transparency (alpha channel).\n\nBeyond the ETC formats, Android devices have varied support for texture compression based on their GPU chipsets and OpenGL implementations. You should investigate texture compression support on the devices you are are targeting to determine what compression types your application should support. In order to determine what texture formats are supported on a given device, you must query the device and review the OpenGL extension names, which identify what texture compression formats (and other OpenGL features) are supported by the device. Some commonly supported texture compression formats are as follows:\n• Adaptable Scalable Texture Compression (ASTC) - A texture compression format designed to supersede prior formats. More flexible than previous formats due to support for various block sizes.\n• S3TC (DXTn/DXTC) - S3 texture compression (S3TC) has several format variations (DXT1 to DXT5) and is less widely available. The format supports RGB textures with 4-bit alpha or 8-bit alpha channels. These formats are represented by the following OpenGL extension name: Some devices only support the DXT1 format variation; this limited support is represented by the following OpenGL extension name:\n\nThe following texture compression formats are considered legacy formats and aren't recommended for use in new applications:\n• ATITC (ATC) - ATI texture compression (ATITC or ATC) is available on a wide variety of devices and supports fixed rate compression for RGB textures with and without an alpha channel. This format may be represented by several OpenGL extension names, for example:\n• PVRTC - PowerVR texture compression (PVRTC) is available on a wide variety of devices and supports 2-bit and 4-bit per pixel textures with or without an alpha channel. This format is represented by the following OpenGL extension name:\n• 3DC - 3DC texture compression (3DC) is a less widely available format that supports RGB textures with an alpha channel. This format is represented by the following OpenGL extension name:\n\nWarning: These texture compression formats are not supported on all devices. Support for these formats can vary by manufacturer and device. For information on how to determine what texture compression formats are on a particular device, see the next section.\n\nNote: Once you decide which texture compression formats your application will support, make sure you declare them in your manifest using <supports-gl-texture> . Using this declaration enables filtering by external services such as Google Play, so that your app is installed only on devices that support the formats your app requires. For details, see OpenGL manifest declarations.\n\nImplementations of OpenGL vary by Android device in terms of the extensions to the OpenGL ES API that are supported. These extensions include texture compressions, but typically also include other extensions to the OpenGL feature set.\n\nTo determine what texture compression formats, and other OpenGL extensions, are supported on a particular device:\n• Run the following code on your target devices to determine what texture compression formats are supported: Warning: The results of this call vary by device model! You must run this call on several target devices to determine what compression types are commonly supported.\n• Review the output of this method to determine what OpenGL extensions are supported on the device.\n\nThe AEP ensures that your application supports a standardized set of OpenGL extensions above and beyond the core set described in the OpenGL 3.1 specification. Packaging these extensions together encourages a consistent set of functionality across devices, while allowing developers to take full advantage of the latest crop of mobile GPU devices.\n\nThe AEP also improves support for images, shader storage buffers, and atomic counters in fragment shaders.\n\nFor your app to be able to use the AEP, the app's manifest must declare that the AEP is required. In addition, the platform version must support it.\n\nAll of the additional features specified in the AEP are included in the base OpenGL ES 3.2 specification. If your app requires OpenGL ES 3.2 you do not need to require the AEP.\n\nDeclare the AEP requirement in the manifest as follows:\n\nTo verify that the platform version supports the AEP, use the method, passing in as the argument. The following code snippet shows an example of how to do so:\n\nIf the method returns true, AEP is supported.\n\nFor more information about the AEP, visit its page at the Khronos OpenGL ES Registry.\n\nThere are several versions of OpenGL ES available on Android devices. You can specify the minimum version of the API your application requires in your manifest, but you may also want to take advantage of features in a newer API at the same time. For example, the OpenGL ES 3.0 API is backward-compatible with the 2.0 version of the API, so you may want to write your application so that it uses OpenGL ES 3.0 features, but falls back to the 2.0 API if the 3.0 API is not available.\n\nBefore using OpenGL ES features from a version higher than the minimum required in your application manifest, your application should check the version of the API available on the device. You can do this in one of two ways:\n• Attempt to create the higher-level OpenGL ES context ( ) and check the result.\n• Create a minimum-supported OpenGL ES context and check the version value.\n\nThe following example code demonstrates how to check the available OpenGL ES version by creating an and checking the result. This example shows how to check for OpenGL ES 3.0 version:\n\nIf the method show above returns null, your code should create a OpenGL ES 2.0 context instead and fall back to using only that API.\n\nThe following code example demonstrates how to check the OpenGL ES version by creating a minimum supported context first, and then checking the version string:\n\nWith this approach, if you discover that the device supports a higher-level API version, you must destroy the minimum OpenGL ES context and create a new context with the higher available API version.\n\nOpenGL ES version 2.0, and version 3.0 both provide high performance graphics interfaces for creating 3D games, visualizations and user interfaces. Graphics progamming for OpenGL ES 2.0 and 3.0 is largely similar, with version 3.0 representing a superset of the 2.0 API with additional features. Programming for the OpenGL ES 1.0/1.1 API versus OpenGL ES 2.0 and 3.0 differs significantly, and isn't recommended for new applications. Developers should carefully consider the following factors before starting development with these APIs:\n• Device Compatibility - Developers should consider the types of devices, Android versions and the OpenGL ES versions available to their customers. For more information on OpenGL compatibility across devices, see the OpenGL versions and device compatibility section.\n• Texture Support - The OpenGL ES 3.0 API has the best support for texture compression because it guarantees availability of the ETC2 compression format, which supports transparency. The 2.0 API implementations include support for ETC1, however this texture format doesn't support transparency. To implement transparency with compressed textures you must either use two ETC1 textures (split between color and alpha) or provide resources in other compression formats supported by the devices you are targeting. For more information, see Texture compression support.\n\nWhile compatibility, and texture support may influence your decision, you should pick an OpenGL API version based on what you think provides the best experience for your users."
    },
    {
        "link": "https://docs.nvidia.com/drive/drive_os_5.1.6.1L/nvvib_docs/DRIVE_OS_Linux_SDK_Development_Guide/baggage/es_spec_3.2.withchanges.pdf",
        "document": ""
    },
    {
        "link": "https://registry.khronos.org/OpenGL/specs/es/3.2/GLSL_ES_Specification_3.20.html",
        "document": "The source character set used for the OpenGL ES Shading Language is Unicode in the UTF-8 encoding scheme. Invalid UTF-8 characters are ignored. During pre-processing, the following applies:\n• A byte with the value zero is always interpreted as the end of the string\n• Backslash ('\\'), is used to indicate line continuation when immediately preceding a new-line.\n• White space consists of one or more of the following characters: the space character, horizontal tab, vertical tab, form feed, carriage-return, line-feed.\n• The number sign (#) is used for preprocessor directives\n• \n• The letters a-z, A-Z, and the underscore (_).\n• The numbers 0-9, except for the first character of a macro name. After preprocessing, only the following characters are allowed in the resulting stream of GLSL ES tokens:\n• The letters a-z, A-Z, and the underscore (_).\n• The symbols period (.), plus (+), dash (-), slash (/), asterisk (*), percent (%), angled brackets (< and >), square brackets ([ and ]), parentheses (( and )), braces ({ and }), caret (^), vertical bar (|), ampersand (&), tilde (~), equals (=), exclamation point (!), colon (:), semicolon (;), comma (,), and question mark (?). There are no digraphs or trigraphs. There are no escape sequences or other uses of the backslash beyond use as the line-continuation character. Lines are relevant for compiler diagnostic messages and the preprocessor. They are terminated by carriage-return or line-feed. If both are used together, it will count as only a single line termination. For the remainder of this document, any of these combinations is simply referred to as a new-line. Lines may be of arbitrary length. In general, the language’s use of this character set is case sensitive. There are no character or string data types, so no quoting characters are included. There is no end-of-file character. The source for a single shader is an array of strings of characters from the character set. A single shader is made from the concatenation of these strings. Each string can contain multiple lines, separated by new-lines. No new-lines need be present in a string; a single line can be formed from multiple strings. No new-lines or other characters are inserted by the implementation when it concatenates the strings to form a single shader. Diagnostic messages returned from compiling a shader must identify both the line number within a string and which source string the message applies to. Source strings are counted sequentially with the first string being string 0. Line numbers are one more than the number of new-lines that have been processed, including counting the new-lines that will be removed by the line-continuation character (\\). Lines separated by the line-continuation character preceding a new-line are concatenated together before either comment processing or preprocessing. This means that no white space is substituted for the line-continuation character. That is, a single token could be formed by the concatenation by taking the characters at the end of one line concatenating them with the characters at the beginning of the next line. Shaders must declare the version of the language they are written to. The version is specified in the first line of a shader by a character string: where number must be a version of the language, following the same convention as __VERSION__ above. The directive “#version 320 es” is required in any shader that uses version 3.20 of the language. Any number representing a version of the language a compiler does not support will cause an error to be generated. Version 1.00 of the language does not require shaders to include this directive, and shaders that do not include a #version directive will be treated as targeting version 1.00. Shaders declaring version 3.20 of the shading language cannot be linked with shaders declaring a previous version. The #version directive must be present in the first line of a shader and must be followed by a newline. It may contain optional white-space as specified below but no other characters are allowed. The directive is only permitted in the first line of a shader. Processing of the #version directive occurs before all other preprocessing, including line concatenation and comment processing. There is a preprocessor that processes the source strings as part of the compilation process. Except as noted below, it behaves as the C++ standard preprocessor (see “Normative References”). The complete list of preprocessor directives is as follows. The following operator is also available: Note that the version directive is not considered to be a preprocessor directive and so is not listed here. Each number sign (#) can be preceded in its line only by spaces or horizontal tabs. It may also be followed by spaces and horizontal tabs, preceding the directive. Each directive is terminated by a new-line. Preprocessing does not change the number or relative location of new-lines in a source string. The number sign (#) on a line by itself is ignored. Any directive not listed above will cause an error. #define and #undef functionality are defined as is standard for C++ preprocessors for macro definitions both with and without macro parameters. The following predefined macros are available: __LINE__ will substitute a decimal integer constant that is one more than the number of preceding new-lines in the current source string. __FILE__ will substitute a decimal integer constant that says which source string number is currently being processed. __VERSION__ will substitute a decimal integer reflecting the version number of the OpenGL ES Shading Language. The version of the shading language described in this document will have __VERSION__ substitute the decimal integer 320. GL_ES will be defined and set to 1. This is not true for the non-ES OpenGL Shading Language, so it can be used to do a compile time test to determine if a shader is compiling as an GLSL ES shader. By convention, all macro names containing two consecutive underscores (__) are reserved for use by underlying software layers. Defining such a name in a shader does not itself result in an error, but may result in unintended behaviors that stem from having multiple definitions of the same name. All macro names prefixed with “GL_” (“GL” followed by a single underscore) are also reserved, and defining such a name results in a compile-time error. It is an error to undefine or to redefine a built-in (pre-defined) macro name. Implementations must support macro-name lengths of up to 1024 characters. It is an error to declare a name with a length greater than this. #if, #ifdef, #ifndef, #else, #elif, and #endif are defined to operate as is standard for C++ preprocessors except for the following:\n• Expressions following #if and #elif are restricted to pp-constant-expressions as defined below.\n• Undefined identifiers not consumed by the defined operator do not default to '0'. Use of such identifiers causes an error. As in C++, a macro name defined with an empty replacement list does not default to '0' when used in a preprocessor expression. A pp-constant-expression is an integral expression, evaluated at compile-time during preprocessing and formed from literal integer constants and the following operators: The defined operator can be used in either of the following ways: There are no number sign based operators (e.g. no or @), no ## operator, nor is there a sizeof operator. The semantics of applying operators in the preprocessor match those standard in the C++ preprocessor with the following exceptions:\n• The 2nd operand in a logical and ('&&') operation is evaluated if and only if the 1st operand evaluates to non-zero.\n• The 2nd operand in a logical or ('||') operation is evaluated if and only if the 1st operand evaluates to zero.\n• There is no boolean type and no boolean literals. A true or false result is returned as integer one or zero respectively. Wherever a boolean operand is expected, any non-zero integer is interpreted as true and a zero integer as false. If an operand is not evaluated, the presence of undefined identifiers in the operand will not cause an error. #error will cause the implementation to put a compile-time diagnostic message into the shader object’s information log (see section 7.12 “Shader, Program and Program Pipeline Queries” of the OpenGL ES Specification for how to access a shader object’s information log). The message will be the tokens following the #error directive, up to the first new-line. The implementation must treat the presence of a #error directive as a compile-time error. #pragma allows implementation-dependent compiler control. Tokens following #pragma are not subject to preprocessor macro expansion. If an implementation does not recognize the tokens following #pragma, then it will ignore that pragma. The following pragmas are defined as part of the language. The STDGL pragma is used to reserve pragmas for use by future revisions of this language. No implementation may use a pragma whose first token is STDGL. can be used to turn off optimizations as an aid in developing and debugging shaders. It can only be used outside function definitions. By default, optimization is turned on for all shaders. The debug pragma can be used to enable compiling and annotating a shader with debug information, so that it can be used with a debugger. It can only be used outside function definitions. By default, debug is turned off. The scope as well as the effect of the optimize and debug pragmas is implementation-dependent except that their use must not generate an error. Incorrect use of predefined pragmas does not cause an error. By default, compilers of this language must issue compile-time syntactic, semantic, and grammatical errors for shaders that do not conform to this specification. Any extended behavior must first be enabled. Directives to control the behavior of the compiler with respect to extensions are declared with the #extension directive where extension_name is the name of an extension. Extension names are not documented in this specification. The token all means the behavior applies to all extensions supported by the compiler. The behavior can be one of the following: Behave as specified by the extension extension_name.\n\n Give a compile-time error on the #extension if the extension extension_name is not supported, or if all is specified. Behave as specified by the extension extension_name.\n\n Warn on the #extension if the extension extension_name is not supported.\n\n Give an error on the #extension if all is specified. Behave as specified by the extension extension_name, except issue warnings on any detectable use of that extension, unless such use is supported by other enabled or required extensions.\n\n If all is specified, then warn on all detectable uses of any extension used.\n\n Warn on the #extension if the extension extension_name is not supported. Behave (including issuing errors and warnings) as if the extension extension_name is not part of the language definition.\n\n If all is specified, then behavior must revert back to that of the non-extended core version of the language being compiled to.\n\n Warn on the #extension if the extension extension_name is not supported. The extension directive is a simple, low-level mechanism to set the behavior for each extension. It does not define policies such as which combinations are appropriate, those must be defined elsewhere. Order of directives matters in setting the behavior for each extension: Directives that occur later override those seen earlier. The all variant sets the behavior for all extensions, overriding all previously issued extension directives, but only for the behaviors warn and disable. The initial state of the compiler is as if the directive was issued, telling the compiler that all error and warning reporting must be done according to this specification, ignoring any extensions. Each extension can define its allowed granularity of scope. If nothing is said, the granularity is a shader (that is, a single compilation unit), and the extension directives must occur before any non-preprocessor tokens. If necessary, the linker can enforce granularities larger than a single compilation unit, in which case each involved shader will have to contain the necessary extension directive. Macro expansion is not done on lines containing #extension and #version directives. For each extension there is an associated macro. The macro is always defined in an implementation that supports the extension. This allows the following construct to be used: #line must have, after macro substitution, one of the following forms: where line and source-string-number are pp-constant-expressions. If these constant expressions are not integer literals then behavior is undefined. After processing this directive (including its new-line), the implementation will behave as if it is compiling at line number line and source string number source-string-number. Subsequent source strings will be numbered sequentially, until another #line directive overrides that numbering. Some implementations have allowed constant expressions in #line directives and some have not. Even where expressions are supported the grammar is ambiguous and so results are implementation dependent. For example, + #line +2 +2 // Line number set to 4, or file to 2 and line to 2 When targeting Vulkan, the following predefined macro is available: If during macro expansion a preprocessor directive is encountered, the results are undefined; the compiler may or may not report an error in such cases. Comments are delimited by /* and */, or by // and a new-line. // style comments include the initial // marker and continue up to, but not including, the terminating newline. /*...*/ comments include both the start and end marker. The begin comment delimiters (/* or //) are not recognized as comment delimiters inside of a comment, hence comments cannot be nested. Comments are treated syntactically as a single space. The language, after preprocessing, is a sequence of tokens. A token can be The following are the keywords in the language and (after preprocessing) can only be used as described in this specification, or an error results: break continue do for while switch case default In addition, when targeting Vulkan, the following keywords also exist: The following are the keywords reserved for future use. Using them will result in an error: In addition, all identifiers containing two consecutive underscores (__) are reserved for use by underlying software layers. Defining such a name in a shader does not itself result in an error, but may result in unintended behaviors that stem from having multiple definitions of the same name. Identifiers are used for variable names, function names, structure names, and field selectors (field selectors select components of and , similarly to structure members). Identifiers have the form: Identifiers starting with “gl_” are reserved, and in general, may not be declared in a shader; this results in an error. However, as noted in the specification, there are some cases where previously declared variables can be redeclared, and predeclared “gl_” names are allowed to be redeclared in a shader only for these specific purposes. Implementations must support identifier lengths of up to 1024 characters. It is an error if the length exceeds this value. Some language rules described below depend on the following definitions. A shader contains a static use of a variable x if, after preprocessing, the shader contains a statement that would access any part of x, whether or not flow of control will cause that statement to be executed. Such a variable is referred to as being statically used. If the access is a write then x is further said to be statically assigned. Some operations require an expression to be dynamically uniform, or that it be located in uniform control flow. These requirements are defined by the following set of definitions. An invocation is a single execution of main() for a particular stage, operating only on the amount of data explicitly exposed within that stage’s shaders. (Any implicit operation on additional instances of data would comprise additional invocations.) For example, in compute execution models, a single invocation operates only on a single work item, or, in a vertex execution model, a single invocation operates only on a single vertex. An invocation group is the complete set of invocations collectively processing a particular compute workgroup or graphical operation, where the scope of a \"graphical operation\" is implementation-dependent, but at least as large as a single triangle or patch, and at most as large as a single rendering command, as defined by the client API. Within a single invocation, a single shader statement can be executed multiple times, giving multiple dynamic instances of that instruction. This can happen when the instruction is executed in a loop, or in a function called from multiple call sites, or combinations of multiple of these. Different loop iterations and different dynamic function-call-site chains yield different dynamic instances of such an instruction. Dynamic instances are distinguished by their control-flow path within an invocation, not by which invocation executed it. That is, different invocations of main() execute the same dynamic instances of an instruction when they follow the same control-flow path. An expression is dynamically uniform for a dynamic instance consuming it when its value is the same for all invocations (in the invocation group) that execute that dynamic instance. Uniform control flow (or converged control flow) occurs when all invocations in the invocation group execute the same control-flow path (and hence the same sequence of dynamic instances of instructions). Uniform control flow is the initial state at the entry into main(), and lasts until a conditional branch takes different control paths for different invocations (non-uniform or divergent control flow). Such divergence can reconverge, with all the invocations once again executing the same control-flow path, and this re-establishes the existence of uniform control flow. If control flow is uniform upon entry into a selection or loop, and all invocations in the invocation group subsequently leave that selection or loop, then control flow reconverges to be uniform. Other examples of non-uniform control flow can occur within loops where some invocations execute iterations that others do not, after conditional breaks, continues, early returns, and after fragment discards, when the condition is true for some fragments but not others. Note that constant expressions are trivially dynamically uniform. It follows that typical loop counters based on these are also dynamically uniform. The compilation units for the shader processors are processed separately before optionally being linked together in the final stage of compilation. The logical phases of compilation are:\n• Source strings are input as byte sequences. The value 'zero' is interpreted as a terminator.\n• Source strings are concatenated to form a single input. Zero bytes are discarded but all other values are retained.\n• Each string is interpreted according to the UTF-8 standard, with the exception that all invalid byte sequences are retained in their original form for subsequent processing.\n• Each {carriage-return, line-feed} and {line-feed, carriage return} sequence is replaced by a single newline. All remaining carriage-return and line-feed characters are then each replaced by a newline.\n• Line numbering for each character, which is equal to the number of preceding newlines plus one, is noted. Note this can only be subsequently changed by the #line directive and is not affected by the removal of newlines in phase 6 of compilation.\n• Wherever a backslash ('\\') occurs immediately before a newline, both are deleted. Note that no whitespace is substituted, thereby allowing a single preprocessing token to span a newline. This operation is not recursive; any new {backslash newline} sequences generated are not removed.\n• All comments are replaced with a single space. All (non-zero) characters and invalid UTF-8 byte sequences are allowed within comments. '//' style comments include the initial '//' marker and continue up to, but not including, the terminating newline. '/…​/' comments include both the start and end marker.\n• The source string is converted into a sequence of preprocessing tokens. These tokens include preprocessing numbers, identifiers and preprocessing operations. The line number associated with each token is copied from the line number of the first character of the token.\n• The preprocessor is run. Directives are executed and macro expansion is performed.\n• The syntax is analyzed according to the GLSL ES grammar.\n• The result is checked according to the semantic rules of the language.\n• Optionally, the shaders are linked together to form one or more programs or separable programs. When a pair of shaders from consecutive stages are linked into the same program, any outputs and corresponding inputs not used in both shaders may be discarded.\n\nAll variables and functions must be declared before being used. Variable and function names are identifiers. There are no default types. All variable and function declarations must have a declared type, and optionally qualifiers. A variable is declared by specifying its type followed by one or more names separated by commas. In many cases, a variable can be initialized as part of its declaration by using the assignment operator (=). User-defined types may be defined using struct to aggregate a list of existing types into a single name. The OpenGL ES Shading Language is type safe. There are no implicit conversions between types. A basic type is a type defined by a keyword in the language. The OpenGL ES Shading Language supports the following basic data types, grouped as follows. for functions that do not return a value a conditional type, taking on values of true or false Note that where the following tables say “accessing a texture”, the sampler* opaque types access textures, and the image* opaque types access images, of a specified type. a handle for accessing state describing how to sample a texture a handle for accessing state describing how to sample a depth texture with comparison In addition, a shader can aggregate these basic types using arrays and structures to build more complex types. There are no pointer types. Functions that do not return a value must be declared as void. There is no default function return type. The keyword void cannot be used in any other declarations (except for empty formal or actual parameter lists), or an error results. A boolean type is any boolean scalar or vector type (bool, bvec2, bvec3, bvec4) To make conditional execution of code easier to express, the type bool is supported. There is no expectation that hardware directly supports variables of this type. It is a genuine Boolean type, holding only one of two values meaning either true or false. Two keywords true and false can be used as literal Boolean constants. Booleans are declared and optionally initialized as in the follow example: Expressions used for conditional jumps (if, for, ?:, while, do-while) must evaluate to the type bool. An integral type is any signed or unsigned, scalar or vector integer type. It excludes arrays and structures. A vector integral type is a vector of signed or unsigned integers: Signed and unsigned integer variables are fully supported. In this document, the term integer is meant to generally include both signed and unsigned integers. highp unsigned integers have exactly 32 bits of precision. When targeting Vulkan, mediump and lowp integers are as defined by the SPIR-V RelaxedPrecision decoration. Otherwise, mediump and lowp integers have implementation-defined numbers of bits. See “Range and Precision” for details. For all precisions, addition, subtraction and multiplication resulting in overflow or underflow will result in the low-order n bits of the correct result R, where n is the size in bits of the integer and R is computed with enough precision to avoid overflow or underflow. Division resulting in overflow will result in an undefined value. Integers are declared and optionally initialized with integer expressions, as in the following example: Literal integer constants can be expressed in decimal (base 10), octal (base 8), or hexadecimal (base 16) as follows. No white space is allowed between the digits of an integer constant, including after the leading 0 or after the leading 0x or 0X of a constant, or before the suffix u or U. When the suffix u or U is present, the literal has type uint, otherwise the type is int. A leading unary minus sign (-) is interpreted as an arithmetic unary negation, not as part of the constant. Hence, literals themselves are always expressed with non-negative syntax, though they could result in a negative value. It is an error to provide a literal integer whose bit pattern cannot fit in 32 bits. The bit pattern of the literal is always used unmodified. So a signed literal whose bit pattern includes a set sign bit creates a negative value. A floating-point type is any floating-point scalar, vector or matrix type. It excludes arrays and structures. Floats are available for use in a variety of scalar calculations. Floating-point variables are defined as in the following example: As an input value to one of the processing units, a floating-point variable is expected to match the IEEE 754 single precision floating-point definition for precision and dynamic range. highp floating-point variables within a shader are encoded according to the IEEE 754 specification for single-precision floating-point values (logically, not necessarily physically). While encodings are logically IEEE 754, operations (addition, multiplication, etc.) are not necessarily performed as required by IEEE 754. See “Range and Precision” for more details on precision and usage of NaNs (Not a Number) and Infs (positive or negative infinities). Floating-point constants are defined as follows. A decimal point (.) is not needed if the exponent part is present. No white space may appear anywhere within a floating-point constant, including before a suffix. A leading unary minus sign (-) is interpreted as a unary operator and is not part of the floating-point constant. There is no limit on the number of digits in any digit-sequence. If the value of the floating-point number is too large (small) to be stored as a single precision value, it is converted to positive (negative) infinity. A value with a magnitude too small to be represented as a mantissa and exponent is converted to zero. Implementations may also convert subnormal (denormalized) numbers to zero. The OpenGL ES Shading Language includes data types for generic 2-, 3-, and 4-component vectors of floating-point values, integers, and Booleans. Floating-point vector variables can be used to store colors, normals, positions, texture coordinates, texture lookup results and the like. Boolean vectors can be used for component-wise comparisons of numeric vectors. Some examples of vector declarations are: Initialization of vectors can be done with constructors. See “Vector and Matrix Constructors”. The OpenGL ES Shading Language has built-in types for 2 × 2, 2 × 3, 2 × 4, 3 × 2, 3 × 3, 3 × 4, 4 × 2, 4 × 3, and 4 × 4 matrices of floating-point numbers. The first number in the type is the number of columns, the second is the number of rows. If there is only one number, the matrix is square. Example matrix declarations: Initialization of matrix values is done with constructors (described in “Vector and Matrix Constructors”) in column-major order. mat2 is an alias for mat2x2, not a distinct type. Similarly for mat3 and mat4. The following is legal: An opaque type is a type where the internal structure of the type is hidden from the language. The opaque types, as listed in the following sections, declare variables that are effectively opaque handles to other objects. These objects are accessed through built-in functions, not through direct reading or writing of the declared variable. They can only be declared as function parameters or in uniform-qualified variables (see “Uniform Variables”). The only opaque types that take memory qualifiers are the image types. Except for array indexing, structure member selection, and parentheses, opaque variables are not allowed to be operands in expressions; such use results in a compile-time error. When aggregated into arrays within a shader, opaque types can only be indexed with a dynamically uniform integral expression (see “Dynamically Uniform Expressions”) unless otherwise noted; otherwise, results are undefined. Opaque variables cannot be treated as l-values; hence cannot be used as out or inout function parameters, nor can they be assigned into. Any such use results in a compile-time error. However, they can be passed as in parameters with matching types and memory qualifiers. They cannot be declared with an initializer. Because a single opaque type declaration effectively declares two objects, the opaque handle itself and the object it is a handle to, there is room for both a storage qualifier and a memory qualifier. The storage qualifier will qualify the opaque handle, while the memory qualifier will qualify the object it is a handle to. Texture-combined sampler types (e.g. sampler2D) are the sampler types described in the Basic Types tables as handles for accessing textures. (They do not include sampler and samplerShadow.) There are distinct texture-combined sampler types for each texture target, and for each of float, integer, and unsigned integer data types. Texture accesses are done through built-in texture functions (described in “Texture Functions”) and texture-combined samplers are used to specify which texture to access and how it is to be filtered. Texture-combined sampler types are opaque types, declared and behaving as described above for opaque types. Image types are opaque types, declared and behaving as described above for opaque types. They can be further qualified with memory qualifiers. When aggregated into arrays within a shader, images can only be indexed with a constant integral expression. Image variables are handles to two-, or three-dimensional images corresponding to all or a portion of a single level of a texture image bound to an image unit. There are distinct image variable types for each texture target, and for each of float, integer, and unsigned integer data types. Image accesses should use an image type that matches the target of the texture whose level is bound to the image unit, or for non-layered bindings of 3D or array images should use the image type that matches the dimensionality of the layer of the image (i.e., a layer of 3D, 2DArray, Cube, or CubeArray should use image2D). If the image target type does not match the bound image in this manner, if the data type does not match the bound image, or if the format layout qualifier does not match the image unit format as described in section 8.22 “Texture Image Loads and Stores” of the OpenGL ES Specification, the results of image accesses are undefined but cannot include program termination. Image variables are used in the image load, store, and atomic functions described in “Image Functions” to specify an image to access. Atomic counter types (e.g. atomic_uint) are opaque handles to counters, declared and behaving as described above for opaque types. The variables they declare specify which counter to access when using the built-in atomic counter functions as described in “Atomic Counter Functions”. They are bound to buffers as described in “Atomic Counter Layout Qualifiers”. Atomic counters aggregated into arrays within a shader can only be indexed with dynamically uniform integral expressions, otherwise results are undefined. Members of structures cannot be declared as atomic counter types. The default precision of all atomic types is highp. It is an error to declare an atomic type with a different precision or to specify the default precision for an atomic type to be lowp or mediump. Atomic counter types are not available when targeting Vulkan. Texture (e.g., texture2D), sampler, and samplerShadow types are opaque types, declared and behaving as described above for opaque types. These types are only available when targeting Vulkan. When aggregated into arrays within a shader, these types can only be indexed with a dynamically uniform expression, or texture lookup will result in undefined values. Texture variables are handles to one-, two-, and three-dimensional textures, cube maps, etc., as enumerated in the basic types tables. There are distinct texture types for each texture target, and for each of float, integer, and unsigned integer data types. Textures can be combined with a variable of type sampler or samplerShadow to create a texture-combined sampler type (e.g., sampler2D, or sampler2DShadow). This is done with a constructor, e.g., , , , or and is described in more detail in section 5.4 \"Constructors\". Subpass-input types are only available when targeting Vulkan. Subpass-input types (e.g., subpassInput) are opaque types, declared and behaving as described above for opaque types. When aggregated into arrays within a shader, they can only be indexed with a dynamically uniform integral expression, otherwise results are undefined. Subpass-input types are handles to two-dimensional single sampled or multi-sampled images, with distinct types for each of float, integer, and unsigned integer data types. Subpass-input types are only available in fragment shaders. It is an error to use them in any other stage. User-defined types can be created by aggregating other already defined types into a structure using the struct keyword. For example, In this example, light becomes the name of the new type, and lightVar becomes a variable of type light. To declare variables of the new type, use its name (without the keyword struct). More formally, structures are declared as follows. However, the definitive grammar is as given in “Shading Language Grammar”. where name becomes the user-defined type, and can be used to declare variables to be of this new type. The name shares the same name space as other variables, types, and functions. All previously visible variables, types, constructors, or functions with that name are hidden. The optional qualifier only applies to any declarators, and is not part of the type being defined for name. Structures must have at least one member declaration. Bit fields are not supported. Member types must be already defined (there are no forward references). Member declarations may contain precision qualifiers, but use of any other qualifier results in an error. Where a member declaration does not include a precision qualifier the member’s precision is inferred as described in Default Precision Qualifiers at the point of the struct type’s declaration. A compile-time error results if a member declaration contains an initializer. Member declarators can contain arrays. Such arrays must have a size specified, and the size must be a constant integral expression that’s greater than zero (see “Constant Expressions”). Each level of structure has its own name space for names given in member declarators; such names need only be unique within that name space. Anonymous structures are not supported. Embedded structure definitions are not supported. Structures can be initialized at declaration time using constructors, as discussed in “Structure Constructors”. Any restrictions on the usage of a type or qualifier also apply to any structure that contains a member of that type or qualifier. This also applies to structure members that are structures, recursively. Structures can contain variables of any type except:\n• atomic_uint (since there is no mechanism to specify the binding)\n• image types (since there is no mechanism to specify the format qualifier) Variables of the same type can be aggregated into arrays by declaring a name followed by brackets ([ ]) enclosing an optional size. When present, the array size must be a constant integral expression (see “Constant Expressions”) greater than zero. The type of the size parameter can be a signed or unsigned integer and the choice of type does not affect the type of the resulting array. Arrays only have a single dimension (a single number within “[ ]”), however, arrays of arrays can be declared. Any type can be formed into an array. Arrays are sized either at compile-time or at run-time. To size an array at compile-time, either the size must be specified within the brackets as above or must be inferred from the type of the initializer. If an array is declared as the last member of a shader storage block and the size is not specified at compile-time, it is sized at run-time. In all other cases, arrays are sized only at compile-time. An array declaration sized at compile-time which leaves the size of the array unspecified is an error. For compile-time sized arrays, it is illegal to index an array with a constant integral expression greater than or equal to the declared size or with a negative constant expression. Arrays declared as formal parameters in a function declaration must also specify a size. Undefined behavior results from indexing an array with a non-constant expression that’s greater than or equal to the array’s size or less than 0. If robust buffer access is enabled (see section 10.3.5 “Robust Buffer Access” of the OpenGL ES Specification), such indexing must not result in abnormal program termination. The results are still undefined, but implementations are encouraged to produce zero values for such accesses. When the length() method will return a compile-time constant, the expression in brackets (x above) will be evaluated and subject to the rules required for array indices, but the array will not be dereferenced. Thus, behavior is well defined even if the run-time value of the expression is out of bounds. An array type can be formed by specifying a non-array type ([type_specifier_nonarray]) followed by an [array_specifier]. Note that the construct type [size] does not always result in an array of length size of type type: This type can be used anywhere any other type can be used, including as the return value from a function as a constructor of an array: and as an alternate way of declaring a variable or function parameter: An array type can also be formed without specifying a size if the definition includes an initializer: Note that the initializer itself does not need to be a constant expression but the length of the initializer will be a constant expression. Arrays can have initializers formed from array constructors: An array of arrays can be declared as: which declares a one-dimensional array of size 3 of one-dimensional arrays of size 2 of vec4. The following declarations do the same thing: When in transparent memory (like in a uniform block), the layout is that the inner-most (right-most in declaration) dimensions iterate faster than the outer dimensions. That is, for the above, the order in memory would be: The last member of a shader storage block (see “Buffer Variables”), may be declared without specifying a size. For such arrays, the effective array size is inferred at run-time from the size of the data store backing the shader storage block. Such runtime-sized arrays may be indexed with general integer expressions, but may not be passed as an argument to a function or indexed with a negative constant expression. However, it is a compile-time error to assign to a runtime-sized array. Assignments to individual elements of the array is allowed. Arrays have a fixed number of elements. This can be obtained by using the length() method: The return value is a signed integral expression. For compile-time sized arrays, the value returned by the length method is a constant expression. For run-time sized arrays , the value returned will not be constant expression and will be determined at run time based on the size of the buffer object providing storage for the block. The precision is determined using the same rules as for other cases where there is no intrinsic precision. See “Precision Qualifiers”. Any restrictions on the usage of a type also apply to arrays of that type. This applies recursively. The scope of a declaration determines where the declaration is visible. GLSL ES uses a system of statically nested scopes. This allows names to be redefined within a shader. The term scope refers to a specified region of the program where names are guaranteed to be visible. For example, a compound_statement_with_scope ('{' statement statement …​ '}') defines a scope. A nested scope is a scope defined within an outer scope. The terms 'same scope' and 'current scope' are equivalent to the term 'scope' but used to emphasize that nested scopes are excluded. The scope of a declaration is the region or regions of the program where that declaration is visible. A name space defines where names may be defined. Within a single name space, a name has at most one entry, specifying it to be one of: structure, variable, or function. In general, each scope has an associated name space. However, in certain cases e.g. for uniforms, multiple scopes share the same name space. In these cases, conflicting declarations are an error, even though the name is only visible in the scopes where it is declared. The scope of a variable is determined by where it is declared. If it is declared outside all function definitions, it has global scope, which starts from where it is declared and persists to the end of the shader it is declared in. If it is declared in a while test or a for statement, then it is scoped to the end of the following sub-statement (specified as statement-no-new-scope in the grammar). Otherwise, if it is declared as a statement within a compound statement, it is scoped to the end of that compound statement. If it is declared as a parameter in a function definition, it is scoped until the end of that function definition. A function’s parameter declarations and body together form a single scope. For both for and while loops, the sub-statement itself does not introduce a new scope for variable names, so the following has a redeclaration compile-time error: The body of a do-while loop introduces a new scope lasting only between the do and while (not including the while test expression), whether or not the body is simple or compound: Representing the if construct as: if if-expression then if-statement else else-statement, a variable declared in the if-statement is scoped to the end of the if-statement. A variable declared in the else-statement is scoped to the end of the else-statement. This applies both when these statements are simple statements and when they are compound statements. The if-expression does not allow new variables to be declared, hence does not form a new scope. Within a declaration, the scope of a name starts immediately after the initializer if present or immediately after the name being declared if not. Several examples: A structure name declaration is visible at the end of the struct_specifier in which it was declared: All variable names, structure type names, and function names in a given scope share the same name space. Function names can be redeclared in the same scope, with the same or different parameters, without error. Otherwise, within a shader, a declared name cannot be redeclared in the same scope; doing so results in a redeclaration error. If a nested scope redeclares a name used in an outer scope, it hides all existing uses of that name. There is no way to access the hidden name or make it unhidden, without exiting the scope that hid it. Names of built-in functions cannot be redeclared as functions. Therefore overloading or redefining built-in functions is an error. A declaration is considered to be a statement that adds a name or signature to the symbol table. A definition is a statement that fully defines that name or signature. E.g. The determination of equivalence of two declarations depends on the type of declaration. For functions, the whole function signature must be considered (see “Function Definitions”). For variables (including arrays) and structures only the names must match. Within each scope, a name may be declared either as a variable declaration or as function declarations or as a structure. Examples of combinations that are allowed: Examples of combinations that are disallowed: The built-in functions are scoped in the global scope users declare global variables in. That is, a shader’s global scope, available for user-defined functions and global variables, is the same as the scope containing the built-in functions. Function declarations (prototypes) cannot occur inside of functions; they must be at global scope. Hence it is not possible to hide a name with a function. Shared globals are variables that can be accessed by multiple compilation units. In GLSL ES the only shared globals are uniforms. Vertex shader outputs are not considered to be shared globals since they must pass through the rasterization stage before they are used as input by the fragment shader. Shared globals share the same name space, and must be declared with the same type and precision. They will share the same storage. Shared global arrays must have the same base type and the same explicit size. Scalars must have exactly the same precision, type name and type definition. Structures must have the same name, sequence of type names, and type definitions, and member names to be considered the same type. This rule applies recursively for nested or embedded types. Variable declarations may have at most one storage qualifier specified in front of the type. These are summarized as local read/write memory, or an input parameter to a function linkage into a shader from a previous stage, variable is copied in linkage out of a shader to a subsequent stage, variable is copied out value does not change across the primitive being processed, uniforms form the linkage between a shader, API, and the application value is stored in a buffer object, and can be read or written both by shader invocations and the API compute shader only; variable storage is shared across all work items in a workgroup Some input and output qualified variables can be qualified with at most one additional auxiliary storage qualifier: Local variables can only use the const storage qualifier (or use no storage qualifier). Note that function parameters can use const, in, and out qualifiers, but as parameter qualifiers. Parameter qualifiers are discussed in “Function Calling Conventions”. Function return types and structure members do not use storage qualifiers. Data types for communication from one run of a shader executable to its next run (to communicate between fragments or between vertices) do not exist. This would prevent parallel execution of the same shader executable on multiple vertices or fragments. In declarations of global variables with no storage qualifier or with a const qualifier, any initializer must be a constant expression. Declarations of global variables with other storage qualifiers may not contain initializers. Global variables without storage qualifiers that are not initialized in their declaration or by the application will not be initialized, but rather will enter main() with undefined values. If no qualifier is present on a global variable, then the variable has no linkage to the application or shaders running on other pipeline stages. For either global or local unqualified variables, the declaration will appear to allocate memory associated with the processor it targets. This variable will provide read/write access to this allocated memory. Named compile-time constants can be declared using the const qualifier. Any variables qualified as constant are read-only variables for that shader. Declaring variables as constant allows more descriptive shaders than using hard-wired numerical constants. The const qualifier can be used with any of the non-void transparent basic data types, as well as with structures and arrays of these. It is an error to write to a const variable outside of its declaration, so they must be initialized when declared. For example, Structure members may not be qualified with const. Structure variables can be declared as const, and initialized with a structure constructor. Initializers for const declarations must be constant expressions, as defined in “Constant Expressions”. SPIR-V specialization constants are expressed in GLSL ES as const with the layout qualifier constant_id, as described in “Specialization-Constant Qualifier.” A constant expression is one of\n• A variable declared with the const qualifier and an initializer, where the initializer is a constant expression. This includes both const declared with a specialization-constant layout qualifier, e.g. layout(constant_id = …​), and those declared without a specialization-constant layout qualifier.\n• An expression formed by an operator on operands that are all constant expressions, including getting an element of a constant array, or a member of a constant structure, or components of a constant vector. However, the lowest precedence operators of the sequence operator (,) and the assignment operators (=, +=, …​) are not included in the operators that can create a constant expression. Also, an array access with a specialization constant as an index does not result in a constant expression.\n• The length() method on a compile-time sized array, whether or not the object itself is constant.\n• A constructor whose arguments are all constant expressions.\n• For non-specialization constants only: A built-in function call whose arguments are all constant expressions, with the exception of the texture lookup functions. This rule excludes functions with a void return or functions that have an out parameter. The built-in functions dFdx, dFdy, and fwidth must return 0 when evaluated inside an initializer with an argument that is a constant expression. Function calls to user-defined functions (non-built-in functions) cannot be used to form constant expressions. Scalar, vector, matrix, array and structure variables are constant expressions if qualified as const. Opaque types cannot be constant expressions. A constant integral expression is a constant expression that evaluates to a scalar signed or unsigned integer. Constant expressions will be evaluated in an invariant way so as to create the same value in multiple shaders when the same constant expressions appear in those shaders. See “The Invariant Qualifier” for more details on how to create invariant expressions and “Precision Qualifiers” for detail on how expressions are evaluated. Constant expressions respect the precise and invariant qualifiers but will be always be evaluated in an invariant way, independent of the use of such qualification, so as to create the same value in multiple shaders when the same constant expressions appear in those shaders. See “The Invariant Qualifier” and “The Precise Qualifier” for more details on how to create invariant expressions. Constant-expressions may be evaluated by a host platform, and are therefore not required to compute the same value that the same expression would evaluate to on the shader execution target. However, the host must use the same or greater precision than the target would use. When the precision qualification cannot be determined, the expression is evaluated at highp. See “Default Precision Qualifiers”. Specialization-constant expressions are never evaluated by the compiler front end, but instead retain the expression’s operations needed to evaluate them later on the host. Shader input variables are declared with the in storage qualifier. They form the input interface between previous stages of the API pipeline and the declaring shader. Input variables must be declared at global scope. Values from the previous pipeline stage are copied into input variables at the beginning of shader execution. It is an error to write to a variable declared as an input. Only the input variables that are actually read need to be written by the previous stage; it is allowed to have superfluous declarations of input variables. See “Built-In Variables” for a list of the built-in input names. Vertex shader input variables (or attributes) receive per-vertex data. It is an error to use auxiliary storage or interpolation qualifiers on a vertex shader input. The values copied in are established by the API or through the use of the layout identifier location. It is a compile-time error to declare a vertex shader input with, or that contains, any of the following types: It is expected that graphics hardware will have a small number of fixed vector locations for passing vertex inputs. Therefore, the OpenGL ES Shading Language defines each non-matrix input variable as taking up one such vector location. There is an implementation-dependent limit on the number of locations that can be used, and if this is exceeded it will cause a link-time error. (Declared input variables that are not statically used do not count against this limit.) A scalar input counts the same amount against this limit as a vec4, so applications may want to consider packing groups of four unrelated float inputs together into a vector to better utilize the capabilities of the underlying hardware. A matrix input will use up multiple locations. The number of locations used will equal the number of columns in the matrix. Tessellation control, evaluation, and geometry shader input variables get the per-vertex values written out by output variables of the same names in the previous active shader stage. For these inputs, centroid and interpolation qualifiers are allowed, but have no effect. Since tessellation control, tessellation evaluation, and geometry shaders operate on a set of vertices, each input variable (or input block, see Interface Blocks below) needs to be declared as an array. For example, Each element of such an array corresponds to one vertex of the primitive being processed. Each array can optionally have a size declared. For geometry shaders, the array size will be set by, (or if provided must be consistent with) the input layout declaration(s) establishing the type of input primitive, as described later in “Input Layout Qualifiers”. Some inputs and outputs are arrayed, meaning that for an interface between two shader stages either the input or output declaration requires an extra level of array indexing for the declarations to match. For example, with the interface between a vertex shader and a geometry shader, vertex shader output variables and geometry shader input variables of the same name must have matching types, except that the geometry shader will have one more array dimension than the vertex shader, to allow for vertex indexing. If such an arrayed interface variable is not declared with the necessary additional input or output array dimension, a link-time error will result. Geometry shader inputs, tessellation control shader inputs and outputs, and tessellation evaluation inputs all have an additional level of arrayness relative to other shader inputs and outputs. These inputs and outputs are known as per-vertex-arrayed inputs and outputs. Component limits for arrayed interfaces (e.g. gl_MaxTessControlInputComponents) are limits per vertex, not limits for the entire interface. For non-arrayed interfaces (meaning array dimensionally stays the same between stages), it is a link-time error if the input variable is not declared with the same type, including array dimensionality, as the matching output variable. The link-time type-matching rules apply to all declared input and output variables, whether or not they are used. Additionally, tessellation evaluation shaders support per-patch input variables declared with the patch and in qualifiers. Per-patch input variables are filled with the values of per-patch output variables written by the tessellation control shader. Per-patch inputs may be declared as one-dimensional arrays, but are not indexed by vertex number. Applying the patch qualifier to inputs can only be done in tessellation evaluation shaders. As with other input variables, per-patch inputs must be declared using the same type and qualification as per-patch outputs from the previous (tessellation control) shader stage. It is a compile-time error to use patch with inputs in any other stage. It is a compile-time error to declare a tessellation control, tessellation evaluation or geometry shader input with, or that contains, any of the following types: It is a compile-time error to declare a fragment shader input with, or that contains, any of the following types: Fragment shader inputs that are, or contain, integral types must be qualified with the interpolation qualifier flat. Fragment inputs are declared as in the following examples: in vec3 normal; centroid in vec2 TexCoord; flat in vec3 myColor; The fragment shader inputs form an interface with the last active shader in the vertex processing pipeline. For this interface, the last active shader stage output variables and fragment shader input variables of the same name must match in type and qualification, with a few exceptions: The storage qualifiers must, of course, differ (one is in and one is out). Also, auxiliary qualification (e.g. centroid) may differ. When auxiliary qualifiers do not match, those provided in the fragment shader supersede those provided in previous stages. If any such qualifiers are completely missing in the fragment shaders, then the default is used, rather than any qualifiers that may have been declared in previous stages. That is, what matters is what is declared in the fragment shaders, not what is declared in shaders in previous stages. When an interface between shader stages is formed using shaders from two separate program objects, it is not possible to detect mismatches between inputs and outputs when the programs are linked. When there are mismatches between inputs and outputs on such interfaces, attempting to use the two programs in the same program pipeline will result in program pipeline validation failures, as described in section 7.4.1 “Shader Interface Matching” of the OpenGL ES Specification. Shaders can ensure matches across such interfaces either by using input and output layout qualifiers (sections “Input Layout Qualifiers” and “Output Layout Qualifiers”) or by using identical input and output declarations of blocks or variables. Complete rules for interface matching are found in section 7.4.1 “Shader Interface Matching” of the OpenGL ES Specification. Compute shaders do not permit user-defined input variables and do not form a formal interface with any other shader stage. See “Compute Shader Special Variables” for a description of built-in compute shader input variables. All other input to a compute shader is retrieved explicitly through image loads, texture fetches, loads from uniforms or uniform buffers, or other user supplied code. The uniform qualifier is used to declare global variables whose values are the same across the entire primitive being processed. All uniform variables are read-only. Except for variables declared within a uniform block, all uniform variables are initialized to 0 at link time and may be updated through the API. When targeting Vulkan, it is an error to declare uniform variables outside a block. The uniform qualifier can be used with any of the basic data types, or when declaring a variable whose type is a structure, or an array of any of these. There is an implementation-dependent limit on the amount of storage for uniforms that can be used for each type of shader and if this is exceeded it will cause a compile-time or link-time error. Uniform variables that are declared but not statically used do not count against this limit. The number of user-defined uniform variables and the number of built-in uniform variables that are used within a shader are added together to determine whether available uniform storage has been exceeded. Uniforms in shaders all share a single global name space when linked into a program or separable program. Hence, the types, precisions, and any location specifiers of all statically used uniform variables with the same name must match across all shaders that are linked into a single program. However it is not required to repeat the location specifier in all the linked shaders. While this single uniform name space is cross stage, a uniform variable name’s scope is per stage: If a uniform variable name is declared in one stage (e.g. a vertex shader) but not in another (e.g. a fragment shader), then that name is still available in the other stage for a different use. A compile or link-time error is generated if any of the explicitly given or compiler generated uniform locations is greater than the implementation-defined maximum number of uniform locations minus one. Unlike locations for inputs and outputs, uniform locations are logical values, not register locations, and there is no concept of overlap. For example: Shader output variables are declared with the out storage qualifier. They form the output interface between the declaring shader and the subsequent stages of the API pipeline. Output variables must be declared at global scope. During shader execution they will behave as normal unqualified global variables. Their values are copied out to the subsequent pipeline stage on shader exit. Only output variables that are read by the subsequent pipeline stage need to be written; it is allowed to have superfluous declarations of output variables. There is not an inout storage qualifier for declaring a single variable name as both input and output to a shader. Also, a variable cannot be declared with both the in and the out qualifiers, this will result in a compile-time or link-time error. Output variables must be declared with different names than input variables. However, nesting an input or output inside an interface block with an instance name allows the same names with one referenced through a block instance name. Vertex, tessellation evaluation, and geometry output variables output per-vertex data and are declared using the out storage qualifier. Applying patch to an output can only be done in a tessellation control shader. It is a compile-time error to use patch on outputs in any other stage. It is a compile-time error to declare a vertex, tessellation evaluation, tessellation control, or geometry shader output with, or that contains, any of the following types:\n• For per-vertex-arrayed variables (applies to tessellation control, tessellation evaluation and geometry shaders): Vertex shader outputs may be qualified with the interpolation qualifier flat1. Unlike previous versions of the OpenGL ES Shading Language, there is no requirement for outputs containing integers to be qualified as flat, since the vertex shader may interface with the tessellation control shader. However, in all cases, the qualifier must match across interfaces. Individual outputs are declared as in the following examples: out vec3 normal; centroid out vec2 TexCoord; invariant centroid out vec4 Color; flat out vec3 myColor; sample out vec4 perSampleColor; These can also appear in interface blocks, as described in “Interface Blocks”. Interface blocks allow simpler addition of arrays to the interface from vertex to geometry shader. They also allow a fragment shader to have the same input interface as a geometry shader for a given vertex shader. Tessellation control shader output variables are used to output per-vertex and per-patch data. Per-vertex output variables are arrayed (see arrayed under “Input Variables”) and declared using the out qualifier without the patch qualifier. Per-patch output variables are declared using the patch and out qualifiers. Since tessellation control shaders produce an arrayed primitive comprising multiple vertices, each per-vertex output variable (or output block, see Interface Blocks below) needs to be declared as an array. For example, Each element of such an array corresponds to one vertex of the primitive being produced. Each array can optionally have a size declared. The array size will be set by (or if provided must be consistent with) the output layout declaration(s) establishing the number of vertices in the output patch, as described later in “Tessellation Control Outputs”. Each tessellation control shader invocation has a corresponding output patch vertex, and may assign values to per-vertex outputs only if they belong to that corresponding vertex. If a per-vertex output variable is used as an l-value, it is a compile-time or link-time error if the expression indicating the vertex index is not the identifier gl_InvocationID. The order of execution of a tessellation control shader invocation relative to the other invocations for the same input patch is undefined unless the built-in function barrier() is used. This provides some control over relative execution order. When a shader invocation calls barrier(), its execution pauses until all other invocations have reached the same point of execution. Output variable assignments performed by any invocation executed prior to calling barrier() will be visible to any other invocation after the call to barrier() returns. Because tessellation control shader invocations execute in undefined order between barriers, the values of per-vertex or per-patch output variables will sometimes be undefined. Consider the beginning and end of shader execution and each call to barrier() as synchronization points. The value of an output variable will be undefined in any of the three following cases:\n• At the beginning of execution.\n• At each synchronization point, unless\n• the value was well-defined after the previous synchronization point and was not written by any invocation since, or\n• the value was written by exactly one shader invocation since the previous synchronization point, or\n• the value was written by multiple shader invocations since the previous synchronization point, and the last write performed by all such invocations wrote the same value.\n• When read by a shader invocation, if\n• the value was undefined at the previous synchronization point and has not been written by the same shader invocation since, or\n• the output variable is written to by any other shader invocation between the previous and next synchronization points, even if that assignment occurs in code following the read. Fragment outputs output per-fragment data and are declared using the out storage qualifier. It is an error to use auxiliary storage qualifiers or interpolation qualifiers in a fragment shader output declaration. It is a compile-time error to declare a fragment shader output with, or that contains, any of the following types: Fragment shader outputs declared as arrays may only be indexed by a constant integral expression. Fragment outputs are declared as in the following examples: Compute shaders have no built-in output variables, do not support user-defined output variables and do not form a formal interface with any other shader stage. All outputs from a compute shader take the form of the side effects such as image stores and operations on atomic counters. The buffer qualifier is used to declare global variables whose values are stored in the data store of a buffer object bound through the API. Buffer variables can be read and written, with the underlying storage shared among all active shader invocations. Buffer variable memory reads and writes within a single shader invocation are processed in order. However, the order of reads and writes performed in one invocation relative to those performed by another invocation is largely undefined. Buffer variables may be qualified with memory qualifiers affecting how the underlying memory is accessed, as described in “Memory Qualifiers”. The buffer qualifier can be used to declare interface blocks (see “Interface Blocks”), which are then referred to as shader storage blocks. It is a compile-time error to declare buffer variables outside a block. There are implementation-dependent limits on the number of shader storage blocks used for each type of shader, the combined number of shader storage blocks used for a program, and the amount of storage required by each individual shader storage block. If any of these limits are exceeded, it will cause a compile-time or link-time error. If multiple shaders are linked together, then they will share a single global buffer variable name space. Hence, the types of all declared buffer variables with the same name must match across all shaders that are linked into a single program. Precision qualifiers for such variables need not match. The shared qualifier is used to declare global variables that have storage shared between all work items in a compute shader workgroup. Variables declared as shared may only be used in compute shaders (see “Compute Processor”). Any other declaration of a shared variable is an error. Shared variables are implicitly coherent (see “Memory Qualifiers”). Variables declared as shared may not have initializers and their contents are undefined at the beginning of shader execution. Any data written to shared variables will be visible to other work items (executing the same shader) within the same workgroup. In the absence of synchronization, the order of reads and writes to the same shared variable by different invocations of a shader is not defined. In order to achieve ordering with respect to reads and writes to shared variables, control flow barriers must be employed using the barrier() function (see “Shader Invocation Control Functions”). There is a limit to the total size of all variables declared as shared in a single program. This limit, expressed in units of basic machine units may be determined by using the OpenGL ES API to query the value of MAX_COMPUTE_SHARED_MEMORY_SIZE. Input, output, uniform, and buffer variable declarations can be grouped into named interface blocks to provide coarser granularity backing than is achievable with individual declarations. They can have an optional instance name, used in the shader to reference their members. An output block of one programmable stage is backed by a corresponding input block in the subsequent programmable stage. A uniform block is backed by the application with a buffer object. A buffer block, also known as a shader storage block, is also backed by the application with a buffer object. It is a compile-time error to have an input block in a vertex shader or an output block in a fragment shader. These uses are reserved for future use. An interface block declaration is defined in the grammar as follows: Each of the above elements is discussed below. The above establishes a uniform block named “Transform” with four uniforms grouped inside it. type-qualifier determines the interface of which the block will be a part and, optionally, additional qualifiers that are applied to the block. It is a compile-time error if it does not include one of the storage qualifiers in, out, uniform or buffer. It may optionally include layout qualifiers, the auxiliary storage qualifier patch, and the precise qualifier. buffer blocks may additionally include [memory qualifiers]. It is a compile-time error to include any other qualifiers. member-list declares the variables that are to be grouped into the block. Types and declarators are the same as for other input, output, uniform, and buffer variable declarations outside blocks, with these exceptions:\n• Arrays of arrays of blocks are not allowed, except for the cases in the tessellation and geometry stages where the declaration is a per-vertex-array of arrays of blocks. If no optional qualifier is used in a member-declaration, the qualification of the member includes all in, out, patch, uniform, or buffer as determined by interface-qualifier. If optional qualifiers are used, they can include interpolation qualifiers, auxiliary storage qualifiers, precision qualifiers, and storage qualifiers and they must declare an input, output, or uniform member consistent with the interface qualifier of the block: Input variables, output variables, uniform variables, and buffer members can only be in in blocks, out blocks, uniform blocks, and shader storage blocks, respectively. Repeating the in, out, patch, uniform, or buffer interface qualifier for a member’s storage qualifier is optional. For example, Members of uniform or buffer storage blocks are always represented in memory as highp, regardless of any precision qualifier associated with the declaration. When values are read from or written to such variables they are converted to or from the declared precision as described in Conversion Between Precisions. Operations on the values within the shader will take place using the declared precision as normal. A shader interface is defined to be one of these:\n• All the uniform variables and uniform blocks declared in a program. This spans all compilation units linked together within one program.\n• All the buffer blocks declared in a program.\n• The boundary between adjacent programmable pipeline stages: This spans all the outputs declared in all compilation units of the first stage and all the inputs declared in all compilation units of the second stage. Note that for the purposes of this definition, the fragment shader and the preceding shader are considered to have a shared boundary even though in practice, all values passed to the fragment shader first pass through the rasterizer and interpolator. The block name (block-name) is used to match within shader interfaces: an output block of one pipeline stage will be matched to an input block with the same name in the subsequent pipeline stage. For uniform or shader storage blocks, the application uses the block name to identify the block. Block names have no other use within a shader beyond interface matching; it is an error to use a block name at global scope for anything other than as a block name (e.g. use of a block name for a global variable name or function name is currently reserved). It is a compile-time error to use the same block name for more than one block declaration in the same shader interface (as defined above) within one shader, even if the block contents are identical. Matched block names within a shader interface (as defined above) must match in terms of having the same number of declarations with the same sequence of types and the same sequence of member names, as well as having matching member-wise layout qualification as defined in “Matching of Qualifiers”. Matched uniform or shader storage block names (but not input or output block names) must also either all be lacking an instance name or all having an instance name, putting their members at the same scoping level. When instance names are present on matched block names, it is allowed for the instance names to differ; they need not match for the blocks to match. Furthermore, if a matching block is declared as an array, then the array sizes must also match (or follow array matching rules for the shader interface between consecutive shader stages). Any mismatch will generate a link-time error. A block name is allowed to have different definitions in different shader interfaces within the same shader, allowing, for example, an input block and output block to have the same name. If an instance name (instance-name) is not used, the names declared inside the block are scoped at the global level and accessed as if they were declared outside the block. If an instance name (instance-name) is used, then it puts all the members inside a scope within its own name space, accessed with the field selector (.) operator (analogously to structures). For example, Outside the shading language (i.e., in the API), members are similarly identified except the block name is always used in place of the instance name (API accesses are to shader interfaces, not to shaders). If there is no instance name, then the API does not use the block name to access a member, just the member name. Within a shader interface, all declarations of the same global name must be for the same object and must match in type and in whether they declare a variable or member of a block with no instance name. The API also needs this name to uniquely identify an object in the shader interface. It is a link-time error if any particular shader interface contains\n• two different blocks, each having no instance name, and each having a member of the same name, or\n• a variable outside a block, and a block with no instance name, where the variable has the same name as a member in the block. out Vertex { vec4 Position; vec2 Texture; } Coords; out Vertex2 { vec4 Color; Color2; }; out Vertex3 { Intensity; vec4 Color; }; Color2; For blocks declared as arrays, the array index must also be included when accessing members, as in this example For uniform or shader storage blocks declared as an array, each individual array element corresponds to a separate buffer object bind range, backing one instance of the block. As the array size indicates the number of buffer objects needed, uniform and shader storage block array declarations must specify an array size. All indices used to index a shader storage block array must be constant integral expressions. A uniform block array can only be indexed with a dynamically uniform integral expression, otherwise results are undefined. When using OpenGL ES API entry points to identify the name of an individual block in an array of blocks, the name string may include an array index (e.g. Transform[2]). When using OpenGL ES API entry points to refer to offsets or other characteristics of a block member, an array index must not be specified (e.g. Transform.ModelViewMatrix). See section 7.3.1 “Program Interfaces” of the OpenGL ES Specification for details. Tessellation control, tessellation evaluation and geometry shader input blocks must be declared as arrays and follow the array declaration and linking rules for all shader inputs for the respective stages. All other input and output block arrays must specify an array size. There are implementation-dependent limits on the number of uniform blocks and the number of shader storage blocks that can be used per stage. If either limit is exceeded, it will cause a link-time error. Layout qualifiers can appear in several forms of declaration. They can appear as part of an interface block definition or block member, as shown in the grammar in the previous section. They can also appear with just an interface-qualifier to establish layouts of other declarations made with that qualifier: Or, they can appear with an individual variable declared with an interface qualifier: Declarations of layouts can only be made at global scope or block members, and only where indicated in the following subsections; their details are specific to what the interface qualifier is, and are discussed individually. The tokens used for layout-qualifier-name are identifiers, not keywords, however, the shared keyword is allowed as a layout-qualifier-id. Generally, they can be listed in any order. Order-dependent meanings exist only if explicitly called out below. As for other identifiers, they are case sensitive. The set of allowed layout qualifiers depends on the shader, the interface and the variable type as specified in the following sections. For example, a sampler in the default uniform block in a fragment shader can have location and binding layout qualifiers but no others. Invalid use of layout qualifiers is an error. The following table summarizes the use of layout qualifiers. It shows for each one what kinds of declarations it may be applied to. These are all discussed in detail in the following sections. all in / out, except for compute Location qualifiers are not allowed for members of an arrayed block, except for per-vertex-arrays (see “Interface Blocks”). Layout qualifiers specific to a particular shader language are discussed in separate sections below. All shaders except compute shaders allow location layout qualifiers on input variable declarations, input block declarations, and input block member declarations. will establish that the shader input normal is assigned to vector location number 3. For vertex shader inputs, the location specifies the number of the vertex attribute from which input values are taken. For inputs of all other shader types, the location specifies a vector number that can be used to match against outputs from a previous shader stage, even if that shader is in a different program object. The following language describes how many locations are consumed by a given type. However, geometry shader inputs, tessellation control shader inputs and outputs, and tessellation evaluation inputs all have an additional level of arrayness relative to other shader inputs and outputs. This outer array level is removed from the type before considering how many locations the type consumes. If a shader input is any scalar or vector type, it will consume a single location. If the declared input (after potentially removing an outer array level as just described above) is an array of size n and each of the elements takes m locations, it will be assigned m * n consecutive locations starting with the location specified. For example, will establish that the shader input colors is assigned to vector location numbers 6, 7, and 8. If the declared input is an n × m matrix, it will be assigned multiple locations starting with the location specified. The number of locations assigned for each matrix will be the same as for an n-element array of m-component vectors. For example, will establish that shader input transforms is assigned to vector locations 9-16, with transforms[0] being assigned to locations 9-12, and transforms[1] being assigned to locations 13-16. If the declared input is a structure or block, its members will be assigned consecutive locations in their order of declaration, with the first member assigned the location provided in the layout qualifier. For a structure, this process applies to the entire structure. It is a compile-time error to use a location qualifier on a member of a structure. For a block, this process applies to the entire block, or until the first member is reached that has a location layout qualifier. When a block member is declared with a location qualifier, its location comes from that qualifier; the member’s location qualifier overrides the block-level declaration. Subsequent members are again assigned consecutive locations, based on the newest location, until the next member declared with a location qualifier. The values used for locations do not have to be declared in increasing order. If a block has no block-level location layout qualifier, it is required that either all or none of its members have a location layout qualifier, or a compile-time error results. If an input is declared as an array of blocks, excluding per-vertex-arrays as required for tessellation, it is an error to declare a member of the block with a location qualifier. When generating SPIR-V, all in and out qualified user-declared (non built-in) variables and blocks (or all their members) must have a shader-specified location. Otherwise, a compile-time error is generated. The locations consumed by block and structure members are determined by applying the rules above recursively as though the structure member were declared as an input variable of the same type. For example: layout(location = ) in S { vec3 a; mat2 b; vec4 c[ ]; layout(location = ) vec2 A; } s; layout(location = ) in block { vec4 d; vec4 e; layout(location = ) vec4 f; vec4 g; layout(location = ) vec4 h; vec4 i; vec4 j; vec4 k; }; The number of input locations available to a shader is limited. For vertex shaders, the limit is the advertised number of vertex attributes. For all other shaders, the limit is implementation-dependent and must be no less than one fourth of the advertised maximum input component count. A program will fail to link if any attached shader uses a location greater than or equal to the number of supported locations, unless device-dependent optimizations are able to make the program fit within available hardware resources. A program will fail to link if explicit location assignments leave the linker unable to find space for other variables without explicit assignments. For the purposes of determining if a non-vertex input matches an output from a previous shader stage, the location layout qualifier (if any) must match. If a vertex shader input variable with no location assigned in the shader text has a location specified through the OpenGL ES API, the API-assigned location will be used. Otherwise, such variables will be assigned a location by the linker. See section 11.1.1 “Vertex Attributes” of the OpenGL ES Specification for more details. It is an error if more than one input or element of a matrix input is bound to the same location. Additional input layout qualifier identifiers allowed for tessellation evaluation shaders are described below. The primitive-mode is used to specify a tessellation primitive mode to be used by the tessellation primitive generator. If present, the primitive-mode specifies that the tessellation primitive generator should subdivide a triangle into smaller triangles, a quad into triangles, or a quad into a collection of lines, respectively. A second group of layout identifiers, vertex spacing, is used to specify the spacing used by the tessellation primitive generator when subdividing an edge. equal_spacing specifies that edges should be divided into a collection of equal-sized segments; fractional_even_spacing specifies that edges should be divided into an even number of equal-length segments plus two additional shorter “fractional” segments; or fractional_odd_spacing specifies that edges should be divided into an odd number of equal-length segments plus two additional shorter “fractional” segments. A third group of layout identifiers, ordering, specifies whether the tessellation primitive generator produces triangles in clockwise or counter-clockwise order, according to the coordinate system depicted in the OpenGL ES Specification. The identifiers cw and ccw indicate clockwise and counter-clockwise triangles, respectively. If the tessellation primitive generator does not produce triangles, the order is ignored. Finally, point mode indicates that the tessellation primitive generator should produce one point for each distinct vertex in the subdivided primitive, rather than generating lines or triangles. Any or all of these identifiers may be specified one or more times in a single input layout declaration. The tessellation evaluation shader object in a program must declare a primitive mode in its input layout. Declaring vertex spacing, ordering, or point mode identifiers is optional. If spacing or vertex ordering declarations are omitted, the tessellation primitive generator will use equal spacing or counter-clockwise vertex ordering, respectively. If a point mode declaration is omitted, the tessellation primitive generator will produce lines or triangles according to the primitive mode. Additional layout qualifier identifiers for geometry shader inputs include primitive identifiers and an invocation count identifier: The identifiers points, lines, lines_adjacency, triangles, and triangles_adjacency are used to specify the type of input primitive accepted by the geometry shader, and only one of these is accepted. The geometry shader must declare this input primitive layout. The identifier invocations is used to specify the number of times the geometry shader executable is invoked for each input primitive received. Invocation count declarations are optional. If no invocation count is declared in the geometry shader, it will be run once for each input primitive. If an invocation count is declared, all such declarations must specify the same count. If a shader specifies an invocation count greater than the implementation-dependent maximum, or less than or equal to zero, a compile-time error results. will establish that all inputs to the geometry shader are triangles and that the geometry shader executable is run six times for each triangle processed. All geometry shader input unsized array declarations will be sized by an earlier input primitive layout qualifier, when present, as per the following table. The intrinsically declared input array gl_in[] will also be sized by any input primitive-layout declaration. Hence, the expression will return the value from the table above. An input can be declared without an array size if there is a previous layout which specifies the size. For built-in inputs (e.g. gl_in[]), a layout must be declared before any use. It is a compile-time error if a layout declaration’s array size (from the table above) does not match all the explicit array sizes specified in declarations of an input variables in the same shader. The following includes examples of compile-time errors: in vec4 Color2[ ]; in vec4 Color3[ ]; layout(lines) in; in vec4 Color4[ ]; layout(lines) in; layout(triangles) in; It is a link-time error if not all provided sizes (sized input arrays and layout size) match in the geometry shader of a program. Fragment shaders allow the following layout qualifier on in only (not with variable declarations): to request that fragment tests be performed before fragment shader execution, as described in section 13.8.4 “Early Fragment Tests” of the OpenGL ES Specification. Specifying this will make per-fragment tests be performed before fragment shader execution. In addition it is an error to statically write to gl_FragDepth in the fragment shader. If this is not declared, per-fragment tests will be performed after fragment shader execution. There are no layout location qualifiers for compute shader inputs. Layout qualifier identifiers for compute shader inputs are the workgroup size qualifiers: The local_size_x, local_size_y, and local_size_z qualifiers are used to declare a fixed workgroup size by the compute shader in the first, second, and third dimension, respectively. If a shader does not specify a size for one of the dimensions, that dimension will have a size of 1. For example, the following declaration in a compute shader is used to declare a two-dimensional compute shader with a workgroup size of 32 X 32 elements, which is equivalent to a three-dimensional compute shader where the third dimension has size one. As another example, the declaration effectively specifies that a one-dimensional compute shader is being compiled, and its size is 8 elements. If the fixed workgroup size of the shader in any dimension is less than or equal to zero or greater than the maximum size supported by the implementation for that dimension, a compile-time error results. Also, if such a layout qualifier is declared more than once in the same shader, all those declarations must set the same set of workgroup sizes and set them to the same values; otherwise a compile-time error results. Furthermore, if a program object contains a compute shader, that shader must contain an input layout qualifier specifying a fixed workgroup size for the program, or a link-time error will occur. Some output layout qualifiers apply to all shader stages and some apply only to specific stages. The latter are discussed in separate sections below. As with input layout qualifiers, all shaders except compute shaders allow location layout qualifiers on output variable declarations, output block declarations, and output block member declarations. The usage and rules for applying the location qualifier to blocks and structures are exactly as described in “Input Layout Qualifiers”. The qualifier may appear at most once within a declaration. For example, in a fragment shader, will establish that the fragment shader output color is assigned to fragment color 3. For fragment shader outputs, the location specifies the color output number receiving the values of the output. For outputs of all other shader stages, the location specifies a vector number that can be used to match against inputs in a subsequent shader stage, even if that shader is in a different program object. If the declared output is an array, it will be assigned consecutive locations starting with the location specified. For example, will establish that colors is assigned to vector location numbers 2, 3, and 4. If the declared output is an n × m matrix, it will be assigned multiple locations starting with the location specified. The number of locations assigned will be the same as for an n-element array of m-component vectors. If the declared output is a structure, its members will be assigned consecutive locations in the order of declaration, with the first member assigned the location specified for the structure. The number of locations consumed by a structure member is determined by applying the rules above recursively as though the structure member were declared as an output variable of the same type. location layout qualifiers may be used on output variables declared as structures. However, it is a compile-time error to use a location qualifier on a structure member. Location layout qualifiers may be used on output blocks and output block members. If an output is declared as an array of blocks, excluding per-vertex-arrays as required for tessellation, it is an error to declare a member of the block with a location qualifier. The number of output locations available to a shader is limited. For fragment shaders, the limit is the advertised number of draw buffers. For all other shaders, the limit is implementation-dependent and must be no less than one fourth of the advertised maximum output component count (compute shaders have no outputs). A program will fail to link if any attached shader uses a location greater than or equal to the number of supported locations, unless device-dependent optimizations are able to make the program fit within available hardware resources. Compile-time errors may also be given if at compile time it is known the link will fail. A negative output location will result in an error. It is a compile-time or link-time error if any of the following occur:\n• any two fragment shader output variables are assigned to the same location.\n• if any two output variables from the same vertex, tessellation or geometry shader stage are assigned to the same location. For all shader types, a program will fail to link if explicit location assignments leave the linker unable to find space for other variables without explicit assignments. If an output variable has no location assigned in the shader text, it will be assigned a location by the linker. See section 11.1.3 “Shader Execution” of the OpenGL ES Specification for more details. If there is only a single output, the location does not need to be specified, in which case it defaults to zero. This applies for all output types, including arrays. If there is more than one fragment output, the location must be specified for all outputs. For the purposes of determining if a non-fragment output matches an input from a subsequent shader stage, the location layout qualifier (if any) must match. Tessellation control shaders allow output layout qualifiers only on the interface qualifier out, not on an output block, block member, or variable declaration. The output layout qualifier identifiers allowed for tessellation control shaders are: The identifier vertices specifies the number of vertices in the output patch produced by the tessellation control shader, which also specifies the number of times the tessellation control shader is invoked. It is a compile- or link-time error for the output vertex count to be less than or equal to zero, or greater than the implementation-dependent maximum patch size. The intrinsically declared tessellation control output array gl_out[] will also be sized by any output layout declaration. Hence, the expression will return the output patch vertex count specified in a previous output layout qualifier. For outputs declared without an array size, including intrinsically declared outputs (i.e., gl_out), a layout must be declared before any use of the method length() or other array use that requires its size to be known. It is a compile-time error if the output patch vertex count specified in an output layout qualifier does not match the array size specified in any output variable declaration in the same shader. All tessellation control shader layout declarations in a program must specify the same output patch vertex count. There must be at least one layout qualifier specifying an output patch vertex count in any program containing a tessellation control shader. Geometry shaders can have two additional types of output layout identifiers: an output primitive type and a maximum output vertex count. The primitive type and vertex count identifiers are allowed only on the interface qualifier out, not on an output block, block member, or variable declaration. The layout qualifier identifiers for geometry shader outputs are The primitive type identifiers points, line_strip, and triangle_strip are used to specify the type of output primitive produced by the geometry shader, and only one of these is accepted. The geometry shader object in a program must declare an output primitive type, and all geometry shader output primitive type declarations in a program must declare the same primitive type. The vertex count identifier max_vertices is used to specify the maximum number of vertices the shader will ever emit in a single invocation. The geometry shader object in a program must declare a maximum output vertex count, and all geometry shader output vertex count declarations in a program must declare the same count. layout(triangle_strip, max_vertices = ) out; layout(max_vertices = ) out; layout(triangle_strip) out; layout(points) out; layout(max_vertices = ) out; all outputs from the geometry shader are triangles and at most 60 vertices will be emitted by the shader. It is an error for the maximum number of vertices to be greater than gl_MaxGeometryOutputVertices. All geometry shader output layout declarations in a program must declare the same layout and same value for max_vertices. If geometry shaders are in a program, there must be at least one geometry output layout declaration somewhere in that program. Fragment shaders can have an output layout for redeclaring the built-in variable gl_FragDepth: The built-in gl_FragDepth is only predeclared in fragment shaders, so redeclaring it in any other shader language results in an error. Fragment shaders additionally support layout qualifiers specifying a set of advanced blend equations supported when the fragment shader is used. These layout qualifiers are only permitted on the interface qualifier out, and use the identifiers specified in the “Layout Qualifier” column of the table below. If a layout qualifier in the table below is specified in the fragment shader, the fragment shader may be used with the corresponding advanced blend equation in the “Blend Equation(s) Supported” column. Additionally, the special qualifier blend_support_all_equations indicates that the shader may be used with any advanced blending equation supported by the OpenGL ES Specification. It is not an error to specify more than one of these identifiers in any fragment shader. Specifying more than one qualifier or blend_support_all_equations means that the fragment shader may be used with multiple advanced blend equations. Additionally, it is not an error to specify any single one of these layout qualifiers more than once. The following layout qualifier can be used for all default-block uniform variables but not for variables in uniform or shader storage blocks. The layout qualifier identifier for uniform variables is: The location specifies the location by which the API can reference the uniform and update its value. Individual elements of a uniform array are assigned consecutive locations with the first element taking location location. Default-block uniform variable declarations sharing the same location linked in the program have to match by name, type, qualifiers and arrayness. For arrays their array dimensionality and array sizes must match. For structs this rule applies recursively to all members. Valid locations for default-block uniform variable locations are in the range of 0 to the implementation-defined maximum number of uniform locations minus one. Locations can be assigned to default-block uniform arrays and structures. The first inner-most scalar, vector or matrix member or element takes the specified location and the compiler assigns the next inner-most member or element the next incremental location value. Each subsequent inner-most member or element gets incremental locations for the entire structure or array. This rule applies to nested structures and arrays and gives each inner-most scalar, vector, or matrix member a unique location. When the linker generates locations for uniforms without an explicit location, it assumes for all uniforms with an explicit location all their array elements and structure members are used and the linker will not generate a conflicting location, even if that element or member is deemed unused. When targeting Vulkan, the push_constant qualifier is used to declare an entire block, and represents a set of push constants, as defined by the Vulkan API. It is an error to apply this to anything other than a uniform block declaration, or when not targeting Vulkan. The values in the block will be initialized as per the Vulkan API specification. A block declared with may optionally include an instance-name. There can be only one push_constant block per stage, or a compile-time or link-time error will result. A push-constant array can only be indexed with dynamically uniform indices. Uniform blocks declared with push_constant use different resources than those without; and are accounted for separately. Layout qualifiers can be used for uniform and shader storage blocks, but not for non-block uniform declarations. The layout qualifier identifiers (and shared keyword) for uniform and shader storage blocks are: None of these have any semantic effect at all on the usage of the variables being declared; they only describe how data is laid out in memory. For example, matrix semantics are always column-based, as described in the rest of this specification, no matter what layout qualifiers are being used. Uniform and shader storage block layout qualifiers can be declared for global scope, on a single uniform or shader storage block, or on a single block member declaration. Default layouts are established at global scope for uniform blocks as: and for shader storage blocks as: When this is done, the previous default qualification is first inherited and then overridden as per the override rules listed below for each qualifier listed in the declaration. The result becomes the new default qualification scoped to subsequent uniform or shader storage block definitions. The initial state of compilation when generating SPIR-V is as if the following were declared: However, when push_constant is declared, the default layout of the buffer will be std430. There is no method to globally set this default. The initial state of compilation when not generating SPIR-V is as if the following were declared: Uniform and shader storage blocks can be declared with optional layout qualifiers, and so can their individual member declarations. Such block layout qualification is scoped only to the content of the block. As with global layout declarations, block layout qualification first inherits from the current default qualification and then overrides it. Similarly, individual member layout qualification is scoped just to the member declaration, and inherits from and overrides the block’s qualification. The shared qualifier overrides only the std140, std430, and packed qualifiers; other qualifiers are inherited. The compiler/linker will ensure that multiple programs and programmable stages containing this definition will share the same memory layout for this block, as long as they also matched in their row_major and/or column_major qualifications. This allows use of the same buffer to back the same block definition across different programs. It is a compile-time error to use the shared qualifier when generating SPIR-V. The packed qualifier overrides only std140, std430, and shared; other qualifiers are inherited. When packed is used, no shareable layout is guaranteed. The compiler and linker can optimize memory use based on what variables actively get used and on other criteria. Offsets must be queried, as there is no other way of guaranteeing where (and which) variables reside within the block. It is a link-time error to access the same packed uniform or shader storage block in multiple stages within a program. Attempts to access the same packed uniform or shader storage block across programs can result in conflicting member offsets and in undefined values being read. However, implementations may aid application management of packed blocks by using canonical layouts for packed blocks. It is a compile-time error to use the packed qualifier when generating SPIR-V. The std140 and std430 qualifiers override only the packed, shared, std140, and std430 qualifiers; other qualifiers are inherited. The std430 qualifier is supported only for shader storage blocks; a shader using the std430 qualifier on a uniform block will result in an error, unless it is also declared with push_constant. The layout is explicitly determined by this, as described in section 7.6.2.2 “Standard Uniform Block Layout” of the OpenGL ES Specification. Hence, as in shared above, the resulting layout is shareable across programs. Layout qualifiers on member declarations cannot use the shared, packed, std140, or std430 qualifiers. These can only be used at global scope (without an object) or on a block declaration, or an error results. The row_major and column_major qualifiers only affect the layout of matrices, including all matrices contained in structures and arrays they are applied to, to all depths of nesting. These qualifiers can be applied to other types, but will have no effect. The row_major qualifier overrides only the column_major qualifier; other qualifiers are inherited. Elements within a matrix row will be contiguous in memory. The column_major qualifier overrides only the row_major qualifier; other qualifiers are inherited. Elements within a matrix column will be contiguous in memory. The binding qualifier specifies the uniform buffer binding point corresponding to the uniform or shader storage block, which will be used to obtain the values of the member variables of the block. It is a compile-time error to specify the binding qualifier for the global scope or for block member declarations. Any uniform or shader storage block declared without a binding qualifier is initially assigned to block binding point zero. After a program is linked, the binding points used for uniform (but not shader storage) blocks declared with or without a binding qualifier can be updated by the API. When used with OpenGL ES, if the binding qualifier is used with a uniform block or shader storage block instanced as an array, the first element of the array takes the specified block binding and each subsequent element takes the next consecutive binding point. For an array of arrays, each element (e.g. 6 elements for a[2][3]) gets a binding point, and they are ordered per the array of array ordering described in “Arrays.” When targeting Vulkan, if the binding qualifier is used with a uniform block or buffer block instanced as an array, the entire array takes only the provided binding number. The next consecutive binding number is available for a different object. For an array of arrays, descriptor set array element numbers used in descriptor set accesses are ordered per the array-of-array ordering described in “Arrays.” If the binding point for any uniform or shader storage block instance is less than zero, or greater than or equal to the corresponding implementation-dependent maximum number of buffer bindings, a compile-time error will occur. When the binding qualifier is used with a uniform or shader storage block instanced as an array of size N, all elements of the array from binding through binding + N - 1 must be within this range. The set qualifier is only available when targeting Vulkan. It specifies the descriptor set this object belongs to. It is an error to apply set to a standalone qualifier, to a member of a block, or when not targeting an API that supports descriptor sets. It is an error to apply set to a block qualified as push_constant. By default, any non-push-constant uniform or shader storage block declared without a set identifier is assigned to descriptor set 0. Similarly, any sampler, texture, or subpass-input type declared as a uniform without a set identifier is also assigned to descriptor set 0. If applied to an object declared as an array, all elements of the array belong to the specified set. When generating SPIR-V, it is an error for either the set or binding value to exceed a front-end-configuration supplied maximum value. When multiple arguments are listed in a layout declaration, the effect will be the same as if they were declared one at a time, in order from left to right, each in turn inheriting from and overriding the result from the previous qualification. results in the qualification being column_major. Other examples: When targeting Vulkan, the offset and align qualifiers for blocks and block members can only be used with uniform and buffer blocks. When not targeting Vulkan, they cannot be used with blocks or block members. The offset qualifier can only be used on block members. The offset qualifier forces the qualified member to start at or after the specified layout-qualifier-value, which will be its byte offset from the beginning of the buffer. It is a compile-time error to have any offset, explicit or assigned, that lies within another member of the block. Two blocks linked together in the same program with the same block name must have the exact same set of members qualified with offset and their layout-qualifier-value values must be the same, or a link-time error results. The specified offset must be a multiple of the base alignment of the type of the block member it qualifies, or a compile-time error results. The align qualifier makes the start of each block member have a minimum byte alignment. It does not affect the internal layout within each member, which will still follow the std140 or std430 rules. The specified alignment must be greater than 0 and a power of 2, or a compile-time error results. The actual alignment of a member will be the greater of the specified align alignment and the standard (e.g. std140) base alignment for the member’s type. The actual offset of a member is computed as follows: If offset was declared, start with that offset, otherwise start with the offset immediately following the preceding member (in declaration order). If the resulting offset is not a multiple of the actual alignment, increase it to the first offset that is a multiple of the actual alignment. This results in the actual offset the member will have. When align is applied to an array, it affects only the start of the array, not the array’s internal stride. Both an offset and an align qualifier can be specified on a declaration. The align qualifier, when used on a block, has the same effect as qualifying each member with the same align value as declared on the block, and gets the same compile-time results and errors as if this had been done. As described in general earlier, an individual member can specify its own align, which overrides the block-level align, but just for that member. Opaque uniform variables can take the uniform layout qualifier for binding: The binding qualifier specifies the point where the variable will be bound. Any opaque variable declared without a binding qualifier has a default binding of zero. When used with OpenGL ES, if the binding qualifier is used with an array, the first element of the array takes the specified binding point and each subsequent element takes the next consecutive binding point. For an array of arrays, each element (e.g. 6 elements for a[2][3]) gets a binding point, and they are ordered per the array of array ordering described in “Arrays.” When targeting Vulkan, if the binding qualifier is used with an array, the entire array takes only the provided binding number. The next consecutive binding number is available for a different object. If the binding is less than zero, or greater than or equal to the implementation-dependent maximum supported number of binding points, a compile-time error will occur. When the binding qualifier is used with an array of size N, all elements of the array from binding through binding + N - 1 must be within this range. A link-time error will result if two shaders in a program specify different layout-qualifier-value bindings for the same opaque-uniform name. However, it is not an error to specify a binding on some but not all declarations for the same name, as shown in the examples below. Atomic counters are not available when targeting Vulkan. Atomic counter layout qualifiers can be used on atomic counter declarations or at global scope to establish defaults. The atomic counter qualifiers are: Each binding has a default offset that is initially 0 and is updated following each declaration containing the type atomic_uint. If such a declaration does not declare a variable then it establishes a default for the named binding. It is a compile-time error if any such declaration does not include a binding layout qualifier. If a declaration contains an offset qualifier then that offset is used in the declaration, otherwise the default offset for the named binding is used. Each atomic counter that is declared is assigned to the named buffer binding point, at the current offset, and then the offset is increased by 4. Arrays of atomic counters assign one such offset to each member, and if multiple variables are declared in the same statement then they will have offsets assigned in order from left to right. Having assigned offsets to variables, if any, the binding’s default offset will be set to the current offset value. will establish that the opaque handle to the atomic counter a will be bound to atomic counter buffer binding point 2 at an offset of 4 basic machine units into that buffer. The default offset for binding point 2 will be post incremented by 4 (the size of an atomic counter). It is a compile-time error to bind an atomic counter with a binding value greater than or equal to gl_MaxAtomicCounterBindings. It is a compile-time error to declare an atomic counter whose offset is such that the buffer containing it would be larger than gl_MaxAtomicCounterBufferSize. It is a compile-time error to declare an atomic counter whose offset is not aligned to a multiple of 4. It is a compile- or link-time error to declare two atomic counters with the same binding and the same offset. Format layout qualifiers can be used on image variable declarations (those declared with a basic type having “image” in its keyword). The format layout qualifier identifiers for image variable declarations are: A format layout qualifier specifies the image format associated with a declared image variable. Only one format qualifier may be specified for any image variable declaration. For image variables with floating-point component types (keywords starting with “image”), signed integer component types (keywords starting with “iimage”), or unsigned integer component types (keywords starting with “uimage”), the format qualifier used must match the float-image-format-qualifier, int-image-format-qualifier, or uint-image-format-qualifier grammar rules, respectively. It is an error to declare an image variable where the format qualifier does not match the image variable type. Any image variable must specify a format layout qualifier. The binding qualifier was described in “Opaque Uniform Layout Qualifiers”. Subpass inputs are only available when targeting Vulkan. Subpass inputs are declared with the basic subpassInput types. They must be declared with the layout qualifier input_attachment_index, or an error results. For example: This selects which subpass input is being read from. The value assigned to input_attachment_index, say i ( ), selects that entry (i th entry) in the input list for the pass. See the API documentation for more detail about passes and the input list. If an array of size N is declared, it consumes N consecutive input_attachment_index values, starting with the one provided. It is a compile-time or link-time error to have different variables declared with the same input_attachment_index. This includes any overlap in the implicit input_attachment_index consumed by array declarations. It is an error if the value assigned to an input_attachment_index is greater than or equal to gl_MaxInputAttachments. Inputs and outputs that could be interpolated can be further qualified by at most one of the following interpolation qualifiers: The presence of and type of interpolation is controlled by the above interpolation qualifiers as well as the auxiliary storage qualifiers centroid and sample. When no interpolation qualifier is present, smooth interpolation is used. It is a compile-time error to use more than one interpolation qualifier. The auxiliary storage qualifier patch is not used for interpolation; it is a compile-time error to use interpolation qualifiers with patch. A variable qualified as flat will not be interpolated. Instead, it will have the same value for every fragment within a primitive. This value will come from a single provoking vertex, as described by the API. A variable qualified as flat may also be qualified as centroid or sample, which will mean the same thing as qualifying it only as flat. A variable qualified as smooth will be interpolated in a perspective-correct manner over the primitive being rendered. Interpolation in a perspective correct manner is specified in equations 13.4 of the OpenGL ES Specification, section 13.4.1 “Line Segments” and equation 13.7, section 13.5.1 “Polygon Interpolation”. When multisample rasterization is disabled, or for fragment shader input variables qualified with neither centroid nor sample, the value of the assigned variable may be interpolated anywhere within the pixel and a single value may be assigned to each sample within the pixel, to the extent permitted by the OpenGL ES Specification. When multisample rasterization is enabled, centroid and sample may be used to control the location and frequency of the sampling of the qualified fragment shader input. If a fragment shader input is qualified with centroid, a single value may be assigned to that variable for all samples in the pixel, but that value must be interpolated at a location that lies in both the pixel and in the primitive being rendered, including any of the pixel’s samples covered by the primitive. Because the location at which the variable is interpolated may be different in neighboring pixels, and derivatives may be computed by computing differences between neighboring pixels, derivatives of centroid-sampled inputs may be less accurate than those for non-centroid interpolated variables. If a fragment shader input is qualified with sample, a separate value must be assigned to that variable for each covered sample in the pixel, and that value must be sampled at the location of the individual sample. In addition to precision qualifiers and memory qualifiers, parameters can have these parameter qualifiers. for function parameters passed back out of a function, but not initialized for use when passed in for function parameters passed both into and out of a function Parameter qualifiers are discussed in more detail in “Function Calling Conventions”. When targeting Vulkan: For interface matching, uniform variables and uniform and buffer block members must have the same precision qualification. Global variables declared in different compilation units linked into the same shader stage must be declared with the same precision qualification. For the purposes of determining if an output from one shader stage matches an input of the next stage, the precision qualifier need not match. This specification only governs the minimum required precision for storage and operations on values. Implementations are free to calculate and/or store any results at higher precisions. If necessary, this variance can be controlled using the invariance qualifier. The precision of highp floating-point variables is defined by the IEEE 754 standard for 32-bit floating-point numbers. This includes support for NaNs (Not a Number) and Infs (positive or negative infinities) and positive and negative zeros. The following rules apply to highp operations: Signed infinities and zeros are generated as dictated by IEEE, but subject to the precisions allowed in the following table. Any subnormal (denormalized) value input into a shader or potentially generated by any operation in a shader can be flushed to 0. The rounding mode cannot be set and is undefined but must not affect the result by more than 1 ULP. NaNs are not required to be generated. Support for signaling NaNs is not required and exceptions are never raised. Operations including built-in functions that operate on a NaN are not required to return a NaN as the result. However if NaNs are generated, isnan() must return the correct value. Precisions are expressed in terms of maximum relative error in units of ULP (units in the last place), unless otherwise noted. For single precision operations, precisions are required as follows: 2.5 ULP for |b| in the range [2-126, 2126]. Correctly rounded single operation or sequence of two correctly rounded operations. 3 ULP outside the range [0.5,2.0].\n\n Absolute error < 2-21 inside the range [0.5,2.0]. Built-in functions defined in the specification with an equation built from the above operations inherit the above errors. These include, for example, the geometric functions, the common functions, and many of the matrix functions. Built-in functions not listed above and not defined as equations of the above have undefined precision. These include, for example, the trigonometric functions and determinant. Storage requirements are declared through use of precision qualifiers. The precision of operations must preserve the storage precisions of the variables involved. highp floating-point values are stored in IEEE 754 single precision floating-point format. mediump and lowp floating-point values have minimum range and precision requirements as detailed below and have maximum range and precision as defined by IEEE 754. All integral types are assumed to be implemented as integers and so may not be emulated by floating-point values. highp signed integers are represented as twos-complement 32-bit signed integers. highp unsigned integers are represented as unsigned 32-bit integers. mediump integers (signed and unsigned) must be represented as an integer with between 16 and 32 bits inclusive. lowp integers (signed and unsigned) must be represented as an integer with between 9 and 32 bits inclusive. The required ranges and precisions for precision qualifiers are: The semi-open interval notation used for the magnitude ranges means that the lower end of the interval is included, but the upper end is excluded. Thus the largest required magnitude is half of the relative precision less than the value given. The largest required value for highp, for example, is 2128 × (1 - 2-24). Relative precision is defined as the worst case (i.e. largest) ratio of the smallest step in relation to the value for all non-zero values in the required ranges, above: \\[\\begin{aligned} \\mathit{Precision}_{relative} = { \\left| { { \\left| v_1 - v_2 \\right| }_{min} } \\over { v_1 } \\right| }_{max}, & v_1,v_2 \n\neq 0, v_1 \n\neq v_2 \\end{aligned}\\] It is therefore twice the maximum rounding error when converting from a real number. Subnormal numbers may be supported and may have lower relative precision. In addition, the range and precision of a mediump floating-point value must be the same as or greater than the range and precision of a lowp floating-point value. The range and precision of a highp floating-point value must be the same as or greater than the range and precision of a mediump floating-point value. The range of a mediump integer value must be the same as or greater than the range of a lowp integer value. The range of a highp integer value must be the same as or greater than the range of a mediump integer value. The actual ranges and precisions provided by an implementation can be queried through the API. See the normative references for details on how to do this. Within the same type, conversion from a lower to a higher precision must be exact. When converting from a higher precision to a lower precision, if the value is representable by the implementation of the target precision, the conversion must also be exact. If the value is not representable, the behavior is dependent on the type:\n• For signed and unsigned integers, the value is truncated; bits in positions not present in the target precision are set to zero. (Positions start at zero and the least significant bit is considered to be position zero for this purpose.)\n• For floating-point values, the value should either clamp to +Inf or -Inf, or to the maximum or minimum value that the implementation supports. While this behavior is implementation-dependent, it should be consistent for a given implementation. Any floating-point, integer, or opaque-type declaration can have the type preceded by one of these precision qualifiers: The variable satisfies the minimum requirements for highp described above. highp variables have the maximum range and precision available but may cause operations to run more slowly on some implementations. SPIR-V RelaxedPrecision when targeting Vulkan, otherwise the variable satisfies the minimum requirements for mediump described above. mediump variables may typically be used to store high dynamic range colors and low precision geometry. SPIR-V RelaxedPrecision when targeting Vulkan, otherwise the variable satisfies the minimum requirements for lowp described above. lowp variables may typically be used to store 8-bit color values. Literal constants do not have precision qualifiers. Neither do Boolean variables. For this paragraph, “operation” includes operators, built-in functions, and constructors, and “operand” includes function arguments and constructor arguments. The precision qualification associated with any operation is the highest precision qualification of the operands consumed by the operation, if any operand has an associated precision. In cases where no operand has a precision qualifier, the precision qualifications of the operands of the next consuming operation in the expression will be used. This rule can be applied recursively until a precision qualified operand is found. If necessary, it will also include the precision qualification of l-values for assignments, of the declared variable for initializers, of formal parameters for function call arguments, or of function return types for function return values. If the precision cannot be determined by this method e.g. if an entire expression is composed only of operands with no precision qualifier, and the result is not assigned or passed as an argument, then it is evaluated at the default precision of the type or greater. When this occurs in the fragment shader, the default precision must be defined. For example, consider the statements: Precision qualifiers, as with other qualifiers, do not affect the basic type of the variable. In particular, there are no constructors for precision conversions; constructors only convert types. Similarly, precision qualifiers, as with other qualifiers, do not contribute to function overloading based on parameter types. As discussed in “Function Calling Conventions”, function input and output is done through copies, and therefore qualifiers do not have to match. Precision qualifiers for outputs in one shader matched to inputs in another shader need not match when both shaders are linked into the same program. When both shaders are in separate programs, mismatched precision qualifiers will result in a program interface mismatch that will result in program pipeline validation failures, as described in section 7.4.1 “Shader Interface Matching” of the OpenGL ES Specification. The precision of a variable is determined when the variable is declared and cannot be subsequently changed. Where the precision of a constant integral or constant floating-point expression is not specified, evaluation is performed at highp. This rule does not affect the precision qualification of the expression. The evaluation of constant expressions must be invariant and will usually be performed at compile time. can be used to establish a default precision qualifier. The type field can be either int, float, or any of the opaque types, and the precision-qualifier can be lowp, mediump, or highp. Any other types or qualifiers will result in an error. If type is float, the directive applies to non-precision-qualified floating-point type (scalar, vector, and matrix) declarations. If type is int, the directive applies to all non-precision-qualified integer type (scalar, vector, signed, and unsigned) declarations. This includes global variable declarations, function return declarations, function parameter declarations, and local variable declarations. Non-precision qualified declarations will use the precision qualifier specified in the most recent precision statement that is still in scope. The precision statement has the same scoping rules as variable declarations. If it is declared inside a compound statement, its effect stops at the end of the inner-most statement it was declared in. Precision statements in nested scopes override precision statements in outer scopes. Multiple precision statements for the same basic type can appear inside the same scope, with later statements overriding earlier statements within that scope. All languages except for the fragment language have the following predeclared globally scoped default precision statements: The fragment language has the following predeclared globally scoped default precision statements: The fragment language has no default precision qualifier for floating-point types. Hence for float, floating-point vector and matrix variable declarations, either the declaration must include a precision qualifier or the default float precision must have been previously declared. Similarly, there is no default precision qualifier in any of the languages for any type not listed above. The built-in macro GL_FRAGMENT_PRECISION_HIGH is defined to one: This macro is available in all languages except compute. In this section, variance refers to the possibility of getting different values from the same expression in different programs. For example, consider the situation where two vertex shaders, in different programs, each set gl_Position with the same expression, and the input values into that expression are the same when both shaders run. It is possible, due to independent compilation of the two shaders, that the values assigned to gl_Position are not exactly the same when the two shaders run. In this example, this can cause problems with alignment of geometry in a multi-pass algorithm. In general, such variance between shaders is allowed. When such variance does not exist for a particular output variable, that variable is said to be invariant. To ensure that a particular output variable is invariant, it is necessary to use the invariant qualifier. It can either be used to qualify a previously declared variable as being invariant: or as part of a declaration when a variable is declared: Only variables output from a shader can be candidates for invariance. This includes user-defined output variables and the built-in output variables. As only outputs can be declared as invariant, an output from one shader stage will still match an input of a subsequent stage without the input being declared as invariant. The invariant keyword can be followed by a comma separated list of previously declared identifiers. All uses of invariant must be at global scope or on block members, and before any use of the variables being declared as invariant. To guarantee invariance of a particular output variable across two programs, the following must also be true:\n• The output variable is declared as invariant in both programs.\n• The same values must be input to all shader input variables consumed by expressions and control flow contributing to the value assigned to the output variable.\n• The texture formats, texel values, and texture filtering are set the same way for any texture function calls contributing to the value of the output variable.\n• All input values are all operated on in the same way. All operations in the consuming expressions and any intermediate expressions must be the same, with the same order of operands and same associativity, to give the same order of evaluation. Intermediate variables and functions must be declared as the same type with the same explicit or implicit precision qualifiers and the same constant qualifiers. Any control flow affecting the output value must be the same, and any expressions consumed to determine this control flow must also follow these invariance rules.\n• All the data flow and control flow leading to setting the invariant output variable reside in a single compilation unit. Essentially, all the data flow and control flow leading to an invariant output must match. Initially, by default, all output variables are allowed to be variant. To force all output variables to be invariant, use the pragma before all declarations in a shader. If this pragma is used after the declaration of any variables or functions, then the set of outputs that behave as invariant is undefined. Generally, invariance is ensured at the cost of flexibility in optimization, so performance can be degraded by use of invariance. Hence, use of this pragma is intended as a debug aid, to avoid individually declaring all output variables as invariant. When a value is stored in a variable, it is usually assumed it will remain constant unless explicitly changed. However, during the process of optimization, it is possible that the compiler may choose to recompute a value rather than store it in a register. Since the precision of operations is not completely specified (e.g. a low precision operation may be done at medium or high precision), it would be possible for the recomputed value to be different from the original value. Values are allowed to be variant within a shader. To prevent this, the invariant qualifier or invariant pragma must be used. Within a shader, there is no invariance for values generated by different non-constant expressions, even if those expressions are identical. To enforce invariance in this example use: There is no mechanism to enforce invariance between a and b. Invariance must be guaranteed for constant expressions. A particular constant expression must evaluate to the same result if it appears again in the same shader or a different shader. This includes the same expression appearing in two shaders of the same language or shaders of two different languages. Constant expressions must evaluate to the same result when operated on as already described above for invariant variables. Constant expressions are not invariant with respect to equivalent non-constant expressions, even when the invariant qualifier or pragma is used. Undefined values are not invariant nor can they be made invariant by use of the invariant qualifier or pragma. In some implementations, undefined values may cause unexpected behavior if they are used in control-flow expressions e.g. in the following case, one, both or neither functions may be executed and this may not be consistent over multiple invocations of the shader: Note that an undefined value is a value that has not been specified. A value that has been specified but has a potentially large error due to, for example, lack of precision in an expression, is not undefined and so can be made invariant. Some algorithms require floating-point computations to exactly follow the order of operations specified in the source code and to treat all operations consistently, even if the implementation supports optimizations that could produce nearly equivalent results with higher performance. For example, many GL implementations support a “multiply-add” instruction that can compute a floating-point expression such as in two operations instead of three operations; one multiply and one multiply-add instead of two multiplies and one add. The result of a floating-point multiply-add might not always be identical to first doing a multiply yielding a floating-point result and then doing a floating-point add. Hence, in this example, the two multiply operations would not be treated consistently; the two multiplies could effectively appear to have differing precisions. The key computation that needs to be made consistent appears when tessellating, where intermediate points for subdivision are synthesized in different directions, yet need to yield the same result, as shown in the diagram below. As stated in “Evaluation of Expressions”, the compiler may transform expressions even if this changes the resulting value. Without any qualifiers, implementations are permitted to perform optimizations that effectively modify the order or number of operations used to evaluate an expression, even if those optimizations may produce slightly different results relative to unoptimized code. The precise qualifier ensures that operations contributing to a variable’s value are done in their stated order and with operator consistency. The order is determined by operator precedence and parentheses, as described in “Operators”. Operator consistency means that for each operator, its result is always computed with the same precision. Specifically, values computed by compiler-generated code must adhere to the following identities:\n• a * b + c * d = b * a + c* d = d * c + b * a = <any other mathematically valid combination> While the following are prevented:\n• a + (b + c) is not allowed to become (a + b) + c\n• a * (b * c) is not allowed to become (a * b) * c\n• a * b + c is not allowed to become a single operation fma(a, b, c) Where a, b, c, and d, are scalars or vectors, not matrices. (Matrix multiplication generally does not commute.) It is the shader writer’s responsibility to express the computation in terms of these rules and the compiler’s responsibility to follow these rules. See the description of gl_TessCoord for the rules the tessellation stages are responsible for following, which in conjunction with the above allow avoiding cracking when subdividing. declares that operations used to produce the value of position must be performed in exactly the order specified in the source code and with all operators being treated consistently. As with the invariant qualifier (see “The Invariant Qualifier”), the precise qualifier may be used to qualify a built-in or previously declared user-defined variable as being precise: When applied to a block or a variable of structure type, precise applies to each contained member, recursively. This qualifier will affect the evaluation of an r-value in a particular function if and only if the result is eventually consumed in the same function by an l-value qualified as precise. Any other expressions within a function are not affected, including return values and output parameters not declared as precise but that are eventually consumed outside the function by a variable qualified as precise. Unaffected expressions also include the controlling expressions in selection and iteration statements and the condition in ternary operators (?:). Some examples of the use of precise: in vec4 a, b, c, d; precise out vec4 v; func( e, f, g, h) { (e*f) + (g*h); } func2( e, f, g, h) { precise result = (e*f) + (g*h); result; } func3( i, j, precise out k) { k = i * i + j; } main() { vec3 r = vec3(a * b); vec3 s = vec3(c * d); v.xyz = r + s; v.w = (a.w * b.w) + (c.w * d.w); v.x = func(a.x, b.x, c.x, d.x); v.x = func2(a.x, b.x, c.x, d.x); func3(a.x * b.x, c.x * d.x, v.x); } For the purposes of determining if an output from one shader stage matches an input of the next stage, the precise qualifier need not match between the input and the output. All constant expressions are evaluated as if precise was present, whether or not it is present. However, as described in “Constant Expressions”, there is no requirement that a compile-time constant expression evaluates to the same value as a corresponding non-constant expression. Shader storage blocks, variables declared within shader storage blocks and variables declared as image types (the basic opaque types with “image” in their keyword), can be further qualified with one or more of the following memory qualifiers: memory variable where reads and writes are coherent with reads and writes from other shader invocations memory variable whose underlying value may be changed at any point during shader execution by some source other than the current shader invocation memory variable where use of that variable is the only way to read and write the underlying memory in the relevant shader stage memory variable that can be used to read the underlying memory, but cannot be used to write the underlying memory memory variable that can be used to write the underlying memory, but cannot be used to read the underlying memory Memory accesses to image variables declared using the coherent qualifier are performed coherently with accesses to the same location from other shader invocations. As described in section 7.11 “Shader Memory Access” of the OpenGL ES Specification, shader memory reads and writes complete in a largely undefined order. The built-in function memoryBarrier() can be used if needed to guarantee the completion and relative ordering of memory accesses performed by a single shader invocation. When accessing memory using variables not declared as coherent, the memory accessed by a shader may be cached by the implementation to service future accesses to the same address. Memory stores may be cached in such a way that the values written may not be visible to other shader invocations accessing the same memory. The implementation may cache the values fetched by memory reads and return the same values to any shader invocation accessing the same memory, even if the underlying memory has been modified since the first memory read. While variables not declared as coherent may not be useful for communicating between shader invocations, using non-coherent accesses may result in higher performance. Memory accesses to image variables declared using the volatile qualifier must treat the underlying memory as though it could be read or written at any point during shader execution by some source other than the executing shader invocation. When a volatile variable is read, its value must be re-fetched from the underlying memory, even if the shader invocation performing the read had previously fetched its value from the same memory. When a volatile variable is written, its value must be written to the underlying memory, even if the compiler can conclusively determine that its value will be overwritten by a subsequent write. Since the external source reading or writing a volatile variable may be another shader invocation, variables declared as volatile are automatically treated as coherent. Memory accesses to image variables declared using the restrict qualifier may be compiled assuming that the variable used to perform the memory access is the only way to access the underlying memory using the shader stage in question. This allows the compiler to coalesce or reorder loads and stores using restrict-qualified image variables in ways that wouldn’t be permitted for image variables not so qualified, because the compiler can assume that the underlying image won’t be read or written by other code. Applications are responsible for ensuring that image memory referenced by variables qualified with restrict will not be referenced using other variables in the same scope; otherwise, accesses to restrict-qualified variables will have undefined results. Memory accesses to image variables declared using the readonly qualifier may only read the underlying memory, which is treated as read-only memory and cannot be written to. It is an error to pass an image variable qualified with readonly to imageStore() or other built-in functions that modify image memory. Memory accesses to image variables declared using the writeonly qualifier may only write the underlying memory; the underlying memory cannot be read. It is an error to pass an image variable qualified with writeonly to imageLoad() or other built-in functions that read image memory. A variable could be qualified as both readonly and writeonly, disallowing both read and write. Such variables can still be used with some queries, for example imageSize() and .length(). Except for image variables qualified with the format qualifiers r32f, r32i, and r32ui, image variables must specify a memory qualifier (readonly, writeonly, or both). The memory qualifiers coherent, volatile, restrict, readonly, and writeonly may be used in the declaration of buffer variables (i.e., members of shader storage blocks). When a buffer variable is declared with a memory qualifier, the behavior specified for memory accesses involving image variables described above applies identically to memory accesses involving that buffer variable. It is a compile-time error to assign to a buffer variable qualified with readonly or to read from a buffer variable qualified with writeonly. The combination readonly writeonly is allowed. Additionally, memory qualifiers may be used at the block-level declaration of a shader storage block, including the combination readonly writeonly. When a block declaration is qualified with a memory qualifier, it is as if all of its members were declared with the same memory qualifier. For example, the block declaration Memory qualifiers are only supported in the declarations of image variables, buffer variables, and shader storage blocks; it is an error to use such qualifiers in any other declarations. When calling user-defined functions, opaque-type variables qualified with coherent, volatile, readonly, or writeonly may not be passed to functions whose formal parameters lack such qualifiers. (See “Function Definitions” for more detail on function calling.) It is legal to have any additional memory qualifiers on a formal parameter, but only restrict can be taken away from an opaque-type calling argument, by a formal parameter that lacks the restrict qualifier. For non-opaque argument types, where the values operated on by the called function are copied-in/copied-out, memory qualifiers are not required match. When a built-in function is called, the code generated is to be based on the actual qualification of the calling argument, not on the list of memory qualifiers specified on the formal parameter in the prototype. Layout qualifiers cannot be used on formal function parameters, and layout qualification is not included in parameter matching. Note that the use of const in an image variable declaration is qualifying the const-ness of the variable being declared, not the image it refers to. The qualifier readonly qualifies the image memory (as accessed through that variable) while const qualifies the variable itself. Specialization constants are used only for SPIR-V and declared using the constant_id layout qualifier. For example: The above makes a specialization constant with a default value of 12. The number 17 is an example author-chosen id by which the API or other tools can later refer to this specific specialization constant. If it is never changed before final lowering, it will retain the value of 12. It is a compile-time error to use the constant_id qualifier on anything but SPIR-V generation of a scalar bool, int, uint, float, or double. Built-in constants can be declared to be specialization constants. For example: The declaration uses just the name of the previously declared built-in variable, with a constant_id layout-qualifier declaration. It is a compile-time error to do this after the constant has been used: Constants are strictly either non-specialization constants or specialization constants, not both. The built-in constant vector gl_WorkGroupSize can be specialized using the local_size_{xyz}_id qualifiers, to individually give the components an id. For example: This leaves gl_WorkGroupSize.y as a non-specialization constant, with gl_WorkGroupSize being a partially specialized vector. Its x and z components can be later specialized, after generating SPIR-V, using the ids 18 and 19. These ids are declared independently from declaring the workgroup size: layout(local_size_x = , local_size_y = ) in; layout(local_size_x_id = ) in; layout(local_size_z_id = ) in; Existing rules for declaring local_size_x, local_size_y, and local_size_z are not changed. For the local-size ids, it is a compile-time error to provide different id values for the same local-size id, or to provide them after any use. Otherwise, order, placement, number of statements, and replication do not cause errors. Two arrays sized with specialization constants are the same type only if sized with the same symbol, and involving no operations. For example: Types containing arrays sized with a specialization constant cannot be compared, assigned as aggregates, declared with an initializer, or used as an initializer. They can, however, be passed as arguments to functions having formal parameters of the same type. Only the outer-most dimension of a variable declared as an array of arrays can be a specialization constant, otherwise a compile-time error results. Arrays inside a block may be sized with a specialization constant, but the block will have a static layout. Changing the specialized size will not re-layout the block. In the absence of explicit offsets, the layout will be based on the default size of the array. When multiple qualifiers are present in a declaration, they may appear in any order, but they must all appear before the type. The layout qualifier is the only qualifier that can appear more than once. Further, a declaration can have at most one storage qualifier, at most one auxiliary storage qualifier, and at most one interpolation qualifier. Multiple memory qualifiers can be used. Any violation of these rules will cause a compile-time error. Empty declarations are declarations without a variable name, meaning no object is instantiated by the declaration. Generally, empty declarations are allowed. Some are useful when declaring structures, while many others have no effect. For example: The combinations of qualifiers that cause compile-time or link-time errors are the same whether or not the declaration is empty, for example:\n\nThe OpenGL ES Shading Language has the following operators. array subscript\n\n function call and constructor structure\n\n field or method selector, swizzle\n\n post fix increment and decrement There is no address-of operator nor a dereference operator. There is no typecast operator; constructors are used instead. These are now described in “Structure and Array Operations”. If a function returns a value, then a call to that function may be used as an expression, whose type will be the type that was used to declare or define the function. Function definitions and calling conventions are discussed in “Function Definitions”. Constructors use the function call syntax, where the function name is a type, and the call makes an object of that type. Constructors are used the same way in both initializers and expressions. (See “Shading Language Grammar” for details.) The parameters are used to initialize the constructed value. Constructors can be used to request a data type conversion to change from one scalar type to another scalar type, or to build larger types out of smaller types, or to reduce a larger type to a smaller type. In general, constructors are not built-in functions with predetermined prototypes. For arrays and structures, there must be exactly one argument in the constructor for each element or member. For the other types, the arguments must provide a sufficient number of components to perform the initialization, and it is an error to include so many arguments that they cannot all be used. Detailed rules follow. The prototypes actually listed below are merely a subset of examples. Converting between scalar types is done as the following prototypes indicate: When constructors are used to convert a floating-point type to an integer type, the fractional part of the floating-point value is dropped. It is undefined to convert a negative floating-point value to an uint. Integer values having more bits of precision than a single-precision floating-point mantissa will lose precision when converted to float. When a constructor is used to convert any integer or floating-point type to a bool, 0 and 0.0 are converted to false, and non-zero values are converted to true. When a constructor is used to convert a bool to any integer or floating-point type, false is converted to 0 or 0.0, and true is converted to 1 or 1.0. The constructor int(uint) preserves the bit pattern in the argument, which will change the argument’s value if its sign bit is set. The constructor uint(int) preserves the bit pattern in the argument, which will change its value if it is negative. Identity constructors, like float(float) are also legal, but of little use. Scalar constructors with non-scalar parameters can be used to take the first element from a non-scalar. For example, the constructor float(vec3) will select the first component of the vec3 parameter. Constructors can be used to create vectors or matrices from a set of scalars, vectors, or matrices. This includes the ability to shorten vectors. If there is a single scalar parameter to a vector constructor, it is used to initialize all components of the constructed vector to that scalar’s value. If there is a single scalar parameter to a matrix constructor, it is used to initialize all the components on the matrix’s diagonal, with the remaining components initialized to 0.0. If a vector is constructed from multiple scalars, one or more vectors, or one or more matrices, or a mixture of these, the vector’s components will be constructed in order from the components of the arguments. The arguments will be consumed left to right, and each argument will have all its components consumed, in order, before any components from the next argument are consumed. Similarly for constructing a matrix from multiple scalars or vectors, or a mixture of these. Matrix components will be constructed and consumed in column major order. In these cases, there must be enough components provided in the arguments to provide an initializer for every component in the constructed value. It is an error to provide extra arguments beyond this last used argument. If a matrix is constructed from a matrix, then each component (column i, row j) in the result that has a corresponding component (column i, row j) in the argument will be initialized from there. All other components will be initialized to the identity matrix. If a matrix argument is given to a matrix constructor, it is an error to have any other arguments. If the basic type (bool, int, or float) of a parameter to a constructor does not match the basic type of the object being constructed, the scalar construction rules (above) are used to convert the parameters. Some useful vector constructors are as follows: Some examples of these are: To initialize the diagonal of a matrix with all other elements set to zero: That is, result[i][j] is set to the float argument for all \\(i = j\\) and set to 0 for all \\(i \n\neq j\\). To initialize a matrix by specifying vectors or scalars, the components are assigned to the matrix elements in column-major order. A wide range of other possibilities exist, to construct a matrix from vectors and scalars, as long as enough components are present to initialize the matrix. To construct a matrix from a matrix: Once a structure is defined, and its type is given a name, a constructor is available with the same name to construct instances of that structure. For example: The arguments to the constructor will be used to set the structure’s members, in order, using one argument per member. Each argument must be the same type as the member it sets. Structure constructors can be used as initializers or in expressions. Array types can also be used as constructor names, which can then be used in expressions or initializers. For example, There must be exactly the same number of arguments as the size of the array being constructed. If no size is present in the constructor, then the array is explicitly sized to the number of arguments provided. The arguments are assigned in order, starting at element 0, to the elements of the constructed array. Each argument must be the same type as the element type of the array. Arrays of arrays are similarly constructed, and the size for any dimension is optional Texture-combined sampler constructors are only available when targeting Vulkan. Texture-combined sampler types, like sampler2D, can be declared with an initializer that is a constructor of the same type, and consuming a texture and a sampler or samplerShadow. For example: The result of a texture-combined sampler constructor cannot be assigned to a variable: Texture-combined sampler constructors can only be consumed by a function parameter.\n• every texture-combined sampler type can be used as a constructor\n• the type of the constructor must match the type of the variable being declared\n• the constructor’s first argument must be a texture type\n• the constructor’s second argument must be a scalar of type sampler or samplerShadow\n• the dimensionality (1D, 2D, 3D, Cube, Rect, Buffer, MS, and Array) of the texture type must match that of the constructed type (that is, the suffixes of the type of the first argument and the type of the constructor will be spelled the same way)\n• there is no control flow construct (e.g., ) that consumes any sampler type Note: Shadow mismatches are allowed between constructors and the second argument. Texture-combined non-shadow samplers can be constructed from samplerShadow and texture-combined shadow samplers can be constructed from sampler. The names of the components of a vector are denoted by a single letter. As a notational convenience, several letters are associated with each component based on common usage of position, color or texture coordinate vectors. The individual components can be selected by following the variable name with period (.) and then the component name. Useful when accessing vectors that represent points or normals Useful when accessing vectors that represent colors Useful when accessing vectors that represent texture coordinates The component names x, r, and s are, for example, synonyms for the same (first) component in a vector. Note that the third component of the texture coordinate set has been renamed p so as to avoid the confusion with r (for red) in a color. Accessing components beyond those declared for the type is an error so, for example: The component selection syntax allows multiple components to be selected by appending their names (from the same name set) after the period (.). No more than 4 components can be selected. The order of the components can be different to swizzle them, or replicated: This notation is more concise than the constructor syntax. To form an r-value, it can be applied to any expression that results in a vector r-value. The component group notation can occur on the left hand side of an expression. To form an l-value, swizzling must further be applied to an l-value and contain no duplicate components. It results in an l-value of scalar or vector type, depending on number of components specified. Array subscripting syntax can also be applied to vectors (but not to scalars) to provide numeric indexing. So in pos[2] refers to the third element of pos and is equivalent to pos.z. This allows variable indexing into a vector, as well as a generic way of accessing components. Any integer expression can be used as the subscript. The first component is at index zero. Reading from or writing to a vector using a constant integral expression with a value that is negative or greater than or equal to the size of the vector results in an error. When indexing with non-constant expressions, behavior is undefined if the index is negative, or greater than or equal to the size of the vector. Note that scalars are not considered to be single-component vectors and therefore the use of component selection operators on scalars is illegal. The components of a matrix can be accessed using array subscripting syntax. Applying a single subscript to a matrix treats the matrix as an array of column vectors, and selects a single column, whose type is a vector of the same size as the (column size of the) matrix. The leftmost column is column 0. A second subscript would then operate on the resulting vector, as defined earlier for vectors. Hence, two subscripts select a column and then a row. Behavior is undefined when accessing a component outside the bounds of a matrix with a non-constant expression. It is an error to access a matrix with a constant expression that is outside the bounds of the matrix. The members of a structure and the length() method of an array are selected using the period (.). In total, only the following operators are allowed to operate on arrays and structures as whole entities: The equality operators and assignment operator are only allowed if the two operands are same size and type. The operands cannot contain any opaque types. Structure types must be of the same declared structure. Both array operands must be compile-time sized. When using the equality operators, two structures are equal if and only if all the members are component-wise equal, and two arrays are equal if and only if all the elements are element-wise equal. Array elements are accessed using the array subscript operator ([ ]). An example of accessing an array element is Array indices start at zero. Array elements are accessed using an expression whose type is int or uint. Behavior is undefined if a shader subscripts an array with an index less than 0 or greater than or equal to the size the array was declared with. Arrays can also be accessed with the method operator (.) and the length method to query the size of the array: Assignments of values to variable names are done with the assignment operator (=): The lvalue-expression evaluates to an l-value. The assignment operator stores the value of rvalue-expression into the l-value and returns an r-value with the type and precision of lvalue-expression. The lvalue-expression and rvalue-expression must have the same type. Any type-conversions must be specified explicitly via constructors. It is an error if the l-value is not writable. Variables that are built-in types, entire structures or arrays, structure members, l-values with the field selector (.) applied to select components or swizzles without repeated fields, l-values within parentheses, and l-values dereferenced with the array subscript operator ([ ]) are all l-values. Other binary or unary expressions, function names, swizzles with repeated fields, and constants cannot be l-values. The ternary operator (?:) is also not allowed as an l-value. Using an incorrect expression as an l-value results in an error. Expressions on the left of an assignment are evaluated before expressions on the right of the assignment. The other assignment operators are where lvalue is the value returned by lvalue-expression, op is as described below, and the lvalue-expression and expression must satisfy the semantic requirements of both op and equals (=). Reading a variable before writing (or initializing) it is legal, however the value is undefined. Expressions in the shading language are built from the following:\n• Constants of type bool, all integral types, all floating-point types, all vector types, and all matrix types.\n• Function calls that return values. In some cases, function calls returning void are also allowed in expressions as specified below.\n• Parenthesized expressions. Any expression, including expressions with void type can be parenthesized. Parentheses can be used to group operations. Operations within parentheses are done before operations across parentheses.\n• The arithmetic binary operators add (+), subtract (-), multiply (*), and divide (/) operate on integer and floating-point scalars, vectors, and matrices. If the operands are integral types, they must both be signed or both be unsigned. All arithmetic binary operators result in the same fundamental type (signed integer, unsigned integer, or floating-point) as the operands they operate on. The following cases are valid\n• The two operands are scalars. In this case the operation is applied, resulting in a scalar.\n• One operand is a scalar, and the other is a vector or matrix. In this case, the scalar operation is applied independently to each component of the vector or matrix, resulting in the same size vector or matrix.\n• The two operands are vectors of the same size. In this case, the operation is done component-wise resulting in the same size vector.\n• The operator is add (+), subtract (-), or divide (/), and the operands are matrices with the same number of rows and the same number of columns. In this case, the operation is done component-wise resulting in the same size matrix.\n• The operator is multiply (*), where both operands are matrices or one operand is a vector and the other a matrix. A right vector operand is treated as a column vector and a left vector operand as a row vector. In all these cases, it is required that the number of columns of the left operand is equal to the number of rows of the right operand. Then, the multiply (*) operation does a linear algebraic multiply, yielding an object that has the same number of rows as the left operand and the same number of columns as the right operand. “Vector and Matrix Operations” explains in more detail how vectors and matrices are operated on. All other cases result in an error. Use the built-in functions dot, cross, matrixCompMult, and outerProduct, to get, respectively, vector dot product, vector cross product, matrix component-wise multiplication, and the matrix product of a column vector times a row vector.\n• The operator modulus (%) operates on signed or unsigned integers or integer vectors. The operand types must both be signed or both be unsigned. The operands cannot be vectors of differing size; this is an error. If one operand is a scalar and the other vector, then the scalar is applied component-wise to the vector, resulting in the same type as the vector. If both are vectors of the same size, the result is computed component-wise. The resulting value is undefined for any component computed with a second operand that is zero, while results for other components with non-zero second operands remain defined. If both operands are non-negative, then the remainder is non-negative. Results are undefined if one or both operands are negative. The operator modulus (%) is not defined for any other data types (non-integer types).\n• The arithmetic unary operators plus (*), negate (*-*), post- and pre-increment and decrement (*--* and *+) operate on integer or floating-point values (including vectors and matrices). All unary operators work component-wise on their operands. These result with the same type they operated on. For post- and pre-increment and decrement, the expression must be a writable l-value. Pre-increment and pre-decrement add or subtract 1 or 1.0 to the contents of the expression they operate on, and the value of the pre-increment or pre-decrement expression is the resulting value of that modification. Post-increment and post-decrement expressions add or subtract 1 or 1.0 to the contents of the expression they operate on, but the resulting expression has the expression’s value before the post-increment or post-decrement was executed.\n• The relational operators greater than (>), less than (<), greater than or equal (>=), and less than or equal (<=) operate only on scalar integer and scalar floating-point expressions. The result is scalar Boolean. The types of the operands must match. To do component-wise relational comparisons on vectors, use the built-in functions lessThan, lessThanEqual, greaterThan, and greaterThanEqual.\n• The equality operators equal (==), and not equal (!=) operate on all types except opaque types. They result in a scalar Boolean. The types of the operands must match. For vectors, matrices, structures, and arrays, all components, members, or elements of one operand must equal the corresponding components, members, or elements in the other operand for the operands to be considered equal. To get a vector of component-wise equality results for vectors, use the built-in functions equal and notEqual.\n• The logical binary operators and (&&), or (||), and exclusive or (^^) operate only on two Boolean expressions and result in a Boolean expression. And (&&) will only evaluate the right hand operand if the left hand operand evaluated to true. Or (||) will only evaluate the right hand operand if the left hand operand evaluated to false. Exclusive or (^^) will always evaluate both operands.\n• The logical unary operator not (!). It operates only on a Boolean expression and results in a Boolean expression. To operate on a vector, use the built-in function not.\n• The sequence (,) operator that operates on expressions by returning the type and value of the right-most expression in a comma separated list of expressions. All expressions are evaluated, in order, from left to right. The operands to the sequence operator may have void type. Opaque types cannot be used with the sequence (,) operator.\n• The ternary selection operator (?:). It operates on three expressions (exp1 ? exp2 : exp3). This operator evaluates the first expression, which must result in a scalar Boolean. If the result is true, it selects to evaluate the second expression, otherwise it selects to evaluate the third expression. Only one of the second and third expressions is evaluated. The second and third expressions cannot be opaque types, or there will be an error. Otherwise, the second and third expressions can be any type, including void, as long their types match. This resulting matching type is the type of the entire expression.\n• The one’s complement operator (~). The operand must be of type signed or unsigned integer or integer vector, and the result is the one’s complement of its operand; each bit of each component is complemented, including any sign bits.\n• The shift operators (<<) and (>>). For both operators, the operands must be signed or unsigned integers or integer vectors. One operand can be signed while the other is unsigned. In all cases, the resulting type will be the same type as the left operand. If the first operand is a scalar, the second operand has to be a scalar as well. If the first operand is a vector, the second operand must be a scalar or a vector with the same size as the first operand, and the result is computed component-wise. The result is undefined if the right operand is negative, or greater than or equal to the number of bits in the left expression’s base type. The value of E1 << E2 is E1 (interpreted as a bit pattern) left-shifted by E2 bits. The value of E1 >> E2 is E1 right-shifted by E2 bit positions. If E1 is a signed integer, the right-shift will extend the sign bit. If E1 is an unsigned integer, the right-shift will zero-extend.\n• The bitwise operators and (&), exclusive-or (^), and inclusive-or (|). The operands must be of type signed or unsigned integers or integer vectors. The operands cannot be vectors of differing size; this is an error. If one operand is a scalar and the other a vector, the scalar is applied component-wise to the vector, resulting in the same type as the vector. The fundamental types of the operands (signed or unsigned) must match, and will be the resulting fundamental type. For and (&), the result is the bitwise-and function of the operands. For exclusive-or (^), the result is the bitwise exclusive-or function of the operands. For inclusive-or (|), the result is the bitwise inclusive-or function of the operands. For a complete specification of the syntax of expressions, see “Shading Language Grammar”. With a few exceptions, operations are component-wise. Usually, when an operator operates on a vector or matrix, it is operating independently on each component of the vector or matrix, in a component-wise fashion. For example, and likewise for most operators and all integer and floating-point vector and matrix types. The exceptions are matrix multiplied by vector, vector multiplied by matrix, and matrix multiplied by matrix. These do not operate component-wise, but rather perform the correct linear algebraic multiply. and similarly for other sizes of vectors and matrices. Specialization-constant operations are only available when targeting SPIR-V. Only some operations discussed in this section may be applied to a specialization constant and still yield a result that is a specialization constant. The operations that do so are listed below. When a specialization constant is operated on with one of these operators and with another constant or specialization constant, the result is implicitly a specialization constant.\n• int(), uint(), and bool() constructors for type conversions from any of the following types to any of the following types:\n• vector versions of the above conversion constructors\n• allowed implicit conversions of the above\n• the following when applied to integer or unsigned integer types:\n• the following when applied to integer or unsigned integer scalar types:\n• The following when applied to the Boolean scalar type: In general expressions must be evaluated in the order specified by the precedence of operations and may only be regrouped if the result is the same or where the result is undefined. No other transforms may be applied that affect the result of an operation. GLSL ES relaxes these requirements for scalar operations in the following ways:\n• Addition and multiplication are assumed to be associative.\n• Multiplication is assumed to be distributive over addition. Therefore expressions may be expanded and re-factored.\n• Floating-point division may be replaced by reciprocal and multiplication.\n• Multiplication may be replaced by repeated addition.\n• Within the constraints of invariance (where applicable), the precision used may vary. These rules also apply to the built-in functions.\n\nThe OpenGL ES Shading Language defines an assortment of built-in convenience functions for scalar and vector operations. Many of these built-in functions can be used in more than one type of shader, but some are intended to provide a direct mapping to hardware and so are available only for a specific type of shader. The built-in functions basically fall into three categories:\n• They expose some necessary hardware functionality in a convenient way such as accessing a texture map. There is no way in the language for these functions to be emulated by a shader.\n• They represent a trivial operation (clamp, mix, etc.) that is very simple for the user to write, but they are very common and may have direct hardware support. It is a very hard problem for the compiler to map expressions to complex assembler instructions.\n• They represent an operation graphics hardware is likely to accelerate at some point. The trigonometry functions fall into this category. Many of the functions are similar to the same named ones in common C libraries, but they support vector input as well as the more traditional scalar input. Applications should be encouraged to use the built-in functions rather than do the equivalent computations in their own shader code since the built-in functions are assumed to be optimal (e.g. perhaps supported directly in hardware). When the built-in functions are specified below, where the input arguments (and corresponding output) can be float, vec2, vec3, or vec4, genFType is used as the argument. Where the input arguments (and corresponding output) can be int, ivec2, ivec3, or ivec4, genIType is used as the argument. Where the input arguments (and corresponding output) can be uint, uvec2, uvec3, or uvec4, genUType is used as the argument. Where the input arguments (or corresponding output) can be bool, bvec2, bvec3, or bvec4, genBType is used as the argument. For any specific use of a function, the actual types substituted for genFType, genIType, genUType, or genBType have to have the same number of components for all arguments and for the return type. Similarly, mat is used for any matrix basic type. Built-in functions have an effective precision qualification. This qualification cannot be set explicitly and may be different from the precision qualification of the result. The precision qualification of the operation of a built-in function is based on the precision qualification of its formal parameters and actual parameters (input arguments): When a formal parameter specifies a precision qualifier, that is used, otherwise, the precision qualification of the actual (calling) argument is used. The highest precision of these will be the precision of the operation of the built-in function. Generally, this is applied across all arguments to a built-in function, with the exceptions being:\n• bitfieldExtract and bitfieldInsert ignore the offset and bits arguments.\n• interpolateAt functions only look at the interpolant argument. The precision qualification of the result of a built-in function is determined in one of the following ways: For the texture sampling and image load functions, the precision of the return type matches the precision of the image or texture-combined sampler type:\n• For prototypes that do not specify a resulting precision qualifier, the precision will be the same as the precision of the operation (as defined earlier).\n• For prototypes that do specify a resulting precision qualifier, the specified precision qualifier is the precision qualification of the result. Where the built-in functions in the following sections specify an equation, the entire equation will be evaluated at the operation’s precision. This may lead to underflow or overflow in the result, even when the correct result could be represented in the operation precision. Function parameters specified as angle are assumed to be in units of radians. In no case will any of these functions result in a divide by zero error. If the divisor of a ratio is 0, then results will be undefined. These all operate component-wise. The description is per component. Arc sine. Returns an angle whose sine is x. The range of values returned by this function is [-π / 2, π / 2]. Results are undefined if |x| > 1. Arc cosine. Returns an angle whose cosine is x. The range of values returned by this function is [0,π]. Results are undefined if |x| > 1. Arc tangent. Returns an angle whose tangent is y / x. The signs of x and y are used to determine what quadrant the angle is in. The range of values returned by this function is [-π, π. Results are undefined if x and y are both 0. Arc tangent. Returns an angle whose tangent is y_over_x. The range of values returned by this function is [-π / 2, π / 2]. Returns the hyperbolic sine function (ex - e-x) / 2. Returns the hyperbolic cosine function (ex + e-x) / 2. Arc hyperbolic cosine; returns the non-negative inverse of cosh. Results are undefined if x < 1. Arc hyperbolic tangent; returns the inverse of tanh. Results are undefined if x ≥ 1. These all operate component-wise. The description is per component. Returns x raised to the y power, i.e., xy. Results are undefined if x < 0. Results are undefined if x = 0 and y ≤ 0. Returns the natural exponentiation of x, i.e., ex. Returns the natural logarithm of x, i.e., returns the value y which satisfies the equation x = ey. Results are undefined if x ≤ 0. Returns the base 2 logarithm of x, i.e., returns the value y which satisfies the equation x = 2y. Results are undefined if x ≤ 0. These all operate component-wise. The description is per component. Returns x if x ≥ 0; otherwise it returns -x. Returns 1.0 if x > 0, 0.0 if x = 0, or -1.0 if x < 0. Returns a value equal to the nearest integer that is less than or equal to x. Returns a value equal to the nearest integer to x whose absolute value is not larger than the absolute value of x. Returns a value equal to the nearest integer to x. The fraction 0.5 will round in a direction chosen by the implementation, presumably the direction that is fastest. This includes the possibility that round(x) returns the same value as roundEven(x) for all values of x. Returns a value equal to the nearest integer to x. A fractional part of 0.5 will round toward the nearest even integer. (Both 3.5 and 4.5 for x will return 4.0.) Returns a value equal to the nearest integer that is greater than or equal to x. Note that implementations may use a cheap approximation to the remainder, and the error can be large due to the discontinuity in floor. This can produce mathematically unexpected results in some cases, such as mod(x,x) computing x rather than 0, and can also cause the result to have a different sign than the infinitely precise result. Returns the fractional part of x and sets i to the integer part (as a whole number floating-point value). Both the return value and the output parameter will have the same sign as x. If x has the value +/- Inf, the return value should be NaN and must be either NaN or 0.0. For highp non-constant expressions, the value returned must be consistent. Returns y if y < x; otherwise it returns x. Returns y if x < y; otherwise it returns x. Returns the linear blend of x and y, i.e., x · (1 - a) + y · a. genFType mix(genFType x, genFType y, genBType a)\n\n genIType mix(genIType x, genIType y, genBType a)\n\n genUType mix(genUType x, genUType y, genBType a)\n\n genBType mix(genBType x, genBType y, genBType a) Selects which vector each returned component comes from. For a component of a that is false, the corresponding component of x is returned. For a component of a that is true, the corresponding component of y is returned. Components of x and y that are not selected are allowed to be invalid floating-point values and will have no effect on the results. Thus, this provides different functionality than, for example,\n\n genFType mix(genFType x, genFType y, genFType(a))\n\n where a is a Boolean vector. Returns 0.0 if x < edge; otherwise it returns 1.0. Returns 0.0 if x ≤ edge0 and 1.0 if x ≥ edge1, and performs smooth Hermite interpolation between 0 and 1 when edge0 < x < edge1. This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to: (And similarly for doubles.) Results are undefined if edge0 ≥ edge1. Returns true if x holds a NaN. Returns false otherwise. Always returns false if NaNs are not implemented. Returns true if x holds a positive infinity or negative infinity. Returns false otherwise. Returns a signed or unsigned integer value representing the encoding of a floating-point value. The float value’s bit-level representation is preserved. Returns a floating-point value corresponding to a signed or unsigned integer encoding of a floating-point value. If an Inf or NaN is passed in, it will not signal, and the resulting floating-point value is unspecified. If a subnormal number is passed in, the result might be flushed to 0. Otherwise, the bit-level representation is preserved. Computes and returns . In uses where the return value is eventually consumed by a variable declared as precise:\n• fma() is considered a single operation, whereas the expression consumed by a variable declared precise is considered two operations.\n• The precision of fma() can differ from the precision of the expression .\n• fma() will be computed with the same precision as any other fma() consumed by a precise variable, giving invariant results for the same input values of a, b, and c. Otherwise, in the absence of precise consumption, there are no special constraints on the number of operations or difference in precision between fma() and the expression . Splits x into a floating-point significand in the range [0.5,1.0], and an integral exponent of two, such that The significand is returned by the function and the exponent is returned in the parameter exp. For a floating-point value of zero, the significand and exponent are both zero. If an implementation supports signed zero, an input value of minus zero should return a significand of minus zero. For a floating-point value that is an infinity or is not a number, the results are undefined. If the input x is a vector, this operation is performed in a component-wise manner; the value returned by the function and the value written to exp are vectors with the same number of components as x. Builds a floating-point number from x and the corresponding integral exponent of two in exp, returning: If this product is too large to be represented in the floating-point type, the result is undefined. If exp is greater than +128, the value returned is undefined. If exp is less than -126, the value returned may be flushed to zero. Additionally, splitting the value into a significand and exponent using frexp() and then reconstructing a floating-point value using ldexp() should yield the original input for zero and all finite non-subnormal values.\n\n If the input x is a vector, this operation is performed in a component-wise manner; the value passed in exp and returned by the function are vectors with the same number of components as x. These functions do not operate component-wise, rather, as described in each case. First, converts each component of the normalized floating-point value v into 16-bit (2x16) or 8-bit (4x8) integer values. Then, the results are packed into the returned 32-bit unsigned integer. The conversion for component c of v to fixed point is done as follows: The first component of the vector will be written to the least significant bits of the output; the last component will be written to the most significant bits. First, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, a pair of 16-bit signed integers, four 8-bit unsigned integers, or four 8-bit signed integers, respectively. Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector. The conversion for unpacked fixed-point value f to floating-point is done as follows: The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits. Returns an unsigned integer obtained by converting the components of a two-component floating-point vector to the 16-bit floating-point representation of the API, and then packing these two 16-bit integers into a 32-bit unsigned integer. The first vector component specifies the 16 least-significant bits of the result; the second component specifies the 16 most-significant bits. Returns a two-component floating-point vector with components obtained by unpacking a 32-bit unsigned integer into a pair of 16-bit values, interpreting those values as 16-bit floating-point numbers according to the API, and converting them to 32-bit floating-point values. The first component of the vector is obtained from the 16 least-significant bits of v; the second component is obtained from the 16 most-significant bits of v. These operate on vectors as vectors, not component-wise. Returns the distance between p0 and p1, i.e., length(p0 - p1) Returns the dot product of x and y, i.e., x · y + x · y + …​ Returns the cross product of x and y, i.e., (x · y - y · x , x · y - y · x , x · y - y · x ). Returns a vector in the same direction as x but with a length of 1, i.e. x / length(x). For the incident vector I and surface orientation N, returns the reflection direction: I - 2 · dot(N, I) · N. N must already be normalized in order to achieve the desired result. For the incident vector I and surface normal N, and the ratio of indices of refraction eta, return the refraction vector. The result is computed by the refraction equation shown below. The input parameters for the incident vector _I_ and the surface normal _N_ must already be normalized to get the desired results. For each of the following built-in matrix functions, there is both a single-precision floating-point version, where all arguments and return values are single precision, and a double-precision floating-point version, where all arguments and return values are double precision. Only the single-precision floating-point version is shown. Multiply matrix x by matrix y component-wise, i.e., result[i][j] is the scalar product of x[i][j] and y[i][j].\n\n Note: to get linear algebraic matrix multiplication, use the multiply operator (*). mat2 outerProduct(vec2 c, vec2 r)\n\n mat3 outerProduct(vec3 c, vec3 r)\n\n mat4 outerProduct(vec4 c, vec4 r)\n\n mat2x3 outerProduct(vec3 c, vec2 r)\n\n mat3x2 outerProduct(vec2 c, vec3 r)\n\n mat2x4 outerProduct(vec4 c, vec2 r)\n\n mat4x2 outerProduct(vec2 c, vec4 r)\n\n mat3x4 outerProduct(vec4 c, vec3 r)\n\n mat4x3 outerProduct(vec3 c, vec4 r) Treats the first parameter c as a column vector (matrix with one column) and the second parameter r as a row vector (matrix with one row) and does a linear algebraic matrix multiply c * r, yielding a matrix whose number of rows is the number of components in c and whose number of columns is the number of components in r. Returns a matrix that is the transpose of m. The input matrix m is not modified. Returns a matrix that is the inverse of m. The input matrix m is not modified. The values in the returned matrix are undefined if m is singular or poorly-conditioned (nearly singular). Relational and equality operators (<, <=, >, >=, ==, !=) are defined to operate on scalars and produce scalar Boolean results. For vector results, use the following built-in functions. Below, the following placeholders are used for the listed specific types: In all cases, the sizes of all the input and return vectors for any particular call must match. Returns true if any component of x is true. Returns true only if all components of x are true. These all operate component-wise. The description is per component. The notation [a, b] means the set of bits from bit-number a through bit-number b, inclusive. The lowest-order bit is bit 0. “Bit number” will always refer to counting up from the lowest-order bit as bit 0. Adds 32-bit unsigned integers x and y, returning the sum modulo 232. The value carry is set to zero if the sum was less than 232, or one otherwise. Subtracts the 32-bit unsigned integer y from x, returning the difference if non-negative, or 232 plus the difference otherwise. The value borrow is set to zero if x ≥ y, or one otherwise. void umulExtended(highp genUType x, highp genUType y, out highp genUType msb, out highp genUType lsb)\n\n void imulExtended(highp genIType x, highp genIType y, out highp genIType msb, out highp genIType lsb) Multiplies 32-bit unsigned or signed integers x and y, producing a 64-bit result. The 32 least-significant bits are returned in lsb. The 32 most-significant bits are returned in msb. Extracts bits [offset, offset + bits - 1] from value, returning them in the least significant bits of the result.\n\n For unsigned data types, the most significant bits of the result will be set to zero. For signed data types, the most significant bits will be set to the value of bit offset + bits - 1.\n\n If bits is zero, the result will be zero. The result will be undefined if offset or bits is negative, or if the sum of offset and bits is greater than the number of bits used to store the operand. Note that for vector versions of bitfieldExtract(), a single pair of offset and bits values is shared for all components. Inserts the bits least significant bits of insert into base. The result will have bits [offset, offset + bits - 1] taken from bits [0, bits - 1] of insert, and all other bits taken directly from the corresponding bits of base. If bits is zero, the result will simply be base. The result will be undefined if offset or bits is negative, or if the sum of offset and bits is greater than the number of bits used to store the operand.\n\n Note that for vector versions of bitfieldInsert(), a single pair of offset and bits values is shared for all components. Reverses the bits of value. The bit numbered n of the result will be taken from bit (bits - 1) - n of value, where bits is the total number of bits used to represent value. Returns the number of one bits in the binary representation of value. Returns the bit number of the least significant one bit in the binary representation of value. If value is zero, -1 will be returned. Returns the bit number of the most significant bit in the binary representation of value. For positive integers, the result will be the bit number of the most significant one bit. For negative integers, the result will be the bit number of the most significant zero bit. For a value of zero or negative one, -1 will be returned. Texture lookup functions are available in all shading stages. However, level-of-detail is implicitly computed only for fragment shaders. Other shaders operate as though the base level-of-detail were computed as zero. The functions in the table below provide access to textures through texture-combined samplers, as set up through the API. Texture properties such as size, pixel format, number of dimensions, filtering method, number of mipmap levels, depth comparison, and so on are also defined by API calls. Such properties are taken into account as the texture is accessed via the built-in functions defined below. Texture data can be stored by the GL as single-precision floating-point, unsigned normalized integer, unsigned integer or signed integer data. This is determined by the type of the internal format of the texture. Texture lookup functions are provided that can return their result as floating-point, unsigned integer or signed integer, depending on the sampler type passed to the lookup function. Care must be taken to use the right sampler type for texture access. The following table lists the supported combinations of sampler types and texture internal formats. Blank entries are unsupported. Doing a texture lookup will return undefined values for unsupported combinations. For depth/stencil textures, the internal texture format is determined by the component being accessed as set through the API. When the depth/stencil texture mode is set to DEPTH_COMPONENT, the internal format of the depth component should be used. When the depth/stencil texture mode is set to STENCIL_INDEX, the internal format of the stencil component should be used. If an integer sampler type is used, the result of a texture lookup is an ivec4. If an unsigned integer sampler type is used, the result of a texture lookup is a uvec4. If a floating-point sampler type is used, the result of a texture lookup is a vec4. In the prototypes below, the in the return type is used as a placeholder for either nothing, , or making a return type of vec4, ivec4, or uvec4. In these cases, the sampler argument type also starts with , indicating the same substitution done on the return type; it is either a floating-point, signed integer, or unsigned integer sampler, matching the basic type of the return type, as described above. For shadow forms (the sampler parameter is a shadow-type), a depth comparison lookup on the depth texture bound to sampler is done as described in section 8.20 “Texture Comparison Modes” of the OpenGL ES Specification. See the table below for which component specifies D . The texture bound to sampler must be a depth texture, or results are undefined. If a non-shadow texture call is made to a sampler that represents a depth texture with depth comparisons turned on, then results are undefined. If a shadow texture call is made to a sampler that represents a depth texture with depth comparisons turned off, then results are undefined. If a shadow texture call is made to a sampler that does not represent a depth texture, then results are undefined. In all functions below, the bias parameter is optional for fragment shaders. The bias parameter is not accepted in any other shader stage. For a fragment shader, if bias is present, it is added to the implicit level-of-detail prior to performing the texture access operation. No bias or lod parameters for multisample textures, or texture buffers are supported because mipmaps are not allowed for these types of textures. The implicit level-of-detail is selected as follows: For a texture that is not mipmapped, the texture is used directly. If it is mipmapped and running in a fragment shader, the level-of-detail computed by the implementation is used to do the texture lookup. If it is mipmapped and running in a non-fragment shader, then the base texture is used. Some texture functions (non-“Lod” and non-“Grad” versions) may require implicit derivatives. Implicit derivatives are undefined within non-uniform control flow and for non-fragment shader texture fetches. For Cube forms, the direction of P is used to select which face to do a 2-dimensional texture lookup in, as described in section 8.13 “Cube Map Texture Selection” of the OpenGL ES Specification. For Array forms, the array layer used will be where d is the depth of the texture array and layer comes from the component indicated in the tables below. The textureSize functions query the dimensions of a specific texture level for a texture-combined sampler. Returns the dimensions of level lod (if present) for the texture bound to sampler, as described in section 11.1.3.4 “Texture Queries” of the OpenGL ES Specification.\n\n The components in the return value are filled in, in order, with the width, height, and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array, or the number of cubes in the texture cube map array. Use the texture coordinate P to do a texture lookup in the texture currently bound to sampler. For shadow forms: When compare is present, it is used as D and the array layer comes from the last component of P. When compare is not present, the last component of P is used as D and the array layer comes from the second to last component of P. For non-shadow forms: the array layer comes from the last component of P. Do a texture lookup with projection. The texture coordinates consumed from P, not including the last component of P, are divided by the last component of P to form projected coordinates P'. The resulting third component of P in the shadow forms is used as D . The third component of P is ignored when sampler has type gsampler2D and P has type vec4. After these values are computed, texture lookup proceeds as in texture. Do a texture lookup as in texture but with explicit level-of-detail; lod specifies λ ] and sets the partial derivatives as follows:\n\n (See section 8.14 “Texture Minification” and equations 8.4-8.6 of the OpenGL ES Specification.)\n\n \n\n ∂u / ∂x = ∂v / ∂x = ∂w / ∂x = 0 \n\n ∂u / ∂y = ∂v / ∂y = ∂w / ∂y = 0 Do a texture lookup as in texture but with offset added to the (u,v,w) texel coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation-dependent and given by gl_MinProgramTexelOffset and gl_MaxProgramTexelOffset, respectively. Note that offset does not apply to the layer coordinate for texture arrays. This is explained in detail in section 8.14.2 “Coordinate Wrapping and Texel Selection” of the OpenGL ES Specification, where offset is (δ , δ , δ ).\n\n Note that texel offsets are also not supported for cube maps. Use integer texture coordinate P to lookup a single texel from sampler. The array layer comes from the last component of P for the array forms. The level-of-detail lod (if present) is as described in sections 11.1.3.2 “Texel Fetches” and 8.14.1 “Scale Factor and Level of Detail” of the OpenGL ES Specification. Fetch a single texel as in texelFetch, offset by offset as described in textureOffset. Do a projective texture lookup as described in textureProj, offset by offset as described in textureOffset. Do an offset texture lookup with explicit level-of-detail. See textureLod and textureOffset. Do a projective texture lookup with explicit level-of-detail. See textureProj and textureLod. Do an offset projective texture lookup with explicit level-of-detail. See textureProj, textureLod, and textureOffset. Do a texture lookup as in texture but with explicit gradients as shown below. The partial derivatives of P are with respect to window x and window y. For the cube version, the partial derivatives of P are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face. Do a texture lookup with both explicit gradient and offset, as described in textureGrad and textureOffset. Do a texture lookup both projectively, as described in textureProj, and with explicit gradient as described in textureGrad. The partial derivatives dPdx and dPdy are assumed to be already projected. Do a texture lookup projectively and with explicit gradient as described in textureProjGrad, as well as with offset, as described in textureOffset. In the textureGrad functions described above, explicit gradients control texture lookups as follows: The texture gather functions take components of a single floating-point vector operand as a texture coordinate, determine a set of four texels to sample from the base level-of-detail of the specified texture image, and return one component from each texel in a four-component result vector. When performing a texture gather operation, the minification and magnification filters are ignored, and the rules for LINEAR filtering in the OpenGL ES Specification are applied to the base level of the texture image to identify the four texels i j , i j , i j , and i j . The texels are then converted to texture base colors (R , G , B , A ) according to table 15.1, followed by application of the texture swizzle as described in section 15.2.1 “Texture Access” of the OpenGL ES Specification. A four-component vector is assembled by taking the selected component from each of the post-swizzled texture source colors in the order (i j , i j , i j , i j ). The selected component is identified by the optional comp argument, where the values zero, one, two, and three identify the R , G , B , or A component, respectively. If comp is omitted, it is treated as identifying the R component. Incomplete textures (see section 8.16 “Texture Completeness” of the OpenGL ES Specification) return a texture source color of (0,0,0,1) for all four source texels. For texture gather functions using a texture-combined shadow sampler type, each of the four texel lookups perform a depth comparison against the depth reference value passed in (refZ), and returns the result of that comparison in the appropriate component of the result vector. As with other texture lookup functions, the results of a texture gather are undefined for shadow samplers if the texture referenced is not a depth texture or has depth comparisons disabled; or for non-shadow samplers if the texture referenced is a depth texture with depth comparisons enabled. The textureGatherOffset built-in functions from the OpenGL ES Shading Language return a vector derived from sampling four texels in the image array of level level . For each of the four texel offsets specified by the offsets argument, the rules for the LINEAR minification filter are applied to identify a 2 × 2 texel footprint, from which the single texel T is selected. A four-component vector is then assembled by taking a single component from each of the four T texels in the same manner as for the textureGather function. If specified, the value of comp must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z, or w post-swizzled component of the four-component vector lookup result for each texel, respectively. If comp is not specified, it is treated as 0, selecting the x component of each texel to generate the result. Perform a texture gather operation as in textureGather by offset as described in textureOffset except that the offset can be variable (non constant) and the implementation-dependent minimum and maximum offset values are given by MIN_PROGRAM_TEXTURE_GATHER_OFFSET and MAX_PROGRAM_TEXTURE_GATHER_OFFSET, respectively. Operate identically to textureGatherOffset except that offsets is used to determine the location of the four texels to sample. Each of the four texels is obtained by applying the corresponding offset in offsets as a (u, v) coordinate offset to P, identifying the four-texel LINEAR footprint, and then selecting the texel i j of that footprint. The specified values in offsets must be constant integral expressions. The atomic-counter operations in this section operate atomically with respect to each other. They are atomic for any single counter, meaning any of these operations on a specific counter in one shader instantiation will be indivisible by any of these operations on the same counter from another shader instantiation. There is no guarantee that these operations are atomic with respect to other forms of access to the counter or that they are serialized when applied to separate counters. Such cases would require additional use of fences, barriers, or other forms of synchronization, if atomicity or serialization is desired. The underlying counter is a 32-bit unsigned integer. The result of operations will wrap to [0, 232-1].\n• increments the counter for c, and\n• returns its value prior to the increment operation. These two steps are done atomically with respect to the atomic counter functions in this table.\n• decrements the counter for c, and\n• returns the value resulting from the decrement operation. These two steps are done atomically with respect to the atomic counter functions in this table. Returns the counter value for c. Atomic memory functions perform atomic operations on an individual signed or unsigned integer stored in buffer object or shared variable storage. All of the atomic memory operations read a value from memory, compute a new value using one of the operations described below, write the new value to memory, and return the original value read, converted to the precision declared in the shader. Note that the operations are performed at the in-memory precision of the storage, which may differ from the precision declared in the shader. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written. Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable. All the built-in functions in this section accept arguments with combinations of restrict, coherent, and volatile memory qualification, despite not having them listed in the prototypes. The atomic operation will operate as required by the calling argument’s memory qualification, not by the built-in function’s formal parameter memory qualification. Computes a new value by adding the value of data to the contents mem. Computes a new value by taking the minimum of the value of data and the contents of mem. Computes a new value by taking the maximum of the value of data and the contents of mem. Computes a new value by performing a bit-wise AND of the value of data and the contents of mem. Computes a new value by performing a bit-wise OR of the value of data and the contents of mem. Computes a new value by performing a bit-wise EXCLUSIVE OR of the value of data and the contents of mem. Computes a new value by simply copying the value of data. Compares the value of compare and the contents of mem. If the values are equal, the new value is given by data; otherwise, it is taken from the original contents of mem. Variables using one of the image basic types may be used by the built-in shader image memory functions defined in this section to read and write individual texels of a texture. Each image variable references an image unit, which has a texture image attached. When image memory functions below access memory, an individual texel in the image is identified using an (i), (i, j), or (i, j, k) coordinate corresponding to the values of P. The coordinates are used to select an individual texel in the manner described in section 8.22 “Texture Image Loads and Stores” of the OpenGL ES Specification. Loads and stores support float, integer, and unsigned integer types. The data types below starting serve as placeholders meaning types starting either “image”, “iimage”, or “uimage” in the same way as \"gvec\" or \"gsampler\" in earlier sections. The IMAGE_PARAMS in the prototypes below is a placeholder representing 18 separate functions, each for a different type of image variable. The IMAGE_PARAMS placeholder is replaced by one of the following parameter lists: where each of the lines represents one of three different image variable types, and image, P specify the individual texel to operate on. The method for identifying the individual texel operated on from image, P, and the method for reading and writing the texel are specified in section 8.22 “Texture Image Loads and Stores” of the OpenGL ES Specification. The atomic functions perform operations on individual texels or samples of an image variable. Atomic memory operations read a value from the selected texel, compute a new value using one of the operations described below, write the new value to the selected texel, and return the original value read. The contents of the texel being updated by the atomic operation are guaranteed not to be modified by any other image store or atomic function between the time the original value is read and the time the new value is written. Atomic memory operations are supported on only a subset of all image variable types; image must be either:\n• a signed integer image variable (type starts “iimage”) and a format qualifier of r32i, used with a data argument of type int, or\n• an unsigned integer image variable (type starts “uimage”) and a format qualifier of r32ui, used with a data argument of type uint, or\n• a float image variable (type starts “image”) and a format qualifier of r32f, used with a data argument of type float (imageAtomicExchange only). All the built-in functions in this section accept arguments with combinations of restrict, coherent, and volatile memory qualification, despite not having them listed in the prototypes. The image operation will operate as required by the calling argument’s memory qualification, not by the built-in function’s formal parameter memory qualification. Returns the dimensions of the image or images bound to image. For arrayed images, the last component of the return value will hold the size of the array. Cube images only return the dimensions of one face, and the number of cubes in the cube map array, if arrayed.\n\n Note: The qualification readonly writeonly accepts a variable qualified with readonly, writeonly, both, or neither. It means the formal argument will be used for neither reading nor writing to the underlying memory. Loads the texel at the coordinate P from the image unit image (in IMAGE_PARAMS). When image and P identify a valid texel, the bits used to represent the selected texel in memory are converted to a vec4, ivec4, or uvec4 in the manner described in section 8.23 “Texture Image Loads and Stores” of the OpenGL ES Specification and returned. Stores data into the texel at the coordinate P from the image specified by image. When image and P identify a valid texel, the bits used to represent data are converted to the format of the image unit in the manner described in section 8.23 “Texture Image Loads and Stores” of the OpenGL ES Specification and stored to the specified texel. Computes a new value by adding the value of data to the contents of the selected texel. Computes a new value by taking the minimum of the value of data and the contents of the selected texel. Computes a new value by taking the maximum of the value data and the contents of the selected texel. Computes a new value by performing a bit-wise AND of the value of data and the contents of the selected texel. Computes a new value by performing a bit-wise OR of the value of data and the contents of the selected texel. Computes a new value by performing a bit-wise EXCLUSIVE OR of the value of data and the contents of the selected texel. Computes a new value by simply copying the value of data. Compares the value of compare and the contents of the selected texel. If the values are equal, the new value is given by data; otherwise, it is taken from the original value loaded from the texel. These functions are only available in geometry shaders. They are described in more depth following the table. Emits the current values of output variables to the current output primitive. On return from this call, the values of output variables are undefined. Completes the current output primitive and starts a new one. No vertex is emitted. The function EmitVertex() specifies that a vertex is completed. A vertex is added to the current output primitive using the current values of all built-in and user-defined output variables. The values of all output variables are undefined after a call to EmitVertex(). If a geometry shader invocation has emitted more vertices than permitted by the output layout qualifier max_vertices, the results of calling EmitVertex() are undefined. The function EndPrimitive() specifies that the current output primitive is completed and a new output primitive (of the same type) will be started by any subsequent EmitVertex(). This function does not emit a vertex. If the output layout is declared to be points, calling EndPrimitive() is optional. A geometry shader starts with an output primitive containing no vertices. When a geometry shader terminates, the current output primitive is automatically completed. It is not necessary to call EndPrimitive() if the geometry shader writes only a single primitive. Fragment processing functions are only available in fragment shaders. Derivatives may be computationally expensive and/or numerically unstable. Therefore, an implementation may approximate the true derivatives by using a fast but not entirely accurate derivative computation. Derivatives are undefined within non-uniform control flow. The expected behavior of a derivative is specified using forward/backward differencing. With single-sample rasterization, \\(dx \\leq 1.0\\) in equations 1b and 2b. For multisample rasterization, \\(dx < 2.0\\) in equations 1b and 2b. An implementation may use the above or other methods to perform the calculation, subject to the following conditions:\n• The method may use piecewise linear approximations. Such linear approximations imply that higher order derivatives, dFdx(dFdx(x)) and above, are undefined.\n• The method may assume that the function evaluated is continuous. Therefore derivatives within the body of a non-uniform conditional are undefined.\n• The method may differ per fragment, subject to the constraint that the method may vary by window coordinates, not screen coordinates. The invariance requirement described in section 13.2 “Invariance” of the OpenGL ES Specification, is relaxed for derivative calculations, because the method may be a function of fragment location. Other properties that are desirable, but not required, are:\n• Functions should be evaluated within the interior of a primitive (interpolated, not extrapolated).\n• Functions for dFdx should be evaluated while holding y constant. Functions for dFdy should be evaluated while holding x constant. However, mixed higher order derivatives, like dFdx(dFdy(y)) and dFdy(dFdx(x)) are undefined.\n• Derivatives of constant arguments should be 0. In some implementations, varying degrees of derivative accuracy may be obtained by providing GL hints (see section 19.1 “Hints” of the OpenGL ES Specification), allowing a user to make an image quality versus speed trade off. Returns the derivative in x using local differencing for the input argument p. Returns the derivative in y using local differencing for the input argument p.\n\n \n\n These two functions are commonly used to estimate the filter width used to anti-alias procedural textures. We are assuming that the expression is being evaluated in parallel on a SIMD array so that at any given point in time the value of the function is known at the grid points represented by the SIMD array. Local differencing between SIMD array elements can therefore be used to derive dFdx, dFdy, etc. Returns the sum of the absolute derivative in x and y using local differencing for the input argument p, i.e., abs(dFdx(p)) + abs(dFdy(p)); Built-in interpolation functions are available to compute an interpolated value of a fragment shader input variable at a shader-specified (x, y) location. A separate (x, y) location may be used for each invocation of the built-in function, and those locations may differ from the default (x, y) location used to produce the default value of the input. For all of the interpolation functions, interpolant must be an l-value from an in declaration; this can include a variable, an anonymous block member, an array element, or some combination of these. Component selection operators (e.g. .xy), and field selection operators may not be used when specifying interpolant. Arrayed inputs can be indexed with general (nonuniform) integer expressions. If interpolant is declared with the flat qualifier, the interpolated value will have the same value everywhere for a single primitive, so the location used for interpolation has no effect and the functions just return that same value. If interpolant is declared with the centroid qualifier, the value returned by interpolateAtSample() and interpolateAtOffset() will be evaluated at the specified location, ignoring the location normally used with the centroid qualifier. Returns the value of the input interpolant sampled at a location inside both the pixel and the primitive being processed. The value obtained would be the same value assigned to the input variable if declared with the centroid qualifier. Returns the value of the input interpolant variable at the location of sample number sample. If multisample buffers are not available, the input variable will be evaluated at the center of the pixel. If sample sample does not exist, the position used to interpolate the input variable is undefined. Returns the value of the input interpolant variable sampled at an offset from the center of the pixel specified by offset. The two floating-point components of offset, give the offset in pixels in the x and y directions, respectively.\n\n An offset of (0, 0) identifies the center of the pixel. The range and granularity of offsets supported by this function is implementation-dependent. The shader invocation control function is only available in tessellation control and compute shaders. It is used to control the relative execution order of multiple shader invocations used to process a patch (in the case of tessellation control shaders) or a workgroup (in the case of compute shaders), which are otherwise executed with an undefined relative order. For any given static instance of barrier(), all tessellation control shader invocations for a single input patch must enter it before any will be allowed to continue beyond it, or all compute shader invocations for a single workgroup must enter it before any will continue beyond it. The function barrier() provides a partially defined order of execution between shader invocations. The ensures that, for some types of memory accesses, values written by one invocation prior to a given static instance of barrier() can be safely read by other invocations after their call to the same static instance barrier(). Because invocations may execute in an undefined order between these barrier calls, the values of a per-vertex or per-patch output variable for tessellation control shaders, or the values of shared variables for compute shaders will be undefined in a number of cases enumerated in “Output Variables” (for tessellation control shaders) and “Shared Variables” (for compute shaders). For tessellation control shaders, the barrier() function may only be placed inside the function main() of the shader and may not be called within any control flow. Barriers are also disallowed after a return statement in the function main(). Any such misplaced barriers result in a compile-time error. A barrier() affects control flow but only synchronizes memory accesses to shared variables and tessellation control output variables. For other memory accesses, it does not ensure that values written by one invocation prior to a given static instance of barrier() can be safely read by other invocations after their call to the same static instance of barrier(). To achieve this requires the use of both barrier() and a memory barrier. For compute shaders, the barrier() function may be placed within control flow, but that control flow must be uniform control flow. That is, all the controlling expressions that lead to execution of the barrier must be dynamically uniform expressions. This ensures that if any shader invocation enters a conditional statement, then all invocations will enter it. While compilers are encouraged to give warnings if they can detect this might not happen, compilers cannot completely determine this. Hence, it is the author’s responsibility to ensure barrier() only exists inside uniform control flow. Otherwise, some shader invocations will stall indefinitely, waiting for a barrier that is never reached by other invocations. Within a single shader invocation, the visibility and order of writes made by that invocation are well-defined. However, the relative order of reads and writes to a single shared memory address from multiple separate shader invocations is largely undefined. Additionally, the order of accesses to multiple memory addresses performed by a single shader invocation, as observed by other shader invocations, is also undefined. The following built-in functions can be used to control the ordering of reads and writes: Control the ordering of memory transactions issued by a single shader invocation. Control the ordering of accesses to atomic-counter variables issued by a single shader invocation. Control the ordering of memory transactions to buffer variables issued within a single shader invocation. Control the ordering of memory transactions to shared variables issued within a single shader invocation, as viewed by other invocations in the same workgroup.\n\n Only available in compute shaders. Control the ordering of memory transactions to images issued within a single shader invocation. Control the ordering of all memory transactions issued within a single shader invocation, as viewed by other invocations in the same workgroup.\n\n Only available in compute shaders. The memory barrier built-in functions can be used to order reads and writes to variables stored in memory accessible to other shader invocations. When called, these functions will wait for the completion of all reads and writes previously performed by the caller that access selected variable types, and then return with no other effect. The built-in functions memoryBarrierAtomicCounter(), memoryBarrierBuffer(), memoryBarrierImage(), and memoryBarrierShared() wait for the completion of accesses to atomic counter, buffer, image, and shared variables, respectively. The built-in functions memoryBarrier() and groupMemoryBarrier() wait for the completion of accesses to all of the above variable types. The functions memoryBarrierShared() and groupMemoryBarrier() are available only in compute shaders; the other functions are available in all shader types. When these functions return, the effects of any memory stores performed using coherent variables prior to the call will be visible to any future1 coherent access to the same memory performed by any other shader invocation. In particular, the values written this way in one shader stage are guaranteed to be visible to coherent memory accesses performed by shader invocations in subsequent stages when those invocations were triggered by the execution of the original shader invocation (e.g. fragment shader invocations for a primitive resulting from a particular geometry shader invocation). An access is only a future access if a happens-before relation can be established between the store and the load. Additionally, memory barrier functions order stores performed by the calling invocation, as observed by other shader invocations. Without memory barriers, if one shader invocation performs two stores to coherent variables, a second shader invocation might see the values written by the second store prior to seeing those written by the first. However, if the first shader invocation calls a memory barrier function between the two stores, selected other shader invocations will never see the results of the second store before seeing those of the first. When using the functions groupMemoryBarrier() or memoryBarrierShared(), this ordering guarantee applies only to other shader invocations in the same compute shader workgroup; all other memory barrier functions provide the guarantee to all other shader invocations. No memory barrier is required to guarantee the order of memory stores as observed by the invocation performing the stores; an invocation reading from a variable that it previously wrote will always see the most recently written value unless another shader invocation also wrote to the same memory. Subpass-input functions are only available when targeting a Vulkan fragment stage. Subpass inputs are read through the built-in functions below. The is again a placeholder for either nothing, , or , indicating either a floating-point, signed integer, or unsigned integer, and these must match between argument type and return type. Read from a subpass input, from the implicit location (x, y, layer) of the current fragment coordinate."
    },
    {
        "link": "https://registry.khronos.org/OpenGL/specs/es/3.2/GLSL_ES_Specification_3.20.pdf",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/19664928/opengl-3-2-cache-compiled-shaders",
        "document": "Is there any way to cache compiled shader programs using OpenGL 3.2?\n\nI've looked at ARB_get_program_binary but found my driver does not support it.\n\nI'd like to be as compatible with older cards as possible so switching to OpenGL 4 is not a good solution.\n\nI'm working with Qt5.1 and using QOpenGLFunctions_3_2_Core to access OpenGL functions."
    },
    {
        "link": "https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/BestPracticesforShaders/BestPracticesforShaders.html",
        "document": "Shaders provide great flexibility, but they can also be a significant bottleneck if you perform too many calculations or perform them inefficiently.\n\nCreating a shader program is an expensive operation compared to other OpenGL ES state changes. Compile, link, and validate your programs when your app is initialized. Once you’ve created all your shaders, the app can efficiently switch between them by calling . Reading diagnostic information after compiling or linking a shader program is not necessary in a Release build of your app and can reduce performance. Use OpenGL ES functions to read shader compile or link logs only in development builds of your app, as shown in Listing 10-1. // Check the status of the compile/link // Show any errors as appropriate Similarly, you should call the function only in development builds. You can use this function to find development errors such as failing to bind all texture units required by a shader program. But because validating a program checks it against the entire OpenGL ES context state, it is an expensive operation. Since the results of program validation are only meaningful during development, you should not call this function in Release builds of your app. Use Separate Shader Objects to Speed Compilation and Linking Many OpenGL ES apps use several vertex and fragment shaders, and it is often useful to reuse the same fragment shader with different vertex shaders or vice versa. Because the core OpenGL ES specification requires a vertex and fragment shader to be linked together in a single shader program, mixing and matching shaders results in a large number of programs, increasing the total shader compile and link time when you initialize your app. OpenGL ES 2.0 and 3.0 contexts on iOS support the extension. You can use the functions provided by this extension to compile vertex and fragment shaders separately, and to mix and match precompiled shader stages at render time using program pipeline objects. Additionally, this extension provides a simplified interface for compiling and using shaders, shown in Listing 10-2. // Compile and link the separate vertex shader program, then read its uniform variable locations // Compile and link the separate fragment shader program (which uses no uniform variables) // Construct a program pipeline object and configure it to use the shaders // Use the previously constructed program pipeline and set uniform contents in shader programs\n\nPrecision hints were added to the GLSL ES language specification to address the need for compact shader variables that match the smaller hardware limits of embedded devices. Each shader must specify a default precision; individual shader variables may override this precision to provide hints to the compiler on how that variable is used in your app. An OpenGL ES implementation is not required to use the hint information, but may do so to generate more efficient shaders. The GLSL ES specification lists the range and precision for each hint. Important: The range limits defined by the precision hints are not enforced. You cannot assume your data is clamped to this range.\n• None When in doubt, default to high precision.\n• None Colors in the to range can usually be represented using low precision variables.\n• None Position data should usually be stored as high precision.\n• None Normals and vectors used in lighting calculations can usually be stored as medium precision.\n• None After reducing precision, retest your app to ensure that the results are what you expect. Listing 10-3 defaults to high precision variables, but calculates the color output using low precision variables because higher precision is not necessary. The actual precision of shader variables can vary between different iOS devices, as can the performance of operations at each level of precision. Refer to the iOS Device Compatibility Reference for device-specific considerations.\n\nNot all graphics processors include vector processors; they may perform vector calculations on a scalar processor. When performing calculations in your shader, consider the order of operations to ensure that the calculations are performed efficiently even if they are performed on a scalar processor. If the code in Listing 10-4 were executed on a vector processor, each multiplication would be executed in parallel across all four of the vector’s components. However, because of the location of the parenthesis, the same operation on a scalar processor would take eight multiplications, even though two of the three parameters are scalar values. The same calculation can be performed more efficiently by shifting the parentheses as shown in Listing 10-5. In this example, the scalar values are multiplied together first, and the result multiplied against the vector parameter; the entire operation can be calculated with five multiplications. Similarly, your app should always specify a write mask for a vector operation if it does not use all of the components of the result. On a scalar processor, calculations for components not specified in the mask can be skipped. Listing 10-6 runs twice as fast on a scalar processor because it specifies that only two components are needed.\n\nUse Uniforms or Constants Instead of Computing Values in a Shader Whenever a value can be calculated outside the shader, pass it into the shader as a uniform or a constant. Recalculating dynamic values can potentially be very expensive in a shader. Branches are discouraged in shaders, as they can reduce the ability to execute operations in parallel on 3D graphics processors (although this performance cost is reduced on OpenGL ES 3.0–capable devices). Your app may perform best if you avoid branching entirely. For example, instead of creating a large shader with many conditional options, create smaller shaders specialized for specific rendering tasks. There is a tradeoff between reducing the number of branches in your shaders and increasing the number of shaders you create. Test different options and choose the fastest solution. If your shaders must use branches, follow these recommendations:\n• None Best performance: Branch on a constant known when the shader is compiled.\n• None Potentially slow: Branch on a value computed inside the shader. You can eliminate many loops by either unrolling the loop or using vectors to perform operations. For example, this code is very inefficient: The same operation can be done directly using a component-wise add: When you cannot eliminate a loop, it is preferred that the loop have a constant limit to avoid dynamic branches. Using indices computed in the shader is more expensive than a constant or uniform array index. Accessing uniform arrays is usually cheaper than accessing temporary arrays. Dynamic texture lookups, also known as dependent texture reads, occur when a fragment shader computes texture coordinates rather than using the unmodified texture coordinates passed into the shader. Dependent texture reads are supported at no performance cost on OpenGL ES 3.0–capable hardware; on other devices, dependent texture reads can delay loading of texel data, reducing performance. When a shader has no dependent texture reads, the graphics hardware may prefetch texel data before the shader executes, hiding some of the latency of accessing memory. Listing 10-7 shows a fragment shader that calculates new texture coordinates. The calculation in this example can easily be performed in the vertex shader, instead. By moving the calculation to the vertex shader and directly using the vertex shader’s computed texture coordinates, you avoid the dependent texture read. Note: It may not seem obvious, but any calculation on the texture coordinates counts as a dependent texture read. For example, packing multiple sets of texture coordinates into a single varying parameter and using a swizzle command to extract the coordinates still causes a dependent texture read.\n\nTraditional OpenGL and OpenGL ES implementations provide a fixed-function blending stage, illustrated in Figure 10-1. Before issuing a draw call, you specify a blending operation from a fixed set of possible parameters. After your fragment shader outputs color data for a pixel, the OpenGL ES blending stage reads color data for the corresponding pixel in the destination framebuffer, then combines the two according to the specified blending operation to produce an output color. In iOS 6.0 and later, you can use the extension to implement programmable blending and other effects. Instead of supplying a source color to be blended by OpenGL ES, your fragment shader reads the contents of the destination framebuffer corresponding to the fragment being processed. Your fragment shader can then use whatever algorithm you choose to produce an output color, as shown in Figure 10-2.\n• None Additional blending modes. By defining your own GLSL ES functions for combining source and destination colors, you can implement blending modes not possible with the OpenGL ES fixed-function blending stage. For example, Listing 10-8 implements the Overlay and Difference blending modes found in popular graphics software.\n• None Post-processing effects. After rendering a scene, you can draw a full-screen quad using a fragment shader that reads the current fragment color and transforms it to produce an output color. The shader in Listing 10-9 can be used with this technique to convert a scene to grayscale.\n• None Non-color fragment operations. Framebuffers may contain non-color data. For example, deferred shading algorithms use multiple render targets to store depth and normal information. Your fragment shader can read such data from one (or more) render targets and use them to produce an output color in another render target. These effects are possible without the framebuffer fetch extension—for example, grayscale conversion can be done by rendering a scene into a texture, then drawing a full-screen quad using that texture and a fragment shader that converts texel colors to grayscale. However, using this extension generally results in better performance. To enable this feature, your fragment shader must declare that it requires the extension, as shown in Listing 10-8 and Listing 10-9. The shader code to implement this feature differs between versions of the OpenGL ES Shading Language (GLSL ES). For OpenGL ES 2.0 contexts and OpenGL ES 3.0 contexts not using shaders, you use the builtin variable for fragment shader output and the builtin variable to read framebuffer data, as illustrated in Listing 10-8. In GLSL ES 3.0, you use user-defined variables declared with the qualifier for fragment shader outputs. If you declare a fragment shader output variable with the qualifier, it will contain framebuffer data when the fragment shader executes. Listing 10-9 illustrates a grayscale post-processing technique using an variable.\n\nUse Textures for Larger Memory Buffers in Vertex Shaders In iOS 7.0 and later, vertex shaders can read from currently bound texture units. Using this technique you can access much larger memory buffers during vertex processing, enabling high performance for some advanced rendering techniques. For example:\n• None Displacement mapping. Draw a mesh with default vertex positions, then read from a texture in the vertex shader to alter the position of each vertex. Listing 10-10 demonstrates using this technique to generate three-dimensional geometry from a grayscale height map texture.\n• None Instanced drawing. As described in Use Instanced Drawing to Minimize Draw Calls, instanced drawing can dramatically reduce CPU overhead when rendering a scene that contains many similar objects. However, providing per-instance information to the vertex shader can be a challenge. A texture can store extensive information for many instances. For example, you could render a vast cityscape by drawing hundreds of instances from vertex data describing only a simple cube. For each instance, the vertex shader could use the variable to sample from a texture, obtaining a transformation matrix, color variation, texture coordinate offset, and height variation to apply to each building. // Use the vertex X and Z values to look up a Y value in the texture. // Put the X and Z values into their places in the position vector. // Transform the position vector from model to clip space. You can also use uniform arrays and uniform buffer objects (in OpenGL ES 3.0) to provide bulk data to a vertex shader, but vertex texture access offers several potential advantages. You can store much more data in a texture than in either a uniform array or uniform buffer object, and you can use texture wrapping and filtering options to interpolate the data stored in a texture. Additionally, you can render to a texture, taking advantage of the GPU to produce data for use in a later vertex processing stage. To determine whether vertex texture sampling is available on a device (and the number of texture units available to vertex shaders), check the value of the limit at run time. (See Verifying OpenGL ES Capabilities.)"
    },
    {
        "link": "https://docs.nvidia.com/drive/drive-os-5.2.0.0L/drive-os/DRIVE_OS_Linux_SDK_Development_Guide/baggage/GLSL_ES_Specification_3.20.withchanges.pdf",
        "document": ""
    }
]