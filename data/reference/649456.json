[
    {
        "link": "https://guava.dev/releases/23.0/api/docs/com/google/common/collect/ImmutableMap.html",
        "document": "\n• whose keys and values are the result of applying the provided mapping functions to the input elements. Entries appear in the result in encounter order. Returns a that accumulates elements into anwhose keys and values are the result of applying the provided mapping functions to the input elements. Entries appear in the resultin encounter order. If the mapped keys contain duplicates (according to , an is thrown when the collection operation is performed. (This differs from the returned by , which throws an .)\n• whose keys and values are the result of applying the provided mapping functions to the input elements. Returns a that accumulates elements into anwhose keys and values are the result of applying the provided mapping functions to the input elements. If the mapped keys contain duplicates (according to ), the values are merged using the specified merging function. Entries will appear in the encounter order of the first occurrence of the key.\n• Returns the empty map. This map behaves and performs comparably to , and is preferable mainly for consistency and maintainability of your code.\n• Returns an immutable map containing a single entry. This map behaves and performs comparably to but will not accept a null key or value. It is preferable mainly for consistency and maintainability of your code.\n• Returns an immutable map containing the given entries, in order.\n• Returns an immutable map containing the given entries, in order.\n• Returns an immutable map containing the given entries, in order.\n• Returns an immutable map containing the given entries, in order.\n• Returns a new builder. The generated builder is equivalent to the builder created by the constructor.\n• . The returned map iterates over entries in the same order as the of the original map. If somehow contains entries with duplicate keys (for example, if it is a whose comparator is not consistent with equals), the results of this method are undefined. Returns an immutable map containing the same entries as. The returned map iterates over entries in the same order as theof the original map. Ifsomehow contains entries with duplicate keys (for example, if it is awhose comparator is not), the results of this method are undefined. Despite the method name, this method attempts to avoid actually copying the data when it is safe to do so. The exact circumstances under which a copy will or will not be performed are undocumented and subject to change. - if any key or value in is null\n• Returns an immutable map containing the specified entries. The returned map iterates over entries in the same order as the original iterable. - if any key, value, or entry is null - if two entries have the same key\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Returns an immutable set of the mappings in this map. The iteration order is specified by the method used to create this map. Typically, this is insertion order.\n• Returns an immutable set of the keys in this map, in the same order that they appear in\n• Returns an immutable collection of the values in this map, in the same order that they appear in"
    },
    {
        "link": "https://guava.dev/releases/21.0/api/docs/com/google/common/collect/ImmutableMap.html",
        "document": "\n• whose keys and values are the result of applying the provided mapping functions to the input elements. Entries appear in the result in encounter order. Returns a that accumulates elements into anwhose keys and values are the result of applying the provided mapping functions to the input elements. Entries appear in the resultin encounter order. If the mapped keys contain duplicates (according to , an is thrown when the collection operation is performed. (This differs from the returned by , which throws an .)\n• whose keys and values are the result of applying the provided mapping functions to the input elements. Returns a that accumulates elements into anwhose keys and values are the result of applying the provided mapping functions to the input elements. If the mapped keys contain duplicates (according to ), the values are merged using the specified merging function. Entries will appear in the encounter order of the first occurrence of the key.\n• Returns the empty map. This map behaves and performs comparably to , and is preferable mainly for consistency and maintainability of your code.\n• Returns an immutable map containing a single entry. This map behaves and performs comparably to but will not accept a null key or value. It is preferable mainly for consistency and maintainability of your code.\n• Returns an immutable map containing the given entries, in order.\n• Returns an immutable map containing the given entries, in order.\n• Returns an immutable map containing the given entries, in order.\n• Returns an immutable map containing the given entries, in order.\n• Returns a new builder. The generated builder is equivalent to the builder created by the constructor.\n• . If somehow contains entries with duplicate keys (for example, if it is a whose comparator is not consistent with equals), the results of this method are undefined. Returns an immutable map containing the same entries as. Ifsomehow contains entries with duplicate keys (for example, if it is awhose comparator is not), the results of this method are undefined. Despite the method name, this method attempts to avoid actually copying the data when it is safe to do so. The exact circumstances under which a copy will or will not be performed are undocumented and subject to change. - if any key or value in is null\n• Returns an immutable map containing the specified entries. The returned map iterates over entries in the same order as the original iterable. - if any key, value, or entry is null - if two entries have the same key\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Returns an immutable set of the mappings in this map. The entries are in the same order as the parameters used to build this map.\n• Returns an immutable set of the keys in this map. These keys are in the same order as the parameters used to build this map.\n• Returns an immutable collection of the values in this map. The values are in the same order as the parameters used to build this map."
    },
    {
        "link": "https://guava.dev/releases/21.0-rc2/api/docs/com/google/common/collect/ImmutableMap.html",
        "document": "\n• whose keys and values are the result of applying the provided mapping functions to the input elements. Entries appear in the result in encounter order. Returns a that accumulates elements into anwhose keys and values are the result of applying the provided mapping functions to the input elements. Entries appear in the resultin encounter order. If the mapped keys contain duplicates (according to , an is thrown when the collection operation is performed. (This differs from the returned by , which throws an .)\n• whose keys and values are the result of applying the provided mapping functions to the input elements. Returns a that accumulates elements into anwhose keys and values are the result of applying the provided mapping functions to the input elements. If the mapped keys contain duplicates (according to ), the values are merged using the specified merging function. Entries will appear in the encounter order of the first occurrence of the key.\n• Returns the empty map. This map behaves and performs comparably to , and is preferable mainly for consistency and maintainability of your code.\n• Returns an immutable map containing a single entry. This map behaves and performs comparably to but will not accept a null key or value. It is preferable mainly for consistency and maintainability of your code.\n• Returns an immutable map containing the given entries, in order.\n• Returns an immutable map containing the given entries, in order.\n• Returns an immutable map containing the given entries, in order.\n• Returns an immutable map containing the given entries, in order.\n• Returns a new builder. The generated builder is equivalent to the builder created by the constructor.\n• . If somehow contains entries with duplicate keys (for example, if it is a whose comparator is not consistent with equals), the results of this method are undefined. Returns an immutable map containing the same entries as. Ifsomehow contains entries with duplicate keys (for example, if it is awhose comparator is not), the results of this method are undefined. Despite the method name, this method attempts to avoid actually copying the data when it is safe to do so. The exact circumstances under which a copy will or will not be performed are undocumented and subject to change. - if any key or value in is null\n• Returns an immutable map containing the specified entries. The returned map iterates over entries in the same order as the original iterable. - if any key, value, or entry is null - if two entries have the same key\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Guaranteed to throw an exception and leave the map unmodified.\n• Returns an immutable set of the mappings in this map. The entries are in the same order as the parameters used to build this map.\n• Returns an immutable set of the keys in this map. These keys are in the same order as the parameters used to build this map.\n• Returns an immutable collection of the values in this map. The values are in the same order as the parameters used to build this map."
    },
    {
        "link": "https://stackoverflow.com/questions/23344915/serializing-guavas-immutabletable",
        "document": "I am using the version 17.0 of Guava, especially the new collection types. While trying to write an through a , I realized that the class and its concrete implementations do not seem to be serializable.\n\nHowever, the two following tickets seem to indicate that the developers are aware of the issue:\n\nDo any of you serialize classes containing attributes? How could I do this, without resorting to using a of s?"
    },
    {
        "link": "https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableMap.java",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/13623175/deserialize-to-an-immutablemap-with-gson",
        "document": "I'd like to use GSON to derialize:\n\nI thought I'd just use regular GSON map parsing, then make an immutable copy of the result, like this:\n\nBut as expected, that was too simple (there is no type information). I get the error:\n\nCan I do what I want?"
    },
    {
        "link": "https://stackoverflow.com/questions/9110677/readresolve-not-working-an-instance-of-guavas-serializedform-appears",
        "document": "During deserialization of one of our data structure (using the default mechanism (no custom writeObject/readObject)), an instance of ImmutableMap$SerializedForm (from google's Guava library) shows up.\n\nSuch an instance should not be visible from clients of guava because instances of SerializedForm are replaced using readResolve (see for example \"writeReplace\" in class com.google.common.collect.ImmutableMap).\n\nHence deserialization fails with the following message :\n\nThis is right since ImmutableMap$SerializedForm is not a subtype of java.util.Map, yet it should have been replaced. What is going wrong ?\n\nWe have no custom writeObject/readObject in class com.blah.C. We do have custom serialization code in parent objects (that contain com.blah.C).\n\nupdate, here's the top of the stacktrace:"
    },
    {
        "link": "https://guava.dev/releases/25.1-jre/api/docs/com/google/common/collect/ImmutableMap.html",
        "document": "\n• whose keys and values are the result of applying the provided mapping functions to the input elements. Entries appear in the result in encounter order. Returns a that accumulates elements into anwhose keys and values are the result of applying the provided mapping functions to the input elements. Entries appear in the resultin encounter order. If the mapped keys contain duplicates (according to , an is thrown when the collection operation is performed. (This differs from the returned by , which throws an .)\n• whose keys and values are the result of applying the provided mapping functions to the input elements. Returns a that accumulates elements into anwhose keys and values are the result of applying the provided mapping functions to the input elements. If the mapped keys contain duplicates (according to ), the values are merged using the specified merging function. Entries will appear in the encounter order of the first occurrence of the key.\n• Returns the empty map. This map behaves and performs comparably to , and is preferable mainly for consistency and maintainability of your code.\n• Returns an immutable map containing a single entry. This map behaves and performs comparably to but will not accept a null key or value. It is preferable mainly for consistency and maintainability of your code.\n• Returns an immutable map containing the given entries, in order.\n• Returns an immutable map containing the given entries, in order.\n• Returns an immutable map containing the given entries, in order.\n• Returns an immutable map containing the given entries, in order.\n• Returns a new builder. The generated builder is equivalent to the builder created by the constructor.\n• Returns a new builder, expecting the specified number of entries to be added. If is exactly the number of entries added to the builder before is called, the builder is likely to perform better than an unsized would have. It is not specified if any performance benefits apply if is close to, but not exactly, the number of entries added to the builder.\n• . The returned map iterates over entries in the same order as the of the original map. If somehow contains entries with duplicate keys (for example, if it is a whose comparator is not consistent with equals), the results of this method are undefined. Returns an immutable map containing the same entries as. The returned map iterates over entries in the same order as theof the original map. Ifsomehow contains entries with duplicate keys (for example, if it is awhose comparator is not), the results of this method are undefined. Despite the method name, this method attempts to avoid actually copying the data when it is safe to do so. The exact circumstances under which a copy will or will not be performed are undocumented and subject to change. - if any key or value in is null\n• Returns an immutable map containing the specified entries. The returned map iterates over entries in the same order as the original iterable. - if any key, value, or entry is null - if two entries have the same key\n• Guaranteed to throw an exception and leave the map unmodified. - key with which the specified value is to be associated - value to be associated with the specified key the previous value associated with , or if there was no mapping for . (A return can also indicate that the map previously associated with , if the implementation supports values.)\n• Guaranteed to throw an exception and leave the map unmodified. - key with which the specified value is to be associated - value to be associated with the specified key the previous value associated with the specified key, or if there was no mapping for the key. (A return can also indicate that the map previously associated with the key, if the implementation supports null values.)\n• Guaranteed to throw an exception and leave the map unmodified. - key with which the specified value is associated - value expected to be associated with the specified key - value to be associated with the specified key if the value was replaced\n• Guaranteed to throw an exception and leave the map unmodified. - key with which the specified value is associated - value to be associated with the specified key the previous value associated with the specified key, or if there was no mapping for the key. (A return can also indicate that the map previously associated with the key, if the implementation supports null values.)\n• Guaranteed to throw an exception and leave the map unmodified. - key with which the specified value is to be associated - the function to compute a value the current (existing or computed) value associated with the specified key, or null if the computed value is null\n• Guaranteed to throw an exception and leave the map unmodified. - key with which the specified value is to be associated - the function to compute a value the new value associated with the specified key, or null if none\n• Guaranteed to throw an exception and leave the map unmodified. - key with which the specified value is to be associated - the function to compute a value the new value associated with the specified key, or null if none\n• Guaranteed to throw an exception and leave the map unmodified. - key with which the resulting value is to be associated - the non-null value to be merged with the existing value associated with the key or, if no existing value or a null value is associated with the key, to be associated with the key - the function to recompute a value if present the new value associated with the specified key, or null if no value is associated with the key\n• Guaranteed to throw an exception and leave the map unmodified. - mappings to be stored in this map\n• Guaranteed to throw an exception and leave the map unmodified. - the function to apply to each entry\n• Guaranteed to throw an exception and leave the map unmodified. - key whose mapping is to be removed from the map the previous value associated with , or if there was no mapping for .\n• Guaranteed to throw an exception and leave the map unmodified. - key with which the specified value is associated - value expected to be associated with the specified key if the value was removed\n• Guaranteed to throw an exception and leave the map unmodified.\n• Returns if this map contains no key-value mappings. if this map contains no key-value mappings\n• Returns if this map contains a mapping for the specified key. More formally, returns if and only if this map contains a mapping for a key such that . (There can be at most one such mapping.) - key whose presence in this map is to be tested if this map contains a mapping for the specified key\n• Returns if this map maps one or more keys to the specified value. More formally, returns if and only if this map contains at least one mapping to a value such that . This operation will probably require time linear in the map size for most implementations of the interface. - value whose presence in this map is to be tested if this map maps one or more keys to the specified value\n• if this map contains no mapping for the key. Returns the value to which the specified key is mapped, orif this map contains no mapping for the key. More formally, if this map contains a mapping from a key to a value such that , then this method returns ; otherwise it returns . (There can be at most one such mapping.) If this map permits null values, then a return value of does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to . The operation may be used to distinguish these two cases. - the key whose associated value is to be returned the value to which the specified key is mapped, or if this map contains no mapping for the key\n• Returns the value to which the specified key is mapped, or if this map contains no mapping for the key. - the key whose associated value is to be returned - the default mapping of the key the value to which the specified key is mapped, or if this map contains no mapping for the key 21.0 (but only since 23.5 in the Android flavor). Note, however, that Java 8 users can call this method with any version and flavor of Guava.\n• Returns an immutable set of the mappings in this map. The iteration order is specified by the method used to create this map. Typically, this is insertion order. a set view of the mappings contained in this map\n• Returns an immutable set of the keys in this map, in the same order that they appear in a set view of the keys contained in this map\n• Returns an immutable collection of the values in this map, in the same order that they appear in a collection view of the values contained in this map\n• Indicates whether some other object is \"equal to\" this one. The method implements an equivalence relation on non-null object references:\n• It is reflexive: for any non-null reference value , should return .\n• It is symmetric: for any non-null reference values and , should return if and only if returns .\n• It is transitive: for any non-null reference values , , and , if returns and returns , then should return .\n• It is consistent: for any non-null reference values and , multiple invocations of consistently return or consistently return , provided no information used in comparisons on the objects is modified.\n• For any non-null reference value , should return . The method for class implements the most discriminating possible equivalence relation on objects; that is, for any non-null reference values and , this method returns if and only if and refer to the same object ( has the value ). Note that it is generally necessary to override the method whenever this method is overridden, so as to maintain the general contract for the method, which states that equal objects must have equal hash codes. - the reference object with which to compare. if this object is the same as the obj argument; otherwise.\n• Returns a hash code value for the object. This method is supported for the benefit of hash tables such as those provided by The general contract of is:\n• Whenever it is invoked on the same object more than once during an execution of a Java application, the method must consistently return the same integer, provided no information used in comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.\n• If two objects are equal according to the method, then calling the method on each of the two objects must produce the same integer result.\n• It is not required that if two objects are unequal according to the method, then calling the method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables. As much as is reasonably practical, the hashCode method defined by class does return distinct integers for distinct objects. (This is typically implemented by converting the internal address of the object into an integer, but this implementation technique is not required by the Java™ programming language.) a hash code value for this object.\n• method returns a string that \"textually represents\" this object. The result should be a concise but informative representation that is easy for a person to read. It is recommended that all subclasses override this method. Returns a string representation of the object. In general, themethod returns a string that \"textually represents\" this object. The result should be a concise but informative representation that is easy for a person to read. It is recommended that all subclasses override this method. The method for class returns a string consisting of the name of the class of which the object is an instance, the at-sign character ` ', and the unsigned hexadecimal representation of the hash code of the object. In other words, this method returns a string equal to the value of:"
    },
    {
        "link": "https://groups.google.com/g/guava-discuss/c/6uC0IySW0rM",
        "document": "Sign in to reply to author You do not have permission to delete messages in this group Either email addresses are anonymous for this group or you need the view member email addresses permission to view the original message \n\nSerializedFrom is used to create a builder, which is then used to \n\nre-construct the deserialised object from the SerializedForm which all \n\nsubclasses use. Looking at ImmutableMap, you already use a very similar pattern, theSerializedFrom is used to create a builder, which is then used tore-construct the deserialised object from the SerializedForm which allsubclasses use. It's almost there, you almost solved it, however the implementation is \n\nstill locked into SerializedForm. If you re-factored it and moved \n\nSerializedFrom to be the Builder's SerializedFrom, then you remove the \n\ndependency. When you use the builder as the serialized form, if you don't like the \n\nserialized form of the builder, create a new builder (with a new class \n\nname). The builder is responsible for the creation of your \n\nImmutableMap, and serialization is akin to a constructor, the remote jvm \n\ndoesn't deserialise ImmutableMap.SerializedForm, it deserialises the \n\nBuilder, which creates ImmutableMap. Have a depreciation period for the old builder, then an old version of \n\nyour ImmutableMap sends an old builder, via serialization, it still \n\ncreates an ImmutableMap, during deserialisation. Then when a later \n\nversion sends you the new builder, it too creates an ImmutableMap during \n\ndeserialization. You can of course now support two completely different \n\nand separate serial forms of your classes. Then when you resend both ImmutableMap instances (via serialization), \n\nonly the new builder instance is sent. This is forward or evolution compatible. You don't always have to \n\nreplace the builder, but it's nice to know the option's there. Now if someone want's backward compatibility as well, the tricky part, \n\nprovided your new builder uses a new class name which doesn't collide \n\nwith any classes in the old name space. They can use an RMI codebase \n\nannotation, the code is then dynamically downloaded to the jvm that has \n\nthe old version of the library, it loads the class file for the new \n\nbuilder and builds an ImmutableMap. This makes it possible to perform a hot upgrades, transferring state \n\nfrom one jvm to another, then if it something goes wrong, roll back to \n\nthe known working state. In a distributed environment, where you can't guarantee the recipient \n\nhas the same class version, you'd treat these classes as though they \n\nwere not serialiseable, which is no great hassle, it just means that if \n\nyou use dependency injection, you're going to have to add the dependency \n\nin order to rebuild it at the remote end, rather than rely on \n\nserialising the field directly. The dependency injection could be fixed by creating wrapper used to \n\nencapsulate the dependency, that becomes responsible for serialisation. Distributed programming is an order of magnitude more difficult, but I'm \n\nworking out ways to make it easier, fitting within the limitations of \n\nthe jvm. We have a test framework that makes it possible to test this type of \n\nserialisation, but I can see why you gave up on serialisation compatibility. Louis Wasserman wrote:\n\n> +1 on putting a patch for this in 10.1.\n\n> -1 on making any guarantee, now or ever, as to serialization \n\n> compatibility between Guava releases.\n\n>\n\n> Louis Wasserman\n\n\n\nSign in to reply to author You do not have permission to delete messages in this group Either email addresses are anonymous for this group or you need the view member email addresses permission to view the original message Louis Wasserman wrote:\n\n> In all fairness, making this change would require that Guava continue \n\n> to support version-compatible serialization for all eternity -- even \n\n> if Peter is writing the original patch, this would require significant \n\n> work on the part of the Guava maintainers in the future. Not really, it's actually no work to change the class if your builder \n\nhasn't changed, since serialisation is no longer it's concern. Although \n\nthe builder implementations should be package private and separate (not \n\na static class), so the client doesn't end up depending on the \n\nimplementation, then you can change it at will. You can also completely remove a class, leave the package private \n\nbuilder implementation behind and have it create another class instead \n\nthat implements the same interface or abstract class, and the client \n\ndoesn't even know, he/she's just been upgraded to a new implementation. \n\nThen when the new implementation is serialised it uses a new builder \n\nimplementation, then after a few versions, remove the old builder, only \n\nsupport upgrades to the next release version if you want, this reduces \n\nthe testing burden and allows a migration path. For testing, because the new serial form is in a new builder, you just \n\ntest each builder deserialises the expected implementation, yes it's \n\neasier to test too, you don't need the old classes, because the old \n\nbuilders fields haven't changed, just their build target. Serialisation \n\nis decoupled. Or your existing implementations can change builder, it's just about \n\ndecoupling dependencies, you'd do it for any other code would you not? \n\nDidn't Google invent Guice? Don't really know what all the fuss is about, open your minds. Even if \n\nyou don't want to take a contribution for whatever reason (after all \n\nit's your project), there's no harm learning something from outside, if \n\nwe share knowledge we all grow, we all have our strengths and weaknesses \n\nor individual experiences, you can teach me something new tomorrow. >\n\n> I think it's perfectly reasonable to reject that burden if the payoff \n\n> doesn't seem worthwhile.\n\n>\n\n> Finally, if you're using Guava in a distributed system, you can \n\n> upgrade Guava versions whenever you like so long as every part of your \n\n > system is using the /same/ Guava version. (Google uses these tools \n\n > for its Java-based projects, too, and manages just fine.)\n\n That KO's our users, it's not my choice, they just never shut down their \n\nclusters, they perform hot upgrades. Anyway I've found my solution, thanks for humoring me. \n\n> http://profiles.google.com/wasserman.louis\n\n>\n\n>\n\n> On Mon, Oct 3, 2011 at 6:03 PM, Peter Firmstone <ji...@zeus.net.au \n\n> <mailto:ji...@zeus.net.au>> wrote:\n\n>\n\n> And you don't seem to be open to the idea of someone else making a\n\n> contribution...\n\n>\n\n> ...you're generous enough to put your code out there.\n\n>\n\n> I can see by the code that there are some smart developers involved.\n\n>\n\n> So there appears to be two options, if you want to use Guava in\n\n> distributed code, or non temporarily Serialize:\n\n>\n\n> 1. Use one version of Guava only.\n\n> 2. Or if you only want to use a few classes, copy them to a new name\n\n> space, fix the serialization and monitor and back port any fixes.\n\n>\n\n> Cheers,\n\n>\n\n> Peter.\n\n>\n\n> Charles Fry wrote:\n\n>\n\n> More to the point this is not something we need, so we lack\n\n> justification to spend time working on it...\n\n>\n\n> On Mon, Oct 3, 2011 at 17:21, Peter Firmstone\n\n> <ji...@zeus.net.au <mailto:ji...@zeus.net.au>\n\n\n\nSign in to reply to author You do not have permission to delete messages in this group Either email addresses are anonymous for this group or you need the view member email addresses permission to view the original message \n\n> On Fri, Sep 30, 2011 at 2:47 PM, peter <\n\n> <mailto:\n\n>\n\n> The best way to handle serialisation evolution is with a serialisation\n\n> proxy, since this allows you to use only the public api of your class,\n\n> eg constructors.\n\n>\n\n> The next best way is to use writeObject and readObject methods to\n\n> serialise your data structures in their simplest form and rebuild them\n\n> during deserialisation.\n\n>\n\n>\n\n> MapMaker's serialization logic is already sophisticated and even \n\n> noteworthy: \n\n>\n\n> As you can see, it uses the serialization proxy pattern *and* \n\n> write/readObject. What's more, it's the first and only usage of the \n\n> serialization proxy pattern I'm aware of that successfully works \n\n Bob Lee wrote:> On Fri, Sep 30, 2011 at 2:47 PM, peter < ji...@zeus.net.au > ji...@zeus.net.au >> wrote:> The best way to handle serialisation evolution is with a serialisation> proxy, since this allows you to use only the public api of your class,> eg constructors.> The next best way is to use writeObject and readObject methods to> serialise your data structures in their simplest form and rebuild them> during deserialisation.> MapMaker's serialization logic is already sophisticated and even> noteworthy: http://is.gd/KELdpR > As you can see, it uses the serialization proxy pattern *and*> write/readObject. What's more, it's the first and only usage of the> serialization proxy pattern I'm aware of that successfully works > around readResolve's broken behavior </> in the presence of circular \n\n > *Note - *The |readResolve| method is not invoked on the object \n\n> until the object is fully constructed, so any references to this\n\n> object in its object graph will not be updated to the new object\n\n > nominated by |readResolve|. However, during the serialization of \n\n> an object with the |writeReplace |method, all references to the\n\n> original object in the replacement object's object graph are\n\n> replaced with references to the replacement object. Therefore in\n\n> cases where an object being serialized nominates a replacement\n\n> object whose object graph has a reference to the original object,\n\n> deserialization will result in an incorrect graph of objects.\n\n> Furthermore, if the reference types of the object being read\n\n > (nominated by |writeReplace|) and the original object are not \n\n> compatible, the construction of the object graph will raise\n\n> a |ClassCastException|.\n\n>\n\n>\n\n> With MapMaker, the serialization proxy also implements ConcurrentMap. \n\n> If the proxy doesn't get replaced due to a circular dependency, it \n\n> will simply forward to the deserialized map instance. It introduces a \n\n> layer of indirection when you deserialize a circular reference, but \n\n> its behavior is otherwise indistinguishable to the user.\n\n>\n\n> At this point, I doubt the map's serialized form will change in an \n\n> incompatible way, but I strongly recommend against using serialization \n\n> for long term persistence. Serialized data is incredibly difficult to \n\n> migrate, and you end up accumulating and carrying around legacy design \n\n> cruft for the lifetime of your data.\n\n> \n\n> Bob\n\n>\n\n Yes, it's already very good, you've also made a very valid point about\n\ncircular references, thank-you and this is also the first time I've seen\n\nsomeone implement a workaround. > around readResolve's broken behavior > in the presence of circular> *Note - *The |readResolve| method is not invoked on the object> nominated by |readResolve|. However, during the serialization of> (nominated by |writeReplace|) and the original object are notYes, it's already very good, you've also made a very valid point aboutcircular references, thank-you and this is also the first time I've seensomeone implement a workaround. I agree with you about long term persistence, in a distributed\n\nenvironment, we need a little more compatibility than one version, not\n\nindefinite though, but at least upgradeable. 1. CustomConcurrentHashMap is package private, the client code will\n\n be expecting a ConcurrentMap, making it replaceable / substitutable.\n\n 2. The serialization proxy uses a builder, allowing the builder to\n\n substitute CustomConcurrentHashMap, with another implementation if\n\n necessary.\n\n 3. The serialization proxy also implements ConcurrentMap, fixing\n\n circular reference issues with readResolve().\n\n 4. The serialization proxy delegates to the new ConcurrentMap, built\n\n during deserialization, so any circular references that were not\n\n updated by readResolve() will work as expected. - very clever.\n\n 5. The serialization proxy has it's own inheritance hierarchy- good\n\n design. \n\nIts' also worth noting that this wasn't designed with upgrade\n\nflexibility in mind, to create the ultimate serialization pattern (for\n\ndistributed computing) based on this design, would only require very\n\nminor refactoring: 1. Move the static internal serialization proxy classes out of\n\n CustomConcurrentHashMap, as package private classes, decoupling\n\n them from CustomConcurrentHashMap.\n\n 2. Provide a static factory method on AbstractSerializationProxy to\n\n create a new serialization proxy instance, have\n\n CustomConcurrentHashMap call this instead of constructing the\n\n serialization proxy directly.\n\n 3. Rename AbstractSerializationProxy to\n\n AbstractSerializationProxyBuilder, and remove all non transient\n\n state, but provide builder methods to set state in the\n\n serialization proxy. Include a protected method to set a delegate\n\n to maintain the readResolve() circular reference fix.\n\n 4. Have the serialization proxy implement all the builder methods and\n\n carry the serialized state.\n\n 5. in the readResolve() method, the build() method is called, which\n\n builds the ConcurrentMap, and sets delegation for circular references. \n\nThen you can change the from MapMaker to CacheBuilder at some point in\n\nthe future and retrieve a ConcurrentMap implementation from Cache instead. You can add a new serialization proxy, to change your serialized form\n\nand leave the existing (although it will only get used by older\n\nserialized forms for compatibility). Then serialization can be utilised whilst performing hot upgrades. In fact, I like the circular reference solution so much I'd like to\n\ndocument it on our wiki, provided you're happy for me to do so? Who can I attribute the readResolve work around to?"
    },
    {
        "link": "https://guava.dev/releases/30.1-jre/api/docs/com/google/common/collect/ImmutableMap.html",
        "document": "\n• whose keys and values are the result of applying the provided mapping functions to the input elements. Entries appear in the result in encounter order. Returns a that accumulates elements into anwhose keys and values are the result of applying the provided mapping functions to the input elements. Entries appear in the resultin encounter order. If the mapped keys contain duplicates (according to , an is thrown when the collection operation is performed. (This differs from the returned by , which throws an .)\n• whose keys and values are the result of applying the provided mapping functions to the input elements. Returns a that accumulates elements into anwhose keys and values are the result of applying the provided mapping functions to the input elements. If the mapped keys contain duplicates (according to ), the values are merged using the specified merging function. Entries will appear in the encounter order of the first occurrence of the key.\n• Returns the empty map. This map behaves and performs comparably to , and is preferable mainly for consistency and maintainability of your code.\n• Returns an immutable map containing a single entry. This map behaves and performs comparably to but will not accept a null key or value. It is preferable mainly for consistency and maintainability of your code. a containing the specified mapping\n• Returns an immutable map containing the given entries, in order. - the first mapping's value - the second mapping's value a containing the specified mappings\n• Returns an immutable map containing the given entries, in order. - the first mapping's value - the second mapping's value - the third mapping's value a containing the specified mappings\n• Returns an immutable map containing the given entries, in order. - the first mapping's value - the second mapping's value - the third mapping's value a containing the specified mappings\n• Returns an immutable map containing the given entries, in order. - the first mapping's value - the second mapping's value - the third mapping's value - the fifth mapping's value a containing the specified mappings\n• Returns a new builder. The generated builder is equivalent to the builder created by the constructor.\n• Returns a new builder, expecting the specified number of entries to be added. If is exactly the number of entries added to the builder before is called, the builder is likely to perform better than an unsized would have. It is not specified if any performance benefits apply if is close to, but not exactly, the number of entries added to the builder.\n• . The returned map iterates over entries in the same order as the of the original map. If somehow contains entries with duplicate keys (for example, if it is a whose comparator is not consistent with equals), the results of this method are undefined. Returns an immutable map containing the same entries as. The returned map iterates over entries in the same order as theof the original map. Ifsomehow contains entries with duplicate keys (for example, if it is awhose comparator is not), the results of this method are undefined. Despite the method name, this method attempts to avoid actually copying the data when it is safe to do so. The exact circumstances under which a copy will or will not be performed are undocumented and subject to change. - a from which entries are drawn, must be non-null a containing the entries of the given - if any key or value in is null\n• Returns an immutable map containing the specified entries. The returned map iterates over entries in the same order as the original iterable. - if any key, value, or entry is null - if two entries have the same key\n• Guaranteed to throw an exception and leave the map unmodified. - key with which the specified value is to be associated - value to be associated with the specified key the previous value associated with , or if there was no mapping for . (A return can also indicate that the map previously associated with , if the implementation supports values.)\n• Guaranteed to throw an exception and leave the map unmodified. - key with which the specified value is to be associated - value to be associated with the specified key the previous value associated with the specified key, or if there was no mapping for the key. (A return can also indicate that the map previously associated with the key, if the implementation supports null values.)\n• Guaranteed to throw an exception and leave the map unmodified. - key with which the specified value is associated - value expected to be associated with the specified key - value to be associated with the specified key if the value was replaced\n• Guaranteed to throw an exception and leave the map unmodified. - key with which the specified value is associated - value to be associated with the specified key the previous value associated with the specified key, or if there was no mapping for the key. (A return can also indicate that the map previously associated with the key, if the implementation supports null values.)\n• Guaranteed to throw an exception and leave the map unmodified. - key with which the specified value is to be associated - the mapping function to compute a value the current (existing or computed) value associated with the specified key, or null if the computed value is null\n• Guaranteed to throw an exception and leave the map unmodified. - key with which the specified value is to be associated - the remapping function to compute a value the new value associated with the specified key, or null if none\n• Guaranteed to throw an exception and leave the map unmodified. - key with which the specified value is to be associated - the remapping function to compute a value the new value associated with the specified key, or null if none\n• Guaranteed to throw an exception and leave the map unmodified. - key with which the resulting value is to be associated - the non-null value to be merged with the existing value associated with the key or, if no existing value or a null value is associated with the key, to be associated with the key - the remapping function to recompute a value if present the new value associated with the specified key, or null if no value is associated with the key\n• Guaranteed to throw an exception and leave the map unmodified. - mappings to be stored in this map\n• Guaranteed to throw an exception and leave the map unmodified. - the function to apply to each entry\n• Guaranteed to throw an exception and leave the map unmodified. - key whose mapping is to be removed from the map the previous value associated with , or if there was no mapping for .\n• Guaranteed to throw an exception and leave the map unmodified. - key with which the specified value is associated - value expected to be associated with the specified key if the value was removed\n• Guaranteed to throw an exception and leave the map unmodified.\n• Returns if this map contains no key-value mappings. if this map contains no key-value mappings\n• Returns if this map contains a mapping for the specified key. More formally, returns if and only if this map contains a mapping for a key such that . (There can be at most one such mapping.) - key whose presence in this map is to be tested if this map contains a mapping for the specified key\n• Returns if this map maps one or more keys to the specified value. More formally, returns if and only if this map contains at least one mapping to a value such that . This operation will probably require time linear in the map size for most implementations of the interface. - value whose presence in this map is to be tested if this map maps one or more keys to the specified value\n• if this map contains no mapping for the key. Returns the value to which the specified key is mapped, orif this map contains no mapping for the key. More formally, if this map contains a mapping from a key to a value such that , then this method returns ; otherwise it returns . (There can be at most one such mapping.) If this map permits null values, then a return value of does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to . The operation may be used to distinguish these two cases. - the key whose associated value is to be returned the value to which the specified key is mapped, or if this map contains no mapping for the key\n• Returns the value to which the specified key is mapped, or if this map contains no mapping for the key. - the key whose associated value is to be returned - the default mapping of the key the value to which the specified key is mapped, or if this map contains no mapping for the key 21.0 (but only since 23.5 in the Android flavor). Note, however, that Java 8 users can call this method with any version and flavor of Guava.\n• Returns an immutable set of the mappings in this map. The iteration order is specified by the method used to create this map. Typically, this is insertion order. a set view of the mappings contained in this map\n• Returns an immutable set of the keys in this map, in the same order that they appear in a set view of the keys contained in this map\n• Returns an immutable collection of the values in this map, in the same order that they appear in a collection view of the values contained in this map\n• Indicates whether some other object is \"equal to\" this one. The method implements an equivalence relation on non-null object references:\n• It is reflexive: for any non-null reference value , should return .\n• It is symmetric: for any non-null reference values and , should return if and only if returns .\n• It is transitive: for any non-null reference values , , and , if returns and returns , then should return .\n• It is consistent: for any non-null reference values and , multiple invocations of consistently return or consistently return , provided no information used in comparisons on the objects is modified.\n• For any non-null reference value , should return . The method for class implements the most discriminating possible equivalence relation on objects; that is, for any non-null reference values and , this method returns if and only if and refer to the same object ( has the value ). Note that it is generally necessary to override the method whenever this method is overridden, so as to maintain the general contract for the method, which states that equal objects must have equal hash codes. - the reference object with which to compare. if this object is the same as the obj argument; otherwise.\n• Returns a hash code value for the object. This method is supported for the benefit of hash tables such as those provided by The general contract of is:\n• Whenever it is invoked on the same object more than once during an execution of a Java application, the method must consistently return the same integer, provided no information used in comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.\n• If two objects are equal according to the method, then calling the method on each of the two objects must produce the same integer result.\n• It is not required that if two objects are unequal according to the method, then calling the method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables. As much as is reasonably practical, the hashCode method defined by class does return distinct integers for distinct objects. (The hashCode may or may not be implemented as some function of an object's memory address at some point in time.) a hash code value for this object.\n• method returns a string that \"textually represents\" this object. The result should be a concise but informative representation that is easy for a person to read. It is recommended that all subclasses override this method. Returns a string representation of the object. In general, themethod returns a string that \"textually represents\" this object. The result should be a concise but informative representation that is easy for a person to read. It is recommended that all subclasses override this method. The method for class returns a string consisting of the name of the class of which the object is an instance, the at-sign character ` ', and the unsigned hexadecimal representation of the hash code of the object. In other words, this method returns a string equal to the value of:"
    }
]