[
    {
        "link": "https://w3schools.com/cpp/cpp_math.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://geeksforgeeks.org/c-mathematical-functions",
        "document": "C++ being a superset of C, supports a large number of useful mathematical functions. These functions are available in standard C++ to support various mathematical calculations.\n\nInstead of focusing on implementation, these functions can be directly used to simplify code and programs. In order to use these functions you need to include a header file- <math.h> or <cmath>.\n\nC++ provides a large set of mathematical functions which are stated below:\n\nExample of C++ Mathematical Functions\n\nC++ program to illustrate some of the above-mentioned functions:"
    },
    {
        "link": "https://w3schools.com/cpp/cpp_ref_math.asp",
        "document": "The library has many functions that allow you to perform mathematical tasks on numbers.\n\nA list of all math functions can be found in the table below:\n\nLearn more about math in our C++ Math Tutorial."
    },
    {
        "link": "https://stackoverflow.com/questions/4864283/what-are-the-functions-in-the-standard-library-that-can-be-implemented-faster-wi",
        "document": "This is where you really need to listen to project managers and MBAs. What you're suggesting is re-implementing parts of the STL and or standard C library. There is an associated cost in terms of time to implement and maintenance burden of doing so, so you shouldn't do it unless you really, genuinely need to, as John points out. The rule is simple: is this calculation you're doing slowing you down (a.k.a. you are bound by the CPU)? If not, don't create your own implementation just for the sake of it.\n\nNow, if you're really interested in fast maths, there are a few places you can start. The gnu multi-precision library implements many algorithms from modern computer arithmetic and semi numerical algorithms that are all about doing maths on arbitrary precision integers and floats insanely fast. The guys who write it optimise in assembly per build platform - it is about as fast as you can get in single core mode. This is the most general case I can think of for optimised maths i.e. that isn't specific to a certain domain.\n\nBringing my first paragraph and second in with what thkala has said, consider that GMP/MPIR have optimised assembly versions per cpu architecture and OS they support. Really. It's a big job, but it is what makes those libraries so fast on a specific small subset of problems that are programming.\n\nSometimes domain specific enhancements can be made. This is about understanding the problem in question. For example, when doing finite field arithmetic under rijndael's finite field you can, based on the knowledge that the characteristic polynomial is 2 with 8 terms, assume that your integers are of size and that addition/subtraction are equivalent to operations. How does this work? Well basically if you add or subtract two elements of the polynomial, they contain either zero or one. If they're both zero or both one, the result is always zero. If they are different, the result is one. Term by term, that is equivalent to xor across a 8-bit binary string, where each bit represents a term in the polynomial. Multiplication is also relatively efficient. You can bet that rijndael was designed to take advantage of this kind of result.\n\nThat's a very specific result. It depends entirely on what you're doing to make things efficient. I can't imagine many STL functions are purely optimised for cpu speed, because amongst other things STL provides: collections via templates, which are about memory, file access which is about storage, exception handling etc. In short, being really fast is a narrow subset of what STL does and what it aims to achieve. Also, you should note that optimisation has different views. For example, if your app is heavy on IO, you are IO bound. Having a massively efficient square root calculation isn't really helpful since \"slowness\" really means waiting on the disk/OS/your file parsing routine.\n\nIn short, you as a developer of an STL library are trying to build an \"all round\" library for many different use cases.\n\nBut, since these things are always interesting, you might well be interested in bit twiddling hacks. I can't remember where I saw that, but I've definitely stolen that link from somebody else on here."
    },
    {
        "link": "https://udacity.com/blog/2021/07/cpp-math-explained.html",
        "document": "“Math” is a simple word that comprises complex concepts, formulas, and functions. Math performs exactly the same way in C++ as it does in the physical world. Within C++ it’s possible to do anything from simple arithmetic to algebra, trigonometry, and calculus.\n\nIn this article, we take a look at how math operations that we see in everyday life appear in C++ and how to use them effectively in your code.\n\nIt comes as no surprise that arithmetic in C++ uses the same operations you learned in elementary school. C++ programmers can even use the modulus operator to output the remainder of a division equation. Here are the operators C++ uses to designate each type of arithmetic expression:\n\nAt a glance, here’s how each of these look in code. Every printing command outputs the result of the arithmetic expression that follows:\n\nEach math operation returns the value you would expect, including the modulus operator where 9 divided by 4 is 2 with a remainder of 1 (accordingly, with 1 as the output).\n\nRules of Math in C++\n\nWhether doing some math in C++ or in the real world, there are certain rules that you must follow to reach a correct solution.\n\nWhen performing arithmetic, the order of operations shows which math calculations are done first. Remembering the acronym PEMDAS will go a long way toward helping you to understand the order quickly. PEMDAS stands for the following:\n\nIn the following code snippets, you will see that C++ first scans your math expression — from left to right — for parentheses and will perform any action within, using the remaining PEMDAS steps within nce that’s complete, evaluation of the top-level expression continues: exponents will be done, then multiplication and division, and, lastly, addition and subtraction.\n\nNote that multiplication and division share the same precedence, followed by addition and subtraction.\n\nLet’s see how this plays out in code. We’ll be visiting exponents in a little bit, as they’re more complex. Take a look at the example below:\n\nAs you can see, it doesn’t matter in which order we write our calculation. Math in C++, following PEMDAS, will always perform the multiplication first.\n\nSwitching things up ever so slightly leads to a completely different result:\n\nThe program will perform calculations on any integers/values appearing inside of parentheses, before moving on to those outside of them. For x in this example, the code will do the addition inside of the parentheses before doing the multiplication. The results are no longer the same as in the previous example:\n\nThe data types in C++ represent different types of numbers. We use the data type for integer values and and for values that have decimal points.\n\nWhen it comes to math in C++, the programming language offers multiple data types for working with decimal-notation numbers. Take a look at the example below:\n\nC++ will output a result based upon the values used for the input when you don’t assign a data type to an output. Even when we do assign a data type, C++ will give us an output based upon the simplest value in our equation.\n\nEven with decimal places in the equation, int will always return an integer. Subsequently, using a float data type won’t add decimal places to the output if our input values are both integers.\n\nThe four outputs of the above code return the following:\n\nMaximums and Minimums in C++\n\nThe and functions will output the highest or lowest value of two inputs:\n\nOur variable becomes the highest number of the two values of our function. Looking at the function, the program will either output 10 or the user’s value depending on which is lower. You can use this mechanism, for example, in if/else statements or loops.\n\nShould you want the program to output the maximum of three (or more) values, you’ll need to use multiple functions:\n\n\n\nThis code does output 10 as the result.\n\nAs mentioned earlier, you can also use C++ to perform more complex mathematical formulae. To access these other types of operations, you’ll need to use the math library from C++ by including at the beginning of your program:\n\nThere are a multitude of math-based functions in C++. Let’s visit some of the more common ones.\n\nWith the cmath library in place, we can finally circle back to exponential equations in C++. To do so, we must call upon the function:\n\nIn code, this looks as follows:\n\nThis bit of code takes the base value 2 to the 5th power (25), for a result of 32.\n\nHeading in the opposite direction, we can use the function to determine the square root of a particular value.\n\nIt may be wise to use the data type here should the value you’re taking the square root of not be a perfect square (winding up with a fractional part, which would be thrown away when storing the result in a variable of data type .\n\nBecause a double is used the above code prints out 15.8745.\n\nIf you wish to round a or result to the nearest integer, use the function. Keep in mind that this is different from changing the data type to , which would truncate the decimal values without rounding the value up.\n\n15.8745 is rounded up to a value of 16.\n\nWe’ve covered quite a bit of C++ in this article, including arithmetic, exponents, and rounding. That said, we’re merely scraping the surface of what’s possible with C++. The language has applications ranging from gaming to browsers, so taking the time to learn it could result in a game-changing career move.\n\nAt Udacity, our C++ experts have designed a hands-on nanodegree program that will teach you what you need to know to start a successful career in C++ programming.\n\nEnroll in our C++ Nanodegree program today!"
    },
    {
        "link": "https://programiz.com/cpp-programming/examples/quadratic-roots",
        "document": "Learn to code solving problems and writing code with our hands-on C++ course.\n\nLearn to code solving problems with our hands-on C++ course!"
    },
    {
        "link": "https://stackoverflow.com/questions/32619920/quadratic-equation-negative-discriminant-in-c",
        "document": "To use the absolute value you can use from the header.\n\nHowever, as I learned it, if the discriminant is negative, it simply means that there is no solution.\n\nSo it might be better solution to just add an clause to only execute that part of the formula if the discrimant is positive.\n\nIn more advanced maths, the square root of a negative number does have an answer in the complex plane. To obtain this result, you can use the datatype and use the overloaded version of that takes a complex number."
    },
    {
        "link": "https://docs.vultr.com/cpp/examples/find-all-roots-of-a-quadratic-equation",
        "document": "C++ Program to Find All Roots of a Quadratic Equation\n\nQuadratic equations are fundamental in algebra and appear frequently in various mathematical problems. They have the standard form ( ax^2 + bx + c = 0 ), where ( a ), ( b ), and ( c ) are coefficients and ( x ) represents the unknown variable. Solving these equations involves finding the values of ( x ) that satisfy the equation, commonly known as the roots of the equation.\n\nIn this article, you will learn how to create a C++ program to find all roots of a quadratic equation. Explore different methodologies for solving quadratic equations programmatically, including handling real and complex roots. Implementations and examples will guide you through using conditionals and mathematical functions to compute and display the roots effectively.\n\nSetting Up Your C++ Environment\n\nBefore diving into the coding part, ensure you have an environment set up for compiling and running C++ programs. You might use an integrated development environment (IDE) like Visual Studio, Code::Blocks, or simple text editors combined with a command-line compiler like GCC or Clang.\n• Understand the discriminant ( \\Delta ) which is ( b^2 - 4ac ). The nature of the roots is determined by the value of the discriminant:\n• If ( \\Delta > 0 ), the equation has two distinct real roots.\n• If ( \\Delta = 0 ), the equation has exactly one real root (also called a repeated or double root).\n• If ( \\Delta < 0 ), the equation has two complex roots.\n\nWriting the Code to Find the Roots\n• None Begin by including the necessary headers and using the standard namespace.\n• None Prompt the user to enter the coefficients ( a ), ( b ), and ( c ) and store these values.\n• None Calculate the discriminant to decide the nature of the roots.\n• None Use conditional statements to calculate and print the roots based on the value of the discriminant. \"Roots are real and different.\" \"Roots are real and same.\" \"Roots are complex and different.\"\n• The program calculates the discriminant to identify the type of roots.\n• Based on the discriminant, appropriate roots are calculated.\n• Roots are either real (and the same or different) or complex.\n• Results are printed directly to the console.\n• Validate input by checking that ( a \n\neq 0 ) since ( a = 0 ) would not represent a quadratic equation but a linear one.\n• Consider implementing error handling for non-numeric inputs which might cause your program to break or behave unexpectedly.\n\nUnderstanding how to determine and calculate the roots of quadratic equations in C++ equips you with fundamental skills that apply in various mathematical and technical domains. By following the examples shown, you handle different scenarios a quadratic equation might present, ensuring your program can compute both real and complex roots accurately. This knowledge aids in tasks ranging from simple homework problems to complex physics simulations where such equations are common."
    },
    {
        "link": "https://cplusplus.com/forum/beginner/480",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/program-to-find-the-roots-of-quadratic-equation",
        "document": "Program to find the Roots of a Quadratic Equation\n\nGiven a quadratic equation in the form ax2 + bx + c, (Only the values of a, b and c are provided) the task is to find the roots of the equation.\n\nThe roots could be found using the below formula (It is known as the formula of Sridharacharya)\n\nThe values of the roots depends on the term (b2 – 4ac) which is known as the discriminant (D).\n\nIf D > 0:\n\n => This occurs when b2 > 4ac.\n\n => The roots are real and unequal.\n\n => The roots are {-b + ?(b2 – 4ac)}/2a and {-b – ?(b2 – 4ac)}/2a. If D = 0:\n\n => This occurs when b2 = 4ac.\n\n => The roots are real and equal.\n\n => The roots are (-b/2a). If D < 0:\n\n => This occurs when b2 < 4ac.\n\n => The roots are imaginary and unequal.\n\n => The discriminant can be written as (-1 * -D).\n\n => As D is negative, -D will be positive.\n\n => The roots are {-b ± ?(-1*-D)} / 2a = {-b ± i?(-D)} / 2a = {-b ± i?-(b2 – 4ac)}/2a where i = ?-1.\n\nUse the following pseudo algorithm to find the roots of the\n\nBelow is the implementation of the above formula.\n\n// C++ program to find roots of a quadratic equation // If a is 0, then equation is not quadratic, but \"Roots are real and different // C program to find roots of a quadratic equation // If a is 0, then equation is not quadratic, but \"Roots are real and different // If a is 0, then equation is not \"Roots are real and different \n\n\" \"Roots are real and same \n\n\" // This code is contributed by Sumit Kumar. # If a is 0, then equation is \"Roots are real and different \" \"Roots are real and same\" # This code is contributed by Sharad Bhardwaj. // If a is 0, then equation is \"Roots are real and different \n\n\" // This code is contributed by nitin mittal. // If a is 0, then equation is not \"Roots are real and different \n\n\" \"Roots are real and same \n\n\" // If a is 0, then equation is\n\nTime Complexity: O(log(D)), where D is the discriminant of the given quadratic equation.\n\nAuxiliary Space: O(1)\n• None Import the math module for square root and other mathematical operations.\n• None Declare the coefficients a, b, and c of the quadratic equation.\n• None Calculate the discriminant discriminant using the formula b^2 – 4ac.\n• None Check if the discriminant is greater than zero, zero, or less than zero.\n• None If the discriminant is greater than zero, calculate two real and distinct roots using the formula (-b + sqrt(discriminant)) / (2*a) and (-b – sqrt(discriminant)) / (2*a), and print the roots with the message “Roots are real and distinct”.\n• None If the discriminant is equal to zero, calculate one real and same root using the formula -b / (2*a), and print the root with the message “Roots are real and same”.\n• None If the discriminant is less than zero, calculate two complex and different roots using the formula (-b / 2*a) +/- (sqrt(-discriminant) / (2*a)), and print the roots with the message “Roots are complex and different”."
    }
]