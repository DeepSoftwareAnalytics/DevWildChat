[
    {
        "link": "https://cs.cmu.edu/Groups/AI/html/cltl/clm/node67.html",
        "document": "The and special forms are the usual means of specifying globally defined variables. The special form is used for defining named constants.\n\nis the recommended way to declare the use of a special variable in a program.\n\nproclaims variable to be (see ), and may perform other system-dependent bookkeeping actions.\n\n\n\n X3J13 voted in June 1987 (DEFVAR-INITIALIZATION) to clarify that if no initial-value form is provided, does not change the value of the variable; if no initial-value form is provided and the variable has no value, does not give it a value. \n\n\n\nIf a second argument form is supplied,\n\nthen variable is initialized to the result of evaluating the form initial-value unless it already has a value. The initial-value form is not evaluated unless it is used; this fact is useful if evaluation of the initial-value form does something expensive like creating a large data structure.\n\n\n\n X3J13 voted in June 1987 (DEFVAR-INIT-TIME) to clarify that evaluation of the initial-value and the initialization of the variable occur, if at all, at the time the form is executed, and that the initial-value form is evaluated if and only if the variable does not already have a value. \n\n\n\nThe initialization is performed by assignment and thus assigns a global value to the variable unless there are currently special bindings of that variable. Normally there should not be any such special bindings.\n\nalso provides a good place to put a comment describing the meaning of the variable, whereas an ordinary proclamation offers the temptation to declare several variables at once and not have room to describe them all.\n\nis similar to , but requires an initial-value form, always evaluates the form, and assigns the result to the variable. The semantic distinction is that is intended to declare a variable changed by the program, whereas is intended to declare a variable that is normally constant but can be changed (possibly at run time), where such a change is considered a change to the program. therefore does not indicate that the quantity never changes; in particular, it does not license the compiler to build assumptions about the value into programs being compiled.\n\nis like but does assert that the value of the variable name is fixed and does license the compiler to build assumptions about the value into programs being compiled. (However, if the compiler chooses to replace references to the name of the constant by the value of the constant in code to be compiled, perhaps in order to allow further optimization, the compiler must take care that such ``copies'' appear to be to the object that is the actual value of the constant. For example, the compiler may freely make copies of numbers but must exercise care when the value is a list.)\n\nIt is an error if there are any special bindings of the variable at the time the form is executed (but implementations may or may not check for this).\n\nOnce a name has been declared by to be constant, any further assignment to or binding of that special variable is an error. This is the case for such system-supplied constants as and . A compiler may also choose to issue warnings about bindings of the lexical variable of the same name.\n\n\n\n X3J13 voted in January 1989 (DEFCONSTANT-SPECIAL) to clarify the preceding paragraph by specifying that it is an error to rebind constant symbols as either lexical or special variables. Consequently, a valid reference to a symbol declared with always refers to its global value. (Unfortunately, this violates the principle of referential transparency, for one cannot always choose names for lexical variables without regard to surrounding context.) \n\n\n\nFor any of these constructs, the documentation should be a string. The string is attached to the name of the variable, parameter, or constant under the documentation type; see the function.\n\n\n\n X3J13 voted in March 1988 (DEFVAR-DOCUMENTATION) to clarify that the documentation-string is not evaluated but must appear as a literal string when the , , or form is evaluated.\n\nFor example, the form\n\nis erroneous because the call to is not a literal string.\n\n(On the other hand, the form\n\nmight be used to accomplish the same purpose, because the call to is evaluated at time; when the form is evaluated, only the result of the call to , a string, appears in the form.) \n\n\n\nThese constructs are normally used only as top-level forms. The value returned by each of these constructs is the name declared."
    },
    {
        "link": "https://gigamonkeys.com/book/variables",
        "document": "The next basic building block we need to look at are variables. Common Lisp supports two kinds of variables: lexical and dynamic.1 These two types correspond roughly to \"local\" and \"global\" variables in other languages. However, the correspondence is only approximate. On one hand, some languages' \"local\" variables are in fact much like Common Lisp's dynamic variables.2 And on the other, some languages' local variables are lexically scoped without providing all the capabilities provided by Common Lisp's lexical variables. In particular, not all languages that provide lexically scoped variables support closures.\n\nTo make matters a bit more confusing, many of the forms that deal with variables can be used with both lexical and dynamic variables. So I'll start by discussing a few aspects of Lisp's variables that apply to both kinds and then cover the specific characteristics of lexical and dynamic variables. Then I'll discuss Common Lisp's general-purpose assignment operator, , which is used to assign new values to variables and just about every other place that can hold a value.\n\nAs in other languages, in Common Lisp variables are named places that can hold a value. However, in Common Lisp, variables aren't typed the way they are in languages such as Java or C++. That is, you don't need to declare the type of object that each variable can hold. Instead, a variable can hold values of any type and the values carry type information that can be used to check types at runtime. Thus, Common Lisp is dynamically typed--type errors are detected dynamically. For instance, if you pass something other than a number to the function, Common Lisp will signal a type error. On the other hand, Common Lisp is a strongly typed language in the sense that all type errors will be detected--there's no way to treat an object as an instance of a class that it's not.3\n\nAll values in Common Lisp are, conceptually at least, references to objects.4 Consequently, assigning a variable a new value changes what object the variable refers to but has no effect on the previously referenced object. However, if a variable holds a reference to a mutable object, you can use that reference to modify the object, and the modification will be visible to any code that has a reference to the same object.\n\nOne way to introduce new variables you've already used is to define function parameters. As you saw in the previous chapter, when you define a function with , the parameter list defines the variables that will hold the function's arguments when it's called. For example, this function defines three variables-- , , and --to hold its arguments.\n\nEach time a function is called, Lisp creates new bindings to hold the arguments passed by the function's caller. A binding is the runtime manifestation of a variable. A single variable--the thing you can point to in the program's source code--can have many different bindings during a run of the program. A single variable can even have multiple bindings at the same time; parameters to a recursive function, for example, are rebound for each call to the function.\n\nAs with all Common Lisp variables, function parameters hold object references.5 Thus, you can assign a new value to a function parameter within the body of the function, and it will not affect the bindings created for another call to the same function. But if the object passed to a function is mutable and you change it in the function, the changes will be visible to the caller since both the caller and the callee will be referencing the same object.\n\nAnother form that introduces new variables is the special operator. The skeleton of a form looks like this:\n\nwhere each variable is a variable initialization form. Each initialization form is either a list containing a variable name and an initial value form or--as a shorthand for initializing the variable to --a plain variable name. The following form, for example, binds the three variables , , and with initial values 10, 20, and :\n\nWhen the form is evaluated, all the initial value forms are first evaluated. Then new bindings are created and initialized to the appropriate initial values before the body forms are executed. Within the body of the , the variable names refer to the newly created bindings. After the , the names refer to whatever, if anything, they referred to before the .\n\nThe value of the last expression in the body is returned as the value of the expression. Like function parameters, variables introduced with are rebound each time the is entered.6\n\nThe scope of function parameters and variables--the area of the program where the variable name can be used to refer to the variable's binding--is delimited by the form that introduces the variable. This form--the function definition or the --is called the binding form. As you'll see in a bit, the two types of variables--lexical and dynamic--use two slightly different scoping mechanisms, but in both cases the scope is delimited by the binding form.\n\nIf you nest binding forms that introduce variables with the same name, then the bindings of the innermost variable shadows the outer bindings. For instance, when the following function is called, a binding is created for the parameter to hold the function's argument. Then the first creates a new binding with the initial value 2, and the inner creates yet another binding, this one with the initial value 3. The bars on the right mark the scope of each binding.\n\nEach reference to will refer to the binding with the smallest enclosing scope. Once control leaves the scope of one binding form, the binding from the immediately enclosing scope is unshadowed and refers to it instead. Thus, calling results in this output:\n\nIn future chapters I'll discuss other constructs that also serve as binding forms--any construct that introduces a new variable name that's usable only within the construct is a binding form.\n\nFor instance, in Chapter 7 you'll meet the loop, a basic counting loop. It introduces a variable that holds the value of a counter that's incremented each time through the loop. The following loop, for example, which prints the numbers from 0 to 9, binds the variable :\n\nAnother binding form is a variant of , . The difference is that in a , the variable names can be used only in the body of the --the part of the after the variables list--but in a , the initial value forms for each variable can refer to variables introduced earlier in the variables list. Thus, you can write the following:\n\nbut not this:\n\nHowever, you could achieve the same result with nested s.\n\nBy default all binding forms in Common Lisp introduce lexically scoped variables. Lexically scoped variables can be referred to only by code that's textually within the binding form. Lexical scoping should be familiar to anyone who has programmed in Java, C, Perl, or Python since they all provide lexically scoped \"local\" variables. For that matter, Algol programmers should also feel right at home, as Algol first introduced lexical scoping in the 1960s.\n\nHowever, Common Lisp's lexical variables are lexical variables with a twist, at least compared to the original Algol model. The twist is provided by the combination of lexical scoping with nested functions. By the rules of lexical scoping, only code textually within the binding form can refer to a lexical variable. But what happens when an anonymous function contains a reference to a lexical variable from an enclosing scope? For instance, in this expression:\n\nthe reference to inside the form should be legal according to the rules of lexical scoping. Yet the anonymous function containing the reference will be returned as the value of the form and can be invoked, via , by code that's not in the scope of the . So what happens? As it turns out, when is a lexical variable, it just works. The binding of created when the flow of control entered the form will stick around for as long as needed, in this case for as long as someone holds onto a reference to the function object returned by the form. The anonymous function is called a closure because it \"closes over\" the binding created by the .\n\nThe key thing to understand about closures is that it's the binding, not the value of the variable, that's captured. Thus, a closure can not only access the value of the variables it closes over but can also assign new values that will persist between calls to the closure. For instance, you can capture the closure created by the previous expression in a global variable like this:\n\nThen each time you invoke it, the value of count will increase by one.\n\nA single closure can close over many variable bindings simply by referring to them. Or multiple closures can capture the same binding. For instance, the following expression returns a list of three closures, one that increments the value of the closed over binding, one that decrements it, and one that returns the current value:\n\nLexically scoped bindings help keep code understandable by limiting the scope, literally, in which a given name has meaning. This is why most modern languages use lexical scoping for local variables. Sometimes, however, you really want a global variable--a variable that you can refer to from anywhere in your program. While it's true that indiscriminate use of global variables can turn code into spaghetti nearly as quickly as unrestrained use of , global variables do have legitimate uses and exist in one form or another in almost every programming language.7 And as you'll see in a moment, Lisp's version of global variables, dynamic variables, are both more useful and more manageable.\n\nCommon Lisp provides two ways to create global variables: and . Both forms take a variable name, an initial value, and an optional documentation string. After it has been ed or ed, the name can be used anywhere to refer to the current binding of the global variable. As you've seen in previous chapters, global variables are conventionally named with names that start and end with . You'll see later in this section why it's quite important to follow that naming convention. Examples of and look like this:\n\nThe difference between the two forms is that always assigns the initial value to the named variable while does so only if the variable is undefined. A form can also be used with no initial value to define a global variable without giving it a value. Such a variable is said to be unbound.\n\nPractically speaking, you should use to define variables that will contain data you'd want to keep even if you made a change to the source code that uses the variable. For instance, suppose the two variables defined previously are part of an application for controlling a widget factory. It's appropriate to define the variable with because the number of widgets made so far isn't invalidated just because you make some changes to the widget-making code.8\n\nOn the other hand, the variable presumably has some effect on the behavior of the widget-making code itself. If you decide you need a tighter or looser tolerance and change the value in the form, you'd like the change to take effect when you recompile and reload the file.\n\nAfter defining a variable with or , you can refer to it from anywhere. For instance, you might define this function to increment the count of widgets made:\n\nThe advantage of global variables is that you don't have to pass them around. Most languages store the standard input and output streams in global variables for exactly this reason--you never know when you're going to want to print something to standard out, and you don't want every function to have to accept and pass on arguments containing those streams just in case someone further down the line needs them.\n\nHowever, once a value, such as the standard output stream, is stored in a global variable and you have written code that references that global variable, it's tempting to try to temporarily modify the behavior of that code by changing the variable's value.\n\nFor instance, suppose you're working on a program that contains some low-level logging functions that print to the stream in the global variable . Now suppose that in part of the program you want to capture all the output generated by those functions into a file. You might open a file and assign the resulting stream to . Now the low-level functions will send their output to the file.\n\nThis works fine until you forget to set back to the original stream when you're done. If you forget to reset , all the other code in the program that uses will also send its output to the file.9\n\nWhat you really want, it seems, is a way to wrap a piece of code in something that says, \"All code below here--all the functions it calls, all the functions they call, and so on, down to the lowest-level functions--should use this value for the global variable .\" Then when the high-level function returns, the old value of should be automatically restored.\n\nIt turns out that that's exactly what Common Lisp's other kind of variable--dynamic variables--let you do. When you bind a dynamic variable--for example, with a variable or a function parameter--the binding that's created on entry to the binding form replaces the global binding for the duration of the binding form. Unlike a lexical binding, which can be referenced by code only within the lexical scope of the binding form, a dynamic binding can be referenced by any code that's invoked during the execution of the binding form.10 And it turns out that all global variables are, in fact, dynamic variables.\n\nThus, if you want to temporarily redefine , the way to do it is simply to rebind it, say, with a .\n\nIn any code that runs as a result of the call to , references to will use the binding established by the . And when returns and control leaves the , the new binding of will go away and subsequent references to will see the binding that was current before the . At any given time, the most recently established binding shadows all other bindings. Conceptually, each new binding for a given dynamic variable is pushed onto a stack of bindings for that variable, and references to the variable always use the most recent binding. As binding forms return, the bindings they created are popped off the stack, exposing previous bindings.11\n\nA simple example shows how this works.\n\nThe creates a global binding for the variable with the value 10. The reference to in will look up the current binding dynamically. If you call from the top level, the global binding created by the is the only binding available, so it prints 10.\n\nBut you can use to create a new binding that temporarily shadows the global binding, and will print a different value.\n\nNow call again, with no , and it again sees the global binding.\n\nNote that the middle call to is wrapped in a that binds to the new value 20. When you run , you get this result:\n\nAs you can see, the first call to sees the global binding, with its value of 10. The middle call, however, sees the new binding, with the value 20. But after the , once again sees the global binding.\n\nAs with lexical bindings, assigning a new value affects only the current binding. To see this, you can redefine to include an assignment to .\n\nNow prints the value of , increments it, and prints it again. If you just run , you'll see this:\n\nNot too surprising. Now run .\n\nNotice that started at 11--the earlier call to really did change the global value. The first call to from increments the global binding to 12. The middle call doesn't see the global binding because of the . Then the last call can see the global binding again and increments it from 12 to 13.\n\nSo how does this work? How does know that when it binds it's supposed to create a dynamic binding rather than a normal lexical binding? It knows because the name has been declared special.12 The name of every variable defined with and is automatically declared globally special. This means whenever you use such a name in a binding form--in a or as a function parameter or any other construct that creates a new variable binding--the binding that's created will be a dynamic binding. This is why the is so important--it'd be bad news if you used a name for what you thought was a lexical variable and that variable happened to be globally special. On the one hand, code you call could change the value of the binding out from under you; on the other, you might be shadowing a binding established by code higher up on the stack. If you always name global variables according to the naming convention, you'll never accidentally use a dynamic binding where you intend to establish a lexical binding.\n\nIt's also possible to declare a name locally special. If, in a binding form, you declare a name special, then the binding created for that variable will be dynamic rather than lexical. Other code can locally declare a name special in order to refer to the dynamic binding. However, locally special variables are relatively rare, so you needn't worry about them.13\n\nDynamic bindings make global variables much more manageable, but it's important to notice they still allow action at a distance. Binding a global variable has two at a distance effects--it can change the behavior of downstream code, and it also opens the possibility that downstream code will assign a new value to a binding established higher up on the stack. You should use dynamic variables only when you need to take advantage of one or both of these characteristics.\n\nOne other kind of variable I haven't mentioned at all is the oxymoronic \"constant variable.\" All constants are global and are defined with . The basic form of is like .\n\nAs with and , has a global effect on the name used--thereafter the name can be used only to refer to the constant; it can't be used as a function parameter or rebound with any other binding form. Thus, many Lisp programmers follow a naming convention of using names starting and ending with for constants. This convention is somewhat less universally followed than the -naming convention for globally special names but is a good idea for the same reason.14\n\nAnother thing to note about is that while the language allows you to redefine a constant by reevaluating a with a different initial-value-form, what exactly happens after the redefinition isn't defined. In practice, most implementations will require you to reevaluate any code that refers to the constant in order to see the new value since the old value may well have been inlined. Consequently, it's a good idea to use only to define things that are really constant, such as the value of NIL. For things you might ever want to change, you should use instead.\n\nOnce you've created a binding, you can do two things with it: get the current value and set it to a new value. As you saw in Chapter 4, a symbol evaluates to the value of the variable it names, so you can get the current value simply by referring to the variable. To assign a new value to a binding, you use the macro, Common Lisp's general-purpose assignment operator. The basic form of is as follows:\n\nBecause is a macro, it can examine the form of the place it's assigning to and expand into appropriate lower-level operations to manipulate that place. When the place is a variable, it expands into a call to the special operator , which, as a special operator, has access to both lexical and dynamic bindings.15 For instance, to assign the value 10 to the variable , you can write this:\n\nAs I discussed earlier, assigning a new value to a binding has no effect on any other bindings of that variable. And it doesn't have any effect on the value that was stored in the binding prior to the assignment. Thus, the in this function:\n\nwill have no effect on any value outside of . The binding that was created when was called is set to 10, immediately replacing whatever value was passed as an argument. In particular, a form such as the following:\n\nwill print 20, not 10, as it's the value of that's passed to where it's briefly the value of the variable before the gives a new value.\n\ncan also assign to multiple places in sequence. For instance, instead of the following:\n\nyou can write this:\n\nreturns the newly assigned value, so you can also nest calls to as in the following expression, which assigns both and the same random value:\n\nVariable bindings, of course, aren't the only places that can hold values. Common Lisp supports composite data structures such as arrays, hash tables, and lists, as well as user-defined data structures, all of which consist of multiple places that can each hold a value.\n\nI'll cover those data structures in future chapters, but while we're on the topic of assignment, you should note that can assign any place a value. As I cover the different composite data structures, I'll point out which functions can serve as \" able places.\" The short version, however, is if you need to assign a value to a place, is almost certainly the tool to use. It's even possible to extend to allow it to assign to user-defined places though I won't cover that.16\n\nIn this regard is no different from the assignment operator in most C-derived languages. In those languages, the operator assigns new values to variables, array elements, and fields of classes. In languages such as Perl and Python that support hash tables as a built-in data type, can also set the values of individual hash table entries. Table 6-1 summarizes the various ways is used in those languages.\n\nTable 6-1. Assignment with in Other Languages\n\nworks the same way--the first \"argument\" to is a place to store the value, and the second argument provides the value. As with the operator in these languages, you use the same form to express the place as you'd normally use to fetch the value.17 Thus, the Lisp equivalents of the assignments in Table 6-1--given that is the array access function, does a hash table lookup, and might be a function that accesses a slot named of a user-defined object--are as follows:\n\nNote that ing a place that's part of a larger object has the same semantics as ing a variable: the place is modified without any effect on the object that was previously stored in the place. Again, this is similar to how behaves in Java, Perl, and Python.18\n\nWhile all assignments can be expressed with , certain patterns involving assigning a new value based on the current value are sufficiently common to warrant their own operators. For instance, while you could increment a number with , like this:\n\nor decrement it with this:\n\nit's a bit tedious, compared to the C-style and . Instead, you can use the macros and , which increment and decrement a place by a certain amount that defaults to 1.\n\nand are examples of a kind of macro called modify macros. Modify macros are macros built on top of that modify places by assigning a new value based on the current value of the place. The main benefit of modify macros is that they're more concise than the same modification written out using . Additionally, modify macros are defined in a way that makes them safe to use with places where the place expression must be evaluated only once. A silly example is this expression, which increments the value of an arbitrary element of an array:\n\nA naive translation of that into a expression might look like this:\n\nHowever, that doesn't work because the two calls to won't necessarily return the same value--this expression will likely grab the value of one element of the array, increment it, and then store it back as the new value of a different element. The expression, however, does the right thing because it knows how to take apart this expression:\n\nto pull out the parts that could possibly have side effects to make sure they're evaluated only once. In this case, it would probably expand into something more or less equivalent to this:\n\nIn general, modify macros are guaranteed to evaluate both their arguments and the subforms of the place form exactly once each, in left-to-right order.\n\nThe macro , which you used in the mini-database to add elements to the variable, is another modify macro. You'll take a closer look at how it and its counterparts and work in Chapter 12 when I talk about how lists are represented in Lisp.\n\nFinally, two slightly esoteric but useful modify macros are and . rotates values between places. For instance, if you have two variables, and , this call:\n\nswaps the values of the two variables and returns . Since and are variables and you don't have to worry about side effects, the previous expression is equivalent to this:\n\nWith other kinds of places, the equivalent expression using would be quite a bit more complex.\n\nis similar except instead of rotating values it shifts them to the left--the last argument provides a value that's moved to the second-to-last argument while the rest of the values are moved one to the left. The original value of the first argument is simply returned. Thus, the following:\n\nis equivalent--again, since you don't have to worry about side effects--to this:\n\nBoth and can be used with any number of arguments and, like all modify macros, are guaranteed to evaluate them exactly once, in left to right order.\n\nWith the basics of Common Lisp's functions and variables under your belt, now you're ready to move onto the feature that continues to differentiate Lisp from other languages: macros.\n\n1Dynamic variables are also sometimes called special variables for reasons you'll see later in this chapter. It's important to be aware of this synonym, as some folks (and Lisp implementations) use one term while others use the other. 2Early Lisps tended to use dynamic variables for local variables, at least when interpreted. Elisp, the Lisp dialect used in Emacs, is a bit of a throwback in this respect, continuing to support only dynamic variables. Other languages have recapitulated this transition from dynamic to lexical variables--Perl's variables, for instance, are dynamic while its variables, introduced in Perl 5, are lexical. Python never had true dynamic variables but only introduced true lexical scoping in version 2.2. (Python's lexical variables are still somewhat limited compared to Lisp's because of the conflation of assignment and binding in the language's syntax.) 3Actually, it's not quite true to say that all type errors will always be detected--it's possible to use optional declarations to tell the compiler that certain variables will always contain objects of a particular type and to turn off runtime type checking in certain regions of code. However, declarations of this sort are used to optimize code after it has been developed and debugged, not during normal development. 4As an optimization certain kinds of objects, such as integers below a certain size and characters, may be represented directly in memory where other objects would be represented by a pointer to the actual object. However, since integers and characters are immutable, it doesn't matter that there may be multiple copies of \"the same\" object in different variables. This is the root of the difference between and discussed in Chapter 4. 5In compiler-writer terms Common Lisp functions are \"pass-by-value.\" However, the values that are passed are references to objects. This is similar to how Java and Python work. 6The variables in forms and function parameters are created by exactly the same mechanism. In fact, in some Lisp dialects--though not Common Lisp-- is simply a macro that expands into a call to an anonymous function. That is, in those dialects, the following: is a macro form that expands into this: 7Java disguises global variables as public static fields, C uses variables, and Python's module-level and Perl's package-level variables can likewise be accessed from anywhere. 8If you specifically want to reset a ed variable, you can either set it directly with or make it unbound using and then reevaluate the form. 9The strategy of temporarily reassigning *standard-output* also breaks if the system is multithreaded--if there are multiple threads of control trying to print to different streams at the same time, they'll all try to set the global variable to the stream they want to use, stomping all over each other. You could use a lock to control access to the global variable, but then you're not really getting the benefit of multiple concurrent threads, since whatever thread is printing has to lock out all the other threads until it's done even if they want to print to a different stream. 10The technical term for the interval during which references may be made to a binding is its extent. Thus, scope and extent are complementary notions--scope refers to space while extent refers to time. Lexical variables have lexical scope but indefinite extent, meaning they stick around for an indefinite interval, determined by how long they're needed. Dynamic variables, by contrast, have indefinite scope since they can be referred to from anywhere but dynamic extent. To further confuse matters, the combination of indefinite scope and dynamic extent is frequently referred to by the misnomer dynamic scope. 11Though the standard doesn't specify how to incorporate multithreading into Common Lisp, implementations that provide multithreading follow the practice established on the Lisp machines and create dynamic bindings on a per-thread basis. A reference to a global variable will find the binding most recently established in the current thread, or the global binding. 12This is why dynamic variables are also sometimes called special variables. 13If you must know, you can look up , , and in the HyperSpec. 14Several key constants defined by the language itself don't follow this convention--not least of which are and . This is occasionally annoying when one wants to use as a local variable name. Another is , which holds the best long-float approximation of the mathematical constant pi. 15Some old-school Lispers prefer to use with variables, but modern style tends to use for all assignments. 16Look up , for more information. 17The prevalence of Algol-derived syntax for assignment with the \"place\" on the left side of the and the new value on the right side has spawned the terminology lvalue, short for \"left value,\" meaning something that can be assigned to, and rvalue, meaning something that provides a value. A compiler hacker would say, \" treats its first argument as an lvalue.\" 18C programmers may want to think of variables and other places as holding a pointer to the real object; assigning to a variable simply changes what object it points to while assigning to a part of a composite object is similar to indirecting through the pointer to the actual object. C++ programmers should note that the behavior of in C++ when dealing with objects--namely, a memberwise copy--is quite idiosyncratic."
    },
    {
        "link": "https://reddit.com/r/lisp/comments/1iryn7r/thoughts_on_recommendation_of_using_global",
        "document": "I'm reading Practical Common Lisp and have questions about its guidance on global variables. The book seems fairly positive about their use. Citing from the book:\n\nLexically scoped bindings help keep code understandable by limiting the scope, literally, in which a given name has meaning. This is why most modern languages use lexical scoping for local variables. Sometimes, however, you really want a global variable--a variable that you can refer to from anywhere in your program. While it's true that indiscriminate use of global variables can turn code into spaghetti nearly as quickly as unrestrained use of goto, global variables do have legitimate uses and exist in one form or another in almost every programming language.7 And as you'll see in a moment, Lisp's version of global variables, dynamic variables, are both more useful and more manageable.\n\nPractically speaking, you should use DEFVAR to define variables that will contain data you'd want to keep even if you made a change to the source code that uses the variable. For instance, suppose the two variables defined previously are part of an application for controlling a widget factory. It's appropriate to define the count variable with DEFVAR because the number of widgets made so far isn't invalidated just because you make some changes to the widget-making code.\n\nThe advantage of global variables is that you don't have to pass them around. Most languages store the standard input and output streams in global variables for exactly this reason--you never know when you're going to want to print something to standard out, and you don't want every function to have to accept and pass on arguments containing those streams just in case someone further down the line needs them.\n\nSo, what I get is that, on the one hand, it recommends to use some aspects of the global variables functionality (the differences between DEFVAR and DEFPARAMETER) to help with REPL-based development. To me, this is odd because I would guess that any REPL-based development should rather rely on other contructs which are less risky than global variables. But I guess in the context of short scripts this would be fine.\n\nSecond, it seems to use the example of \"stdin\" being global in other languages as an argument in favor of some use of global variables. I would say that, at most, global state can be appropriate when it represents something that is genuinely global to your entire program's context, such as stdin. But this might be pushing it too far. Also, many modern languages have moved to namespaced approaches for these things (maybe with Ruby as an exception), so it's not universal.\n\nI understand CL has unique features around lexical redefinition of special variables, but I'm curious how the community views the role of global variables in well-structured programs today."
    },
    {
        "link": "https://jtra.cz/stuff/lisp/sclr/defparameter.html",
        "document": ""
    },
    {
        "link": "https://github.com/lmj/global-vars",
        "document": "In Common Lisp, a special variable that is never dynamically bound typically serves as a stand-in for a global variable. The library provides true global variables that are implemented by some compilers. An attempt to rebind a global variable properly results in a compiler error. That is, a global variable cannot be dynamically bound.\n\nGlobal variables therefore allow us to communicate an intended usage that differs from special variables. Global variables are also more efficient than special variables, especially in the presence of threads.\n• Subsequent redefinitions will not change the value (like ). The argument is evaluated at compile-time. On SBCL, this permits optimizations based upon the invariant that is always bound.\n• Same as except is evaluated at load time, not compile time.\n• Same as except subsequent redefinitions will update the value (like ).\n• Same as except is evaluated at load time, not compile time.\n• LispWorks: , in particular and .\n\nFor these implementations, rebinding a global variable is a compilation error.\n\nOn other implementations, a global variable is implemented as a symbol macro which expands to a form. Rebinding a global variable will (unfortunately) not signal an error.\n\nIt is recommended to use a naming convention for global variables, such as . This makes it clear that is a mistake even if the compiler doesn't catch it."
    },
    {
        "link": "http://ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_format.html",
        "document": ""
    },
    {
        "link": "https://gigamonkeys.com/book/a-few-format-recipes",
        "document": "Common Lisp's function is--along with the extended macro--one of the two Common Lisp features that inspires a strong emotional response in a lot of Common Lisp users. Some love it; others hate it.1\n\n's fans love it for its great power and concision, while its detractors hate it because of the potential for misuse and its opacity. Complex control strings sometimes bear a suspicious resemblance to line noise, but remains popular with Common Lispers who like to be able to generate little bits of human-readable output without having to clutter their code with lots of output-generating code. While 's control strings can be cryptic, at least a single expression doesn't clutter things up too badly. For instance, suppose you want to print the values in a list delimited with commas. You could write this:\n\nThat's not too bad, but anyone reading this code has to mentally parse it just to figure out that all it's doing is printing the contents of to standard output. On the other hand, you can tell at a glance that the following expression is printing , in some form, to standard output:\n\nIf you care exactly what form the output will take, then you'll have to examine the control string, but if all you want is a first-order approximation of what this line of code is doing, that's immediately available.\n\nAt any rate, you should have at least a reading knowledge of , and it's worth getting a sense of what it can do before you affiliate yourself with the pro- or anti- camp. It's also important to understand at least the basics of because other standard functions, such as the condition-signaling functions discussed in the next chapter, use -style control strings to generate output.\n\nTo further complicate matters, supports three quite different kinds of formatting: printing tables of data, pretty-printing s-expressions, and generating human-readable messages with interpolated values. Printing tables of data as text is a bit pass� these days; it's one of those reminders that Lisp is nearly as old as FORTRAN. In fact, several of the directives you can use to print floating-point values in fixed-width fields were based quite directly on FORTRAN edit descriptors, which are used in FORTRAN to read and print columns of data arranged in fixed-width fields. However, using Common Lisp as a FORTRAN replacement is beyond the scope of this book, so I won't discuss those aspects of .\n\nPretty-printing is likewise beyond the scope of this book--not because it's pass� but just because it's too big a topic. Briefly, the Common Lisp pretty printer is a customizable system for printing block-structured data such as--but not limited to--s-expressions while varying indentation and dynamically adding line breaks as needed. It's a great thing when you need it, but it's not often needed in day-to-day programming.2\n\nInstead, I'll focus on the parts of you can use to generate human-readable strings with interpolated values. Even limiting the scope in that way, there's still a fair bit to cover. You shouldn't feel obliged to remember every detail described in this chapter. You can get quite far with just a few idioms. I'll describe the most important features of first; it's up to you how much of a wizard you want to become.\n\nAs you've seen in previous chapters, the function takes two required arguments: a destination for its output and a control string that contains literal text and embedded directives. Any additional arguments provide the values used by the directives in the control string that interpolate values into the output. I'll refer to these arguments as format arguments.\n\nThe first argument to , the destination for the output, can be , , a stream, or a string with a fill pointer. is shorthand for the stream , while causes to generate its output to a string, which it then returns.3 If the destination is a stream, the output is written to the stream. And if the destination is a string with a fill pointer, the formatted output is added to the end of the string and the fill pointer is adjusted appropriately. Except when the destination is and it returns a string, returns .\n\nThe second argument, the control string, is, in essence, a program in the language. The language isn't Lispy at all--its basic syntax is based on characters, not s-expressions, and it's optimized for compactness rather than easy comprehension. This is why a complex control string can end up looking like line noise.\n\nMost of 's directives simply interpolate an argument into the output in one form or another. Some directives, such as , which causes to emit a newline, don't consume any arguments. And others, as you'll see, can consume more than one argument. One directive even allows you to jump around in the list of arguments in order to process the same argument more than once or to skip certain arguments in certain situations. But before I discuss specific directives, let's look at the general syntax of a directive.\n\nAll directives start with a tilde ( ) and end with a single character that identifies the directive. You can write the character in either upper- or lowercase. Some directives take prefix parameters, which are written immediately following the tilde, separated by commas, and used to control things such as how many digits to print after the decimal point when printing a floating-point number. For example, the directive, one of the directives used to print floating-point values, by default prints two digits following the decimal point.\n\nHowever, with a prefix parameter, you can specify that it should print its argument to, say, five decimal places like this:\n\nThe values of prefix parameters are either numbers, written in decimal, or characters, written as a single quote followed by the desired character. The value of a prefix parameter can also be derived from the format arguments in two ways: A prefix parameter of causes to consume one format argument and use its value for the prefix parameter. And a prefix parameter of will be evaluated as the number of remaining format arguments. For example:\n\nI'll give some more realistic examples of how you can use the argument in the section \"Conditional Formatting.\"\n\nYou can also omit prefix parameters altogether. However, if you want to specify one parameter but not the ones before it, you must include a comma for each unspecified parameter. For instance, the directive, another directive for printing floating-point values, also takes a parameter to control the number of decimal places to print, but it's the second parameter rather than the first. If you want to use to print a number to five decimal places, you can write this:\n\nYou can also modify the behavior of some directives with colon and at-sign modifiers, which are placed after any prefix parameters and before the directive's identifying character. These modifiers change the behavior of the directive in small ways. For instance, with a colon modifier, the directive used to output integers in decimal emits the number with commas separating every three digits, while the at-sign modifier causes to include a plus sign when the number is positive.\n\nWhen it makes sense, you can combine the colon and at-sign modifiers to get both modifications.\n\nIn directives where the two modified behaviors can't be meaningfully combined, using both modifiers is either undefined or given a third meaning.\n\nNow you're ready to look at specific directives. I'll start with several of the most commonly used directives, including some you've seen in previous chapters.\n\nThe most general-purpose directive is , which consumes one format argument of any type and outputs it in aesthetic (human-readable) form. For example, strings are output without quotation marks or escape characters, and numbers are output in a natural way for the type of number. If you just want to emit a value for human consumption, this directive is your best bet.\n\nA closely related directive, , likewise consumes one format argument of any type and outputs it. However, tries to generate output that can be read back in with . Thus, strings will be enclosed in quotation marks, symbols will be package-qualified when necessary, and so on. Objects that don't have a able representation are printed with the unreadable object syntax, . With a colon modifier, both the and directives emit as rather than . Both the and directives also take up to four prefix parameters, which can be used to control whether padding is added after (or before with the at-sign modifier) the value, but those parameters are only really useful for generating tabular data.\n\nThe other two most frequently used directives are , which emits a newline, and , which emits a fresh line. The difference between the two is that always emits a newline, while emits one only if it's not already at the beginning of a line. This is handy when writing loosely coupled functions that each generate a piece of output and that need to be combined in different ways. For instance, if one function generates output that ends with a newline ( ) and another function generates some output that starts with a fresh line ( ), you don't have to worry about getting an extra blank line if you call them one after the other. Both of these directives can take a single prefix parameter that specifies the number of newlines to emit. The directive will simply emit that many newline characters, while the directive will emit either n - 1 or n newlines, depending on whether it starts at the beginning of a line.\n\nLess frequently used is the related directive, which causes to emit a literal tilde. Like the and directives, it can be parameterized with a number that controls how many tildes to emit.\n\nIn addition to the general-purpose directives, and , supports several directives that can be used to emit values of specific types in particular ways. One of the simplest of these is the directive, which is used to emit characters. It takes no prefix arguments but can be modified with the colon and at-sign modifiers. Unmodified, its behavior is no different from except that it works only with characters. The modified versions are more useful. With a colon modifier, outputs nonprinting characters such as space, tab, and newline by name. This is useful if you want to emit a message to the user about some character. For instance, the following:\n\ncan emit messages like this:\n\nbut also like the following:\n\nWith the at-sign modifier, will emit the character in Lisp's literal character syntax.\n\nWith both the colon and at-sign modifiers, the directive can print extra information about how to enter the character at the keyboard if it requires special key combinations. For instance, on the Macintosh, in certain applications you can enter a null character (character code 0 in ASCII or in any ASCII superset such as ISO-8859-1 or Unicode) by pressing the Control key and typing @. In OpenMCL, if you print the null character with the directive, it tells you this:\n\nHowever, not all Lisps implement this aspect of the directive. And even if they do, it may or may not be accurate--for instance, if you're running OpenMCL in SLIME, the key chord is intercepted by Emacs, invoking .4\n\nFormat directives dedicated to emitting numbers are another important category. While you can use the and directives to emit numbers, if you want fine control over how they're printed, you need to use one of the number-specific directives. The numeric directives can be divided into two subcategories: directives for formatting integer values and directives for formatting floating-point values.\n\nFive closely related directives format integer values: , , , , and . The most frequently used is the directive, which outputs integers in base 10.\n\nAs I mentioned previously, with a colon modifier it adds commas.\n\nAnd with an at-sign modifier, it always prints a sign.\n\nAnd the two modifiers can be combined.\n\nThe first prefix parameter can specify a minimum width for the output, and the second parameter can specify a padding character to use. The default padding character is space, and padding is always inserted before the number itself.\n\nThese parameters are handy for formatting things such as dates in a fixed-width format.\n\nThe third and fourth parameters are used in conjunction with the colon modifier: the third parameter specifies the character to use as the separator between groups and digits, and the fourth parameter specifies the number of digits per group. These parameters default to a comma and the number 3. Thus, you can use the directive without parameters to output large integers in standard format for the United States but can change the comma to a period and the grouping from 3 to 4 with .\n\nNote that you must use commas to hold the places of the unspecified width and padding character parameters, allowing them to keep their default values.\n\nThe , , and directives work just like the directive except they emit numbers in hexadecimal (base 16), octal (base 8), and binary (base 2).\n\nFinally, the directive is the general radix directive. Its first parameter is a number between 2 and 36 (inclusive) that indicates what base to use. The remaining parameters are the same as the four parameters accepted by the , , , and directives, and the colon and at-sign modifiers modify its behavior in the same way. The directive also has some special behavior when used with no prefix parameters, which I'll discuss in the section \"English-Language Directives.\"\n\nFour directives format floating-point values: , , , and . The first three of these are the directives based on FORTRAN's edit descriptors. I'll skip most of the details of those directives since they mostly have to do with formatting floating-point values for use in tabular form. However, you can use the , , and directives to interpolate floating-point values into text. The , or general, floating-point directive, on the other hand, combines aspects of the and directives in a way that only really makes sense for generating tabular output.\n\nThe directive emits its argument, which should be a number,5 in decimal format, possibly controlling the number of digits after the decimal point. The directive is, however, allowed to use computerized scientific notation if the number is sufficiently large or small. The directive, on the other hand, always emits numbers in computerized scientific notation. Both of these directives take a number of prefix parameters, but you need to worry only about the second, which controls the number of digits to print after the decimal point.\n\nThe , or monetary, directive is similar to but a bit simpler. As its name suggests, it's intended for emitting monetary units. With no parameters, it's basically equivalent to . To modify the number of digits printed after the decimal point, you use the first parameter, while the second parameter controls the minimum number of digits to print before the decimal point.\n\nAll three directives, , , and , can be made to always print a sign, plus or minus, with the at-sign modifier.6\n\nSome of the handiest directives for generating human-readable messages are the ones for emitting English text. These directives allow you to emit numbers as English words, to emit plural markers based on the value of a format argument, and to apply case conversions to sections of 's output.\n\nThe directive, which I discussed in \"Character and Integer Directives,\" when used with no base specified, prints numbers as English words or Roman numerals. When used with no prefix parameter and no modifiers, it emits the number in words as a cardinal number.\n\nWith the colon modifier, it emits the number as an ordinal.\n\nAnd with an at-sign modifier, it emits the number as a Roman numeral; with both an at-sign and a colon, it emits \"old-style\" Roman numerals in which fours and nines are written as IIII and VIIII instead of IV and IX.\n\nFor numbers too large to be represented in the given form, behaves like .\n\nTo help you generate messages with words properly pluralized, provides the directive, which simply emits an s unless the corresponding argument is .\n\nTypically, however, you'll use with the colon modifier, which causes it to reprocess the previous format argument.\n\nWith the at-sign modifier, which can be combined with the colon modifier, emits either y or ies.\n\nObviously, can't solve all pluralization problems and is no help for generating messages in other languages, but it's handy for the cases it does handle. And the directive, which I'll discuss in a moment, gives you a more flexible way to conditionalize parts of 's output.\n\nThe last directive for dealing with emitting English text is , which allows you to control the case of text in the output. Each is paired with a , and all the output generated by the portion of the control string between the two markers will be converted to all lowercase.\n\nYou can modify with an at sign to make it capitalize the first word in a section of text, with a colon to make it to capitalize all words, and with both modifiers to convert all text to uppercase. (A word for the purpose of this directive is a sequence of alphanumeric characters delimited by nonalphanumeric characters or the ends of the text.)\n\nIn addition to directives that interpolate arguments and modify other output, provides several directives that implement simple control constructs within the control string. One of these, which you used in Chapter 9, is the conditional directive This directive is closed by a corresponding , and in between are a number of clauses separated by . The job of the directive is to pick one of the clauses, which is then processed by . With no modifiers or parameters, the clause is selected by numeric index; the directive consumes a format argument, which should be a number, and takes the nth (zero-based) clause where N is the value of the argument.\n\nIf the value of the argument is greater than the number of clauses, nothing is printed.\n\nHowever, if the last clause separator is instead of , then the last clause serves as a default clause.\n\nIt's also possible to specify the clause to be selected using a prefix parameter. While it'd be silly to use a literal value in the control string, recall that used as a prefix parameter means the number of arguments remaining to be processed. Thus, you can define a format string such as the following:\n\nand then use it like this:\n\nNote that the control string actually contains two directives--both of which use to select the clause to use. The first consumes between zero and two arguments, while the second consumes one more, if available. will silently ignore any arguments not consumed while processing the control string.\n\nWith a colon modifier, the can contain only two clauses; the directive consumes a single argument and processes the first clause if the argument is and the second clause is otherwise. You used this variant of in Chapter 9 to generate pass/fail messages, like this:\n\nNote that either clause can be empty, but the directive must contain a .\n\nFinally, with an at-sign modifier, the directive can have only one clause. The directive consumes one argument and, if it's non- , processes the clause after backing up to make the argument available to be consumed again.\n\nAnother directive that you've seen already, in passing, is the iteration directive . This directive tells to iterate over the elements of a list or over the implicit list of the format arguments.\n\nWith no modifiers, consumes one format argument, which must be a list. Like the directive, which is always paired with a directive, the directive is always paired with a closing }. The text between the two markers is processed as a control string, which draws its arguments from the list consumed by the directive. will repeatedly process this control string for as long as the list being iterated over has elements left. In the following example, the consumes the single format argument, the list , and then processes the control string , repeating until all the elements of the list have been consumed.\n\nHowever, it's annoying that in the output the last element of the list is followed by a comma and a space. You can fix that with the directive; within the body of a directive, the causes the iteration to stop immediately, without processing the rest of the control string, when no elements remain in the list. Thus, to avoid printing the comma and space after the last element of a list, you can precede them with a .\n\nThe first two times through the iteration, there are still unprocessed elements in the list when the is processed. The third time through, however, after the directive consumes the , the will cause to break out of the iteration without printing the comma and space.\n\nWith an at-sign modifier, processes the remaining format arguments as a list.\n\nWithin the body of a }, the special prefix parameter refers to the number of items remaining to be processed in the list rather than the number of remaining format arguments. You can use that, along with the directive, to print a comma-separated list with an \"and\" before the last item like this:\n\nHowever, that doesn't really work right if the list is two items long because it adds an extra comma.\n\nYou could fix that in a bunch of ways. The following takes advantage of the behavior of when nested inside another or directive--it iterates over whatever items remain in the list being iterated over by the outer . You can combine that with a directive to make the following control string for formatting lists according to English grammar:\n\nWhile that control string verges on being \"write-only\" code, it's not too hard to understand if you take it a bit at a time. The outer } will consume and iterate over a list. The whole body of the iteration then consists of a ; the output generated each time through the iteration will thus depend on the number of items left to be processed from the list. Splitting apart the directive on the clause separators, you can see that it's made up of four clauses, the last of which is a default clause because it's preceded by a rather than a plain . The first clause, for when there are zero elements to be processed, is empty, which makes sense--if there are no more elements to be processed, the iteration would've stopped already. The second clause handles the case of one element with a simple directive. Two elements are handled with . And the default clause, which handles three or more elements, consists of another iteration directive, this time using to iterate over the remaining elements of the list being processed by the outer . And the body of that iteration is the control string that can handle a list of three or more elements correctly, which is fine in this context. Because the loop consumes all the remaining list items, the outer loop iterates only once.\n\nIf you wanted to print something special such as \"<empty>\" when the list was empty, you have a couple ways to do it. Perhaps the easiest is to put the text you want into the first (zeroth) clause of the outer and then add a colon modifier to the closing } of the outer iteration--the colon forces the iteration to be run at least once, even if the list is empty, at which point processes the zeroth clause of the conditional directive.\n\nAmazingly, the directive provides even more variations with different combinations of prefix parameters and modifiers. I won't discuss them other than to say you can use an integer prefix parameter to limit the maximum number of iterations and that, with a colon modifier, each element of the list (either an actual list or the list constructed by the directive) must itself be a list whose elements will then be used as arguments to the control string in the } directive.\n\nA much simpler directive is the directive, which allows you to jump around in the list of format arguments. In its basic form, without modifiers, it simply skips the next argument, consuming it without emitting anything. More often, however, it's used with a colon modifier, which causes it to move backward, allowing the same argument to be used a second time. For instance, you can use to print a numeric argument once as a word and once in numerals like this:\n\nOr you could implement a directive similar to for an irregular plural by combing with .\n\nIn this control string, the prints the format argument as a cardinal number. Then the directive backs up so the number is also used as the argument to the directive, selecting between the clauses for when the number is zero, one, or anything else.7\n\nWithin an directive, skips or backs up over the items in the list. For instance, you could print only the keys of a plist like this:\n\nThe directive can also be given a prefix parameter. With no modifiers or with the colon modifier, this parameter specifies the number of arguments to move forward or backward and defaults to one. With an at-sign modifier, the prefix parameter specifies an absolute, zero-based index of the argument to jump to, defaulting to zero. The at-sign variant of can be useful if you want to use different control strings to generate different messages for the same arguments and if different messages need to use the arguments in different orders.8\n\nAnd there's more--I haven't mentioned the directive, which can take snippets of control strings from the format arguments or the directive, which allows you to call an arbitrary function to handle the next format argument. And then there are all the directives for generating tabular and pretty-printed output. But the directives discussed in this chapter should be plenty for the time being.\n\nIn the next chapter, you'll move onto Common Lisp's condition system, the Common Lisp analog to other languages' exception and error handling systems.\n\n1Of course, most folks realize it's not worth getting that worked up over anything in a programming language and use it or not without a lot of angst. On the other hand, it's interesting that these two features are the two features in Common Lisp that implement what are essentially domain-specific languages using a syntax not based on s-expressions. The syntax of 's control strings is character based, while the extended macro can be understood only in terms of the grammar of the keywords. That one of the common knocks on both and is that they \"aren't Lispy enough\" is evidence that Lispers really do like the s-expression syntax. 2Readers interested in the pretty printer may want to read the paper \"XP: A Common Lisp Pretty Printing System\" by Richard Waters. It's a description of the pretty printer that was eventually incorporated into Common Lisp. You can download it from . 3To slightly confuse matters, most other I/O functions also accept and as stream designators but with a different meaning: as a stream designator, designates the bidirectional stream , while designates as an output stream and as an input stream. 4This variant on the directive makes more sense on platforms like the Lisp Machines where key press events were represented by Lisp characters. 5Technically, if the argument isn't a real number, is supposed to format it as if by the directive, which in turn behaves like the directive if the argument isn't a number, but not all implementations get this right. 6Well, that's what the language standard says. For some reason, perhaps rooted in a common ancestral code base, several Common Lisp implementations don't implement this aspect of the directive correctly. 7If you find \"I saw zero elves\" to be a bit clunky, you could use a slightly more elaborate format string that makes another use of like this: (format nil \"I saw ~[no~:;~:*~r~] el~:*~[ves~;f~:;ves~].\" 0) ==> \"I saw no elves.\" (format nil \"I saw ~[no~:;~:*~r~] el~:*~[ves~;f~:;ves~].\" 1) ==> \"I saw one elf.\" (format nil \"I saw ~[no~:;~:*~r~] el~:*~[ves~;f~:;ves~].\" 2) ==> \"I saw two elves.\" 8This kind of problem can arise when trying to localize an application and translate human-readable messages into different languages. can help with some of these problems but is by no means a full-blown localization system."
    },
    {
        "link": "https://cs.cmu.edu/Groups/AI/html/cltl/clm/node200.html",
        "document": "The function is very useful for producing nicely formatted text, producing good-looking messages, and so on. can generate a string or output to a stream.\n\nFormatted output is performed not only by the function itself but by certain other functions that accept a control string ``the way does.'' For example, error-signaling functions such as accept control strings.\n\nis used to produce formatted output. outputs the characters of control-string, except that a tilde ( ) introduces a directive. The character after the tilde, possibly preceded by prefix parameters and modifiers, specifies what kind of formatting is desired. Most directives use one or more elements of arguments to create their output; the typical directive puts the next element of arguments into the output, formatted in some special way. It is an error if no argument remains for a directive requiring an argument, but it is not an error if one or more arguments remain unprocessed by a directive.\n\nThe output is sent to destination. If destination is , a string is created that contains the output; this string is returned as the value of the call to .\n\n\n\n X3J13 voted in January 1989 (STREAM-ACCESS) to specify that when the first argument to is , creates a stream of type in much the same manner as . (This stream may be visible to the user if, for example, the directive is used to print a structure that has a user-supplied print function.) \n\n\n\nIn all other cases returns , performing output to destination as a side effect. If destination is a stream, the output is sent to it. If destination is , the output is sent to the stream that is the value of the variable . If destination is a string with a fill pointer, then in effect the output characters are added to the end of the string (as if by use of ).\n\nThe function includes some extremely complicated and specialized features. It is not necessary to understand all or even most of its features to use effectively. The beginner should skip over anything in the following documentation that is not immediately useful or clear. The more sophisticated features (such as conditionals and iteration) are there for the convenience of programs with especially complicated formatting requirements.\n\nA directive consists of a tilde ( ), optional prefix parameters separated by commas, optional colon ( ) and at-sign ( ) modifiers, and a single character indicating what kind of directive this is. The alphabetic case of the directive character is ignored. The prefix parameters are generally integers, notated as optionally signed decimal numbers.\n\n\n\n X3J13 voted in June 1987 (FORMAT-ATSIGN-COLON) to specify that if both colon and at-sign modifiers are present, they may appear in either order; thus and mean the same thing. However, it is traditional to put the colon first, and all the examples in this book put colons before at-signs. \n\n\n\nSometimes a prefix parameter is used to specify a character, for instance the padding character in a right- or left-justifying operation. In this case a single quote ( ) followed by the desired character may be used as a prefix parameter, to mean the character object that is the character following the single quote. For example, you can use to print an integer in decimal radix in five columns with leading zeros, or to get leading asterisks.\n\nIn place of a prefix parameter to a directive, you can put the letter (or ), which takes an argument from arguments for use as a parameter to the directive. Normally this should be an integer or character object, as appropriate. This feature allows variable-width fields and the like. If the argument used by a parameter is , the effect is as if the parameter had been omitted. You may also use the character in place of a parameter; it represents the number of arguments remaining to be processed.\n\nIt is an error to give a format directive more parameters than it is described here as accepting. It is also an error to give colon or at-sign modifiers to a directive in a combination not specifically described here as being meaningful.\n\n\n\n X3J13 voted in January 1989 (FORMAT-PRETTY-PRINT) to clarify the interaction between and the various printer control variables (those named ). This is important because many operations are defined, directly or indirectly, in terms of or , which are affected by the printer control variables. The general rule is that does not bind any of the standard printer control variables except as specified in the individual descriptions of directives. An implementation may not bind any standard printer control variable not specified in the description of a directive, nor may an implementation fail to bind any standard printer control variables that is specified to be bound by such a description. (See these descriptions for specific changes voted by X3J13.)\n\nOne consequence of this change is that the user is guaranteed to be able to use the and directives to do pretty printing, under control of the variable. Implementations have differed on this point in their interpretations of the first edition. The new directive may be more appropriate than either and for some purposes, whether for pretty printing or ordinary printing. See section 27.4 for a discussion of and other new directives related to pretty printing. \n\n\n\nHere are some relatively simple examples to give you the general flavor of how is used.\n\nIn the descriptions of the directives that follow, the term arg in general refers to the next item of the set of arguments to be processed. The word or phrase at the beginning of each description is a mnemonic (not necessarily an accurate one) for the directive.\n\nRadix. prints arg in radix n. The modifier flags and any remaining parameters are used as for the directive. Indeed, is the same as . The full form here is therefore . \n\n X3J13 voted in January 1989 (FORMAT-PRETTY-PRINT) to specify that binds to , to , and to the value of the first parameter during the processing of the directive with a parameter. \n\n If no parameters are given to , then an entirely different interpretation is given. \n\n Notice of correction. In the first edition, this sentence referred to ``arguments'' given to . The correct term is ``parameters.'' \n\n The argument should be an integer; suppose it is . Then prints arg as a cardinal English number: ; prints arg as an ordinal English number: ; prints arg as a Roman numeral: ; and prints arg as an old Roman numeral: . \n\n X3J13 voted in January 1989 (FORMAT-PRETTY-PRINT) to specify that binds to during the processing of the directive with no parameter. The first edition did not specify how and its variants should handle arguments that are very large or not positive. Actual practice varies, and X3J13 has not yet addressed the topic. Here is a sampling of current practice. For and , nearly all implementations produce Roman numerals only for integers in the range 1 to 3999, inclusive. Some implementations will produce old-style Roman numerals for integers in the range 1 to 4999, inclusive. All other integers are printed in decimal notation, as if had been used. For zero, most implementations print for and for . For with a negative argument, most implementations simply print the word followed by its absolute value as a cardinal in English. For with a negative argument, some implementations also print the word followed by its absolute value as an ordinal in English; other implementations print the absolute value followed by the word . Thus the argument might produce or . Each has its charm, but one is not always a suitable substitute for the other; users should be careful. There is standard English nomenclature for fairly large integers (up to , at least), based on appending the suffix -illion to Latin names of integers. Thus we have the names trillion, quadrillion, sextillion, septillion, and so on. For extremely large integers, one may express powers of ten in English. One implementation gives (which is , the result of ) in this manner: one times ten to the sixtieth power six hundred six times ten to the fifty-seventh power nine hundred thirty-eight septdecillion forty-four sexdecillion two hundred fifty-eight quindecillion nine hundred ninety quattuordecillion two hundred seventy-five tredecillion five hundred forty-one duodecillion nine hundred sixty-two undecillion ninety-two decillion three hundred forty-one nonillion one hundred sixty-two octillion six hundred two septillion five hundred twenty-two sextillion two hundred two quintillion nine hundred ninety-three quadrillion seven hundred eighty-two trillion seven hundred ninety-two billion eight hundred thirty-five million three hundred one thousand three hundred seventy-six Another implementation prints it this way (note the use of ): one times ten to the sixtieth power plus six hundred six times ten to the fifty-seventh power plus ... plus two hundred seventy-five times ten to the forty-second power plus five hundred forty-one duodecillion nine hundred sixty-two undecillion ... three hundred seventy-six Unfortunately, the meaning of this nomenclature differs between American English (in which k-illion means , so one trillion is ) and British English (in which k-illion means , so one trillion is ). To avoid both confusion and prolixity, I recommend using decimal notation for all numbers above 999,999,999; this is similar to the escape hatch used for Roman numerals. \n\n Plural. If arg is not to the integer , a lowercase is printed; if arg is to , nothing is printed. (Notice that if arg is a floating-point , the is printed.) does the same thing, after doing a to back up one argument; that is, it prints a lowercase if the last argument was not . This is useful after printing a number using . prints if the argument is , or if it is not. does the same thing, but backs up first. Character. The next arg should be a character; it is printed according to the modifier flags. \n\n prints the character in an implementation-dependent abbreviated format. This format should be culturally compatible with the host environment. \n\n \n\n X3J13 voted in June 1987 (FORMAT-OP-C) to specify that performs exactly the same action as if the character to be printed has zero for its bits attributes. X3J13 voted in March 1989 (CHARACTER-PROPOSAL) to eliminate the bits and font attributes, replacing them with the notion of implementation-defined attributes. The net effect is that characters whose implementation-defined attributes all have the ``standard'' values should be printed by in the same way that would print them. \n\n spells out the names of the control bits and represents non-printing characters by their names: , , . This is a ``pretty'' format for printing characters. prints what would, and then if the character requires unusual shift keys on the keyboard to type it, this fact is mentioned: . This is the format for telling the user about a key he or she is expected to type, in prompts, for instance. The precise output may depend not only on the implementation but on the particular I/O devices in use. prints the character so that the Lisp reader can read it, using syntax. \n\n X3J13 voted in January 1989 (FORMAT-PRETTY-PRINT) to specify that binds to during the processing of the directive. Other variants of the directive do not bind any printer control variables. \n\n\n\nFixed-format floating-point. The next arg is printed as a floating-point number. The full form is . The parameter w is the width of the field to be printed; d is the number of digits to print after the decimal point; k is a scale factor that defaults to zero. Exactly w characters will be output. First, leading copies of the character padchar (which defaults to a space) are printed, if necessary, to pad the field on the left. If the arg is negative, then a minus sign is printed; if the arg is not negative, then a plus sign is printed if and only if the modifier was specified. Then a sequence of digits, containing a single embedded decimal point, is printed; this represents the magnitude of the value of arg times , rounded to d fractional digits. (When rounding up and rounding down would produce printed values equidistant from the scaled value of arg, then the implementation is free to use either one. For example, printing the argument using the format may correctly produce either or .) Leading zeros are not permitted, except that a single zero digit is output before the decimal point if the printed value is less than 1, and this single zero digit is not output after all if w=d+1. If it is impossible to print the value in the required format in a field of width w, then one of two actions is taken. If the parameter overflowchar is specified, then w copies of that parameter are printed instead of the scaled value of arg. If the overflowchar parameter is omitted, then the scaled value is printed using more than w characters, as many more as may be needed. If the w parameter is omitted, then the field is of variable width. In effect, a value is chosen for w in such a way that no leading pad characters need to be printed and exactly d characters will follow the decimal point. For example, the directive will print exactly two digits after the decimal point and as many as necessary before the decimal point. If the parameter d is omitted, then there is no constraint on the number of digits to appear after the decimal point. A value is chosen for d in such a way that as many digits as possible may be printed subject to the width constraint imposed by the parameter w and the constraint that no trailing zero digits may appear in the fraction, except that if the fraction to be printed is zero, then a single zero digit should appear after the decimal point if permitted by the width constraint. If both w and d are omitted, then the effect is to print the value using ordinary free-format output; uses this format for any number whose magnitude is either zero or between (inclusive) and (exclusive). If w is omitted, then if the magnitude of arg is so large (or, if d is also omitted, so small) that more than 100 digits would have to be printed, then an implementation is free, at its discretion, to print the number using exponential notation instead, as if by the directive (with all parameters to defaulted, not taking their values from the directive). If arg is a rational number, then it is coerced to be a and then printed. (Alternatively, an implementation is permitted to process a rational number by any other method that has essentially the same behavior but avoids such hazards as loss of precision or overflow because of the coercion. However, note that if w and d are unspecified and the number has no exact decimal representation, for example , some precision cutoff must be chosen by the implementation: only a finite number of digits may be printed.) If arg is a complex number or some non-numeric object, then it is printed using the format directive , thereby printing it in decimal radix and a minimum field width of w. (If it is desired to print each of the real part and imaginary part of a complex number using a directive, then this must be done explicitly with two directives and code to extract the two parts of the complex number.) \n\n X3J13 voted in January 1989 (FORMAT-PRETTY-PRINT) to specify that binds to during the processing of the directive. \n\n\n\nThe presence or absence of the modifier corresponds to the effect of the Fortran or edit descriptor; nothing in Common Lisp corresponds to the Fortran edit descriptor.\n\nThe scale factor specified by the parameter k corresponds to the scale factor k specified by the Fortran edit descriptor.\n\nIn Fortran, the leading zero that precedes the decimal point when the printed value is less than 1 is optional; in Common Lisp, the implementation is required to print that zero digit.\n\nIn Common Lisp, the w and d parameters are optional; in Fortran, they are required.\n\nIn Common Lisp, the pad character and overflow character are user-specifiable; in Fortran, they are always space and asterisk, respectively.\n\nA Fortran implementation is prohibited from printing a representation of negative zero; Common Lisp permits the printing of such a representation when appropriate.\n\nIn MacLisp and Lisp Machine Lisp, the format directive takes a single parameter: the number of digits to use in the printed representation. This incompatibility between Common Lisp and MacLisp was introduced for the sake of cultural compatibility with Fortran.\n\nExponential floating-point. The next arg is printed in exponential notation. The full form is . The parameter w is the width of the field to be printed; d is the number of digits to print after the decimal point; e is the number of digits to use when printing the exponent; k is a scale factor that defaults to 1 (not zero). Exactly w characters will be output. First, leading copies of the character padchar (which defaults to a space) are printed, if necessary, to pad the field on the left. If the arg is negative, then a minus sign is printed; if the arg is not negative, then a plus sign is printed if and only if the modifier was specified. Then a sequence of digits, containing a single embedded decimal point, is printed. The form of this sequence of digits depends on the scale factor k. If k is zero, then d digits are printed after the decimal point, and a single zero digit appears before the decimal point if the total field width will permit it. If k is positive, then it must be strictly less than d+2; k significant digits are printed before the decimal point, and d-k+1 digits are printed after the decimal point. If k is negative, then it must be strictly greater than -d; a single zero digit appears before the decimal point if the total field width will permit it, and after the decimal point are printed first -k zeros and then d+k significant digits. The printed fraction must be properly rounded. (When rounding up and rounding down would produce printed values equidistant from the scaled value of arg, then the implementation is free to use either one. For example, printing using the format may correctly produce either or .) Following the digit sequence, the exponent is printed. First the character parameter exponentchar is printed; if this parameter is omitted, then the exponent marker that would use is printed, as determined from the type of the floating-point number and the current value of . Next, either a plus sign or a minus sign is printed, followed by e digits representing the power of 10 by which the printed fraction must be multiplied to properly represent the rounded value of arg. If it is impossible to print the value in the required format in a field of width w, possibly because k is too large or too small or because the exponent cannot be printed in e character positions, then one of two actions is taken. If the parameter overflowchar is specified, then w copies of that parameter are printed instead of the scaled value of arg. If the overflowchar parameter is omitted, then the scaled value is printed using more than w characters, as many more as may be needed; if the problem is that d is too small for the specified k or that e is too small, then a larger value is used for d or e as may be needed. If the w parameter is omitted, then the field is of variable width. In effect a value is chosen for w in such a way that no leading pad characters need to be printed. If the parameter d is omitted, then there is no constraint on the number of digits to appear. A value is chosen for d in such a way that as many digits as possible may be printed subject to the width constraint imposed by the parameter w, the constraint of the scale factor k, and the constraint that no trailing zero digits may appear in the fraction, except that if the fraction to be printed is zero, then a single zero digit should appear after the decimal point if the width constraint allows it. If the parameter e is omitted, then the exponent is printed using the smallest number of digits necessary to represent its value. If all of w, d, and e are omitted, then the effect is to print the value using ordinary free-format exponential-notation output; uses this format for any non-zero number whose magnitude is less than or greater than or equal to . \n\n X3J13 voted in January 1989 (FORMAT-E-EXPONENT-SIGN) to amend the previous paragraph as follows: If all of w, d, and e are omitted, then the effect is to print the value using ordinary free-format exponential-notation output; uses a similar format for any non-zero number whose magnitude is less than or greater than or equal to . The only difference is that the directive always prints a plus or minus sign before the exponent, while omits the plus sign if the exponent is non-negative. (The amendment reconciles this paragraph with the specification several paragraphs above that always prints a plus or minus sign before the exponent.) \n\n If arg is a rational number, then it is coerced to be a and then printed. (Alternatively, an implementation is permitted to process a rational number by any other method that has essentially the same behavior but avoids such hazards as loss of precision or overflow because of the coercion. However, note that if w and d are unspecified and the number has no exact decimal representation, for example , some precision cutoff must be chosen by the implementation: only a finite number of digits may be printed.) If arg is a complex number or some non-numeric object, then it is printed using the format directive , thereby printing it in decimal radix and a minimum field width of w. (If it is desired to print each of the real part and imaginary part of a complex number using a directive, then this must be done explicitly with two directives and code to extract the two parts of the complex number.) \n\n X3J13 voted in January 1989 (FORMAT-PRETTY-PRINT) to specify that binds to during the processing of the directive. \n\n Here is an example of the effects of varying the scale factor:\n\nThe presence or absence of the modifier corresponds to the effect of the Fortran or edit descriptor; nothing in Common Lisp corresponds to the Fortran edit descriptor.\n\nThe scale factor specified by the parameter k corresponds to the scale factor k specified by the Fortran edit descriptor; note, however, that the default value for k is 1 in Common Lisp, as opposed to the default value of zero in Fortran. (On the other hand, note that a scale factor of 1 is used for Fortran list-directed output, which is roughly equivalent to using with the w, d, e, and overflowchar parameters omitted.)\n\nIn Common Lisp, the w and d parameters are optional; in Fortran, they are required.\n\nIn Fortran, omitting e causes the exponent to be printed using either two or three digits; if three digits are required, then the exponent marker is omitted. In Common Lisp, omitting e causes the exponent to be printed using as few digits as possible; the exponent marker is never omitted.\n\nIn Common Lisp, the pad character and overflow character are user-specifiable; in Fortran they are always space and asterisk, respectively.\n\nA Fortran implementation is prohibited from printing a representation of negative zero; Common Lisp permits the printing of such a representation when appropriate.\n\nIn MacLisp and Lisp Machine Lisp, the format directive takes a single parameter: the number of digits to use in the printed representation. This incompatibility between Common Lisp and MacLisp was introduced for the sake of cultural compatibility with Fortran.\n\nThe Common Lisp rules for deciding between the use of and are compatible with the rules used by Fortran but have been extended to cover the cases where w or d is omitted or where e is specified.\n\nIn MacLisp and Lisp Machine Lisp, the format directive is equivalent to the Common Lisp directive. This incompatibility between Common Lisp and MacLisp was introduced for the sake of cultural compatibility with Fortran.\n\nDollars floating-point. The next arg is printed as a floating-point number in fixed-format notation. This format is particularly convenient for printing a value as dollars and cents. The full form is . The parameter d is the number of digits to print after the decimal point (default value 2); n is the minimum number of digits to print before the decimal point (default value 1); w is the minimum total width of the field to be printed (default value 0). First padding and the sign are output. If the arg is negative, then a minus sign is printed; if the arg is not negative, then a plus sign is printed if and only if the modifier was specified. If the modifier is used, the sign appears before any padding, and otherwise after the padding. If w is specified and the number of other characters to be output is less than w, then copies of padchar (which defaults to a space) are output to make the total field width equal w. Then n digits are printed for the integer part of arg, with leading zeros if necessary; then a decimal point; then d digits of fraction, properly rounded. If the magnitude of arg is so large that more than m digits would have to be printed, where m is the larger of w and 100, then an implementation is free, at its discretion, to print the number using exponential notation instead, as if by the directive , where w and padchar are present or omitted according to whether they were present or omitted in the directive, and where q=d+n-1, where d and n are the (possibly default) values given to the directive. If arg is a rational number, then it is coerced to be a and then printed. (Alternatively, an implementation is permitted to process a rational number by any other method that has essentially the same behavior but avoids such hazards as loss of precision or overflow because of the coercion.) If arg is a complex number or some non-numeric object, then it is printed using the format directive , thereby printing it in decimal radix and a minimum field width of w. (If it is desired to print each of the real part and imaginary part of a complex number using a directive, then this must be done explicitly with two directives and code to extract the two parts of the complex number.) \n\n X3J13 voted in January 1989 (FORMAT-PRETTY-PRINT) to specify that binds to during the processing of the directive. \n\n This outputs a character, thereby terminating the current output line and beginning a new one (see ). No arg is used. Simply putting a newline in the control string would work, but is often used because it makes the control string look nicer in the middle of a Lisp program. Unless it can be determined that the output stream is already at the beginning of a line, this outputs a newline (see ). calls and then outputs n-1 newlines. does nothing. This outputs a page separator character, if possible. does this n times. is vertical bar, not capital I. Tilde immediately followed by a newline ignores the newline and any following non-newline whitespace characters. With a , the newline is ignored, but any following whitespace is left in place. With an , the newline is left in place, but any following whitespace is ignored. This directive is typically used when a format control string is too long to fit nicely into one line of the program: (defun type-clash-error (fn nargs argnum right-type wrong-type) (format *error-output* \"~&Function ~S requires its ~:[~:R~;~*~] ~ argument to be of type ~S,~%but it was called ~ with an argument of type ~S.~%\" fn (eql nargs 1) argnum right-type wrong-type)) (type-clash-error 'aref nil 2 'integer 'vector) prints: Function AREF requires its second argument to be of type INTEGER, but it was called with an argument of type VECTOR. (type-clash-error 'car 1 1 'list 'short-float) prints: Function CAR requires its argument to be of type LIST, but it was called with an argument of type SHORT-FLOAT. Note that in this example newlines appear in the output only as specified by the and directives; the actual newline characters in the control string are suppressed because each is preceded by a tilde. Tabulate. This spaces over to a given column. will output sufficient spaces to move the cursor to column colnum. If the cursor is already at or beyond column colnum, it will output spaces to move it to column colnum+k*colinc for the smallest positive integer k possible, unless colinc is zero, in which case no spaces are output if the cursor is already at or beyond column colnum. colnum and colinc default to . Ideally, the current column position is determined by examination of the destination, whether a stream or string. (Although no user-level operation for determining the column position of a stream is defined by Common Lisp, such a facility may exist at the implementation level.) If for some reason the current absolute column position cannot be determined by direct inquiry, may be able to deduce the current column position by noting that certain directives (such as , or , or with the argument being a string containing a newline) cause the column position to be reset to zero, and counting the number of characters emitted since that point. If that fails, may attempt a similar deduction on the riskier assumption that the destination was at column zero when was invoked. If even this heuristic fails or is implementationally inconvenient, at worst the operation will simply output two spaces. (All this implies that code that uses is more likely to be portable if all format control strings that use the directive either begin with or to force a newline or are designed to be used only when the destination is known from other considerations to be at column zero.) performs relative tabulation. outputs colrel spaces and then outputs the smallest non-negative number of additional spaces necessary to move the cursor to a column that is a multiple of colinc. For example, the directive outputs three spaces and then moves the cursor to a ``standard multiple-of-eight tab stop'' if not at one already. If the current output column cannot be determined, however, then colinc is ignored, and exactly colrel spaces are output. \n\n X3J13 voted in June 1989 (PRETTY-PRINT-INTERFACE) to define and to perform tabulation relative to a point defined by the pretty printing process (see section 27.4). \n\n The next arg is ignored. ignores the next n arguments. ``ignores backwards''; that is, it backs up in the list of arguments so that the argument last processed will be processed again. backs up n arguments. When within a construct (see below), the ignoring (in either direction) is relative to the list of arguments being processed by the iteration. is an ``absolute goto'' rather than a ``relative goto'': it goes to the nth arg, where 0 means the first one; n defaults to 0, so goes back to the first arg. Directives after a will take arguments in sequence beginning with the one gone to. When within a construct, the ``goto'' is relative to the list of arguments being processed by the iteration. Indirection. The next arg must be a string, and the one after it a list; both are consumed by the directive. The string is processed as a control string, with the elements of the list as the arguments. Once the recursive processing of the control string has been finished, then processing of the control string containing the directive is resumed. Example: Note that in the second example three arguments are supplied to the control string , but only two are processed and the third is therefore ignored. With the modifier, only one arg is directly consumed. The arg must be a string; it is processed as part of the control string as if it had appeared in place of the construct, and any directives in the recursively processed control string may consume arguments of the control string containing the directive. Example: Here is a rather sophisticated example. The function itself, as implemented at one time in Lisp Machine Lisp, used a routine internal to the package called to signal error messages; in turn used , which used recursively. Now took a string and arguments, just like , but also printed the control string to (which at this point was available in the global variable ) and a little arrow showing where in the processing of the control string the error occurred. The variable pointed one character after the place of the error. (The character set used in the Lisp Machine Lisp implementation contains a down-arrow character , which is not a standard Common Lisp character.) This first processed the given string and arguments using , then output a newline, tabbed a variable amount for printing the down-arrow, and printed the control string between double quotes (note the use of to include double quotes within the control string). The effect was something like this: (format t \"The item is a ~[Foo~;Bar~;Loser~].\" 'quux) >>ERROR: The argument to the FORMAT \"~[\" command must be a number. \"The item is a ~[Foo~;Bar~;Loser~].\"\n\n\n\n X3J13 voted in June 1989 (PRETTY-PRINT-INTERFACE) to introduce certain directives to support the user interface to the pretty printer described in detail in chapter 27.\n\nThe format directives after this point are much more complicated than the foregoing; they constitute control structures that can perform case conversion, conditional selection, iteration, justification, and non-local exits. Used with restraint, they can perform powerful tasks. Used with abandon, they can produce completely unreadable and unmaintainable code.\n\nThe case-conversion, conditional, iteration, and justification constructs can contain other formatting constructs by bracketing them. These constructs must nest properly with respect to each other. For example, it is not legitimate to put the start of a case-conversion construct in each arm of a conditional and the end of the case-conversion construct outside the conditional:\n\nOne might expect this to produce either or , depending on whether is false or true; but in fact the construction is illegal because the and constructs are not properly nested.\n\nThe processing indirection caused by the directive is also a kind of nesting for the purposes of this rule of proper nesting. It is not permitted to start a bracketing construct within a string processed under control of a directive and end the construct at some point after the construct in the string containing that construct, or vice versa. For example, this situation is illegal:\n\nOne might expect it to produce , but in fact the construction is illegal because the and constructs are not properly nested.\n\nCase conversion. The contained control string str is processed, and what it produces is subject to case conversion: converts every uppercase character to the corresponding lowercase character; capitalizes all words, as if by ; capitalizes just the first word and forces the rest to lowercase; converts every lowercase character to the corresponding uppercase character. In this example, is used to cause the first word produced by to be capitalized: Conditional expression. This is a set of control strings, called clauses, one of which is chosen and used. The clauses are separated by and the construct is terminated by . For example, The argth clause is selected, where the first clause is number 0. If a prefix parameter is given (as ), then the parameter is used instead of an argument. (This is useful only if the parameter is specified by , to dispatch on the number of arguments remaining to be processed.) If arg is out of range, then no clause is selected (and no error is signaled). After the selected alternative has been processed, the control string continues after the . has a default case. If the last used to separate clauses is instead, then the last clause is an ``else'' clause that is performed if no other clause is selected. For example: selects the false control string if arg is , and selects the true control string otherwise. tests the argument. If it is not , then the argument is not used up by the command but remains as the next one to be processed, and the one clause true is processed. If the arg is , then the argument is used up, and the clause is not processed. The clause therefore should normally use exactly one argument, and may expect it to be non- . For example: The combination of and is useful, for example, for dealing with English conventions for printing lists: (setq foo \"Items:~#[ none~; ~S~; ~S and ~S~ ~:;~@{~#[~; and~] ~S~^,~}~].\") (format foo) => \"Items: none.\" (format foo 'foo) => \"Items: FOO.\" (format foo 'foo 'bar) => \"Items: FOO and BAR.\" (format foo 'foo 'bar 'baz) => \"Items: FOO, BAR, and BAZ.\" (format foo 'foo 'bar 'baz 'quux) => \"Items: FOO, BAR, BAZ, and QUUX.\" This separates clauses in and constructions. It is an error elsewhere. This terminates a . It is an error elsewhere. Iteration. This is an iteration construct. The argument should be a list, which is used as a set of arguments as if for a recursive call to . The string str is used repeatedly as the control string. Each iteration can absorb as many elements of the list as it likes as arguments; if str uses up two arguments by itself, then two elements of the list will get used up each time around the loop. If before any iteration step the list is empty, then the iteration is terminated. Also, if a prefix parameter n is given, then there will be at most n repetitions of processing of str. Finally, the directive can be used to terminate the iteration prematurely. Here are some simple examples: (format \"The winners are:~{ ~S~}.\" '(fred harry jill)) => \"The winners are: FRED HARRY JILL.\" (format \"Pairs:~{ <~S,~S>~}.\" '(a 1 b 2 c 3)) => \"Pairs: <A,1> <B,2> <C,3>.\" is similar, but the argument should be a list of sublists. At each repetition step, one sublist is used as the set of arguments for processing str; on the next repetition, a new sublist is used, whether or not all of the last sublist had been processed. Example: is similar to , but instead of using one argument that is a list, all the remaining arguments are used as the list of arguments for the iteration. Example: If the iteration is terminated before all the remaining arguments are consumed, then any arguments not processed by the iteration remain to be processed by any directives following the iteration construct. combines the features of and . All the remaining arguments are used, and each one must be a list. On each iteration, the next argument is used as a list of arguments to str. Example: Terminating the repetition construct with instead of forces str to be processed at least once, even if the initial list of arguments is null (however, it will not override an explicit prefix parameter of zero). If str is empty, then an argument is used as str. It must be a string and precede any arguments processed by the iteration. As an example, the following are equivalent: This will use as a formatting string. The says it will be processed at most once, and the says it will be processed at least once. Therefore it is processed exactly once, using as the arguments. This case may be handled more clearly by the directive, but this general feature of is more powerful than . This terminates a . It is an error elsewhere. Justification. This justifies the text produced by processing str within a field at least mincol columns wide. str may be divided up into segments with , in which case the spacing is evenly divided between the text segments. With no modifiers, the leftmost text segment is left-justified in the field, and the rightmost text segment right-justified; if there is only one text element, as a special case, it is right-justified. The modifier causes spacing to be introduced before the first text segment; the modifier causes spacing to be added after the last. The minpad parameter (default ) is the minimum number of padding characters to be output between each segment. The padding character is specified by padchar, which defaults to the space character. If the total width needed to satisfy these constraints is greater than mincol, then the width used is mincol+k*colinc for the smallest possible non-negative integer value k; colinc defaults to , and mincol defaults to . Note that str may include directives. All the clauses in str are processed in order; it is the resulting pieces of text that are justified. The directive may be used to terminate processing of the clauses prematurely, in which case only the completely processed clauses are justified. If the first clause of a is terminated with instead of , then it is used in a special way. All of the clauses are processed (subject to , of course), but the first one is not used in performing the spacing and padding. When the padded result has been determined, then if it will fit on the current line of output, it is output, and the text for the first clause is discarded. If, however, the padded text will not fit on the current line, then the text segment for the first clause is output before the padded text. The first clause ought to contain a newline (such as a directive). The first clause is always processed, and so any arguments it refers to will be used; the decision is whether to use the resulting segment of text, not whether to process the first clause. If the has a prefix parameter n, then the padded text must fit on the current line with n character positions to spare to avoid outputting the first clause's text. For example, the control string can be used to print a list of items separated by commas without breaking items over line boundaries, beginning each line with . The prefix parameter in accounts for the width of the comma that will follow the justified item if it is not the last element in the list, or the period if it is. If has a second prefix parameter, then it is used as the width of the line, thus overriding the natural line width of the output stream. To make the preceding example use a line width of 50, one would write If the second argument is not specified, then uses the line width of the output stream. If this cannot be determined (for example, when producing a string result), then uses as the line length. Terminates a . It is an error elsewhere. \n\n X3J13 voted in June 1989 (PRETTY-PRINT-INTERFACE) to introduce certain directives to support the user interface to the pretty printer. If is used to terminate a directive, the directive is equivalent to a call on . See section 27.4 for details. \n\n Up and out. This is an escape construct. If there are no more arguments remaining to be processed, then the immediately enclosing or construct is terminated. If there is no such enclosing construct, then the entire formatting operation is terminated. In the case, the formatting is performed, but no more segments are processed before doing the justification. The should appear only at the beginning of a clause, because it aborts the entire clause it appears in (as well as all following clauses). may appear anywhere in a construct. (setq donestr \"Done.~^ ~D warning~:P.~^ ~D error~:P.\") (format donestr) => \"Done.\" (format donestr 3) => \"Done. 3 warnings.\" (format donestr 1 5) => \"Done. 1 warning. 5 errors.\" If a prefix parameter is given, then termination occurs if the parameter is zero. (Hence is equivalent to .) If two parameters are given, termination occurs if they are equal. If three parameters are given, termination occurs if the first is less than or equal to the second and the second is less than or equal to the third. Of course, this is useless if all the prefix parameters are constants; at least one of them should be a or a parameter. If is used within a construct, then it merely terminates the current iteration step (because in the standard case it tests for remaining arguments of the current step only); the next iteration step commences immediately. To terminate the entire iteration process, use . \n\n X3J13 voted in March 1988 (FORMAT-COLON-UPARROW-SCOPE) to clarify the behavior of as follows. It may be used only if the command it would terminate is or . The entire iteration process is terminated if and only if the sublist that is supplying the arguments for the current iteration step is the last sublist (in the case of terminating a command) or the last argument to that call to (in the case of terminating a command). Note furthermore that while is equivalent to in all circumstances, is not equivalent to because the latter terminates the entire iteration if and only if no arguments remain for the current iteration step (as opposed to no arguments remaining for the entire iteration process). Here are some examples of the differences in the behaviors of , , and . For each sublist, `` '' appears after the first word unless there are no additional words. For each sublist, `` '' always appears after the first word, unless it is the last sublist, in which case the entire iteration is terminated. For each sublist, `` '' appears after the first word, but if the sublist has only one word then the entire iteration is terminated. \n\n If appears within a control string being processed under the control of a directive, but not within any or construct within that string, then the string being processed will be terminated, thereby ending processing of the directive. Processing then continues within the string containing the directive at the point following that directive. If appears within a or construct, then all the commands up to the are properly selected or case-converted, the or processing is terminated, and the outward search continues for a or construct to be terminated. For example: Here are some examples of the use of within a construct.\n\n\n\n X3J13 voted in June 1989 (PRETTY-PRINT-INTERFACE) to introduce user-defined directives in the form of the directive. See section 27.4 for details.\n\nThe hairiest control string I have ever seen in shown in table 22-8. It started innocently enough as part of the simulator for Connection Machine Lisp [44,57]; the xapping data type, defined by , needed a option so that xappings would print properly. As this data type became more complicated, step by step, so did the control string.\n\nSee the description of for a discussion of xappings and the definition. Assume that the predicate is true of a xapping if it is a xector, and that the predicate is true if every value in the range is the same as its corresponding index.\n\nHere is a blow-by-blow description of the parts of this format string:"
    },
    {
        "link": "https://en.wikipedia.org/wiki/Format_(Common_Lisp)",
        "document": "Format is a function in Common Lisp that can produce formatted text using a format string similar to the print format string. It provides more functionality than , allowing the user to output numbers in various formats (including, for instance: hex, binary, octal, roman numerals, and English), apply certain format specifiers only under certain conditions, iterate over data structures, output data tabularly, and even recurse, calling internally to handle data structures that include their own preferred formatting strings. This functionally originates in MIT's Lisp Machine Lisp,[1] where it was based on Multics.\n\nThe function is specified by the syntax:[2]\n\nDirectives in the control string are interpolated using the format arguments, and the thus constructed character sequence is written to the destination.\n\nThe destination may either be a stream, a dynamic string, , or the constant; the latter of which presents a special case in that it creates, formats and returns a new string object, while refers to the standard output, usually being equivalent to the console. Streams in Common Lisp comprehend, among others, string output and file streams; hence, being capable of writing to such a variety of destinations, this function unifies capabilities distributed among distinct commands in some other programming languages, such as C's for console output, for string formatting, and for file writing.\n\nThe multitude of destination types is exemplified in the following:\n\nThe control string may contain literal characters as well as the meta character (tilde), which demarcates format directives. While literals in the input are echoed verbatim, directives produce a special output, often consuming one or more format arguments.\n\nA format directive, introduced by a , is followed by zero or more prefix parameters, zero or more modifiers, and the directive type. A directive definition, hence, must conform to the following pattern:\n\nThe directive type is always specified by a single character, case-insensitive in the case of letters. The data to be processed by a format directive, if at all necessary, is called its format argument and may be zero or more objects of any type compatible. Whether and in which quantity such data is accepted depends on the directive and potential modifiers applied unto it. The directive type , for instance, abstains from the consumption of any format arguments, whereas expects exactly one integer number to print, and , a directive influenced by the at-sign modifier, processes all remaining arguments.\n\nThe following directive, , expects one number object from the format arguments and writes its binary (radix 2) equivalent to the standard output.\n\nWhere configurations are permissive, prefix parameters may be specified.\n\nPrefix parameters enable an injection of additional information into a directive to operate upon, similar to the operation of parameters when provided to a function. Prefix parameters are always optional, and, if provided, must be located between the introducing and either the modifiers or, if none present, the directive type. The values are separated by commas, but do not tolerate white spaces on either side. The number and type of these parameters depends on the directive and the influence of potential modifiers.\n\nTwo particular characters may be utilized as prefix parameter values with distinctive interpretation: or acts as a placeholder for an integer number or character from the format arguments which is consumed and placed into its stead. The second special character, , is substituted by the tally of format arguments yet abiding their consumption. Both and enable behavior defined by dynamic content injected into the prefix parameter list.\n\nThe parameter value introduces a functionality equivalent to a variable in the context of general programming. Given this simple scenario, in order to left-pad a binary representation of the integer number to at least eight digits with zeros, the literal solution is as follows:\n\nThe first prefix parameter controlling the output width may, however, be defined in terms of the character, delegating the parameter value specification to the next format argument, in our case .\n\nSolutions of this kind are particularly a benefit if parts of the prefix parameter list shall be described by variables or function arguments instead of literals, as is the case in the following piece of code:\n\nEven more fitting in those situations involving external input, a function argument may be passed into the format directive:\n\nas a prefix parameter tallies those format arguments not yet processed by preceding directives, doing so without actually consuming anything from this list. The utility of such a dynamically inserted value is preponderantly restricted to use cases pertaining to conditional processing. As the argument number can only be an integer number greater than or equal to zero, its significance coincides with that of an index into the clauses of a conditional directive.\n\nThe interplay of the special prefix parameter value with the conditional selection directive is illustrated in the following example. The condition states four clauses, accessible via the indices 0, 1, 2, and 3 respectively. The number of format arguments is employed as the means for the clause index retrieval; to do so, we insert into the conditional directive which permits the index to be a prefix parameter. computes the tally of format arguments and suggests this number as the selection index. The arguments, not consumed by this act, are then available to and processed by the selected clause's directives.\n\nModifiers act in the capacity of flags intending to influence the behavior of a directive. The admission, magnitude of behavioral modification and effect, as with prefix parameters, depends upon the directive. In some severe cases, the syntax of a directive may be varied to a degree as to invalidate certain prefix parameters; this power especially distinguishes modifiers from most parameters. The two valid modifier characters are (at-sign) and (colon), possibly in combination as either or .\n\nThe following example illustrates a rather mild case of influence exerted upon a directive by the modifier: It merely ensures that the binary representation of a formatted number is always preceded by the number's sign:\n\nAn enumeration of the format directives, including their complete syntax and modifier effects, is adduced below.[3]\n\nIf the destination is not at the beginning of a fresh line, prints line breaks; otherwise, prints - 1 line breaks. Either prints the number in the specified base (radix) or spells it out. .\n• With prefix parameters, prints the argument in the radix (base).\n• Without prefix parameters, the format argument is spelt out, either in English letters or in Roman numerals. Prints the argument as an English number. Prints the argument in Roman numerals using the usual Roman format (e.g., 4 = IV). Prints the argument in Roman numerals using the old Roman format (e.g., 4 = IIII). Prints as decimal number without (plus) sign or group separator. Prepends the sign and uses commas as group separator. Prints as binary number without (plus) sign or group separator. Prepends the sign and uses commas as group separator. Prints as octal number without (plus) sign or group separator. Prepends the sign and uses commas as group separator. Prints as hexadecimal number without (plus) sign or group separator. Prepends the sign and uses commas as group separator. Prints the argument as a float in fixed-point notation. Prints as fixed-point without (plus) sign. Prints the argument as a float in exponential notation. Prints as exponential without (plus) sign. Prints the argument either as a float in fixed-point or exponential notation, choosing automatically. Prints as fixed-point or exponential without (plus) sign. Prints the argument according to monetary conventions. Prints in monetary conventions without (plus) sign or padding. Prints as empty list instead of . Pads on the left instead of the right side. Pads on the left and prints as . Prints the argument in a manner compatible with the function. Prints as empty list instead of . Pads on the left instead of the right side. Pads on the left and prints as . Prints the argument in accordance with the printer control variables. Prints in accordance with the currently set control variables. Prints a line break according to the pretty printer rules. Starts indenting from the first character. Dispatches the formatting operation to a user-defined function. The function must accept at least four parameters:\n• The stream or adjustable string to print to,\n• A Boolean value which is if the modifier was supplied, and\n• A Boolean value which is if the modifier was supplied. Additionally, zero or more arguments may be specified if the function shall also permit prefix parameters. Moves the output cursor to a given column or by a horizontal distance. Moves to the specified column. Moves the cursor relative to the current position. Moves to the argument at index . Prints an expression based upon a condition. These expressions, or clauses, are separated by the directive, and a default clause can be stated by using as its leading separator. The number of permitted clauses depends upon the concrete variety of this directive as stated by its modifier or modifiers. The whole conditional portion must be terminated with a . There exists an alternative form, valid only without modifiers, which relocates the index of the clause to select, selectionIndex, from the format arguments to a prefix parameter: This syntax commends itself especially in conjunction with the special prefix parameter character which equates the selected element with the number of format arguments left to process. A directive of this kind allows for a very concise modeling of multiple selections. The format argument must be a zero-based integer index, its value being that of the clause to select and print. Selects the first clause if the format argument is , otherwise the second one. Only processes the clause if the format argument is , otherwise skips it. Iterates over one or more format arguments and prints these. The iterative portion must be closed with a directive. If the directive is found inside of the enclosed portion, any content following it is only consumed if the current element is not the last one in the processed list. If the prefix parameter is specified, its value defines the maximum number of elements to process; otherwise all of these are consumed. A single format argument is expected to be a list, its elements are consumed in order by the enclosed directives. Expects the format argument to be a list of lists, consuming its sublists. Regards all remaining format arguments as a list and consumes these. Regards all remaining format arguments as a list of sublists, consuming these sublists. Substitutes the directive by the next argument, expected to be a format argument, using the subsequent format arguments in the new portion. Expects the subsequent format argument to be a list whose elements are associated with the inserted control string. Expects separate format arguments instead of a list of these for the inserted portion, as one would specify in the usual manner. Modifies the case of the enclosed string. Capitalizes the first word only, converts the rest to lower case. Prints a singular or plural suffix depending upon the numeric format argument. Prints nothing if the argument equals 1, otherwise prints plural suffix . Moves back to the last consumed format argument, printing nothing if it was 1, otherwise printing . Prints a suffix if the argument equals 1, otherwise prints suffix . Moves back to the last consumed format argument, printing suffix if it was 1, otherwise printing suffix . Used in an iteration directive to terminate processing of the enclosed content if no further format arguments follow. .\n• If no prefix parameter is specified, the directive ceases if zero arguments remain to process.\n• If one prefix parameter is specified, the directive ceases if resolves to zero.\n• If two prefix parameters and are specified, the directive ceases if equals .\n• If three prefix parameters , and are specified, the directive ceases if it holds: ≤ ≤ . Skips or retains line breaks and adjacent whitespaces in a multi-line control string. Skips the immediately following line break and adjacent whitespaces. Skips the immediately following line break, but retains adjacent whitespaces. Retains the immediately following line break, but skips adjacent whitespaces.\n\nAn example of a C call is the following:\n\nUsing Common Lisp, this is equivalent to:\n\nAnother example would be to print every element of list delimited with commas, which can be done using the ~{, ~^ and ~} directives:[4]\n\nNote that not only is the list of values iterated over directly by , but the commas correctly are printed between items, not after them. A yet more complex example would be printing out a list using customary English phrasing:\n\nThe ability to define a new directive through provides the means for customization. The next example implements a function which prints an input string either in lowercase, uppercase or reverse style, permitting a configuration of the number of repetitions, too.\n\n\"This function represents a callback suitable as a directive in a to print REPETITIONS number of times to the DESTINATION. expect a generalized Boolean each, being the representatives of the ``:'' and ``@'' modifiers respectively. Their influence is defined - If no modifier is set, the FORMAT-ARGUMENT is printed without - If the colon modifier is set, but not the at-sign modifier, the FORMAT-ARGUMENT is converted into lowercase before printing. - If the at-modifier is set, but not the colon-modifier, the FORMAT-ARGUMENT is converted into uppercase before printing. - If both modifiers are set, the FORMAT-ARGUMENT is reversed before The number of times the FORMAT-ARGUMENT string is to be printed is determined by the prefix parameter REPETITIONS, which must be a non-negative integer number and defaults to one.\" ;; Adjust the STRING-TO-PRINT based upon the modifiers. ;; Print a lowercase \"Hello\" (= \"hello\") three times. ;; Print an uppercase \"Hello\" (= \"HELLO\") three times.\n\nWhilst is somewhat infamous for its tendency to become opaque and hard to read, it provides a remarkably concise yet powerful syntax for a specialized and common need.[4]"
    },
    {
        "link": "https://clojure.github.io/clojure/branch-1.3.x/doc/clojure/pprint/CommonLispFormat.html",
        "document": "cl-format is an implementation of the incredibly baroque Common Lisp format function as specified in Common Lisp, the Language, 2nd edition, Chapter 22.\n\nFormat gives you an easy and powerful way to format text and data for output. It supports rich formatting of strings and numbers, loops, conditionals, embedded formats, etc. It is really a domain-specific language for formatting.\n\nThis implementation for clojure has the following goals:\n• Support the full feature set of the Common Lisp format function (including the X3J13 extensions) with the only exception being concepts that make no sense or are differently interpreted in Clojure.\n• Provide a more native feeling solution for Clojure programmers than the Java format method and its relatives.\n• Be fast. This includes the ability to precompile formats that are going to be used reptitively.\n\nWhy would I use cl-format?\n\nFor some people the answer to this question is that they are used to Common Lisp and, therefore, they already know the syntax of format strings and all the directives.\n\nA more interesting answer is that cl-format provides a way of rendering strings that is much more suited to Lisp and its data structures.\n\nBecause iteration and conditionals are built into the directive structure of cl-format, it is possible to render sequences and other complex data structures directly without having to loop over the data structure.\n\nFor example, to print the elements of a sequence separated by commas, you simply say:\n\nThe corresponding output using Clojure's Java-based format function would involve a nasty loop/recur with some code to figure out about the commas. Yuck!\n\ncl-format is 100% compatible with the Common Lisp standard as specified in CLtLv2. This includes all of the functionality of Common Lisp's format function including iteration, conditionals, text justification and rich options for displaying real and integer values. It also includes the directives to support pretty printing structured output.\n\nIf you find a bug in a directive, drop me a line with a chunk of code that exhibits the bug and the version of cl-format you found it in and I'll try to get it fixed.\n\nI also intend to have good built-in documentation for the directives, but I haven't built that yet.\n\nThe following directives are not yet supported: ~:T and ~@:T (but all other forms of ~T work) and extensions with ~/.\n\nThe pretty printer interface is similar, but not identical to the interface in Common Lisp.\n\nHow to use cl-format\n\nOnce cl-format is in your path, adding it to your code is easy:\n\nIf you want to refer to the cl-format function as \"format\" (rather than using the clojure function of that name), you can use this idiom:\n\nYou might want to do this in code that you've ported from Common Lisp, for instance, or maybe just because old habits die hard.\n\nFrom the REPL, you can grab it using (use):\n\ncl-format is a standard clojure function that takes a variable number of arguments. You call it like this:\n\nstream can be any Java Writer (that is java.io.Writer) or the values true, false, or nil. The argument true is identical to using out while false or nil indicate that cl-format should return its result as a string rather than writing it to a stream.\n\nformat is either a format string or a compiled format (see below). The format string controls the output that's written in a way that's similar to (but much more powerful than) the standard Clojure API format function (which is based on Java's java.lang.String.Format).\n\nFormat strings consist of characters that are to be written to the output stream plus directives (which are marked by ~) as in \"The answer is ~,2f\". Format strings are documented in detail in Common Lisp the Language, 2nd edition, Chapter 22.\n\nargs is a set of arguments whose use is defined by the format.\n\nWriters in Java have no real idea of current column or device page width, so the format directives that want to work relative to the current position on the page have nothing to work with. To deal with this, cl-format contains an extension to writer called pretty-writer. A pretty-writer watches the output and keeps track of what column the current output is going to.\n\nWhen you call format and your format includes a directive that cares about what column it's in (~T, ~&, ~<...~>), cl-format will automatically wrap the Writer you passed in with a pretty-writer. This means that by default all cl-format statements act like they begin on a fresh line and have a page width of 72.\n\nFor many applications, these assumptions are fine and you need to do nothing more. But sometimes you want to use multiple cl-format calls that output partial lines. You may also want to mix cl-format calls with the native clojure calls like print. If you want stay column-aware while doing this you need to create a pretty-writer of your own (and possibly bind it to out ).\n\nAs an example of this, this function takes a nested list and prints it as a table (returning the result as a string):\n\nThe get-pretty-writer function takes the Writer to wrap and (optionally) the page width (in columns) for use with ~<...~>.\n\nThe following function uses cl-format to dump a columnized table of the Java system properties:\n\nThere are some more examples in the pretty print examples gallery at http://github.com/tomfaulhaber/pprint-examples:\n• hexdump - a program that uses cl-format to create a standard formatted hexdump of the requested stream.\n• multiply - a function to show a formatted multipication table in a very \"first-order\" way.\n• props - the show-props example shown above.\n• show_doc - some utilities for showing documentation from various name spaces.\n\nThe floating point directives that show exponents (~E, ~G) show E for the exponent character in all cases (unless overridden with an exponentchar). Clojure does not distinguish between floats and doubles in its printed representation and neither does cl-format.\n\nThe ~A and ~S directives accept the colon prefix, but ignore it since () and nil are not equivalent in Clojure.\n\nClojure has 3 different reader syntaxes for characters. The ~@c directive to cl-format has an argument extension to let you choose:\n• ~@c (with no argument) prints \"\\c\" (backslash followed by the printed representation of the character or \n\newline, \\space, \\tab, \\backspace, \\return)\n• ~'o@c prints \"\\oDDD\" where DDD are the octal digits representing the character.\n• ~'u@c prints \"\\uXXXX\" prints the hex Unicode representation of the character."
    }
]