[
    {
        "link": "https://packaging.python.org/en/latest/guides/writing-pyproject-toml",
        "document": "is a configuration file used by packaging tools, as well as other tools such as linters, type checkers, etc. There are three possible TOML tables in this file.\n• None The table is strongly recommended. It allows you to declare which build backend you use and which other dependencies are needed to build your project.\n• None The table is the format that most build backends use to specify your project’s basic metadata, such as the dependencies, your name, etc.\n• None The table has tool-specific subtables, e.g., , , . We only touch upon this table here because its contents are defined by each tool. Consult the particular tool’s documentation to know what it can contain.\n\nThe table should always be present, regardless of which build backend you use ( defines the build tool you use). On the other hand, the table is understood by most build backends, but some build backends use a different format. A notable exception is Poetry, which before version 2.0 (released January 5, 2025) did not use the table, it used the table instead. With version 2.0, it supports both. Also, the setuptools build backend supports both the table, and the older format in or . For new projects, use the table, and keep only if some programmatic configuration is needed (such as building C extensions), but the and formats are still valid. See Is setup.py deprecated?.\n\nThe table contains a key, which specifies the build backend to be used. It also contains a key, which is a list of dependencies needed to build the project – this is typically just the build backend package, but it may also contain additional dependencies. You can also constrain the versions, e.g., . Usually, you’ll just copy what your build backend’s documentation suggests (after choosing your build backend). Here are the values for some common build backends:\n\nThe rest of this guide is devoted to the table. Most of the time, you will directly write the value of a field. For example: , or . However, in some cases, it is useful to let your build backend compute the metadata for you. For example: many build backends can read the version from a attribute in your code, a Git tag, or similar. In such cases, you should mark the field as dynamic using, e.g., When a field is dynamic, it is the build backend’s responsibility to fill it. Consult your build backend’s documentation to learn how it does it.\n\nPut the name of your project on PyPI. This field is required and is the only field that cannot be marked as dynamic. The project name must consist of ASCII letters, digits, underscores “ ”, hyphens “ ” and periods “ ”. It must not start or end with an underscore, hyphen or period. Comparison of project names is case insensitive and treats arbitrarily long runs of underscores, hyphens, and/or periods as equal. For example, if you register a project named , users will be able to download it or declare a dependency on it using any of the following spellings: , , , . Put the version of your project. Some more complicated version specifiers like (for an alpha release) are possible; see the specification for full details. This field is required, although it is often marked as dynamic using This allows use cases such as filling the version from a attribute or a Git tag. Consult the Single-sourcing the Project Version discussion for more details.\n\nTo install a command as part of your package, declare it in the table. In this example, after installing your project, a command will be available. Executing this command will do the equivalent of . On Windows, scripts packaged this way need a terminal, so if you launch them from within a graphical application, they will make a terminal pop up. To prevent this from happening, use the table instead of . In that case, launching your script from the command line will give back control immediately, leaving the script to run in the background. The difference between and is only relevant on Windows.\n\nBoth of these fields contain lists of people identified by a name and/or an email address. This should be a one-line description of your project, to show as the “headline” of your project page on PyPI (example), and other places such as lists of search results (example). This is a longer description of your project, to display on your project page on PyPI. Typically, your project will have a or file and you just put its file name here. The README’s format is auto-detected from the extension: You can also specify the format explicitly, like this: PEP 639 (accepted in August 2024) has changed the way the field is declared. Make sure your preferred build backend supports PEP 639 before trying to apply the newer guidelines. As of February 2025, setuptools and flit don’t support PEP 639 yet. This is a valid SPDX license expression consisting of one or more license identifiers. The full license list is available at the SPDX license list page. The supported list version is 3.17 or any later compatible one. As a general rule, it is a good idea to use a standard, well-known license, both to avoid confusion and because some organizations avoid software whose license is unapproved. If your project is licensed with a license that doesn’t have an existing SPDX identifier, you can create a custom one in format . The custom identifiers must follow the SPDX specification, clause 10.1 of the version 2.2 or any later compatible one. This can take two forms. You can put your license in a file, typically or , and link that file here: or you can write the name of the license: If you are using a standard, well-known license, it is not necessary to use this field. Instead, you should use one of the classifiers starting with . (As a general rule, it is a good idea to use a standard, well-known license, both to avoid confusion and because some organizations avoid software whose license is unapproved.) PEP 639 (accepted in August 2024) has introduced the field. Make sure your preferred build backend supports PEP 639 before declaring the field. As of February 2025, setuptools and flit don’t support PEP 639 yet. This is a list of license files and files containing other legal information you want to distribute with your package. The glob patterns must follow the specification:\n• None Alphanumeric characters, underscores ( ), hyphens ( ) and dots ( ) will be matched verbatim.\n• None Path delimiters must be the forward slash character ( ).\n• None Patterns are relative to the directory containing , and thus may not start with a slash character.\n• None Parent directory indicators ( ) must not be used.\n• None Each glob must match at least one file. Literal paths are valid globs. Any characters or character sequences not covered by this specification are invalid. This will help PyPI’s search box to suggest your project when people search for these keywords. A list of PyPI classifiers that apply to your project. Check the full list of possibilities. # How mature is this project? Common values are # Indicate who your project is intended for # Specify the Python versions you support here. Although the list of classifiers is often used to declare what Python versions a project supports, this information is only used for searching and browsing projects on PyPI, not for installing projects. To actually restrict what Python versions a project can be installed on, use the requires-python argument. To prevent a package from being uploaded to PyPI, use the special classifier. PyPI will always reject packages with classifiers beginning with . A list of URLs associated with your project, displayed on the left sidebar of your PyPI project page. See Well-known labels for a listing of labels that PyPI and other packaging tools are specifically aware of, and PyPI’s project metadata docs for PyPI-specific URL processing. Note that if the label contains spaces, it needs to be quoted, e.g., but . Users are advised to use Well-known labels for their project URLs where appropriate, since consumers of metadata (like package indices) can specialize their presentation. For example in the following metadata, neither nor is a well-known label, so they will be rendered verbatim: Whereas in this metadata and both have well-known equivalents ( and ), and can be presented with those semantics in mind (the project’s home page and its external download location, respectively)."
    },
    {
        "link": "https://pandas.pydata.org/docs/getting_started/install.html",
        "document": "The easiest way to install pandas is to install it as part of the Anaconda distribution, a cross platform distribution for data analysis and scientific computing. The Conda package manager is the recommended installation method for most users.\n\nInstructions for installing from source, PyPI, or a development version are also provided.\n\nFor users that are new to Python, the easiest way to install Python, pandas, and the packages that make up the PyData stack (SciPy, NumPy, Matplotlib, and more) is with Anaconda, a cross-platform (Linux, macOS, Windows) Python distribution for data analytics and scientific computing. Installation instructions for Anaconda can be found here. For users experienced with Python, the recommended way to install pandas with Miniconda. Miniconda allows you to create a minimal, self-contained Python installation compared to Anaconda and use the Conda package manager to install additional packages and create a virtual environment for your installation. Installation instructions for Miniconda can be found here. The next step is to create a new conda environment. A conda environment is like a virtualenv that allows you to specify a specific version of Python and set of libraries. Run the following commands from a terminal window. This will create a minimal environment with only Python and pandas installed. To put your self inside this environment run. pandas can be installed via pip from PyPI. You must have to install from PyPI. It is recommended to install and run pandas from a virtual environment, for example, using the Python standard library’s venv pandas can also be installed with sets of optional dependencies to enable certain functionality. For example, to install pandas with the optional dependencies to read Excel files. The full list of extras that can be installed can be found in the dependency section. If you encounter an , it usually means that Python couldn’t find pandas in the list of available libraries. Python internally has a list of directories it searches through, to find packages. You can obtain these directories with. One way you could be encountering this error is if you have multiple Python installations on your system and you don’t have pandas installed in the Python installation you’re currently using. In Linux/Mac you can run on your terminal and it will tell you which Python installation you’re using. If it’s something like “/usr/bin/python”, you’re using the Python from the system, which is not recommended. It is highly recommended to use , for quick installation and for package and dependency updates. You can find simple installation instructions for pandas in this document. See the contributing guide for complete instructions on building from the git source tree. Further, see creating a development environment if you wish to create a pandas development environment. Installing the development version is the quickest way to:\n• None Try a new feature that will be shipped in the next release (that is, a feature from a pull-request that was recently merged to the main branch).\n• None Check whether a bug you encountered has been fixed since the last release. The development version is usually uploaded daily to the scientific-python-nightly-wheels index from the PyPI registry of anaconda.org. You can install it by running. Note that you might be required to uninstall an existing version of pandas to install the development version.\n\npandas has many optional dependencies that are only used for specific methods. For example, requires the package, while requires the package. If the optional dependency is not installed, pandas will raise an when the method requiring that dependency is called. If using pip, optional pandas dependencies can be installed or managed in a file (e.g. requirements.txt or pyproject.toml) as optional extras (e.g. ). All optional dependencies can be installed with , and specific sets of dependencies are listed in the sections below. You are highly encouraged to install these libraries, as they provide speed improvements, especially when working with large data sets. Accelerates certain numerical operations by using multiple cores as well as smart chunking and caching to achieve large speedups Accelerates certain types of by using specialized cython routines to achieve large speedup. Alternative execution engine for operations that accept using a JIT compiler that translates Python functions to optimized machine code using the LLVM compiler. One of the following combinations of libraries is needed to use the top-level function:\n• None Only lxml, although see HTML Table Parsing for reasons as to why you should probably not take this approach.\n• None if you install BeautifulSoup4 you must install either lxml or html5lib or both. will not work with only BeautifulSoup4 installed.\n• None You are highly encouraged to read HTML Table Parsing gotchas. It explains issues surrounding the installation and usage of the above three libraries. XML parser for read_xml and tree builder for to_xml SQL support for databases other than sqlite Compression for HDF5; only available on\n• None If you want to use , it is highly recommended to install pyarrow using conda. may fail if pyarrow was installed from pypi, and is not compatible with Windows OS. Handling files aside from simple local and HTTP (required dependency of s3fs, gcsfs). Depending on operating system, system-level packages may need to installed. For clipboard to operate on Linux one of the CLI tools or must be installed on your system."
    },
    {
        "link": "https://pip.pypa.io/en/stable/reference/build-system/pyproject-toml",
        "document": "Modern Python packages can contain a file, first introduced in PEP 518 and later expanded in PEP 517, PEP 621 and PEP 660. This file contains build system requirements and information, which are used by pip to build the package.\n\nThe overall process for building a package is:\n• None Generate the package’s metadata, if necessary and possible.\n\nThe wheel can then be used to perform an installation, if necessary.\n\nFor building packages using this interface, pip uses an isolated environment. That is, pip will install build-time Python dependencies in a temporary directory which will be added to for the build commands. This ensures that build requirements are handled independently of the user’s runtime environment. For example, a project that needs an older version of setuptools to build can still be installed, even if the user has a newer version installed (and without silently replacing that version).\n\nIntroduced in PEP 518, the key in the file is a list of requirement specifiers for build-time dependencies of a package. It is also possible for a build backend to provide dynamically calculated build dependencies, using PEP 517’s hook. This hook will be called by pip, and dependencies it describes will also be installed in the build environment. For example, newer versions of setuptools expose the contents of to pip via this hook. Build-time requirement specifiers follow PEP 508, so it’s possible to reference packages with URLs. For example:\n\nOnce the build environment has been created and populated with build-time dependencies, will usually need metadata about a package (name, version, dependencies, and more). If PEP 517’s hook is provided by the build backend, that will be used to generate the packages’ metadata. Otherwise, a wheel will be generated (as described below) and the metadata contained within such a wheel will be used.\n\nFor generating a wheel, pip uses the PEP 517 hook that has to be provided by the build backend. The build backend will generate a wheel, which may involve compiling extension code written in C/C++ (or other languages). Wheels generated using this mechanism can be cached for reuse, to speed up future installations.\n\nFor performing editable installs, pip will use PEP 660 hook that has to be provided by the build backend. The wheels generated using this mechanism are not cached. If this hook is missing on the build backend and there’s a file in the project, pip will fallback to the legacy setup.py-based editable installation. This is considered a stopgap solution until setuptools adds support for PEP 660, at which point this functionality will be removed; following pip’s regular deprecation policy.\n\nBuild backends have the ability to accept configuration settings, which can change the way the build is handled. These settings take the form of a series of pairs. The user can supply configuration settings using the command line option (which can be supplied multiple times, in order to specify multiple settings). The supplied configuration settings are passed to every backend hook call. Configuration settings provided via command line options (or the equivalent environment variables or configuration file entries) are passed to the build of requirements explicitly provided as pip command line arguments. They are not passed to the build of dependencies, or to the build of requirements provided in requirement files."
    },
    {
        "link": "https://python-poetry.org/docs/pyproject",
        "document": "In package mode, the only required fields are and (either in the section or in the section). Other fields are optional. In non-package mode, the and fields are required if using the section.\n\nThe section of the file according to the specification of the PyPA.\n\nThe name of the package. Always required when the section is specified\n\nThis should be a valid name as defined by PEP 508.\n\nThe version of the package. Always required when the section is specified\n\nThis should be a valid PEP 440 string.\n\nIf you want to set the version dynamically via or you are using a plugin, which sets the version dynamically, you should add to dynamic and define the base version in the section, for example:\n\nThe license of the package.\n\nThe recommended notation for the most common licenses is (alphabetical):\n\nOptional, but it is highly recommended to supply this. More identifiers are listed at the SPDX Open Source License Registry.\n\nYou can also specify a license file. However, when doing this the complete license text will be added to the metadata and the License classifier cannot be determined automatically so that you have to add it manually.\n\nA path to the README file or the content.\n\nThe Python version requirements of the project.\n\nThe authors of the package.\n\nThis is a list of authors and should contain at least one author.\n\nThe maintainers of the package.\n\nThis is a list of maintainers and should be distinct from authors.\n\nA list of keywords that the package is related to.\n\nA list of PyPI trove classifiers that describe the project.\n\nThe URLs of the project.\n\nIf you publish your package on PyPI, they will appear in the section.\n\nThis section describes the console scripts that will be installed when installing the package.\n\nHere, we will have the script installed which will execute the function in the module in the package.\n\nThis section describes the GUI scripts that will be installed when installing the package.\n\nHere, we will have the script installed which will execute the function in the module in the package.\n\nEntry points can be used to define plugins for your package.\n\nPoetry supports arbitrary plugins, which are exposed as the ecosystem-standard entry points and discoverable using . This is similar to (and compatible with) the entry points feature of . The syntax for registering a plugin is:\n• - type of the plugin, for example or\n• - name of the plugin\n• - the entry point of the plugin (a function or class)\n\nThe of the project.\n\nThese are the dependencies that will be declared when building an sdist or a wheel.\n\nSee Dependency specification for more information about the relation between and .\n\nThe optional dependencies of the project (also known as extras).\n\nThe section of the file is composed of multiple sections.\n\nWhether Poetry operates in package mode (default) or not.\n\nSee basic usage for more information.\n\nThe name of the package. Required in package mode if not defined in the project section\n\nThis should be a valid name as defined by PEP 508.\n\nThe version of the package. Required in package mode if not defined in the project section\n\nThis should be a valid PEP 440 string.\n\nThe license of the package.\n\nThe recommended notation for the most common licenses is (alphabetical):\n\nOptional, but it is highly recommended to supply this. More identifiers are listed at the SPDX Open Source License Registry.\n\nThe authors of the package.\n\nThis is a list of authors and should contain at least one author. Authors must be in the form .\n\nThe maintainers of the package.\n\nThis is a list of maintainers and should be distinct from authors. Maintainers may contain an email and be in the form .\n\nA path, or list of paths corresponding to the README file(s) of the package.\n\nThe file(s) can be of any format, but if you intend to publish to PyPI keep the recommendations for a PyPI-friendly README in mind. README paths are implicitly relative to .\n\nThe contents of the README file(s) are used to populate the Description field of your distribution’s metadata (similar to in setuptools). When multiple files are specified they are concatenated with newlines.\n\nAn URL to the website of the project.\n\nAn URL to the repository of the project.\n\nAn URL to the documentation of the project.\n\nA list of keywords that the package is related to.\n\nA list of PyPI trove classifiers that describe the project.\n\nA list of packages and modules to include in the final distribution.\n\nIf your project structure differs from the standard one supported by , you can specify the packages you want to include in the final distribution.\n\nIf your package is stored inside a “lib” directory, you must specify it:\n\nThe parameter is designed to specify the relative destination path where the package will be located upon installation. This allows for greater control over the organization of packages within your project’s structure.\n\nIf you want to restrict a package to a specific build format you can specify it by using :\n\nFrom now on, only the build archive will include the package.\n\nA list of patterns that will be excluded or included in the final package.\n\nYou can explicitly specify to Poetry that a set of globs should be ignored or included for the purposes of packaging. The globs specified in the exclude field identify a set of files that are not included when a package is built. has priority over .\n\nIf a VCS is being used for a package, the exclude field will be seeded with the VCS’ ignore settings ( for git for example).\n\nYou can also specify the formats for which these patterns have to be included, as shown here:\n\nIf no format is specified, defaults to only .\n\nIn contrast, defaults to both and .\n\nPoetry is configured to look for dependencies on PyPI by default. Only the name and a version string are required in this case.\n\nIf you want to use a private repository, you can add it to your file, like so:\n\nIf you have multiple repositories configured, you can explicitly tell poetry where to look for a specific package:\n\nYou may also specify your project’s compatible python versions in this section, instead of or in addition to .\n\nYou can organize your dependencies in groups to manage them in a more granular way.\n\nSee Dependency groups for a more in-depth look at how to manage dependency groups and Dependency specification for more information on other keys and specifying version ranges.\n\nThis section describes the scripts or executables that will be installed when installing the package\n\nHere, we will have the script installed which will execute the function in the module in the package.\n\nThis tells Poetry to include the specified file, relative to your project directory, in distribution builds. It will then be copied to the appropriate installation directory for your operating system when your package is installed.\n• On Windows the file is placed in the directory.\n• On *nix system the file is placed in the directory.\n\nIn its table form, the value of each script can contain a and . The supported types are and . When the value is a string, it is inferred to be a script.\n\nPoetry supports extras to allow expression of:\n• optional dependencies, which enhance a package, but are not required; and\n\nWhen installing packages with Poetry, you can specify extras by using the option:\n\nAny extras you don’t specify will be removed. Note this behavior is different from optional dependency groups not selected for install, e.g. those not specified via .\n\nYou can install all extras with the option:\n\nWhen installing or specifying Poetry-built packages, the extras defined in this section can be activated as described in PEP 508.\n\nFor example, when installing the package using , the dependencies required by the extra can be installed as shown below.\n\nPoetry supports arbitrary plugins, which are exposed as the ecosystem-standard entry points and discoverable using . This is similar to (and compatible with) the entry points feature of . The syntax for registering a plugin is:\n• - type of the plugin, for example or\n• - name of the plugin\n• - the entry point of the plugin (a function or class)\n\nIn addition to the basic urls ( , and ), you can specify any custom url in the section.\n\nIf you publish your package on PyPI, they will appear in the section.\n\nA constraint for the Poetry version that is required for this project. If you are using a Poetry version that is not allowed by this constraint, an error will be raised.\n\nIn this section, you can specify that certain plugins are required for your project:\n\nSee Project plugins for more information.\n\nPEP-517 introduces a standard way to define alternative build systems to build a Python project.\n\nPoetry is compliant with PEP-517, by providing a lightweight core library, so if you use Poetry to manage your Python project you should reference it in the section of the file like so:"
    },
    {
        "link": "https://stackoverflow.com/questions/74508024/is-requirements-txt-still-needed-when-using-pyproject-toml",
        "document": "Since mid 2022 it is now possible to get rid of , in favor of . Editable installs work with recent versions of setuptools and pip and even the official packaging tutorial switched away from to .\n\nHowever, documentation regarding seems to be have been also removed, and I wonder where to put the pinned requirements now?\n\nAs a refresher: It used to be common practice to put the dependencies (without version pinning) in avoiding issues when this package gets installed with other packages needing the same dependencies but with conflicting version requirements. For packaging libraries a was usually sufficient.\n\nFor deployments (i.e. non libraries) you usually also provided a with version-pinned dependencies. So you don't accidentally get the latest and greatest but the exact versions of dependencies that that package has been tested with.\n\nSo my question is, did anything change? Do you still put the pinned requirements in the when used together with ? Or is there an extra section for that in ? Is there some documentation on that somewhere?"
    },
    {
        "link": "https://stackoverflow.com/questions/70242603/pip-install-upgrade-pip-and-pip-install-upgrade-setuptools-both-failed-with",
        "document": "i encountered errors with trying to upgrade pip, and its setup tools. Appended below are the errors.\n\nSo i have tried the many suggestions listd in this thread over at https://github.com/facebook/prophet/issues/418 but to no avail.\n\nDoes anyone know of a solution ? Thanks in advance !"
    },
    {
        "link": "https://stackoverflow.com/questions/35894511/upgrade-pip-error-message",
        "document": "Previously I had been struggling to install and run a couple of python modules so I remember moving files around a bit. Is that what has caused this error? How can I fix this? I am on Mac.\n\nI was trying to install bs4 prior to this and I got similar error messages. (But i suspect the bs4 install has more issues so that's another question for later).\n\nAlso sorry for any format issues with the code. Have tried my best to make it look like it is on the terminal."
    },
    {
        "link": "https://github.com/pypa/pip/issues/11978",
        "document": "Various github actions that we set up in the past now break if they upgrade to 23.1 It starts when we upgrade pip and setuptools. This is what we have in our ci.yml file:\n\nwhich used to produce:\n\nSo things are already weird here: why did pip drop from 23.0.1 to 22.0.4?\n\nThen things actually fail later when using pip to install anything else: we get the error \"/opt/hostedtoolcache/Python/3.9.16/x64/bin/python: No module named pip\":\n\nhere, and it told me the version was 23.1. If I ask it to upgrade pip, it does so!\n\nSo pip --version thinks it's 23.1, but if you ask it to upgrade, it'll upgrade! However, this doesn't help; subsequent 'install' commands still fail the same way, complaining that the module 'pip' doesn't exist.\n\nThe first time I saw the new behavior today:\n\n https://github.com/biosimulators/Biosimulators_tellurium/actions/runs/4722113676/jobs/8376265185\n\nA version that succeeds because I don't try to upgrade pip:\n\n https://github.com/biosimulators/Biosimulators_tellurium/actions/runs/4725975440/jobs/8385029359\n• I agree to follow the PSF Code of Conduct."
    },
    {
        "link": "https://activestate.com/resources/quick-reads/how-to-package-python-dependencies-with-pip-setuptools",
        "document": "If you’re packaging a Python package for publication, how do you ensure that all of the required dependencies are included? Just like pip is the standard package manager for Python, setup.py is the heart and center of Python projects installed with pip. Simply put, setup.py is a build script template distributed with Python’s setuptools package.\n\nSetuptools is the Python Packaging Authority (PyPA) package development process library and utility for building Python projects based on packages and their dependencies listed in a setup.py script. A Python file that relies only on the standard library can be redistributed and reused without the need to use setuptools. But for projects that consist of multiple files, need additional libraries, or need a specific version of Python, setuptools will be required.\n\nThis article provides a brief tutorial on how to work with setuptools.\n\nSetuptools is typically installed with Python downloaded from python.org, so there’s no need to separately install setuptools. Instead, your first step should be to use pip to update your Python installation to the latest version of setuptools on popular operating systems like Windows, Linux or macOS:\n\nIf you get a permissions error, instead of using sudo, consider creating a virtual environment with virtualenv, venv, pipenv or pyenv. If you’re working with more than one project, rather than installing everything in /site-packages, you’ll want to work with virtual environments to ensure each project has just the dependencies it requires.\n\nThe following script is an example of how to create a setup.py script for your Python 3 (not Python 2) project. The script syntax spells out the information you need to provide, including metadata such as:\n• Project name – enter a name for your project in quotes\n• Python packages and Python modules to include in the distribution (dist) – the find_packages(‘,’) default argument will incorporate all packages that include an __init__.py file and are located in the local directory (dir) where setup.py is installed\n• Project version number – enter a version number for the project in quotes\n• List a license for the project – enter the name of the license you are licensing your project for use under in quotes\n• Short description of your library (lib) – enter a brief description of your project in quotes\n• Long description of your library (lib) – enter a more detailed description of your project either in text or using markdown\n• Your name – enter your name in quotes to denote who the author is\n• Your email address – optionally provide an email address in quotes where users can contact you\n• Link to your GitHub repository or website – optionally provide a link to your project’s repo, list your maintainers, etc\n• Download Link from where the project can be downloaded from – provide an URL to your project’s source code in quotes\n• List of keywords – provide a list of keywords in square brackets associated with your project to make it easier to search for\n• List project dependencies – provide a list of all the dependencies your project requires in square brackets. The easiest way to provide this is to copy and paste from the install_requires section (see below).\n• https://pypi.org/classifiers – provide a list of all classifiers that apply to your project in square brackets. You can find a comprehensive list of classifiers at https://pypi.org/classifiers\n\ninstall_requires is a section within the setup.py file in which you need to input a list of the minimum dependencies needed for a project to run correctly on the target operating system (such as ubuntu). When pip runs setup.py, it will install all of the dependencies listed in install_requires.\n\nFor example, if your project includes matplotlib, you’ll need to list it, as well as its dependency of NumPy in install_requires as shown below:\n\nExample of Install_requires with Platform Specific Dependencies\n\nYou can modify install_requires by adding in platform-specific and version-specific dependencies, depending on the environment that a project is to be installed on. For instance, if our previous example included matplotlib v3.2.1 and numpy v1.17.4 on Python 3.6.6 for Linux, we could specify:\n\nWhen the command is run, all of the dependencies not already installed will be downloaded, built (if necessary), and installed. Any scripts that require specific dependencies at runtime will be installed with wrappers that ensure the correct versions are added to sys.path (system path).\n\nIf your project has a dependency requirement that is not currently in the Python Package Index (PyPI), you can still include them if they can be accessed via http and are packaged as either an egg, .py file, or a VCS (Version Control System) repository, such as Git or Subversion, rather than just a tarball (tar.gz).\n\nIn order to download dependencies not found in PyPI, you will need to add URLs to a dependency_links section under setup() in the setup.py file. Assuming that the dependencies are packaged correctly, they will be automatically installed:\n\nTo check a dependency not found in PyPI, prefix the package name and version # with _ (instead of -) in the dependency_links argument:\n\nDependency resolution is at the core of the ActiveState Platform. When you create a project and start adding requirements, the Platforms tell you what dependencies those requirements have.\n\nThe ActiveState Platform is a cloud-based build tool for Python. It provides build automation and vulnerability remediation for:\n• Linked C and Fortran libraries, so you can build data science packages\n• Find, fix and automatically rebuild a secure version of Python packages like Django and environments in minutes\n\nThe ActiveState Platform aims to handle every dependency for every language. That means handling libraries down to the C/C++ level, external tools, and all the conditional dependencies that exist. To take things even further, our ultimate goal is to support multi-language projects. That means that you can create a project using both Python and Perl packages, and we’ll make sure that both languages are using the same (up to date) OpenSSL version.\n\nGet a hands-on appreciation for how the ActiveState Platform can help you manage your dependencies for Python environments. Just run the following command to install Python 3.9 and our package manager, the State Tool:\n\nNow you can run state install <packagename>. Learn more about how to use the State Tool to manage your Python environment.\n\nLet us know your experience in the ActiveState Community forum.\n\nWatch this video to learn how to use the ActiveState Platform to create a Python 3.9 environment, and then use the Platform’s CLI (State Tool) to install and manage it."
    },
    {
        "link": "https://reddit.com/r/chromeos/comments/1ftnzzn/sudo_python3_m_pip_install_upgrade_pip_setuptools",
        "document": "I'm trying to install pip so I can install packages for python.\n\nI tried using lots of different things online and they all say something like:\n\npython3-xyz, where xyz is the package you are trying to\n\nIf you wish to install a non-Debian-packaged Python package,\n\nThen use path/to/venv/bin/python and path/to/venv/bin/pip. Make\n\nsure you have python3-full installed.\n\nIf you wish to install a non-Debian packaged Python application,\n\nit may be easiest to use pipx install xyz, which will manage a\n\nvirtual environment for you. Make sure you have pipx installed.\n\nSee /usr/share/doc/python3.11/README.venv for more information.\n\nnote: If you believe this is a mistake, please contact your Python installation or OS distribution provider. You can override this, at the risk of breaking your Python installation or OS, by passing --break-system-packages.\n\nhint: See PEP 668 for the detailed specification.\n\nMY DEVICE IS NOT A SCHOOL CHROMEBOOK!!!!! I have used it for school in the past (it has been powerwashed since then), and I have a school account added, but not to sign in, just for email. Please help!!!!"
    }
]