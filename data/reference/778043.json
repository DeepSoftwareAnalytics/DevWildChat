[
    {
        "link": "https://css-tricks.com/a-complete-guide-to-css-media-queries",
        "document": "CSS Media queries are a way to target browser by certain characteristics, features, and user preferences, then apply styles or run other code based on those things. Perhaps the most common media queries in the world are those that target particular viewport ranges and apply custom styles, which birthed the whole idea of responsive design.\n\nThere are lots of other things we can target beside viewport width. That might be screen resolution, device orientation, operating system preference, or even more among a whole bevy of things we can query and use to style content.\n\nLooking for a quick list of media queries based on the viewports of standard devices, like phones, tablets and laptops? Check out our collection of snippets.\n\nMedia queries are commonly associated with CSS, but they can be used in HTML and JavaScript as well.\n\nThere are a few ways we can use media queries directly in HTML. There’s the element that goes right in the document . In this example. we’re telling the browser that we want to use different stylesheets at different viewport sizes: <html> <head> <!-- Served to all users --> <link rel=\"stylesheet\" href=\"all.css\" media=\"all\" /> <!-- Served to screens that are at least 20em wide --> <link rel=\"stylesheet\" href=\"small.css\" media=\"(min-width: 20em)\" /> <!-- Served to screens that are at least 64em wide --> <link rel=\"stylesheet\" href=\"medium.css\" media=\"(min-width: 64em)\" /> <!-- Served to screens that are at least 90em wide --> <link rel=\"stylesheet\" href=\"large.css\" media=\"(min-width: 90em)\" /> <!-- Served to screens that are at least 120em wide --> <link rel=\"stylesheet\" href=\"extra-large.css\" media=\"(min-width: 120em)\" /> <!-- Served to print media, like printers --> <link rel=\"stylesheet\" href=\"print.css\" media=\"print\" /> </head> <!-- ... --> </html> Why would you want to do that? It can be a nice way to fine-tune the performance of your site by splitting styles up in a way that they’re downloaded and served by the devices that need them. But just to be clear, this doesn’t always prevent the stylesheets that don’t match those media queries from downloading, it just assigns them a low loading priority level. So, if a small screen device like a phone visits the site, it will only download the stylesheets in the media queries that match its viewport size. But if a larger desktop screen comes along, it will download the entire bunch because it matches all of those queries (well, minus the print query in this specific example). That’s just the element. As our guide to responsive images explains, we can use media queries on element, which informs the element what version of an image the browser should use from a set of image options. <picture> <!-- Use this image if the screen is at least 800px wide --> <source srcset=\"cat-landscape.png\" media=\"(min-width: 800px)\"> <!-- Use this image if the screen is at least 600px wide --> <source srcset=\"cat-cropped.png\" media=\"(min-width: 600px)\"> <!-- Use this image if nothing matches --> <img src=\"cat.png\" alt=\"A calico cat with dark aviator sunglasses.\"> </picture> Again, this can be a nice performance win because we can serve smaller images to smaller devices — which presumably (but not always) will be low powered devices that might be limited to a data plan. And let’s not forget that we can use media queries directly on the element as well:\n\nNow that we’ve seen several examples of where media queries can be used, let’s pick them apart and see what they’re actually doing.\n\nThe first ingredient in a media query recipe is the rule itself, which is one of many CSS at-rules. Why does get all the attention? Because it’s geared to the type of media that a site is viewed with, what features that media type supports, and operators that can be combined to mix and match simple and complex conditions alike. What type of media are we trying to target? In many (if not most) cases, you’ll see a value used here, which makes sense since many of the media types we’re trying to match are devices with screens attached to them. But screens aren’t the only type of media we can target, of course. We have a few, including:\n• : Matches documents that are viewed in a print preview or any media that breaks the content up into pages intended to print.\n• : Matches devices that read the content audibly, such as a screenreader. This replaces the now deprecated type since Media Queries Level 4. To preview print styles in a screen all major browsers can emulate the output of a print stylesheet using DevTools. Other media types such as , , , , , and have been deprecated and, while the spec continues to advise browsers to recognize them, they must evaluate to nothing. If you are using one of these consider changing it for a modern approach. Once we define the type of media we’re trying to match, we can start defining what features we are trying to match it to. We’ve looked at a lot of examples that match screens to width, where is the type and both and are features with specific values. But there are many, many (many!) more “features” we can match. Media Queries Level 5 groups media features into 6 categories. Defines the widths of the viewport. This can be a specific number (e.g. ) or a range (using and ). Defines the height of the viewport. This can be a specific number (e.g. ) or a range (using and ). Defines the width-to-height aspect ratio of the viewport The way the screen is oriented, such as tall ( ) or wide ( ) based on how the device is rotated. Checks how the device treats content that overflows the viewport in the block direction, which can be (allows scrolling), (allows scrolling and manual page breaks), (broken up into pages), and (not displayed). Checks if content that overflows the viewport along the inline axis be scrolled, which is either (no scrolling) or (allows scrolling). Defines the target pixel density of the device Defines the scanning process of the device, which is the way the device paints an image onto the screen (where draws odd and even lines alternately, and draws them all in sequence). Determines if the device uses a grid ( ) or bitmap ( ) screen Checks how frequently the device can modify the appearance of content (if it can at all), with values including , and . A method for determining the external environment of a device, such as dim or excessively bright places. Tests the display mode of a device, including (no browsers chrome), (a standalone application), (a standalone application, but with some navigation), and (a more traditional browser window) Defines the color support of a device, expressed numerically as bits. So, a value of would be the equivalent of a device that supports 12-bit color, and a value of zero indicates no color support. Defines the number of values the device supports. This can be a specific number (e.g. ) or a range (e.g. , ), just like . The number of bits per pixel that a device’s monochrome supports, where zero is no monochrome support. Defines the range of colors supported by the browser and device, which could be , or The combination of how much brightness, color depth, and contrast ratio supported by the video plane of the browser and user device. Checks if the browser or operating system is set to invert colors (which can be useful for optimizing accessibility for sight impairments involving color) Sort of like but checks if the primary input mechanism is a pointer and, if so, how accurate it is (where is less accurate, is more accurate, and is no pointer). Sort of like but checks if the primary input mechanism (e.g. mouse of touch) allows the user to hover over elements Checks if the device uses a pointer, such as a mouse or styles, as well as how accurate it is (where is less accurate and is more accurate) Checks if the device is capable of hovering elements, like with a mouse or stylus. In some rare cases, touch devices are capable of hovers. The spec references user agents, including TVs, that render video and graphics in two separate planes that each have their own characteristics. The following features describe those planes. Describes the approximate range of colors supported by the video plane of the browser and user device The combination of how much brightness, color depth, and contrast ratio supported by the video plane of the browser and user device. The width of the video plane area of the targeted display The height of the video plane area of the targeted display The resolution of the video plane area of the targeted display Checks whether the device allows scripting (i.e. JavaScript) where allows scripting, Detects if the user’s system settings are set to reduce motion on the page, which is a great accessibility check. Detects if the user’s system settings prevent transparent across elements. Detects if the user’s system settings are set to either increase or decrease the amount of contrast between colors. Detects if the user prefers a light or dark color scheme, which is a rapidly growing way to go about creating “dark mode” interfaces. Tests whether the browser restricts the colors available to use (which is or ) Detects if the user prefers to use less data for the page to be rendered. The width-to-height aspect ratio of the output device The height of the device’s surface that displays rendered elements The width of the device’s surface that displays rendered elements Media queries support logical operators like many programming languages so that we can match media types based on certain conditions. The rule is itself a logical operator that is basically stating that “if” the following types and features are matches, then do some stuff. But we can use the operator if we want to target screens within a range of widths: /* Matches screen between 320px AND 768px */ @media screen (min-width: 320px) and (max-width: 768px) { .element { /* Styles! */ } } We can also comma-separate features as a way of using an operator to match different ones: /* Matches screens where either the user prefers dark mode or the screen is at least 1200px wide */ @media screen (prefers-color-scheme: dark), (min-width 1200px) { .element { /* Styles! */ } } Perhaps we want to target devices by what they do not support or match. This declaration removes the body’s background color when the device is a printer and can only show one color.\n\nWant to go deeper? Check out “CSS Media Queries: Quick Reference & Guide” from the DigitalOcean community for more examples that follow the syntax for media quieries.\n\nDo you really need CSS media queries?\n\nMedia queries are a powerful tool in your CSS toolbox with exciting hidden gems. But if you accomodate your design to every possible situation you’ll end up with a codebase that’s too complex to maintain and, as we all know, CSS is like a bear cub: cute and inoffensive but when it grows it will eat you alive.\n\nThat’s why I recommend following Ranald Mace’s concept of Universal Design which is “the design of products to be usable by all people, to the greatest extent possible, without the need for adaptation or specialized design.”\n\nIn “Accessibility for Everyone” Laura Kalbag explains that the difference between accessible and universal design is subtle but important. An accessible designer would create a large door for people on a wheel chair to enter, while a universal designer would produce an entry that anyone would fit disregarding of their abilities.\n\nI know that talking about universal design on the web is hard and almost sound utopian, but think about it, there are around 150 different browsers, around 50 different combinations of user preferences, and as we mentioned before more than 24000 different and unique Android devices alone.\n\nThis means that there are at least 18 million possible cases in which your content might be displayed. In the words of the fantastic Miriam Suzanne, “CSS out here trying to do graphic design of unknown content on an infinite and unknown canvas, across operating systems, interfaces, & languages. There’s no possible way for any of us to know what we’re doing.”\n\nThat’s why assuming is really dangerous, so when you design, develop and think about your products leave assumptions behind and use media queries to make sure that your content is displayed correctly in any contact and before any user.\n\nMany of the media features outlined in the previous section — including , , and — can be prefixed with or to express minimum or maximum constraints. We’ve already seen these in use throughout many of the examples, but the point is that we can create a range of value to match instead of having to declare specific values.\n\nIn the following snippet, we’re painting the body’s background purple when the viewport width is wider than 30em and narrower than 80em. If the viewport width does not match that range of values, then it will fallback to white.\n\nMedia Queries Level 4 specifies a new and simpler syntax using less then ( ), greater than ( ) and equals ( ) operators. So, that last example can be converted to the new syntax, like so:\n\nCSS allows you to nest at-rules or group statements using parentheses, making it possible to go as deep as we want to evaluate complex operations.\n\nBe careful! even thought it’s possible to create powerful and complex expressions, you might end up with a very opinionated, hard to maintain query. As Brad Frost puts it: “The more complex our interfaces are, the more we have to think to maintain them properly.”\n\nMany of the features added in Media Queries Level 4 are centered around accessibility.\n\ndetects if the user has the reduced motion preference activated to minimize the amount of movements and animations. It takes two values:\n• : Indicates that the user has made no preference known to the system.\n• : Indicates that user has notified the system that they prefer an interface that minimizes the amount of movement or animation, preferably to the point where all non-essential movement is removed.\n\nThis preference is generally used by people who suffer from vestibular disorder or vertigo, where different movements result in loss of balance, migraine, nausea or hearing loss. If you ever tried to spin quickly and got dizzy, you know what it feels like.\n\nIn a fantastic article by Eric Bailey, he suggests stopping all animations with this code:\n\nPopular frameworks like Bootstrap have this feature on by default. In my opinion there is no excuse not to use — just use it.\n\nThe feature informs whether the user has chosen to increase or reduce contrast in their system preferences or the browser settings. It takes three values:\n• : When a user has made no preference known to the system. If you use it as a boolean it’ll evaluate false.\n• : When a user has selected the option to display a higher level of contrast.\n• : When a user has selected the option to display a lower level of contrast.\n\nAt the moment of writing this feature is not supported by any browser. Microsoft has done a non-standard earlier implementation with the feature that works only on Microsoft Edge v18 or earlier (but not Chromium-based versions).\n\nThis example is increasing the contrast of a the class button from AA to AAA when the user has high contrast on.\n\nThe feature informs whether the user has chosen to invert the colors on their system preferences or the browser settings. Sometimes this option is used as an alternative to high contrast. It takes two values:\n• : When colors are displayed normally\n• : When a user has selected the option to invert colors\n\nThe problem with inverted colors is that it’ll also invert the colors of images and videos, making them look like x-ray images. By using a CSS invert filter you can select all images and videos and invert them back.\n\nAt the time of writing this feature is only supported by Safari.\n\nHaving a “dark mode” color scheme is something we’re seeing a lot more of these days, and thanks to the feature, we can tap into a user’s system or browser preferences to determine whether we serve a “dark” or a “light” theme based on the ir preferences.\n• : When a user has selected that they prefer a light theme or has no active preferences\n• : When a user has selected a dark display in their settings\n\nAs Adhuham explains in the complete guide to Dark Mode there is way more to it than just changing the color of the background. Before you jump into doing dark mode remember that if you don’t have a very smart implementation strategy you might end up with a code base that’s really hard to maintain. CSS variables can do wonders for it but that’s a subject for another article.\n\nMedia Queries Level 5 is currently in Working Draft status, which means a lot can change between now and when it becomes a recommendation. But it includes interesting features that are worth mentioning because they open up new ways to target screens and adapt designs to very specific conditions.\n\nHey, we just covered these in the last section! Oh well. These features are exciting because they’re informed by a user’s actual settings, whether they are from the user agent or even at the operating system level.\n\nThis is neat. Some browsers will limit the number of available colors that can be used to render styles. This is called “forced colors mode” and, if enabled in the browser settings, the user can choose a limited set of colors to use on a page. As a result, the user is able to define color combinations and contrasts that make content more comfortable to read.\n\nThe feature allows us to detect if a forced color palette is in use with the value. If matched, the browser must provide the required color palette through the CSS system colors. The browser is also given the leeway to determine if the background color of the page is light or dark and, if appropriate, trigger the appropriate value so we can adjust the page.\n\nSome devices (and browsers) are capable of super bright displays, rendering a wide range of colors, and high contrast ratios between colors. We can detect those devices using the feature, where the keyword matches these devices and matches everything else.\n\nWe’re likely to see changes to this because, as of right now, there’s still uncertainty about what measurements constitute “high” levels of brightness and contrast. The browser may get to make that determination.\n\nThe spec talks about some screens, like TVs, that are capable of displaying video and graphics on separate “planes” which might be a way of distinguishing the video frame from other elements on the screen. As such, Media Queries Level 5 is proposing a new set of media features aimed at detecting video characteristics, including color gamut and dynamic range.\n\nThere are also proposals to detect video height, width and resolution, but the jury’s still out on whether those are the right ways to address video.\n\nBrowsers keep evolving and since by the time you are reading this post chances are that browser support for this feature might change, please check MDN updated browser compatibility table.\n\nLet’s look at a bunch of media query examples. There are so many combinations of media types, features, and operators that the number of possibilities we could show would be exhaustive. Instead, we’ll highlight a handful based on specific media features. This is the probably the most widely used media feature. It informs the width of the browser’s viewport including the scrollbar. It unlocked the CSS implementation of what Ethan Marcotte famously coined responsive design: a process by which a design responds to the size of the viewport using a combination of a fluid grid, flexible images, and responsive typesetting. Later, Luke Wroblewski evolved the concept of responsive design by introducing the term mobile-first, encouraging designers and developers to start with the small-screen experience first then progressively enhance the experience as the screen width and device capabilities expand. A mobile-first can usually be spotted by it’s use of instead of . If we start with , we’re essentially saying, “hey, browser, start here and work up.” On the flip side, is sort of like prioritizing larger screens. One approach for defining breakpoints by width is using the dimensions of standard devices, like the exact pixel width of an iPhone. But there are many, many (many), many different phones, tables, laptops, and desktops. Looking at Android alone, there are more than 24,000 variations of viewport sizes, resolutions, operating systems, and browsers, as of August 2015. So, while targeting the precise width of a specific device might be helpful for troubleshooting or one-off fixes, it’s probably not the most robust solution for maintaining a responsive architecture. This isn’t a new idea by any stretch. Brad Frost was already preaching the virtues of letting content — not devices — determine breakpoints in his post “7 habits of highly effective media queries” published back in 2013. And even though media queries are still a valid tool to create responsive interfaces, there are many situations where it’s possible to avoid using width at all. Modern CSS allow us to create flexible layouts with CSS grid and flex that adapts our content to the viewport size without a need to add breakpoints. For example, here is a grid layout that adapts how many columns it will have without any media queries at all. There are many articles about thinking beyond width, I wrote about it a few years ago and I recommend checking out Una Kravet’s Ten modern layouts in one line of CSS. This example is pulled straight from our Guide to Dark Mode on the Web. The idea is that we can detect whether a user’s system settings are configured to light or dark mode using the feature and then define an alternate set of colors for the rendered UI. Combining this technique with CSS custom properties makes things even easier because they act like variables that we only need to define once, then use throughout the code. Need to swap colors? Change the custom property value and it updates everywhere. That’s exactly what does. We define a set of colors as custom properties, then redefine them inside a media query using the feature to change colors based on the user’s settings. This gallery is responsive without using the feature. It detects the of the viewport. If it’s a viewport, the sidebar will became a header; if it’s it stays off to the side. Using the media feature, it decides if the main input device is — like a finger — or — like a mouse cursor — to set the size of the clickable areas of the checkboxes. Then, by using the media feature, the example checks if the device is capable of hovering (like a mouse cursor) and display a checkbox in each card. The animations are removed when is set to . And did you notice something? We’re actually not using media queries for the actual layout and sizing of the cards! That’s handled using the function on the element to show how responsive design doesn’t always mean using media queries. In short, this is a fully responsive app without ever measuring or making assumptions. /* iPhone X Landscape */ @media only screen and (min-device-width: 375px) and (max-device-width: 812px) and (-webkit-min-device-pixel-ratio: 3) and (orientation: landscape) { /* Styles! */ } The media feature tests whether a device is rotated the wide way (landscape) or the tall way (portrait). While media queries are unable to know exactly which device is being used, we can use the exact dimensions of a specific device. The snippet above is targets the iPhone X. In the example above, we’re using to detached fixed elements and avoid taking up too much screen real estate when the screen is too short. A horizontal navigation bar is in a fixed position when the screen is tall, but detaches itself on shorter screens. Like the feature, detects the height of the viewport, including the scrollbar. Many of us browse the web on small devices with narrow viewports, making designing for different heights more relevant than ever. Anthony Colangelo describes how Apple uses the media feature in a meaningful way to deal with the size of the hero image as the viewport’s height changes. A font can look either too big or too small, depending on the size of the screen that’s showing it. If we’re working on a small screen, then chances are that we’ll want to use smaller type than what we’d use on a much larger screen. The idea here is that we’re using the browser’s width to scale the font size. We set a default font size on the that acts as the “small” font size, then set another font size using a media query that acts as the “large” font size. In the middle? We set the font size again, but inside another media query that calculates a size based on the browser width. The beauty of this is that it allows the font size to adjust based on the browser width, but never go above or below certain sizes. However, there is a much simpler way to go about this that requires no media queries at all, thanks to newer CSS features, like , , and . Have you ever visited a site that had super tiny buttons? Some of us have fat fingers making it tough to tap an object accurately without inadvertently tapping something else instead. Sure, we can rely on the feature to tell if we’re dealing with a small screen, but we can also detect if the device is capable of hovering over elements. If it isn’t then it’s probably a touch device, or perhaps a device that supports both, like the Microsoft Surface. The demo above uses checkboxes as an example. Checkboxes can be a pain to tap on when viewing them on a small screen, so we’re increasing the size and not requiring a hover if the device is incapable of events. Again, this approach isn’t always accurate. Check out Patrick Lauke’s thorough article that details potential issues working with , , and .\n\nSpecial thanks to Sarah Rambacher who helped to review this guide."
    },
    {
        "link": "https://reddit.com/r/Frontend/comments/4439e6/is_there_a_best_practice_for_organizing_your",
        "document": "Should they all go in their own section together? Should they come after the base styles they relate to? Scattered throughout?\n\nFor example, if I were to style thusly:\n\nShould I include the media query looking like:\n\nRight after the initial style or do something like save it for a \"media query\" section at the end of the file? What about different breakpoints for the same rule?"
    },
    {
        "link": "https://w3schools.com/css/css_rwd_mediaqueries.asp",
        "document": "It uses the rule to include a block of CSS properties only if a certain condition is true.\n\nEarlier in this tutorial we made a web page with rows and columns, and it was responsive, but it did not look good on a small screen.\n\nMedia queries can help with that. We can add a breakpoint where certain parts of the design will behave differently on each side of the breakpoint.\n\nYou can add as many breakpoints as you like.\n\nWe will also insert a breakpoint between tablets and mobile phones.\n\nHere we use media queries to add breakpoints when screen is max 600px, when screen is min 600px, and when screen is min 768px : @media only screen and (max-width: 600px) {\n\n .item1 {grid-area: 1 / span 6;}\n\n .item2 {grid-area: 2 / span 6;}\n\n .item3 {grid-area: 3 / span 6;}\n\n .item4 {grid-area: 4 / span 6;}\n\n .item5 {grid-area: 5 / span 6;}\n\n}\n\n\n\n@media only screen and (min-width: 600px) {\n\n .item1 {grid-area: 1 / span 6;}\n\n .item2 {grid-area: 2 / span 1;}\n\n .item3 {grid-area: 2 / span 4;}\n\n .item4 {grid-area: 3 / span 6;}\n\n .item5 {grid-area: 4 / span 6;}\n\n}\n\n\n\n@media only screen and (min-width: 768px) {\n\n .item1 {grid-area: 1 / span 6;}\n\n .item2 {grid-area: 2 / span 1;}\n\n .item3 {grid-area: 2 / span 4;}\n\n .item4 {grid-area: 2 / span 1;}\n\n .item5 {grid-area: 3 / span 6;}\n\n}\n\n Try it Yourself »\n\nThere are tons of screens and devices with different heights and widths, so it is hard to create an exact breakpoint for each device. To keep things simple you could target five groups:\n\n/* Extra small devices (phones, 600px and down) */\n\n@media only screen and (max-width: 600px) {...} \n\n\n\n/* Small devices (portrait tablets and large phones, 600px and up) */\n\n@media only screen and (min-width: 600px) {...} \n\n\n\n/* Medium devices (landscape tablets, 768px and up) */\n\n @media only screen and (min-width: 768px) {...} \n\n\n\n/* Large devices (laptops/desktops, 992px and up) */\n\n @media only screen and (min-width: 992px) {...} \n\n\n\n/* Extra large devices (large laptops and desktops, 1200px and up) */\n\n@media only screen and (min-width: 1200px) {...} Try it Yourself »\n\nMedia queries can also be used to change layout of a page depending on the orientation of the browser.\n\nYou can have a set of CSS properties that will only apply when the browser window is wider than its height, a so called \"Landscape\" orientation:\n\nAnother common use of media queries, is to hide elements on different screen sizes:\n\nI will be hidden on small screens.\n\nYou can also use media queries to change the font size of an element on different screen sizes:\n\n/* If the screen size is 601px or more, set the font-size of <div> to 80px */\n\n@media only screen and (min-width: 601px) {\n\n div.example {\n\n font-size: 80px;\n\n }\n\n}\n\n\n\n/* If the screen size is 600px or less, set the font-size of <div> to 30px */\n\n@media only screen and (max-width: 600px) {\n\n div.example {\n\n font-size: 30px;\n\n }\n\n}\n\n Try it Yourself »\n\nFor a full overview of all the media types and features/expressions, please look at the @media rule in our CSS reference."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_media_queries/Using_media_queries",
        "document": "Media queries allow you to apply CSS styles depending on a device's media type (such as print vs. screen) or other features or characteristics such as screen resolution or orientation, aspect ratio, browser viewport width or height, user preferences such as preferring reduced motion, data usage, or transparency. Media queries are used for the following:\n• To conditionally apply styles with the CSS and at-rules.\n• To target specific media for the , , , and other HTML elements with the or attributes.\n• To test and monitor media states using the and methods. Note: The examples on this page use CSS's for illustrative purposes, but the basic syntax remains the same for all types of media queries.\n\nMedia types describe the general category of a given device. Although websites are commonly designed with screens in mind, you may want to create styles that target special devices such as printers or audio-based screen readers. For example, this CSS targets printers: You can also target multiple devices. For instance, this rule uses two media queries to target both screen and print devices: See media types for the list of available media types. Because media types describe devices in very broad terms, most of the originally-defined media types were deprecated, with just , , and remaining. To target more specific attributes, use media features instead.\n\nMedia features describe the specific characteristics of a given user agent, output device, or environment. For instance, you can apply specific styles to widescreen monitors, computers that use mice, or devices that are being used in low-light conditions. This example applies styles when the user's primary input mechanism (such as a mouse) can hover over elements: Media features are either range or discrete. Discrete features take their value from an enumerated set of possible keyword values. For example, the discrete feature accepts either or . Many range features can be prefixed with \"min-\" or \"max-\" to express \"minimum condition\" or \"maximum condition\" constraints. For example, this CSS will apply styles only if your browser's viewport width is equal to or narrower than 1250px: The following media queries are equivalent to the above example: With media query range features, you can either use the inclusive and prefixes or the more concise range syntax operators and . The following media queries are equivalent: The range comparisons above are inclusive. To exclude the comparison value, use and/or . If you create a media feature query without specifying a value, the nested styles will be used as long as the feature's value is not or . For example, this CSS will apply to any device with a color screen: If a feature doesn't apply to the device on which the browser is running, expressions involving that media feature are always false. For more Media feature examples, please see the reference page for each specific feature.\n\nSometimes you may want to create a media query that depends on multiple conditions. This is where the logical operators come in: , , and . Furthermore, you can combine multiple media queries into a comma-separated list; this allows you to apply the same styles in different situations, with the contained media queries evaluated as a logical composition: interpreted as if each media query were within parentheses with an between them. In the previous example, we saw the operator used to group a media type with a media feature. The operator can also combine multiple media features within a single media query. The operator negates a media query, or a media feature when used with brackets, basically reversing their normal meanings. The operator can, under certain conditions, be used to combine multiple media features within a single media query. Lastly, the operator was used to prevent older browsers from applying the styles without evaluating the media feature expressions but it has no effect in modern browsers. Note: In most cases, the media type is used by default when no other type is specified. However, if you use the operator, you must explicitly specify a media type. You can see or as a whole.\n\nYou can use a comma-separated list of media queries to apply styles when the user's device matches any one of various media types, features, or states. The following rule contains two media queries. The block's styles will apply if either the user's device has a height of 680px or more or if the browser viewport is in portrait mode (the viewport height is greater than the viewport width): In this example, if the user is printing to a PDF and the page height is 800px, the media query returns true because the first query component — which tests whether the viewport has a height of or more — is true. Likewise, if a user is on a smartphone in portrait mode with a viewport height of 480px, the media query returns true because the second query component is true. In a comma-separated list of media queries, the individual media queries end at the comma or, in the case of the last media query in the list, at the opening bracket ( ).\n\nThe keyword inverts the meaning of a single media query. For example, the CSS styles in this media query will apply to everything except printed media: The negates only the media query it is applied to. The , without parenthesis, negates all the features within the media query in which it is contained. This means, in a comma-separated list of media queries, each applies to the single query it is contained within, applying to all the features within that single query. In this example, the applies to the first media query, which concludes at the first comma: @media not screen and (color), print and (color) { /* … */ } The above query is evaluated like this: @media (not (screen and (color))), print and (color) { /* … */ } Both examples are valid. Media conditions can be grouped by wrapping them in parentheses ( ). These groups can then be nested within a condition the same as a single media query. The is evaluated last in a media query, meaning it applies to the entire media query, not to a single feature within a query, as if an open parenthesis was added immediately after the and closed at the end of the media query. @media not all and (monochrome) { /* … */ } @media not (all and (monochrome)) { /* … */ } It is not evaluated like this: @media (not all) and (monochrome) { /* … */ } To negate a single feature within a media query, use parenthesis. Encompassing a and a media feature in parentheses limits the components of the query that get negated. In this example, we negate the media feature but not the media type: The matches if the device has no hover capability. In this case, because of the parentheses, the applies to but not to ."
    },
    {
        "link": "https://elegantthemes.com/blog/wordpress/responsive-design-with-css-media-query-breakpoints-the-easy-way",
        "document": "There’s nothing worse than meticulously designing a web page and checking it on a mobile phone, and nothing is readable. Thankfully, CSS offers several ways of addressing this exact situation. One of the most long-standing tools in the CSS toolbelt is Media Queries.\n\nMedia Queries let you specify design rules in very specific situations. If you know how to write CSS, you can start writing media queries in about five minutes. But their benefits are not beyond you if you aren’t a pro with CSS—I’ll show you how WordPress’ best page builder lets you build media queries without ever realizing it.\n\nWhat Are Media Queries and Important Things to Know\n\nWebsites are opened on all sorts of devices, from large desktop displays to cell phones. Media queries are a key CSS tool for achieving a readable and well-designed site regardless of screen size. Media Queries allow you to conditionally apply CSS styles based on screen size, device type, orientation, resolution, and more.\n\nThe iPhone’s release was really the first time that responsive design became an essential part of web design. Much of the web was simply unreadable on mobile devices. Today, the situation is much better, but things are still complicated. There are dozens of flagship phones out there with all sorts of screen resolutions and dimensions.\n\nMore than that, desktop displays are getting to absurd proportions (a 40+ inch display is in my future), meaning web designers have to create websites that work between 2.5 and 41 inches wide.\n\nAnd maybe a little bit smaller if this catches on.\n\nIt starts with @media, which tells the browser you are defining a media query. Next, you specify the media type. For websites, screen is the most common type, as it applies to computer screens, tablets, and smartphone displays. There are others, like print and\n\nAfter the media type, you add media features within parentheses. These are the conditions that trigger the media query. Width is the critical media feature. You’ll often use max-width and min-width to target different screen widths. Max-width applies styles when the screen is at or below a certain width. Min-width applies styles when the screen is at or above a certain width.\n\nInside the media query, you write standard CSS rules. These CSS rules will only be applied when the media query’s conditions (usually width conditions) are met.\n\nMedia Queries can target more than device width. Orientation detects if a device is in portrait (vertical) or landscape (horizontal) mode. Resolution and device-pixel ratio are used for high-resolution or “retina” screens to ensure sharp images and text. Pointer and hover can differentiate between devices with touch input versus mouse-based interactions. So, after you learn the basics of width-based media queries, there’s still more for you to learn.\n\nMedia Queries quickly get hard to manage. Follow these key practices to keep your styles organized and scalable:\n• Mobile-First Designing → Start with your smallest breakpoint as the base, then use min-width to scale up instead of constantly overriding styles.\n• Use Adaptive Layouts → Flexbox and Grid can eliminate the need for excessive media queries by making elements flow by default.\n• Keep Styles Modular → For easier maintenance, place component-specific media queries inside the component’s CSS file rather than a global stylesheet.\n\nBreakpoints are specific screen widths that media queries can target. Breakpoints roughly match up to device categories: small phones, tablets, and desktops. However, those figures are just mental categories. While there are standard “defaults,” it’s best to test your site in your browser’s Dev Tools. Examine your site’s design to determine where breakpoints are needed.\n\nHere’s an example of a page with default breakpoints set but where the design suffers because the mobile breakpoint looks better than the tablet breakpoint at 770px.\n\nHere are some default Media Queries ranges you can start with (but feel free to deviate if your design demands something different):\n\nHere’s how the Bootstrap Framework has their breakpoints set:\n\nMedia Queries solve so much of what can go wrong with responsive web design. It’s just that they aren’t always the easiest to work with. They can be hard to manage and diagnose problems within because they are essentially more CSS that you have to write.\n\nHow Divi Makes Media Queries Easier to Work With\n\nApplying media queries quickly becomes overwhelming with so many breakpoints you could create rules for. While it works, it can easily become taxing.\n\nThat’s actually the main benefit of a visual design tool like Divi. With Divi, Media Queries are abstracted out of view and are automatically created based on your design decisions within a visual page builder. You get all the benefits of finely tuned designs (on multiple breakpoints) without having to write or manage each individual media query.\n\nInstead, Divi makes it easy to manage (find, update, and delete) every module’s responsive settings. It’s quite the opposite of managing hundreds of media queries in a stylesheet. That method requires a lot of jumping around a .css document, using Ctrl+F/Cmd+F to find the queries to edit. Inside Divi, all your responsive settings are saved on the module itself. To edit a style, find and click the element on the page, go to the responsive view you want to edit, and make your changes. All of Divi’s design tools are modulated to work at that breakpoint, making it very intuitive.\n\nDivi allows you to define your own breakpoint widths. That means you don’t need to use a default setting that doesn’t quite align with your needs. You can change any breakpoint to apply precisely at the seam you need. Note that breakpoints are set site-wide.\n\nOther Things that Help You Build Responsive Websites\n\nWhile media queries help you control designs at specific breakpoints, modern CSS tools can reduce reliance on them by making elements inherently flexible. What if your layouts could adjust themselves automatically—without extra media queries?\n\nCSS Grid is a layout system that places elements into a grid, and the whole grid structure automatically adjusts to the available spacing. It is good for displaying a set number of items along a structure column and row layout. Unlike Flexbox which works across one axis, Grid works across two dimensions of control.\n\nWhen to Use Grid\n• When you need a dynamic grid that rearranges itself based on available space.\n• Auto-fit fills the row with as many columns as can fit. If extra space remains, columns grow instead of leaving empty gaps.\n• Minmax(200px, 1fr) means each column is at least 200px but grows in instances with any extra space.\n• No media queries are required—columns adjust naturally based on screen width.\n\nFlexbox is a layout system designed for arranging elements along a single axis (row or column). It dynamically distributes space between items, making it ideal for navigation menus, buttons, and content alignment.\n• When designing navbars, buttons, and form layouts that adjust based on available space.\n• When elements need equal spacing or dynamic wrapping without writing breakpoints.\n• Flex-wrap: wrap; allows items to break onto a new line when they no longer fit in a single row, meaning that they adjust naturally to different screen sizes.\n• No media queries needed—items flow naturally as the container resizes.\n\nThe clamp() function allows font sizes (or other properties) to scale dynamically between a minimum and maximum value, all based on screen size. This makes text readable on small screens but doesn’t grow too large on bigger displays.\n• When designing headings and body text that should be fluid without needing media queries.\n• Prevents text from becoming too small on mobile or too large on ultra-wide screens.\n• The H1 heading will be at least 1.5rem and will scale dynamically at 2% of the viewport width but never exceed 3rem.\n• There is no need for media queries to adjust typography for different screen sizes\n\nLogical properties replace hard-coded values (like width, height, left, and right) with flow-aware terms like inline-size (width) and block-size (height). These adjust automatically based on text direction and don’t rely on precise measurements per each breakpoint.\n• When designing multi-language websites that switch between left-to-right (LTR) and right-to-left (RTL) layouts.\n• Useful for internationalization without needing different stylesheets or media queries.\n\nExample: Logical Properties on a Container Instead of Fixed Values\n• Inline-size ensures full width in any writing mode (LTR or RTL) without hard coding for each writing mode separately.\n• Works without needing separate styles for Arabic, Hebrew, or other RTL languages. This eliminates the need to write separate CSS for different text directions, allowing layouts to adjust automatically.\n\nAny web designer should know one or two of the tools below. They’ll help you see how your response designs are shaping up, no matter which CSS modules you use to achieve your end result.\n\nGoogle Chrome’s and Firefox’s responsive view in the Developer Tools is very handy (Chrome pictured above). With it, you can simulate various predefined devices, including popular smartphones and tablets. You also have:\n• Page Width Handle (Draggable Resizing)\n• This allows you to manually adjust the viewport width by dragging to test how the website responds at different screen widths.\n• Page Height Handle (Draggable Resizing)\n• This allows you to manually adjust the viewport height by dragging to test how the website responds at different screen heights.\n• Media Query Breakpoints Overview\n• A visual representation of active CSS media queries. The blue bars indicate min-width breakpoints, the yellow bars show max-width, and the purple/pink bars highlight other media features (like min and max).\n• Viewport Dimensions & Device Selection\n• This displays the current viewport width and height in pixels. You can select predefined device sizes or set custom widths to test responsiveness at standard intervals.\n\nYou can open Chrome’s or Firefox’s DevTools by pressing Ctrl + Shift + I on Windows/Linux or Cmd + Option + I on Mac.\n\nLambdaTest is a cloud-based platform that allows developers to test their websites on various devices and operating systems. The platform also supports automated workflows, which are particularly useful for large-scale projects.\n\nBrowserStack provides real-time testing on real devices, ensuring the most accurate results. Its ability to simulate different screen resolutions, browsers, and operating systems makes it an essential tool for responsive testing. Developers can integrate it with their CI/CD pipelines for seamless testing workflows. BrowserStack offers different tools for testing media queries:\n• Automated Testing (Using Selenium, Playwright, or other automation tools).\n\nHow to Use Divi to Create Media Queries Without Coding Them\n\nSince you have some more understanding of Media Queries (along with how to test them), I wanted to show you exactly how it works inside of Divi. Divi 5 introduces an advanced breakpoint system, giving users more control over responsive design. You can access breakpoints directly within the Visual Builder on any page.\n\nClick the “three-dot icon” in Visual Builder’s main taskbar to view a list of the breakpoints you can add and customize.\n\nFind the toggle switches inside the settings to enable or disable breakpoints as needed. You can also set custom values for all breakpoints.\n\nWhen you’re breakpoints are ready to go, you can click on any module on the page. From there, change to the breakpoint you want to make the change on, select the styles you want to edit, and make your changes.\n\nYou can see exactly how it will look at that breakpoint, and you can even use the draggable width bar to see how it would look throughout the breakpoint’s range.\n\nResponsive settings applied in a module on the Phone, Phone Wide, Tablet, and Tablet Wide breakpoints use min-width media queries. Responsive settings applied in a module at the Widescreen and Ultra Wide breakpoints use max-width media queries. These are automatically created for you; you don’t need to write them manually—it’s just how they work behind the scenes.\n\nDesktop acts as the base device between the closest breakpoints above and below it. The base device doesn’t use media queries, just standard CSS. But again, Divi makes sure that you never have to worry about writing these media queries yourself. As you make changes in the UI, those media queries are automatically created.\n\nResponsive design makes it so that every website visitor gets a good experience. A one-size-fits-all approach won’t cut it with devices ranging from wearables to ultra-wide monitors. Media queries and modern CSS techniques give you the tools to build sites that adapt intelligently to any screen size. And if working with CSS directly is intimidating, Divi makes it as easy as ever to achieve the same effect without needing to write or manage separate media queries.\n\nAre you building a new site or redesigning your current one on WordPress? Use Divi 5 to create the easiest responsive website of your life."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_selectors",
        "document": "The CSS selectors module defines the patterns to select elements to which a set of CSS rules are then applied along with their specificity. The CSS selectors module provides us with more than 60 selectors and five combinators. Other modules provide additional pseudo-class selectors and pseudo-elements.\n\nIn CSS, selectors are patterns used to match, or select, the elements you want to style. Selectors are also used in JavaScript to enable selecting the DOM nodes to return as a .\n\nSelectors, whether used in CSS or JavaScript, enable targeting HTML elements based on their type, attributes, current states, and even position in the DOM. Combinators allow you to be more precise when selecting elements by enabling selecting elements based on their relationship to other elements."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Styling_basics/Basic_selectors",
        "document": "You've already seen how, in CSS, selectors are used to target the HTML elements on our web pages that we want to style. There are a wide variety of CSS selectors available, allowing for fine-grained precision when selecting elements to style, and in the next few articles we'll look at the different types in depth. In this article we'll recap some selector fundamentals, including the basic type, class, and ID selectors, and selector lists. We'll also introduce the universal selector.\n• Understand that IDs are unique per document — you should use an ID to select one specific element.\n• Understand that you can have multiple classes per element, and these can be used to layer on styles as required.\n\nA CSS selector is the first part of a CSS Rule. It is a pattern of elements and other terms that tell the browser which HTML elements should be selected to have the CSS property values inside the rule applied to them. The element or elements which are selected by the selector are referred to as the subject of the selector. In earlier articles you may have met some different selectors, and learned that there are selectors that target the document in different ways — for example by selecting an element such as , or a class such as . Let's start off by recapping the main ones you've already seen.\n\nA type selector is sometimes referred to as a tag name selector or element selector because it selects an HTML tag/element in your document. In the example below, we have used the , and selectors. Try adding a CSS rule to select the element and change its color to blue:\n\nYou can create a selector that will target specific elements with the class applied. In this next example, we will highlight a with a class of differently to an heading with a class of . We do this by using the type selector for the element we want to target, with the class appended using a dot, with no white space in between. This approach reduces the scope of a rule. The rule will only apply to that particular element and class combination. You would need to add another selector if you decided the rule should apply to other elements too.\n\nTarget an element if it has more than one class applied You can apply multiple classes to an element and target them individually, or only select the element when all of the classes in the selector are present. This can be helpful when building up components that can be combined in different ways on your site. In the example below, we have a that contains a note. The grey border is applied when the box has a class of . If it also has a class of or , we change the . We can tell the browser that we only want to match the element if it has two classes applied by chaining them together with no white space between them. You'll see that the last doesn't get any styling applied, as it only has the class; it needs as well to get anything applied. <div class=\"notebox\">This is an informational note.</div> <div class=\"notebox warning\">This note shows a warning.</div> <div class=\"notebox danger\">This note shows danger!</div> <div class=\"danger\"> This won't get styled — it also needs to have the notebox class </div>\n\nThe case-sensitive ID selector begins with a rather than a dot character, but is used in the same way as a class selector. The difference is that an ID can be used only once per page, and elements can only have a single value applied to them. It can select an element that has the set on it, and you can precede the ID with a type selector to only target the element if both the element and ID match. You can see both of these uses in the following example: Warning: Using the same ID multiple times in a document may appear to work for styling purposes, but don't do this. It results in invalid code, and will cause strange behavior in many places.\n\nIf you have more than one thing which uses the same CSS then the individual selectors can be combined into a selector list so that the rule is applied to all of the individual selectors. For example, if I have the same CSS for an and also a class of , I could write this as two separate rules. I could also combine these into a selector list, by adding a comma between them. White space is valid before or after the comma. You may also find the selectors more readable if each is on a new line. In the live example below try combining the two selectors which have identical declarations. The visual display should be the same after combining them. When you group selectors in this way, if any selector is syntactically invalid, the whole rule will be ignored. In the following example, the invalid class selector rule will be ignored, whereas the would still be styled. When combined however, neither the nor the class will be styled as the entire rule is deemed invalid.\n\nThe universal selector is indicated by an asterisk ( ). It selects everything in the document. If is chained using a descendant combinator, it selects everything inside that ancestor element. For example, selects all the nested elements inside the element. In the following example, we use the universal selector to remove the margins on all elements. Instead of the browser's default styling, which spaces out headings and paragraphs with margins, everything is close together. This kind of behavior can sometimes be seen in \"reset stylesheets\", which strip out all of the browser styling. Since the universal selector makes global changes, we use it for very specific situations, such as the one described below.\n\nUsing the universal selector to make your selectors easier to read One use of the universal selector is to make selectors easier to read and more obvious in terms of what they are doing. For example, if we wanted to select any descendant elements of an element that are the first child of their parent, including direct children, and make them bold, we could use the pseudo-class. We will learn more about this in the lesson on pseudo-classes and pseudo-elements: However, this selector could be confused with , which will select any element that is the first child of another element. To avoid this confusion, we can add the universal selector to the pseudo-class, so it is more obvious what the selector is doing. It is selecting any element which is the first-child of an element, or the first-child of any descendant element of : Although both do the same thing, the readability is significantly improved."
    },
    {
        "link": "https://devdocs.io/css",
        "document": ""
    },
    {
        "link": "https://wpshout.com/css-selector-types",
        "document": "Here’s what we’re going to cover:\n\nThe universal selector, as the name suggests, selects all elements. You can use it on its own or along with another selector. It’s declared using the asterisk characters (*).\n\nThe above example uses the universal selector to target all elements on the page. This gives the elements a value of . This is a common use of the universal selector that ensures more intuitive sizing of page elements.\n\nIf you use the universal selector along with another selector, it might look like this:\n\nThe above selects all child elements (including deeply nested elements) of elements. Another example that’s a little more complex might be:\n\nIn the above example, I’m selecting all span elements that are inside any element that are children of elements. You won’t see this type of use for the universal selector very often, as it’s quite unintuitive.\n\nThe type selector, also referred to as an element type selector, selects elements based on the element’s tag name in the HTML. Below are a few examples:\n\nThe above includes two CSS rules that apply CSS to all elements or all elements. You can target any valid HTML element using its equivalent type selector name.\n\nYou can also technically invent HTML tag names, then use the custom name in your CSS. For example, you could have this in your HTML:\n\nThen the following in CSS:\n\nThe above works, but it is strongly recommended not to do this. If you need a generic HTML element, use or , then use classes and data attributes as needed to customize it.\n\nNonetheless, the above should illustrate how the type selector works from a CSS standpoint.\n\nYou may also be interested in:\n• 15 Best Programming Fonts for Coding and Development (Free!)\n\nThe class selector is the most-used and most useful of all CSS selector types. It’s declared using a dot ( ) followed by a custom name that must exist as a attribute in your HTML.\n\nFor example you might have the following HTML:\n\nIn your CSS you can target the above element using the class selector as follows:\n\nThe HTML included two different class names in the attribute, so I was able to target the same element using separate class selectors.\n\nThe class selector is the basis for CSS methodologies like OOCSS, BEM, and SMACSS. This selector type is also the foundation for popular CSS frameworks like Bootstrap and Tailwind.\n\nYou can create atomic styles using the class selector. These types of styles, often called single-purpose utility classes, are reusable and can serve as building blocks for complex CSS projects. The number of class names you can include in a single HTML attribute is more or less unlimited. Thus, the class selector serves a powerful foundation for many frameworks today.\n\nThe class selector is also powerful because you can reuse a class name multiple times on a single page, making it versatile and flexible.\n\nThe ID selector is declared using the pound symbol ( ) followed by a custom name. This selector will match an HTML element that uses the same name as a value for the attribute.\n\nYour HTML would look like this:\n\nAnd the following CSS would target the above element:\n\nUse of the ID selector is strongly discouraged for multiple reasons:\n• The ID selector can only target a single element and therefore cannot be reused\n• The ID selector has very high specificity, so if you want to override it elsewhere in your stylesheet, it will be difficult, making your stylesheet harder to maintain\n\nWhile most developers today discourage use of the ID selector, the attribute is encouraged in HTML for defining in-page anchors as well as for JavaScript hooks. Use class names or other selectors instead of the ID selector, to ensure CSS is as maintainable as possible.\n\nThe attribute selector is a fairly underused and underappreciated CSS selector type. You write this selector using square brackets ( ) and the value inside the brackets should match an HTML attribute.\n\nFor example, suppose you have the following HTML:\n\nNow notice the following CSS:\n\nThis CSS targets all elements that have a attribute. You can use the attribute selector on its own with no other selector present:\n\nThe above targets all elements that have a attribute, regardless of what element type they are.\n\nUsefully, you can declare the attribute selector’s value using a number of different operators and flags. Below are examples of each.\n\nThis uses the starts-with operator ( ) to target all anchor elements with an attribute that starts with (the hash or pound sign):\n\nThe following uses the wildcard operator to target all anchor elements with an attribute that has the word “downloads” anywhere in its value:\n\nNext I’ll use the case-insensitivity flag ( ) to target all anchor elements with an attribute that has the word “downloads” anywhere, regardless of capitalization:\n\nThis next code uses the case-sensitivity flag ( ) to target all anchor elements with an attribute that has the word “Blog” anywhere in the URL, with strict capitalization:\n\nFinally, the following uses the ends-with operator ( ) to target all anchor elements with an attribute that ends with “.pdf”:\n\nYou can use the above snippet to add an icon next to the link, dependent on the file type of the URL.\n\nThere are a number of different characters that work as combinators that are not technically “selectors” but they work along with selectors. These let you to target specific elements in certain contexts.\n\nThe descendant combinator is the space character that separates two selectors. In the following code, the selector targets all anchor elements that are children of paragraph elements.\n\nChildren targeted are immediate children and any grandchildren, no matter how deeply nested.\n\nYou declare a child combinator using the greater-than symbol ( ). It’s similar to the descendant combinator but allows you to select only the direct child elements of the element to the left of the combinator.\n\nThe above will target only anchor elements that are immediate children of paragraphs. Any anchor elements that are nested inside other elements that are inside the will not be selected.\n\nThe general sibling combinator is defined using a tilde ( ). This allows you to select all sibling elements that appear after the elements defined by the selector before the tilde. It will not select sibling elements that are prior to elements defined by the selector before the tilde.\n\nFor example, the following will select all elements that follow and share the same parent as it (i.e. they are siblings):\n\nThis means in the following HTML, only the latter two elements will qualify for the styles, even though the first is also technically a “sibling”:\n\nThe adjacent sibling combinator is defined using the plus sign ( ). With this combinator, you can select an element that immediately follows the first element. For example, one common use case for this CSS selector type is indenting paragraphs:\n\nAlthough most paragraphs on the web are double spaced with no indenting, many blogs will use the method common in print publications (that is, indenting paragraphs that follow paragraphs). This is achieved using the CSS above via the adjacent sibling combinator. Thus, the above CSS will only apply the indent to paragraphs that immediately follow another paragraph. The first paragraph inside the parent will not be selected.\n\nThere are a whole slew of pseudo-classes available to style different elements and parts of a web page. A pseudo-class selects based on a state rather than the existence of an element. Pseudo-classes are defined using a single-colon, followed by the pseudo-class name.\n\nIf the psuedo-class is placed directly following another selector (e.g. ) it will style the specified state only on the targeted selector. If there’s a space between the selector and the pseudo-class ( ), it becomes two selectors separated by a descendant combinator.\n\nBelow is a list and brief description of the most common pseudo-classes:\n• – Styles links that are not visited.\n• – Targets links that have been visited, with some limitations due to privacy\n• – Styles a part of a document based on a document fragment in the URL, similar to how Wikipedia styles footnotes\n• – Targets the root element of a document, usually the element\n• – Allows you to use math-like notation or keywords ( and ) to select specific elements, commonly used for things like zebra stripes with CSS\n• – Targets the first child element of a parent\n• – Targets the last child element of a parent\n• – Allows you to use math-like notation and keywords ( and ) to match a specific set of elements among a group\n• – Styles elements that the user hovers their mouse over\n• – Targets the element that’s currently ‘activated’, usually by means of a click\n• – Matches the element that currently has focus, usually by means of the keyboard or a mouse click\n• – Selects radio buttons and checkboxes that are in the “selected” or “checked” state\n• – Targets form elements that have the attribute set\n\nThere are also some functional pseudo-classes that allow you to pass in a list of selectors. Based on the list provided, this type of pseudo-class will either style or avoid styling the elements passed in.\n• – Matches any selectors in a comma-separated list passed into the function, but with potentially high specificity\n• – Matches any element that’s not in the list passed in\n• – Slightly improves on by matching any elements in the list without affecting specificity\n• – Helps to target a parent or previous sibling element, depending on the selector provided\n\nThere are a number of other pseudo-classes, many added to the specification in more recent years with weaker browser support. You can see a comprehensive list on MDN.\n\nPseudo-elements are declared using a double colon ( ) followed by the pseudo-element name. As the word “pseudo” suggests, these selectors target what more or less amount to imaginary elements on the page.\n\nThe most common pseudo-elements are briefly described below:\n• – Used in conjunction with the property, adds a pseudo-element inside an element, but before the targeted element’s content\n• – Same as previous, but adds a pseudo-element after the targeted element’s content\n• – Styles the first letter of the first line of the targeted block-level element that’s not preceded by other content (like an image)\n• – Styles the first line of the targeted block-level element, the size of which is defined by various factors (width of the element, width of the viewport, font size, etc.)\n• – Allows you to style the placeholder text that appears inside a form input or textarea element, set using the attribute in HTML\n• – Styles any text on the page that’s selected, usually done by the user by clicking and dragging the mouse\n• – This targets the “marker box” for HTML list items, meaning the area where the “bullet” appears, allowing you to add a custom marker, number, or bullet\n\nPseudo-elements should be used with care, particularly and . These can inject text content into the page that’s not accessible to screen readers. Thus, these selectors should only be used for decorative elements that aren’t critical to the main content.\n\nIt should also be noted that some pseudo-elements previously were supported using the single-colon syntax (e.g. ). These will still work in most browsers for legacy reasons but it’s recommended to always use the double-colon syntax to differentiate them from pseudo-classes.\n\nThere are some other pseudo-elements that are lesser-known with weaker browser support that are listed on MDN.\n\nAs many of the code examples in this article have shown, CSS selector types can be combined to create all sorts of possibilities when targeting elements.\n\nFor example, there are simple selectors that include a single entity (e.g. ). There are compound selectors that combine multiple selectors but don’t use a combinator (e.g. ). There are complex selectors that use combinators that separate two or more selectors (e.g. ). Some of these are referred to as relative selectors because a portion of the selector is implied (e.g. , which uses a combinator with nothing in front).\n\nFinally, one of the most common ways to combine selectors is using one or more commas ( ). Note the following example:\n\nThe above is called a selector list. This will target any of the elements represented by one or more of the listed selectors separated by commas.\n\nIn the above example, even if a page has no elements, it will still target the and elements. This is a common technique to avoid repeating CSS for multiple selector rules. This allows you to use one set of properties for a single CSS rule.\n\nLearning the different CSS selector types takes some time and experience. Remember to do your best to keep selectors simple. The more selectors you include in a combined selector, the harder it will be to maintain your CSS. Class selectors are always the safest to use to help with this.\n\nI hope this review of the different selector types has helped you and given you some powerful tools to use for your next CSS project.\n\nLet us know if you have any questions on how these things work or if any of the above advice is unclear in any way."
    },
    {
        "link": "https://w3.org/Style/CSS/specs.en.html",
        "document": ""
    }
]