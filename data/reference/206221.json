[
    {
        "link": "https://auth0.com/docs/manage-users/cookies/spa-authenticate-with-cookies",
        "document": "Securing a single-page app (SPA) can be a challenge. However, if your SPA meets the following criteria, then you can simplify your implementation by using cookies to authenticate.\n• None Served to the client using your own backend.\n• None Has the same domain as your backend.\n• None Makes API calls that require authentication to your backend.\n\nHere is a description of this approach as well as a sample implementation using Node.js.\n\nThe steps below show how tokens are retrieved and used. In this approach, the Implicit Flow with Form Post is used instead of a traditional Authorization Code Flow with Proof Key for Code Exchange. This is because Form Post Response Mode is a simpler way to implement login when it’s your own resource you are requesting to access.\n• None The user accesses a protected route using the browser, or performs some action that requires an authentication step to be initiated (such as clicking on a Login button)\n• None The browser client redirects to a route on the backend, or to the protected route depending on what the user did\n• None The backend constructs a request to the authorization server’s endpoint and redirects the browser client there\n• None The user is prompted to authenticate themselves using whatever method the authorization server presents\n• None The authorization server POSTs the tokens to the redirect URI as a URL-encoded form post. The backend is able to retrieve those tokens by parsing the body data.\n\nAt this point, the user is authenticated and the backend has the required tokens. A cookie can now be created to represent this state on the client. The client browser is then redirected to a route that serves the SPA and also receives the authentication cookie.\n\nFrom now on, this cookie is traded between the client and backend when API calls are made using an AJAX call. On each request, the backend verifies if the cookie is still valid and if so, allows the request to continue.\n\nWhen implementing this approach you'll need to handle cases where the authentication cookie is invalid or missing. The API call to the backend from the client happens in the background, so the client has to deal with any response from the server indicating the user should reauthenticate.\n\nIn the following sample application, this case is handled in a naive way by prompting the user to re-authenticate if the API call results in a 302 Redirect result. The 302 occurs because, upon unsuccessful validation of the cookie, the server tries to redirect to the Authorization endpoint of the and sends this response to the client.\n\nThe example application uses Node.js and Express to demonstrate the concepts covered above.\n• None To follow along, make sure you have the latest version of Node installed.\n• None Once Node is installed, download or clone the source code and open the project folder inside a terminal window. // Clone the tutorial respository using SSH git clone git@github.com:auth0-blog/spa-cookie-demo // ... or if you use HTTPS: git clone https://github.com/auth0-blog/spa-cookie-demo.git // Move into the project directory cd spa-cookie-demo\n• None The branch represents the state of the application before any authentication is added. If you would like to refer to the final version of the application, check out the branch:\n\nInstall the application dependencies by running from your terminal window. To run the application, use . This starts the Express server. Go to http://localhost:3000 in your browser to view the application.\n\nThe development servers uses , which automatically restarts whenever it detects any file changes.\n\nWith the application open at http://localhost:3000, click the Call API button. You should see a message displayed on the screen.\n\nNote that you were able to make the API call without being logged in. Let's fix that by adding some middleware that requires the user to authenticate before the API call can be made.\n\nFor the application to work with authentication, requires some environment variables to be present. For this application, these variables can be specified in a file. Create a file in the root of the project directory and populate it with the following:\n• None Go to Dashboard > Applications > Applications and click Create Application.\n• None Name your new application, select Regular Web Applications, and click Create\n• None In the Settings for your new app, add to Allowed Callback URLs.\n• None Go to Dashboard > Authentication > Social and set up some social connections. Enable them for your app in the Application options in the Connections tab. The example uses username/password database, Facebook, Google, and X.\n• None On the Settings screen, note the domain and client ID settings at the top.\n• None There are two values that need to be configured as part of the application. Reopen the file and set these values:\n• None With the server and environment configuration done, find your browser window that has the application open. If you've closed the browser and stopped the server, run the following from the terminal to restart the application:\n• None Open http://localhost:3000 in the browser. From a user interface perspective, the app should look the same, however this time when the Call API button is clicked, you should receive a warning that the user is not logged in. Also note that you do not see the \"Hello, World\" message as before since the call to the API has been rejected.\n• None Click Log in now to log in. Once you have been authenticated, you'll return to the app and see an updated UI that reflects your new logged-in state. You should be able to press the Call API button once more to invoke an API call to the server, and it now works.\n• None Click the Profile link at the top of the page to show user information retrieved from the ID token."
    },
    {
        "link": "https://dev.to/emmykolic/cookies-based-authentication-vs-session-based-authentication-1f6",
        "document": "If There’s one thing I would like to know previously, it is the entire way Authentication works, session authentication and cookie authentication are both types of token-based authentication. So we will be talking about Cookie-Based and Session-Based Authentication. As a developer, there will come a time when you will see the need of using authentication in your web application.\n\nWhat images do you have in mind when you hear the terms sessions and cookies? Cookies are kept on the client directly (Browser). Whereas sessions make use of a cookie as a kind of key to link with the information kept on the server side. Because the actual values are concealed from the client and the developer has control over when the data expires, sessions are preferred by the majority of developers.\n\nWithout wasting your time let’s jump straight into this guide.\n\nVerifying a user or entity's identity to access a system, network, or application is known as authentication. It entails confirming that the user's or an entity's identity credentials, such as a username and password, a security token, biometric information, or a digital certificate, are accurate.\n\nTo ensure that only authorized parties or individuals are given access to sensitive data and resources, authentication is a crucial component of security. To offer a secure and dependable access control system, it is frequently used in conjunction with other security measures including authorization, encryption, and multi-factor authentication.\n\nWhen a user logs into an application or website, session authentication, a sort of token-based authentication, creates a special session ID for them. The server-side storage of this session ID is used to verify user requests made after that point.\n\nThe server generates a fresh session ID and links it to the user's account each time they log in. The user's browser then receives this session ID as a cookie, which is saved on the user's device. With each successive request, the user's browser subsequently sends the session ID back to the server, enabling it to confirm the user's identity and grant access to secured resources.\n\nWeb apps and websites frequently utilize session authentication to provide users access to their accounts without requiring them to enter their passwords again each time they change pages or do other actions. It frequently works in tandem with other security measures like multi-factor authentication and encryption to offer a strong and dependable access control solution.\n\nSession-based authentication has advantages, below are the advantages while using Session-Based authentication.\n• None Security: By asking the user to enter login information for each session, session-based authentication aids in preventing unwanted access to a user's account. As a result, it becomes more challenging for attackers to access a user's account because they would need to be aware of the login information for each session.\n• None User Experience: Since a user only needs to log in once and their session is kept active for a while, session-based authentication can make using the system easier (e.g. 30 minutes or an hour). This indicates that the user can go between pages of the website or application without repeatedly entering their login information.\n• None Scalability: As the server just needs to keep track of active sessions rather than keeping login information for each user, session-based authentication can be readily scaled up to handle huge numbers of users.\n• One of the largest threats to session-based authentication is session hijacking, in which an attacker takes control of a user's session and assumes their identity. Using safeguards like SSL encryption, secure session cookies, and session timeouts can help to mitigate this. ##\n• Session Fixation: This potential flaw in session-based authentication occurs when a user's session ID is established by an attacker before the user logs in, giving the attacker control of the user's session after the user logs in. By creating a fresh session ID after the user logs in, this can be avoided. ##\n• Resource Consumption: Because the server must keep track of all active sessions, session-based authentication can be very resource-intensive. This is because this procedure uses a lot of memory and processing power. By putting in place restrictions like session timeouts and a cap on the number of active sessions per user, this can be lessened.\n\nWebsites and web apps employ cookies authentication as a user authentication technique. After a person logs in to a website, little text files known as cookies are used and kept on their device.\n\nA cookie with a special identifier linked to the user's account is created by the website when a user checks in. The user's device then receives and stores this cookie in their browser. The website may recognize the user and authenticate them without them having to log in again by sending the cookie back to the website on subsequent visits.\n\nAs users do not need to log in repeatedly to access their accounts, cookies authentication can be used to offer a simple and seamless user experience. To avoid jeopardizing the security of the user's account, it is crucial to make sure that the cookies used for authentication are safe and difficult to manipulate. Also, because it could not always offer enough security, cookie authentication might not be appropriate for all websites or applications.\n• None Convenience: Cookies-based authentication makes it easier for users to access the website or application since they don't need to continuously enter their login information after closing their browser or powering off their device.\n• None Scalability: Because the server only needs to keep track of each user's active sessions, cookies-based authentication may be scaled up to handle enormous numbers of users.\n• None Personalization: By collecting users' preferences and behavior on the website or app, cookies-based authentication enables websites or applications to tailor the user experience.\n• None Security Risks: Cross-site scripting (XSS) attacks and session hijacking are two security vulnerabilities that cookies-based authentication may be subject to. Session timeouts, SSL encryption, and the use of secure cookies are among the countermeasures that can be used to lessen this risk.\n• None Cookies-based authentication can present privacy issues because the website or application may be gathering and storing personal information about the user. By putting policies in place like making clear privacy policies and receiving explicit user agreements for data collecting, this can be lessened.\n• None Users who share devices or use public computers might not have the optimal user experience using cookies-based authentication because other users may be able to access their login information if it is kept on the device. Using safeguards like giving users the choice to log out of the session and erasing the cookies when a user signs out can help to mitigate this.\n\nCommon methods for preserving user authentication over numerous requests in web applications include cookies-based authentication and session-based authentication.\n\nCookies-based authentication involves putting authentication data in a cookie that is saved on the user's browser, including their login credentials. To identify the user and preserve their authorized state, the server sends this cookie along with every subsequent request the user makes to the web application.\n\nOn the other hand, session-based authentication includes saving the authentication data on the server side. An exclusive session ID is generated and linked to an account when a user checks in. This session ID is then provided to the server with each subsequent request and saved on the user's browser as a cookie. The user's authentication details can then be looked up by the server using the session ID, which helps to keep the user in an authenticated state.\n\nThe location of the authentication data storage is the primary distinction between cookies-based authentication and session-based authentication. Although session-based authentication stores the authentication data on the server, cookies-based authentication stores it on the user's browser.\n\nIn general, cookies-based authentication is simpler to implement because the server doesn't need to keep track of any session data, which is a benefit. Cookies-based authentication is more susceptible to security threats, like cookie theft and session hijacking, though.\n\nAs the authentication data is retained on the server and inaccessible to the user, session-based authentication is typically thought to be more secure. Nevertheless, because the server must manage session timeouts and expiration as well as session information, session-based authentication might be trickier to implement.\n\nIn the end, the web application's demands and requirements will determine whether to use cookies-based authentication or session-based authentication.\n\nWhich one should I use?\n\nEvery developer is entitled to His/Her opinion on which authentication to use. But my advice is to use session-based authentication because it’s safer. While building your site or application, you may need to go for any of them. Below are the use cases for Session and Cookies authentication.\n\nUse case for Cookies Authentication\n\n When a person registers to a website, cookies authentication is frequently used. The server creates a distinct session ID after verifying the user's credentials once they submit their username and password. The user's browser's cookie then contains the session ID. Each time the user makes a new request to the server, the cookie is sent along with it, enabling the server to recognize the user and deliver customized information. Because it is reasonably simple to implement and is widely supported by web browsers, cookies authentication is a popular option.\n\nUse case for Session Authentication\n\n When a user interacts with a web application that necessitates repeated requests to complete a job, session authentication is frequently used. To place an order on an e-commerce website, for instance, a user may need to add items to their cart, enter shipping details, and enter payment information. The server constructs a session object linked to the user's login credentials to preserve the state of the order across multiple requests. An individual session ID is delivered in a cookie to the user's browser along with this session object, which is saved on the server. The server can obtain the session object and keep track of the order's status because each future request from the user includes the session ID. To enable safe, stateful interactions between the user and the web application, session authentication is frequently combined with cookie authentication.\n• With the HttpOnly and Secure flags set, use secure cookies.\n• Consider the sensitivity of the data and the user's behavior when setting the cookie expiration time.\n• To prevent tampering, encrypt the cookie contents using powerful encryption methods.\n• In stateless apps or other situations where cookies are inappropriate, take into account utilizing a token-based strategy as an alternative to cookies for authentication.\n• Use a private, random session identification and save it on the server.\n• To lessen the chance of a session being hijacked, limit the session's lifespan.\n• Use secure session archiving techniques, such as an encrypted file or database system.\n• To protect the session data while it is in transit, use SSL/TLS encryption.\n• When logging out or after a predetermined amount of inactivity, invalidate the session.\n\nIn both situations, it is crucial to routinely evaluate and audit the authentication procedures to spot and fix any potential security flaws. Users must also be instructed about best practices, such as not disclosing their login information to others and staying away from public computers when conducting sensitive business.\n\nFinally, we’re done with this guide, hope you’ve gained a ton of value! Going through this guide entirely you will learn the basics of Cookies and Sessions authentication, and learn more about authentication itself.\n\nWe also saw a lot of differences between them, you’ll bet me that going through this guide was a waste. Feel free to drop a comment in the comment section, like this guide, and follow me for More.\n\nFull-stack Laravel developer Emmanuel Okolie has years of experience working in the software development sector. By combining software development, writing, and instructing others in what he does, he has developed full-fledged skills. \n\n His stacks include , , , , and other languages and frameworks.\n\nHe creates websites for clients as a freelancer and writes technical guides to show people how to do his work.\n\nIf given the chance, Emmanuel Okolie would enjoy speaking with you. Please go to and follow him on his website, Facebook, Github, LinkedIn, and Twitter."
    },
    {
        "link": "https://stackoverflow.com/questions/17769011/how-does-cookie-based-authentication-work",
        "document": "To expand on Conor's answer and add a little bit more to the discussion...\n\nCan someone give me a step by step description of how cookie based authentication works? I've never done anything involving either authentication or cookies. What does the browser need to do? What does the server need to do? In what order? How do we keep things secure?\n\nBefore anything else, the user has to sign up. The client posts a HTTP request to the server containing their username and password.\n\nThe server receives this request and hashes the password before storing the username and password in your database. This way, if someone gains access to your database they won't see your users' actual passwords.\n\nNow your user logs in. They provide their username/password and again, this is posted as a HTTP request to the server.\n\nThe server looks up the username in the database, hashes the supplied login password, and compares it to the previously hashed password in the database. If it doesn't check out, we may deny them access by sending a 401 status code and ending the request.\n\nIf everything checks out, we're going to create an access token, which uniquely identifies the user's session. Still in the server, we do two things with the access token:\n• Store it in the database associated with that user\n• Attach it to a response cookie to be returned to the client. Be sure to set an expiration date/time to limit the user's session\n\nHenceforth, the cookies will be attached to every request (and response) made between the client and server.\n\nBack on the client side, we are now logged in. Every time the client makes a request for a page that requires authorization (i.e. they need to be logged in), the server obtains the access token from the cookie and checks it against the one in the database associated with that user. If it checks out, access is granted.\n\nThis should get you started. Be sure to clear the cookies upon logout!"
    },
    {
        "link": "https://auth0.com/docs/manage-users/cookies",
        "document": "Cookies are strings of data that a web server sends to the browser. When a browser sends a future request to the web server, it sends the same string to the web server along with its request.\n\nPreviously in Auth0, the cookie attribute options were , , or . If you didn't set the attribute manually, Auth0 would use the default value of . Effective February 2020, Google Chrome v80 changed the way it handles cookies. To that end, Auth0 implemented the following changes to how it handles cookies:\n• None Cookies without the attribute set will be set to .\n• None Cookies with must be secured, otherwise they cannot be saved in the browser's cookie jar. The goal of these changes are to improve security and help mitigate CSRF attacks.\n\nWebsites typically use cookies to ensure that users are recognized when they move between pages, so they don't get asked to log in again every time. Websites also use cookies to remember information users have entered. For example, e-commerce sites use cookies to remember the items placed in a shopping cart.\n\nUsers can choose whether to accept cookies by changing the settings in their browser.\n\nTypically, single-page apps (such as React, Vue, and AngularJS + Node), native mobile apps (such as iOS and Android), and web APIs (written in Node, Ruby, ASP.NET, or a mix of those) benefit most from token-based authentication. Traditional, server-side web applications have traditionally used cookie-based authentication.\n\nCookie-based authentication is implemented by each web platform differently, but at the end of the day, they all end up setting some cookie (tied to a session on the server) which represents the authenticated user. On each request, that cookie is sent and the session is deserialized from some store (in memory if it's a single server or some persistent storage if it's a server farm). We provide SDKs for most of the platforms that will tie into the corresponding authentication subsystem (such as passport on node, IPrincipal on .NET or Java, and so on).\n\nWhen you build an application that requires authentication, you can use sessions and cookies to determine if a user is authenticated each time a request is made. To do this, you can choose to use either stateful or stateless cookies.\n\nStateful cookies contain a pointer to a database record that stores the session information.\n• None Have no limitations on amount of session information stored.\n• None Can easily clear a user's session--just remove the record from the database.\n• None Requires a database to store the session data (but most web applications already have this).\n• None Increases latency because you have to make database calls to read the session (and sometimes write it) for each HTTP request a user makes.\n• None Can be challenging to scale when you have many users and therefore many reads/writes to your database.\n\nStateless cookies are self-contained; they include all session information that you need (for authenticated users, the user ID) and reside on the client. To prevent external tampering, stateless cookies should be encrypted (or at least signed).\n• None Reduces latency because you don't have to call a database.\n• None Must restrict stored session information because cookies are limited in size (max 4KB in most browsers). Although session information may be split between multiple cookies, we don't recommend it.\n• None Makes it difficult to revoke a session, because there is no record in a database you can delete; you’ll need to find other methods to forcefully clear a session.\n• None If using multiple web servers, must make sure all servers have the key to encrypt/decrypt or sign the cookie."
    },
    {
        "link": "https://curity.io/resources/learn/oauth-cookie-best-practices",
        "document": "When using OAuth and OpenID Connect in a browser based application, the two main options are to develop a website or a single page application (SPA). Either of these can use HTTP-only cookies to convey user identities in HTTPS requests, to secure calls from the frontend to the backend.\n\nBrowser based apps send cookies to their own backends, which are in the as the web origin. During more advanced navigation, web apps can contact external sites, and send cookies. One such use case is during OAuth flows, when the browser interacts with the authorization server.\n\nRecent same-site cookie restrictions can lead to application problems in some OAuth flows. This article therefore explains how to avoid them, to ensure good security, reliability and usability. Some best practices are also provided, on both web cookie security and other cross-domain navigation use cases.\n\nCurrent cookie behaviors are explained in the latest updates to the HTTP state management specification, also known as RFC6265. Servers now issue a attribute when issuing cookies, to indicate its desired behavior. The newer cookie properties are also understood by all modern browsers (or user agents).\n\nModern user agents implement the client-side behavior from the specification, but often go beyond it, adding further restrictions. This protects users against unwelcome tracking by external sites. For example, the Safari browser prevents cross-site tracking by default, even for cookies.\n\nThe RFC6265 specification explains rules for classifying requests from user agents as same-site or cross-site. This includes actions to inspect the web origin, the target domain, and ancestor documents for nested browsing contexts. The end result is that cookies issued by external domains are considered third-party.\n\nExact behaviors may vary a little between the main browsers. The main use cases affected are iframes that load content from external domains, or Ajax requests sent from the browser to APIs in external domains.\n\nWhen authenticating a user, your browser based app will run a code flow. The initial request sent in an HTTP redirect will contain parameters similar to these:\n\nThe authorization server validates the initial request, then issues a temporary HTTP-only cookie to the browser, including the property. This cookie must be re-sent by the browser for all subsequent requests in the authentication workflow, so that these requests are secured correctly.\n\nThe authorization server then presents multiple screens. Some of these are HTTP POST requests, such as those to submit a user's password. Finally, once the code flow completes, a single sign-on (SSO) session may be created. This is represented by another cookie, which also uses .\n\nIn your own applications, is not the most secure cookie option. It is the standard behavior for authorization servers, which also implement many other techniques for protecting requests.\n\nBrowser based apps can send code flow requests using any window that supports redirects. Usually the main window is used, but it is also possible to send the request from a popup window or an iframe. These windows have different privacy characteristics, which affects how the user agent sends cookies.\n\nMain windows and popup windows show the user a navigation bar, to indicate the origin the user has been redirected to. For iframes however, the user is not informed which origin is being used, and the window can even be completely hidden. This increases the scope for iframes to be used for malicious purposes.\n\nThe trend in modern browsers such as Safari is therefore to only send OAuth cookies for top level redirects, and to drop them for requests sent from iframes, or when issuing Ajax requests.\n\nBefore discussing OAuth flows that are restricted by same-site cookies, this section summarizes how the backend of a browser based application should issue cookies for its frontend. The cookie issuing can be done by building a website. Alternatively, a backend for frontend (BFF) can perform this task on behalf of a single page application. HTTP-only cookies issued are then shared across all browser tabs.\n\nUsing the latest cookie improvements to secure your browser based apps is now recommended. If you instead use OAuth tokens directly in JavaScript, there are extra attack vectors. The introduction to the token handler pattern provides background on protecting against browser threats.\n\nAlways issue cookies from a backend domain hosted on the same parent domain as the browser based app's origin. Avoid issuing cookies from an unrelated API domain, e.g. , to the web origin of the browser based app, e.g. . This will issue cookies that are considered third party, and user agents are likely to drop them during API requests.\n\nWeb development teams must ensure good browser security. A common option is to follow recommendations published by the Open Web Application Security Project (OWASP). Two of the main threats are cross site request forgery (CSRF) and cross site scripting (XSS). When issuing cookies to browser based apps, the cookie property provides the strongest built-in CSRF protection.\n\nThe OWASP recommendations includes defense in depth measures to protect against CSRF, in addition to using same-site cookies. When developing single page applications, a convenient place to manage these concerns is in an API gateway, in order to keep the security plumbing out of your application code. The token handler design overview describes this approach, with the following end-to-end flow:\n\nIt is possible to issue cookies from an API domain, e.g. , in the same parent site as the web origin, e.g. . The cookies issued then remain same-site and are not impacted by recent browser restrictions. Doing so provides additional options when designing your web deployments, since cookies are only used in API requests. It is therefore possible to design API routes independently to your web domains.\n\nSecure cookies returned to the browser must be HTTP-only, so that they cannot be directly accessed by scripts. They must also use the cookie property, and only be accepted by servers in HTTPS connections.\n\nAvoid storing secure values in the browser, such as in local storage. Instead, use server-side capabilities to protect the confidentiality and integrity of cookies issued. This can include the use of a strong symmetric encryption algorithm, such as AES256-GCM, with a key known only to security components in the backend.\n\nAlso, ensure that cookies are time limited and no longer accepted after a defined period of time. This is automatically ensured when all expiry is based on underlying OAuth tokens. It is recommended to also use non-persistent cookies, so that cookies are removed when the user agent is closed.\n\nCookies containing identity information ultimately act as credentials for accessing your data, so send them to as few endpoints as possible, and take care in server code, when setting domains and paths. Avoid setting cookies on entire top level domains such as .\n\nIn the token handler pattern, cookies used to access data are only sent to the API endpoints that need them, and the cookie used for token refresh is only sent to a particular endpoint of the OAuth Agent.\n\nAvoid implementing your own single sign-on solution that sets cookies for a top level domain such as . Doing so sends SSO cookies to many endpoints that are not entitled to receive them. Always use an authorization server instead, which will set SSO cookies for a separate dedicated domain.\n\nCookies are needed to convey identity, but should not be used as a general mechanism for conveying data, due to size limitations. Current browsers have a limit of 4KB per cookie, and some servers, such as NGINX, have an overall 4KB default limit for the cookie header size. Therefore, use small opaque tokens when storing tokens in cookies. The RFC6265 document provides further information on cookie limits, though some user agents may go beyond this and restrict cookie sizes further.\n\nA number of OAuth flows for web applications use iframes that load content from the authorization server domain, or redirect to it, or send Ajax requests. Some user agents, such as Safari, will refuse to send authorization server cookies in these scenarios, preventing these flows from working. Some affected OAuth flows are summarized in the following sections, along with alternative approaches.\n\nWhen loading a browser based app, it is possible to spin up a hidden iframe and send a code flow request that includes the OpenID Connect prompt=none parameter. This sends the SSO cookie, and if the user is not already authenticated, a response with an parameter is received.\n\nWhen the user agent refuses to send the SSO cookie, this flow no longer works. In most web scenarios, it remains easy to determine if the user is signed in though, by simply making an HTTP request to the app's backend, to check whether a valid HTTP-only cookie is present.\n\nSingle page applications that use access tokens in the browser can silently refresh tokens by running a complete code flow on a hidden iframe, using . This flow can be triggered when an access token expires, or as a background operation, that refreshes the access token before the time in its field.\n\nBrowser based apps that use cookies can handle token refresh in a simpler way. When the app calls an API and receives a response with a 401 HTTP status code, it must call its backend to perform a token refresh, which will rewrite cookies. The app can then retry the API call with the new access token.\n\nCurity provides a simple solution for single page applications called the assisted token flow. This downloads Javascript code from an endpoint of the authorization server, which runs in an secure iframe and performs a code flow, after which tokens can be sent from the browser.\n\nDue to recent browser restrictions however, this flow may fail, if the user agent refuses to send temporary cookies required to secure the authentication workflow. The assisted token flow may still be useful as a simple solution for internal applications, especially if you can control which browsers are used.\n\nThe OpenID Connect specification provides multiple options for OpenID Connect Logout. One such option is session management, which downloads Javascript code from an endpoint of the authorization server. This code then runs in an iframe and frequently polls an endpoint of the authorization server, using the SSO cookie. This enables the app to detect user logout at the authorization server, then ensure that the user is also signed out of the application.\n\nLogout flows may fail if they rely on third-party cookies sent from iframes. Instead, a simpler and more reliable option is to implement RP-initiated logout, using a top level redirect. Multi-tab logout within a web domain can be achieved by setting a property in the user agent's local storage, then listening for storage event changes on other browser windows. See the SPA using token handler for an example.\n\nOnce your web cookie security is implemented securely, and you are using reliable OAuth flows, you may also need to design solutions for multi-application scenarios. This section provides recommendations for securely managing various types of navigation.\n\nIt is possible to share cookies across multiple web applications. Doing so avoids OpenID Connect redirects when users navigate across applications, which can provide a seamless user experience. In many cases though, this is not a good security design.\n\nFor OAuth secured browser based apps, cookies map to OAuth tokens representing privileges. When navigating across business areas, ensure that users of each application run with least privilege. In the following example, a marketing user's cookie maps to a token that includes a scope:\n\nA more secure design is to implement navigation across business areas using single sign-on. Cookies sent to APIs will then map to tokens designed with least privilege, while also providing a good user experience. Use separate backends to achieve this, and ensure that each app sends cookies to APIs via a different domain or path:\n\nCookie sharing is a better choice in micro-frontend architectures. A browser based app for a single business area could be split across teams, to keep code sizes manageable. Multiple micro-frontends could then be deployed, to run at paths such as and . This is easy to enable when API driven cookie issuing is used, since the cookie issuing technology is external to each application, and conflicts are thus avoided.\n\nIt is possible to use or HTML elements as widgets that consume external content, as part of a web mashup solution. With recent browser restrictions this will no longer work reliably in all browsers. If a third-party cookie is used, the user agent may not send it. Some alternative designs, such as using access tokens directly in the browser, result in suboptimal security.\n\nThe preferred option is to instead design such solutions to use a first-party or HTML element, that sends first-party requests to your own backend, so that only same-site cookies are used. Consider using a reverse proxy in your own backend, to route such requests to the third party domain. The reverse proxy can also attach a secure B2B credential, such as an access token or client certificate.\n\nIt is common for organizations to want users to navigate seamlessly from their mobile app to a browser based app. In some cases, single sign-on may not work due to web and mobile SSO cookies being stored in different cookie jars, leading to a double login. Other interoperability solutions are not obvious, when mobile apps use tokens, while web applications use secure cookies.\n\nIn all cases though, browser based apps should continue to use the security recommendations from this article, and use the most secure cookies in mobile browsers. For further techniques on mobile web interoperability, see the nonce authenticator pattern article, and the Mobile Web SSO code example.\n\nBrowsers and servers must protect against many security threats when using cookies, and you must implement up to date cookie best practices in your applications. Recent cookie restrictions also need to be managed, which help to protect privacy, but may also prevent some web design patterns from working. To overcome these barriers, use the following main techniques, to ensure predictable results:\n• Use only the latest and most secure cookies in your browser based apps\n• Use a top level window for OAuth redirects, to ensure that third-party cookies are handled reliably\n• For other secure communication from the browser to third-party domains, route requests via your backend"
    },
    {
        "link": "https://curity.medium.com/how-to-handle-sessions-with-cookies-and-tokens-29fd77eda4c0",
        "document": "An application is usually an orchestration of several components, requiring more advanced session management than a single instance.\n\nA session can be considered as the user’s activity within an application in a given time frame. It starts when the user first interacts with the application and ends when the user stops being active (explicitly or implicitly). A session can be anonymous (unauthenticated) or authenticated, but when we discuss sessions, we usually refer to the user’s authenticated session(s).\n\nAn authenticated session allows an application to identify a user and perform authorization based on the session data, without requiring the user to go through the authentication process repeatedly.\n\nThe user can end a session implicitly, such as by closing the browser or client, or explicitly by initiating a logout. Features like “remember me” commonly prevent the session from being discarded when quitting the browser. An authenticated session can also expire and become invalid.\n\nAn authenticated session starts after the user has successfully authenticated. When using OpenID Connect, the user authenticates to the OpenID Connect provider. After successful authentication, the OpenID Connect provider returns the ID token to the client, which verifies the token and creates a session. The client also receives an access token and maybe even a refresh token used to call downstream APIs. At this stage, there are three sessions involved:\n\nWhenever the user interacts with the application, it will make use of the client session. The session with the OpenID Connect provider can be reused over different clients and applications, providing a single sign-on capability (SSO). These sessions are often represented by cookies.\n\nThe application can use access and refresh tokens to call a downstream API on behalf of the user. Since the API uses access tokens for authorization decisions (which was part of the definition of an authenticated session), the tokens are the building blocks for another session, the API session.\n\nAfter receiving and verifying the ID token, the client can choose to issue a session cookie to keep track of the user. It can store session data from the ID token in memory or server side. For example, a client may want to keep the username, authentication time or authentication method and then discard the ID token.\n\nAnother type of application may just save the ID token in memory to represent the session. If required, the client also stores the access tokens and, optionally, the refresh tokens in the session. Thus, when managing and maintaining a session for an application, keep the following tools in mind:\n\nAlthough SSO is within the realm of the OpenID Connect provider, it can still be used by an application to seamlessly access a user session. If used, the user may not even notice that a client renewed its session. Access tokens, together with refresh tokens, can have a similar effect. When combined with refresh tokens, access tokens can be long lived and valid longer than a client session. Consequently, a client may be able to call an API on behalf of the user despite its own session with the user being expired.\n\nHandling sessions and securing data is pretty straightforward if you think of the application as a single instance of a program. A short-lived access token is used as an API credential, and refresh tokens can be used to retrieve new access tokens without user interaction. When using rolling refresh tokens, a new refresh token is issued together with the access token, which reduces the risks of stolen tokens.\n\nHowever, an application is usually an orchestration of several components. It might include one or more clients, such as web, desktop or mobile, as well as other APIs in the backend and an API gateway or reverse proxy in between.\n\nThe user might interact with several components of the application at the same time. Consequently, there are trade-offs when dealing with session management, and in some use cases, it can be challenging to enable the preferred behaviors.\n\nA simple stateless design can be a good starting point, using short-lived access tokens that will expire shortly and do not need to be revoked. In some applications, it’s OK for a user to log in from different clients (devices) simultaneously, whereas others want to restrict that (think of a paywall). In the latter case, it must be possible to revoke a session at once.\n\nWhen it comes to revoking access tokens, take the token format into account. Opaque tokens using the phantom token flow can be revoked, though the gateway will need to be notified of the revocation event. Meanwhile, JSON Web Tokens (JWTs) are self-contained, so an API will not know if a JWT was revoked since it does not contact the authorization server on every request.\n\nFor an in-depth guide to session management concepts, including advanced techniques such as subscribing to revocation events, see the “Session Management Techniques” solution brief."
    },
    {
        "link": "https://medium.com/codex/sessions-tokens-and-cookies-2fcae32bb7a3",
        "document": "For this week’s article, I had every intention of writing about what OAuth is. However, after spending time researching OAuth, it came to my attention that without any background knowledge of the basics, such as sessions, tokens, and cookies, it would be all too easy to misunderstand what OAuth does. Being able to gather my thoughts in one place and review them so far would also be useful for future reference.\n\nOn that note, this article is tailored for those who are looking for a basic understanding of what sessions, tokens, and cookies are, how they work, and why they exist. Because it’s geared towards beginners or at least those looking for a review on a basic high-level understanding, we’ll try to avoid going too far into the specifics. We’ll still look at some detail though. Note, sessions can be used to define durations on websites, programs, or even computers. For this article, however, we’re only going to look at website sessions, as those will relate more closely to cookies and tokens. So, without further delay, let’s get to researching.\n\nWhen thinking of building out a website, a session is all interactions made by a user within a timeframe. This time could be set to be a certain period before the session…"
    },
    {
        "link": "https://screenconnect.com/blog/session-management-best-practices",
        "document": "When you log on to a web-based application, there is a lot going on behind the scenes of this temporary user/system interaction, or session. Session management refers to the process of preserving the user’s identity, permissions, and other information for the duration of the session.\n\nSince sessions involve private and sensitive information such as passwords and other authentication protocols, it's important that unauthorized parties are not able to see or access that information. Improper access management can result in authorized access to your system and sensitive user data.\n\nIn addition to regulating access, the application should be able to recognize the user each time they log on for a seamless user experience. Adhering to session management best practices helps ensure that sessions run smoothly and securely.\n\nWhen it comes to providing superior remote desktop support, session management is a critical part of keeping your end customers safe and satisfied. Let’s take a closer look at why this is important.\n\nWhy session management matters in IT\n\nWebsites and browsers use HTTP, which is a “stateless” protocol. This means that the server does not retain information about sessions or the user. However, web applications need some way to retrieve information or recognize users from one session to the next. This is where session management comes in.\n\nSession management can be broken down into different steps:\n• Session creation . When a user logs into a web application, the server creates a session. The session receives a unique identifier, generally a session ID or token, which is often stored in a cookie on the user’s browser.\n• Storage . The server stores information related to the session. This can include user-specific settings or items added to a shopping cart.\n• Termination or expiration. Sessions end when the user logs out or is inactive for a period of time.\n• Tracking. Each time the user logs on to the web application, the session ID helps the server identify the user, and it retrieves information related to the user and previous session activity.\n\nSince sessions can be vulnerable to attacks, management is critical to security. If developers don’t pay attention to security trends or best practices, sessions can be vulnerable to a multitude of issues. These include cross-site scripting (XSS) attacks, in which attackers insert malicious scripts into web pages, enabling them to steal session cookies, or brute-force attacks, in which a malicious actor repeatedly tries to guess passwords on authorized user accounts.\n\nThese are just a few of the possible liabilities involved if there is a lack of strong session management. Aside from security concerns, inadequate session management can lead to user frustration if they experience frequent logouts or if their information and preferences aren’t saved across sessions.\n\nImplementing robust session management best practices can help prevent or mitigate security risks and support a positive user experience. These are the top session management best practices to follow.\n\nTo maintain the security and integrity of user sessions, session IDs should be configured in a way that makes them hard to guess, predict, or decrypt.\n• None Use strong randomization techniques and make sure that IDs are of sufficient length (at least 128 bits/16 bytes).\n• None Avoid predictable patterns, such as sequential numbers or IDs based on timestamps or other easily identifiable values.\n• None Make sure session IDs are unique across all applications or services.\n\nYou can use tools like a cryptographically secure pseudo-random number generator (CSPRNG) to generate unique session IDs and implement logging mechanisms to track their usage. These practices will help make sure that session IDs are generated and configured in a way that is secure and unpredictable to prevent vulnerabilities.\n\nCookies are small pieces of data stored on users’ browsers. They help servers track user interactions with a web application, so proper attribution is critical to session security and user experience.\n• None Use HttpOnly and Secure Flags. This reduces the risk of XSS attacks and ensures the cookie is only sent over secure HTTPS connections.\n• None Configure cookies to be valid for shorter periods. This limits the ability of attackers to reuse stolen cookies.\n• None Limit the scope of cookies to the specific domain and subdomains that require access.\n• None Make sure cookies are invalidated when the session ends.\n\nAppropriate access controls in session management ensure that users have the correct level of access to the resources and functionalities in a web application. A few best practices to follow when implementing them include:\n• None Use role-based access control (RBAC), in which roles assigned to users dictate what actions and resources they can access.\n• None Define permissions at a highly granular level to prevent providing users with extraneous access.\n• None Consider implementing dynamic access controls, which restrict access to specific resources based on factors such as user location, role, and even the time of day.\n• None Regularly review permissions and adjust them for users who have changed roles or no longer require access to certain areas or functionalities.\n\nWhen permissions change due to user roles being updated or their access levels restricted or expanded, users should retain access to just the resources and features they are authorized to use on the web application. When renewing or regenerating session IDs due to permission changes, make sure you follow these best practices.\n• None Have mechanisms in place to detect permissions changes. You should determine events or triggers that indicate these changes and develop logic for renewal and regeneration.\n• None Invalidate the existing session and force the user to reauthenticate for access.\n• None Generate a new, unique session ID for the user that is associated with their updated permissions.\n• None Copy over any relevant session data, user settings, and authentication information to the new session.\n• None Send the new session ID to the user's browser as a cookie and update the session state on the server.\n• None Notify the user about their need to reauthenticate due to the permissions change.\n\nEncrypting web sessions helps maintain data confidentiality, while recording supports accountability and auditing when troubleshooting or investigating incidents during sessions.\n\nFor encrypting, it’s important to encrypt data while being transmitted between the user’s browser and the web server as well as to prepare it for storage. You can obtain a Transport Layer Security (TLS) / Secure Sockets Layer (SSL) certificate from a trusted authority to enable encrypted communication.\n\nRecording should log session activities such as login attempts and other actions. For potentially suspicious actions like changing settings or other information, make sure you record the user’s IP address and a timestamp. Ensure that session logs are encrypted and stored securely. This will provide an audit trail for additional monitoring or an investigation.\n\nFinally, make sure you abide by any regulatory requirements (such as GDPR or HIPAA) that mandate specific requirements for storing session data.\n\nIn session management, network segmentation can support improved security by restricting communication between segments. This can be beneficial if one segment is attacked or compromised. The power to define different rules and policies for each segment also allows for more control over access.\n\nTo segment a network for optimal session management, keep these practices in mind:\n• None Classify data and assets according to their sensitivity, importance, and regulatory requirements, then ensure the network architecture reflects those factors.\n• None Isolate administrative functions and other sensitive systems and data in separate segments that have stricter access controls and strong authentication.\n• None to ensure users can access only the segments and functionalities they are authorized for. This limits the entire network from being exposed to potential attacks or breaches.\n• None Implement strong mechanisms for monitoring and logging traffic for suspicious behaviors during sessions.\n\nEffective session management ensures that the session is properly terminated when the user logs off or the server ends it due to expiration. This reduces the risk of unauthorized access, breaches, and data exposure.\n\nWhether initiated by the user or the server, these steps should be taken:\n• None The server removes the session data associated with the user's session or marks it as invalid.\n• None The cookie should be set to expire immediately after termination or shortly afterward. This prevents the browser from sending the now-invalid session ID in subsequent requests.\n• None The server should record details about the logoff, such as the time and date.\n• None The application’s user interface should update to show that the user is logged out, such as by redirecting to a landing page, showing a message indicating they have logged off, or changing the “log out” button to “log in.”\n\nAudit logs are essential for detecting and investigating unauthorized access and improving session management security. To ensure your logging is useful, secure, and accurate, implement these practices:\n• None Clearly define what events and activities during sessions need to be logged.\n• None Include critical relevant details such as the user's identity, timestamp, session ID, IP address, the action that took place, and what resource they accessed.\n• None When possible, prevent audit logs from being modified or deleted. If not, protect them from tampering by implementing measures such as digital signatures, checksums, or hashing.\n\nUsers are valuable resources to help ensure strong session management. Make sure they know how to use the web applications safely and protect their accounts with these tips:\n• None Provide clear and accessible documentation that explains how to log on and log off correctly, how to keep their authorization credentials safe, and how to recognize attempts at infiltrating their sessions.\n• None Remind them to uncheck the “remember me” option and completely log out of web applications when they are using a device that is not their own, such as at a library.\n• None Encourage users to report suspicious activity or attempts to gain access to credentials or other information.\n\nIf you use a software solution to assist with session management, providing ample support will help ensure your teams leverage it effectively and to its fullest extent. Here are some ways you can encourage consistency across users to deliver a great customer experience:\n• None Provide documentation that explains session management best practices, concepts, configuration options, and security considerations.\n• None Create a knowledge base that covers a wide range of session management topics and frequently asked questions.\n• None Share information about updates, improvements, and new features in the solution.\n• None Encourage collaboration between support and development teams to improve session management and the user experience.\n\nWith today’s increasingly dispersed workforce, it is more critical than ever to arm IT techs with the tools they need to quickly resolve remote support and access requests. This is why leading organizations leverage remote desktop software to resolve customer support needs while maintaining secure and controlled access across their environment.\n\nConnectWise ScreenConnect enables technicians to provide secure on-demand remote desktop and mobile support, helping end users get back to work faster. Total browser and OS compatibility, flexible configuration and customization options, and world-class security ensure seamless session management, every time.\n\nExperience ScreenConnect for yourself by activating your free 14-day trial, no credit card required, today."
    },
    {
        "link": "https://workos.com/blog/session-management-best-practices",
        "document": "If you think you’re done when you authenticate a user, think again. Proper session management can make or break your app, both security and UX-wise. We gathered some industry best practices to help you get started.\n\nSecure session management is crucial for keeping web applications and their users safe. Otherwise, you are exposed to security vulnerabilities, like unauthorized access, data breaches, and account hijacking. To avoid such risks and maintain a secure environment, web developers and system administrators should be careful and avoid common pitfalls.\n\nIn this article, we will explore some common best practices for session management and see how you can implement each using Node or Python.\n\nA user session refers to the period of time during which a user interacts with your app. It starts when the user logs in or opens the application and ends when they log out, close the app, or become inactive for a certain amount of time.\n\nUser sessions help track user activity, improve the user experience, and enable features like personalized content, user authentication, or maintaining shopping carts. Each session receives a unique identifier, generally a session ID or token, which is often stored in a cookie on the user’s browser.\n\nThe session management flow looks like this:\n• The app creates a unique session identifier or token for the user. This identifier is stored in a cookie and contains information about the user and the session. The session expires after a certain amount of time.\n• The user can keep using the app without having to authenticate again until they log out or become inactive for a certain amount of time (i.e., the session expires).\n\nSounds simple enough, but there are many pitfalls ahead. Let’s see some best practices you should remember when implementing session management.\n\nOne of the foundational elements of session management is the session identifier (ID), which uniquely identifies a user's session. The session ID should be:\n• Random and unpredictable: Using predictable or sequential session IDs makes it easier for attackers to guess or brute-force session identifiers, compromising the session's security. Always generate session IDs using a secure, random algorithm with sufficient entropy (e.g., 128-bit or 256-bit randomness).\n• Long and unique: A shorter or overly simplistic session ID increases the risk of a collision or prediction. Ensuring each session ID is long enough minimizes this risk.\n\nHow to generate a secure session ID with Python:\n• The module is explicitly designed for cryptographic use and produces a very strong random number suitable for security-sensitive applications like session IDs or passwords.\n• You can easily customize the character set (letters, digits, symbols) used in the session ID by modifying the string.\n\nHow to generate a secure session ID with Node:\n• : This function generates a specified number of cryptographically secure random bytes.\n• : Converts the random bytes into a hexadecimal string. The default is 32 bytes, which gives you a 64-character hexadecimal string.\n• Length: The default length is 32 bytes, but you can change it if you want a longer or shorter session ID.\n\nSession cookies are the most common way to store session IDs on the client side. But you must be careful when sending them from one service to another. To prevent interception or manipulation of session cookies:\n• Set the flag: This ensures the cookie is only sent over secure HTTPS connections, preventing interception over unencrypted HTTP.\n• Set the flag: This prevents client-side JavaScript from accessing the session cookie, reducing the risk of XSS (Cross-Site Scripting) attacks. cookies can only be accessed by the backend server.\n• Use the attribute: This prevents cross-site request forgery (CSRF) attacks by ensuring the cookie is only sent to the domain that set it. You have the following options:\n• Strict: Cookies are only sent in same-site requests, preventing cross-site request forgery (CSRF).\n• Lax: Cookies are sent in same-site and some cross-site requests, offering a balance between security and user experience.\n• None: Cookies are sent with all requests, requiring additional security measures like and .\n• Expires/Max-Age: These attributes define how long a cookie will be valid (unless explicitly destroyed due to logout). When set, the cookie will remain persistently stored on the browser until the specified expiration time or max-age.\n\nHow to create a secure cookie with Python (Flask):\n\nHow to create a secure cookie with Node (Express):\n\nThis is what that response will look like:\n\nTo mitigate the risk of session hijacking or unauthorized access, it’s important to implement appropriate session expiration and timeout mechanisms:\n• Set short expiration times: Sessions should not last indefinitely. Sessions should expire after a reasonable period of inactivity (e.g., 15-30 minutes). If a user is inactive for this period, they should be logged out automatically.\n• Implement sliding expiry: If the user is active during the session, extend the expiration time. This helps to prevent session expiration during legitimate use while reducing risks for inactive users.\n• Log out after a fixed period: Even if a session is active, it should eventually expire after a defined period (e.g., 24 hours), requiring the user to log in again.\n\nThere is no silver bullet here, it depends on whether the app is high or low risk. Banks will log you out after 5 minutes of inactivity while other low-risk apps will leave you logged in for hours (or days). You should evaluate your own needs while trying to balance user experience and security.\n\nThe OWASP Session Management Cheat Sheet advises: “Both the idle and absolute timeout values are highly dependent on how critical the web application and its data are. Common idle timeouts ranges are 2-5 minutes for high-value applications and 15-30 minutes for low risk applications. Absolute timeouts depend on how long a user usually uses the application. If the application is intended to be used by an office worker for a full day, an appropriate absolute timeout range could be between 4 and 8 hours.”\n\nAlways encrypt session traffic with HTTPS. This ensures data in transit (including session IDs) is protected from man-in-the-middle attacks and eavesdroppers.\n\nTo prevent session fixation attacks, session IDs should be regenerated after the user successfully logs in or logs out:\n• Regenerate session ID after login: When a user logs in, their session ID should be regenerated to prevent attackers from hijacking or predicting a session ID.\n• Regenerate session ID after privilege elevation: If a user changes their privileges (e.g., admin access), regenerate their session ID to protect against privilege escalation attacks.\n\nEnsure that a session is fully terminated when a user logs out. This includes clearing session data and invalidating the session ID.Example using Python and Flask:\n\nExample using Node and Express:\n• This route clears the session cookie by calling . It tells the browser to delete the cookie by setting it to expire immediately.\n• It also uses the same cookie attributes ( , , and ) to ensure the cookie is properly cleared.\n• Once the cookie is cleared, the user is logged out.\n\nAvoid storing sensitive session data like passwords, personal information, or tokens directly within the session. Instead:\n• Store minimal data: Store only a session ID or reference to the session data (e.g., user ID, session state) and fetch other information from the database or another secure source.\n• Use server-side session storage: For higher security, store session data on the server-side, especially for sensitive information, and avoid relying solely on client-side storage (like cookies or local storage).\n\nContinuously monitor and log session activity to detect suspicious or unusual patterns:\n• Track login locations: Log the IP address and user-agent (browser/device information) for each session to detect anomalies such as logins from different geographical locations in a short period.\n• Alert on abnormal behavior: Set up alerts for suspicious activities such as multiple failed login attempts or rapid session creation and destruction.\n\nTools like WorkOS Radar can help detect bots, impossible travel, brute-force attacks, and more and either automatically block them or alert the security team.\n\nIf your application uses a load-balancing system, a user's requests might be distributed across different servers, which could cause issues like losing session data (e.g., user preferences or shopping cart items). Ensure that session management works seamlessly across different servers using one of the following options:\n• Sticky sessions: The load balancer routes the user's requests to the same server, often by tracking the session through a cookie or session ID. This helps maintain continuity and ensures a smoother user experience.\n• Shared session stores: Use shared session stores, like Redis or Memcached, so users can be routed to any server without losing their session data. This allows for better load balancing and scalability since requests can be routed to any server.\n• Use JSON Web Tokens (JWT): JWTs are designed to be stateless. This means that the session data is stored in the token itself and doesn't require a centralized session store like Redis. Each JWT contains all the information the server needs, such as user authentication data, permissions, and other claims, and it is signed so it can be trusted without needing to reference a database. It should be noted that you might still have to use JWT and a shared session store like Redis. In this case, Redis can be used to store extra session-related data (like shopping cart items), while JWTs are used for authentication.\n\nIf you use JWTs, you must always validate them before use. This includes:\n• Parse the JWT to extract the header, payload, and signature.\n• Verify the signature using the secret key or public key.\n• Check the expiration time ( ) and the not-before time ( ) claims to ensure the JWT is valid.\n• Verify the issuer ( ) claim to ensure the JWT was issued by a trusted party.\n• Verify the audience ( ) claim to ensure the JWT is intended for the correct recipient.\n\nWhile not directly related to session management, multi-factor authentication (MFA) strengthens session security significantly by adding an extra layer of verification.\n\nWhen users want to perform sensitive actions like changing their password or accessing sensitive information, ask them to provide a second form of authentication (e.g., SMS code, authenticator app). If your app is high-risk, consider requiring MFA as part of the initial login process.\n\nKeeping users safe online is a constant battle between security and usability. Use these tips to improve the user experience with regard to session management.\n\nInstead of abruptly logging out users, inform them in advance that their session is about to expire and give them an option to extend it (similar to how airlines warn you when you are in the process of booking tickets and have been idle for a while). This ensures users don’t lose their progress unexpectedly.\n\nImplementing these session management best practices is key to building secure, reliable web applications. By generating robust session IDs, mandating HTTPS, configuring cookies correctly, enforcing timeouts, rotating session IDs, and diligently monitoring user sessions, you can maintain a safe environment and deliver a seamless user experience."
    },
    {
        "link": "https://stytch.com/blog/session-management-best-practices",
        "document": "Sessions are used to uniquely identify users, determine access privileges, and maintain their login state within an application. This relieves authenticated users from having to repeatedly enter their login credentials, ensuring a seamless and personalized user experience.\n\nIn monolithic applications, these user sessions are stored in server memory or a centralized session store/database. As such, whenever a user successfully authenticates their identity, the server generates a unique session on the server-side and sends the associated session ID to the client. This session ID must then be included in all subsequent client requests made to the server, allowing the server to associate each request with the corresponding user session.\n\nHowever, in stateless microservices architectures, where multiple services are running concurrently on separate servers or containers, session management becomes more complicated than in simple monolithic web apps running on a single server.\n\nThis is why microservices leverage token-based authorization mechanisms like JSON Web Tokens (JWTs) to manage session data. These self-contained tokens can be used to manage user privileges and session information across multiple servers and services, without having to make frequent requests to a central server or session store.\n\nIn this article, we’ll explore how web developers can effectively create and manage user sessions on the client and server-side, as well as in typical monolithic and microservices environments, without compromising user experience, security, performance, and scalability of the system. We’ll cover five key session management best practices, and common session vulnerabilities, and show you how Stytch makes it easy for web developers to manage both traditional sessions and session JWTs.\n\nIn stateful (sessions-based) session management, the server maintains user information and state throughout multiple requests within a single session. As we mentioned before now, user data and session information are typically stored on the server, often in a database or memory. This unique session ID is exchanged between the client (browser) and the server with each request, either via cookies or by embedding it in the request URL (though the latter is considered less secure).\n\nThroughout a user’s interaction with an application, session data remains on the server, persisting even if the user closes the browser and returns later, as long as the session is valid. However, once the session expires, the associated session information is invalidated by the server. Active sessions can be terminated due to user inactivity, security-related timeouts, or user actions, such as logging out.\n\nStateful session management is generally considered more secure against client-side attacks like cross-site scripting (XSS), since sensitive session information resides on the server, making it less susceptible to manipulation on the frontend. However, session data can also be stored on the client-side, typically using cookies.\n\nCookies are small text files sent by the server and stored in the user’s browser. They are then included in subsequent requests, allowing the server to identify the user and their session. However, cookies can also be vulnerable to attacks like session hijacking, XSS, and cross-site request forgery (CSRF) if not attributed properly or stored in insecure web storage locations.\n\nIn stateless (token-based) session management, the server doesn’t store session information between requests. Each client request is independent, containing all the necessary session and auth information, usually in a compact JSON Web Token (JWT).\n\nFor example, when a user logs into a web application that leverages tokens, the server authenticates their credentials and creates a signed JWT containing the user’s session information, known as claims. This signed JWT (also referred to as access token) is then sent back to the user’s browser, where it’s usually stored in a secure cookie for subsequent client requests.\n\nHowever, there are more secure ways to handle JWTs. A safer method is to store access tokens in memory rather than in local storage or cookies, but this comes with a caveat. If a user refreshes the page or closes the browser tab/window, all data stored in memory, including the access token, will be erased.\n\nThis is why web applications use a combination of access tokens and refresh tokens. To maintain seamless user experiences without compromising security, refresh tokens are securely stored in client-side cookies, while access tokens are retained on the server. Before an access token expires, the refresh token is used to silently refresh it, preventing any noticeable disruptions to the user.\n\nIn monoliths, session data is typically stored in a centralized session store, such as a database or an in-memory cache, which is accessible by all components of the application. However, in a microservice architecture, each service is designed to be independent and self-contained, making it challenging to share session data across multiple services.\n\nIn a monolithic app, authentication and authorization are handled by a single module or middleware, which can grant or deny access to various parts of the application based on the user’s session data. However, in a microservice architecture, where each service is running on separate servers or containers and may have its own auth framework, this approach isn’t practical, as services can’t communicate or exchange data locally.\n\nTo address this challenge, microservices architectures often rely heavily on token-based authentication mechanisms, such as JSON Web Tokens (JWTs). JWTs are self-contained tokens that can encapsulate the necessary user information and can be propagated across multiple services, eliminating the need for back-and-forth requests to a centralized session store.\n\nNonetheless, managing token lifecycles, including issuance, revocation, and ensuring consistent validation across all services can be complex. This often requires a central authorization server that can be shared by multiple services or instances.\n\nWhile there are some drawbacks to this kind of centralized authorization, such as the increased complexity and risk of a single point of failure, the performance and scalability benefits often outweigh these risks.\n\nMany microservices architectures use a sidecar decoupling pattern in which supporting functions of the main service, such as session management and auth, are provided by sidecars attached to this main service.\n\nAuth sidecars are co-located with their associated microservice, sharing the same server, pod, or container. This ensures that any failures or restarts are isolated to that service. This approach shifts authorization responsibilities from the main service to the auth sidecars, which communicate directly with the centralized auth service.\n\nAside: on Stytch, session tokens and session JWTs are completely interoperable, and both are returned on every API response so that developers can use whichever option is best for their application. Explore our docs to learn more.\n\nAn attacker can unlawfully gain control over a legitimate user’s active session by stealing their session identifier or token after the user has successfully logged in.\n\nIn situations where the attacker and the victim share the same network, such as a public Wi-Fi connection, the attacker can eavesdrop on unencrypted network traffic. This makes it possible for the attacker to intercept communication between the victim’s device (client) and the targeted server, potentially compromising the integrity and confidentiality of the session ID or token. Armed with this stolen token, the attacker can then impersonate the legitimate user and perform actions on their behalf, effectively hijacking their session.\n\nFurthermore, storing session IDs or tokens in local storage or insecure cookies on the client-side can also make applications vulnerable to attackers. In such a scenario, a cross-site scripting (XSS) attack can introduce malicious code that extracts the user’s session information from the frontend and transmits it to the attacker.\n\nTo prevent session hijacking, always employ secure communication protocols like HTTPS and TLS/SSL to encrypt data transmission between clients and servers. Furthermore, to mitigate XSS attacks, always implement secure cookie flags, enforce automated session timeouts and expiration, and mandate user re-authentication when users perform sensitive actions within the app.\n\nSession fixation vulnerabilities occur when web applications fail to properly generate or validate session IDs before authorizing access. Attackers can exploit these vulnerabilities by tricking the victim into adopting a predetermined identifier, often through phishing or malicious links. Once a user interacts with a link or email containing this attacker-determined session ID, the attacker can impersonate the user, control their account, perform actions on their behalf, or gain access to sensitive information.\n\nTo protect against session fixation, web applications leverage strong cryptographic algorithms and entropy sources to generate random and unpredictable session IDs. This significantly reduces the chances of an attacker successfully guessing or predicting a valid session ID, even if they have access to an old one.\n\nThe most secure web applications always enforce strict server-side validation for each request. This ensures that session IDs are legitimate and linked to the correct user before granting access. Furthermore, implementing short session durations that automatically expire when the user is inactive effectively minimizes potential vulnerabilities and exposure, even in the event of a session compromise.\n\nIn man-in-the-middle attacks, attackers use an intermediate server to sniff and intercept HTTP requests between a user’s device (client) and a web server. This allows attackers to potentially steal sensitive data like passwords, credit card information, or even session IDs.\n\nTo ensure secure data transmission and prevent MitM attacks, it’s important to use HTTPS connections for the entire web session. HTTPS encrypts all communication between a user’s device and the server, making it unreadable to attackers, even if they intercept it.\n\nCross-site request forgery (CSRF) exploits a user’s existing login session to trick their browser into performing unauthorized actions. Unlike session hijacking, CSRF attackers don’t steal session IDs or tokens. Instead, they create malicious links, forms, or scripts that a user may interact with on a seemingly legitimate website. The browser unknowingly leverages the user’s active session to run these malicious scripts and execute the attacker’s commands, which could include stealing funds, changing account settings, or even sending emails, all without the user’s knowledge or consent.\n\nNonetheless, web applications can implement several security measures to protect against CSRF attacks. One approach is to use anti-CSRF tokens. These are unique, unpredictable values that are embedded within forms and validated on the server-side. This ensures that the submitted form originates from a legitimate user and not an attacker.\n\nAdditionally, when using cookies, setting the SameSite attribute as either ‘Strict’ or ‘Lax’ can further mitigate CSRF risks by restricting the context in which cookies are sent during cross-origin requests. This makes it harder for attackers to intercept the user’s cookies (which might contain a session ID) to perform unauthorized actions on the targeted website.\n\nNever store sensitive authorization data, such as session IDs, tokens (JWTs), user credentials, or roles and permissions, on the client-side (e.g., in browser storage or insecure cookies). This information should always be stored and managed on the server-side, where it can be properly secured and protected from potential client-side vulnerabilities and unauthorized access.\n\nWhen using cookies for session management, it’s important to set the appropriate flags and attributes to enhance their security. The following are some of the most important flags and attributes to consider:\n• HttpOnly: This flag instructs the browser to prevent client-side scripts, including malicious scripts from accessing the cookie. This can help protect against cross-site scripting (XSS) attacks.\n• Secure: This flag ensures that the cookie is only transmitted over secure (HTTPS) connections. This helps to protect against eavesdropping and man-in-the-middle attacks, that could potentially capture session IDs from insecure browser traffic.\n• SameSite: This attribute restricts cross-site cookie sharing, thereby mitigating the risk of CSRF attacks. To prevent unauthorized cross-site requests from accessing or modifying session cookies, you can set the SameSite cookie attribute to “Strict” or “Lax” based on your application’s requirements.\n• Expires/Max-Age: These attributes define the lifespan of a cookie. When set, the cookie will remain persistently stored on the browser until the specified expiration time or max age.\n• Domain: This attribute instructs the browser to only send the cookie to a specific domain and its subdomains. It prevents cookies from being sent to unintended destinations.\n• Path: This attribute instructs the browser to only send the cookie to a specific directory or subdirectory within a domain.\n\nTo mitigate the risk of unauthorized access and brute-force attacks, it’s important to use cryptographically secure random number generators (CSRNGs) or strong cryptographic algorithms with sufficient entropy to generate highly secure session IDs. These algorithms are designed to produce truly random and unpredictable output, reducing the likelihood of collisions or patterns that could be exploited by attackers.\n\nAlways generate session IDs with a length of at least 128 bits (or 32 characters for Base64-encoded IDs). Using longer session IDs significantly increases the complexity and computational effort required for brute-force attacks, making them practically infeasible for attackers to guess or deduce. Avoid using predictable patterns or sequential numbering to generate session IDs, as these weaknesses can be easily exploited by attackers.\n\nAlways provide users with a clear and accessible way to manually terminate their sessions, such as a “Logout” button or link in a prominent location on the user interface. This ensures that users can securely end their sessions when they are finished, preventing unauthorized access to their accounts or data.\n\nUpon logging out, the application must invalidate the user’s session, clear any session-related data stored on the server or client-side, and redirect the user to a secure location, such as the login page or a dedicated logged-out page.\n\nTo protect user accounts and data from unauthorized access, it’s important to implement automatic session expiration and timeouts.\n\nIn addition to manual session expiration, setting reasonable session timeouts based on the sensitivity of the application and the expected usage patterns can help mitigate the risk of session hijacking. After a predetermined period of inactivity, the application should automatically invalidate the current session and prompt the user to re-authenticate, thereby preventing the extended and/or expired session from being exploited.\n\nOn Stytch, user sessions are identified by session tokens and JSON Web Tokens (JWTs) that are authenticated on each request. To initiate a session, developers can call the authenticate magic link or authenticate OTP endpoint, specifying the desired session_duration_minutes to set the session’s lifespan.\n\nStytch returns both a session_token, which is a static value that remains valid for the duration of a session, and a session_jwt that has a shorter expiration time of 5 minutes. However, when JWTs expire, you can pass them to our session API to retrieve newer JWTs. Our servers ensure that the underlying session is still active before issuing a new JWT.\n\nTo extend a session’s validity, you can call the authenticate session endpoint with the desired session_duration_minutes parameter to set a new expiration time without modifying the session_token or session_jwt. On the other hand, you can also revoke an active session by passing the corresponding session ID or JWT to the revoke session endpoint.\n\nTo get started, check out our documentation and sign up for a developer account. If you have any questions, please don’t hesitate to contact us at support@stytch.com."
    }
]