[
    {
        "link": "https://medium.com/@shaliamekh/clean-architecture-with-python-d62712fd8d4f",
        "document": "Creating applications that are not only functional but also maintainable and scalable is paramount. Clean Architecture, conceptualized by Robert C. Martin (Uncle Bob), promotes a clear distinction between business logic and implementation details. This approach allows developers to focus on the essence of their applications without being tied to specific frameworks or external dependencies.\n\nFor this step-by-step tutorial, we’ll dive into the domain of auction management, and implement a piece of functionality that an auction management system might have. We’ll explore how TDD goes along with developing a Clean Architecture app. Additionally, we’ll try to integrate FastAPI, one of the most popular Python web frameworks, into the Clean Architecture paradigm.\n\nGet down to coding\n\nThe code used in this tutorial can be found in this github repository.\n\nLet’s start with the central component of the architecture where the core business objects reside — the domain. We’ll define Item, Bid, and Auction entities.\n\nWithin the Auction entity, we also use the Price object, which I’ve defined as a value object. How is a value object different from an entity? Value objects do not have unique identities. They are immutable over time: once created, their state can not be changed. In our example, if an auction price changes, we simply create a new one. Other examples of value objects include addresses, phone numbers, colors, or temperatures.\n\nFor now, we’ll consider accepting payments in only one currency.\n\nNow that we’ve defined the basic data structures our app will operate on, we can begin writing our business logic — the use cases.\n\nHere we may identify multiple scenarios, such as creating an item, creating an auction, submitting a bid for an existing auction, and so on. For the purpose of this tutorial, let’s focus on the latter.\n\nSubmitting a bid would involve the following logic:\n• Check if the auction the bid is submitted to exists.\n• Check if the auction is active.\n• Verify if the bid price is higher than the auction’s starting price or the highest bid.\n• Save the bid if all the conditions listed above are met.\n\nAt this point, let’s think of the adapters that we might need here, define the use case class signature, and proceed with TDD.\n\nWithin the use case, we’ll need to retrieve the auction by its identifier and save the bid if it meets our logic, regardless of where and how these entities are stored. To abstract the data access logic from the core business logic, we define as an interface that will be implemented and tested separately.\n\nBefore creating our first test, we also need to mock this layer. For this purpose, in-memory implementations are typically used: during testing, we store our entities in a simple Python list but interact with them using the same interface.\n\nNow, let’s proceed with our first unit test. We’ll be using pytest and pytest-asyncio.\n\nTo inject the required dependencies (in our case, it’s only the auction repository), we’ll use pytest fixtures.\n\nIn this first test, we expect that if a bid is submitted for an auction that does not exist (our in-memory storage is empty at this point), the corresponding exception will be raised.\n\nIf you attempt to run the test, it will obviously fail, as we have not yet implemented anything within the use case. Let’s do this.\n\nNow, the test should run successfully.\n\nBy following this step-by-step development pattern (TDD), we build and test the rest of the logic described above for this particular use case.\n\nHere is our final use case.\n\nLet’s recap what we have so far. We’ve implemented the core business logic of the app and thoroughly tested it while setting aside the concerns of storing (SQL or NoSQL database, blob storage, etc.) and accepting (HTTP, RPC, message brokers, etc) data.\n\nAt this point the project structure looks like this:\n\nWe will discuss the pros and cons of this structure once we have completed the data access layer (our database storage adapter) and the drivers layer (the web framework).\n\nIt’s time to develop a real implementation of our auction repository. To avoid managing the database schema and migration, I’ll opt for MongoDB and will store all the entities in one embedded document. As we are building an asynchronous app, we’ll need the motor library. Let’s install it and define the class signature for our adapter. Remember, it should implement the interface we already created.\n\nNow lets run MongoDB docker container and get down to writing our first integration tests.\n\nOf course we follow the same step-by-step TDD approach: one test per one peace of logic. Thus, we do not miss anything. For the purpose of testing, I created one more method within our repository to add auctions.\n\nHere is what we eventually get.\n\nAs we’re not using any kind of ORM, we’ll need to define some methods for mapping our entities and MongoDB documents back and forth. I’ve left this behind the scene, as it is not the focus of this tutorial.\n\nNow that we’ve completed our MongoDB implementation of the auction adapter, we can appreciate how easy it will be to switch to another technology: PostgreSQL, AWS S3 bucket, or anything else. We simply create another adapter, test it, and inject it into our use case without altering the core business logic.\n\nNext, let’s consider an approach for accepting incoming data for a new bid. Implementing REST API built with FastAPI seems like a viable solution for our requirements. Powered by the Starlette, it handles every single request as an asynchronous task. This will allow us to benefit from the async app we already have. Let’s dive into it.\n\nFor now, I’ve placed all the framework-related code in a single file. However, as the service grows, maintaining it in this manner will become challenging. Therefore, you might want to check how I've structured it into multiple files in the project repository.\n\nYou might wonder why I opted for such a deeply nested FastAPI dependencies structure, with a separate function for every layer. The reason is flexibility. Let’s imagine we have an adapter that makes calls to a very expensive external API, and we want to call it only in production. With this approach, we can inject different implementations of the adapter depending on the environment:\n\nLet’s get back to our example. We also should not forget to handle all the custom exceptions that may be raised within our app. Again, tests come first.\n\nNow you can run the server and call our endpoint.\n\nYou should get a 404 response indicating that this auction doesn’t exist yet. So go to the mongo shell and create it.\n\nIf you run the curl command again, you should receive a 204 response, and the auction bids will include the one we have just submitted.\n\nNow, it would be beneficial to write some end-to-end tests. I usually use Postman for this purpose. However, let’s leave this outside the scope of this tutorial.\n\nHere is the project structure we have so far, with FastAPI code divided into multiple modules and tests created for the endpoint:\n\nAs our demo application is completed, I want to highlight some points related to the integration of Clean Architecture and FastAPI. If you already have experience with Clean Architecture, you should know that it usually involves controllers and presenters responsible for the validation and serialization of incoming and outgoing data. In out setup this functionality is delegated to FastAPI (Pydantic specifically). For resolving the dependencies, we use FastAPI’s built-in dependency injection mechanism. And you’ll probably agree that this is what we love FastAPI for.\n\nIn my opinion, it’s a reasonable trade-off. But we have to keep in mind that when switching to some other driver, we might run into problems. We’ll probably still be able to use Pydantic for data validation and serialization. But we’ll need to come up with some other solution for resolving dependencies.\n\nOne more time, keep it clean!\n\nI’ve encountered numerous examples of “clean architecture” on Python when use cases included framework dependencies (like HTTPException or even FastAPI Depends object).\n\nWhy is it important to keep it clean? Let me illustrate this with a real-life scenario. Recently, we run into a situation where the volume of data we needed to process surged. Having this and some other reasons in mind we decided to switch from HTTP to a message broker.\n\nHaving framework dependencies within our use case would require to fully rebuild the use case containing a lot of code and update all the tests. However, with the architecture I advocate in this tutorial, we were worried about nothing but the consumer.\n\nTo draw the bottom line, let’s consider all the pros and cons that this project setup and Clean Architecture in general bring into place.\n\nWhy is this cool?\n• We are not dependent on any third-party library. None of the frameworks impose their way of building the app;\n• Our app is decoupled; its parts are interchangeable without the need to fully rebuild it if we want to switch to another database or framework;\n• Because of this, the testability is awesome. It’s easier to add new logic and test it;\n• We have a nice and highly scalable project layout where every component has its place.\n\nWhat helped us to achieve this?\n• The concept of dependency injection: adapters (in our case ) are injected into the use cases;\n• The concept of inversion of control: instead of using a real implementation of a repository in the use case , we define an abstract class which outlines interfaces to be used within the use case.\n\nWhat are the downsides?\n• The above-mentioned concepts might be tricky to understand for the Clean Architecture newcomers; the project structure might seem too complicated at first glance;\n• With all this decoupling, we really need to write more code.\n\nFinishing our tutorial, let’s look at our only use case logic. How can it evolve in the future? At some point, we’ll probably want to process bids submitted in different currencies. This will certainly require calling some third-party API to get currency exchange rates. For making external asynchronous HTTP calls, we will need some other dependencies such as aiohttp or httpx libraries. Or what if, in the near future, a new and more effective library appears? As you could already understand, this piece of code is perfect for being implemented within our adapters layer, while comparing already converted bid prices would reside within the use case itself. Let’s keep this as homework for this tutorial."
    },
    {
        "link": "https://github.com/pcah/python-clean-architecture/blob/master/docs/PRINCIPLES.md",
        "document": "The library promotes thinking that your domain should be the first thing you start to develop on the first day of your project. No choice of a framework should be required -- you may not discover yet enough information needed to choose one. Similarly, neither infrastructure configuration nor developer toolset should be required. You should be able to start by describing your domain with pseudocode.\n\nThe library should encourage the developer to follow KISS principle. There are several ways to expand this abbreviation and we prefer to state it as is mentioned above: keep things simple and straightforward. Simple means to us both without unnecessary complication and complexity. Straightforward means stating its intent explicitly.\n\nBoth terms describe either application component as a single element and relations between components. It is easy to build fancy features with lots of objects and relations and thus make the design complicated. It is hard to keep things minimalist and yet expressible. There are several ways you can embody this idea and we mention three of these below:\n\nPure functions are side-effect-free functions, which returned value is based only on its input. This is especially important when mentioned functions implement valid transformations between states of the application. For example, a function may describe how a value object representing money transforms into a (new) value object of another currency. We advise you not to expect such function to implicitly retrieve exchange ratio from an external source. Let the function that makes the transformation take the exchange ratio as an argument.\n\nSelf-contained class has its intent formulated and understandable by its code and its code only. This means that you don't need to gather bits of code placed outside of the class to understand its purpose.\n\nThe Single Responsibility Principle promotes that a component should be responsible for one single thing only.\n\nLet's take a look at one practical example. The core of an application should be expressible with objects as simple as possible (compare to the concept of \"Plain Old Java Objects\"). Entities should not be entangled with neither the persistence framework nor validation schemes. The same goes for all the business logic objects, like value objects, services and events. They should be focused on expressing both: fragments of the business logic and intentions of the specific component design. The validation and the database mapping should be expressed with other components, stating their intent by explicit separation.\n\nThis observation makes frameworks like SQLAlchemy or Django deemed providing inappropriate or unsuitable design. Take a look at Django's . Its design puts three different responsibilities into one class: (1) HTML rendering, (2) input data validation & (3) integration with data schema declaration class (a class). For the purpose of letting a developer to reimplement one of responsibilities, you should make them separated into three classes. You can decide the degree and the direction of coupling, but keeping responsibilities apart will bring you closer to The Clean Architecture. If you don't want to bring superfluous code to your project, use configurable constructor helpers, which give the developer freedom to use them for auto-generation of code or build components by hand.\n\nOne of the main purposes The Clean Architecture exists is separation of concerns with regard to the business logic. Layers, represented by circles in the classic diagrams of onion architectures, represent code components the more logic-pure, the closer to the center. In the very center lie framework- and application-independent code that models the knowledge about the domain itself. The key feature of this separation is The Dependency Rule quoted below and the following corollary: every technical detail should be resolved as far outside of the domain layer as possible and reasonable.\n\nInspired by Robert Martin's The Clean Architecture, this library formulates three key layers: domain, application and framework (with the latter represented by the package). The drivers & connections layer (implicit to the library) hides beneath the framework layer.\n\nThe library wants to promote a design that makes its components coupled only there when it is needed and suitable. On the other hand, components that have reason to exists only together or don't exist at all, should be tightly coupled.\n\nLoose coupling is a design technique of deferring architecture decisions (vide #⁠1) and improving code reusability. It also is a way to achieve separation of layers (vide #⁠3). To provide loose coupling, this library uses dependency injection. We decided to use our own implementation that focuses on being stateful and non-global. Our DI container is a non-global Singleton by single instance and an explicit (and commonly the only one) argument of a component's constructor.\n\nMost of the time, dependency injection is achieved using interfaces (in a python meaning): abstract classes that define its API as contracts between the components. We also use the interfaces along with Python 3's type annotations. This approach synergize with static analysis features of IDEs or language linters.\n\nThere are several ways to describe coupling, but it boils down to this: If changing one module in a program requires changing another module, then coupling exists. (...) Coupling also occurs when code in one module uses code from another, perhaps by calling a function or accessing some data. At this point, it becomes clear that, unlike duplication, you can’t treat coupling as something to always avoid. You can break a program into modules, but these modules will need to communicate in some way — otherwise, you’d just have multiple programs. Coupling is desirable, because if you ban coupling between modules, you have to put everything in one big module. Then, there would be lots of coupling — just all hidden under the rug. So coupling is something we need to control, but how?\n\nLoose coupling enables independent variability among the participants, allowing for example one component to change its implementation technology or its version without affecting other systems. In an enterprise-wide or inter-enterprise (i.e., B2B) integration scenario, independent variability has considerable value because one party usually doesn't have control over all applications, meaning that some components can change without central coordination or approval. For example, if a business partner decides to upgrade to the latest version of SAP there is little one can do to stop them. In the reverse scenario, your business might need to update components without being able to force the other side to make the corresponding change. Loose coupling is like buying insurance. It's best when you don't need it, but that doesn't mean you wasted your money.\n\nThe library's components should be open to reimplementation of other components. This is somewhat an aspect of self-contained classes that support SRP (vide #⁠2), but may necessitate some extra effort to introduce loose coupling (vide #⁠4) where it is needed.\n\nLayered architecture (vide #⁠3) using dependency injection keeps things easy to detach and reimplement, especially on the edge of two layers. But we don't want to stop at this level and we aim to keep things exchangeable with different implementations. For example, if a component within some layer can be implemented in a few different ways, other objects of mentioned layer should not depend on any concrete implementation. They should define a common contract with its interface class and keep their expectations within boundaries of that contract. The library don't have to provide all possible implementations, but it shouldn't keep you from writing your own.\n\nAt the end, the library should become something more similar to a toolbox, that let's you choose tools as you need them, than a framework that forces you to do specific things. Feel free to use only a part of the implementations given by the library or reimplement them with your own code along with the growth of your application.\n\nThe library aims to provide integrations with popular libraries, frameworks and their design patterns. Much of the effort put into designing a clean architecture library would have been futile without proper integrations with The Real World of programming in Python. This real world is day-to-day struggle you, The Developer, take to develop and maintain your application, library or whatever you do. PCA strives to support you with a set of useful integrations. Of course it can (and should) never provide all possible integrations and their number will always be too small, but our goal is to provide at least the key ones. Thanks to The Principle #⁠5, we try to provide clean separation and reliable means to reimplement the integrations in a way you need, if there is no implementation you need."
    },
    {
        "link": "https://medium.com/@surajit.das0320/understanding-clean-architecture-in-python-deep-dive-on-the-code-17141dc5761a",
        "document": "In this article, I will take you through a working example of clean architecture in Python. The underlying concepts and design are language agnostic and can be applied with any language.\n\nTopic — We will build a sample use case of creating a Customer. The Customer has the following attributes :-\n\nThe core of Clean architecture design is made up of the following :-\n\nLet’s start with the Domain layer. In the above example, our Customer is a domain and we need to create a domain entity for the customer.\n\nDomain — We will use Pydantic to build our domain entity. Using Pydantic is purely a preference and it can be replaced with a dataclass or a simple Python class\n\nSo, we have our domain entity for Customer set up. We can write a quick test to check if its working as expected.\n\nGood. We are done with our first step. We have an entity set up and we have also added our tests.\n\nRepository — This is what is going to interact with your infrastructure layer. Remember the repository structure should be infrastructure agnostic. Let me explain with a bit of code.\n\nSo, we have a base repository interface where all the basic operations are defined. Then we define a concrete class which implements the abstract repo interface. In our case, we are going to save our customer record in our Django model. Let’s create a customer model.\n\nLet’s write our implementation for the repository\n\nWe will implement the insert operation for the customer\n\nNow, lets implement the get_by_id operation for the customer\n\nSo, we have the insert and get_by_id operation implemented. Let’s write a test for the methods\n\nSo, we have added a factory class and registered the factory class in conftest.py\n\nLet’s create a fixture for customer_repo because we will use it in our tests.\n\nNow, our boilerplate code is ready for us to create the tests for the repo.\n\nSo, we have added the tests for insert and get_by_id. Next, we will implement the update\n\nNow, let’s write a test for the update\n\nThe last two implementation that we have is to get all customers and delete a customer. Let’s dive in\n\nNow, let’s add a tests for the delete and list methods.\n\nFinal look at the repo and tests.\n\nSo far, we have covered two of the key components of clean architecture\n\nNow, we need to implement the business logic which will be in the use cases. Use case is also similar to services module.\n\nNow, let’s create the concrete implementation for this use case for the customer ops.\n\nGreat, let’s add few tests for our use case\n\nAwesome, we have completed all the three layers for Clean Architecture so far. We have added the domain layer which is our CustomerEntity. Then we have added the repository layer which is our CustomerRepository and finally, we have added our UseCase layer which is our CustomerUseCase class.\n\nSo, far we have able to build the components in isolation and test them without any coupling. The use case class for customer takes a repo in the __init__ method and that is what the real magic is. This is where we could easily switch the repos which interacts with out storage at run time if need be. The structure of the base repo dictates any other concrete repo class must implement the methods declared which is why this design is so awesome.\n\nThe last and final layer is the views or handlers or routes…\n\nI am going to demonstrate the views but it is pretty straightforward.\n\nSo, what’s happening in the views/handlers/routes ?\n• The route or view layer is the presentation layer.\n• The data is passed to the serializers.\n• The serializer then returns a validated_data which is a dictionary.\n• The dictionary is then mapped to the domain entity.\n• The Concrete Customer Use case object is instantiated with a concrete repository instance.\n• Then, we invoke the right method based on the route method. e.g get_by_id, list, insert or delete.\n• The use case then invokes the repository method and returns the data.\n• The returned data is then converted to a dict and passed to the DRF Response class with the right status_code.\n• It separates the infrastructure concerns from the application code.\n• Decoupled code is easier to maintain and scale.\n• Testing each component or layer is easy since it is not coupled with other layers.\n• Dependency injection and IOC is at the heart of the above implementation."
    },
    {
        "link": "https://news.ycombinator.com/item?id=33999191",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/Python/comments/1gthdpy/deply_keep_your_python_architecture_clean",
        "document": "My name is Archil. I'm a Python/PHP developer originally from Ukraine, now living in Wrocław, Poland. I've been working on a tool called Deply, and I'd love to get your feedback and thoughts on it.\n\nWhat My Project Does\n\nDeply is a standalone Python tool designed to enforce architectural patterns and dependencies in large Python projects. Deply analyzes your code structure and dependencies to ensure that architectural rules are followed. This promotes cleaner, more maintainable, and modular codebases.\n• Dynamic Configuration: Easily configure collectors for each layer using file patterns and class inheritance.\n• CI Integration: Integrate Deply into your Continuous Integration pipeline to automatically detect and prevent architecture violations before they reach production.\n• Who It's For: Developers and teams working on medium to large Python projects who want to maintain a clean architecture.\n• Intended Use: Ideal for production environments where enforcing module boundaries is critical, as well as educational purposes to teach best practices.\n• Continuous Integration: Add Deply to your CI/CD pipeline to catch architectural violations early in the development process.\n• Refactoring: Use Deply to understand existing dependencies in your codebase, making large-scale refactoring safer and more manageable.\n• Code Reviews: Assist in code reviews by automatically checking if new changes adhere to architectural rules.\n\nWhile there are existing tools like pydeps that visualize dependencies, Deply focuses on:\n• Enforcement Over Visualization: Not just displaying dependencies but actively enforcing architectural rules by detecting violations.\n• Customization: Offers dynamic configuration with various collectors to suit different project structures.\n\nI'm eager to hear your thoughts, suggestions, or criticisms. Deply is currently at version 0.1.5, so it's not entirely stable yet, but I'm actively working on it. I'm open to pull requests and looking forward to making Deply a useful tool for the Python community.\n\nThank you for your time!"
    },
    {
        "link": "https://stackoverflow.com/questions/1569049/making-pythons-assert-throw-an-exception-that-i-choose",
        "document": "This will work. But it's kind of crazy.\n\nWhy not the following? This is less crazy.\n\nIt's only a little wordier than the statement, but doesn't violate our expectation that assert failures raise .\n\nThen you can more-or-less replace your existing assertions with something like this.\n\nOnce you've done this, you are now free to fuss around with enable or disabling or whatever it is you're trying to do.\n\nAlso, read up on the warnings module. This may be exactly what you're trying to do."
    },
    {
        "link": "https://realpython.com/python-raise-exception",
        "document": "When you use the statement in Python to raise (or throw) an exception, you signal an error or an unusual condition in your program. With , you can trigger both built-in and custom exceptions. You can also include custom messages for more clarity or even re-raise exceptions to add context or handle further processing.\n\nBy the end of this tutorial, you’ll understand that:\n• Raising an exception in Python signals an error condition, halting normal program flow.\n• You use to initiate exceptions for error handling or to propagate existing exceptions.\n• You can raise custom exceptions by defining new exception classes derived from .\n• The difference between and lies in their use. You use for debugging, while is used to signal runtime errors.\n• You can re-raise an exception by using a bare within an block to preserve the original traceback.\n\nLearning about the statement will allow you to handle errors and exceptional situations effectively in your code. By knowing how to use it, you’ll be able to develop more robust programs and improve the quality of your code.\n\nTo get the most out of this tutorial, you should understand the fundamentals of Python, including variables, data types, conditional statements, exception handling, and classes.\n\nExceptions play a fundamental role in Python. They allow you to handle errors and exceptional situations in your code. But what is an exception? An exception represents an error or indicates that something is going wrong. Some programming languages, such as C, and Go, encourage you to return error codes, which you check. In contrast, Python encourages you to raise exceptions, which you handle. Note: In Python, not all exceptions are errors. The built-in exception is an excellent example of this. Python internally uses this exception to terminate the iteration over iterators. Python exceptions that represent errors have the suffix attached to their names. Python also has a specific category of exceptions that represent warnings to the programmer. Warnings come in handy when you need to alert the user of some condition in a program. However, that condition may not warrant raising an exception and terminating the program. A common example of a warning is , which appears when you use deprecated features. When a problem occurs in a program, Python automatically raises an exception. For example, watch what happens if you try to access a nonexistent index in a object: In this example, your list doesn’t have a index. Its indices go from to , covering your seven colors. So, if you try to get index number , then you get an exception telling you that your target index is out of range. Note: In the example above, Python raised the exception on its own, which it’ll only do with built-in exceptions. You, as a programmer, have the option to raise built-in or custom exceptions, as you’ll learn in the section Choosing the Exception to Raise: Built-in vs Custom. Every raised exception has a traceback, also known as a stack trace, stack traceback, or backtrace, among other names. A traceback is a report containing the sequence of calls and operations that traces down to the current exception. In Python, the traceback header is in most situations. Then you’ll have the actual call stack and the exception name followed by its error message. Note: Since the introduction of the new PEG parser in Python 3.9, there’s been an ongoing effort to make the error messages in tracebacks more helpful and specific. This effort continues to produce new results, and Python 3.12 and Python 3.13 has incorporated even better error messages. Exceptions will cause your program to terminate unless you handle them using a … block: \"Your list doesn't have that index :-(\" Your list doesn't have that index :-( The first step in handling an exception is to predict which exceptions can happen. If you don’t do that, then you can’t handle the exceptions, and your program will crash. In that situation, Python will print the exception traceback so that you can figure out how to fix the problem. Sometimes, you must let the program fail in order to discover the exceptions that it raises. In the above example, you know beforehand that indexing a list with an index beyond its range will raise an exception. So, you’re ready to catch and handle that specific exception. The block takes care of catching exceptions. The clause specifies the exception that you’re predicting, and the code block allows you to take action accordingly. The whole process is known as exception handling. If your code raises an exception in a function but doesn’t handle it there, then the exception propagates to where you called function. If your code doesn’t handle it there either, then it continues propagating until it reaches the main program. If there’s no exception handler there, then the program halts with an exception traceback. Exceptions are everywhere in Python. Virtually every module in the standard library uses them. Python will raise exceptions in many different circumstances. The Python documentation states that: Exceptions are a means of breaking out of the normal flow of control of a code block in order to handle errors or other exceptional conditions. An exception is raised at the point where the error is detected; it may be handled by the surrounding code block or by any code block that directly or indirectly invoked the code block where the error occurred. (Source) In short, Python automatically raises exceptions when an error occurs during a program’s execution. Python also allows you to raise exceptions on demand using the keyword. This keyword lets you handle your program’s errors in a more controlled manner.\n\nIn Python, you can raise either built-in or custom exceptions. When you raise an exception, the result is the same as when Python does it. You get an exception traceback, and your program crashes unless you handle the exception on time. Note: In Python’s terminology, exceptions are raised, while in other programming languages, such as C++ and Java, exceptions are thrown. To raise an exception by yourself, you’ll use the statement, which has the following general syntax: A keyword with no argument reraises the active exception. Note that you can only use a bare in code blocks with an active exception. Otherwise, you’ll get a exception: In this example, you’re in a context with no active exceptions. Therefore, Python can’t reraise a previous exception. Instead, it raises a exception. The bare statement is useful when you need to perform some actions after catching an exception, and then you want to reraise the original exception. You’ll learn more about this use case of in the section Reraising a Previous Exception. The object in the syntax must return an instance of a class that derives from , which is the base class for all built-in exceptions. It can also return the exception class itself, in which case Python will automatically instantiate the class for you. Note that can be any Python expression that returns an exception class or instance. For example, your argument to could be a custom function that returns an exception: This function takes an exception class and an error message as arguments. Then the function instantiates the input exception using the message as an argument. Finally, it returns the exception instance to the caller. You can use this function as an argument to the keyword, as you do in the above example. The clause is also optional in the syntax. It allows you to chain exceptions together. If you provide the clause, then must evaluate to another exception class or instance. You’ll learn more about the clause in the section Chaining Exceptions With the Clause. Here’s another example of how works. This time, you create a new instance of the class: For illustration purposes, you raise an instance of , but raising this generic exception actually isn’t a best practice. As you’ll learn later, user-defined exceptions should derive from this class, although they can derive from other built-in exceptions too. Note: In Python, starting the error messages of exceptions with a lowercase letter is common practice. Also, they don’t end in a period. To illustrate, consider the following examples: In the first example, you get a exception because you’re trying to divide by . Note how the default error message starts with a lowercase letter and doesn’t have a period at its end. In the second example, you try to access the index in an empty list, and Python raises a exception for you. In this case, the error message follows the same described pattern. Even though this practice isn’t an explicit convention, you should consider sticking to this pattern to ensure consistency in your codebase. The class constructor of exceptions like can take multiple positional arguments or a tuple of arguments: You’ll typically instantiate exceptions with a single argument: a string that provides an appropriate error message. However, you can also instantiate them with multiple arguments. In this example, you provide additional arguments to the class constructor. These arguments allow you to give other developers more information about what caused the error and how to fix it. The attribute gives you direct access to all the arguments passed to the constructor: In this example, you access the arguments using the attribute. This attribute holds a tuple that you can index to access specific arguments. Now that you’ve learned the basics of raising exceptions in Python, it’s time to move on. An essential part of raising your own exceptions is deciding which exception is appropriate in a given moment.\n\nChoosing the Exception to Raise: Built-in vs Custom When it comes to manually raising exceptions in your code, deciding which exception to raise is an important step. In general, you should raise exceptions that clearly communicate the problem you’re dealing with. In Python, you can raise two different kinds of exceptions:\n• Built-in exceptions: These exceptions are built into Python. You can use them directly in your code without importing anything.\n• User-defined exceptions: Custom exceptions are those that you create when no built-in exception fits your needs. You’ll typically put them in a dedicated module for a specific project. In the following sections, you’ll find some guidelines for deciding which exception to raise in your code. Python has a rich set of built-in exceptions structured in a class hierarchy with the class at the top. One of the most frequently used subclasses of is . The class is a fundamental part of Python’s exception-handling scaffolding. It’s the base class for most of the built-in exceptions that you’ll find in Python. It’s also the class that you’ll typically use to create your custom exceptions. Python has more than sixty built-in exceptions. You’ve probably seen some of the following concrete exceptions in your day-to-day coding: Appears when an statement has trouble loading a module Happens when can’t locate a given module Appears when a global or local name isn’t defined Happens when an attribute reference or assignment fails Occurs when an indexing operation on a sequence uses an out-of-range index Occurs when a key is missing in a dictionary Appears when the second operand in a division or modulo operation is Happens when an operation, function, or method operates on an object of inappropriate type Occurs when an operation, function, or method receives the right type of argument but the wrong value This table is just a small sample of Python’s built-in exceptions. You can use these and all the other built-in exceptions when using the statement in your code. In most cases, you’ll likely find an appropriate built-in exception for your specific use case. If that’s your case, then favor the built-in exception over a custom one. For example, say you’re coding a function to compute the square of all the values in an input , and you want to ensure that the input object is a list or tuple: In , you use a conditional statement to check whether the input object is a list or a tuple. If it’s not, then you raise a exception. That’s an excellent exception choice because you want to ensure the correct type in the input. If the type is wrong, then getting a is a logical response. If you don’t find a built-in exception that semantically suits your needs, then you can define a custom one. To do this, you must inherit from another exception class, typically . For example, say that you’re coding a gradebook app and need to calculate the students’ average grades. You want to ensure that all the grades are between 0 and 100. To handle this scenario, you can create a custom exception called . You’ll raise this exception if a grade value is outside the target interval, meaning it’s invalid: \"grade values must be between 0 and 100 inclusive\" In this example, you first create a custom exception by inheriting from . You don’t need to add new functionality to your custom exception, so you use the statement to provide a placeholder class body. This new exception is specific to your grade project. Note how the exception name helps communicate the underlying issue. Note: In Python, defining custom exceptions with a statement as the class body is a common practice. This is because the class’s name is often the most important aspect of a custom exception. You’ll also find situations where you may want to add new features to your custom exceptions. However, that topic is beyond the scope of this tutorial. Inside the function, you use a loop to iterate over the input list of grades. Then you check if the current grade value falls outside the range of to . If that’s the case, then you instantiate and raise your custom exception, . Here’s how your function works in practice: File , line , in File , line , in : grade values must be between 0 and 100 inclusive With an invalid grade value, your function raises , which is project-specific and shows an explicit message about the actual error. Some developers may argue that, in this example, you can use the built-in instead of defining your own custom exception, and they might be right. In general, you’ll define custom exceptions when you want to point out project-specific errors or exceptional situations. If you decide to use custom exceptions, then remember that the naming conventions for classes apply. Additionally, you should add the suffix to custom exceptions that represent errors and no suffix for non-error exceptions. If you’re defining custom warnings, then you should use the suffix instead. All these naming conventions make your intentions clearer to other developers.\n\nAnother important step in effectively using the statement is deciding when to raise a given exception in your code. You’ll need to decide whether raising an exception is the best option to solve your current problem. In general, you should raise exceptions when you need to:\n• Signal errors and exceptional situations: The most common use case of the statement is to signal that an error or exceptional situation has occurred. When an error or exceptional situation occurs in your code, you can raise an exception in response.\n• Reraise exception after doing some additional processing: A common use case of is to reraise an active exception after performing some operations. A good example of this use case is when you need to log the error before raising the actual exception. Some programming languages, such as C and Go, encourage you to return error codes from functions and methods. Then you’ll have to check these codes in conditional statements and handle the underlying errors accordingly. For example, Go programmers should be familiar with the following construct: Here, must return a result and an error. The conditional checks the error and takes action accordingly. In contrast, Python encourages you to use exceptions to deal with errors and exceptional situations. Then you’ll have to handle these errors using the … construct. This approach is pretty common in Python code. The standard library and the language itself have many examples of it. An equivalent Python function would look something like this: In , you use a … block to catch an exception that or any other code called from that function would raise. The object represents the target exception in the example. Then you log the error and reraise the active exception, . Note: The approach that encourages using error codes and conditionals is generally known as look before you leap (LBYL). In contrast, the approach that encourages raising and handling exceptions is known as easier to ask forgiveness than permission (EAFP). To dive deeper into how both approaches work, check out LBYL vs EAFP: Preventing or Handling Errors in Python. In practice, you’ll raise exceptions as soon as the error or exceptional situation occurs. On the other hand, when to catch and handle the raised exception will depend on your specific use case. Sometimes, capturing the exception close to where it first occurred makes sense. This way, you’ll have enough context to correctly handle the exception and recover without terminating the entire program. However, if you’re writing a library, then you typically don’t have enough context to handle the exception, so you leave the exception handling to the clients. Now that you have a clearer idea of when to raise exceptions in your Python code, it’s time to get your hands dirty and start raising exceptions.\n\nRaising exceptions is a popular way to deal with errors and exceptional situations in Python. For that reason, you’ll find yourself using the statement in several situations. For example, you’ll use the statement to raise exceptions in response to a given condition in your code or to reraise active exceptions after performing some additional processing. You’ll also use this statement to chain exceptions with the clause so that you provide more context to anyone debugging your code or code that’s built on top of it. Before diving into this discussion, you’ll learn a bit about the internal structure of an exception. Exception classes have an attribute called , which is a tuple containing the arguments that you provide to the exception constructor: The attribute gives you dynamic access to all the arguments that you passed to the exception class constructor at instantiation time. You can take advantage of this attribute when you’re raising your own exceptions. Exception classes also have two methods:\n• allows you to provide a new traceback for the exception, and it returns the updated exception object.\n• allows you to include one or more notes in an exception’s traceback. You can access the list of notes in a given exception by inspecting the special attribute. Both methods allow you to provide extra information about a given exception, which will help your users debug their code. Finally, exceptions also have a bunch of special, or dunder, attributes like . Two of the most useful dunder attributes are and . Note: Special attributes are also known as dunder attributes. The word dunder comes from the double underscores at the beginning and end of the names. The attribute holds the traceback object attached to an active exception: In this example, you access the attribute, which holds an exception traceback object. You can use traceback objects like this to customize a given exception using the method. Python automatically creates a traceback object when an exception occurs. Then it attaches the object to the exception’s attribute, which is writable. You can create an exception and provide it with your own traceback using the method. The attribute will store the expression passed to the class when you’re chaining exceptions in your code. You’ll learn more about this attribute in the section about . Now that you know the basics of how exceptions are built internally, it’s time to continue learning about raising exceptions. Raising an exception when you meet a given condition is a common use case of the statement. These conditions are usually related to possible errors and exceptional situations. For example, say that you want to write a function to determine if a given number is prime. The input number must be an integer. It should also be greater than or equal to . Here’s a possible implementation that handles these situations by raising exceptions: This function checks if the input number isn’t an instance of , in which case it raises a . Then the function checks if the input number is less than , raising a if the condition is true. Note that both statements check for conditions that would cause errors or conditional situations if they passed silently. Then the function iterates through the integers between and the square root of . Inside the loop, the conditional statement checks if the current number is divisible by any other in the interval. If so, then the function returns because the number isn’t prime. Otherwise, it returns to signal that the input number is prime. Finally, it’s important to note that you’ve raised both exceptions early in the function, right before doing any computation. Raising exceptions early, as you did in this function, is considered a best practice. You can use the statement without any arguments to reraise the last exception that occurred in your code. The classic situation where you’d want to use this way is when you need to log the error after it happens: In this example, you use to catch any exceptions that happen in the code block. If an exception of any type occurs, then you log the actual error using the module from the standard library and finally reraise the active exception using a bare statement. Note: Catching a generic as in the example above, is considered a bad practice in Python. You should always try to find a specific exception to catch. This way, you’ll prevent hiding unknown errors. However, in this specific use case of , you may want to specify a broad or generic exception in the clause so that you can catch several different errors, log them, and then reraise the original exception for higher-level code to handle. Note that you’ll get a similar effect if you use with a reference to the active exception as an argument: If you use the current exception as an argument to , then you get an extra piece of traceback. The second line in the traceback tells you that line 5 has reraised an exception. That’s the exception that you manually raised. The third traceback line tells you what the original exception in the code was. That exception occurred on line 2. Another common scenario where you’d need to reraise an exception is when you want to wrap one exception in another or intercept one exception and translate it into a different one. To illustrate, say that you’re writing a math library, and you have several external math-related libraries as dependencies. Each external library has its own exceptions, which may end up confusing you and your users. In this case, you can catch those libraries’ exceptions, wrap them with a custom exception and then raise it. For example, the following function captures a and wraps it in a custom : File , line , in : During handling of the above exception, another exception occurred: File , line , in File , line , in : In this example, you catch the concrete exception, , and wrap it in your own custom exception, . This technique can be useful in a few situations, including the following:\n• Abstracting away external exceptions: When you’re writing a library that interacts with multiple external components, you may want to abstract away external exceptions and raise custom exceptions so that your users don’t depend on the former. That’s what you did in the example above.\n• Unifying handling actions: When you have multiple exception types with the same handling action, it might make sense to catch all those exceptions, raise a single custom exception, and handle it according to your planned actions. This practice can simplify your error-handling logic.\n• Augmenting the context of a caught exception: When you’re handling an exception that doesn’t have enough context or behavior at first, you can add those features and then reraise the exception manually. The above use cases of reraising exceptions are neat and can facilitate your life when you’re handling exceptions in your code. However, changing exceptions with the clause often offers a better alternative. For example, if you use the syntax in the above example, then you’ll suppress the and only get information about . In the following section, you’ll learn about the clause and how it works. The statement has an optional clause. This clause allows you to chain the raised exception with a second exception provided as an argument to . Note that if you use the clause, then its argument must be an expression that returns an exception class or instance. You’ll typically use in an code block to chain the raised exception with the active one. If the argument to is an exception instance, then Python will attach it to the raised exception’s attribute. If it’s an exception class, then Python will instantiate it before attaching it to . The effect of is that you’ll have both exception tracebacks on your screen: File , line , in : The above exception was the direct cause of the following exception: File , line , in : In this example, you use in the clause to catch any exception in the block. Then you raise a from the concrete exception, which is a in this case. The clause chains both exceptions, providing complete context for the user to debug the code. Note how Python presents the first exception as the direct cause of the second one. This way, you’ll be in a better position to track the error down and fix it. This technique is pretty handy when you’re processing a piece of code that can raise multiple types of exceptions. Consider the following function: \"denominator can't be zero\" This function raises a if the input argument isn’t a number. Similarly, it raises a if the argument is equal to because this will cause the zero division error. Here are two examples of how the clause can be helpful: File , line , in File , line , in : denominator can't be zero The above exception was the direct cause of the following exception: File , line , in : File , line , in File , line , in : The above exception was the direct cause of the following exception: File , line , in : In the first example, the traceback shows the exception that happens when the second argument to is . This traceback helps you track the actual error in your code. In the second example, the traceback directs your eyes toward the exception, which is due to using the wrong argument type. It’s important to note that if you don’t use , then Python will raise both exceptions, but the output will be a bit different: File , line , in File , line , in : denominator can't be zero During handling of the above exception, another exception occurred: File , line , in : Now the traceback doesn’t state that the the first exception is the root cause of the second one. Another way to use is when you use as its argument. Using allows you to suppress or hide the original exception’s traceback when it’s not necessary or informative. You can also use this syntax to suppress the traceback of built-in exceptions when raising your own exception. To illustrate how works, say that you’re coding a package to consume an external REST API. You’ve decided to use the library to access the API. However, you don’t want to expose the exceptions that this library provides. Instead, you want to use a custom exception. Note: For the code below to work, you must first install the library in your current Python environment using or a similar tool. Here’s how you can achieve that behavior: The function takes a URL as an argument and makes a GET request to it. If an error occurs during the API call, then the function raises the exception, which is your custom exception. The clause will hide the original exception’s traceback, replacing it with your own. To check how this function works, say that you make a spelling mistake while providing the API endpoint: In this example, you misspell the target URL. This mistake raises an exception that Python automatically catches in the clause using the generic exception. Note how you’ve completely suppressed the original exception in the traceback. Instead, you only get the custom exception. The construct is useful when you want to provide a custom traceback and error message and suppress the original exception. This can be helpful in cases where the original exception message isn’t very informative or useful for users, and you want to provide a more helpful message.\n\nFollowing Best Practices When Raising Exceptions When it comes to raising exceptions in Python, you can follow a few practices and recommendations that will make your life more pleasant. Here’s a summary of some of these practices and recommendations:\n• Favor specific exceptions over generic ones: You should raise the most specific exception that suits your needs. This practice will help you track down and fix problems and errors.\n• Provide informative error messages and avoid exceptions with no message: You should write descriptive and explicit error messages for all your exceptions. This practice will provide a context for those debugging the code.\n• Favor built-in exceptions over custom exceptions: You should try to find an appropriate built-in exception for every error in your code before writing your own exception. This practice will ensure consistency with the rest of the Python ecosystem. Most experienced Python developers will be familiar with the most common built-in exceptions, making it easier for them to understand and work with your code.\n• Avoid raising the exception: You should avoid raising the in your code. This exception is specifically for the statement, and it’s not appropriate in other contexts.\n• Raise exceptions as soon as possible: You should check error conditions and exceptional situations early in your code. This practice will make your code more efficient by avoiding unnecessary processing that a delayed error check could throw away. This practice fits the fail-fast design.\n• Explain the raised exceptions in your code’s documentation: You should explicitly list and explain all the exceptions that a given piece of code could raise. This practice helps other developers understand which exceptions they should expect and how they can handle them appropriately. To illustrate some of these recommendations, consider the following example, where you raise a generic exception: In this example, you use the class to point out an issue that’s closely related to the input value. Using a more specific exception like is more appropriate in this example. Improving the error message a bit will also help: \"age must not be negative\" File , line , in : In this example, the very name of the raised exception helps you communicate the actual issue. Additionally, the error message is more precise and helpful. Again, you should provide informative error messages regardless of whether you’re using a built-in or custom exception. In general, the error message in an exception should concisely describe what went wrong. The error message should be specific enough to help other developers identify, diagnose, and debug the error. However, it shouldn’t reveal too many details of your code’s internals because this practice may lead to security flaws. In any case, remember that these are just recommended practices. They’re not strict rules. You’ll face situations in which you would want to raise and handle generic exceptions. Finally, if you’re writing a library for other developers, then you must document the exceptions that your functions and methods can raise. You should list the types of exceptions that your code may raise and briefly describe what each exception means and how your users can handle them in their code.\n\nThe statement isn’t the only statement that raises exceptions in Python. You also have the statement. However, the goal of is different, and it can only raise one type of exception, . The statement is a debugging and testing tool in Python. It allows you to write sanity checks that are known as assertions. You can use these checks to verify whether certain assumptions remain true in your code. If any of your assertions become false, then the statement raises an exception. Getting this error may mean that you have a bug in your code. Note: To dive deeper into writing assertions in your code, check out Python’s : Debug and Test Your Code Like a Pro. You shouldn’t use the statement to handle user input or other kinds of input errors. Why? Because assertions can, and most likely will, be disabled in production code. So, it’s best to use them during development as a tool for debugging and testing. In Python, has the following syntax: In this construct, can be any valid Python expression or object that you need to test for truthiness. If is false, then the statement raises an . The parameter is optional but encouraged because it adds more context for those debugging and testing the code. It can hold an error message describing the issue that the statement is supposed to catch. Here’s an example that shows how you write an statement with a descriptive error message: \"expected age to be at least 0, got File , line , in : expected age to be at least 0, got -10 The error message in this assertion clearly communicates what’s making the condition fail. In this example, the condition is false, so raises an in response. Again, you should use something other than the statement to validate input because assertions can be disabled in production code, making the input skip the validation. It’s also important to note that your code shouldn’t explicitly raise the exception with a statement. This exception should occur as a result of a failing assertion while you’re testing and debugging your code during development.\n\nIf you’re in Python 3.11 or greater, then you’ll have the option to use the new class and the associated syntax. These new Python features are useful when you need to handle multiple errors simultaneously. For example, you might reach for them when an asynchronous program has several concurrent tasks that could fail at the same time. But in general, you probably won’t raise an very often. Apart from the usual error message, the constructor takes an additional argument consisting of a non-empty sequence of exceptions. Here’s a toy example that shows how you can raise an exception group and what its traceback looks like: You raise an as you’d raise any other exception in Python. However, the traceback of an exception group is quite different from the traceback of a regular exception. You’ll get information about the exception group and its grouped exceptions. Once you’ve wrapped several exceptions in an exception group, then you can catch them with the syntax, like in the code below: Note that this construct behaves differently from either multiple clauses that catch different exceptions or an clause that catches multiple exceptions. In those latter cases, the code will catch the first exception that occurs. With this new syntax, your code will raise all the exceptions, so it can catch all of them. Note: For a deep dive into the various ways to catch one or all of multiple exceptions, check out How to Catch Multiple Exceptions in Python. Finally, when you raise an , Python will try it as a regular exception because it’s a subclass of . For example, if you remove the asterisk from the clause, then Python won’t catch any of the listed exceptions: In this new version of your code, you removed the asterisk from the clause. So, your code won’t catch any individual exceptions in the group. The idea is that to catch any of the subexceptions in an exception group, you must use the syntax. However, you can use a plain if you want to catch the itself: In the context of a regular clause, Python tries as it would try any other exception. It catches the group and runs the handling code."
    },
    {
        "link": "https://stackoverflow.com/questions/839636/best-practices-for-python-exceptions",
        "document": "What are the best practices for creating exceptions? I just saw this, and I don't know if I should be horrified, or like it. I read several times in books that exceptions should never ever hold a string, because strings themselves can throw exceptions. Any real truth to this?\n\nBasically from my understanding from the scripts is that this was done so all the inhouse Python libraries will have a common error message format (something that is desperately needed) so I can understand why putting the error message string is a good idea. (Almost every method throws exceptions due to the utter need for nothing invalid getting through).\n\nThe code in question is the following:\n\nThis is just the tip of the iceberg, but can someone give me some insight in what makes this a terrible idea? Or if there is a much better exception coding process/style."
    },
    {
        "link": "https://geeksforgeeks.org/python-exception-handling",
        "document": "Python Exception Handling handles errors that occur during the execution of a program. Exception handling allows to respond to the error, instead of crashing the running program. It enables you to catch and manage errors, making your code more robust and user-friendly.\n\nExample: Trying to divide a number by zero will cause an exception.\n\nExplanation: In this example, dividing number by 0 raises a ZeroDivisionError. The try block contains the code that might cause an exception and the except block handles the exception, printing an error message instead of stopping the program.\n• Error : Errors are serious issues that a program should not try to handle. They are usually problems in the code’s logic or configuration and need to be fixed by the programmer. Examples include syntax errors and memory errors.\n• Exception : Exceptions are less severe than errors and can be handled by the program. They occur due to situations like invalid input, missing files or network issues.\n\nExplanation: A syntax error is a coding mistake that prevents the code from running. In contrast, an exception like ZeroDivisionError can be managed during the program’s execution using exception handling.\n\nException handling in Python is done using the try, except, else and finally blocks.\n\ntry, except, else and finally Blocks\n• try Block lets us test a block of code for errors. Python will “try” to execute the code in this block. If an exception occurs, execution will immediately jump to the except block.\n• except Block: enables us to handle the error or exception. If the code inside the try block throws an error, Python jumps to the except block and executes it. We can handle specific exceptions or use a general except to catch all exceptions.\n• else Block: is optional and if included, must follow all except blocks. The else block runs only if no exceptions are raised in the try block. This is useful for code that should execute if the try block succeeds.\n• finally Block: always runs, regardless of whether an exception occurred or not. It is typically used for cleanup operations (closing files, releasing resources).\n• try block asks for user input and tries to divide 100 by the input number.\n• else block runs if no exception occurs, displaying the result.\n• finally block runs regardless of the outcome, indicating the completion of execution.\n\nPython has many built-in exceptions, each representing a specific error condition. Some common ones include:\n\nThe base class for all built-in exceptions. The base class for all non-exit exceptions. Base class for all errors related to arithmetic operations. Raised when a division or modulo operation is performed with zero as the divisor. Raised when a numerical operation exceeds the maximum limit of a data type. Raised when an attribute reference or assignment fails. Raised when a sequence subscript is out of range. Raised when a dictionary key is not found. Raised when an operation runs out of memory. Raised when a local or global name is not found. Raised when an operation or function is applied to an object of inappropriate type. Raised when a function receives an argument of the right type but inappropriate value. Raised when an import statement has issues. Raised when a module cannot be found.\n\nWhen working with exceptions in Python, we can handle errors more efficiently by specifying the types of exceptions we expect. This can make code both safer and easier to debug.\n\nCatching specific exceptions makes code to respond to different exception types differently.\n• None The ValueError is caught because the string “str” cannot be converted to an integer.\n• None If x were 0 and conversion successful, the ZeroDivisionError would be caught when attempting to calculate its inverse.\n\nWe can catch multiple exceptions in a single block if we need to handle them in the same way or we can separate them if different types of exceptions require different handling.\n• None The ValueError is caught when trying to convert “twenty” to an integer.\n• None TypeError might occur if the operation was incorrectly applied to non-integer types, but it’s not triggered in this specific setup.\n• None IndexError would be caught if an index outside the range of the list was accessed, but in this scenario, it’s under control.\n\nHere’s a simple calculation that may fail due to various reasons.\n• None An ArithmeticError (more specific like ZeroDivisionError) might be caught if this were a number-to-number division error. However, TypeError is actually triggered here due to attempting to divide a string by a number.\n• catch-all except: is used to catch the TypeError, demonstrating the risk that the programmer might not realize the actual cause of the error (type mismatch) without more detailed error logging.\n\nWe raise an exception in Python using the raise keyword followed by an instance of the exception class that we want to trigger. We can choose from built-in exceptions or define our own custom exceptions by inheriting from Python’s built-in Exception class.\n• None The function set checks if the age is negative. If so, it raises a ValueError with a message explaining the issue.\n• None This ensures that the age attribute cannot be set to an invalid state, thus maintaining the integrity of the data.\n• Improved program reliability : By handling exceptions properly, you can prevent your program from crashing or producing incorrect results due to unexpected errors or input.\n• Simplified error handling : Exception handling allows you to separate error handling code from the main program logic, making it easier to read and maintain your code.\n• Cleaner code: With exception handling, you can avoid using complex conditional statements to check for errors, leading to cleaner and more readable code.\n• Easier debugging : When an exception is raised, the Python interpreter prints a traceback that shows the exact location where the exception occurred, making it easier to debug your code.\n• Performance overhead: Exception handling can be slower than using conditional statements to check for errors, as the interpreter has to perform additional work to catch and handle the exception.\n• Increased code complexity : Exception handling can make your code more complex, especially if you have to handle multiple types of exceptions or implement complex error handling logic.\n• Possible security risks: Improperly handled exceptions can potentially reveal sensitive information or create security vulnerabilities in your code, so it’s important to handle exceptions carefully and avoid exposing too much information about your program."
    },
    {
        "link": "https://dev.to/kyotanakada/best-practices-for-implementing-exception-handling-in-python-1ni1",
        "document": "Writing effective exception handling code is essential for creating robust and maintainable applications.\n\n Below are some best practices for writing exception handling code in Python:\n\n1. Catch Only What You Can Handle\n• Catch specific exceptions rather than using a broad except clause.\n• This ensures that only the exceptions you expect and know how to handle are caught.\n• Avoid using without specifying an exception type.\n• This can catch unexpected errors and make debugging difficult.\n\n# Code that might raise an exception # Catch all exceptions if necessary\n• Place the code that might raise an exception here.\n• Execute this block if no exception was raised in the try block.\n• Execute this block regardless of whether an exception was raised, often used for cleanup.\n\n# Code that might raise an exception This will always be executed.\n• Use the module to log exceptions.\n• Logging helps diagnose issues in production without revealing errors to end users.\n• If you catch an exception but can't fully handle it, consider re-raising it so that it can be handled elsewhere.\n\n# Code that might raise an exception\n• Use context managers (with statement) to manage resources like files, sockets, or database connections.\n• This ensures that resources are properly released even if an exception is raised.\n\n-Instead of allowing your application to crash, provide fallback mechanisms or user-friendly error messages.\n• For example, if a configuration file is missing, you might use default settings instead.\n• Ignoring exceptions can hide bugs and make the application behave unpredictably.\n• Use docstrings to document the exceptions that your functions can raise.\n• This helps other developers understand what exceptions to expect and how to handle them.\n\nDivides two numbers. :param a: Numerator. :param b: Denominator. :return: The result of the division. :raises ZeroDivisionError: If the denominator is zero.\n\n10. Use Custom Exceptions When Appropriate\n• Create custom exceptions to represent specific error conditions in your application.\n• This can make your code more readable and easier to maintain.\n• Write tests to ensure that your exception handling works as expected.\n• Use frameworks like unittest or pytest to test both normal and exceptional cases.\n• Exceptions should be used for unexpected conditions, not as a regular control flow mechanism.\n• For example, avoid using exceptions to handle predictable conditions like the end of a loop.\n• Python allows you to chain exceptions to preserve the original context when raising a new exception.\n• Use from to link related exceptions.\n\nBy following these best practices, you can write more robust, maintainable, and readable exception handling code that gracefully manages errors and enhances your application's reliability."
    },
    {
        "link": "https://stackoverflow.com/questions/17090311/symfony-best-practices-should-queries-be-in-repositories-or-services",
        "document": "I have a question about best practices in Symfony 2. Sorry if it's a bit vague and subjective. I guess I can sum up my question as:\n\n\"Are repositories always the right place for queries?\".\n\nRight now I'm putting most of my doctrine queries in entity repositories. Most of my controller actions do typical things like query for an entity or collection of entities, throw an exception or redirect depending on the outcome of that, otherwise update one or more entities. Most actions are more complex than can be done efficiently with the standard ->find, ->findBy etc queries. Most require joins. When a query involves multiple entities, sometimes I'm not sure which repository it should even go in. I guess there is the root entity of the query but ... sometimes data from the joined entities are more important and relevant so it feels wrong to put it in the root entity's repository.\n\nThat's working okay but I tend to end up with lots of almost the same but slightly different queries in my repositories. Coming up with names and keeping track of exactly what each one does can get confusing and tedious. Most of these queries are used by only one or two (often seldom used) controller actions in the same controller. I feel like I'm cluttering my repositories with too much specialized, seldom used stuff.\n\nIt seems like all but the most simple actions should be encapsulated in an object or service. So, I've started doing a lot of my queries directly in the service rather than a repository. It's easy to look at the action all in one place. Is this an okay practice?"
    },
    {
        "link": "https://reddit.com/r/django/comments/sa0uj7/how_to_you_get_better_at_django_orm",
        "document": "I used Django for many years in various projects, but I still feel limited in my knowledge when I have to build a complex query. There are many concepts and tools in Django ORM (eg: Subquery, Q, F, annotate, prefetch, OuterRef, etc.) and even if when I read the doc I'm thinking \"ok it's pretty clear to me\", I still struggle to build complex queries by myself and often end up asking a question on SO to help me.\n\nCould you provide some pieces of advices or resources (books, videos, blog posts) to master the Django ORM? My purpose is to be able to translate any requirement in a query, without external help."
    },
    {
        "link": "https://rootstrap.com/blog/tips-for-using-databases-with-django-orm-object-relational-mapper",
        "document": "Handling data is a big part of developing applications with Django. To do that, we use Django's ORM, from retrieving a specific set of instances to updating several rows in the database.\n\nIt's no surprise then that the way we make those queries can significantly impact our app's performance. So, in this blog post, we will look into some valuable functionalities provided by Django.\n\nWe will also provide some best practices to keep in mind when writing our queries and how we can combine them to maximize the efficiency of our application.\n\nA queryset is a collection of data from the database. The Django ORM allows us to easily make queries in Python without the need of using the SQL language.\n\nQuerysets are lazy, meaning that just creating a queryset does not trigger any database hits. You can add filters and modify the same queryset many times, but it will only access the database once it needs to be evaluated.\n\nIn this example, even though we create and manipulate the queryset more than once, the only time when Django accesses the database is in the print function.\n\nEach queryset contains a cache to minimize database access:\n• The first time the queryset is evaluated (the first time we hit the database with that queryset), the cache is empty; after that, Django saves the result.\n• If the queryset is again evaluated, the cache will be used instead of hitting the database.\n\nDjango provides an explain function that shows the execution plan of the queryset:\n\nThis is useful when you want to analyze queries that you may need to optimize.\n\nBest practices for using Querysets\n\nThe following is a list of good practices to take into consideration to be efficient when using querysets:\n• Try to reduce the number of hits to the database as much as possible.\n• When working on data from queries, try to make the database do as much work as possible instead of handling that work yourself with python code (sorting, comparing fields, etc.).\n• If you know what fields you will need, try to fetch only those fields instead of all of them for each instance.\n• Don’t trigger hits to the database if it’s not necessary (for example, to get an empty queryset).\n• Create a database index for any unique field you know you will frequently use to search instances.\n• If you are working not only with a particular model instance but also with instances of models related to it, see if you can use [.c-inline-code]select_related[.c-inline-code] and [.c-inline-code]prefetch_related[.c-inline-code] to improve your queries.\n• When you have an instance of a given model A in memory, and you want to access the id of a related model instance (let’s call it model B), use [.c-inline-code]instance_a.instance_b_id[.c-inline-code] instead of [.c-inline-code]instance_a.instance_b.id[.c-inline-code]. Why? When you define a foreign key from A to B, you already have the id of the model B instance in the model A table as an attribute. In the next section, we will explain this a little bit more.\n• For updating/creating multiple instances of a Model, it’s better to do it as a bulk operation by using [.c-inline-code]bulk_update[.c-inline-code] or [.c-inline-code]bulk_create[.c-inline-code], respectively, instead of one by one. Consider that using these functions doesn’t trigger the save or create methods, so any custom code in those methods will not be executed.\n\nNext, we will show a defined reality and introduce examples for all concepts. After that, we will go into more detail regarding best practices.\n\nOur reality example here is the Target app:\n• Users register in the system with their email.\n• They also have optional data: name, username, date of birth, and zodiac sign.\n• They can create/update at most ten targets on an actual map.\n• Each target has a title, topic, radius in meters, and location.\n• When a user creates a target in the map in a given location with a given radius, the system checks if there are other targets from other users that have the same topic and intersecting area. If that happens, a match is created between those owner users. The app then allows them to know each other.\n• Each user has a list of matched users (that user has at least one match with him).\n\nThe following is an example image of matching targets with the intersecting area and the same topic:\n\nThe following is a simple diagram showing the models and relationships:\n\nHere are the models defined from reality example:\n\nTo see what SQL query is going to be executed for a particular Django queryset you have two options (both require you to launch a python console using [.c-inline-code]python manage.py shell[.c-inline-code] or [.c-inline-code]python manage.py shell_plus[.c-inline-code] if you have the django-extensions library installed):\n\nYou can use either [.c-inline-code]print(queryset.query)[.c-inline-code] or [.c-inline-code]str(queryset.query)[.c-inline-code]:\n\nOption 2 (the Django DEBUG setting must be set to True)\n\nYou can use the queries attribute of the connection module from [.c-inline-code]django.db[.c-inline-code]:\n\nconnection.queries will display a list of dictionaries with the following keys:\n• sql, whose value is the SQL statement\n• time, whose value is how long the statement took to execute (in seconds)\n\nAll queries executed since the start of the session will be listed; it doesn't matter when the connection module was imported. If at any point you want to clear the queries list, you can use the [.c-inline-code]reset_queries[.c-inline-code] function:\n\nUsing these tools, you can also count how many hits to the database a particular queryset triggers. You can do this by looking at the difference in the value of [.c-inline-code]len(connection. queries)[.c-inline-code] before and after the queryset is executed, or by clearing the queryset list and then looking at the importance of [.c-inline-code]len(connection.queries)[.c-inline-code] after evaluating the queryset.\n\nAs a rule of thumb, if you only want to know how many elements are in a queryset, it's best to use the queryset count function instead of using [.c-inline-code]len(queryset)[.c-inline-code], except if the queryset was already evaluated. In that case, the count will return the len of the queryset's cached value).\n\nFor example, let's try to fetch how many users we have in our database:\n\nAs you can see, using [.c-inline-code]len(queryset)[.c-inline-code] first evaluates the queryset, so it fetches all the users and then calculates the length of the collection.\n\nIn contrast, when using the count function, the users are counted at the database level, which is more efficient memory-wise since you avoid every user instance being loaded into memory and is also generally faster.\n\nSometimes, you may want to use only a specific subset of fields from a model. In those cases, it may be a good idea to only get those fields for every row in the database, so you avoid fetching and loading into memory data that you will not use.\n\nAs how there are many options. Using our previous example with the user model, let’s say you want to retrieve only the id and email fields; you could use:\n\nAs you can see, all the options presented execute the same SQL statement under the hood. The difference is that one returns a list of dictionaries and the other a list of tuples, with the last one a list of model instances.\n\nIt’s worth noting that you can still access fields other than id and email in the instances fetched with only, but a different SQL query will be triggered specifically to fetch the value of that field if you do so.\n\nIn case you want to select all the fields except a minor subset of them, you can use defer.\n\nIn some specific cases, you could need an empty queryset, and a natural solution for this would be to make a queryset using a filter with the condition that no model instances could meet.\n\nThis would not be the best way since you could still hit the database at least once to evaluate the queryset.\n\nThe best way would be using the querysets none function, which provides you with an empty queryset without triggering any database hits. But, if you need to use a filter to generate your empty queryset, you can use the condition [.c-inline-code]pk__in=[][.c-inline-code], any model instance can’t meet this condition, and the ORM is smart enough to realize this and not make any hits to the database.\n\nWhen a model A has a [.c-inline-code]ForeignKey[.c-inline-code] field to a model B, every instance of A has a field called [.c-inline-code]b_id[.c-inline-code] (name derived from the name of the related model in snake case + the word “id”).\n\nSo, when we fetch an instance of A from the database we already have the id of its related B instance available. One can wonder if there is a difference then between using [.c-inline-code]a.b_id[.c-inline-code] and [.c-inline-code]a.b.id[.c-inline-code].\n\nLet’s try with an example from our reality:\n\nAs we can see, when accessing the user id through [.c-inline-code]target.user_id[.c-inline-code], we trigger no SQL query since this value is part of the data we fetched from the database when we retrieved our target instance. But, when accessing target.user.id, we trigger a new SQL query to retrieve every field of the related user (unless you use the [.c-inline-code]select_related[.c-inline-code] function).\n\nAs mentioned before, when working with several instances, it’s better to use bulk operations to reduce the number of hits to the database.\n\nAs an example, if we want to create several users, we can do the following:\n\nThis works but we are hitting the database 3 times. With [.c-inline-code]bulk_create[.c-inline-code], we can do the very same thing hitting only once, defining a list of objects:\n\nIn the same way, we can use [.c-inline-code]bulk_update[.c-inline-code], but in this case, we must have a list of user objects already created in the database. Suppose we want this for each user that has a name but doesn’t have a username:\n• Get the name, remove spaces, and transform it to lowercase. This value will be the username.\n• As an example, if the user’s name is John Doe, then we want the username to be johndoe.\n\nThis is a solution to get this done:\n• The list of modified objects that you want to update. These objects already exist in the database and you have changed at least one field.\n• The list of columns that you have changed in the objects.\n• When using [.c-inline-code]bulk_create[.c-inline-code] and [.c-inline-code]bulk_update[.c-inline-code], the model’s save function is not executed.\n• accepts a [.c-inline-code]batch_size[.c-inline-code] param in case the list of objects to create is too big. This param splits the bulk creation in more hits to the database but helps to avoid very big SQL queries.\n• if updates fields defined on multi-table inheritance ancestors will generate an extra query per ancestor.\n• if updates a large number of columns in a large number of rows, the SQL generated can be very large. Avoid this by adding a suitable [.c-inline-code]batch_size[.c-inline-code] param to the function. This is analogous to [.c-inline-code]batch_size[.c-inline-code] in [.c-inline-code]bulk_create[.c-inline-code]\n\nIn this section, we will describe different queries examples to show efficient ways of addressing them. We will describe each case in natural language, then present the queryset and finally show the resultant SQL query.\n\nAs mentioned, if possible it's recommended to delegate computations to the database instead of doing them directly in memory.\n\nF expressions help us to do precisely that, allowing us to reference database fields and letting the database handle operations with that value.\n\nFor example in the following query:\n\nFilters all targets that have an updated_at value posterior to their created_at value, but the value of updated_at is never loaded into memory, it's just referenced so the database can use it in the comparison:\n\nAs we can see in the generated SQL:\n\nAnother use of F expressions can be for updating database rows. For example, if we wanted to increase the [.c-inline-code]created_at[.c-inline-code] value for all rows by 3 days, we could retrieve all instances, modify the attribute value, and save all instances.\n\nThis would require at least 2 hits to the database, but using F expressions we can do it in just one:\n\nThis generates the following SQL query:\n\nQ objects represent conditions that can be used in database queries. They are helpful not only because they let you reuse conditions in multiple questions but also because they can be combined to express complex conditions.\n\nA common use case for Q objects is defining an OR condition for a filter. As an example, let’s retrieve the targets whose topic is “Sports” or that contains the word sport in their title:\n\nThe generated SQL is as follows:\n\nImagine if we need to print for each target: the target title, and then the email of the corresponding owner user. This can be a solution:\n\nThis is a working solution, but how many times does it access the database? Imagine that N is the number of targets in the system:\n• Accesses one time to get all the targets ([.c-inline-code]Target.objects.all() : 1[.c-inline-code])\n• For each target accesses one time to get the email of the owner user ([.c-inline-code]target.user.email : N[.c-inline-code])\n• To get the title doesn’t need to access the database because it’s brought in the first query.\n\nThat is a total of N + 1 hits. As mentioned, it’s important to reduce the number of hits to the database. If N is a huge number, then we are accessing it a lot of times and this will generate a performance issue. This is known as the N + 1 problem.\n\nLet’s look at a way of addressing this with [.c-inline-code]select_related[.c-inline-code] and [.c-inline-code]prefetch_related[.c-inline-code].\n\nLet’s see the definition in Django docs:\n\nThis returns a [.c-inline-code]QuerySet[.c-inline-code] that will “follow” foreign-key relationships, selecting additional related-object data when it executes its query. This performance booster results in a single, more complex question but means later use of foreign-key relationships won’t require database queries.\n\nContinuing the example, the solution would be this:\n\nNow, the output is the same as before, but we only access the database once with this solution. That is because [.c-inline-code]select_related[.c-inline-code] brought in the same query, each user's email. We can use [.c-inline-code]selected_related[.c-inline-code] with foreign-key and one-to-one relationships fields. Let’s see now how to do this when we have many-to-many relationships.\n\nNow we need to print for each user: the user id and the emails of the related users that matched with him (remember we have the [.c-inline-code]mateched_users[.c-inline-code] relationship). Let’s see the definition in the Django docs:\n\nThis returns a [.c-inline-code]QuerySet[.c-inline-code] that will automatically retrieve, in a single batch, related objects for each of the specified lookups.\n\nSo, it has the same purpose as [.c-inline-code]select_related[.c-inline-code] but it has a different strategy. The solution to the mentioned problem using the function is this:\n\nThis function accesses two times to the database:\n• One time to get all the users ([.c-inline-code]User.objects.all() : 1[.c-inline-code]).\n• A second time to get the matched users of each user ([.c-inline-code].prefetch_related(\"matched_users\") : 1[.c-inline-code]).\n\nIf we didn't use the [.c-inline-code]prefetch_related[.c-inline-code] function in the previous solution, we would have the database accessed N + 1 times (being N the number of users in the system).\n• select_related solves the N + 1 problem accessing only one time to the database. It’s used for foreign-key and one-to-one relationships fields.\n• prefetch_related solves the N + 1 problem accessing only two times to the database. It’s used for many-to-many relationships fields."
    },
    {
        "link": "https://forum.djangoproject.com/t/structuring-large-complex-django-projects-and-using-a-services-layer-in-django-projects/1487",
        "document": "Weekend hot take: “hide data access behind a service layer is the write getter/setter methods wrapping private attributes of web application architecture. Which is to say, both can solve niche problems you might not have, but are wrongly promoted as universal best practices.”"
    },
    {
        "link": "https://stackoverflow.com/questions/10155517/repository-pattern-vs-orm",
        "document": "What good is a repository pattern when you have an ORM?\n\nExample. Suppose i have the following (fictional) tables:\n\nNow with an orm i could simply put this in a model file:\n\nNow $user is already my object, which could easily be lazy loaded:\n\nNow with the Repository pattern i'd had to create a repository for the Users and one for the Roles. The repository also needs all kinds of functions to retrieve data for me and to store it. Plus it needs to work with Entity models. So i have to create all of those too.\n\nTo me that looks like alot of stuff do... When i could simply get the data like i described above with an ORM. And i could store it just as easy:\n\nIn this case it would not only store the user object to the database, but also any changes i made to the 'Roles' object aswell. So no need for any extra work like you need with the repository pattern...\n\nSo my question basically is, why would i want to use a repository pattern with an ORM? I've seen tutorials where to use that pattern (like with Doctrine). But it really just doesn't make any sense to me... Anyone any explanation for its use in combination with an ORM..??"
    }
]