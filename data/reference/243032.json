[
    {
        "link": "https://learn.microsoft.com/en-us/office/vba/api/excel.range.calculate",
        "document": "Calculates all open workbooks, a specific worksheet in a workbook, or a specified range of cells on a worksheet, as shown in the table in the Remarks section.\n\nThis example calculates the formulas in columns A, B, and C in the used range on Sheet1.\n\nHave questions or feedback about Office VBA or this documentation? Please see Office VBA support and feedback for guidance about the ways you can receive support and provide feedback."
    },
    {
        "link": "https://learn.microsoft.com/et-ee/office/vba/api/excel.range.calculate",
        "document": "Calculates all open workbooks, a specific worksheet in a workbook, or a specified range of cells on a worksheet, as shown in the table in the Remarks section.\n\nThis example calculates the formulas in columns A, B, and C in the used range on Sheet1.\n\nHave questions or feedback about Office VBA or this documentation? Please see Office VBA support and feedback for guidance about the ways you can receive support and provide feedback."
    },
    {
        "link": "https://learn.microsoft.com/en-us/office/vba/api/excel.range(object)",
        "document": "Represents a cell, a row, a column, a selection of cells containing one or more contiguous blocks of cells, or a 3D range.\n\nThe default member of Range forwards calls without parameters to the Value property and calls with parameters to the Item member. Accordingly, is equivalent to , to and to .\n\nThe following properties and methods for returning a Range object are described in the Example section:\n• Range and Cells properties of the Worksheet object\n• Range and Cells properties of the Range object\n• Rows and Columns properties of the Worksheet object\n• Rows and Columns properties of the Range object\n\nUse Range (arg), where arg names the range, to return a Range object that represents a single cell or a range of cells. The following example places the value of cell A1 in cell A5.\n\nThe following example fills the range A1:H8 with random numbers by setting the formula for each cell in the range. When it's used without an object qualifier (an object to the left of the period), the Range property returns a range on the active sheet. If the active sheet isn't a worksheet, the method fails.\n\nUse the Activate method of the Worksheet object to activate a worksheet before you use the Range property without an explicit object qualifier.\n\nThe following example clears the contents of the range named Criteria.\n\nUse Cells on a worksheet to obtain a range consisting all single cells on the worksheet. You can access single cells via Item(row, column), where row is the row index and column is the column index. Item can be omitted since the call is forwarded to it by the default member of Range. The following example sets the value of cell A1 to 24 and of cell B1 to 42 on the first sheet of the active workbook.\n\nThe following example sets the formula for cell A2.\n\nAlthough you can also use to return cell A1, there may be times when the Cells property is more convenient because you can use a variable for the row or column. The following example creates column and row headings on Sheet1. Be aware that after the worksheet has been activated, the Cells property can be used without an explicit sheet declaration (it returns a cell on the active sheet).\n\nUse_expression_.Cells, where expression is an expression that returns a Range object, to obtain a range with the same address consisting of single cells. On such a range, you access single cells via Item(row, column), where are relative to the upper-left corner of the first area of the range. Item can be omitted since the call is forwarded to it by the default member of Range. The following example sets the formula for cell C5 and D5 of the first sheet of the active workbook.\n\nUse Range (cell1, cell2), where cell1 and cell2 are Range objects that specify the start and end cells, to return a Range object. The following example sets the border line style for cells A1:J10.\n\nUse Rows on a worksheet to obtain a range consisting all rows on the worksheet. You can access single rows via Item(row), where row is the row index. Item can be omitted since the call is forwarded to it by the default member of Range.\n\nThe following example deletes row 5 and 10 of the first sheet of the active workbook.\n\nUse Columns on a worksheet to obtain a range consisting all columns on the worksheet. You can access single columns via Item(row) [sic], where row is the column index given as a number or as an A1-style column address. Item can be omitted since the call is forwarded to it by the default member of Range.\n\nThe following example deletes column \"B\", \"C\", \"E\", and \"J\" of the first sheet of the active workbook.\n\nUse_expression_.Rows, where expression is an expression that returns a Range object, to obtain a range consisting of the rows in the first area of the range. You can access single rows via Item(row), where row is the relative row index from the top of the first area of the range. Item can be omitted since the call is forwarded to it by the default member of Range.\n\nThe following example deletes the ranges C8:D8 and C6:D6 of the first sheet of the active workbook.\n\nUse_expression_.Columns, where expression is an expression that returns a Range object, to obtain a range consisting of the columns in the first area of the range. You can access single columns via Item(row) [sic], where row is the relative column index from the left of the first area of the range given as a number or as an A1-style column address. Item can be omitted since the call is forwarded to it by the default member of Range.\n\nThe following example deletes the ranges L2:L10, G2:G10, F2:F10 and D2:D10 of the first sheet of the active workbook.\n\nUse Offset (row, column), where row and column are the row and column offsets, to return a range at a specified offset to another range. The following example selects the cell three rows down from and one column to the right of the cell in the upper-left corner of the current selection. You cannot select a cell that is not on the active sheet, so you must first activate the worksheet.\n\nUse Union (range1, range2, ...) to return multiple-area ranges—that is, ranges composed of two or more contiguous blocks of cells. The following example creates an object defined as the union of ranges A1:B2 and C3:D4, and then selects the defined range.\n\nIf you work with selections that contain more than one area, the Areas property is useful. It divides a multiple-area selection into individual Range objects and then returns the objects as a collection. Use the Count property on the returned collection to verify a selection that contains more than one area, as shown in the following example.\n\nThis example uses the AdvancedFilter method of the Range object to create a list of the unique values, and the number of times those unique values occur, in the range of column A.\n\nHave questions or feedback about Office VBA or this documentation? Please see Office VBA support and feedback for guidance about the ways you can receive support and provide feedback."
    },
    {
        "link": "https://blog.coupler.io/excel-vba-range",
        "document": "Ranges are a key concept in Excel, and knowing how to work with them is essential for anyone who wants to program or automate their work using Excel VBA.\n\nIn this tutorial, we’ll take a look at how to work with Excel ranges in VBA. We’ll start by discussing what a Range object is. Then, we’ll look at the different ways of referencing a range. Lastly, we’ll explore various examples of how to work with ranges using VBA code.\n\nThe Excel VBA Range object is used to represent a range in a worksheet. A range can be a cell, a group of cells, or even all the 17,179,869,184 cells in a sheet.\n\nWhen programming with Excel VBA, the Range object is going to be your best friend. That’s because much of your work will focus on manipulating data within sheets. Understanding how to work with the Range object will make it easier for you to perform various actions on cells, such as changing their values, sorting, or doing a copy-paste.\n\nThe following is the Excel object hierarchy:\n\n\n\nYou can see that the Excel VBA Range object is a property of the Worksheet object. This means that you can access a range by specifying the name of the sheet and the cell address you want to work with. When you don’t specify a sheet name, by default Excel will look for the range in the active sheet. For example, if Sheet1 is active, then both of these lines will refer to the same cell range:\n\nLet’s have a closer look at how to reference a range in the section below.\n\nReferring to a Range object in Excel VBA can be done in several ways. We’ll discuss the basic syntax and some alternatives that you might want to use, depending on your needs.\n\nTo refer to a range that consists of one cell, for example, cell D5, you can use the syntax below:\n\nTo refer to a range of cells, you have two acceptable syntaxes. For example, A1 through D5 can be specified using any one below:\n\nTo refer to a range outside the active sheet, you need to include the worksheet name. Here’s an example:\n\nTo refer to an entire row, for example, Row 5:\n\nTo refer to an entire column, for example, Column D:\n\nExcel VBA also allows you to refer to multiple ranges at once by using a comma to separate each area. For example, see the below syntax used for referring to all ranges shown in the image:\n\nYou have probably already used named ranges in your worksheets. They can be found under Name Manager in the Formulas tab.\n\nTo refer to a range named MyRange, use the following code:\n\nRemember to enclose the range’s name in double quotes. Otherwise, Excel thinks that you’re referring to a variable.\n\nAlternatively, you can also use the shortcut syntax discussed previously. In this case, double quotes aren’t used:\n\nAnother way to refer to a range is by using the Cells property. This property takes two arguments:\n\nYou must use a numeric value for Row, but you may use either a numeric or string value for Column. Both of these lines refer to cell D5:\n\nThe advantage of using the Cells property to refer to ranges becomes clear when you need to loop through rows or columns. You can create a more readable piece of code by using variables as the Cells arguments in a looping.\n\nThe Offset property provides another handy means for referring to ranges. It allows you to refer to a cell based on the location of another cell, such as the active cell.\n\nLike the Cells property, the Offset property has two parameters. The first determines how many rows to offset, while the second represents the number of columns to offset. Here is the syntax:\n\nFor example, the following code refers to cell D5 from cell A1:\n\nThe negative numbers refer to cells that are above or below the range of values. For example, a -2 row offset refers to two rows above the range, and a -1 column offset refers to a column to the left of the range. The following example refers to cell A1:\n\nIf you need to go over only a row or a column, but not both, you don’t have to enter both the row and the column parameters. You can also use 0 as one or both of the arguments. For example, the following lines refer to D5:\n\nLet’s take a look at some of the most common range examples. These examples will show you how to use VBA to select and manipulate ranges in your worksheets. Some of these examples are complete procedures, while others are code snippets that you can just copy-paste to your own Sub to try.\n\nTo select a range of cells, use the Select method.\n\nThe following line selects a range from A1 to D5 in the active worksheet:\n\nTo select a range from A1 to the active cell, use the following line:\n\nThe following code selects from the active cell to 3 rows below the active cell and five columns to the right:\n\nIt’s important to note that when you need to select a range on a specific worksheet, you need to ensure that the correct worksheet is active. Otherwise, an error will occur. For example, you want to select B2 to J5 on Sheet1. The following code will generate an error if Sheet1 is not active:\n\nInstead, use these two lines of code to make your code work as expected:\n\nThe following statement sets a value of 100 into cell C7 of the active worksheet:\n\nThe Value property allows you to represent the value of any cell in a worksheet. It’s a read/write property, so you can use it for both reading and changing values.\n\nYou can also set values of a range of any size. The following statement enters the text “Hello” into each cell in the range A1:C7 in Sheet2:\n\nValue is the default property for a Range object. This means that if you don’t provide any properties in your range, Excel will use this Value property.\n\nBoth of the following lines enter a value of 100 into cell C7 of the active worksheet:\n\nTo copy and paste a range in Excel VBA, you use the Copy and Paste methods. The Copy method copies a range, and the Paste method pastes it into a worksheet. It might look a bit complicated but let’s see what each does with an example below.\n\nLet’s say you have Orders data, as shown in the below screenshot, which is imported from Airtable every day using Coupler.io. This tool allows users to do it automatically on the schedule they want with just a few clicks and no coding required.\n\nIn addition, they can combine data from other different sources (such as Jira, Mailchimp, etc.) into one destination for analysis purposes.\n\nAs you can see, the data starts from B2. You want to copy only range B2:C11 and paste them to Sheet2 at the same address. The following is an example Sub you can use:\n\nAlternatively, you can also use a single line of code as shown below:\n\nThe above Sub procedure takes advantage of the fact that the Copy method can use an argument that corresponds to the destination range for the copy operation. Notice that actually, you don’t have to select a range before doing something with it.\n\nIn many cases, you may need to copy a range of cells but don’t know exactly how many rows and columns it has. For example, if you use Coupler.io or other integration tools to import data from an external app into Excel on a daily schedule, the number of rows may change over time.\n\nHow can you determine this dynamic range? One solution is to use the CurrentRegion property. This property returns an Excel VBA Range object within its boundaries. As long as the data is surrounded by one empty row and one empty column, you can select it with CurrentRegion.\n\nThe following line selects the contiguous range around Cell B2:\n\nNow, let’s say you want to select only Columns B and C of the range, and from the second row, you can use the following line:\n\nYou can now do whatever you want with your selected range — copy or move it to another sheet, format it, and so on.\n\nIf you want to find the last row of a used range using Excel VBA, it’s also possible without selecting anything. Here’s the line you can use to find the row number of Column B’s last row data:\n\nExcel VBA: Loop for each cell in a range\n\nFor looping each cell in a range, the For Each loop is an excellent choice. This type of loop is great for looping through a collection of objects such as cells in a range, worksheets in a workbook, or other collections.\n\nThe following procedure shows how to loop through each cell in Range B2:K11. We use an object variable named Obj, which refers to the cell being processed. Within the loop, the code checks if the cell contains a formula and then sets its color to blue.\n\nExcel VBA: Loop for each row in a range\n\nWhen looping through rows (or columns), you can use the Cells property to refer to a range of cells. This makes your code more readable compared to when you’re using the Range syntax.\n\nFor example, to loop for each row in range B2:K11 and bold all the cells from Column I to K, you might write a loop like this:\n\nInstead of typing in a range address, you can use the Cells property to make the loop easier to read and write. For example, the code below uses the Cells and Resize properties to find the required cell based on the active cell:\n\nThere are three ways to clear a range in Excel VBA.\n\nThe first is to use the Clear method, which will clear the entire range, including cell contents and formatting.\n\nThe second is to use the ClearContents method, which will clear the contents of the range but leave the formatting intact.\n\nThe third is to use the ClearFormats method, which will clear the formatting of the range but leave the contents intact.\n\nFor example, to clear a range B1 to M15, you can use one of the following lines of code below, based on your needs:\n\nWhen deleting a range, it differs from just clearing a range. That’s because Excel shifts the remaining cells around to fill up your deleted range.\n\nThe code below deletes Row 5 using the Delete method:\n\nTo delete a range that is not a complete row or column, you have to provide an argument (such as xlToLeft, xlUp — based on your needs) that indicates how Excel should shift the remaining cells.\n\nFor example, the following code deletes cell B2 to M10, then fills the resulting gap by shifting the other cells to the left:\n\nYou can also use a VBA code to delete rows with a specific condition. For example, let’s try to delete all the rows with a discount of 0 from the below sheet:\n\nHere’s an example Sub you may want to use:\n\nThe above code loops from Row 3 to 11. In each loop, it checks the discount value in Column F and removes the entire row if the value equals 0.\n\nWith the below data, suppose you want to find if there is an order with OrderNumber equal to 1003320 and output its cell address.\n\nYou can use the Find method in this case, as shown in the below code:\n\nThe output of the above code will be the first occurrence of the search value in the specified range. If the value is not found, a message box showing info that the order is not found will appear.\n\nThe following is an example of a Sub that adds alphabets A-Z in a range. The code uses Offset to refer to a cell below the active cell in a loop.\n\nTo use the Sub, ѕеlесt a сеll where you want tо start thе alphabets. Then, run it by pressing F5. The code will insert A-Z to the cells downward.\n\nExcel VBA: Add auto-numbers to a range with a variable from user input\n\nJuѕt lіkе inserting alphabets as shown in the previous example, you саn аlѕо іnѕеrt auto-numbers іn уоur worksheet automatically. This can be helpful when you work with large data.\n\nThe following is an example of a Sub that adds auto-numbers to your Excel sheet:\n\nTо uѕе the соdе, уоu need tо ѕеlесt the сеll frоm where you want tо start thе auto-numbеrѕ. Then, run the Sub. In the message box that appears, enter the maximum value for the auto-numbers and сlісk OK.\n\nImagine that you have written a Sub procedure to import Orders.csv into an Excel sheet:\n\nYou want to sum up all the discount values and put the result in J12. The following code that utilizes the Sum worksheet function would handle that:\n\nThe Sort method sorts values in a range based on the criteria you provide.\n\nSuppose you have the following sheet:\n\nTo sort the above data based оn thе vаluеѕ іn Column D, you can use the following code:\n\nYou can also sort the range by multiple columns. For example, to sort by Column B and Column D, here’s an example code you can use:\n\nHere are the arguments used in the above methods:\n• Kеу: It specifies the field you want to use in ѕоrting thе data.\n• Ordеr: It ѕресіfies whеthеr уоu wаnt tо sort the dаtа іn аѕсеndіng or dеѕсеndіng order.\n\nArrays are powerful because they can actually make the code run faster. Especially when working with large data, you can use arrays to make all the processing happen in memory and then write the data to the sheet once.\n\nFor example, suppose you have the following sheet:\n\nThe following Sub uses a variable X, which is a Variant data type, to store the value of Range A2:E10. Variants can hold any type of data, including arrays.\n\nYou can then treat the X variable as though it were an array. The following line returns the value of cell A6:\n\nNow, let’s say you want to calculate the total order using the following calculation:\n\nRather than doing calculation and writing the result for each row using a looping, you can store the calculation result in an array OrderTotal as shown in the below code and write the result once:\n\nThis error message often happens when you try to access a range of cells in a worksheet that has been deleted or renamed.\n\nLet’s say your code expected a worksheet named Setting. For some reason, this sheet is renamed Settings. So, the error occurs every time the below Sub runs:\n\nTo prevent the runtime error happening again, you may want to add an error handler code like this below:\n\nThank you for reading our Excel VBA Range tutorial. We hope that you’ve found it helpful! And if there’s anything else about Excel programming or other topics that interest you, be sure to check out our other Excel tutorials.\n\nIn addition, you may find that Coupler.io is a valuable tool for you if you’re looking for an easy way to pull and combine your data from multiple sources into one destination for analysis and reporting. This tool also lets you specify the range address of your imported data so you can keep all of your calculations (including. formulas) in the sheets.\n\nThanks again for reading, and happy coding!"
    },
    {
        "link": "https://github.com/MicrosoftDocs/VBA-Docs/blob/master/api/Excel.Range.Calculate.md",
        "document": "Calculates all open workbooks, a specific worksheet in a workbook, or a specified range of cells on a worksheet, as shown in the table in the Remarks section.\n\nThis example calculates the formulas in columns A, B, and C in the used range on Sheet1."
    },
    {
        "link": "https://techcommunity.microsoft.com/discussions/excelgeneral/9-quick-tips-to-improve-your-vba-macro-performance/173687",
        "document": "As part of our work to help enterprises upgrade to Office 365 ProPlus, we have found that some users have been experiencing slow running VBA, which can be frustrating. The good news is that there are steps which can be taken to improve performance.\n\nThis post aims to raise awareness of the steps that you can take to improve the performance of your macros, whether you are an end user, IT admin, or developer. We’ve collected the following steps from blog posts, Microsoft field engineers, and Microsoft MVPs like Charles Williams and Jan Karel Pieterse.\n\n1. Turn off everything but the essentials in VBA\n\nOne of the first things to do when speeding up VBA code is to turn off unnecessary features such as animations, screen updating, automatic calculations and events while your macro is running. These features can add extra overhead and slow down the macro, particularly if the macro is modifying many cells and triggering lots of screen updates and recalculations.\n\nThe below code sample shows you how to enable/disable:\n\nAnimations can be disabled across Windows by accessing the Ease of Access Center.\n\nAnimations can be disabled in Excel specifically, under the Advanced or Ease of Access tab, within the File > Options menu.\n\nPlease see the following link for more information: https://support.office.com/en-us/article/turn-off-office-animations-9ee5c4d2-d144-4fd2-b670-22cef9fa025a\n\nOffice animations can be disabled across multiple computers by setting the appropriate registry key via a group policy setting.\n\nWarning: Using Registry Editor incorrectly can cause serious, system-wide problems that may require you to re-install Windows to correct them. Microsoft cannot guarantee that any problems resulting from the use of Registry Editor can be solved. Use this tool at your own risk.\n\nThe select method is common to see in VBA code, however it is often added to the macro where it isn’t needed. Select can trigger cell events such as animations and conditional formatting which slow the macro down, so removing unnecessary selects can significantly speed up your macro.\n\nThe following example shows the code before and after making the change to remove unnecessary selects.\n\n5. Using the With statement to read object properties\n\nWhen working with objects, use the With statement to reduce the number of times object properties are read. The following example shows the code before and after making the change to use the With statement.\n\nReading and writing to cells in Excel from VBA is expensive. There is an overhead that is incurred every time data moves between VBA and Excel.\n\nThe mountain between Excel and VBA\n\nThis means that you should try to reduce the number of times you pass data between VBA and Excel. This is where ranges are useful. Instead of reading and writing to each cell individually in a loop, read the entire range into an array at the start, loop through the array, and then write the entire array back at the end. The following example code shows how a range can be used to read and write the values once, instead of reading each cell individually.\n\n7. Use .Value2 instead of .Text or .Value\n\nThere are different ways that you can retrieve values from a cell, and which property you use can make a different in the performance of your code.\n\n.Text is commonly used to retrieve the value of a cell – it returns the formatted value of a cell. Getting the formatting of a cell is more complex than just retrieving a value, and makes .Text quite slow.\n\n.Value is an improvement over .Text, as this mostly gets the value from the cell, without formatting. However for cells formatted as a date or currency, .Value will return a VBA date or VBA currency (which may truncate decimal places).\n\n.Value2 gives the underlying value of the cell. As it involves no formatting, .Value2 is faster than .Value. .Value2 is faster than .Value when processing numbers (there is no significant difference with text), and is much faster using a variant array.\n\nFor a more detailed explanation, please see Charles William’s blog post, “TEXT vs VALUE vs VALUE2”: https://fastexcel.wordpress.com/2011/11/30/text-vs-value-vs-value2-slow-text-and-how-to-avoid-it/\n\nWhen you use the Macro Recorder to record operations that use copy and paste, the code will use the copy and paste methods by default. However, within VBA code, it is much faster to bypass the clipboard and use internal operations instead. By default, copying will copy everything, including formulas, values and formatting. You can make copying faster by only copying values or formulas, without the formatting. The following example shows the code before and after making the change to bypass the clipboard.\n\nIf you still find that a macro takes longer than expected to execute many individual copy and paste operations, you may want to apply the following hot fix: https://support.microsoft.com/en-in/help/2817672/macro-takes-longer-than-expected-to-execute-many-individual-copy-and-p\n\nOption Explicit is one of the available Module directives in VBA that instructs VBA how to treat the code within the code module. Setting Option Explicit requires all variables to be declared and will give compile errors if an undeclared variable is used. This helps catch incorrectly typed variable names and improves performance with all variable types being defined at compile time, instead of being inferred at runtime.\n\nThis can be set by typing: Option Explicit at the top of each module in your project or by checking the \"Require Variable Declaration\" option under Tools -> Options in the VBA editor.\n\nAdditional Details on Module directives can be found here: https://docs.microsoft.com/en-us/dotnet/visual-basic/language-reference/statements/option-explicit-statement\n\nWe hope that this has helped highlight some of the ways that you can make your macros run faster. We’re sure that we haven’t covered everything, so please comment below with any other tips or tricks to improve the performance of your macros in Excel.\n\nAfter using the new macro animations stopped working/it’s stuck on manual calculation.\n\nIt is possible the code disables the various settings, but the macro crashes before re-enabling these settings. To fix this, you will need to run the code to enable these settings again.\n\nhttps://www.thespreadsheetguru.com/blog/2015/2/25/best-way-to-improve-vba-macro-performance-and-prevent-slow-code-execution - The Best Way To Improve VBA Macro Performance And Prevent Slow Code Execution\n\nCharles Williams founded Decision Models in 1996 to provide advanced consultancy, decision support solutions, and tools based on Microsoft Excel and relational databases. Charles is the author of FastExcel, the widely used Excel performance profiler and performance toolset, and co-author of Name Manager, the popular utility for managing defined names. For more information about Excel calculation performance and methods, memory usage, and VBA user-defined functions, visit the Decision Models Web site.\n\nJan Karel Pieterse is a long time Excel MVP who develops custom solutions focused on Microsoft Office, with deep expertise in Excel and VBA. He runs the website JKP Application Development Services site, where you can find an interesting collection of articles, training events, and utilities. For a good overview of topics, see this list of in-depth articles. Jan develops some cool and useful utilities for Excel, including NameManager, RefTreeAnalyser, and Flexfind. You can find a full list on the downloads page."
    },
    {
        "link": "https://learn.microsoft.com/en-us/office/vba/excel/concepts/excel-performance/excel-tips-for-optimizing-performance-obstructions",
        "document": "Follow these tips for optimizing many frequently occurring performance obstructions in Excel.\n\nLearn how to improve performance related to types of references and links.\n\nDo not use forward referencing and backward referencing\n\nTo increase clarity and avoid errors, design your formulas so that they don't refer forward (to the right or below) to other formulas or cells. Forward referencing usually does not affect calculation performance, except in extreme cases for the first calculation of a workbook, where it might take longer to establish a sensible calculation sequence if there are many formulas that need to have their calculation deferred.\n\nMinimize use of circular references with iteration\n\nCalculating circular references with iterations is slow because multiple calculations are needed, and these calculations are single-threaded. Frequently you can \"unroll\" the circular references by using algebra so that iterative calculation is no longer needed. For example, in cash flow and interest calculations, try to calculate the cash flow before interest, calculate the interest, and then calculate the cash flow including the interest.\n\nExcel calculates circular references sheet-by-sheet without considering dependencies. Therefore, you usually get slow calculation if your circular references span more than one worksheet. Try to move the circular calculations onto a single worksheet or optimize the worksheet calculation sequence to avoid unnecessary calculations.\n\nBefore the iterative calculations start, Excel must recalculate the workbook to identify all the circular references and their dependents. This process is equal to two or three iterations of the calculation.\n\nAfter the circular references and their dependents are identified, each iteration requires Excel to calculate not only all the cells in the circular reference, but also any cells that depend on the cells in the circular reference chain, together with volatile cells and their dependents. If you have a complex calculation that depends on cells in the circular reference, it can be faster to isolate this into a separate closed workbook and open it for recalculation after the circular calculation has converged.\n\nIt's important to reduce the number of cells in the circular calculation and the calculation time that is taken by these cells.\n\nAvoid inter-workbook links when it is possible; they can be slow, easily broken, and not always easy to find and fix.\n\nUsing fewer larger workbooks is usually, but not always, better than using many smaller workbooks. Some exceptions to this might be when you have many front-end calculations that are so rarely recalculated that it makes sense to put them in a separate workbook, or when you have insufficient RAM.\n\nTry to use simple direct cell references that work on closed workbooks. By doing this, you can avoid recalculating all your linked workbooks when you recalculate any workbook. Also, you can see the values Excel has read from the closed workbook, which is frequently important for debugging and auditing the workbook.\n\nIf you cannot avoid using linked workbooks, try to have them all open instead of closed, and open the workbooks that are linked to before you open the workbooks that are linked from.\n\nUsing many worksheets can make your workbook easier to use, but generally it is slower to calculate references to other worksheets than references within worksheets.\n\nTo save memory and reduce file size, Excel tries to store information about only the area on a worksheet that was used. This is called the used range. Sometimes various editing and formatting operations extend the used range significantly beyond the range that you would currently consider used. This can cause performance obstructions and file-size obstructions.\n\nYou can check the visible used range on a worksheet by using Ctrl+End. Where this is excessive, you should consider deleting all the rows and columns below and to the right of your real last used cell, and then saving the workbook. Create a backup copy first. If you have formulas with ranges that extend into or refer to the deleted area, these ranges will be reduced in size or changed to #N/A.\n\nWhen you frequently add rows or columns of data to your worksheets, you need to find a way of having your Excel formulas automatically refer to the new data area, instead of trying to find and change your formulas every time.\n\nYou can do this by using a large range in your formulas that extends well beyond your current data boundaries. However, this can cause inefficient calculation under certain circumstances, and it is difficult to maintain because deleting rows and columns can decrease the range without you noticing.\n\nStarting in Excel 2007, you can use structured table references, which automatically expand and contract as the size of the referenced table increases or decreases.\n\nThis solution has several advantages:\n• None Fewer performance disadvantages exist than the alternatives of whole column referencing and dynamic ranges.\n• None It's easy to have multiple tables of data on a single worksheet.\n• None Formulas that are embedded in the table also expand and contract with the data.\n\nAlternatively, use whole column and row references\n\nAn alternative approach is to use a whole column reference, for example $A:$A. This reference returns all the rows in Column A. Therefore, you can add as much data as you want, and the reference will always include it.\n\nThis solution has both advantages and disadvantages:\n• None Many Excel built-in functions (SUM, SUMIF) calculate whole column references efficiently because they automatically recognize the last used row in the column. However, array calculation functions like SUMPRODUCT either cannot handle whole column references or calculate all the cells in the column.\n• None User-defined functions don't automatically recognize the last-used row in the column and, therefore, frequently calculate whole column references inefficiently. However, it is easy to program user-defined functions so that they recognize the last-used row.\n• None It's difficult to use whole column references when you have multiple tables of data on a single worksheet.\n• None In Excel 2007 and later versions, array formulas can handle whole-column references, but this forces calculation for all the cells in the column, including empty cells. This can be slow to calculate, especially for 1 million rows.\n\nBy using the OFFSET or INDEX and COUNTA functions in the definition of a named range, you can make the area that the named range refers to dynamically expand and contract. For example, create a defined name using one of the following formulas:\n\nWhen you use the dynamic range name in a formula, it automatically expands to include new entries.\n\nUsing the INDEX formula for a dynamic range is generally preferable to the OFFSET formula because OFFSET has the disadvantage of being a volatile function that will be calculated at every recalculation.\n\nPerformance decreases because the COUNTA function inside the dynamic range formula must examine many rows. You can minimize this performance decrease by storing the COUNTA part of the formula in a separate cell or defined name, and then referring to the cell or name in the dynamic range:\n\nYou can also use functions such as INDIRECT to construct dynamic ranges, but INDIRECT is volatile and always calculates single-threaded.\n\nDynamic ranges have the following advantages and disadvantages:\n• None Dynamic ranges work well to limit the number of calculations performed by array formulas.\n• None Using many dynamic ranges can decrease performance.\n\nIn Office 365 version 1809 and later, Excel's VLOOKUP, HLOOKUP, and MATCH for exact match on unsorted data is much faster than ever before when looking up multiple columns (or rows with HLOOKUP) from the same table range.\n\nThat said, for earlier Excel versions, Lookups continue to be frequently significant calculation obstructions. Fortunately, there are many ways of improving lookup calculation time. If you use the exact match option, the calculation time for the function is proportional to the number of cells scanned before a match is found. For lookups over large ranges, this time can be significant.\n\nLookup time using the approximate match options of VLOOKUP, HLOOKUP, and MATCH on sorted data is fast and is not significantly increased by the length of the range you are looking up. Characteristics are the same as binary search.\n\nEnsure that you understand the match-type and range-lookup options in MATCH, VLOOKUP, and HLOOKUP.\n\nThe following code example shows the syntax for the MATCH function. For more information, see the Match method of the WorksheetFunction object.\n• None Matchtype=1 returns the largest match less than or equal to the lookup value when the lookup array is sorted ascending (approximate match). If the lookup array is not sorted ascending, MATCH will return an incorrect answer. The default option is approximate match sorted ascending.\n• None Matchtype=0 requests an exact match and assumes that the data is not sorted.\n• None Matchtype=-1 returns the smallest match greater than or equal to the lookup value if the lookup array is sorted descending (approximate match).\n\nThe following code example shows the syntax for the VLOOKUP and HLOOKUP functions. For more information, see the VLOOKUP and HLOOKUP methods of the WorksheetFunction object.\n• None Range-lookup=TRUE returns the largest match less than or equal to the lookup value (approximate match). This is the default option. Table array must be sorted ascending.\n• None Range-lookup=FALSE requests an exact match and assumes the data is not sorted.\n\nAvoid performing lookups on unsorted data where possible because it is slow. If your data is sorted, but you want an exact match, see Use two lookups for sorted data with missing values.\n\nUse INDEX and MATCH or OFFSET instead of VLOOKUP\n\nTry using the INDEX and MATCH functions instead of VLOOKUP. Although VLOOKUP is slightly faster (approximately 5 percent faster), simpler, and uses less memory than a combination of MATCH and INDEX, or OFFSET, the additional flexibility that MATCH and INDEX offer often enables you to significantly save time. For example, you can store the result of an exact MATCH in a cell and reuse it in several INDEX statements.\n\nThe INDEX function is fast and is a non-volatile function, which speeds up recalculation. The OFFSET function is also fast; however, it is a volatile function, and it sometimes significantly increases the time taken to process the calculation chain.\n\nIt's easy to convert VLOOKUP to INDEX and MATCH. The following two statements return the same answer:\n\nBecause exact match lookups can be slow, consider the following options for improving performance:\n• None Use one worksheet. It's faster to keep lookups and data on the same sheet.\n• None When you can, SORT the data first (SORT is fast), and use approximate match.\n• None When you must use an exact match lookup, restrict the range of cells to be scanned to a minimum. Use tables and structured references or dynamic range names rather than referring to a large number of rows or columns. Sometimes you can pre-calculate a lower-range limit and upper-range limit for the lookup.\n\nUse two lookups for sorted data with missing values\n\nTwo approximate matches are significantly faster than one exact match for a lookup over more than a few rows. (The breakeven point is about 10-20 rows.)\n\nIf you can sort your data but still cannot use approximate match because you cannot be sure that the value you are looking up exists in the lookup range, you can use this formula:\n\nThe first part of the formula works by doing an approximate lookup on the lookup column itself.\n\nYou can check if the answer from the lookup column is the same as the lookup value (in which case you have an exact match) by using the following formula:\n\nIf this formula returns True, you have found an exact match, so you can do the approximate lookup again, but this time, return the answer from the column you want.\n\nIf the answer from the lookup column did not match the lookup value, you have a missing value, and the formula returns \"notexist\".\n\nBe aware that if you look up a value smaller than the smallest value in the list, you receive an error. You can handle this error by using IFERROR, or by adding a small test value to the list.\n\nUse IFERROR function for unsorted data with missing values\n\nIf you must use exact match lookup on unsorted data, and you cannot be sure whether the lookup value exists, you often must handle the #N/A that is returned if no match is found. Beginning with Excel 2007, you can use the IFERROR function, which is both simple and fast.\n\nIn earlier versions, a simple but slow way is to use an IF function that contains two lookups.\n\nYou can avoid the double exact lookup if you use exact MATCH once, store the result in a cell, and then test the result before doing an INDEX.\n\nIf you cannot use two cells, use COUNTIF. It's generally faster than an exact match lookup.\n\nUse MATCH and INDEX for exact match lookups on multiple columns\n\nYou can often reuse a stored exact MATCH many times. For example, if you are doing exact lookups on multiple result columns, you can save time by using one MATCH and many INDEX statements rather than many VLOOKUP statements.\n\nAdd an extra column for the MATCH to store the result ( ), and for each result column use the following:\n\nAlternatively, you can use VLOOKUP in an array formula. (Array formulas must be entered by using Ctrl+-Shift+Enter. Excel will add the { and } to show you that this is an array formula).\n\nUse INDEX for a set of contiguous rows or columns\n\nYou can also return many cells from one lookup operation. To look up several contiguous columns, you can use the INDEX function in an array formula to return multiple columns at once (use 0 as the column number). You can also use the INDEX function to return multiple rows at one time.\n\nThis returns column A to column J from the stored row created by a previous MATCH statement.\n\nUse MATCH to return a rectangular block of cells\n\nUse the MATCH and OFFSET functions to return a rectangular block of cells.\n\nUse MATCH and INDEX for two-dimensional lookup\n\nYou can efficiently do a two-dimensional table lookup by using separate lookups on the rows and columns of a table by using an INDEX function with two embedded MATCH functions, one for the row and one for the column.\n\nIn large worksheets, you may frequently need to look up by using multiple indexes, such as looking up product volumes in a country/region. To do this, you can concatenate the indexes and perform the lookup by using concatenated lookup values. However, this is inefficient for two reasons:\n\nIt's often more efficient to calculate a subset range for the lookup (for example, by finding the first and last row for the country/region, and then looking up the product within that subset range).\n\nTo look up the table to use in addition to the row and the column, you can use the following techniques, focusing on how to make Excel look up or choose the table.\n\nIf each table that you want to look up (the third dimension) is stored as a set of named structured tables, range names, or as a table of text strings that represent ranges, you might be able to use the CHOOSE or INDIRECT functions.\n• None Using CHOOSE and range names can be an efficient method. CHOOSE is not volatile, but it is best-suited to a relatively small number of tables. This example dynamically uses to choose which range name ( ) to use for the lookup table.\n• None The following example uses the INDIRECT function and to dynamically create the sheet name to use for the lookup table. This method has the advantage of being simple and able to handle a large number of tables. Because INDIRECT is a volatile single-threaded function, the lookup is single-thread calculated at every calculation even if no data has changed. Using this method is slow.\n• None You could also use the VLOOKUP function to find the name of the sheet or the text string to use for the table, and then use the INDIRECT function to convert the resulting text into a range.\n\nAnother technique is to aggregate all your tables into one giant table that has an additional column that identifies the individual tables. You can then use the techniques for multiple-index lookup shown in the previous examples.\n\nThe MATCH, VLOOKUP, and HLOOKUP functions allow you to use the wildcard characters ? (any single character) and * (no character or any number of characters) on alphabetical exact matches. Sometimes you can use this method to avoid multiple matches.\n\nArray formulas and the SUMPRODUCT function are powerful, but you must handle them carefully. A single array formula might require many calculations.\n\nThe key to optimizing the calculation speed of array formulas is to ensure that the number of cells and expressions that are evaluated in the array formula is as small as possible. Remember that an array formula is a bit like a volatile formula: if any one of the cells that it references has changed, is volatile, or has been recalculated, the array formula calculates all the cells in the formula and evaluates all the virtual cells it needs to do the calculation.\n\nTo optimize the calculation speed of array formulas:\n• None Take expressions and range references out of the array formulas into separate helper columns and rows. This makes much better use of the smart recalculation process in Excel.\n• None Do not reference complete rows, or more rows and columns than you need. Array formulas are forced to calculate all the cell references in the formula even if the cells are empty or unused. With 1 million rows available starting in Excel 2007, an array formula that references a whole column is extremely slow to calculate.\n• None Starting in Excel 2007, use structured references where you can to keep the number of cells that are evaluated by the array formula to a minimum.\n• None In versions earlier than Excel 2007, use dynamic range names where possible. Although they are volatile, it is worthwhile because they minimize the size of the ranges.\n• None Be careful with array formulas that reference both a row and a column: this forces the calculation of a rectangular range.\n• None Use SUMPRODUCT if possible; it is slightly faster than the equivalent array formula.\n\nConsider options for using SUM for multiple-condition array formulas\n\nYou should always use the SUMIFS, COUNTIFS, and AVERAGEIFS functions instead of array formulas where you can because they are much faster to calculate. Excel 2016 introduces fast MAXIFS and MINIFS functions.\n\nIn versions earlier than Excel 2007, array formulas are often used to calculate a sum with multiple conditions. This is relatively easy to do, especially if you use the Conditional Sum Wizard in Excel, but it is often slow. Usually there are much faster ways of getting the same result. If you have only a few multiple-condition SUMs, you may be able to use the DSUM function, which is much faster than the equivalent array formula.\n\nIf you must use array formulas, some good methods of speeding them up are as follows:\n• None Use dynamic range names or structured table references to minimize the number of cells.\n• None Split out the multiple conditions into a column of helper formulas that return True or False for each row, and then reference the helper column in a SUMIF or array formula. This might not appear to reduce the number of calculations for a single array formula; however, most of the time it enables the smart recalculation process to recalculate only the formulas in the helper column that need to be recalculated.\n• None Consider concatenating together all the conditions into a single condition, and then using SUMIF.\n• None If the data can be sorted, count groups of rows and limit the array formulas to looking at the subset groups.\n\nThese functions evaluate each of the conditions from left to right in turn. Therefore, it is more efficient to put the most restrictive condition first, so that subsequent conditions only need to look at the smallest number of rows.\n\nConsider options for using SUMPRODUCT for multiple-condition array formulas\n\nStarting in Excel 2007, you should always use the SUMIFS, COUNTIFS, and AVERAGEIFS functions, and in Excel 2016 MAXIFS and MINIFS functions, instead of SUMPRODUCT formulas where possible.\n\nIn earlier versions, there are a few advantages to using SUMPRODUCT instead of SUM array formulas:\n• None SUMPRODUCT does not have to be array-entered by using Ctrl+Shift+Enter.\n• None SUMPRODUCT is usually slightly faster (5 to 10 percent).\n\nUse SUMPRODUCT for multiple-condition array formulas as follows:\n\nIn this example, and are conditional expressions such as . Because conditional expressions return True or False instead of numbers, they must be coerced to numbers inside the SUMPRODUCT function. You can do this by using two minus signs (--), or by adding 0 (+0), or by multiplying by 1 (x1). Using -- is slightly faster than +0 or x1.\n\nNote that the size and shape of the ranges or arrays that are used in the conditional expressions and range to sum must be the same, and they cannot contain entire columns.\n\nYou can also directly multiply the terms inside SUMPRODUCT rather than separate them by commas:\n\nThis is usually slightly slower than using the comma syntax, and it gives an error if the range to sum contains a text value. However, it is slightly more flexible in that the range to sum may have, for example, multiple columns when the conditions have only one column.\n\nUse SUMPRODUCT to multiply and add ranges and arrays\n\nIn cases like weighted average calculations, where you need to multiply a range of numbers by another range of numbers and sum the results, using the comma syntax for SUMPRODUCT can be 20 to 25 percent faster than an array-entered SUM.\n\nThese three formulas all produce the same result, but the third formula, which uses the comma syntax for SUMPRODUCT, takes only about 77 percent of the calculation time that the other two formulas need.\n\nBe aware of potential array and function calculation obstructions\n\nThe calculation engine in Excel is optimized to exploit array formulas and functions that reference ranges. However, some unusual arrangements of these formulas and functions can sometimes, but not always, cause significantly increased calculation time.\n\nIf you find a calculation obstruction that involves array formulas and range functions, you should look for the following:\n• None Array formulas and range functions that reference part of a block of cells that are calculated in another array formula or range function. This situation can frequently occur in time series analysis.\n• None One set of formulas referencing by row, and a second set of formulas referencing the first set by column.\n• None A large set of single-row array formulas covering a block of columns, with SUM functions at the foot of each column.\n\nFunctions significantly extend the power of Excel, but the way in which you use them can often affect calculation time.\n\nMost native Excel functions work well with multi-threaded calculation. However, where possible, avoid using the following single-threaded functions:\n• VBA and Automation user-defined functions (UDFs), but XLL-based UDFs can be multi-threaded\n• CELL when either the \"format\" or \"address\" argument is used\n• ADDRESS where the fifth parameter (the ) is given\n• Any database function (DSUM, DAVERAGE, and so on) that refers to a PivotTable\n\nUse tables for functions that handle ranges\n\nFor functions like SUM, SUMIF, and SUMIFS that handle ranges, the calculation time is proportional to the number of used cells you are summing or counting. Unused cells are not examined, so whole column references are relatively efficient, but it is better to ensure that you don't include more used cells than you need. Use tables, or calculate subset ranges or dynamic ranges.\n\nVolatile functions can slow recalculation because they increase the number of formulas that must be recalculated at each calculation.\n\nYou can often reduce the number of volatile functions by using INDEX instead of OFFSET, and CHOOSE instead of INDIRECT. However, OFFSET is a fast function and can often be used in creative ways that give fast calculation.\n\nUse C or C++ user-defined functions\n\nUser-defined functions that are programmed in C or C++ and that use the C API (XLL add-in functions) generally perform faster than user-defined functions that are developed by using VBA or Automation (XLA or Automation add-ins). For more information, see Developing Excel 2010 XLLs.\n\nThe performance of VBA user-defined functions is sensitive to how you program and call them.\n\nIt's usually faster to use the Excel formula calculations and worksheet functions than to use VBA user-defined functions. This is because there is a small overhead for each user-defined function call and significant overhead transferring information from Excel to the user-defined function. But well-designed and called user-defined functions can be much faster than complex array formulas.\n\nEnsure that you have put all the references to worksheet cells in the user-defined function input parameters instead of in the body of the user-defined function, so that you can avoid adding Application.Volatile unnecessarily.\n\nIf you must have many formulas that use user-defined functions, ensure that you are in manual calculation mode, and that the calculation is initiated from VBA. VBA user-defined functions calculate much more slowly if the calculation is not called from VBA (for example, in automatic mode or when you press F9 in manual mode). This is particularly true when the Visual Basic Editor (Alt+F11) is open or has been opened in the current Excel session.\n\nYou can trap F9 and redirect it to a VBA calculation subroutine as follows. Add this subroutine to the Thisworkbook module.\n\nUser-defined functions in Automation add-ins (Excel 2002 and later versions) don't incur the Visual Basic Editor overhead because they don't use the integrated editor. Other performance characteristics of Visual Basic 6 user-defined functions in Automation add-ins are similar to VBA functions.\n\nIf your user-defined function processes each cell in a range, declare the input as a range, assign it to a variant that contains an array, and loop on that. If you want to handle whole column references efficiently, you must make a subset of the input range, dividing it at its intersection with the used range, as in this example.\n\nIf your user-defined function is using worksheet functions or Excel object model methods to process a range, it is generally more efficient to keep the range as an object variable than to transfer all the data from Excel to the user-defined function.\n\nIf your user-defined function is called early in the calculation chain, it can be passed as uncalculated arguments. Inside a user-defined function, you can detect uncalculated cells by using the following test for empty cells that contain a formula:\n\nA time overhead exists for each call to a user-defined function and for each transfer of data from Excel to VBA. Sometimes one multi-cell array formula user-defined function can help you minimize these overheads by combining multiple function calls into a single function with a multi-cell input range that returns a range of answers.\n\nMinimize range of cells that SUM and SUMIF reference\n\nThe Excel SUM and SUMIF functions are frequently used over a large number of cells. Calculation time for these functions is proportionate to the number of cells covered, so try to minimize the range of cells that the functions are referencing.\n\nUse wildcard SUMIF, COUNTIF, SUMIFS, COUNTIFS, and other IFS functions\n\nUse the wildcard characters ? (any single character) and * (no character or any number of characters) in the criteria for alphabetical ranges as part of the SUMIF, COUNTIF, SUMIFS, COUNTIFS, and other IFS functions.\n\nThere are two methods of doing period-to-date or cumulative SUMs. Suppose the numbers that you want to cumulatively SUM are in column A, and you want column B to contain the cumulative sum; you can do either of the following:\n• None You can create a formula in column B such as and drag it down as far as you need. The beginning cell of the SUM is anchored in A1, but because the finishing cell has a relative row reference, it automatically increases for each row.\n• None You can create a formula such as in cell B1 and in cell B2 and drag it down as far as you need. This calculates the cumulative cell by adding this row's number to the previous cumulative SUM.\n\nFor 1,000 rows, the first method makes Excel do about 500,000 calculations, but the second method makes Excel do only about 2,000 calculations.\n\nWhen you have multiple sorted indexes to a table (for example, Site within Area) you can often save significant calculation time by dynamically calculating the address of a subset range of rows (or columns) to use in the SUM or SUMIF function.\n\nTo calculate the address of a subset range of row or columns:\n• None Count the number of rows for each subset block.\n• None Add the counts cumulatively for each block to determine its start row.\n• None Use OFFSET with the start row and count to return a subset range to the SUM or SUMIF that covers only the subset block of rows.\n\nUse the SUBTOTAL function to SUM filtered lists. The SUBTOTAL function is useful because, unlike SUM, it ignores the following:\n• None Hidden rows that result from filtering a list. Starting in Excel 2003, you can also make SUBTOTAL ignore all hidden rows, not just filtered rows.\n\nThe AGGREGATE function is a powerful and efficient way of calculating 19 different methods of aggregating data (such as SUM, MEDIAN, PERCENTILE and LARGE). AGGREGATE has options for ignoring hidden or filtered rows, error values, and nested SUBTOTAL and AGGREGATE functions.\n\nThe DFunctions DSUM, DCOUNT, DAVERAGE, and so on are significantly faster than equivalent array formulas. The disadvantage of the DFunctions is that the criteria must be in a separate range, which makes them impractical to use and maintain in many circumstances. Starting in Excel 2007, you should use SUMIFS, COUNTIFS, and AVERAGEIFS functions instead of the DFunctions.\n\nUse the following tips to create faster VBA macros.\n\nTurn off everything but the essentials while code is running\n\nTo improve performance for VBA macros, explicitly turn off the functionality that is not required while your code executes. Often, one recalculation or one redraw after your code runs is all that is necessary and can improve performance. After your code executes, restore the functionality to its original state.\n\nThe following functionality can usually be turned off while your VBA macro executes:\n• None Application.ScreenUpdating Turn off screen updating. If Application.ScreenUpdating is set to False, Excel does not redraw the screen. While your code runs, the screen updates quickly, and it is usually not necessary for the user to see each update. Updating the screen once, after the code executes, improves performance.\n• None Application.DisplayStatusBar Turn off the status bar. If Application.DisplayStatusBar is set to False, Excel does not display the status bar. The status bar setting is separate from the screen updating setting so that you can still display the status of the current operation even while the screen is not updating. However, if you don't need to display the status of every operation, turning off the status bar while your code runs also improves performance.\n• None Application.Calculation Switch to manual calculation. If Application.Calculation is set to xlCalculationManual, Excel only calculates the workbook when the user explicitly initiates the calculation. In automatic calculation mode, Excel determines when to calculate. For example, every time a cell value that is related to a formula changes, Excel recalculates the formula. If you switch the calculation mode to manual, you can wait until all the cells associated with the formula are updated before recalculating the workbook. By only recalculating the workbook when necessary while your code runs, you can improve performance.\n• None Application.EnableEvents Turn off events. If Application.EnableEvents is set to False, Excel does not raise events. If there are add-ins listening for Excel events, those add-ins consume resources on the computer as they record the events. If it is not necessary for the add-in to record the events that occur while your code runs, turning off events improves performance.\n• None ActiveSheet.DisplayPageBreaks Turn off page breaks. If ActiveSheet.DisplayPageBreaks is set to False, Excel does not display page breaks. It's not necessary to recalculate page breaks while your code runs, and calculating the page breaks after the code executes improves performance.\n\nThe following example shows the functionality that you can turn off while your VBA macro executes.\n\nRead and write large blocks of data in a single operation\n\nOptimize your code by explicitly reducing the number of times data is transferred between Excel and your code. Instead of looping through cells one at a time to get or set a value, get or set the values in the entire range of cells in one line, using a variant containing a two-dimensional array to store values as needed. The following code examples compare these two methods.\n\nThe following code example shows non-optimized code that loops through cells one at a time to get and set the values of cells A1:C10000. These cells don't contain formulas.\n\nThe following code example shows optimized code that uses an array to get and set the values of cells A1:C10000 all at the same time. These cells don't contain formulas.\n\nUse .Value2 rather than .Value or .Text when reading data from an Excel range\n• .Text returns the formatted value of a cell. This is slow, can return ### if the user zooms, and can lose precision.\n• .Value returns a VBA currency or VBA date variable if the range was formatted as Date or Currency. This is slow, can lose precision, and can cause errors when calling worksheet functions.\n• .Value2 is fast and does not alter the data being retrieved from Excel.\n\nSelecting and activating objects is more processing intensive than referencing objects directly. By referencing an object such as a Range or a Shape directly, you can improve performance. The following code examples compare the two methods.\n\nThe following code example shows non-optimized code that selects each Shape on the active sheet and changes the text to \"Hello\".\n\nThe following code example shows optimized code that references each Shape directly and changes the text to \"Hello\".\n\nThe following is a list of additional performance optimizations you can use in your VBA code:\n• None Return results by assigning an array directly to a Range.\n• None Declare variables with explicit types to avoid the overhead of determining the data type, possibly multiple times in a loop, during code execution.\n• None For simple functions that you use frequently in your code, implement the functions yourself in VBA instead of using the WorksheetFunction object. For more information, see Use faster VBA user-defined functions.\n• None Use the Range.SpecialCells method to scope down the number of cells with which your code interacts.\n• None Consider the performance gains if you implemented your functionality by using the C API in the XLL SDK. For more information, see the Excel 2010 XLL SDK Documentation.\n\nConsider performance and size of Excel file formats\n\nStarting in Excel 2007, Excel contains a wide variety of file formats compared to earlier versions. Ignoring the Macro, Template, Add-in, PDF, and XPS file format variations, the three main formats are XLS, XLSB, and XLSX.\n• The XLS format is the same format as earlier versions. When you use this format, you are restricted to 256 columns and 65,536 rows. When you save an Excel 2007 or Excel 2010 workbook in XLS format, Excel runs a compatibility check. File size is almost the same as earlier versions (some additional information may be stored), and performance is slightly slower than earlier versions. Any multi-threaded optimization Excel does with respect to cell calculation order is not saved in the XLS format. Therefore, calculation of a workbook can be slower after saving the workbook in the XLS format, closing, and re-opening the workbook.\n• XLSB is the binary format starting in Excel 2007. It's structured as a compressed folder that contains many binary files. It's much more compact than the XLS format, but the amount of compression depends on the contents of the workbook. For example, ten workbooks show a size reduction factor ranging from two to eight with an average reduction factor of four. Starting in Excel 2007, opening and saving performance is only slightly slower than the XLS format.\n• XLSX is the XML format starting in Excel 2007, and is the default format starting in Excel 2007. The XLSX format is a compressed folder that contains many XML files (if you change the file name extension to .zip, you can open the compressed folder and examine its contents). Typically, the XLSX format creates larger files than the XLSB format (1.5 times larger on average), but they are still significantly smaller than the XLS files. You should expect opening and saving times to be slightly longer than for XLSB files.\n\nYou may find that opening, closing, and saving workbooks is much slower than calculating them. Sometimes this is just because you have a large workbook, but there can also be other reasons.\n\nIf one or more of your workbooks open and close more slowly than is reasonable, it might be caused by one of the following issues.\n• Temporary files can accumulate in your \\Windows\\Temp directory (in Windows 95, Windows 98, and Windows ME), or your \\Documents and Settings\\User Name\\Local Settings\\Temp directory (in Windows 2000 and Windows XP). Excel creates these files for the workbook and for controls that are used by open workbooks. Software installation programs also create temporary files. If Excel stops responding for any reason, you might need to delete these files. Too many temporary files can cause problems, so you should occasionally clean them out. However, if you have installed software that requires that you restart your computer, and you have not yet done so, you should restart before deleting the temporary files.\n\nAn easy way to open your temp directory is from the Windows Start menu: Click Start, and then click Run. In the text box, type %temp%, and then click OK.\n• Tracking changes in a shared workbook causes your workbook file-size to increase rapidly.\n• Be sure that your Windows swap file is located on a disk that has a lot of space and that you defragment the disk periodically.\n• A workbook that has its structure protected with a password (Tools menu > Protection > Protect Workbook > enter the optional password) opens and closes much slower than one that is protected without the optional password.\n• Oversized used ranges can cause slow opening and increased file size, especially if they are caused by hidden rows or columns that have non-standard height or width. For more information about used range problems, see Minimize the used range.\n• A large number of controls (check boxes, hyperlinks, and so on) on worksheets can slow down opening a workbook because of the number of temporary files that are used. This might also cause problems opening or saving a workbook on a WAN (or even a LAN). If you have this problem, you should consider redesigning your workbook.\n• None Large number of links to other workbooks If possible, open the workbooks that you are linking to before you open the workbook that contains the links. Often it is faster to open a workbook than to read the links from a closed workbook.\n• Some virus scanner settings can cause problems or slowness with opening, closing, or saving, especially on a server. If you think that this might be the problem, try temporarily switching the virus scanner off.\n• Under some circumstances, Excel recalculates your workbook when it opens or saves it. If the calculation time for your workbook is long and is causing a problem, ensure that you have calculation set to manual, and consider turning off the calculate before save option (Tools > Options > Calculation).\n• Check the size of your toolbar file. A typical toolbar file is between 10 KB and 20 KB. You can find your XLB files by searching for by using Windows search. Each user has a unique XLB file. Adding, changing, or customizing toolbars increases the size of your toolbar.xlb file. Deleting the file removes all your toolbar customizations (renaming it \"toolbar.OLD\" is safer). A new XLB file is created the next time you open Excel.\n\nYou can make performance improvements in the following areas.\n• PivotTables provide an efficient way to summarize large amounts of data.\n• None Totals as final results. If you need to produce totals and subtotals as part of the final results of your workbook, try using PivotTables.\n• None Totals as intermediate results. PivotTables are a great way to produce summary reports, but try to avoid creating formulas that use PivotTable results as intermediate totals and subtotals in your calculation chain unless you can ensure the following conditions:\n• None The PivotTable has been refreshed correctly during the calculation.\n• None The PivotTable has not been changed so that the information is still visible. If you still want to use PivotTables as intermediate results, use the GETPIVOTDATA function.\n• Conditional formats and data validation are great, but using a lot of them can significantly slow down calculation. If the cell is displayed, every conditional format formula is evaluated at each calculation and when the display of the cell that contains the conditional format is refreshed. The Excel object model has a Worksheet.EnableFormatConditionsCalculation property so that you can enable or disable the calculation of conditional formats.\n• Defined names are one of the most powerful features in Excel, but they do take additional calculation time. Using names that refer to other worksheets adds an additional level of complexity to the calculation process. Also, you should try to avoid nested names (names that refer to other names). Because names are calculated every time a formula that refers to them is calculated, you should avoid putting calculation-intensive formulas or functions in defined names. In these cases, it can be significantly faster to put your calculation-intensive formula or function in a spare cell somewhere and refer to that cell instead, either directly or by using a name.\n• None Formulas that are used only occasionally Many workbooks contain a significant number of formulas and lookups that are concerned with getting the input data into the appropriate shape for the calculations, or are being used as defensive measures against changes in the size or shape of the data. When you have blocks of formulas that are used only occasionally, you can copy and paste special values to temporarily eliminate the formulas, or you can put them in a separate, rarely opened workbook. Because worksheet errors are often caused by not noticing that formulas have been converted to values, the separate workbook method may be preferable.\n• The 32-bit version of Excel can use up to 2 GB of RAM or up to 4 GB of RAM for Large Address Aware 32-bit versions of Excel 2013 and 2016. However, the computer that is running Excel also requires memory resources. Therefore, if you only have 2 GB of RAM on your computer, Excel cannot take advantage of the full 2 GB because a portion of the memory is allocated to the operating system and other programs that are running. To optimize the performance of Excel on a 32-bit computer, we recommend that the computer have at least 3 GB of RAM. The 64-bit version of Excel does not have a 2 GB or up to 4 GB limit. For more information, see the \"Large data sets and the 64-bit version of Excel\" section in Excel performance: Performance and limit improvements.\n\nThis article covered ways to optimize Excel functionality such as links, lookups, formulas, functions, and VBA code to avoid common obstructions and improve performance.\n\nHave questions or feedback about Office VBA or this documentation? Please see Office VBA support and feedback for guidance about the ways you can receive support and provide feedback."
    },
    {
        "link": "https://stackoverflow.com/questions/12391786/effect-of-screen-updating",
        "document": "If you want to see a fairly drastic example of why is important, run the following code. It takes roughly 45 times longer in Excel 2011 for me to run this swap without ! This is a huge difference in time.\n\nAlso, while we're on the topic of ways to increase efficiency, another key point is that , , and are rarely (if ever) necessary. When you record macros it will always use these but there are very few situations when you need to actually use them in code. Likewise, anything with in title (such as ) normally is an indication you will have slower code because you presumably are selecting cells.\n\nYou can almost always refer to cells/worksheets specifically and avoid select. For example:\n\nwill work regardless of whether you are currently on the first worksheet. A common new VBA mistake is to do something more like:\n\nwhich is an unneeded step."
    },
    {
        "link": "https://soa.org/news-and-publications/newsletters/compact/2012/january/com-2012-iss42/excel-vba-speed-and-efficiency",
        "document": "As the proud owner of several large VBA macros, I have spent a considerable amount of time looking for ways to make macros run faster. This article lists my top rules for speeding up VBA. It is easy to lapse into bad programming habits when working with small macros, but with large macros and macros that run a long time it is critical to use efficient coding. This article is primarily focused on Excel VBA macros, however many of these rules apply to Microsoft Access VBA macros as well.\n\nThe first five rules generally have the largest impact on macro performance. Rules six through 11 have a marginal impact. Please note that my estimates of time savings below may vary significantly for your specific application. The analysis used Excel 2007.\n\nThis rule is well known, but it is the most important rule. When a new value is entered into a worksheet cell, Excel will recalculate all the cells that refer to it. If the macro is writing values into the worksheet, VBA will need to wait until the worksheet is done recalculating each entry before it can resume. The impact of leaving automatic calculation turned on can be dramatic. I highly recommend turning off automatic calculation using the following command at the beginning of the macro.\n\nIf you need to recalculate spreadsheet values while the macro is running you can use any of the following commands. The first command recalculates the entire workbook. The second command only recalculates a specific sheet. The third command only recalculates a specific Range.\n\nWhen the macro is done, automatic calculation needs to be turned back on using the following command. If the macro ends prematurely before this command is processed, you will need to manually reset calculation to automatic in EXCEL.\n\nEvery time VBA writes data to the worksheet it refreshes the screen image that you see. Refreshing the image is a considerable drag on performance. The following command turns off screen updates.\n\nAt the end of the macro use the following command to turn screen updates back on.\n\nRule #3. Minimize traffic between VBA and the worksheet\n\nOnce the macro begins it is important to avoid unnecessary references to the worksheet. Grabbing data from the spreadsheet is a drag on performance. Avoid reading or writing worksheet data within loops whenever possible. It is much faster to read the data once and save it into memory than to reread it each time.\n\nIn this example, the macro will need to grab the named Range \"issue_age\" from the worksheet repeatedly. This is a common mistake. VBA is much faster when it doesn't need to stop and interact with the worksheet.\n\nIn the following code the variable Issue_Age is read in only once from the worksheet and traffic between VBA and Excel is minimized. The code below is more than 100 times faster than the code above!\n\nIt is also more efficient to perform all numerical calculations in VBA. It is frequently tempting to leave formulas in the spreadsheet and call them from the macro. But, if speed is important, put all the formulas in the macro. This minimizes traffic and doesn't require spreadsheet recalculation.\n\nAs a general rule use commands WorkSheets, Range, Cells and Application as efficiently as possible outside of loops.\n\nRule #4. Read and write blocks of data in a single operation\n\nThis rule is a continuation of Rule #3. This is another way to minimize traffic between VBA and Excel. Whenever possible read and write data in chunks. There are several methods to accomplish this. Here is an example of reading in a large block of data (2,600 cells) into an array. This example is roughly 50 times faster than reading in each cell individually in a loop.\n\nLikewise, here are examples of writing the array back into the worksheet. All are roughly 40 times faster than writing each of the 2,600 cells individually within a loop.\n\nThis rule was surprising to me. I had naively assumed that common worksheet functions would be efficiently processed by VBA. This is clearly not the case. For example, most VBA users are probably aware that VBA does not have a Max() or Min() function. Excel does have these functions. It is common to use the following code that uses the Excel version of Max():\n\nI found an open source version of a VBA Max() function on the Internet. It was 10 times faster than the Excel based counterpart above. However, the code below is over 80 times faster! I concede that the function below only works with two arguments and does not support arrays, but the improvement in speed is substantial.\n\nI suggest caution when using worksheet functions in large, time consuming macros. You should evaluate the impact of rewriting the function. Note that any command that starts with \"Application.\" or \"WorksheetFunction.\" is referring to an Excel function. I can't say that all \"Application.\" functions are slow. But, I have written or downloaded versions of Min(), Max(), Average(), Match(), NormSInv() and StDev() that are much faster than the Excel versions.\n\nDo not declare a numerical variable as Variant unless necessary. Note that if you choose not to use \"Option Explicit\" at the beginning of the macro any undefined variable will be a Variant. Variants are very flexible because they can be numerical or text, but they are slow to process in a formula. The impact on efficiency is not large, but every little bit helps. Note that this rule also applies to any functions you write. Based on my tests the variable types from fastest to slowest in mathematical equations are: Constant, Single, Double, Long, Integer, Variant.\n\nStrings (text) are slow to evaluate. Avoid evaluating Strings in code like this:\n\nEnumeration assigns a constant numerical value to a variable. VBA can process enumerated values quickly while maintaining readable code. Enumeration can assign default numerical values or specific values can be assigned.\n\nBoolean operators are simply TRUE or FALSE switches that process really quickly. In the example below bMale, bFemale and bUnisex are Boolean variables. The Boolean code is roughly 10 times faster than using Strings.\n\nYou generally do not need to use the Select command to read or write to a worksheet. It is about 30 times faster not to Select a worksheet.\n\nVBA can process math faster than it can display the StatusBar. Writing to the StatusBar is another example of traffic between VBA and Excel. The following example writes one out of every 100 scenarios to the StatusBar. It is about 90 times faster than writing every scenario to the StatusBar.\n\nAs actuaries we love macros full of formulas. Frequently the formulas are not as efficient as they should be. In the example below, the macro calculates the monthly value of a fund growing at 5 percent annual effective interest for 50 years. I frequently see code like this:\n\nIt is more efficient to convert the annual interest rate to monthly rate once as shown below. Within the loop, VBA only uses a single numerical operation (multiplication). The example above uses four numerical operations (one multiplication, one addition, one division and one exponentiation) within the loop and is therefore about four times slower.\n\nAlso note that exponentiation is slower than addition, subtraction, multiplication or division.\n\nThe Copy and Paste (or PasteSpecial) functions are slow. It is about 25 times faster to use the following to copy and paste values.\n\nI have found it useful to write a small macro to evaluate the time savings associated with various methods. The macro simply performs a method a million times or so and records the time spent performing that method. The simple macro below compares the Excel Max() function to the Max2 function shown in Rule #5.\n\nPlease contact me if you have other time-saving tips.\n\nI also want to point out and thank several excellent articles on the internet that address this topic:\n\nhttp://www.avdf.com/apr98/art_ot003.html by Dermot Balson\n\nhttp://www.cpearson.com/excel/optimize.htm by Pearson Software Consulting\n\nhttp://blogs.office.com/b/microsoft-excel/archive/2009/03/12/excel-vba-performance-coding-best-practices.aspx by Diego M. Oppenheimer\n\nhttp://www.ozgrid.com/VBA/SpeedingUpVBACode.htm by Ozgrid\n\nKevin Roper, FSA, MAAA is actuary with AEGON USA Inc. He can be contacted at kroper@aegonusa.com"
    },
    {
        "link": "https://stackoverflow.com/questions/51437903/vba-performance-what-order-should-use-to-disable-enable-screen-updating",
        "document": "I have a macro in place that toggles the following:\n\nI turn them all on/off at the same time, but I noticed that sometimes EnableEvents does not turn back on, and screenUpdating does not turn off.\n\nIs there a specific order I should follow because they somehow affect each other when toggling them?"
    }
]