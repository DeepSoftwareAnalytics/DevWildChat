[
    {
        "link": "https://legacy.reactjs.org/docs/hooks-effect.html",
        "document": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.\n\nThe Effect Hook lets you perform side effects in function components:\n\nThis snippet is based on the counter example from the previous page, but we added a new feature to it: we set the document title to a custom message including the number of clicks.\n\nData fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects. Whether or not you’re used to calling these operations “side effects” (or just “effects”), you’ve likely performed them in your components before.\n\nThere are two common kinds of side effects in React components: those that don’t require cleanup, and those that do. Let’s look at this distinction in more detail.\n\nSometimes, we want to run some additional code after React has updated the DOM. Network requests, manual DOM mutations, and logging are common examples of effects that don’t require a cleanup. We say that because we can run them and immediately forget about them. Let’s compare how classes and Hooks let us express such side effects.\n\nIn React class components, the method itself shouldn’t cause side effects. It would be too early — we typically want to perform our effects after React has updated the DOM.\n\nThis is why in React classes, we put side effects into and . Coming back to our example, here is a React counter class component that updates the document title right after React makes changes to the DOM:\n\nNote how we have to duplicate the code between these two lifecycle methods in class.\n\nThis is because in many cases we want to perform the same side effect regardless of whether the component just mounted, or if it has been updated. Conceptually, we want it to happen after every render — but React class components don’t have a method like this. We could extract a separate method but we would still have to call it in two places.\n\nNow let’s see how we can do the same with the Hook.\n\nWe’ve already seen this example at the top of this page, but let’s take a closer look at it:\n\nWhat does do? By using this Hook, you tell React that your component needs to do something after render. React will remember the function you passed (we’ll refer to it as our “effect”), and call it later after performing the DOM updates. In this effect, we set the document title, but we could also perform data fetching or call some other imperative API.\n\nWhy is called inside a component? Placing inside the component lets us access the state variable (or any props) right from the effect. We don’t need a special API to read it — it’s already in the function scope. Hooks embrace JavaScript closures and avoid introducing React-specific APIs where JavaScript already provides a solution.\n\nDoes run after every render? Yes! By default, it runs both after the first render and after every update. (We will later talk about how to customize this.) Instead of thinking in terms of “mounting” and “updating”, you might find it easier to think that effects happen “after render”. React guarantees the DOM has been updated by the time it runs the effects.\n\nNow that we know more about effects, these lines should make sense:\n\nWe declare the state variable, and then we tell React we need to use an effect. We pass a function to the Hook. This function we pass is our effect. Inside our effect, we set the document title using the browser API. We can read the latest inside the effect because it’s in the scope of our function. When React renders our component, it will remember the effect we used, and then run our effect after updating the DOM. This happens for every render, including the first one.\n\nExperienced JavaScript developers might notice that the function passed to is going to be different on every render. This is intentional. In fact, this is what lets us read the value from inside the effect without worrying about it getting stale. Every time we re-render, we schedule a different effect, replacing the previous one. In a way, this makes the effects behave more like a part of the render result — each effect “belongs” to a particular render. We will see more clearly why this is useful later on this page.\n\nEarlier, we looked at how to express side effects that don’t require any cleanup. However, some effects do. For example, we might want to set up a subscription to some external data source. In that case, it is important to clean up so that we don’t introduce a memory leak! Let’s compare how we can do it with classes and with Hooks.\n\nIn a React class, you would typically set up a subscription in , and clean it up in . For example, let’s say we have a module that lets us subscribe to a friend’s online status. Here’s how we might subscribe and display that status using a class:\n\nNotice how and need to mirror each other. Lifecycle methods force us to split this logic even though conceptually code in both of them is related to the same effect.\n\nLet’s see how we could write this component with Hooks.\n\nYou might be thinking that we’d need a separate effect to perform the cleanup. But code for adding and removing a subscription is so tightly related that is designed to keep it together. If your effect returns a function, React will run it when it is time to clean up:\n\nWhy did we return a function from our effect? This is the optional cleanup mechanism for effects. Every effect may return a function that cleans up after it. This lets us keep the logic for adding and removing subscriptions close to each other. They’re part of the same effect!\n\nWhen exactly does React clean up an effect? React performs the cleanup when the component unmounts. However, as we learned earlier, effects run for every render and not just once. This is why React also cleans up effects from the previous render before running the effects next time. We’ll discuss why this helps avoid bugs and how to opt out of this behavior in case it creates performance issues later below.\n\nWe’ve learned that lets us express different kinds of side effects after a component renders. Some effects might require cleanup so they return a function:\n\nOther effects might not have a cleanup phase, and don’t return anything.\n\nThe Effect Hook unifies both use cases with a single API.\n\nIf you feel like you have a decent grasp on how the Effect Hook works, or if you feel overwhelmed, you can jump to the next page about Rules of Hooks now.\n\nWe’ll continue this page with an in-depth look at some aspects of that experienced React users will likely be curious about. Don’t feel obligated to dig into them now. You can always come back to this page to learn more details about the Effect Hook.\n\nOne of the problems we outlined in the Motivation for Hooks is that class lifecycle methods often contain unrelated logic, but related logic gets broken up into several methods. Here is a component that combines the counter and the friend status indicator logic from the previous examples:\n\nNote how the logic that sets is split between and . The subscription logic is also spread between and . And contains code for both tasks.\n\nSo, how can Hooks solve this problem? Just like you can use the State Hook more than once, you can also use several effects. This lets us separate unrelated logic into different effects:\n\nHooks let us split the code based on what it is doing rather than a lifecycle method name. React will apply every effect used by the component, in the order they were specified.\n\nIf you’re used to classes, you might be wondering why the effect cleanup phase happens after every re-render, and not just once during unmounting. Let’s look at a practical example to see why this design helps us create components with fewer bugs.\n\nEarlier on this page, we introduced an example component that displays whether a friend is online or not. Our class reads from , subscribes to the friend status after the component mounts, and unsubscribes during unmounting:\n\nBut what happens if the prop changes while the component is on the screen? Our component would continue displaying the online status of a different friend. This is a bug. We would also cause a memory leak or crash when unmounting since the unsubscribe call would use the wrong friend ID.\n\nIn a class component, we would need to add to handle this case:\n\nForgetting to handle properly is a common source of bugs in React applications.\n\nNow consider the version of this component that uses Hooks:\n\nIt doesn’t suffer from this bug. (But we also didn’t make any changes to it.)\n\nThere is no special code for handling updates because handles them by default. It cleans up the previous effects before applying the next effects. To illustrate this, here is a sequence of subscribe and unsubscribe calls that this component could produce over time:\n\nThis behavior ensures consistency by default and prevents bugs that are common in class components due to missing update logic.\n\nIn some cases, cleaning up or applying the effect after every render might create a performance problem. In class components, we can solve this by writing an extra comparison with or inside :\n\nThis requirement is common enough that it is built into the Hook API. You can tell React to skip applying an effect if certain values haven’t changed between re-renders. To do so, pass an array as an optional second argument to :\n\nIn the example above, we pass as the second argument. What does this mean? If the is , and then our component re-renders with still equal to , React will compare from the previous render and from the next render. Because all items in the array are the same ( ), React would skip the effect. That’s our optimization.\n\nWhen we render with updated to , React will compare the items in the array from the previous render to items in the array from the next render. This time, React will re-apply the effect because . If there are multiple items in the array, React will re-run the effect even if just one of them is different.\n\nThis also works for effects that have a cleanup phase:\n\nIn the future, the second argument might get added automatically by a build-time transformation.\n\nCongratulations! This was a long page, but hopefully by the end most of your questions about effects were answered. You’ve learned both the State Hook and the Effect Hook, and there is a lot you can do with both of them combined. They cover most of the use cases for classes — and where they don’t, you might find the additional Hooks helpful.\n\nWe’re also starting to see how Hooks solve problems outlined in Motivation. We’ve seen how effect cleanup avoids duplication in and , brings related code closer together, and helps us avoid bugs. We’ve also seen how we can separate effects by their purpose, which is something we couldn’t do in classes at all.\n\nAt this point you might be questioning how Hooks work. How can React know which call corresponds to which state variable between re-renders? How does React “match up” previous and next effects on every update? On the next page we will learn about the Rules of Hooks — they’re essential to making Hooks work."
    },
    {
        "link": "https://react.dev/reference/react/useEffect",
        "document": "In this example, a cleanup function is not needed because the class manages only the DOM node that was passed to it. After the React component is removed from the tree, both the DOM node and the class instance will be automatically garbage-collected by the browser JavaScript engine. You can use an Effect to fetch data for your component. Note that if you use a framework, using your framework’s data fetching mechanism will be a lot more efficient than writing Effects manually. If you want to fetch data from an Effect manually, your code might look like this: Note the variable which is initialized to , and is set to during cleanup. This ensures your code doesn’t suffer from “race conditions”: network responses may arrive in a different order than you sent them.\n\nWriting data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later. It’s easier to use a custom Hook—either your own or maintained by the community. What are good alternatives to data fetching in Effects? Writing calls inside Effects is a popular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:\n• Effects don’t run on the server. This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.\n• Fetching directly in Effects makes it easy to create “network waterfalls”. You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.\n• Fetching directly in Effects usually means you don’t preload or cache data. For example, if the component unmounts and then mounts again, it would have to fetch the data again.\n• It’s not very ergonomic. There’s quite a bit of boilerplate code involved when writing calls in a way that doesn’t suffer from bugs like race conditions. This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:\n• If you use a framework, use its built-in data fetching mechanism. Modern React frameworks have integrated data fetching mechanisms that are efficient and don’t suffer from the above pitfalls.\n• Otherwise, consider using or building a client-side cache. Popular open source solutions include React Query, useSWR, and React Router 6.4+. You can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes). You can continue fetching data directly in Effects if neither of these approaches suit you. Notice that you can’t “choose” the dependencies of your Effect. Every reactive value used by your Effect’s code must be declared as a dependency. Your Effect’s dependency list is determined by the surrounding code: If either or change, your Effect will reconnect to the chat using the new values. Reactive values include props and all variables and functions declared directly inside of your component. Since and are reactive values, you can’t remove them from the dependencies. If you try to omit them and your linter is correctly configured for React, the linter will flag this as a mistake you need to fix: To remove a dependency, you need to “prove” to the linter that it doesn’t need to be a dependency. For example, you can move out of your component to prove that it’s not reactive and won’t change on re-renders: Now that is not a reactive value (and can’t change on a re-render), it doesn’t need to be a dependency. If your Effect’s code doesn’t use any reactive values, its dependency list should be empty ( ): An Effect with empty dependencies doesn’t re-run when any of your component’s props or state change. If you have an existing codebase, you might have some Effects that suppress the linter like this: When dependencies don’t match the code, there is a high risk of introducing bugs. By suppressing the linter, you “lie” to React about the values your Effect depends on. Instead, prove they’re unnecessary.\n\nNow that you create the object inside the Effect, the Effect itself only depends on the string. With this fix, typing into the input doesn’t reconnect the chat. Unlike an object which gets re-created, a string like doesn’t change unless you set it to another value. Read more about removing dependencies. If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the function is different for every render: By itself, creating a function from scratch on every re-render is not a problem. You don’t need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render. Avoid using a function created during rendering as a dependency. Instead, declare it inside the Effect:"
    },
    {
        "link": "https://legacy.reactjs.org/docs/hooks-overview.html",
        "document": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.\n\nHooks are backwards-compatible. This page provides an overview of Hooks for experienced React users. This is a fast-paced overview. If you get confused, look for a yellow box like this:\n\n↑↑↑ Each section ends with a yellow box like this. They link to detailed explanations.\n\nThis example renders a counter. When you click the button, it increments the value:\n\nHere, is a Hook (we’ll talk about what this means in a moment). We call it inside a function component to add some local state to it. React will preserve this state between re-renders. returns a pair: the current state value and a function that lets you update it. You can call this function from an event handler or somewhere else. It’s similar to in a class, except it doesn’t merge the old and new state together. (We’ll show an example comparing to in Using the State Hook.)\n\nThe only argument to is the initial state. In the example above, it is because our counter starts from zero. Note that unlike , the state here doesn’t have to be an object — although it can be if you want. The initial state argument is only used during the first render.\n\nYou can use the State Hook more than once in a single component:\n\nThe array destructuring syntax lets us give different names to the state variables we declared by calling . These names aren’t a part of the API. Instead, React assumes that if you call many times, you do it in the same order during every render. We’ll come back to why this works and when this is useful later.\n\nBut what is a Hook?\n\nHooks are functions that let you “hook into” React state and lifecycle features from function components. Hooks don’t work inside classes — they let you use React without classes. (We don’t recommend rewriting your existing components overnight but you can start using Hooks in the new ones if you’d like.)\n\nReact provides a few built-in Hooks like . You can also create your own Hooks to reuse stateful behavior between different components. We’ll look at the built-in Hooks first.\n\nYou’ve likely performed data fetching, subscriptions, or manually changing the DOM from React components before. We call these operations “side effects” (or “effects” for short) because they can affect other components and can’t be done during rendering.\n\nThe Effect Hook, , adds the ability to perform side effects from a function component. It serves the same purpose as , , and in React classes, but unified into a single API. (We’ll show examples comparing to these methods in Using the Effect Hook.)\n\nFor example, this component sets the document title after React updates the DOM:\n\nWhen you call , you’re telling React to run your “effect” function after flushing changes to the DOM. Effects are declared inside the component so they have access to its props and state. By default, React runs the effects after every render — including the first render. (We’ll talk more about how this compares to class lifecycles in Using the Effect Hook.)\n\nEffects may also optionally specify how to “clean up” after them by returning a function. For example, this component uses an effect to subscribe to a friend’s online status, and cleans up by unsubscribing from it:\n\nIn this example, React would unsubscribe from our when the component unmounts, as well as before re-running the effect due to a subsequent render. (If you want, there’s a way to tell React to skip re-subscribing if the we passed to didn’t change.)\n\nJust like with , you can use more than a single effect in a component:\n\nHooks let you organize side effects in a component by what pieces are related (such as adding and removing a subscription), rather than forcing a split based on lifecycle methods.\n\nHooks are JavaScript functions, but they impose two additional rules:\n• Only call Hooks at the top level. Don’t call Hooks inside loops, conditions, or nested functions.\n• Only call Hooks from React function components. Don’t call Hooks from regular JavaScript functions. (There is just one other valid place to call Hooks — your own custom Hooks. We’ll learn about them in a moment.)\n\nWe provide a linter plugin to enforce these rules automatically. We understand these rules might seem limiting or confusing at first, but they are essential to making Hooks work well.\n\nSometimes, we want to reuse some stateful logic between components. Traditionally, there were two popular solutions to this problem: higher-order components and render props. Custom Hooks let you do this, but without adding more components to your tree.\n\nEarlier on this page, we introduced a component that calls the and Hooks to subscribe to a friend’s online status. Let’s say we also want to reuse this subscription logic in another component.\n\nFirst, we’ll extract this logic into a custom Hook called :\n\nIt takes as an argument, and returns whether our friend is online.\n\nNow we can use it from both components:\n\nThe state of each component is completely independent. Hooks are a way to reuse stateful logic, not state itself. In fact, each call to a Hook has a completely isolated state — so you can even use the same custom Hook twice in one component.\n\nCustom Hooks are more of a convention than a feature. If a function’s name starts with ” ” and it calls other Hooks, we say it is a custom Hook. The naming convention is how our linter plugin is able to find bugs in the code using Hooks.\n\nYou can write custom Hooks that cover a wide range of use cases like form handling, animation, declarative subscriptions, timers, and probably many more we haven’t considered. We are excited to see what custom Hooks the React community will come up with.\n\nThere are a few less commonly used built-in Hooks that you might find useful. For example, lets you subscribe to React context without introducing nesting:\n\nAnd lets you manage local state of complex components with a reducer:\n\nPhew, that was fast! If some things didn’t quite make sense or you’d like to learn more in detail, you can read the next pages, starting with the State Hook documentation.\n\nYou can also check out the Hooks API reference and the Hooks FAQ.\n\nFinally, don’t miss the introduction page which explains why we’re adding Hooks and how we’ll start using them side by side with classes — without rewriting our apps."
    },
    {
        "link": "https://w3schools.com/react/react_useeffect.asp",
        "document": "The Hook allows you to perform side effects in your components.\n\nSome examples of side effects are: fetching data, directly updating the DOM, and timers.\n\naccepts two arguments. The second argument is optional.\n\nLet's use a timer as an example.\n\nBut wait!! It keeps counting even though it should only count once!\n\nruns on every render. That means that when the count changes, a render happens, which then triggers another effect.\n\nThis is not what we want. There are several ways to control when side effects run.\n\nWe should always include the second parameter which accepts an array. We can optionally pass dependencies to in this array.\n\nSo, to fix this issue, let's only run this effect on the initial render.\n\nHere is an example of a Hook that is dependent on a variable. If the variable updates, the effect will run again: import { useState, useEffect } from \"react\"; import ReactDOM from \"react-dom/client\"; function Counter() { const [count, setCount] = useState(0); const [calculation, setCalculation] = useState(0); useEffect(() => { setCalculation(() => count * 2); }, [count]); // <- add the count variable here return ( <> <p>Count: {count}</p> <button onClick={() => setCount((c) => c + 1)}>+</button> <p>Calculation: {calculation}</p> </> ); } const root = ReactDOM.createRoot(document.getElementById('root')); root.render(<Counter />);\n\nIf there are multiple dependencies, they should be included in the dependency array.\n\nTimeouts, subscriptions, event listeners, and other effects that are no longer needed should be disposed.\n\nWe do this by including a return function at the end of the Hook."
    },
    {
        "link": "https://devonblog.com/frontend/reactjs/mastering-side-effects-in-functional-components-with-reacts-useeffect-hook",
        "document": "Welcome to another blog on React Hooks. In this article, we will discuss about which is used for handling side effects in functional components\n\nWhat are the Side Effects?\n\nIn React, a side effect is any operation that interacts with the world outside the confines of a React component. This includes actions that can alter the state of the application, interact with the browser, or perform asynchronous tasks. Here are some common examples:\n• API Calls: Fetching or sending data to an external server. These actions are asynchronous and not part of React’s internal state management or rendering process, making them side effects.\n• Direct DOM Manipulations: Directly manipulating the DOM using JavaScript, such as changing an element’s style or attributes with methods like . These actions bypass React’s virtual DOM, which is designed to efficiently update the web page.\n• Timers: Implementing delays or repeated actions with or . These functions schedule future changes that are executed outside the usual flow of React’s component rendering, thus constituting side effects.\n• Subscriptions: Establishing connections to external data sources, such as setting up web sockets or subscribing to data streams with observables. These connections persist beyond the lifecycle of individual renders and need to be managed to prevent issues like memory leaks.\n\nAs discussed above is a special function provided by React that allows us to handle side effects that happen beyond the React component and helps us to synchronize with external systems.\n\nLet’s look at the syntax\n• \n• \n• \n• This is the function where you put the code that has side effects.\n• The function can optionally return another function, known as the cleanup function, which is used to clean up the side effects (like removing event listeners, canceling subscriptions, or clearing timers) before the effect runs again.\n• \n• \n• \n• This is an optional array that determines when the should run.\n• The will run after every render by default if no dependency array is provided.\n• If an empty array is provided, the will run only once after the initial render, mimicking the behavior of in-class components.\n• If you include values (usually props or state) in the array, the will run after the initial render and then after every render where the included dependencies have changed since the last render.\n\nLet’s review a simple counter application in which we increment a state on button click, and log the current count in a state, which updates on every component render.\n\nDefault: In this example, the console.log(“Render”) and setLog(`Current count is ${count}`) will display output on every button click as the state changes and the component is re-rendered.\n\n\n\n Empty Array ([]): In this example, the console.log(“Render”) and setLog(Current count is ${count}) will display output only on the initial render, regardless of the number of times the button is clicked.\n\nWith Values: In this example, the console.log(“Render”) and setLog(Button is clicked ${count} time(s)) will display output whenever the state is updated for the count and vehicleManufacturer.\n\nMultiple useEffect in a Component: When it comes to managing side effects in React components, multiple hooks are your secret weapon. Not only do they keep your code clean and organized, but they also give you ninja-level control over the dependencies.\n\nA simple example would be to showcase a product and its stock at regular intervals; in this case, we would separate the effects for handling the API call to get the product details and for showcasing the stock.\n\nCleanup functions are essential for preventing memory leaks and unwanted behavior when components unmount, which typically occurs when they are removed from the DOM due to various scenarios such as state changes, navigation, or routing.\n\nThe cleanup function is executed before the component unmounts and after the effect runs, including after the initial render.\n\nExample of cleanup function for removing event listener.\n\nis typically used directly inside a functional component, however, if we find ourselves repeating the same logic in multiple components we can consider creating a custom hook that encapsulates the logic. This helps us make the code more modular and easier to maintain.\n\nLet’s take the basic counter-example we showcased previously, which involves dependent arrays, and demonstrate how to transform it into a custom hook for utilization.\n\nIn this article, we’ve explored the hook, an essential tool for managing side effects in React’s functional components. We examined the basic syntax and various dependencies with practical examples and discussed the common mistakes that can occur when adding dependencies. We also covered the concepts of cleanup functions and with custom hooks.\n\nis a pivotal tool used in the React ecosystem, alongside . As we continue our series on React hooks, remember that each hook offers distinct benefits that enhance the capabilities of your React applications. Stay tuned for further explorations of React hooks, which will equip you with the knowledge to build more dynamic and robust applications. Keep learning and experimenting — your journey through React’s capabilities is just beginning. Happy coding!"
    },
    {
        "link": "https://react-redux.js.org/api/hooks",
        "document": "React's \"hooks\" APIs give function components the ability to use local component state, execute side effects, and more. React also lets us write custom hooks, which let us extract reusable hooks to add our own behavior on top of React's built-in hooks.\n\nReact Redux includes its own custom hook APIs, which allow your React components to subscribe to the Redux store and dispatch actions.\n\nThese hooks were first added in v7.1.0.\n\nAs with , you should start by wrapping your entire application in a component to make the store available throughout the component tree:\n\nFrom there, you may import any of the listed React Redux hooks APIs and use them within your function components.\n\nAllows you to extract data from the Redux store state for use in this component, using a selector function.\n\nThe selector will be called with the entire Redux store state as its only argument. The selector may return any value as a result, including directly returning a value that was nested inside , or deriving new values. The return value of the selector will be used as the return value of the hook.\n\nThe selector will be run whenever the function component renders (unless its reference hasn't changed since a previous render of the component so that a cached result can be returned by the hook without re-running the selector). will also subscribe to the Redux store, and run your selector whenever an action is dispatched.\n\nWhen an action is dispatched, will do a reference comparison of the previous selector result value and the current result value. If they are different, the component will be forced to re-render. If they are the same, the component will not re-render. uses strict reference equality checks by default, not shallow equality (see the following section for more details).\n\nThe selector is approximately equivalent to the argument to conceptually.\n\nYou may call multiple times within a single function component. Each call to creates an individual subscription to the Redux store. Because of the React update batching behavior used in React Redux v7, a dispatched action that causes multiple s in the same component to return new values should only result in a single re-render.\n\nWhen the function component renders, the provided selector function will be called and its result will be returned from the hook. (A cached result may be returned by the hook without re-running the selector if it's the same function reference as on a previous render of the component.)\n\nHowever, when an action is dispatched to the Redux store, only forces a re-render if the selector result appears to be different than the last result. The default comparison is a strict reference comparison. This is different than , which uses shallow equality checks on the results of calls to determine if re-rendering is needed. This has several implications on how you should use .\n\nWith , all individual fields were returned in a combined object. It didn't matter if the return object was a new reference or not - just compared the individual fields. With , returning a new object every time will always force a re-render by default. If you want to retrieve multiple values from the store, you can:\n• Call multiple times, with each call returning a single field value\n• Use Reselect or a similar library to create a memoized selector that returns multiple values in one object, but only returns a new object when one of the values has changed.\n• Use the function from React-Redux as the argument to , like:\n• Use a custom equality function as the argument to , like:\n\nThe optional comparison function also enables using something like Lodash's or Immutable.js's comparison capabilities.\n\nUsing props via closure to determine what to extract:\n\nWhen using with an inline selector as shown above, a new instance of the selector is created whenever the component is rendered. This works as long as the selector does not maintain any state. However, memoizing selectors (e.g. created via from ) do have internal state, and therefore care must be taken when using them. Below you can find typical usage scenarios for memoizing selectors.\n\nWhen the selector does only depend on the state, simply ensure that it is declared outside of the component so that the same selector instance is used for each render:\n\nThe same is true if the selector depends on the component's props, but will only ever be used in a single instance of a single component:\n\nHowever, when the selector is used in multiple component instances and depends on the component's props, you need to ensure that selector's memoization behavior is properly configured (see here for details).\n\nruns some extra checks in development mode to watch for unexpected behavior. These checks do not run in production builds.\n\nIn development, the provided selector function is run an extra time with the same parameter during the first call to , and warns in the console if the selector returns a different result (based on the provided).\n\nThis is important, as a selector that returns a different result reference when called again with the same inputs will cause unnecessary rerenders.\n\nIf a selector result is suitably stable (or the selector is memoized), it will not return a different result and no warning will be logged.\n\nBy default, this will only happen when the selector is first called. You can configure the check in the Provider or at each call.\n\nIn development, a check is conducted on the result returned by the selector. It warns in the console if the result is the same as the parameter passed in, i.e. the root state.\n\nA call returning the entire root state is almost always a mistake, as it means the component will rerender whenever anything in state changes. Selectors should be as granular as possible, like .\n\nBy default, this will only happen when the selector is first called. You can configure the check in the Provider or at each call.\n\nThere are some differences between the selectors passed to and a function:\n• The selector may return any value as a result, not just an object.\n• The selector normally should return just a single value, and not an object. If you do return an object or an array, be sure to use a memoized selector to avoid unnecessary re-renders.\n• The selector function does not receive an argument. However, props can be used through closure (see the examples above) or by using a curried selector.\n• You can use the option to customize the comparison behavior\n\nThis hook returns a reference to the function from the Redux store. You may use it to dispatch actions as needed.\n\nWhen passing a callback using to a child component, you may sometimes want to memoize it with . If the child component is trying to optimize render behavior using or similar, this avoids unnecessary rendering of child components due to the changed callback reference.\n\nThis hook returns a reference to the same Redux store that was passed in to the component.\n\nThis hook should probably not be used frequently. Prefer as your primary choice. However, this may be useful for less common scenarios that do require access to the store, such as replacing reducers.\n\nThe component allows you to specify an alternate context via the prop. This is useful if you're building a complex reusable component, and you don't want your store to collide with any Redux store your consumers' applications might use.\n\nTo access an alternate context via the hooks API, use the hook creator functions:\n\nOne of the most difficult aspects of React Redux's implementation is ensuring that if your function is defined as , it will be called with the \"latest\" props every time. Up through version 4, there were recurring bugs reported involving edge case situations, such as errors thrown from a function for a list item whose data had just been deleted.\n\nStarting with version 5, React Redux has attempted to guarantee that consistency with . In version 7, that is implemented using a custom class internally in , which forms a nested hierarchy. This ensures that connected components lower in the tree will only receive store update notifications once the nearest connected ancestor has been updated. However, this relies on each instance overriding part of the internal React context, supplying its own unique instance to form that nesting, and rendering the with that new context value.\n\nWith hooks, there is no way to render a context provider, which means there's also no nested hierarchy of subscriptions. Because of this, the \"stale props\" and \"zombie child\" issues may potentially re-occur in an app that relies on using hooks instead of .\n• a selector function relies on this component's props to extract data\n• a parent component would re-render and pass down new props as a result of an action\n• but this component's selector function executes before this component has had a chance to re-render with those new props\n\nDepending on what props were used and what the current store state is, this may result in incorrect data being returned from the selector, or even an error being thrown.\n\n\"Zombie child\" refers specifically to the case where:\n• Multiple nested connected components are mounted in a first pass, causing a child component to subscribe to the store before its parent\n• An action is dispatched that deletes data from the store, such as a todo item\n• The parent component would stop rendering that child as a result\n• However, because the child subscribed first, its subscription runs before the parent stops rendering it. When it reads a value from the store based on props, that data no longer exists, and if the extraction logic is not careful, this may result in an error being thrown.\n\ntries to deal with this by catching all errors that are thrown when the selector is executed due to a store update (but not when it is executed during rendering). When an error occurs, the component will be forced to render, at which point the selector is executed again. This works as long as the selector is a pure function and you do not depend on the selector throwing errors.\n\nIf you prefer to deal with this issue yourself, here are some possible options for avoiding these problems altogether with :\n• Don't rely on props in your selector function for extracting data\n• In cases where you do rely on props in your selector function and those props may change over time, or the data you're extracting may be based on items that can be deleted, try writing the selector functions defensively. Don't just reach straight into - read first, and verify that it exists before trying to read .\n• Because adds the necessary to the context provider and delays evaluating child subscriptions until the connected component has re-rendered, putting a connected component in the component tree just above the component using will prevent these issues as long as the connected component gets re-rendered due to the same store update as the hooks component.\n\nAs mentioned earlier, by default will do a reference equality comparison of the selected value when running the selector function after an action is dispatched, and will only cause the component to re-render if the selected value changed. However, unlike , does not prevent the component from re-rendering due to its parent re-rendering, even if the component's props did not change.\n\nIf further performance optimizations are necessary, you may consider wrapping your function component in :\n\nWe've pared down our hooks API from the original alpha release, focusing on a more minimal set of API primitives. However, you may still wish to use some of the approaches we tried in your own apps. These examples should be ready to copy and paste into your own codebase.\n\nThis hook was in our original alpha release, but removed in , based on Dan Abramov's suggestion. That suggestion was based on \"binding action creators\" not being as useful in a hooks-based use case, and causing too much conceptual overhead and syntactic complexity.\n\nYou should probably prefer to call the hook in your components to retrieve a reference to , and manually call in callbacks and effects as needed. You may also use the Redux function in your own code to bind action creators, or \"manually\" bind them like .\n\nHowever, if you'd like to still use this hook yourself, here's a copy-pastable version that supports passing in action creators as a single function, an array, or an object.\n\nThere are some architectural trade offs to take into consideration when deciding whether to use hooks or not. Mark Erikson summarizes these nicely in his two blog posts Thoughts on React Hooks, Redux, and Separation of Concerns and Hooks, HOCs, and Tradeoffs."
    },
    {
        "link": "https://geeksforgeeks.org/react-redux-hooks-useselector-and-usedispatch",
        "document": "State management is a major aspect of building React applications, allowing users to maintain and update application state predictably. With the introduction of React Hooks, managing state has become even more streamlined and efficient.\n\nAmong the most commonly used hooks for state management in React Redux are useSelector and useDispatch. In this article, we'll explore how these hooks work and how they can simplify your React Redux development process.\n\nuseSelector is a hook provided by React Redux that allows functional components to extract and access data from the Redux store. It subscribes to the Redux store, and whenever the store is updated, the component re-renders to reflect the changes. Here's a breakdown of how to use useSelector:\n• None Import the useSelector hook from the 'react-redux' library.\n• useSelector within your functional component, passing in a selector function.\n• None The selector function defines which part of the state you want to extract and use within your component.\n• useSelector returns the selected data from the Redux store, which you can then use within your component.\n\nuseDispatch is another hook provided by React Redux, which allows functional components to dispatch actions to the Redux store. It returns a reference to the dispatch function from the Redux store, enabling components to trigger state changes. Here's how to use useDispatch:\n• None Import the useDispatch hook from the 'react-redux' library.\n• None Call useDispatch within your functional component to get a reference to the dispatch function.\n• None Use the dispatch function to dispatch actions to the Redux store, which will update the state accordingly.\n\nExample: Below is the example to show the concept of useSelector().\n• None Install the necessary package in your application using the following command.\n\nStart your application using the following command.\n• Simplified Syntax : The hooks provide a more concise and cleaner syntax compared to traditional methods of connecting components to the Redux store, such as using\n• Functional Components : Since hooks are designed for functional components, they align well with the modern React paradigm. This allows developers to write more functional and composable code.\n• Better Performance hook automatically subscribes the component to the Redux store, but it only re-renders when the selected state value it depends on changes. This can lead to better performance by preventing unnecessary re-renders.\n• Improved Code Organization : Using hooks allows you to colocate your Redux-related logic directly within your functional components, making it easier to understand and maintain.\n• Learning Curve : Switching from older methods to hooks might take some time to get used to, especially for developers who are not familiar with React hooks. It may require learning new concepts and patterns.\n• Dependency on Hooks : Hooks are a newer feature in React, so your codebase becomes dependent on them. If you need to support older versions of React or if hooks change in the future, it could impact your codebase's compatibility.\n• Redux Coupling : While hooks provide a cleaner way to access Redux state, they still tightly connect your components to the Redux store. This might make it harder to refactor or reuse components independently from Redux.\n• Performance Concerns : While hooks are optimized to only re-render when necessary, incorrect usage or excessive re-renders can still affect performance. users need to be careful, especially in complex applications."
    },
    {
        "link": "https://builtin.com/software-engineering-perspectives/useselector-usedispatch-react-redux",
        "document": "React Redux offers a set of hooks as an alternative to the existing higher-order component. These hooks allow you to connect to the Redux store and dispatch actions without having to wrap your components in .\n\nThis guide will cover how to implement the React-Redux hooks useSelector and useDispatch in your application.\n\nMore in Software EngineeringWhat Is React?\n\nBegin by installing the following in your app:\n\nThe examples in this guide will be referring to my repository, available here.\n\nHere is a quick gif of the app’s functionality:\n\nThere are two separate states, one for keeping track of the counter and one for keeping track of a logged-in user. We will have separate files to handle each state.\n\nMore in Software Engineering10 iOS Development Tips for Swift and Xcode\n\nLet’s begin by defining the actions for the counter in . A couple of methods are necessary: increment and decrement. We will export these two methods in an object.\n\nSimilarly, let’s define the actions for the current user in , which will also have two methods, and , that will be exported in an object.\n\nTo be organized, we import these two files under one location, the file, within the actions folder. We create a variable and set it to an object that contains the imported actions that will be exported.\n\nSimilar to the approach taken for the actions file structure, we create a separate reducers folder to hold the user and the counter reducers. Let’s start with the counter reducer, .\n\nA reducer function takes in two arguments, the state and the action. The state doesn’t necessarily have to be set to an object. In this case, the default value of the state is set to an integer.\n\nAs we defined earlier, an action returns an object that can contain two keys: type and, optionally, a payload. Based on the action type, the value of the state will be changed. Keep in mind that a default case is necessary in the event that an action type is called that doesn’t exist to prevent the app from breaking.\n\nFor the current user reducer, , the state will be set to an empty object that will contain the keys user and loggedIn. Notice the difference in what is being returned between counter and currentUser. In all cases, the counter reducer returns an integer since its initial value was an integer. In the case of the current user reducer, an object is always returned.\n\nWe need to combine these reducers into one. Under , let’s import the reducer files as well as combineReducers:\n\nCombine reducers does what its name implies and combines the separate reducer files into one. It takes in one argument: an object that contains the reducer files. Now that our actions and reducers are set, let’s move on to implementing Redux in our app.\n\nIn our under the src folder, we will import the following:\n\nA Redux store will be created with the method createStore. It takes in two arguments, the rootReducer, which is the file that combined our reducers, and the Redux devtools extension.\n\nFinally, we wrap our app component with the provider component from React Redux. The provider component will take in one prop, store, which will be set to the store from createStore.\n\nMaster Software EngineeringCreating an Npm-Only Build Step for JavaScript — the Easy Way\n\nWe import the following hooks from React Redux: useSelector and useDispatch. Before, we had to import from React Redux and wrap our components with it in order to map state to props and map dispatch to props.\n\nThe equivalent of map state to props is useSelector. It takes in a function argument that returns the part of the state that you want. In this case, we have the following keys from state defined: counter and currentUser. We defined these earlier when combining reducers.\n\nThus, the variables counter and currentUser are set to the state defined by their respective reducers.\n\nThe equivalent of map dispatch to props is useDispatch. We will invoke useDispatch and store it to a variable, dispatch. Dispatch will work with the allActions imported from the actions folder. For example, useEffect calls a dispatch with the following action: . User is defined as:\n\nKeep in mind, allActions is an object with userActions and counterActions as keys. Just as a refresher on the setUser function defined in :\n\nsetUser will return an object with type and payload. Dispatch will take this object and look through the reducers that match the action type. In this particular case, it is located in within reducers folder.\n\nAnd there you have it. The React-Redux hooks useSelector and useDispatch are implemented in the React App. Compared to the alternative, the code is cleaner and more organized.\n\nThank you for reading!"
    },
    {
        "link": "https://react-redux.js.org/introduction/getting-started",
        "document": "React Redux is the official React UI bindings layer for Redux. It lets your React components read data from a Redux store, and dispatch actions to the store to update state.\n\nReact Redux 8.x requires React 16.8.3 or later / React Native 0.59 or later, in order to make use of React Hooks.\n\nThe recommended way to start new apps with React and Redux is by using our official Redux+TS template for Vite, or by creating a new Next.js project using Next's template.\n\nBoth of these already have Redux Toolkit and React-Redux configured appropriately for that build tool, and come with a small example app that demonstrates how to use several of Redux Toolkit's features.\n\nWe do not currently have official React Native templates, but recommend these templates for standard React Native and for Expo:\n\nTo use React Redux with your React app, install it as a dependency:\n\nYou'll also need to install Redux and set up a Redux store in your app.\n\nReact-Redux v8 is written in TypeScript, so all types are automatically included.\n\nReact Redux includes a component, which makes the Redux store available to the rest of your app:\n\nReact Redux provides a pair of custom React hooks that allow your React components to interact with the Redux store.\n\nreads a value from the store state and subscribes to updates, while returns the store's method to let you dispatch actions.\n\nRedux maintainer Mark Erikson appeared on the \"Learn with Jason\" show to explain how we recommend using Redux today. The show includes a live-coded example app that shows how to use Redux Toolkit and React-Redux hooks with Typescript, as well as the new RTK Query data fetching APIs.\n\nSee the \"Learn Modern Redux\" show notes page for a transcript and links to the example app source.\n\nThe #redux channel of the Reactiflux Discord community is our official resource for all questions related to learning and using Redux. Reactiflux is a great place to hang out, ask questions, and learn - come join us!\n\nYou can also ask questions on Stack Overflow using the #redux tag."
    },
    {
        "link": "https://dev.to/efkumah/how-to-manage-state-in-a-react-app-using-redux-5pc",
        "document": "In this tutorial, you will manage the state of a React app using Redux. Redux helps you track and manage the state of an entire application in a single object instead of having the state and logic in a top-level component.\n\nYou will build a to-do app that centralizes the state and logic using Redux.\n\nBy the end of the tutorials you will know:\n• None What Redux is and the benefit of using Redux for state management.\n• None Understand and use Redux concepts such as the store, reducer, actions, etc. in a Todo app.\n\nThe tutorial will be in two sections. The first section explains key concepts, the Redux architecture, and the basic usage of Redux. In the next section, we will build a Todo app using Redux for state management.\n\nTo get the most out of this tutorial you should be familiar with:\n\nReact enables developers to build complex user interfaces easily. To add interactivity to the UI, React components need access to data. The data can be a response from an API endpoint or defined within the app. This data will be updated in response to an interaction, such as when a user clicks on a button, or types into an input field.\n\nInside a React component, the data is stored in an called . Whenever changes, the component will re-render, and React will update the screen to display the new data as part of the UI.\n\nIn a React app, multiple components may need access to the state. Hence, it needs to be effectively managed. Effective state management entails being able to store and update data in an application.\n\nWith Redux, you have a central store to keep, update, and monitor the state of your application. That means, our components may not have states. The state will be in a central location and can be accessed by multiple components in your application.\n\nA basic React app can be segmented into the following:\n• None State: The current condition of the app\n• None View: The UI of the app\n• None Actions: A function that updates the state when an event occurs in your app (generally referred to as Event handlers).\n\nEvery component in an app can have a state. However, it becomes a challenge if multiple components need access to the same data. To solve this issue, we \"lift the state up\". Lifting state up is a process where you move the state from a child component to its parent (top-level) component. With this approach, you can easily share state between multiple child components.\n\nHowever, there are disadvantages to \"lifting state up\":\n• None It can complicate your code: Lifting the state up can add huge boilerplate code to your components. The state must be passed down from the parent component to the child components resulting in . Additionally, the state is updated in the parent component.\n• None It can impact performance: When you lift the state up, you increase the number of components that will re-render when the state changes. This can affect performance, especially on mobile devices.\n\nIn a large-scale single-page application, our code will manage more states. This state can include server responses and cached data, as well as locally created data that has not yet been persisted to the server. It will get to the stage where you will lose control over when, why and how the state updates. Making it difficult to reproduce bugs or add new features.\n\nA better approach is to extract the shared states from the parent component and put them into a centralized location outside the component tree.\n\nThis is a better approach because:\n• None Regardless of the component position, you can trigger actions from any component inside the parent component, and the state can be modified.\n\nThat is the concept behind Redux. It helps developers manage global state (a state that is needed across many parts of our app), and make the state accessible by all components irrespective of how deeply nested they are.\n\nThe first rule of Redux is that everything that can be modified in your application should be represented in a single object called the or the\n\nThere are key terms to know when using Redux. To make it easy to understand these terms we will first consider an analogy for Redux. After this, we will define the terms in the next sections.\n\nImagine you are the Managing Partner of a huge restaurant. To be well versed in managing the restaurant, you decide to keep track of the state of the restaurant.\n\nYou might want to track:\n• None The stock of the various ingredients available\n\nTo keep all this information in your brain will be a hassle. Instead, you keep them in a central location called the store ( ).\n\nYou hire an attendant ( ) who is the only person who can update the store's information.\n\nThere are shareholders ( ) who rely on the state(data) of the restaurant to update their portfolio ( ). These shareholders can only access data and cannot modify it.\n\nNow let us assume the shareholders hire a new chef and the store's data need to be updated. Because they cannot update the data, a shareholder can send ( ) a note with that new information to the attendant( ). He then updates the previous data in the store with the latest information.\n\nAnytime data is updated, the rest of the shareholders are notified ( ), and they can update their portfolio ( )\n\nBelow are the new terms to be familiar with:\n\nThe second rule of Redux is that the is read-only. You can only modify the state tree by sending an . This ensures that neither the views nor the network callbacks will ever write directly to the state. Instead, they express an intent to transform the state.\n\nIn other words, is the only recommended way to change the application .\n\nAn action describes what has occurred in the application. It is a JavaScript object passed as a parameter to the and holds the information required for the to update the .\n\nAn varies in any given application. For instance, in a counter app, you will only need the following\n\nIn a todo app, you may have the following :\n\nWith Redux, because we are separating the from the components, the components don't know exactly how the state changes. All they care about is that they need to send an .\n\nThe action has a property where you specify what event occurred in your component. That means whenever an event occurs, the event handler function will dispatch an with what has occurred to help update the in the store.\n\nThe also has a property. Any new data about the event will be in the . For instance, when I dispatch an of \"addedTodo\", the can contain the new to-do item and the ID.\n\nBelow are examples of objects:\n\n\n\nThe are functions that return objects. Because the contains the logic that can be used in multiple instances of the application, you can pass it some that can be accessed in the objects.\n\nBelow are examples of :\n\n\n\nA is a pure function that accepts the current and an as and returns the updated . It is called a because similar to the method, the Redux reducer reduces a set of actions over time into a single state.\n\nThe reducer should be a pure function. A pure function is a function that will return the same output for the same input. It does not change or modify the global state or the state of any other functions.\n\nWhat this means is :\n• None A reducer function is not allowed to modify the current . Instead, they must make a copy of the current and update the copied values.\n• None A reducer function should not update the state by reading from a database\n• None A reducer function should not make a call to any third-party API\n\nBelow is the syntax of a reducer function:\n\n\n\nThe logic inside the reducer function is as below:\n• None In the body of the function, we check the property.\n• None If the of action matches something you have defined, you will make a copy of the , and modify that state with the new value from the\n• None If the does not match anything you have defined, you will return the existing\n\nBelow is an example of a function:\n\n\n\nBelow is what is happening:\n• None In the statement verify if the matches the expression on the right ( )\n• None If it does, then we use the spread operator ( ) to make a copy of the , and update the copy with the new todo data derived from\n• None If not, we return the previous\n\nThe third principle of Redux is that to describe state changes, you declare a function that accepts the previous state of the app, the action being dispatched, and returns the next state of the app\n\nA in an object that holds the entire of your application. It is the central location of data and where data is updated.\n\nThe has three main methods:\n• None : Returns the current of the application\n• None : This is how to instruct the component to send an action to the store to change the of the application.\n• : The method will allow the components to listen for a change in data. It accepts a as a function that helps you:\n• Update the UI to reflect the current state\n• Perform side effects or any other task that needs to be done when the state changes.\n\nBelow is an example of how to create a in redux.\n\n\n\nDispatch is used to send to our . It is the only way to change the of our app.\n\nTo update the , you will call the method. When is called, the store will execute the reducers (the reducers have access to the current and an as input, and perform some logic). The store then updates its state with the output of the reducers.\n\nThe method accepts the object as an argument.\n\n\n\nIn the snippet above, for instance, whenever a user enters a new to-do, you will dispatch the action to the . Because there is a function inside the store, it will use the dispatched to determine the logic for the new state.\n\nSelectors are functions that help you extract specific data from the . It accepts the as an argument and returns the data to retrieve from the .\n\nYou will use the in your component to get specific data from the state.\n\n\n\nIn this section, we will use all the terminologies learned to explain how data flow in our app, and how the UI is re-rendered when the state changes.\n\nLet's take a look at the setup of Redux:\n• None Define the logic and pass the function to the store. The accepts the and object as arguments.\n• None The will run the logic in the function\n• None The value returned by the reducer function becomes the initial state of the app.\n• None When the component is mounted, it connects with the store, gets the initial state, and uses the state to display the UI. Because the component is connected to the store, it will have access to any state update.\n• None An event occurs in the app. For instance, a to-do item has been added\n• None The component dispatches the to the redux\n• None The re-runs the function. It has access to the previous , the object, and returns the updated state\n• None The notifies all the connected components of the state change.\n• None Each UI component will verify if it needs to use the updated state.\n• None If it does, it re-renders the UI with the new state and updates what is on the screen.\n\nIn this section, we will learn how to create a and actions to the store.\n\nThe Redux store brings together the , and of our application. It is the central location of the application's state.\n\nThe functions of the are to:\n• None Hold the current state of the application.\n• None Allow access to the current state\n• None Allow the state to be updated\n\nUse the method from the Redux library to create the . This method accepts a function as an argument.\n\nBelow is a code snippet on how to create a store:\n\n\n\nNext, you will need to pass the \"root reducer\" function to the . The root reducer combines all of the other reducers in your application.\n\nTo create a root reducer, you import the method from the Redux library. The helps you combine all the different reducer functions. It accepts an of reducer functions as its argument. The of the object will become the keys in your root state object, and the values are the reducer functions.\n\nBelow is an example of how to create a :\n\n\n\nNow, you have learned how to\n\nNext, you will learn how to get the initial state of the store and dispatch actions to the store\n\nTo update the of the application, the component needs to dispatch actions.\n\nBelow is how to do that:\n• None Import the into your application\n• None call the methods and pass it the objects.\n\n\n\nUse the method to subscribe to a store. The method will listen for changes to the of your app. This will help you update the UI to reflect the current , perform side effects, or any task that needs to be done when the changes.\n\nIn the code snippet below illustrates how to listen for updates, and log the latest state to the console:\n\n\n\nIn this section, you will use the concept learned to build a to-do app with basic functionalities ( add, delete, and complete a todo) while using redux for management.\n\nWe will not go in-depth into each implementation as we have covered the concepts earlier.\n\nHere are the steps to follow:\n• None Set up your React project and install the required dependencies\n• None Create your Todo components for the UI\n• None Create a redux to track and manage the of your app\n• None Define the logic and connect to the store\n\nThe repository for the project is found here. It has branches for each major step we will implement.\n\nCreate a React app in your project directory by following the steps below:\n• Start a project from the basic template using Vite by running the command below in your terminal:\n\n // Replace \"my-react-app\" with the name of your project.\n• Install the and dependencies in your file. Run the command\n\n This installs the core redux architecture and simplifies connecting the react app with redux.\n\nBelow is the UI for our app.\n• The components needed to create the UI of the app are:\n\nNext, we will need to create a to keep track of and manage the entire of the application. We do that using the method from Redux.\n• None Create a \"store\" folder in the root directory of your app\n• None Call the method, and pass the as an argument ( we will define this in the next step)\n• None Export the to be used inside your React app\n\n\n\nWe will define our reducer inside a file. Reducers are functions that contain the logic required to update the state and return a new state. The will also contain the initial state of our app.\n\nFollow the steps below to define a function:\n\nAdd the code snippet below to the file\n\n\n\nIn the code above:\n• None We added the initial of our app. It is prefilled with an of todos to enable us to display some dummy data when the app is rendered.\n• None We define the function. This function accepts the and objects as parameters.\n• None In the body of the function, we implemented a statement. Based on the expression ( ) there is a logic in each on how the will be updated and returned.\n• None Finallly, we the and pass it as an argument to the method (as previously indicated).\n\nStep 5: Wrapping the component around your app\n\nThe component enables the Redux to be available to any nested components that need to access the .\n\nSince any React component in a React Redux app can be connected to the store, most applications will render a at the top level, with the entire app’s component tree inside of it.\n\nBelow is how to wrap our root component inside a\n• None Import the in the\n• None Wrap your root component in the\n• None The accepts a props with the imported as its value\n\n\n\nIn the code above, we have wrapped the around component to enable all nested components to access the\n\nNext, we would read and display data from the store using the hook\n\nStep 6: Reading and displaying the todos with hook\n\nReact-Redux has its custom hooks, which you can use in your components. The hook lets the React components read data from the Redux store. It accepts a selector function that takes the entire Redux store state as its argument, reads some value from the state, and returns that result.\n\nFollow the steps below to read and display data:\n• None Call the method. It accepts a selector function as a callback\n• None Return the from the\n\nThe code below illustrates how to read the from our store.\n• None The first time the component renders, the hook will execute the callback function.\n• None What is returned by the will be returned by the hook to be used in our component.\n• None The will hold the same data as the inside our Redux store state.\n• None We use the JavaScript method to iterate over each todo and display a single todo.\n• None The automatically subscribes to the Redux store. Hence, whenever an is dispatched, it will call the function. If the value returned by the has been updated, will force the component to re-render with the new data.\n\nWe know how to read and display data from the . Next, we will learn how to dispatch actions from the components to update the store\n\nThe hook provides access to the method that is needed to dispatch to update the .\n\nWe can call in any component that needs to dispatch actions, and then call as needed.\n\nIn the component, let's dispatch an action to add a new todo:\n• None Call the method. It returns the function\n• None Enter and submit the new todo\n• Call the method in the and pass the object\n\n\n\nIn the code above, on submitting a new todo:\n• None The dispatches the object to the function to update the\n\nBecause we have imported the hook, we can easily add a new todo to the store's state, and it will reflect in the UI.\n\nBelow is what we have done so far\n• None Wrap the around your top-level component to enable all other components to access and update the store.\n• None Call the hook to read data in React components\n• None Call the hook to dispatch actions in React components\n\nDispatching action on clicking the \"delete\" and \"complete\" buttons\n\nIn the components, we can now click on the \"delete\" and \"complete\" button. On clicking these buttons we dispatch actions to delete and complete a todo. These are handled in the and action creators.\n\nThe code snippet is as below:\n• Clicking the \"delete\" and \"complete\" button calls the and functions respectively. The function dispatches an action to the to delete the specified item while the function dispatches an action to the to complete the selected item.\n\nThe difference between Redux and Context API is how they manage states. In Redux state is managed in a central store. However, the Context API deals with state updates on a component level, as they happen within each component.\n\nYou might ask, can't you use the hook from the Context API to pass state to multiple components since that eliminates ?\n\nIn a scenario where a state affects multiple components or is required by all the components in an app, you can use the hook to manage . This avoids props drilling and makes data easily accessible in all components.\n\nHowever, there are some disadvantages to using :\n• The hook has a complex setup: When building an enterprise-level app where multiple components may need access to , you might have to use the API to create multiple contexts and provide each context with the data required for the different aspects of your application. For instance, you will create\n• Theming Context: to change the theme. For example, enable dark mode\n• Form Context: to pass form data to the form component, etc. This phenomenon might result in having to create multiple contexts to meet a specific need, leading to deeply nested Context Provider components in your application.\n• None Secondly, is not optimized for enterprise-level apps where the state changes frequently. This will decrease the performance of your app.\n• None Lastly, when using , UI logic and state management will be in the same component.\n\nBelow are some scenarios you might use Redux over :\n• None There are lots of states in your application, and these states are required in many places in the app.\n• None The app state is updated frequently over time\n• None The logic to update that state may be complex\n• None The app has a medium or large-sized codebase and might be worked on by multiple developers\n\nIn this tutorial, you managed the state of a React Todo app using Redux. Next, learn how to manage the state using the Redux Toolkit. Redux Toolkit makes it easier to write good Redux applications and speeds up development. Furthermore, learn Redux DevTools to help you trace when, where, why, and how your application's state changed."
    },
    {
        "link": "https://blog.logrocket.com/localstorage-javascript-complete-guide",
        "document": "Editor’s note: This post was updated by Muhmmed Ali on 28 February 2024 to include advanced data management techniques in . Check out our guide to storing and retrieving JavaScript objects in for more information.\n\nIt can be infuriating to accidentally close a webpage while filling out a form. You lose all the data already filled and have to start over. In this article, you’ll learn how to use in JavaScript to save your data beyond a single browsing session. We’ll show you how to use this mechanism and the property, and review the basics of web storage in JavaScript.\n\nWhat is in JavaScript?\n\nis a property that allows JavaScript sites and apps to save key-value pairs in a web browser with no expiration date. This means the data stored persists even after the user closes the browser or restarts the computer.\n\nis a object property, which makes it a global object that can interact with and manipulate the browser window. It can also be used in combination with other properties and methods.\n\nThe mechanism is available via the property. is part of the interface in JavaScript, which represents a window containing a DOM document.\n\nThe interface features a wide range of functions, constructors, objects, and namespaces. is a read-only property that returns a reference to the local storage object used to store data that is only accessible to the origin that created it.\n\nWhen to use\n\nPut simply, is used for storing and retrieving data. While you can store small amounts of data with , it’s not suitable for large datasets. is accessible to anyone who uses the device, so you shouldn’t use it to store sensitive information. You can use it to store user preferences, like language or theme. You can also use it to cache data if you use it frequently. can store form data that won’t be lost if the user closes the browser.\n\nIf you have an application that requires you to log in, can be used to keep your session data. You can remain logged in even after closing and reopening the browser. We’ll demonstrate this later in this tutorial using a simple to-do app.\n\nIn the meantime, for a refresher on how to use in JavaScript, check out the video tutorial below:\n\nIn Google Chrome, web storage data is saved in an SQLite file in a subfolder in the user’s profile. The subfolder is located at on Windows machines and on macOS. Firefox saves storage objects in an SQLite file called , which is also located in the user’s profile folder.\n\nis one of two mechanisms for the Web Storage API, the other being . The Web Storage API is a set of mechanisms that enables browsers to store key-value pairs. It is designed to be much more intuitive than using cookies.\n\nThe key-value pairs represent storage objects, which are similar to objects, except they remain intact during page loads and are always strings. You can access these values like an object or using the method (more on that later).\n\nBoth and maintain a separate storage area for each available origin for the duration of the page session. The main difference between them is that only maintains a storage area. At the same time, the browser is open (including when the page reloads or restores) while continues to store data after the browser is closed.\n\nstores data that won’t expire, while only stores data for a single session. It’s important to note that data loaded in an incognito browsing session will be cleared once the last private tab is closed. ‘s method is useful when temporary data storage is required, and it should be used in situations where data persistence beyond the current session is not required.\n\nTypically, has a smaller storage limit compared to , often limited to a few megabytes per origin. This makes it suitable for storing temporary data during a user’s session without consuming excessive browser resources.\n\n, on the other hand, provides a larger storage capacity, often ranging from 5-10 MB per origin. It is suited for storing larger amounts of data that need to persist across multiple sessions.\n\nin JavaScript is an important tool for storing client-side data. However, it has several advantages and disadvantages you should consider.\n\nThe first advantage of is one we’ve mentioned a few times already, and it is that stored data doesn’t expire. You can still access the data offline, and caches data that can be used without an internet connection.\n\nStoring data with is more secure than storing with cookies, and you have more control of your data. Lastly, has a larger storage capacity compared to cookies. While cookies can only store four kilobytes of data, can store up to five megabytes of data.\n\nis synchronous, meaning each operation only executes one after the other. This poses minimal issues for smaller datasets but as your data grows, this can become a larger issue.\n\nAlthough is more secure than cookies, you still shouldn’t use it to store sensitive data. Anyone with access to the user’s device can access the data stored with . Additionally, can only store strings, so if you want to store other data types, you’ll have to convert them to strings. And finally, storing too much data with can slow down your application.\n\nYou’ve heard it repeatedly by now — stores data. And, if you’re storing data, it means you may need to retrieve it later. In this section, we’ll explore exactly how works. Here’s a rundown of how it works:\n• : Adds key and value to\n• : Passes a number to retrieve the key of a\n\nThe method allows you to store values in . It takes two parameters: a key and a value. The key can be referenced later to fetch the value attached to it. Here’s how it should look:\n\nIn the code above, you can see that is the key and is the value. As we’ve already noted, can only store strings. To store arrays or objects in , you would have to convert them to strings.\n\nTo do this, we use the method before passing to , like so:\n\nallows you to access the data stored in the browser’s object. This method accepts only one parameter, the , and returns the as a string:\n\nThis returns a string with a value of . If the specified key doesn’t exist in , it’ll return . In the case of the array, we make use of the method, which converts a JSON string into a JavaScript object:\n\nUsing the array we created above, here’s how to retrieve it from :\n\nThis method will return the array . You can inspect the webpage, and find it in the console, like this:\n\nThis image is from Firefox, so it’ll look a little different on other browsers. Let’s compare it with another array that’s not stored with :\n\nNow, we have two arrays on the console, as shown below:\n\nNormally, if you comment them out in your code editor, they should disappear from the console. But anything stored with will remain. Here’s an example:\n\nTo delete an item from , you’ll use the method. When passing a key , the method removes the existing key from the storage. If no item is associated with the given key, this method will do nothing. Here’s the code:\n\nHow to delete all items in :\n\nTo delete all items in , you will use the method. This method, when invoked, clears the entire storage of all records for that domain. It does not receive any parameters. Use the following code:\n\nHow to get the name of a key:\n\nThe method comes in handy when you need to loop through keys but still be able to pass a number or index to to retrieve the name of the . Here’s what that looks like:\n\nThe parameter represents the zero-based index of the you want to retrieve the name for.\n\nStoring data in the browser with\n\nWe’ve reviewed all the methods; now we’ll look at them more practically. Here’s a to-do app built with :\n\nSee the Pen \n\n To-do App by Oscar-Jite (@oscar-jite)\n\n on CodePen.\n\nThe app has a very simple HTML markup:\n\nIn the code above, we’ve added two functions, and , that we’ll use later in the JavaScript. The CSS is also simple; you can style it however you like. The important part is the JavaScript. You’ll start by selecting the list where the tasks will be added and the field, as shown below:\n\nNext, you load any pre-existing items in . If there aren’t any, you create an empty , as shown below:\n\nNow, we’ll create a function that adds a task, which would be a , into the empty :\n\nNow, we add functionality to the buttons. The button stores the items in , and the button deletes every item. Here’s the code:\n\nThe function gets the items from the field, . It then adds them to the and saves them to while simultaneously adding them to the list. The function clears all items from , removes them from the list, and resets the .\n\nBoth and cookies are used to store client-side data. As we mentioned before, cookies can only store a maximum of four kilobytes of data, which is significantly less than ‘s five megabytes of storage capacity.\n\nCookies are automatically sent to the server with every HTTP request, but stays local within the user’s device. This can improve web performance and doesn’t increase network traffic because it doesn’t share data with the server.\n\nAs we’ve seen, the data you store with doesn’t expire; it stays indefinitely until you delete it manually. On the other hand, cookies can be set to expire after some time or as soon as you close the browser. Cookies usually store data like user preferences and login/authentication information. This data is accessible across all tabs and windows of the browser. However, only stores data that is accessible within a specific protocol or domain.\n\n, as a type of web storage, is an HTML5 specification. It is supported by major browsers, including Internet Explorer v8. You can use the following snippet to check if the browser supports :\n\nNow, we’ll explore some advanced techniques for managing data in . We will work on how to efficiently remove keys, employ best practices for storing and setting objects, and use JSON parsing and stringification for complex data.\n\nEfficiently removing keys from objects stored in is necessary to optimize storage space, especially if you are building an application where data is frequently updated or deleted. Deleting unnecessary keys helps prevent from becoming clustered with useless data.\n\nTo effectively remove a key from an object in , you can retrieve the object using the key, remove the desired property, and then set the updated object back into . This minimizes unnecessary data manipulation and storage overhead:\n\nJSON parsing and stringification are powerful techniques for handling complex data structures when storing and retrieving data in . They allow for easy conversion between JavaScript objects and JSON strings, enabling efficient data management and manipulation.\n\nWhen storing complex data structures like objects or arrays in , it’s essential to stringify them using before setting them into . This converts the JavaScript object into a JSON string, which can then be stored as a key-value pair:\n\nWhen dealing with nested objects or arrays, ensure that all nested objects are also stringified and parsed to maintain the integrity of the data structure:\n\nIn this article, we explored the capabilities of in JavaScript as a simple and efficient way to store and retrieve data without relying on cookies. We covered how and when to use , as well as how to save, retrieve, and delete items in . Through the example of a to-do app, we demonstrated in action, comparing it to cookies.\n\nIn this post, you learned how and when to use . We covered how to save, retrieve, and delete items in . We also created a to-do app to see how works in a practical scenario. Finally, we compared it to cookies.\n\nSo, you’ve learned about a great tool that’s easy to use with broad browser support. How will you implement in your next project? Happy coding!"
    },
    {
        "link": "https://medium.com/@ravipatel.it/javascript-local-storage-concepts-with-example-19cebaf3011b",
        "document": "Local Storage stores data as key-value pairs, where both the key and value are stored as strings. If you want to store other data types like arrays or objects, you’ll need to convert them into strings (using ).\n\nUnlike session storage (which clears data when the page is closed), Local Storage is persistent across browser sessions. Data stored in Local Storage remains until it is explicitly deleted or the user clears their browser’s cache.\n\nLocal Storage is not designed for storing large amounts of data. The limit varies across different browsers but is typically around 5MB per origin (domain).\n\nLocal Storage is accessible via JavaScript, making it vulnerable to cross-site scripting (XSS) attacks. Never store sensitive information like passwords or personal data in Local Storage.\n\nAll Local Storage operations are synchronous, meaning they block the main thread while being executed. This might lead to performance issues if you’re handling large amounts of data.\n\nThe Local Storage API is straightforward, with just a few core methods:\n• – Retrieves the data associated with the key.\n• – Removes the data associated with the key.\n• – Returns the number of items in Local Storage.\n• – Returns the key at a given index.\n\nLocal Storage stores data as strings, so if you want to store more complex data like objects or arrays, you’ll need to serialize them using and deserialize them using .\n\nExample: Storing and Retrieving an Object\n\nLet’s say you want to store user preferences (an object) in Local Storage:\n\nMany websites use Local Storage to save user preferences like theme settings (dark mode), language choices, or layout configurations. For example, once a user selects “dark mode,” the setting is saved in Local Storage, so the next time they visit the website, the theme automatically applies.\n\nLocal Storage can be used to maintain a shopping cart state in e-commerce websites. Even if the user leaves the site and returns later, the items they added to their cart can still be available.\n\nSometimes users may accidentally refresh a page while filling out a form. Local Storage can be used to persist the form data so that users don’t lose their progress."
    },
    {
        "link": "https://zipy.ai/blog/localstorage-in-javascript",
        "document": "Imagine being able to create personalized dashboards that remember a user's layout preferences, or crafting dynamic web games where players can pick up right where they left off, even if they close their browser. With web storages, this dream becomes reality.\n\nlocalStorage, sessionStorage, and cookies are different types of client-side storage methods, through which you can store, retrieve, and delete data.\n\nWe are covering localStorage in this blog because it is one of the most commonly used web storage methods. Throughout this guide, we'll navigate the ins and outs of local storage and learn how to store and retrieve data effortlessly, manage complex data structures.\n\nWhat does the term web storage API refer to?\n\nA set of technologies called the Web Storage API enables web browsers to store data in key-value pairs. This storage option is easier to use and more intuitive than using cookies.Using this method, key-value pairs represent objects that are similar to storage objects, with the exception that they are always stored as strings and remain intact even after a page reload. These values can be obtained by using the getItem() method, which we will go over in more depth later, or by accessing them like objects.\n\nHow is localStorage different from sessionStorage and cookies\n\nSessionStorage and localStorage are two distinct utilities offered by the web storage API. Every mechanism maintains a unique storage space for every available origin for the duration of the ongoing page session.\n\nThe main difference between localStorage and sessionStorage is that the formerStorage merely keeps the storage space open in the browser, even when the page is restored or refreshed. However, even if the browser is closed, data is still stored in localStorage. This implies that information saved in localStorage survives long after the browser is closed, whereas information saved in sessionStorage is deleted when the page is closed.\n\nAnother method for client-side data storage is through cookies. They do not have as much storage as web storage, though, and are less secure. Every HTTP request also includes cookies, which may have an impact on the application's performance.\n\nLet's now concentrate on using JavaScript's localStorage.\n\nW‎hat is the definition of loca‎lStorage in JavaScript?\n\nlocalStorage is a JavaScript property that enables websites and applications to store key-value pairs in a web browser, which per‎sists even after the browser window is closed. The data stays there when the user comes back or refreshes the page.\n\nThe data stored using web storage in Google Chrome is saved in an SQLite file that is stored in a subfolder of the user's profile. Here’s the code based upon the different types of machines and browsers.\n\nIn JavaScript, the localStorag‎e mechanism can be accessed using the Window.localStorage property, which is a part of the Window interface. The Window interface is associated with a window that contains a DOM document and includes various functions, constru‎ctors, objects, and namespaces.\n\nWindow.localStorage is a read-only property that provides a reference to the local sto‎rage object. This object is used to‎ store data, which is on‎ly accessible to the origin that created it. Therefore,‎ any website or application can only acce‎ss data that it has stored in its own origin's localStorage, and not that of any other website or application.\n\nlocalStorage provides five methods that can be used in web‎ applications to manipulate data:\n• getItem(): Retrieves a value associated with a given key from the localStorage.\n• ‎removeItem(): Removes a ke‎y-value pair from the localStorage using a specified key.\n• clear(): Removes all key-value pairs from the localSto‎rage.‎\n• key(): Retrieves the name of the key at a specified index in the localStorage.\n\nUsing these methods you can interact with the localStorage object and save and get data in an organized way. With these methods, web applications can persist data across p‎age loads and even after the user closes the browser.\n\nUsing setItem() to store values in localStorage\n\nThe setI‎tem() method is used to add key-value pairs to the‎ localStorage object. It needs a key and a value, and saves the value with the key. If a key already exists, the value is updated. Here's an example:\n\nIn the first line, we are storing the string \"john_doe\" under the key \"username\" in localStorage. In the second line, we are updat‎ing the value of the \"username\" key to \"jane_doe\".\n\n‎Note that local‎‎Storage can only store strings, so if you want to store a non-string value, you need to convert ‎‎it to a string first using JSON.stringify(). For example:\n\nIn this example, we save a thing called “user” in localStorage by making it a string with JSON.stringify(). To ret‎‎‎rieve the object later, we would use the getItem() method and then parse the JSON string using JSON.parse().\n\nUsing getItem() to retriev‎‎e a value from localStorage\n\nlocalStorag‎‎e is a web API that allo‎‎ws web applications to store key-value pairs in the user's web browser. One of the methods provided by the localStorage API is getItem(), which is used to retrieve the value associa‎‎ted with a given key.\n\nTo use getItem(), you just give the key to the method. For example, if you previously stored a value associated with the key \"username\", you can retrieve it with the following code:\n\ngetItem() gives null when the key is missing in the localStorage. So, check the value before using it:\n\ngetItem() can be useful for persisting data between page loads or for stori‎ng user preferences.\n\nHowever, it's import‎ant to note that localStorage has a size limit of about 5-10 MB depending on the browser, and storing too much data can‎ slow down the application. Therefore, it's recommended to use localStorage for small amounts of data.\n\nUsing removeIte‎‎m() to delete a key-value pair from localStorage\n\n‎removeItem(), which is used to remove a key-value pair from localStorage using a specified key. To use removeItem(), you simply pa‎‎ss the key as an argument to the method. For example, if you want to remove the v‎‎alue associated with the key \"username\" from localStorage, you can use the following code:\n\nIf the speci‎‎‎fied key is not found in localStorage, removeItem() will do nothing and the stora‎ge will remain unchanged. Therefore, it's a good p‎ractice to check if the key ‎exists before attempting to remove it:‎\n\nremoveItem() can be useful for deleting sensitive data or cleaning up localStorage when it's no longer needed. It's important to note removeItem() deletes one key-value pair only. To delete all the data from localStorage, use clear(). More on clear() in the next sub-section.\n\nUsing clear() to remove all key-value pairs from localStorage\n\nTo avoid any potential problems, it's crucial to remember the storage limit when using localStorage and to remove local storage when needed. This is handled via the localStorage API's clear() method.\n\nHere, clear() ensures that the storage limit is never exceeded by deleting every key-value combination from localStorage.Consider a web application where the user can select the background colour and have it saved in localStorage using the key backgroundColor.\n\nYou can use the clear() function to remove all of the data in localStorage, including the backgroundColor key-value combination, if the user wishes to start again with their preferences.\n\nAnother scenario where you may want to clear local storage is when you're developing a web application and need to test how it behaves with an empty storage. Here, you can use clear() to delete all the data in localStorage and start fresh.\n\nIt is important to note that c‎‎learing local storage with clear() will delete all the data stored in localStorage permanently and cannot be undone. Therefore, it's recommended to use clear() with caution and provide a confirmation dialogue to the user before clearing the storage.\n\nAdditionally, it's recommended‎‎ to test the behaviour of your application after clearing local storage to ensure that it handles the situation correctly.\n\nUsing the key() method to ret‎rieve a specific key name\n\nThe key() method is a useful feature of th‎e localStorage object that allows you to retrieve the name of a key located at a specific index in localStorage‎. The syntax for using key() is simple and involves passing a‎n index as an argument to the method. For example, this code gets the name of the second key in localStorage:\n\nIn this example, key(1) retrieves the nam‎e of the second key in localStorage and assigns it to the secondKey variable. The console.log() statement then outputs ‎the name of this key ‎to the console.\n\nUsing the key() method can be especially helpful when you need to access a specific key in localStorage and you don‎'t know its name. By itera‎ting through the keys in localStorage and using key() to retrieve their names, you can easily find the key you need.\n\nLocalStorage is supported by almost all popular browsers, including Chrome, Firefox, Safari, Opera, and Edge. It is crucial to remember that the amount of storage that is accessible and the functionality of localStorage may differ slightly across different browsers.\n\nFor instance, different browsers have different capacities for localStorage data storage. To make sure your web apps function properly on all platforms, it's a good idea to test them in a variety of browsers.Additionally, fallback choices should be available for users of older browsers, as some may not support localStorage.\n\nHere's an illustration of how to use this JavaScript code snippet to see if localStorage is supported:\n\nThis code checks if the browser supports web st‎orage by checking if the Storage object is defined. If it is, it means the browser supports web storage, and we can use localSt‎orage to store and retrieve d‎ata.\n\nIn th‎is example, we set a key-value p‎air using localStorage.setItem(), and retrieve it using localStorage.getItem(). If web storage‎ is not supported, the code insid‎e the else block will execute and output a message to the console.\n\nBest Practices for usi‎‎ng localStorage in Javascript‎\n• Use localStorage fo‎r non-expiring data: Store user preferences o‎‎r settings that won't expire even if the browser is closed.\n• Avoid storing sensitive information in local storage: Don't store sensitive data such as passwords or cr‎edit card numbers as it can be accessed by anyone with acce‎ss to the computer.\n• Minimize frequent access to local storage: Accessing local storage can cause performance issues, so minimize the number of times you n‎eed to access it.\n• Use try/catch when accessing local storage: Handle errors gracefully by catching them and displaying appropriate messages to the user.\n• Test code on d‎‎ifferent browsers and devices: Test yo‎‎ur code on multiple platforms to avoid compatibility or performance issues.\n• Convert objects to strings before storing them: Use JSON.stringify() to convert objects into strings before storing them in local storage.‎\n• Convert stored strings bac‎‎k into JavaScript objects: Use JSON.parse() to convert stored strings back into JavaScript objects or arrays‎‎.\n• Consider using a library like Store.js or Lawnchair: These libraries provide a simple API for working wi‎th local storage, with features like automatic serialization/deserialization of objects, support for multiple types of storage, and expiration‎ times on stored items.\n\nLimitations of workin‎g with localStorage in Javascript\n• It is not a replacement for a server-based database, as information is only stored in the browser‎‎\n• localStorage has a storage limit of 5MB across all major browsers\n• localStorage has ‎‎no data protection and can be accessed by any code on your web page, making it insecure\n• localStorage is synchronous, meaning each operation ca‎lled will execute one after the other\n\nBy keeping these li‎mitations in mind, we can effectively and safely use localStorage in our web applications.\n\nIn this blog, we have learned how to use localStorage in JavaScript to store data on the user’s browser. We now know that localStorage is a useful feature which can be used for various purposes, such as saving user preferences, caching data, or implementing offline functionality.\n\nThere are also other types of storage in JavaScript that you can use for different scenarios. sessionStorage is similar to localStorage, but it only stores data for one session. Cookies are small pieces of data that are sent from the server to the browser and stored on the user’s device. We would highly recommend you to learn more about types of storages in JavaScript, such as localStorage, sessionStorage and cookies for better usability. Till then."
    },
    {
        "link": "https://tiny.cloud/blog/javascript-localstorage",
        "document": "Your app needs a cloud service provider and a database. It's unavoidable. But sometimes, you need to let your customers save content without involving the database or cloud service provider. In this case, you can use JavaScript to access localStorage iny our browser. But you probably have questions: what is localStorage, when can you use it, and is it secure?\n\nIf you've already learned about localStorage, and you know what you're getting yourself into, check through the table of contents, or start with the JavaScript local storage demo. The demo makes use of the TinyMCE rich text editor as an example of a useful content builder.\n\nOtherwise, read on to find out more about JavaScript and localStorage, what it is, and how it works.\n\nWhat is localStorage in JavaScript\n\n Advantages and limitations of localStorage\n\n localStorage vs sessionStorage vs Cookie\n\n SessionStorage vs localStorage\n\n localStorage vs Cookie\n\n IndexedDB vs localStorage\n\nHow to use localStorage methods in JavaScript\n\nHow to clear localStorage\n\nlocalStorage JavaScript example\n\nlocalStorage next steps\n\nWhat is localStorage in JavaScript\n\nlocalStorage in JavaScript allows web applications to store data locally within the user's browser – with no expiration date. The data isn’t deleted when the browser is closed, and is available when the browser is opened again.\n\nData stored remains saved depending on if the browser is using a best-effort method, or a persistent method. When best-effort is in effect, the data persists as long as the stored data does note exceed the limits, and customers don't manually delete the localStorage saved data. When persistent is used, data is only deleted, or evicted, by the customer's choice.\n\nAll browsers support localStorage through the api.Window.localStorage method, and you can log any browser compatibility issues at the MDN browser compatibility GitHub repository.\n\nlocalStorage also allows your customers to access specific data quickly without the overhead of a database. There are other advantages and disadvantages to understand when working with localStorage.\n\n\n\n✏️NOTE: Other options for data storage are available, like Uploadcare for example.\n• It stores up to 5MiB of data in local storage\n• A maximum of 10MiB of data across bot localStorage and sessionStorage (data in sessionStorage is cleared when the page session ends)\n• Easy to use – no need for a web server or backend database\n• Great for getting an idea up and running and for testing purposes\n• It can only store strings, specifically UTF-16 string format, with two bytes per character. This can restrict you from using it for more complex scenarios although, HTML can be stored as a string\n• It’s local to the browser and specific to the origin (per domain and protocol), and there’s no guarantee that the data will persist even in that same context\n• It’s not secure. Don’t store any private or personal information in localStorage\n\nThe main difference between localStorage, sessionStorage, and cookie storage is size.\n\nOf these three types of storage, localStorage is the newest kind of in-browser storage.\n\nUnlike sessionStorage, data stored in localStorage persists, and is accessible even after the browser closes. On Stack Overflow, cssyphus put together a useful explanation that contrasts the different storage types along with a list of resources.\n\nSessionStorage is useful when you need browser storage that does not impact web application performance. Login credentials are held in sessionStorage as they are cleared once the open tab closes.\n\nCookies are the oldest kind of in-browser storage. With their small capacity, they can hold small amounts of data, and are not designed to hold sensitive data such as login credentials.\n\nTogether, these two kinds of storage are the main data storage objects available that the browser can access easily for storing and retrieving information for customers. The main difference between Session and Local kinds of storage is the lifespan of the stored data.\n\nSessionStorage is tied to a specific tab the browser may have open, whereas localStorage is accessible across any tab the browser has open. Once the tab closes, the sessionStorage is deleted, but localStorage persists.\n\nCompared to localStorage, Cookies are older, and can only fit small amounts of data. There are two kinds of Cookies: session, and persistent.\n• Session Cookies, like sessionStorage, expire when the browser closes.\n• A persistent Cookie has an expiry attribute, or a max-age attribute that designates when the browser deletes the data held in cookie storage.\n\nCookies are accessible by servers, as when browsers interact with a server, cookie data is sent along with requests and responses.\n\nA new kind of browser storage, IndexedDB appeared in an attempt to make an improved version of localStorage. Contrasting the two, IndexedDB has a more complex API syntax compared to localStorage. IndexedDB allows for the storage of structured data.\n\nUnlike localStorage, IndexedDB is described as a JavaScript-based object-oriented database. Its design is to provide database-like behavior without the need for an internet connection to a web-server.\n\nHow to use localStorage methods in JavaScript\n\nThere are four basic JavaScript localStorage methods you can use to access and work with localStorage:\n• setItem() - takes a key-value pair and adds it to localStorage\n• getItem() - takes a key and returns the corresponding value\n• removeItem() - takes a key and removes the corresponding key-value pair\n\nTo test out these methods, the following procedure uses the setItem() and getItem() methods. Feel free to try out the other methods in a similar way.\n• Open a browser, and then access the console. For example, in Google Chrome, open Developer Tools and click on the Console tab.\n• Enter the localStorage command, and the current stored data will be returned. For example (assuming it’s empty to begin with):\n• Enter localStorage.setItem('myKey', 'testValue') and the string testValue will be stored against the key myKey:\n• Enter localStorage.getItem('myKey') and the corresponding string will be returned:\n\nYou can run the command clear() to completely clear the localStorage data (for the domain):\n• Check if there is content stored in localStorage:\n• For the purpose of the test, add some content to clear:\n• Clear the localStorage data using the clear() method:\n• Check again to confirm the local storage is clear.\n\nThe following demo shows how you can store information from the TinyMCE text area in localStorage.\n\nCreate a simple index.html file with a single textarea, and two buttons as follows. The textarea id can be anything – in this example it's called myTextArea.\n\nOn the ADD_YOUR_TINYMCE_API_KEY_HERE string: TinyMCE requires a valid API key, otherwise error messages concerning read-only mode can appear in the TinyMCE text area. Your API key is free, and you can access it on the TinyMCE dashboard using Google or GitHub credentials.\n\nThe demo content has two JavaScript functions: saveContent() and loadContent(). The buttons are configured so that when clicked they trigger the relevant JavaScript function. Here’s how it works in more detail:\n• The saveContent() function accesses the current value of the textarea and assigns it to a variable myContent\n• getContent() retrieves the TinyMCE text area contents. You could also use document.getElementById() to access the textarea with id myTextArea\n• The loadContent() function operates in a similar way, only in reverse\n• setContent() then adds the retrieved data to the TinyMCE text area\n\nHere's how the localStorage demo works with TinyMCE:\n\nAnd the following image shows the demo with some custom CSS for the buttons to add more visual interest:\n\nTo test out the demo:\n• Type something in the textarea and click Save. (For example, the demo contains a snippet of prose from Frankenstein) The content then saves to localStorage.\n• Refresh the page, and the content will disappear.\n• Click the Load button, and the content is retrieved from localStorage, and appears in the text area.\n\nWhy not try taking this example one step further? Check out the article with more information on adding a rich text editor that works with JavaScript localStorage:\n\nIf you’d like to know more about Tiny, follow us on Twitter or send us a message if you have any questions on how your app could work with localStorage and TinyMCE."
    },
    {
        "link": "https://blog.logrocket.com/storing-retrieving-javascript-objects-localstorage",
        "document": "Editor’s note: This article was last updated by Rahul Chhodde on 7 August 2024 to offer a deeper exploration of storing objects in , such as techniques to serialize JavaScript objects using , and situations where working with and storing multiple objects in is necessary.\n\nThe Web Storage API provides JavaScript-based mechanisms to securely store and access data as key-value pairs in the client’s browser. This is useful for storing non-sensitive data such as user preferences, application states, and even API responses in some cases.\n\nThe two mechanisms of the Web Storage API, and , allow developers to store data persistently and temporarily. This stored data can be easily retrieved later and utilized to facilitate the user.\n\nIn this article, we’ll learn how to stringify and parse JavaScript objects into JSON strings to save them in , and then reverse the process to retrieve the data. We’ll also briefly cover the key differences between , , and HTTP cookies, highlighting the benefits and drawbacks of using over the other two.\n\nThe object is one of the two mechanisms of Web Storage that allow developers to store data on the client’s browser that persists even after the browser window is closed. This stored data can be accessed throughout a particular domain using easy-to-use API methods, some of which are shown below:\n\nNote that the data stored in the object from a domain can only be accessed or modified by pages of the same origin, which — in this case — stands for protocol, domain, and port collectively. You can verify this behavior using these methods in your browser’s developer console.\n\nAccording to W3Schools, the object stores the data with no expiration date. The data will not be deleted even when the user leaves the page or closes the browser window; it will be available for future sessions. This ability to hold the data is known as data persistence in software and web development.\n\nThe second Web Storage mechanism, , is nearly identical to but differs in two ways: it temporarily stores data for the specified (or current) tab and does so for only a limited period.\n\nThe object stays active as long as the corresponding tab is open and persists data through page reloads and restorations. When a webpage is loaded into a browser tab, , if used, creates a new page session and assigns it to that tab. That page session is only valid for that particular origin accessed in that specific tab.\n\nNote: Data stored in each kind of Web Storage is distinct for each protocol of a given page. This means that data stored on a site accessed via HTTP is stored on a different object than data stored on the same site accessed via HTTPS.\n\nand work similarly, but the main difference is that data stored in is persistent, shared between tabs of the same origin, and lasts forever for that specific origin unless the browser’s storage is cleared or we clear using JavaScript or manually.\n\nUsing Chrome DevTools, you can view the data in both and objects and observe the distinctions we just covered. Here’s a screenshot depicting locating both objects in the tab of DevTools:\n\nTo store and reuse information like user preferences, application states, API response, and larger chunks of data to facilitate perceived performance, we choose over , because this info should persist to be used occasionally to personalize and update the user experience.\n\nNote: When the last private tab is closed, data stored in the object of a site opened in a private tab or incognito mode is cleared, which makes sense because it’s a private browsing session.\n\nHTTP cookies are a conventional mechanism for storing small bits of data exchanged between the client and the server during each HTTP request.\n\nOnce connected to a client, the server generates certain bits of information, saves them in a cookie file, and sends them to the client’s browser. This information is labeled with a unique ID for each user and their computer, which helps the server identify the user whenever a connection is established.\n\nCookies carry information such as auth and session data, CSRF tokens, tracking data, and tiny, site-specific user preferences to help personalize a user’s experience. However, they can be a privacy nightmare. We’ll discuss this in the following segment.\n\nWhy and when to use cookies?\n\nCookies are not the recommended solution for storing larger volumes of data on the client side. They are better suited for session management and are one of the most widely supported solutions for doing so.\n\nWith each request, cookies are sent to the server in the HTTP headers from the browser, as opposed to using or , which are only accessed by the application as client-side data storage and open to vulnerabilities.\n\nFor session security, cookies marked as and can minimize the chances of session hijacking, limiting XSS (cross-site scripting) and CSRF (cross-side request forgery) attacks on the user’s browser during the session.\n\nWhen not to use cookies\n\nHTTP cookies have been a long-standing standard, and keeping your apps 100% cookie-free isn’t always possible. However, there are a few cases where you might want to avoid them:\n• Cookies are supposed to be transmitted with every request made to the server, which is why they are kept tiny and can’t hold data more than 4KB. This makes them unfit for caching big values like huge user preference data, application states, user-authored documents, etc.\n• Third-party cookies raise a serious privacy concern, as the site you’ve visited doesn’t create or own them. Such cookies are usually linked to tracking user data, which puts them under suspicion, and many browsers are preparing to restrict them to safeguard user privacy\n\nThese points leave us to store our heaps of non-sensitive data in . Such situations often demand saving complex data like JavaScript objects locally, which requires a slightly different approach.\n\nHow to store a JavaScript object in\n\nModern web apps often demand saving JavaScript objects locally to provide offline access, restore application state, or cache an API response for perceived performance benefits.\n\nNote that such data shouldn’t carry sensitive information, as once stored in Web Storage, it becomes accessible to any JavaScript code running on the same origin.\n\nLet’s start by gaining a basic understanding of how to work with by exploring its methods and properties for various use cases:\n• : Adds data to a Web Storage object using its two arguments, a key, and a value:\n• : Returns the value of the key name that’s passed to it:\n• : Removes a key that’s passed to it with its corresponding value:\n• : Clears all the key-value pairs in the associated storage and should be used with caution:\n• : Returns the key at the specified index in the storage:\n• : Returns the total number of key-value pairs stored in the associated storage:\n\nYou can learn more about these methods on MDN’s Web Storage API docs.\n\nThe example below demonstrates data persistence accomplished using some of these Web Storage API methods. Click the Current count button, rerun the CodePen, and see the count data persisting using :\n\nSee the Pen \n\n localStorage in action by Rahul (@_rahul)\n\n on CodePen.\n\nIn the demo above, whenever you click the count or the clear button, multiple items are created, read, or modified and the changes to the corresponding values are reflected in the frontend.\n\nStoring JavaScript object data in Web Storage is a bit tricky, as it allows you to store only string values. If we try to store a JavaScript object without first converting it to a string, we will get an response, as shown in the image below:\n\nis a string representation of an object instance whose value was never read at the time of storing the data, which will result in data loss.\n\nThe correct way to store object data to is to first convert it to a string. Then, we can move on to the storage procedure.\n\nThis object-to-string conversion of object data is known as serialization, and turning this converted string back to object data is called deserialization. Let’s briefly discuss two important JSON methods that are responsible for object data serialization and deserialization:\n• : Converts any object value into a string JSON (serialization)\n• : Turns a JSON string into its corresponding object or value (deserialization)\n\nNow, utilizing the method with JSON , we can easily convert a JavaScript object to a JSON string and push it to the object. Here’s a quick example to demonstrate this:\n\nNow, if we try to retrieve the object data without deserializing it, we will receive a JSON string instead of an object, which makes sense, as it is what we stored to .\n\nWe need to deserialize this JSON string data using the JSON parse method to turn it back into a JavaScript object:\n\nHere, we retrieved our previously set JavaScript object using the method on the object and saved it into a variable. Next, we parsed that string into a JavaScript object and finally logged it to the console:\n\nMore examples of storing objects in\n• Storing Date objects: Constructing an object using the current timestamp using the Date object and a random value, and saving it to or clearing it from the using button inputs\n• Persisting remote data: Fetching remote data from a dummy API and storing it in ; the network fetch in this example is only triggered when no associated data in is found\n\nLet’s say we have a bunch of similar objects, and we want to group all of them and store them as one JSON string in the . We can turn them into an object array and then serialize them as shown below:\n\nIf you have bigger chunks of data to work with, you might want to store each of them with separate keys, but accessing all of them quickly can be done using this namespace approach:\n\nis one of the mechanisms of the Web Storage API. The API provides 5-10MB of storage per origin, and the exact storage may vary depending on the browser. Respecting this size limit, you should avoid storing more than 3-4MB of data per origin in Web Storage objects.\n\nKeep in mind that Web Storage API operations are synchronous and block the main thread, therefore performing heavy operations using it may block other resources from loading in the browser.\n\nTypes of data that can be stored as a JSON string\n\nPrimitive data types like numbers, Booleans, and strings are JSON-safe, while values like functions, undefined, symbols, and Date objects are not JSON-safe. If no JSON-safe values are found during conversion, they are either excluded from an object or changed to in an array.\n\nNote: Some of these such values can be made JSON-safe, for example, we used the method with the Date object in this example to make it JSON-safe before pushing it to Web Storage.\n\nIn this article, we learned a useful technique for storing multiple bits of information in a single key and using the JSON stringify and parse methods. We also covered some working demonstrations that apply this approach to different tasks, as well as storing and retrieving multiple JavaScript objects from .\n\nIn summary, we should be mindful of the data we store locally, and take advantage of the object to store JavaScript objects by first converting them to JSON strings with the method and then turning them back to objects with the method."
    }
]