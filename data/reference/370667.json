[
    {
        "link": "https://nextjs.org/docs/app/getting-started/installation",
        "document": "How to set up a new Next.js project\n\nWe recommend starting a new Next.js app using , which sets up everything automatically for you. To create a project, run:\n\nOn installation, you'll see the following prompts:\n\nWhat is your project named? my-app Would you like to use TypeScript? No / Yes Would you like to use ESLint? No / Yes Would you like to use Tailwind CSS? No / Yes Would you like your code inside a `src/` directory? No / Yes Would you like to use App Router? (recommended) No / Yes Would you like to use Turbopack for `next dev`? No / Yes Would you like to customize the import alias (`@/*` by default)? No / Yes What import alias would you like configured? @/*\n\nAfter the prompts, will create a folder with your project name and install the required dependencies.\n\nTo manually create a new Next.js app, install the required packages:\n\nOpen your file and add the following :\n\nThese scripts refer to the different stages of developing an application:\n• : runs to build the application for production usage.\n\nNext.js uses file-system routing, which means the routes in your application are determined by how you structure your files.\n\nCreate an folder, then add a and file. These will be rendered when the user visits the root of your application ( ).\n\nCreate a root layout inside with the required and tags:\n\nYou can optionally create a folder at the root of your project to store static assets such as images, fonts, etc. Files inside can then be referenced by your code starting from the base URL ( ).\n• Edit the file and save it to see the updated result in your browser.\n\nNext.js comes with built-in TypeScript support. To add TypeScript to your project, rename a file to / . Run , Next.js will automatically install the necessary dependencies and add a file with the recommended config options.\n\nNext.js includes a custom TypeScript plugin and type checker, which VSCode and other code editors can use for advanced type-checking and auto-completion.\n\nYou can enable the plugin in VS Code by:\n\nNow, when editing files, the custom plugin will be enabled. When running , the custom type checker will be used.\n\nSee the TypeScript configuration page for more information on how to use TypeScript in your project.\n\nNext.js comes with built-in ESLint, automatically installing the necessary packages and configuring the proper settings when you create a new project with .\n\nTo add ESLint to an existing project, add as a script to :\n\nThen, run and you will be guided through the installation and configuration process.\n\nYou'll see a prompt like this:\n• Strict: Includes Next.js' base ESLint configuration along with a stricter Core Web Vitals rule-set. This is the recommended configuration for developers setting up ESLint for the first time.\n• Cancel: Does not include any ESLint configuration. Only select this option if you plan on setting up your own custom ESLint configuration.\n\nIf either of the two configuration options are selected, Next.js will automatically install and as dependencies in your application and create an file in the root of your project that includes your selected configuration.\n\nYou can now run every time you want to run ESLint to catch errors. Once ESLint has been set up, it will also automatically run during every build ( ). Errors will fail the build, while warnings will not.\n\nSee the ESLint Plugin page for more information on how to configure ESLint in your project.\n\nNext.js has in-built support for the and options of and files. These options allow you to alias project directories to absolute paths, making it easier to import modules. For example:\n\nTo configure absolute imports, add the configuration option to your or file. For example:\n\nIn addition to configuring the path, you can use the option to module paths.\n\nFor example, the following configuration maps to :\n\nEach of the are relative to the location. For example:"
    },
    {
        "link": "https://nextjs.org/docs",
        "document": "Welcome to the Next.js documentation!\n\nNext.js is a React framework for building full-stack web applications. You use React Components to build user interfaces, and Next.js for additional features and optimizations.\n\nUnder the hood, Next.js also abstracts and automatically configures tooling needed for React, like bundling, compiling, and more. This allows you to focus on building your application instead of spending time with configuration.\n\nWhether you're an individual developer or part of a larger team, Next.js can help you build interactive, dynamic, and fast React applications.\n\nSome of the main Next.js features include:\n\nHow to Use These Docs\n\nOn the left side of the screen, you'll find the docs navbar. The pages of the docs are organized sequentially, from basic to advanced, so you can follow them step-by-step when building your application. However, you can read them in any order or skip to the pages that apply to your use case.\n\nOn the right side of the screen, you'll see a table of contents that makes it easier to navigate between sections of a page. If you need to quickly find a page, you can use the search bar at the top, or the search shortcut ( or ).\n\nTo get started, check out the Installation guide.\n\nNext.js has two different routers: the App Router and the Pages Router. The App Router is a newer router that allows you to use React's latest features, such as Server Components and Streaming. The Pages Router is the original Next.js router, which allowed you to build server-rendered React applications and continues to be supported for older Next.js applications.\n\nAt the top of the sidebar, you'll notice a dropdown menu that allows you to switch between the App Router and the Pages Router features. Since there are features that are unique to each directory, it's important to keep track of which tab is selected.\n\nThe breadcrumbs at the top of the page will also indicate whether you're viewing App Router docs or Pages Router docs.\n\nAlthough our docs are designed to be beginner-friendly, we need to establish a baseline so that the docs can stay focused on Next.js functionality. We'll make sure to provide links to relevant documentation whenever we introduce a new concept.\n\nTo get the most out of our docs, it's recommended that you have a basic understanding of HTML, CSS, and React. If you need to brush up on your React skills, check out our React Foundations Course, which will introduce you to the fundamentals. Then, learn more about Next.js by building a dashboard application.\n\nFor optimal accessibility when using a screen reader while reading the docs, we recommend using Firefox and NVDA, or Safari and VoiceOver.\n\nIf you have questions about anything related to Next.js, you're always welcome to ask our community on GitHub Discussions , Discord , X (Twitter) , and Reddit ."
    },
    {
        "link": "https://nextjs.org/docs/app/api-reference/cli/create-next-app",
        "document": "The CLI allow you to create a new Next.js application using the default template or an example from a public GitHub repository. It is the easiest way to get started with Next.js.\n\nThe following options are available:\n\nTo create a new app using the default template, run the following command in your terminal:\n\nYou will then be asked the following prompts:\n\nWhat is your project named? my-app Would you like to use TypeScript? No / Yes Would you like to use ESLint? No / Yes Would you like to use Tailwind CSS? No / Yes Would you like your code inside a `src/` directory? No / Yes Would you like to use App Router? (recommended) No / Yes Would you like to use Turbopack for `next dev`? No / Yes Would you like to customize the import alias (`@/*` by default)? No / Yes\n\nOnce you've answered the prompts, a new project will be created with your chosen configuration.\n\nWith an official Next.js example\n\nTo create a new app using an official Next.js example, use the flag. For example:\n\nYou can view a list of all available examples along with setup instructions in the Next.js repository .\n\nWith any public GitHub example\n\nTo create a new app using any public GitHub example, use the option with the GitHub repo's URL. For example:"
    },
    {
        "link": "https://nextjs.org/docs/pages/api-reference/cli/create-next-app",
        "document": "The CLI allow you to create a new Next.js application using the default template or an example from a public GitHub repository. It is the easiest way to get started with Next.js.\n\nThe following options are available:\n\nTo create a new app using the default template, run the following command in your terminal:\n\nYou will then be asked the following prompts:\n\nWhat is your project named? my-app Would you like to use TypeScript? No / Yes Would you like to use ESLint? No / Yes Would you like to use Tailwind CSS? No / Yes Would you like your code inside a `src/` directory? No / Yes Would you like to use App Router? (recommended) No / Yes Would you like to use Turbopack for `next dev`? No / Yes Would you like to customize the import alias (`@/*` by default)? No / Yes\n\nOnce you've answered the prompts, a new project will be created with your chosen configuration.\n\nWith an official Next.js example\n\nTo create a new app using an official Next.js example, use the flag. For example:\n\nYou can view a list of all available examples along with setup instructions in the Next.js repository .\n\nWith any public GitHub example\n\nTo create a new app using any public GitHub example, use the option with the GitHub repo's URL. For example:"
    },
    {
        "link": "https://nextjs.org/docs/pages/getting-started/installation",
        "document": "We recommend starting a new Next.js app using , which sets up everything automatically for you. To create a project, run:\n\nOn installation, you'll see the following prompts:\n\nWhat is your project named? my-app Would you like to use TypeScript? No / Yes Would you like to use ESLint? No / Yes Would you like to use Tailwind CSS? No / Yes Would you like your code inside a `src/` directory? No / Yes Would you like to use App Router? (recommended) No / Yes Would you like to use Turbopack for `next dev`? No / Yes Would you like to customize the import alias (`@/*` by default)? No / Yes What import alias would you like configured? @/*\n\nAfter the prompts, will create a folder with your project name and install the required dependencies.\n\nTo manually create a new Next.js app, install the required packages:\n\nOpen your file and add the following :\n\nThese scripts refer to the different stages of developing an application:\n• : runs to build the application for production usage.\n\nNext.js uses file-system routing, which means the routes in your application are determined by how you structure your files.\n\nCreate a directory at the root of your project. Then, add an file inside your folder. This will be your home page ( ):\n\nNext, add an file inside to define the global layout. Learn more about the custom App file.\n\nFinally, add a file inside to control the initial response from the server. Learn more about the custom Document file.\n\nYou can optionally create a folder at the root of your project to store static assets such as images, fonts, etc. Files inside can then be referenced by your code starting from the base URL ( ).\n• Edit the file and save it to see the updated result in your browser.\n\nNext.js comes with built-in TypeScript support. To add TypeScript to your project, rename a file to / . Run , Next.js will automatically install the necessary dependencies and add a file with the recommended config options.\n\nSee the TypeScript configuration page for more information on how to use TypeScript in your project.\n\nNext.js comes with built-in ESLint, automatically installing the necessary packages and configuring the proper settings when you create a new project with .\n\nTo add ESLint to an existing project, add as a script to :\n\nThen, run and you will be guided through the installation and configuration process.\n\nYou'll see a prompt like this:\n• Strict: Includes Next.js' base ESLint configuration along with a stricter Core Web Vitals rule-set. This is the recommended configuration for developers setting up ESLint for the first time.\n• Cancel: Does not include any ESLint configuration. Only select this option if you plan on setting up your own custom ESLint configuration.\n\nIf either of the two configuration options are selected, Next.js will automatically install and as dependencies in your application and create an file in the root of your project that includes your selected configuration.\n\nYou can now run every time you want to run ESLint to catch errors. Once ESLint has been set up, it will also automatically run during every build ( ). Errors will fail the build, while warnings will not.\n\nSee the ESLint Plugin page for more information on how to configure ESLint in your project.\n\nNext.js has in-built support for the and options of and files. These options allow you to alias project directories to absolute paths, making it easier to import modules. For example:\n\nTo configure absolute imports, add the configuration option to your or file. For example:\n\nIn addition to configuring the path, you can use the option to module paths.\n\nFor example, the following configuration maps to :\n\nEach of the are relative to the location. For example:"
    },
    {
        "link": "https://nextjs.org/docs/pages/building-your-application/routing/api-routes",
        "document": "Any file inside the folder is mapped to and will be treated as an API endpoint instead of a . They are server-side only bundles and won't increase your client-side bundle size.\n\nFor example, the following API route returns a JSON response with a status code of :\n• API Routes can't be used with static exports. However, Route Handlers in the App Router can.\n• API Routes will be affected by configuration in .\n\nTo handle different HTTP methods in an API route, you can use in your request handler, like so:\n• - An object containing the cookies sent by the request. Defaults to\n• - An object containing the query string . Defaults to\n• - An object containing the body parsed by , or if no body was sent\n\nEvery API Route can export a object to change the default configuration, which is the following:\n\nis automatically enabled. If you want to consume the body as a or with , you can set this to .\n\nOne use case for disabling the automatic is to allow you to verify the raw body of a webhook request, for example from GitHub .\n\nis the maximum size allowed for the parsed body, in any format supported by bytes , like so:\n\nis an explicit flag that tells the server that this route is being handled by an external resolver like express or connect. Enabling this option disables warnings for unresolved requests.\n\nis automatically enabled, warning when an API Routes' response body is over 4MB.\n\nIf you are not using Next.js in a serverless environment, and understand the performance implications of not using a CDN or dedicated media host, you can set this limit to .\n\ncan also take the number of bytes or any string format supported by , for example , or . This value will be the maximum response size before a warning is displayed. Default is 4MB. (see above)\n\nThe Server Response object , (often abbreviated as ) includes a set of Express.js-like helper methods to improve the developer experience and increase the speed of creating new API endpoints.\n• - A function to set the status code. must be a valid HTTP status code\n• - Sends the HTTP response. can be a , an or a\n• - Redirects to a specified path or URL. must be a valid HTTP status code . If not specified, defaults to \"307\" \"Temporary redirect\".\n• - Revalidate a page on demand using . must be a .\n\nWhen sending a response back to the client, you can set the status code of the response.\n\nThe following example sets the status code of the response to ( ) and returns a property with the value of as a JSON response:\n\nWhen sending a response back to the client you can send a JSON response, this must be a serializable object . In a real world application you might want to let the client know the status of the request depending on the result of the requested endpoint.\n\nThe following example sends a JSON response with the status code ( ) and the result of the async operation. It's contained in a try catch block to handle any errors that may occur, with the appropriate status code and error message caught and sent back to the client:\n\nSending an HTTP response works the same way as when sending a JSON response. The only difference is that the response body can be a , an or a .\n\nThe following example sends a HTTP response with the status code ( ) and the result of the async operation.\n\nRedirects to a specified path or URL\n\nTaking a form as an example, you may want to redirect your client to a specified path or URL once they have submitted the form.\n\nThe following example redirects the client to the path if the form is successfully submitted:\n\nYou can make your API Routes more type-safe by importing the and types from , in addition to those, you can also type your response data:\n\nAPI Routes support dynamic routes, and follow the same file naming rules used for .\n\nNow, a request to will respond with the text: .\n\nAPI Routes can be extended to catch all paths by adding three dots ( ) inside the brackets. For example:\n• matches , but also , and so on.\n\nMatched parameters will be sent as a query parameter ( in the example) to the page, and it will always be an array, so, the path will have the following object:\n\nAnd in the case of , and any other matching path, new parameters will be added to the array, like so:\n\nNow, a request to will respond with the text: .\n\nCatch all routes can be made optional by including the parameter in double brackets ( ).\n\nFor example, will match , , , and so on.\n\nThe main difference between catch all and optional catch all routes is that with optional, the route without the parameter is also matched ( in the example above).\n\nThe objects are as follows:\n• Predefined API routes take precedence over dynamic API routes, and dynamic API routes over catch all API routes. Take a look at the following examples:\n• - Will match , , etc. But not\n• - Will match , , etc. But not ,\n\nIf you would like to use API Routes with the Edge Runtime, we recommend incrementally adopting the App Router and using Route Handlers instead.\n\nThe Route Handlers function signature is isomorphic, meaning you can use the same function for both Edge and Node.js runtimes."
    },
    {
        "link": "https://nextjs.org/docs/app/getting-started/project-structure",
        "document": "This page provides an overview of the folder and file conventions in Next.js, as well as tips for organizing your project.\n\nTop-level folders are used to organize your application's code and static assets.\n\nTop-level files are used to configure your application, manage dependencies, run middleware, integrate monitoring tools, and define environment variables.\n\nThe React components defined in special files of a route segment are rendered in a specific hierarchy:\n\nIn a nested route, the components of a segment will be nested inside the components of its parent segment.\n\nApart from folder and file conventions, Next.js is unopinionated about how you organize and colocate your project files. But it does provide several features to help you organize your project.\n\nIn the directory, nested folders define route structure. Each folder represents a route segment that is mapped to a corresponding segment in a URL path.\n\nHowever, even though route structure is defined through folders, a route is not publicly accessible until a or file is added to a route segment.\n\nAnd, even when a route is made publicly accessible, only the content returned by or is sent to the client.\n\nThis means that project files can be safely colocated inside route segments in the directory without accidentally being routable.\n\nPrivate folders can be created by prefixing a folder with an underscore:\n\nThis indicates the folder is a private implementation detail and should not be considered by the routing system, thereby opting the folder and all its subfolders out of routing.\n\nSince files in the directory can be safely colocated by default, private folders are not required for colocation. However, they can be useful for:\n• Consistently organizing internal files across a project and the Next.js ecosystem.\n\nRoute groups can be created by wrapping a folder in parenthesis:\n\nThis indicates the folder is for organizational purposes and should not be included in the route's URL path.\n\nRoute groups are useful for:\n• Organizing routes into groups e.g. by site section, intent, or team.\n• Enabling nested layouts in the same route segment level:\n• Creating multiple nested layouts in the same segment, including multiple root layouts\n• Adding a layout to a subset of routes in a common segment\n\nNext.js supports storing application code (including ) inside an optional directory. This separates application code from project configuration files which mostly live in the root of a project.\n\nThe following section lists a very high-level overview of common strategies. The simplest takeaway is to choose a strategy that works for you and your team and be consistent across the project.\n\nThis strategy stores all application code in shared folders in the root of your project and keeps the directory purely for routing purposes.\n\nThis strategy stores all application code in shared folders in the root of the directory.\n\nThis strategy stores globally shared application code in the root directory and splits more specific application code into the route segments that use them."
    },
    {
        "link": "https://thatsoftwaredude.com/content/12869/a-simple-nextjs-api-folder-structure",
        "document": "If you're working on a brand new Next.js project from the ground up and it has a server-side component, then you'll have to figure out early on just how you want to organize your files and your project structure.\n\nThis is by far, not my favorite step in the development process. And that's because it is a crucial step and if you do it wrong, you're going to be kicking yourself a year from now because you wish you had done it differently.\n\nWhich is why in this article I will be breaking down the folder setup that I personally when building brand new Next.js apps from the ground up.\n\nThis is why structure matters\n\nYou'll want to organize everything in a way where it's simple to add new pages, components, functions later on without having to overhaul anything major. And you'll want to take security into account as well, meaning that only the appropriate files that need to be public, should be public.\n\nSo the following is a sample folder layout for a Next.js API project that more or less resembles what I would use in a real-world application. I say more or less, because on a production environment I would typically have more security and sanitation related folders and files. But to keep things simple I'll mainly just focus on routes and services in this article, the heart of any server.\n\nFirst and foremost, if you're new to Next.js, the pages/api folder is conventionally where you will add your API methods. The default routing in Next.js is configured out of the box to read this folder and to expose the files located here as public endpoints.\n\nThe name of each file is (conventionally) used as the name of the route. If for example you have a user related endpoint that, say, retrieves the users profile picture, then you might have a file in your pages/api folder that resembles the following:\n\nAnd the subsequent route that you would use to call this endpoint would be:\n\nBecause Next.js follows this naming convention from the start, you don't have to wander too much in order to setup a decent structure. So now let's take a look at what that might look like expanded out a few routes.\n\nLet's break down what's happening here. For one, as mentioned above, everything route related goes down in the api/ folder. I personally like to segment my endpoints by category, such as \"posts\" and \"users\" and whatever else is related to my project.\n\nAnd it's not just personal preference here. Next.js file names are used as the URL route, as mentioned above, and to keep in line with convention it makes sense that you are going to have/need multiple index.js and [id].js files per category.\n\nIf you're unfamiliar, index.js is a default filename that does not need to be specified in the route URL. For example, pages/api/users/index.js can be called with the following URL:\n\nNext.js knows to look for the index.js file without needing to specify it. And that means, you guessed it, that you can only use it once per folder. Hence the benefit of segmenting everything out.\n\nBut do you have to separate everything, or can you simply just dump every file into the main /api directory? Technically, you can do whatever you want with your server and break free of convention, which is a huge benefit that you often get with Node based projects. The following structure for example, would still be considered valid:\n\nAnd that's a commonly seen pattern (that I commonly see) that probably shouldn't be. In a real-world production application you're going to end up with several hundred to several thousand routes and trying to navigate your way through a slew of poorly named files isn't going to help anyone, particularly not your future self.\n\nAnd to circle back to what I said earlier, this is why it's crucial to setup a proper file and naming system when working on new projects from the very beginning. It's very simple to refactor 5 files into proper categories in the beginning, but it's near impossible to do the same for thousands. At least not without causing substantial issues to other parts of your code.\n\nWith routing files out of the way, it is equally as important to organize every other kind of file that you're going to end up needing. That includes random utilities and security-based files.\n\nNote again, that a real-world production application would probably have substantially more folders and they might not necessarily resemble anything like what's above. This is a great starting point, if you have a simple project that you're working on however.\n\nI typically recommend putting any tertiary non-route folders into the main parent route. This ensures that you know where everything is from the very beginning and you aren't struggling to remember which folder is the parent of so and so.\n\nUtility, utils, etc. Essentially, these are scripts that perform some kind of system-wide function that you will use frequently. In fact, if you use it more than once, you should put it in your utilities folder. This include, but is not limited, to the following:\n\nIf you have a function that removes HTML from a given string for example, this would be the place to add it.\n\nI typically just have 1 or 2 files in my utilities folder, mainly utils.js and usually some kind of specialized file that differentiates from regular utilities, just in case that is a use case.\n\nAnd ideally, you should find yourself constantly adding new features and functions to this library and your projects grow in size.\n\nYou of course, don't have to settle for just 2 files. If you're working with multiple 3rd party libraries, and they each require specialized utility functions, then it would make sense to create a separate file for each.\n\nRoutes are one thing, but your actual coding logic has to live somewhere in an organized manner. You'll commonly find a services folder somewhere in any kind of Node application these days.\n\nSimilarly to how your API routes are setup, creating a service file for each of those equivalent categories makes sense. This way you won't be fumbling around trying to locate which service 'files' your user routes require. You'll know by naming convention, that it is probably user.js.\n\nI've also seen other developers use user.service.js as the naming convention for service files. This can help to differentiate and locate files much easier as well, when working with a larger number of files.\n\nI also tend to create service files for any 3rd party implementation that I may be using. For example, if I'm using the Slack API for whatever reason I will have a slack.js file as a service file as well.\n\nIt's best to keep your services folder away from your /api folder, so that you're not exposing any service files or functions through the public routing system.\n\nAnd similarly to services, having middleware (of any kind) segmented into its own region is just going to help you with scalability in the future. You might not have any type of middleware in the beginning of your project, but it's a good practice to at least have the folder created and ready for whenever you decide to add files into.\n\nAnd if multiple people are working on a particular application, it also lets them know where to include new files.\n\nJust as an example, if you have authentication functionality setup as middleware, creating a separate auth.js file to handle that logic will simplify things going forward. In general, categorizing things in terms of how you would talk about them (in true OOP) fashion can be beneficial for projects that will undoubtedly grow in size and scale.\n\nThere isn't any perfect folder structure or system out there today, because every developer and every company will have their own specific needs and requirements. I personally have spent hours setting up new server projects on what I thought was the most ideal file naming convention, only to have that house of cards topple on me within a week.\n\nAnd for that, you definitely need to know as much about the requirements as possible from the very beginning.\n\nBut at the bare minimum, separating out your concerns from the very start will at least reduce the chances of any major overhauls in the future. Hopefully."
    },
    {
        "link": "https://stackoverflow.com/questions/76214501/nextjs-13-folder-structure-best-practice",
        "document": "I think reading this section in Next docs helps you organize the project folders:\n\nI tried with many different structures and I finally chose this one:\n• None Everything (all folders and files) will be in the directory because the directory accepts colocation and it’s different from directory which was only for routing purposes. In this way directory can be assumed the new directory.\n• None All the non-routes folders will be Private Folders by prefixing their name with an underscore (as stated in the link above). This tells the Next router that this folder is not part of the routes. (e.g. , , ...)\n• None To this point we established that every folder with underscore is not route and other folders without it are a part of the routing system (although having a or file in the folder is another condition for being a part of the routing system), but I used another Next 13 feature and it is Route Groups (as stated in the link above). It is wrapping a folder name in parenthesis, so that it shows the folder is for organizational purposes (grouping folders) and should not be included in the route’s URL path, e.g. (routes).\n\nWith these principles, I have all my required folders in directory, and with Route Groups all my routes are grouped in a folder, and with Private Folders by prefixing non-route folders with underscore, everything is isolated.\n\nThe image below is the summary of all the points above.\n\nHope the link and my way of organizing project folders help you."
    },
    {
        "link": "https://reddit.com/r/nextjs/comments/1e4juvk/how_do_you_structure_files_and_directories_in",
        "document": "I've been working with Next.js for a while now, and I'm looking to refine my development practices to align with the latest best practices. With all the updates and new features, I want to make sure I'm following the most efficient and effective techniques.\n\nHow do you structure files and directories for scalability and maintainability?\n\nAre you placing all the files in the app folder or src?\n\nAnd are you using (folder) to organise your files to for example (marketing), (solution), (blog)"
    }
]