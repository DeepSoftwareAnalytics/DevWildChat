[
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics.Raycast.html",
        "document": "Suggest a change Thank you for helping us improve the quality of Unity Documentation. Although we cannot accept all submissions, we do read each suggested change from our users and will make updates where applicable. Close For some reason your suggested change could not be submitted. Please <a>try again</a> in a few minutes. And thank you for taking the time to help us improve the quality of Unity Documentation. Close\n\nTo select which layers a ray should collide with, use a LayerMask.\n\n\n\nSpecifying allows you to control whether or not Trigger colliders generate a hit, or whether to use the global Physics.queriesHitTriggers setting.\n\n\n\nNotes: Raycasts will not detect Colliders for which the Raycast origin is inside the Collider. In all these examples FixedUpdate is used rather than Update. Refer to Order of execution for event functions to understand the difference between Update and FixedUpdate, and to see how they relate to physics queries."
    },
    {
        "link": "https://docs.unity3d.com/550/Documentation/ScriptReference/Physics.Raycast.html",
        "document": "Select your preferred scripting language. All code snippets will be displayed in this language."
    },
    {
        "link": "https://discussions.unity.com/t/this-documentation-example-for-raycasting-is-just-dead-wrong-and-has-not-been-fixed-for-years/907063",
        "document": ""
    },
    {
        "link": "https://docs.unity.cn/540/Documentation/ScriptReference/Physics.Raycast.html",
        "document": "Select your preferred scripting language. All code snippets will be displayed in this language."
    },
    {
        "link": "https://forum.kerbalspaceprogram.com/topic/87776-does-anyone-have-experience-with-why-physicsraycast-sometimes-passes-through-parts",
        "document": "Unity's Physics.RayCast() doesn't seem very reliable when it comes to aiming the ray at ship parts. It works fine for ground terrain or KSC buildings, but when aimed at ship parts it works intermitently. Note, this is NOT (I don't think) a problem with the layers because it hits the SAME part for one or two Update()'s, then in the next update it passes right through it, then in the next Update() it hits it again, then a few updates later it starts passing through it again, and so on. The problem seems more pronounced when the ship is in motion (I have a laser on the ship aiming at another part of the same ship to measure the distance between them as an Infernal Robotics part moves them farther apart, and when the ship takes off the erroneous \"penetrating\" raycasts start happening more frequently than when it was on the ground.) I've tried googling about it and it seems to be that people have trouble with Raycast hitting moving parts and it has something to do with the exact timing of when you call Physics.RayCast(). I find people claiming it's better if you put Physics.RayCast() calls in FixedUpdate() instead of Update(), but that seems like a drastic measure as FixedUpdate is a precious resource I should avoid using, and the rest of my logic about what to do with the raycast is too \"expensive\" for FixedUpdate() and needs to stay in Update() so it's going to make the programming more complex if I putthe raycasts in FixedUpdate(). Does anyone have good experience with Physics.Raycast() hitting ship parts and know whether or not this claim is really true (that you need to put the raycasts in FixedUpdate() for them to work right?) That's a major undertaking to make that change for my mod and it would be horrible if I went through the work only to find its a red herring. Unity's own docs for RayCast never mention this, but given the state of Unity's documentation, the fact that it never mentions it is hardly conclusive.\n\nI don't think whatever you will be doing will impact the game that much honestly. Every bullet in skillful has a raycast that checks for missed collisions, and there can be literally hundreds at once. All my raycasts are in FixedUpdate and only things like keypresses are in Update. Does the drawing of the ray, if I'm showing it visually with a red lineRenderer, have to also be in FixedUpdate? I think the problem may be that. When I raycast in FixedUpdate and then draw the result, the drawing is really far off, appearing about 20 meters ahead of the craft as it orbits, making it very hard to debug what I'm looking at. But then again I'm tying to raycast in FixedUpdate and then Draw in Update. I think I can do it but the logic is messy because of the fallback to a slow numeric algorithm when the terrain is too far away for raycasts to work (the game unloads the polygon colliders when the terrain is more than about 10-20 km away or so). What I'm trying to do is basically this: Where MyRayCastWrapper( stuff ) is doing the following: Step 1 - Try Physics.Raycast to hit ground or ship objects near enough to have loaded colliders. Step 2 - If Step 1 returned false, then fall back to my own homebrewed numeric algorithm to find terrain hits with the distant planet surface by querying the pqsController. The ugly part is that although Step 1 and the ray drawing may both be fast enough to put in FixedUpdate, there's that annoying Step 2 which really shouldn't be in FixedUpdate because it's computationally expensive, and yet it happens *between* Step 1 and the drawing of the ray. I could wait and draw the ray later but then it's being drawn in the wrong animation frame and thus in the wrong spot. I think it's doable but messy. I may have to disable the numeric solver, get the solution working for just raycast only, and then work out how to re-enable the numeric solver in the new way the code looks after that. That really looks like it's in the wrong order around. Are you sure I'm supposed to be checking how many alllHits there were and THEN for each one of them be calling Raycast on them? Doesn't the raycast come first and allhits isn't even populated until it's been called?\n\nOkay this is really getting quite infuriating. (Dealing with the API, not you guys. You've been very helpful but the game just isn't cooperating.) See the screenshots below. The laserbeam keeps toggling between giving a hit of 1.78 meters intersecting the structuralBeam3, versus giving a hit of 3.32 meters intersecting the landingLeg1-2 that's beyond it. Every few updates it flips between these two answers. The craft is sitting still on the ground. Not Moving. When the laser does miss the 1.78 hit and pass through to the 3.32 hit, I can see clearly the beam passing right through the middle of the closer object, incorrectly failing to detect the hit. This is the relevant code: \n\n /// <summary>\n\n /// Perform Unity's Physics.RayCast() check when the movement of all the objects is set in stone and they are not moving:\n\n /// Physics.RayCast() is unreliable when called from Update() because objects are moving their positions during their\n\n /// Update()'s and you don't know when during the order of all that your own Update() will be getting called. Therefore\n\n /// Physics.Raycast() has to be called during FixedUpdate.\n\n /// </summary>\n\n public void FixedUpdate()\n\n {\n\n // The location of origin is different in FixedUpdate than it is\n\n // in Update, so it has to be reset in both:\n\n origin = this.part.transform.TransformPoint( relLaserOrigin );\n\n pointing = this.part.transform.rotation * Vector3d.down;\n\n\n\n mostRecentUnityRaycastSuccess = false;\n\n\n\n if( hasPower && Activated && origin != null && pointing != null)\n\n {\n\n RaycastHit[] hits = null;\n\n hits = Physics.RaycastAll( origin, pointing, MaxDistance, mask );\n\n Debug.Log(\"num hits = \" + hits.Length );\n\n if( hits.Length > 0 )\n\n {\n\n mostRecentUnityRaycastSuccess = true;\n\n float bestDist = Mathf.Infinity;\n\n foreach( RaycastHit hit in hits )\n\n {\n\n Debug.Log(\"hit.distance = \" + hit.distance + \", bestDist = \" + bestDist);\n\n if( hit.distance < bestDist )\n\n {\n\n Debug.Log(\"using new hit.\");\n\n bestDist = hit.distance;\n\n mostRecentUnityRaycastResult = hit;\n\n }\n\n }\n\n }\n\n }\n\n }\n\n See the Debug.Log statements? This is what they're showing in the log: \n\nnum hits = 3\n\nhit.distance = 6.966611, bestDist = Infinity\n\nusing new hit.\n\nhit.distance = 3.787935, bestDist = 6.966611\n\nusing new hit.\n\nhit.distance = 3.323033, bestDist = 3.787935\n\nusing new hit.\n\nnum hits = 4\n\nhit.distance = 6.966611, bestDist = Infinity\n\nusing new hit.\n\nhit.distance = 3.787934, bestDist = 6.966611\n\nusing new hit.\n\nhit.distance = 1.778339, bestDist = 3.787934\n\nusing new hit.\n\nhit.distance = 3.323035, bestDist = 1.778339\n\nnum hits = 4\n\nhit.distance = 6.966611, bestDist = Infinity\n\nusing new hit.\n\nhit.distance = 3.787933, bestDist = 6.966611\n\nusing new hit.\n\nhit.distance = 1.778339, bestDist = 3.787933\n\nusing new hit.\n\nhit.distance = 3.323039, bestDist = 1.778339\n\nnum hits = 3\n\nhit.distance = 6.966611, bestDist = Infinity\n\nusing new hit.\n\nhit.distance = 3.787933, bestDist = 6.966611\n\nusing new hit.\n\n It seems entirely outside my ability to control it - it just sometimes fails to include the structureBeam3 among the hits, even though I'm not doing anything different. And it seems to randomly flip between finding it and not finding it based on who knows what. I'm tempted to punt and just tell people \"sometimes it will fail to hit parts and there's nothing I can do about it.\"\n\nOkay this is really getting quite infuriating. (Dealing with the API, not you guys. You've been very helpful but the game just isn't cooperating.) See the screenshots below. The laserbeam keeps toggling between giving a hit of 1.78 meters intersecting the structuralBeam3, versus giving a hit of 3.32 meters intersecting the landingLeg1-2 that's beyond it. Every few updates it flips between these two answers. The craft is sitting still on the ground. Not Moving. When the laser does miss the 1.78 hit and pass through to the 3.32 hit, I can see clearly the beam passing right through the middle of the closer object, incorrectly failing to detect the hit. This is the relevant code: \n\n /// <summary>\n\n /// Perform Unity's Physics.RayCast() check when the movement of all the objects is set in stone and they are not moving:\n\n /// Physics.RayCast() is unreliable when called from Update() because objects are moving their positions during their\n\n /// Update()'s and you don't know when during the order of all that your own Update() will be getting called. Therefore\n\n /// Physics.Raycast() has to be called during FixedUpdate.\n\n /// </summary>\n\n public void FixedUpdate()\n\n {\n\n // The location of origin is different in FixedUpdate than it is\n\n // in Update, so it has to be reset in both:\n\n origin = this.part.transform.TransformPoint( relLaserOrigin );\n\n pointing = this.part.transform.rotation * Vector3d.down;\n\n\n\n mostRecentUnityRaycastSuccess = false;\n\n\n\n if( hasPower && Activated && origin != null && pointing != null)\n\n {\n\n RaycastHit[] hits = null;\n\n hits = Physics.RaycastAll( origin, pointing, MaxDistance, mask );\n\n Debug.Log(\"num hits = \" + hits.Length );\n\n if( hits.Length > 0 )\n\n {\n\n mostRecentUnityRaycastSuccess = true;\n\n float bestDist = Mathf.Infinity;\n\n foreach( RaycastHit hit in hits )\n\n {\n\n Debug.Log(\"hit.distance = \" + hit.distance + \", bestDist = \" + bestDist);\n\n if( hit.distance < bestDist )\n\n {\n\n Debug.Log(\"using new hit.\");\n\n bestDist = hit.distance;\n\n mostRecentUnityRaycastResult = hit;\n\n }\n\n }\n\n }\n\n }\n\n }\n\n See the Debug.Log statements? This is what they're showing in the log: \n\nnum hits = 3\n\nhit.distance = 6.966611, bestDist = Infinity\n\nusing new hit.\n\nhit.distance = 3.787935, bestDist = 6.966611\n\nusing new hit.\n\nhit.distance = 3.323033, bestDist = 3.787935\n\nusing new hit.\n\nnum hits = 4\n\nhit.distance = 6.966611, bestDist = Infinity\n\nusing new hit.\n\nhit.distance = 3.787934, bestDist = 6.966611\n\nusing new hit.\n\nhit.distance = 1.778339, bestDist = 3.787934\n\nusing new hit.\n\nhit.distance = 3.323035, bestDist = 1.778339\n\nnum hits = 4\n\nhit.distance = 6.966611, bestDist = Infinity\n\nusing new hit.\n\nhit.distance = 3.787933, bestDist = 6.966611\n\nusing new hit.\n\nhit.distance = 1.778339, bestDist = 3.787933\n\nusing new hit.\n\nhit.distance = 3.323039, bestDist = 1.778339\n\nnum hits = 3\n\nhit.distance = 6.966611, bestDist = Infinity\n\nusing new hit.\n\nhit.distance = 3.787933, bestDist = 6.966611\n\nusing new hit.\n\nhit.distance = 3.323033, bestDist = 3.787935\n\nusing new hit.\n\n It seems entirely outside my ability to control it - it just sometimes fails to include the structureBeam3 among the hits (returning a list of only 3 hits, not the correct 4 hits), even though I'm not doing anything different in that particular update. And it seems to randomly flip between finding it and not finding it based on who knows what. I'm tempted to punt and just tell people \"sometimes it will fail to hit parts and there's nothing I can do about it.\" Edited by Steven Mading \n\ntail end of my output log was cut off.\n\nDid you test this with other parts? Not all parts are created equal unfortunately. That could have a few collider boxes in the sides, and nothing where you are shooting the ray at. I'm not saying that's what's happening but just to eliminate that possibility try doing the test on 4 totally different parts with different part shapes. About the code yes it's a$$ backwards I knew I'd mess it up but I think you understood it anyways. And yes I'd put all of it in FixedUpdate(), get your fps with and without your code running, I don't think you'll see much of a difference. I will if I include the fallback pqs technique in fixedupdate. If all I do is the raytracing it's fast enough in fixedupdate. If I run a recursive iterator that has to take about 500 loop iterations to get down to an answer within 2m of accurate because the only way to detect terrain hits at long distances is to test sample points along the ray, then it won't. I already know it's not even fast enough for plain ole Update(). I had to split the algorithm up across multiple updates, remembering state between them to get acceptable FPS. Note, that's even BEFORE I moved any of it to fixedupdate. The problem of finding the solution of the intercept of a ray with the pqs terrain is NOT a trivial calculation. It requires itrerative approximation. That's why I have to have half the logic (the stuff using Physics.RayCast) in fixedUPate and the other half (the fallback to pqsCOllider) in Update(). But that's not even related to my problem. Even when dealing with JUST nearby objects using JUST Physics.RayCast in JUST FixedUpdate, Unity is returning inconsistent results where in one FixedUpdate it will hit the part and in the next one it will pass through it to the part behind it *even when nothing moved*. I suspect that what's happening is that because I get FixedUpates more frequently than Updates, that not all the movement and recalculation of all the KSP parts is finished between fixedUpdates. There is no guarantee that Unity gets its way through ALL the parts' Update()s before the next FixedUpdate. So some have moved and others haven't yet. That's my guess. As to changing parts - again it's reliably inconsistent - any part has the effect that it tends to pass right through about 1/3 of the time in FixedUpdate. I've tried falling back on an ugly amount of work to compensate for it - I only need the information up to date once per Update, not once per FixedUpdate - so I'm trying to gather ALL the hits of ALL the fixed Updates that happened between Update()s, and then when the Update() runs, taking the nearest hit among ALL of them. that way as long as it hits the object on at least ONE of the FixedUpdates I don't care that it missed on others. It has to miss on all of them to be a real miss.\n\nSeems like you know you're stuff. So if 1 in 3 is a fail, why not double up the rays and have 1 in 6 fail. What is an acceptable level of loss? I've fired tons of rays and I don't see 1 in 3 misses even when the bullet is going 1200 m/s. Though if you are scanning something in orbit --> stationary the velocities could be much higher, at that point I can't attest as it is logical that it may be incapable of that accuracy. I do a raycast lookback on all my bullet rigidbodies, essentially the raycast looks at the step in motion between frames and sees if there was a missed collision. It seems reliable to me (again at up to 1200 - 1300 m/s - I don't require faster than that). You're not tracking a physical position over time, you're doing an instantaneous ray. So I realize this might be useless, but it could trigger an idea for you... Have you tried using the algorithm to just fire a bullet through just one thin part rather than through a ship made of multiple parts? It might be that as long as you hit one of the parts of the ship it's a success, whereas I need to hit the *correct* part of the ship to be a success. If I hit the fuel tank in the middle even though there was a panel part in front of it that I should have hit first, then that's a \"fail\" by my criteria. For firing a bullet to hit a ship, hitting the tank instead of the panel would still look like a good success for your needs. I don't know. It could also be a very ugly timing issue. It might be that it depends on how many Update()'s happen versus how many FixedUpate()'s happen, and computer speed changes whether or not a full suite of Update()s happen and finish on time before a FixedUpdate(). There is also something here, about calling from Update but waiting for the FixedUpdate. Again might not be relevant other than to perhaps trigger an idea. I read that thread before on my previous googling. Sadly, some of the advice is about what order I should be updating the position of \"my\" objects in, as if I was writing my own Unity game from scratch and had the privilege to do that. This isn't useful in the context of a KSP mod because I'm not in charge of deciding when to update and draw the ship parts, SQUAD is in their proprietary code that I don't know how it was written. And the rest of the advice is quite different because it talks about drawing a raycast from the camera, which I'm not doing. Sadly I'm suspecting that what's actually happening here is that SQUAD's own code is updating parts in such a way that it's not working right when trying to hit thin parts. It might explain also why it is that the main game itself has such a hard time with right-clicking on parts working to bring up the menu. That user interface is ALSO dependant on raycasting and it also seems to fail about half the time when I try to click on parts. I have to keep re-trying until I get lucky enough to get it to work.\n\nSo here's some things to try: [*]Is the behaviour the same with Physics.Raycast() as well as Physics.RaycastAll()? In the past I've had issues with RaycastAll() in my own Unity projects. yes. I was using Physics.RayCast() first and then changed to using Physics.RaycastAll() later to see if it would help. Both had the same problem. [*]Try using Physics.Spherecast() with an appropriate radius, which does what you'd expect it to (raycast with a sphere instead of a point). It's more expensive, but it should get you an idea of what's going on. If you're thinking that there is positional jitter that is causing your error, using a Spherecast will help determine that - if it is hitting but the raycast isn't, there's a small jitter involved. If it's still not hitting This isn't workable in this case because I don't hardcode which part I'm trying to aim at. Its \"return the hit on whichever part you hit that's nearest\". [*]I don't know exactly how the methods you're using to get your laser aim start point and direction are working exactly, but it seems like a far easier way would be to place a transform in your model file (placed and oriented as your laser origin), get it via a standard method, and just use that transform's position and forward parameters to aim the beam. I'm not sure why you're doing otherwise, but as you're raycasting within KSP's physics bubble against things inside the physics bubble, you shouldn't need to do much else. If all else fails, you should try this. [*]Related to point 3, how are you drawing your LineRenderer (I don't see it in your code)? It's done during Update(), using a recalculation of origin and pointing (since the location of things can be different during Update()), but capping the distance of the line at whatever the distance result of the raycasts in FixedUpdate were. So FixedUpdate is picking the distance of the hit, then Update() is drawing using that distance. I don't think that will make much difference but I could move the drawing code to fixedupdate too. The problem isn't the drawing, but the calculation of the distance is missing the hit entirely."
    },
    {
        "link": "https://discussions.unity.com/t/outline-highlight-objects/717320",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/highlighting-interactable-objects/917712",
        "document": ""
    },
    {
        "link": "https://docs.unity3d.com/2020.1/Documentation/Manual/ScenePicking.html",
        "document": "You can select a single GameObjectThe fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info\n\nSee in Glossary in the Scene viewAn interactive view into the world you are creating. You use the Scene View to select and position scenery, characters, cameras, lights, and all other types of Game Object. More info\n\nSee in Glossary or from the Hierarchy window. You can also select more than one GameObject at a time.\n\nUnity highlights selected GameObjects and their children in the Scene view. By default, the selection outline color is orange, and the child outline color is blue. You can also choose to highlight selected GameObjects’ wireframes in a different color. You can change all of these outline highlight colors from the Unity Preferences (Unity > Preferences on macOS or Edit > Preferences on Windows).\n\nFor more information about the outline and wireframe selection visualizations, see the documentation on the Gizmos menu.\n\nTo select a single GameObject, choose one of these methods:\n• Click on it in the Scene view. If you repeatedly click on the shared space between overlapping GameObjects, the selection cycles between them.\n• None Click its name in the Hierarchy window.\n\nTo select or de-select multiple GameObjects choose one of these methods:\n• Drag a rectangle around multiple GameObjects. Unity selects anything that falls inside this bounding box.\n• Hold the Shift key while clicking GameObjects in the SceneA Scene contains the environments and menus of your game. Think of each unique Scene file as a unique level. In each Scene, you place your environments, obstacles, and decorations, essentially designing and building your game in pieces. More info\n\nSee in Glossary. You can also use the Ctrl (Windows) or Command (macOS) key to add or remove GameObjects from the selection. Note: When something in the Editor needs a single selected GameObject to perform an action, it looks for an “Active” object. For example, Unity has to decide which GameObject to use as the pivot for transform tools while in Pivot mode. By default, Unity considers the first GameObject you select to be the “Active” object. And every time you Shift+click on one of several selected GameObjects, you change which one of them is active. When a GameObject is active in the Scene view, Unity doesn’t display any visible cues that it is active. However, you can see which GameObject is active in the Scene view when you repeatedly Shift+click in Pivot mode with multiple objects selected.\n\nHowever, if you are working with a large Scene containing a lot of Scene items (such as GameObjects, Terrain objects, Cameras, and Lights), selecting multiple objects can be very tricky. To help you select only the items you want, you can block some objects from being picked, using the Scene picking controls.\n\nYou can toggle Scene picking controls on and off to mark which items are pickable when you work in the Editor. By default, all items are pickable, but you can choose which Scene items Unity skips adding to the selection when you click on them. For example, if you are working in a large Scene with over 10,000 objects, you can temporarily block specific GameObjects from being selected to prevent accidental editing.\n\nOnce you mark an item as unpickable, Unity continues to render them even though you can no longer select or edit them in the Scene view. The pickability state persists only in the Editor and only for the user in the Project where it was set. Changing the pick state does not “dirty” the Scene (that is, count as a modification).\n\nScene picking controls are very similar to the Scene visibility controls.\n\nYou control Scene pickability for individual GameObjects from the Hierarchy window.\n• Click a GameObject’s pickability icon in the Hierarchy window to toggle between enabling and disabling picking the GameObject and its children. Toggling pickability for a GameObject and its children affects all child GameObjects, from the “target” GameObject all the way down to the bottom of the hierarchy.\n• Alt + Click a GameObject’s pickability icon in the Hierarchy window to toggle between enabling and disabling picking the GameObject only. Toggling pickability for a single GameObject does not affect its children. They retain whatever pickability status they had previously.\n\nBecause you can toggle pickability for a whole branch or a single GameObject, you can end up with GameObjects that are pickable, but have children or parents that you cannot pick. To help you track what’s going on, the pickability icon changes to indicate each GameObject’s status.\n\nAny Scene picking changes you make in the Hierarchy window are persistent. Unity re-applies them whenever you use Select All or Deselect All, close and re-open the Scene, and so on."
    },
    {
        "link": "https://docs.unity3d.com/Manual/GameObjects.html",
        "document": "The GameObjectThe fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info\n\nSee in Glossary is the most important concept in the Unity Editor.\n\nEvery object in your game is a GameObject, from characters and collectible items to lights, camerasA component which creates an image of a particular viewpoint in your scene. The output is either drawn to the screen or captured as a texture. More info\n\nSee in Glossary and special effects. However, a GameObject can’t do anything on its own; you need to give it properties before it can become a character, an environment, or a special effect.\n\nGameObjects are the fundamental objects in Unity that represent characters, props and scenery. They do not accomplish much in themselves but they act as containers for ComponentsA functional part of a GameObject. A GameObject can contain any number of components. Unity has many built-in components, and you can create your own by writing scripts that inherit from MonoBehaviour. More info\n\nSee in Glossary, which implement the functionality.\n\nTo give a GameObject the properties it needs to become a light, or a tree, or a camera, you need to add components to it. Depending on what kind of object you want to create, you add different combinations of components to a GameObject.\n\nUnity has lots of different built-in component types, and you can also make your own components using the Unity Scripting API.\n\nFor example, a Light object is created by attaching a Light component to a GameObject.\n\nA solid cube object has a MeshThe main graphics primitive of Unity. Meshes make up a large part of your 3D worlds. Unity supports triangulated or Quadrangulated polygon meshes. Nurbs, Nurms, Subdiv surfaces must be converted to polygons. More info\n\nSee in Glossary Filter and Mesh RendererA mesh component that takes the geometry from the Mesh Filter and renders it at the position defined by the object’s Transform component. More info\n\nSee in Glossary component, to draw the surface of the cube, and a Box ColliderAn invisible shape that is used to handle physical collisions for an object. A collider doesn’t need to be exactly the same shape as the object’s mesh - a rough approximation is often more efficient and indistinguishable in gameplay. More info\n\nSee in Glossary component to represent the object’s solid volume in terms of physics.\n\nA GameObject always has a Transform component attached (to represent position and orientation) and it is not possible to remove this. The other components that give the object its functionality can be added from the editor’s Component menu or from a script. There are also many useful pre-constructed objects (primitive shapes, Cameras, etc) available on the GameObject > 3D Object menu, see Primitive Objects.\n\nBecause GameObjects are an important part of Unity, there is a lot of manual content with extensive detail about them. See the following sections for more information on using GameObjects in Unity:\n• None Tags \n\n A reference word which you can assign to one or more GameObjects to help you identify GameObjects for scripting purposes. For example, you might define and “Edible” Tag for any item the player can eat in your game. More info\n\nYou can find out more about controlling GameObjects from scriptsA piece of code that allows you to create your own Components, trigger game events, modify Component properties over time and respond to user input in any way you like. More info\n\nSee in Glossary on the GameObject scripting reference page."
    },
    {
        "link": "https://discussions.unity.com/t/outline-effect-using-hdrp/717862",
        "document": ""
    }
]