[
    {
        "link": "https://developer.android.com/reference/android/bluetooth/BluetoothAdapter",
        "document": "Represents the local device Bluetooth adapter. The lets you perform fundamental Bluetooth tasks, such as initiate device discovery, query a list of bonded (paired) devices, instantiate a using a known MAC address, and create a to listen for connection requests from other devices, and start a scan for Bluetooth LE devices.\n\nTo get a representing the local Bluetooth adapter, call the function on . On JELLY_BEAN_MR1 and below you will need to use the static method instead.\n\nFundamentally, this is your starting point for all Bluetooth actions. Once you have the local adapter, you can get a set of objects representing all paired devices with ; start device discovery with ; or create a to listen for incoming RFComm connection requests with ; listen for incoming L2CAP Connection-oriented Channels (CoC) connection requests with ; or start a scan for Bluetooth LE devices with using the scanner from .\n\nFor more information about using Bluetooth, read the Bluetooth developer guide.\n\nAlphabetic characters must be uppercase to be valid. Close the connection of the profile proxy to the Service. This method was deprecated in API level 33. Starting with , applications are not allowed to enable/disable Bluetooth. Compatibility Note: For applications targeting or above, this API will always fail and return . If apps are targeting an older SDK ( or below), they can continue to use this API. This method was deprecated in API level 33. Starting with , applications are not allowed to enable/disable Bluetooth. Compatibility Note: For applications targeting or above, this API will always fail and return . If apps are targeting an older SDK ( or below), they can continue to use this API. Returns the hardware address of the local Bluetooth adapter. Return the set of objects that are bonded (paired) to the local adapter. This method was deprecated in API level 31. this method will continue to work, but developers are strongly encouraged to migrate to using , since that approach enables support for . Get the timeout duration of the . Return the maximum LE advertising data length in bytes, if LE Extended Advertising feature is supported, 0 otherwise. Get the maximum number of connected devices per audio profile for this device. Get the friendly Bluetooth name of the local Bluetooth adapter. Get the current connection state of a profile. Get the profile proxy object associated with the profile. Get a object for the given Bluetooth hardware address. Get a object for the given Bluetooth hardware address. Get a object for the given Bluetooth hardware address and addressType. Get the current Bluetooth scan mode of the local Bluetooth adapter. Get the current state of the local Bluetooth adapter. Return true if the local Bluetooth adapter is currently in the device discovery process. Return true if Bluetooth is currently enabled and ready for use. Returns if the LE audio broadcast assistant feature is supported, if the feature is not supported, or an error code. Returns if the LE audio broadcast source feature is supported, if the feature is not supported, or an error code. Returns if the LE audio feature is supported, if the feature is not supported, or an error code. Return true if the multi advertisement is supported by the chipset \n\n For apps targeting or lower, this requires the permission which can be gained with a simple manifest tag. Return true if offloaded filters are supported \n\n For apps targeting or lower, this requires the permission which can be gained with a simple manifest tag. Return true if offloaded scan batching is supported \n\n For apps targeting or lower, this requires the permission which can be gained with a simple manifest tag. Create an insecure L2CAP Connection-oriented Channel (CoC) and assign a dynamic PSM value. Creates a listening server channel for Bluetooth connections with the specified socket settings . Set the friendly Bluetooth name of the local Bluetooth adapter. This method was deprecated in API level 21. use instead. This method was deprecated in API level 21. use instead. This method was deprecated in API level 21. Use instead.\n\nThe discovery process usually involves an inquiry scan of about 12 seconds, followed by a page scan of each new device to retrieve its Bluetooth name. This is an asynchronous call, it will return immediately. Register for and intents to determine exactly when the discovery starts and completes. Register for to be notified as remote Bluetooth devices are found. Device discovery is a heavyweight procedure. New connections to remote Bluetooth devices should not be attempted while discovery is in progress, and existing connections will experience limited bandwidth and high latency. Use to cancel an ongoing discovery. Discovery is not managed by the Activity, but is run as a system service, so an application should always call even if it did not directly request a discovery, just to be sure. Device discovery will only find remote devices that are currently discoverable (inquiry scan enabled). Many Bluetooth devices are not discoverable by default, and need to be entered into a special mode. If Bluetooth state is not , this API will return false. After turning on Bluetooth, wait for with to get the updated value. If a device is currently bonding, this request will be queued and executed once that device has finished bonding. If a request is already queued, this request will be ignored. \n\n For apps targeting or lower, this requires the permission which can be gained with a simple manifest tag. \n\n For apps targeting or or higher, this requires the permission which can be gained with . \n\n In addition, this requires either the permission or a strong assertion that you will never derive the physical location of the device. You can make this assertion by declaring on the relevant manifest tag, but it may restrict the types of Bluetooth devices you can interact with. \n\n Requires\n\nCalled by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the method to dispose of system resources or to perform other cleanup. The general contract of is that it is invoked if and when the Java virtual machine has determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, except as a result of an action taken by the finalization of some other object or class which is ready to be finalized. The method may take any action, including making this object available again to other threads; the usual purpose of , however, is to perform cleanup actions before the object is irrevocably discarded. For example, the finalize method for an object that represents an input/output connection might perform explicit I/O transactions to break the connection before the object is permanently discarded. The method of class performs no special action; it simply returns normally. Subclasses of may override this definition. The Java programming language does not guarantee which thread will invoke the method for any given object. It is guaranteed, however, that the thread that invokes finalize will not be holding any user-visible synchronization locks when finalize is invoked. If an uncaught exception is thrown by the finalize method, the exception is ignored and finalization of that object terminates. After the method has been invoked for an object, no further action is taken until the Java virtual machine has again determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, including possible actions by other objects or classes which are ready to be finalized, at which point the object may be discarded. The method is never invoked more than once by a Java virtual machine for any given object. Any exception thrown by the method causes the finalization of this object to be halted, but is otherwise ignored.\n\n[[[\"Easy to understand\",\"easyToUnderstand\",\"thumb-up\"],[\"Solved my problem\",\"solvedMyProblem\",\"thumb-up\"],[\"Other\",\"otherUp\",\"thumb-up\"]],[[\"Missing the information I need\",\"missingTheInformationINeed\",\"thumb-down\"],[\"Too complicated / too many steps\",\"tooComplicatedTooManySteps\",\"thumb-down\"],[\"Out of date\",\"outOfDate\",\"thumb-down\"],[\"Samples / code issue\",\"samplesCodeIssue\",\"thumb-down\"],[\"Other\",\"otherDown\",\"thumb-down\"]],[\"Last updated 2025-03-13 UTC.\"],[],[]]"
    },
    {
        "link": "https://developer.android.com/develop/connectivity/bluetooth/setup",
        "document": "Before your app can communicate over Bluetooth or Bluetooth Low Energy, you need to verify that Bluetooth is supported on the device, and if it is, ensure that it is enabled. Note that this check is only necessary if the attribute in the manifest file entry is set to .\n\nIf Bluetooth isn't supported, then you should gracefully disable any Bluetooth features. If Bluetooth is supported, but disabled, then you can request that the user enable Bluetooth without leaving your app.\n\nThe first step is adding the Bluetooth permissions to your manifest file in order to use the following APIs.\n\nOnce the permissions are in place, Bluetooth setup is accomplished in two steps using the :\n• The is required for any and all Bluetooth activity. The represents the device's own Bluetooth adapter (the Bluetooth radio). To get a , you first need to have a . Use this context to obtain an instance of the system service. Calling will give you a object. If returns null, then the device doesn't support Bluetooth.\n• Next, you need to ensure that Bluetooth is enabled. Call to check whether Bluetooth is currently enabled. If this method returns false, then Bluetooth is disabled. To request that Bluetooth be enabled, call , passing in an intent action. This call issues a request to enable Bluetooth through the system settings (without stopping your app).\n\nA dialog appears requesting user permission to enable Bluetooth, as shown in figure 1. If the user grants permission, the system begins to enable Bluetooth, and focus returns to your app once the process completes (or fails).\n\nThe constant passed to is a locally-defined integer that must be greater than or equal to 0. The system passes this constant back to you in your implementation as the parameter.\n\nIf enabling Bluetooth succeeds, your activity receives the result code in the callback. If Bluetooth was not enabled due to an error (or the user responded \"Deny\") then the result code is .\n\nOptionally, your app can also listen for the broadcast intent, which the system broadcasts whenever the Bluetooth state changes. This broadcast contains the extra fields and , containing the new and old Bluetooth states, respectively. Possible values for these extra fields are , , , and . Listening for this broadcast can be useful if your app needs to detect runtime changes made to the Bluetooth state.\n\nTip: Enabling discoverability automatically enables Bluetooth. If you plan to consistently enable device discoverability before performing Bluetooth activity, you can skip step 2 in the earlier steps.\n\nOnce Bluetooth is enabled on the device, you can use both Bluetooth classic and Bluetooth Low Energy.\n\nFor Bluetooth classic, you can find Bluetooth devices and connect to Bluetooth devices.\n\nFor Bluetooth Low Energy, you can find BLE devices, connect to a GATT server, and transfer BLE data."
    },
    {
        "link": "https://stackoverflow.com/questions/69970743/android-studio-kotlin-bluetooth-action-request-enable-doesnt-work",
        "document": "After start my program, click the button, app falls. When I tried tutorials from other developers, Google, ... it doesnt solve the problem. I am ignoring startActivityForResult() is deprecated, I wanna ask user for turn on bluetooth - thats all.\n\nThe problem is on device with android 12.\n\nHere are my permission from manifest file:\n\nHere is my code from MainActivity.kt\n\nI am lost little bit... thank you for help..."
    },
    {
        "link": "https://stackoverflow.com/questions/62045391/androidstudio-kotlin-connect-to-bluetooth",
        "document": "Just because comments are not good for this, let me give you a list of things you ought to do before you can act with Bluetooth. (apologies this is in Java because that's what I have right now, but very easy to translate to Kotlin if needed)\n\nI'm doing this for BT LE (low energy) which is the preferred way for.. obvious reasons.\n• Did you add the permission(s) to the Manifest? You need something like\n• Make sure Bluetooth exists and is turned on...\n\nNow that you have a manager, you need to get the :\n\nAll this is fine in onCreate, but keep in mind that you have to check if BT is enabled every time the user resumes the activity (For it could have been turned off/disabled/revoked/etc).\n\nIf the BT radio is off (user turning it off), you can programmatically enable it, if you have the corresponding permission (which I think is BT admin or similar, you're gonna have to search on that one, because it's been a while).\n\nI believe it was.\n\nSince BT is a radio that needs power, it will take a while (seconds) to turn on and be available. For this you need to \"listen\" with Yet Another broadcast receiver...\n\nIn other words, the activity will fire an intent ( ) telling Android to enable BT, you will subscribe to that broadcast to listen to the callback. Once android informs you that BT is on, you can go back to step 1 and start checking if it's enabled, you have permission, etc.\n\nThe callback is if I have not forgotten too much... looked like\n\nIn there you ought to check for various states... among them:\n\nThis signals that the state changed, but another nested if is needed to determine to what state...\n\nThose are all the ones you care (check the BluetoothAdapter enum for more info).\n\nIn the you know BT is on... so..\n\nNow you can tell the adapter that you want to ...\n\n(remember to call when you're done).\n\nAs each device is found, the will be called with the info you need to attempt to connect and pair (if needed).\n\nThe signature of the callback ( ) is something like:\n\nThis is, as far as I can remember the old API.\n\nAPI 21 has a where you can specify how you want to scan, but it's essentially a similar method. Initiate scan, pass a callback and wait for results to show up.\n\nYou have various modes too:\n• None SCAN_MODE_OPPORTUNISTIC: can't remember :) I think it was to use other scanner results 'around' you. Never used it.\n\nOnce you have identified the device you were looking for the has everything you need to tell BT to \"connect\" to it.\n\n^ this is the signature of the \"new\" Scanner.\n\nFrom that ScanResult, you can do:\n\nIf the scan fails for any reason, you get a callback on . And again, there are various \"reasons\" (check the ) why the scan failed.\n\nRemember I may be mixing API 18 or API 21 \"apis\" here, but the concept is very similar in both.\n\nOnce you have finally grabbed a Device's MAC address... you can ask the adapter to try to connect to it:\n\nThe callback is of and again, it has a bunch of methods among them\n\nAt this point you ought to read more about how Bluetooth works (and how it works on Android) because there are various modes (Gatt being one way) of operating with BT. It's impossible to know each and how/what you want to do once connected.\n\nThe rule of thumb will be: make sure you're prepared to having to re-pair or re-request permissions, because it's ultimately the user's choice to disable, turn off, walk-away, revoke permission, etc. at any point during this."
    },
    {
        "link": "https://reintech.io/blog/kotlin-bluetooth-building-connected-android-app",
        "document": "In this tutorial, we will learn how to build an Android app that utilizes Bluetooth API to connect with other devices. We will be using Kotlin as our programming language.\n\nCreate a new Android project in Android Studio with Kotlin support enabled. Choose an empty activity template and name the project as \"BluetoothApp\".\n\nAdd the following permissions to the AndroidManifest.xml file:\n\nIn the MainActivity.kt file, add the following code to initialize the BluetoothAdapter:\n\nAdd the following code to the onCreate() function in MainActivity.kt to check if the device supports Bluetooth and display a message if it doesn't:\n\nAdd the following code to the onCreate() function in MainActivity.kt to enable Bluetooth if it's disabled:\n\nAdd the following code to MainActivity.kt to allow your app to discover Bluetooth devices:\n\nNow, add the following code to start the discovery process:\n\nOnce you have discovered the devices and selected one, you can connect to the device using the following code:\n\nReplace \"Device_Address\" with the actual address of the Bluetooth device you want to connect to, and MY_UUID with a UUID for your app. You can generate a UUID using the following command:\n\nIn this tutorial, we learned how to build an Android app using Kotlin and Bluetooth APIs to discover and connect to other devices. This knowledge can be helpful for developers looking to create connected apps and for those looking to hire Android developers with experience in Bluetooth technology."
    },
    {
        "link": "https://developer.android.com/develop/connectivity/bluetooth/bt-permissions",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nTo use Bluetooth features in your app, you must declare several permissions. You should also specify whether your app requires support for Bluetooth classic or Bluetooth Low Energy (BLE). If your app doesn't require Bluetooth classic or BLE but can still benefit from these technologies, you can check for availability at runtime.\n\nThe set of permissions that you declare in your app depends on your app's target SDK version.\n\nNote: On Android 8.0 (API level 26) and higher, the Companion Device Manager (CDM) provides a more streamlined method of connecting to companion devices, compared to the permissions described in this section. The CDM system provides a pairing UI on behalf of your app and doesn't require location permissions. If you want more control over the pairing and connecting experience, use the permissions described in this section.\n\nIf your app targets Android 12 (API level 31) or higher, declare the following permissions in your app's manifest file:\n• If your app looks for Bluetooth devices, such as BLE peripherals, declare the permission.\n• If your app makes the current device discoverable to other Bluetooth devices, declare the permission.\n• If your app communicates with already-paired Bluetooth devices, declare the permission.\n• For your legacy Bluetooth-related permission declarations, set to 30. This app compatibility step helps the system grant your app only the Bluetooth permissions that it needs when installed on devices that run Android 12 or higher.\n• If your app uses Bluetooth scan results to derive physical location, declare the permission. Otherwise, you can strongly assert that your app doesn't derive physical location and set to 30 for the permission.\n\nThe , , and permissions are runtime permissions. Therefore, you must explicitly request user approval in your app before you can look for Bluetooth devices, make a device discoverable to other devices, or communicate with already-paired Bluetooth devices. When your app requests at least one of these permissions, the system prompts the user to allow your app to access Nearby devices, as shown in figure 1.\n\nThe following code snippet demonstrates how to declare Bluetooth-related permissions in your app if it targets Android 12 or higher:\n\nIf your app doesn't use Bluetooth scan results to derive physical location, you can make a strong assertion that your app never uses the Bluetooth permissions to derive physical location. To do so, complete the following steps:\n• None Add the attribute to your permission declaration, and set this attribute's value to . Note: If you include in your , some BLE beacons are filtered from the scan results.\n• None If location isn't otherwise needed for your app, remove the permission from your app's manifest.\n\nThe following code snippet shows how to update your app's manifest file:\n\nIf your app targets Android 11 (API level 30) or lower, declare the following permissions in your app's manifest file:\n• is necessary to perform any Bluetooth classic or BLE communication, such as requesting a connection, accepting a connection, and transferring data.\n• is necessary because, on Android 11 and lower, a Bluetooth scan could potentially be used to gather information about the location of the user.\n\nBecause location permissions are runtime permissions, you must request these permissions at runtime along with declaring them in your manifest.\n\nIf you want your app to initiate device discovery or manipulate Bluetooth settings, you must declare the permission. Most apps need this permission solely for the ability to discover local Bluetooth devices. Don't use the other abilities granted by this permission unless the app is a \"power manager\" that modifies Bluetooth settings upon user request. Declare the permission in your app manifest file. For example:\n\nIf your app supports a service and can run on Android 10 (API level 29) or Android 11, you must also declare the permission to discover Bluetooth devices. For more information on this requirement, see Access location in the background.\n\nThe following code snippet shows how to declare the permission:\n\nSee the reference for more information about declaring app permissions.\n\nIf Bluetooth is a critical piece of your app, you can add flags to your manifest file indicating this requirement. The element allows you to specify the type of hardware your app uses and whether or not it is required.\n\nThis example shows how to indicate that Bluetooth classic is required for your app.\n\nIf your app relies on Bluetooth Low Energy, you can use the following:\n\nIf you say the feature is required for your app, then the Google Play store will hide your app from users on devices lacking those features. For this reason, you should only set the required attribute to if your app can't work without the feature.\n\nTo make your app available to devices that don't support Bluetooth classic or BLE, you should still include the element in your app's manifest, but set . Then, at run-time, you can determine feature availability by using :"
    },
    {
        "link": "https://stackoverflow.com/questions/75374234/requesting-runtime-permissions-in-kotlin",
        "document": "I have a MVVM app, which needs Bluetooth through the entire app. The only screen that doesn't require Bluetooth is the Onboarding screen. In the first screen, the app starts automatically searching for devices, which requires BLUETOOTH_SCAN to function properly. I have attempted numerous things to request the runtime permissions and check if the Bluetooth is on, but nothing seemed to work. I'd greatly appreciate any help.\n\nI have tried calling the functions in the onResume() of the activity, but it slows down the app a significant lot. I have also tried requesting the permissions when the startScan() function gets called, but that seems to crash, because in order to start the scan I need to have the permissions allowed and the bluetooth adapter should be initialized, a.k.a Bluetooth should be turned on"
    },
    {
        "link": "https://punchthrough.com/mastering-permissions-for-bluetooth-low-energy-android",
        "document": "Navigating Android’s ever-evolving permissions landscape can be a daunting task for developers building Bluetooth Low Energy (BLE) applications. Over the years, Android OS updates have introduced new permissions, modified existing ones, and changed how developers must approach permissions for BLE-related functionality.\n\nKeeping up with these changes can feel like aiming at a moving target, especially when each version of Android brings its own set of requirements. Whether it’s managing runtime permissions, addressing user denials, or making complex requests more user-friendly, understanding and adapting to these challenges is essential for building reliable and user-focused BLE apps.\n\nWhy Should You Trust Us?\n\nAt Punch Through, we understand these challenges intimately. With over a decade of experience tackling BLE-specific issues, we’ve encountered and solved countless problems that developers like you face daily. As the creators of the LightBlue app—a widely trusted tool in the BLE development community—we’ve worked extensively with BLE permissions and learned firsthand what works, what doesn’t, and how to make the process more efficient.\n\nThis article is designed to be your practical, code-focused resource for managing BLE permissions on Android. Our goal is to cut through the complexity and provide clear, actionable solutions to help you streamline your development process. Whether you’re struggling with permissions setup, runtime management, or user education, this guide will equip you with the knowledge to handle it all.Before diving in, note that this resource assumes you already have your BLE project set up. If you’re still in the early stages and need help getting started, we recommend checking out our Ultimate Guide to Android BLE, where we cover project setup in detail. Once you’re ready, let’s dive into the intricacies of permissions handling and take your BLE app to the next level.\n\nAll the code snippets in this guide aim to showcase how a given BLE operation should be performed. The actual, full implementation in the context of an example app is available on our open-source GitHub repo.\n\nNote: As of April 17, 2024, we’ve updated this entire repo to support a of Android 14, along with new Nearby Devices permission handling for Android 12+ and the new methods for Android 13+.\n\nWhy Are Permissions So Important?\n\nPermissions are foundational to building BLE apps, directly influencing your app’s ability to access BLE hardware, comply with Android’s safety requirements, and deliver a positive user experience. From the very beginning of app development, understanding your permissions requirements and implementing appropriate handling strategies is essential to ensuring your app can scan for, connect to, and exchange data with BLE devices\n\nBeyond functionality, permissions are critical for building privacy and trust into your app. BLE functionality often requires access to sensitive user data, such as location, which can raise concerns for users. Implementing permissions thoughtfully during development helps you create an app that is transparent, respects user privacy, and builds trust. Android’s permissions framework ensures that users stay in control of their data, and it’s your responsibility as a developer to design an app that aligns with these expectations.\n\nWith each new Android version, permissions policies evolve to address emerging threats and ensure apps handle sensitive data appropriately. This ever-changing landscape makes staying up-to-date on Android permissions requirements essential for BLE developers. Each Android update introduces new rules or adjustments that can impact how your app functions. Falling behind on these changes can lead to errors, crashes, or even the inability for your app to access BLE hardware at all.\n\nBy understanding the dependencies between BLE functionality and permissions—and adapting your app as policies evolve—you ensure your app remains secure, compliant, and functional, delivering the best possible experience to your users.\n\nNow that we’ve established why permissions are essential to BLE app functionality and user trust, let’s start with the first step in the permissions implementation process: declaring the required permissions in your AndroidManifest.xml file.\n\nThis file serves as the blueprint for your app’s permissions, informing Android about the features your app intends to use. Without the proper declarations here, your app won’t even get off the ground when it comes to accessing BLE hardware.\n\nWhether you’re starting a new project or revisiting an existing one, ensuring that all necessary permissions are included is crucial for avoiding runtime issues and ensuring compliance with Android’s evolving policies. Let’s walk through how to set this up.\n\nBegin by opening your project’s . You can find this file under app → manifests → in your project’s tool window. Within the <manifest> tag, you’ll need to include permissions that allow your app to perform core BLE tasks, such as scanning for and connecting to devices. Here’s what you’ll need to add:\n\nHere’s what each of these permissions do:\n• BLUETOOTH: Legacy permission that allows the app to connect to Bluetooth devices.\n• BLUETOOTH_ADMIN: Legacy permission that allows the app to scan for and bond with Bluetooth devices.\n• ACCESS_FINE_LOCATION: Between Android 6 and Android 11 (inclusive on both ends), location permission is required for the app to get BLE scan results. The main motivation behind having to require the users to grant this permission explicitly is to protect users’ privacy. A BLE scan can often unintentionally reveal the user’s location to unscrupulous app developers who scan for specific BLE beacons, or some BLE devices may advertise location-specific information. Before Android 10, ACCESS_COARSE_LOCATION can be used to gain access to BLE scan results, but we recommend using ACCESS_FINE_LOCATION instead since it works for all versions of Android.\n• ACCESS_COARSE_LOCATION: Apps targeting Android 12 (API 31) and above must also request this permission in addition to ACCESS_FINE_LOCATION.\n• BLUETOOTH_SCAN: For apps targeting Android 12 and above, developers can finally request explicit permission to perform only Bluetooth scans without having to obtain location access for devices running Android 12 and above.\n• BLUETOOTH_CONNECT: For apps targeting Android 12 and above, developers can request this permission to connect to Bluetooth peripherals that are currently bonded to an Android device running Android 12 and above.\n\nOut of all these permissions, , , , and are considered — in Android terms — dangerous or runtime permissions. What this means is that while some permissions are automatically granted to the app during installation time, the user needs to explicitly grant these permissions to the app from the app UI. It’s of utmost importance to stress to the user that your app won’t use their location for anything aside from ensuring BLE scanning works if that’s the case.\n\nIf BLE hardware is a requirement for your app, you can optionally declare that your app uses BLE features on Android devices. By doing so, users on devices without BLE capabilities won’t see your app on the Google Play Store. If this behavior sounds good, add the following snippet below the tags.\n\nOn Android, runtime permissions are used to enhance user control and privacy. Unlike install-time permissions, which are granted automatically when the app is installed, runtime permissions require users to explicitly grant access to sensitive features or data during app usage. This ensures that users are fully aware of and in control of the data or functionalities the app accesses at specific moments.\n\nFor Bluetooth Low Energy (BLE) apps, runtime permissions are essential because BLE functionality often involves accessing sensitive user data, such as location or nearby devices, which Android classifies as potentially privacy-invading. Without these permissions, your app cannot initiate key BLE operations, like scanning for or connecting to devices.\n\nOne of the things we recommend you have in your , , or at least in a extension function, is a way to know whether the user has granted the required runtime permissions. The following extension functions work together to do just this:\n\nThe two functions above are extension functions on the object, meaning each instance with access to these functions can call them and use them as if these functions were part of the original class declaration. Depending on how you structure your source code, these extension functions may reside in another Kotlin source file so that they can be accessed by other as well.\n\nNow add a top-level constant declaration outside your ‘s class declaration — the actual value of the constant can be any positive integer you want:\n\nSince the runtime permissions are only needed from the moment when the user wants to perform a BLE scan, it makes sense that we should only prompt the user to grant this permission when they want to initiate a BLE scan. The following snippets assume you have a Button that’ll start scanning for BLE devices when tapped.\n\nIn that ’s , we want to call a function . If that’s the only thing the will do, your code should look something like this:\n\nwill essentially check to see if the required runtime permissions have been granted before allowing the user to proceed with performing a BLE scan.\n\nwill call if we don’t yet have the relevant runtime permissions — this API-dependent check is encapsulated within , an extension function that we shared earlier.\n\nIf at least one runtime permission is missing, an alert will then be shown to inform the user of the need to grant the missing runtime permission(s) and giving them the sole option of “OK,” which will trigger a system dialog prompting the user to grant the relevant permission(s) to the app.\n\nWe’ll now need to do the same thing as before and react to the user’s actions, this time by overriding the function on to handle the case when the is equal to :\n\nIf the user agrees to grant the app with the runtime permissions that we’ve requested, we’re good to go and can start scanning for BLE devices; otherwise, we’ll keep asking them to grant those permissions if they have yet to permanently deny the request by checking the “Don’t ask again” box.\n\nNote on Android 11 and newer: A repeated denial is implicitly treated as a permanent denial by Android, and the app can no longer prompt the user to grant those permissions. In this case, developers should have proper UX explaining why the permissions are needed and how to remedy this situation by directing the users to App Settings so they can manually grant those denied permissions. A common way of doing so is by launching an and by setting the ‘s data to a specific URI which describes the app’s package name, e.g., .\n\nAgain, a well-designed app should have a more graceful way of handling the various rejection scenarios, but we’ll leave that as an exercise for the reader.\n\nAt this point, we’d like you to once again build and run the app on a physical Android device. If your Android device is running Android 6–11 (inclusive on both ends of the range), you should see a location access prompt appear as you tap “Start Scan”; if your device is running Android 12 or newer, you should see a nearby Bluetooth devices access prompt appear instead. Verify that the deny option will cause the permission request prompt to reappear, after which you should grant the requested permissions to avoid getting into the permanent denial execution branch.\n\nFor the sake of brevity, we’ll assume these runtime permissions have been granted for all the following sections.\n\nMaking Sure That Bluetooth is Enabled\n\nIf Bluetooth being enabled is crucial to your app’s core functionality, you’ll want to make sure that your users keep Bluetooth enabled while they’re using your app. Fortunately, Android provides an action that can prompt a user to turn on Bluetooth on their device. The only caveat is that if your app targets Android 12 or higher, the new permission must be granted before you can use this action.\n\nIn our example below, we want to check in the ’s if Bluetooth is enabled; if it’s not, we display an alert:\n\nWhen your first Activity is about to show with these additions, we check if the is enabled. If it’s not, we display a system alert utilizing . to request that the user enable Bluetooth on their Android device. Remember that you need the permission before you can launch this on Android 12 and above!\n\nAt this point, take the time to build and run the app on a physical Android device. We’re using an Android physical device because simulators don’t yet come with Bluetooth support at the time of writing. You’ll notice that if you disable Bluetooth and get to your , a system dialog prompts you to enable Bluetooth. If you dismiss the dialog, the app attempts to keep displaying the same alert over and over again until the user accepts our recommendation to turn on Bluetooth.\n\nIn a production app, there’ll likely be some kind of UX around this to educate the users on why they should enable Bluetooth. Instead of the very crude example of calling , you can either display a new informational alert that’ll later call into your function to display the Bluetooth-enabling system alert again or kick-start some other fancy user education flow.\n\nThe code samples in the following sections assume that they’ll only ever be called by the app code when the user has already granted all the relevant runtime permissions.\n\nFor the purposes of running our sample code, if you’re encapsulating all the BLE scanning and connecting logic in one or two main classes, you may want to add a for the specific “MissingPermission” warning that Android Studio may emit for classes that utilize the Android Bluetooth APIs without an explicit runtime permission check surrounding these usages.\n\nTo recap, permissions are the backbone of BLE app functionality. They ensure your app can access essential hardware, comply with Android’s security framework, and create a seamless, privacy-conscious user experience. By understanding why permissions matter, how they interact with BLE functionality, and implementing best practices for managing them, you’re setting your app up for success.\n\nBut handling permissions is just the beginning of building a robust BLE app. Once you’ve nailed down your permissions setup, the next steps involve performing a scan, discovering services, and diving into data transfer through read/write operations. If you’re ready to move on, we recommend exploring our Ultimate Guide to Android BLE for a detailed walkthrough of these advanced steps.If you’re looking to go deeper into BLE development, check out our resource page for more insights into advanced BLE functionalities. And if you’re still facing challenges—whether with permissions or any other part of your BLE app development process—Punch Through is here to help. With our extensive BLE expertise and hands-on experience, we’re ready to tackle even the toughest development roadblocks with you.\n\nFor more expert connectivity development resources, check out our other great resources:"
    },
    {
        "link": "https://medium.com/@elementalistbtg/android-permissions-for-bluetooth-1f3683ec6f5",
        "document": "While creating a simple Android app that uses the Bluetooth APIs I stumbled the most in the very first and expectedly easiest step of the process: Setting the right permissions for my App. 😥😥😥\n\nLet me tell you the issue so that nobody has to lose more hours on this trivial thing in the future. 😉\n\nTo begin with, I followed the official instructions provided for Bluetooth permissions targeting devices of Android 11 and 12. For older devices, the permissions change a bit but the process is the same.\n\nGenerally speaking, when you need permissions in an App you specify them at your Manifest and if they are considered dangerous you also request them at runtime…Easy right? 😉\n\nSo my manifest file looked like this:\n\nSince my app was discovering other devices and not the other way around I didn't use android.permission.BLUETOOTH_ADVERTISE (API 31+) but you may need to include it…\n\nBluetooth permissions are considered of the dangerous type so you must request them at runtime.\n\nNow what needed to be done is to ask for runtime permissions when the app was running (and preferably when the Bluetooth API needed it and not before).\n\nSo since my app was fairly simple, I had a button that initiated a devices list scan and then I had the permissions pop-up prompt show up….\n\nThe LATEST WAY of asking for permissions is to use ActivityResultContract either for single or multiple permissions. That was done like this (code is for composable functions and multiple permissions):\n\nDon't bother with the function extraLocationPermissionRequest() just yet….\n\nAnd the permissions required were:\n\nBy correctly handling the results for the permissions according to personal preferences this article should have finished here….\n\nBut unfortunately the App didn't work as intended in my phone (with Android 11 installed).🤔\n\nLet's see now the extra steps that are needed for the app to work.\n\nFirst, remember the function extraLocationPermissionRequest()? Well in Android 11 you need to request an extra permission for Manifest.permission.ACCESS_BACKGROUND_LOCATION in order for the app to allow you to use Bluetooth correctly.\n\nSo i used this function to take the user to another settings screen after he accepts the first permissions like this:\n\nI am using general purpose functions so take your time to study the code above…🧐\n\nAfter this extra step is made the user now must select the \"Allow all the time\" option from the settings screen.\n\nNow all these steps are documented although you have to poke around a lot to get them in order.\n\nThe last part is something that is NOT documented!\n\nAndroid official documentation gives us specific steps that are illustrated below:\n\nSo after declaring permissions in the Manifest and after the user consented to runtime permissions everything should work as intended right? right? RIGHT?😮‍💨\n\nWell… the Bluetooth never worked for my phone doing just the above… And it was by sheer luck that i found out the problem for this… You don't need to just give runtime access to bluetooth and location for your app.\n\nYou must have Bluetooth and Location services enabled!\n\nEnabling Bluetooth was already part of my process, but enabling GPS was something that took me hours to figure out… So if you want to scan for example for nearby Bluetooth devices then Location services must be enabled….\n\nSo as final step you add this piece of code (wherever you like)…\n\n… and you are done. Bluetooth is working just fine.🎉🎉🎉\n\nI hope my article is of any help to fellow developers that have not used Bluetooth before…\n\nAs an extra note i want to add that in the process of making my App work i tried also using Companion Device manager. The documentation is straightforward for this API and i managed to easily set it up correctly and got it working… BUT! I had to also enable Location Services for my app to be able to discover devices AND if you want to do anything more with the device you pair with (for example exchange data), you must request runtime permissions. So although i got it working i didn't use it after all.\n\nThe Android app I made is a simple App that communicates with a Raspberry Pi for a Google funded project I participated and the full code can be found here if you want:"
    },
    {
        "link": "https://developer.android.com/training/permissions/requesting",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nEvery Android app runs in a limited-access sandbox. If your app needs to use resources or information outside of its own sandbox, you can declare a runtime permission and set up a permission request that provides this access. These steps are part of the workflow for using permissions.\n\nIf you declare any dangerous permissions, and if your app is installed on a device that runs Android 6.0 (API level 23) or higher, you must request the dangerous permissions at runtime by following the steps in this guide.\n\nIf you don't declare any dangerous permissions, or if your app is installed on a device that runs Android 5.1 (API level 22) or lower, the permissions are automatically granted, and you don't need to complete any of the remaining steps on this page.\n\nThe basic principles for requesting permissions at runtime are as follows:\n• Ask for a permission in context, when the user starts to interact with the feature that requires it.\n• Don't block the user. Always provide the option to cancel an educational UI flow, such as a flow that explains the rationale for requesting permissions.\n• If the user denies or revokes a permission that a feature needs, gracefully degrade your app so that the user can continue using your app, possibly by disabling the feature that requires the permission.\n• Don't assume any system behavior. For example, don't assume that permissions appear in the same permission group. A permission group merely helps the system minimize the number of system dialogs that are presented to the user when an app requests closely related permissions.\n\nBefore you declare and request runtime permissions in your app, evaluate whether your app needs to do so. You can fulfill many use cases in your app, such as taking photos, pausing media playback, and displaying relevant ads, without needing to declare any permissions.\n\nIf you conclude that your app needs to declare and request runtime permissions, complete these steps:\n• In your app's manifest file, declare the permissions that your app might need to request.\n• Design your app's UX so that specific actions in your app are associated with specific runtime permissions. Let users know which actions might require them to grant permission for your app to access private user data.\n• Wait for the user to invoke the task or action in your app that requires access to specific private user data. At that time, your app can request the runtime permission that's required for accessing that data.\n• None Check whether the user has already granted the runtime permission that your app requires. If so, your app can access the private user data. If not, continue to the next step. You must check whether you have a permission every time you perform an operation that requires that permission.\n• None Check whether your app should show a rationale to the user, explaining why your app needs the user to grant a particular runtime permission. If the system determines that your app shouldn't show a rationale, continue to the next step directly, without showing a UI element. If the system determines that your app should show a rationale, however, present the rationale to the user in a UI element. In this rationale, clearly explain what data your app is trying to access and what benefits the app can provide to the user if they grant the runtime permission. After the user acknowledges the rationale, continue to the next step.\n• None Request the runtime permission that your app requires to access the private user data. The system displays a runtime permission prompt, such as the one shown on the permissions overview page.\n• None Check the user's response—whether they chose to grant or deny the runtime permission.\n• None If the user granted the permission to your app, you can access the private user data. If the user denied the permission instead, gracefully degrade your app experience so that it provides functionality to the user without the information that's protected by that permission.\n\nFigure 1 illustrates the workflow and set of decisions associated with this process:\n\nDetermine whether your app was already granted the permission\n\nTo check whether the user already granted your app a particular permission, pass that permission into the method. This method returns either or , depending on whether your app has the permission.\n\nExplain why your app needs the permission\n\nThe permissions dialog shown by the system when you call says what permission your app wants, but doesn't say why. In some cases, the user might find that puzzling. It's a good idea to explain to the user why your app wants the permissions before you call .\n\nResearch shows that users are much more comfortable with permissions requests if they know why the app needs them, such as whether the permission is needed to support a core feature of the app or for advertising. As a result, if you're only using a fraction of the API calls that fall under a permission group, it helps to explicitly list which of those permissions you're using and why. For example, if you're only using coarse location, let the user know this in your app description or in help articles about your app.\n\nUnder certain conditions, it's also helpful to let users know about sensitive data access in real time. For example, if you’re accessing the camera or microphone, it’s a good idea to let the user know by using a notification icon somewhere in your app, or in the notification tray (if the application is running in the background), so it doesn't seem like you're collecting data surreptitiously.\n\nUltimately, if you need to request a permission to make something in your app work, but the reason isn't clear to the user, find a way to let the user know why you need the most sensitive permissions.\n\nIf the method returns , call . If this method returns , show an educational UI to the user. In this UI, describe why the feature that the user wants to enable needs a particular permission.\n\nAdditionally, if your app requests a permission related to location, microphone, or camera, consider explaining why your app needs access to this information.\n\nAfter the user views an educational UI, or the return value of indicates that you don't need to show an educational UI, request the permission. Users see a system permission dialog, where they can choose whether to grant a particular permission to your app.\n\nTo do this, use the contract, included in an AndroidX library, where you allow the system to manage the permission request code for you. Because using the contract simplifies your logic, it is the recommended solution when possible. However, if needed you can also manage a request code yourself as part of the permission request and include this request code in your permission callback logic.\n\nAllow the system to manage the permission request code\n\nTo allow the system to manage the request code that's associated with a permissions request, add dependencies on the following libraries in your module's file:\n\nYou can then use one of the following classes:\n• To request multiple permissions at the same time, use .\n\nThe following steps show how to use the contract. The process is nearly the same for the contract.\n• None In your activity or fragment's initialization logic, pass in an implementation of into a call to . The defines how your app handles the user's response to the permission request. Keep a reference to the return value of , which is of type .\n• None To display the system permissions dialog when necessary, call the method on the instance of that you saved in the previous step. After is called, the system permissions dialog appears. When the user makes a choice, the system asynchronously invokes your implementation of , which you defined in the previous step. Note: Your app cannot customize the dialog that appears when you call . To provide more information or context to the user, change your app's UI so that it's easier for users to understand why a feature in your app needs a particular permission. For example, you might change the text in the button that enables the feature. Also, the text in the system permission dialog references the permission group associated with the permission that you requested. This permission grouping is designed for system ease-of-use, and your app shouldn't rely on permissions being within or outside of a specific permission group.\n\nThe following code snippet shows how to handle the permissions response:\n\nAnd this code snippet demonstrates the recommended process to check for a permission and to request a permission from the user when necessary:\n\nAs an alternative to allowing the system to manage the permission request code, you can manage the permission request code yourself. To do so, include the request code in a call to .\n\nThe following code snippet demonstrates how to request a permission using a request code:\n\nAfter the user responds to the system permissions dialog, the system then invokes your app's implementation of . The system passes in the user response to the permission dialog, as well as the request code that you defined, as shown in the following code snippet:\n\nWhen you request location permissions, follow the same best practices as for any other runtime permission. One important difference when it comes to location permissions is that the system includes multiple permissions related to location. Which permissions you request, and how you request them, depend on the location requirements for your app's use case.\n\nIf your app contains a feature that shares or receives location information only once, or for a defined amount of time, then that feature requires foreground location access. Some examples include the following:\n• Within a messaging app, a feature lets users share their current location with another user.\n\nThe system considers your app to be using foreground location if a feature of your app accesses the device's current location in one of the following situations:\n• An activity that belongs to your app is visible.\n• None Your app is running a foreground service. When a foreground service is running, the system raises user awareness by showing a persistent notification. Your app retains access when it's placed in the background, such as when the user presses the Home button on their device or turns their device's display off. On Android 10 (API level 29) and higher, you must declare a foreground service type of , as shown in the following code snippet. On earlier versions of Android, it's recommended that you declare this foreground service type. <!-- Recommended for Android 9 (API level 28) and lower. --> <!-- Required for Android 10 (API level 29) and higher. --> <service android:name=\"MyNavigationService\" android:foregroundServiceType=\"location\" ... > <!-- Any inner elements go here. --> </service>\n\nYou declare a need for foreground location when your app requests either the permission or the permission, as shown in the following snippet:\n\nAn app requires background location access if a feature within the app constantly shares location with other users or uses the Geofencing API. Several examples include the following:\n• Within an IoT app, a feature lets users configure their home devices such that they turn off when the user leaves their home and turn back on when the user returns home.\n\nThe system considers your app to be using background location if it accesses the device's current location in any situation other than the ones described in the foreground location section. The background location accuracy is the same as the foreground location accuracy, which depends on the location permissions that your app declares.\n\nOn Android 10 (API level 29) and higher, you must declare the permission in your app's manifest to request background location access at runtime. On earlier versions of Android, when your app receives foreground location access, it automatically receives background location access as well.\n\nIf the user denies a permission request, your app should help users understand the implications of denying the permission. In particular, your app should make users aware of the features that don't work because of the missing permission. When you do so, keep the following best practices in mind:\n• None Guide the user's attention. Highlight a specific part of your app's UI where there's limited functionality because your app doesn't have the necessary permission. Examples of what you could do include the following:\n• Show a message where the feature's results or data would have appeared.\n• Display a different button that contains an error icon and color.\n• None Be specific. Don't display a generic message. Instead, make clear which features are unavailable because your app doesn't have the necessary permission.\n• None Don't block the user interface. In other words, don't display a full-screen warning message that prevents users from continuing to use your app at all.\n\nAt the same time, your app should respect the user's decision to deny a permission. Starting in Android 11 (API level 30), if the user taps Deny for a specific permission more than once during your app's lifetime of installation on a device, the user doesn't see the system permissions dialog if your app requests that permission again. The user's action implies \"don't ask again.\" On previous versions, users saw the system permissions dialog each time your app requested a permission, unless they had previously selected a \"don't ask again\" checkbox or option.\n\nIf a user denies a permission request more than once, this is considered a permanant denial. It's very important to only prompt users for permissions when they need access to a specific feature, otherwise you might inadvertently lose the ability to re-request permissions.\n\nIn certain situations, the permission might be denied automatically, without the user taking any action. (A permission might be granted automatically as well.) It's important to not assume anything about automatic behavior. Each time your app needs to access functionality that requires a permission, check that your app is still granted that permission.\n\nTo provide the best user experience when asking for app permissions, also see App permissions best practices.\n\nTo identify whether an app has been permanently denied permissions (for debugging and testing purposes), use the following command:\n\nWhere is the name of the package to inspect.\n\nThe output of the command contains sections that look like this:\n\nPermissions that have been denied once by the user are flagged by . Permissions that have been denied permanently by selecting Deny twice are flagged by .\n\nTo ensure that testers see the request dialog during testing, reset these flags when you're done debugging your app. To do this, use the command:\n\nis the name of the permission you want to reset.\n\nTo view a complete list of Android app permissions, visit the permissions API reference page.\n\nStarting in Android 11 (API level 30), whenever your app requests a permission related to location, microphone, or camera, the user-facing permissions dialog contains an option called Only this time, as shown in figure 2. If the user selects this option in the dialog, your app is granted a temporary one-time permission.\n\nYour app can then access the related data for a period of time that depends on your app's behavior and the user's actions:\n• While your app's activity is visible, your app can access the data.\n• If the user sends your app to the background, your app can continue to access the data for a short period of time.\n• If you launch a foreground service while the activity is visible, and the user then moves your app to the background, your app can continue to access the data until the foreground service stops.\n\nIf the user revokes the one-time permission, such as in system settings, your app can't access the data, regardless of whether you launched a foreground service. As with any permission, if the user revokes your app's one-time permission, your app's process terminates.\n\nWhen the user next opens your app and a feature in your app requests access to location, microphone, or camera, the user is prompted for the permission again.\n\nAndroid provides several ways to reset unused runtime permissions to their default, denied state:\n• An API where you can proactively remove your app's access to an unused runtime permission.\n• A system mechanism that automatically resets the permissions of unused apps.\n\nOn Android 13 (API level 33) and higher, you can remove your app's access to runtime permissions that your app no longer requires. When you update your app, perform this step so that users are more likely to understand why your app continues to request specific permissions. This knowledge helps build user trust in your app.\n\nTo remove access to a runtime permission, pass the name of that permission into . To remove access to a group of runtime permissions at the same time, pass a collection of permission names into . The permission removal process happens asynchronously and kills all processes associated with your app's UID.\n\nFor the system to remove your app's access to the permissions, all processes tied to your app must be killed. When you call the API, the system determines when it's safe to kill these processes. Usually, the system waits until your app spends an extended period of time running in the background instead of the foreground.\n\nTo inform the user that your app no longer requires access to specific runtime permissions, show a dialog the next time the user launches your app. This dialog can include the list of permissions.\n\nIf your app targets Android 11 (API level 30) or higher and isn't used for a few months, the system protects user data by automatically resetting the sensitive runtime permissions that the user had granted your app. Learn more in the guide about app hibernation.\n\nRequest to become the default handler if necessary\n\nSome apps depend on access to sensitive user information related to call logs and SMS messages. If you want to request the permissions specific to call logs and SMS messages and publish your app to the Play Store, you must prompt the user to set your app as the default handler for a core system function before requesting these runtime permissions.\n\nFor more information on default handlers, including guidance on showing a default handler prompt to users, see the guide about permissions used only in default handlers.\n\nTo grant all runtime permissions automatically when you install an app on an emulator or test device, use the option for the command, as demonstrated in the following code snippet:\n\nFor additional information about permissions, read these articles:\n\nTo learn more about requesting permissions, review the permissions samples\n\nYou can also complete this codelab that demonstrates privacy best practices."
    }
]