[
    {
        "link": "https://doc.qt.io/qt-6/qmainwindow.html",
        "document": "The QMainWindow class provides a main application window. More...\n\nA main window provides a framework for building an application's user interface. Qt has QMainWindow and its related classes for main window management. QMainWindow has its own layout to which you can add QToolBars, QDockWidgets, a QMenuBar, and a QStatusBar. The layout has a center area that can be occupied by any kind of widget. You can see an image of the layout below. A central widget will typically be a standard Qt widget such as a QTextEdit or a QGraphicsView. Custom widgets can also be used for advanced applications. You set the central widget with . Main windows have either a single (SDI) or multiple (MDI) document interface. You create MDI applications in Qt by using a QMdiArea as the central widget. We will now examine each of the other widgets that can be added to a main window. We give examples on how to create and add them. Qt implements menus in QMenu and QMainWindow keeps them in a QMenuBar. QActions are added to the menus, which display them as menu items. You can add new menus to the main window's menu bar by calling , which returns the QMenuBar for the window, and then add a menu with QMenuBar::addMenu(). QMainWindow comes with a default menu bar, but you can also set one yourself with . If you wish to implement a custom menu bar (i.e., not use the QMenuBar widget), you can set it with . An example of how to create menus follows: The function creates popup menus when the main window receives context menu events. The default implementation generates a menu with the checkable actions from the dock widgets and toolbars. You can reimplement for a custom menu. Toolbars are implemented in the QToolBar class. You add a toolbar to a main window with . You control the initial position of toolbars by assigning them to a specific Qt::ToolBarArea. You can split an area by inserting a toolbar break - think of this as a line break in text editing - with or . You can also restrict placement by the user with QToolBar::setAllowedAreas() and QToolBar::setMovable(). The size of toolbar icons can be retrieved with . The sizes are platform dependent; you can set a fixed size with . You can alter the appearance of all tool buttons in the toolbars with . An example of toolbar creation follows: Dock widgets are implemented in the QDockWidget class. A dock widget is a window that can be docked into the main window. You add dock widgets to a main window with . There are four dock widget areas as given by the Qt::DockWidgetArea enum: left, right, top, and bottom. You can specify which dock widget area that should occupy the corners where the areas overlap with . By default each area can only contain one row (vertical or horizontal) of dock widgets, but if you enable nesting with , dock widgets can be added in either direction. Two dock widgets may also be stacked on top of each other. A QTabBar is then used to select which of the widgets should be displayed. We give an example of how to create and add dock widgets to a main window: You can set a status bar with , but one is created the first time (which returns the main window's status bar) is called. See QStatusBar for information on how to use it. QMainWindow can store the state of its layout with ; it can later be retrieved with . It is the position and size (relative to the size of the main window) of the toolbars and dock widgets that are stored.\n\nSee also QMenuBar, QToolBar, QStatusBar, QDockWidget, and Menus Example.\n\nThis enum contains flags that specify the docking behavior of QMainWindow. The user can drop one dock widget \"on top\" of another. The two widgets are stacked and a tab bar appears for selecting which one is visible. Each dock area contains a single stack of tabbed dock widgets. In other words, dock widgets cannot be placed next to each other in a dock area. If this option is set, AllowNestedDocks has no effect. The two vertical dock areas on the sides of the main window show their tabs vertically. If this option is not set, all dock areas show their tabs at the bottom. Implies AllowTabbedDocks. See also setTabPosition(). When dragging the titlebar of a dock, all the tabs that are tabbed with it are going to be dragged. Implies AllowTabbedDocks. Does not work well if some QDockWidgets have restrictions in which area they are allowed. (This enum value was added in Qt 5.6.) These options only control how dock widgets may be dropped in a QMainWindow. They do not re-arrange the dock widgets to conform with the specified options. For this reason they should be set before any dock widgets are added to the main window. Exceptions to this are the AnimatedDocks and VerticalTabs options, which may be set at any time. The DockOptions type is a typedef for QFlags<DockOption>. It stores an OR combination of DockOption values.\n\nThis property holds whether manipulating dock widgets and tool bars is animated When a dock widget or tool bar is dragged over the main window, the main window adjusts its contents to indicate where the dock widget or tool bar will be docked if it is dropped. Setting this property causes QMainWindow to move its contents in a smooth animation. Clearing this property causes the contents to snap into their new positions. By default, this property is set. It may be cleared if the main window contains widgets which are slow at resizing or repainting themselves. Setting this property is identical to setting the AnimatedDocks option using setDockOptions(). This property holds whether docks can be nested If this property is , dock areas can only contain a single row (horizontal or vertical) of dock widgets. If this property is , the area occupied by a dock widget can be split in either direction to contain more dock widgets. Dock nesting is only necessary in applications that contain a lot of dock widgets. It gives the user greater freedom in organizing their main window. However, dock nesting leads to more complex (and less intuitive) behavior when a dock widget is dragged over the main window, since there are more ways in which a dropped dock widget may be placed in the dock area. Setting this property is identical to setting the AllowNestedDocks option using setDockOptions(). This property holds the docking behavior of QMainWindow The default value is AnimatedDocks | AllowTabbedDocks. This property holds whether the tab bar for tabbed dockwidgets is set to document mode. size of toolbar icons in this mainwindow. The default is the default tool bar icon size of the GUI style. Note that the icons used must be at least of this size as the icons are only scaled down. This property holds the tab shape used for tabbed dock widgets. style of toolbar buttons in this mainwindow. To have the style of toolbuttons follow the system settings, set this property to Qt::ToolButtonFollowStyle. On Unix, the user settings from the desktop environment will be used. On other platforms, Qt::ToolButtonFollowStyle means icon only. This property holds whether the window uses the unified title and toolbar look on macOS Note that the Qt 5 implementation has several limitations compared to Qt 4:\n• Use in windows with OpenGL content is not supported. This includes QOpenGLWidget.\n• Using dockable or movable toolbars may result in painting errors and is not recommended\n\nConstructs a QMainWindow with the given parent and the specified widget flags. QMainWindow sets the Qt::Window flag itself, and will hence always be created as a top-level widget. Adds the given dockwidget to the specified area. Adds dockwidget into the given area in the direction specified by the orientation. Adds the toolbar into the specified area in this main window. The toolbar is placed at the end of the current tool bar block (i.e. line). If the main window already manages toolbar then it will only move the toolbar to area. See also insertToolBar(), addToolBarBreak(), and insertToolBarBreak(). This is an overloaded function. This is an overloaded function. Creates a QToolBar object, setting its window title to title, and inserts it into the top toolbar area. Adds a toolbar break to the given area after all the other objects that are present. Returns the central widget for the main window. This function returns if the central widget has not been set. Returns the dock widget area that occupies the specified corner. Returns a popup menu containing checkable entries for the toolbars and dock widgets present in the main window. If there are no toolbars and dock widgets present, this function returns . By default, this function is called by the main window when the user activates a context menu, typically by right-clicking on a toolbar or a dock widget. If you want to create a custom popup menu, reimplement this function and return a newly-created popup menu. Ownership of the popup menu is transferred to the caller. See also addDockWidget(), addToolBar(), and menuBar(). Returns the Qt::DockWidgetArea for dockwidget. If dockwidget has not been added to the main window, this function returns . See also addDockWidget(), splitDockWidget(), and Qt::DockWidgetArea. This signal is emitted when the size of the icons used in the window is changed. The new icon size is passed in iconSize. You can connect this signal to other components to help maintain a consistent appearance for your application. Inserts the toolbar into the area occupied by the before toolbar so that it appears before it. For example, in normal left-to-right layout operation, this means that toolbar will appear to the left of the toolbar specified by before in a horizontal toolbar area. See also insertToolBarBreak(), addToolBar(), and addToolBarBreak(). Inserts a toolbar break before the toolbar specified by before. Returns the menu bar for the main window. This function creates and returns an empty menu bar if the menu bar does not exist. If you want all windows in a Mac application to share one menu bar, don't use this function to create it, because the menu bar created here will have this QMainWindow as its parent. Instead, you must create a menu bar that does not have a parent, which you can then share among all the Mac windows. Create a parent-less menu bar this way: Returns the menu bar for the main window. This function returns null if a menu bar hasn't been constructed yet. Removes the dockwidget from the main window layout and hides it. Note that the dockwidget is not deleted. Removes the toolbar from the main window layout and hides it. Note that the toolbar is not deleted. Removes a toolbar break previously inserted before the toolbar specified by before. Resizes the dock widgets in the list docks to the corresponding size in pixels from the list sizes. If orientation is Qt::Horizontal, adjusts the width, otherwise adjusts the height of the dock widgets. The sizes will be adjusted such that the maximum and the minimum sizes are respected and the QMainWindow itself will not be resized. Any additional/missing space is distributed amongst the widgets according to the relative weight of the sizes. If the blue and the yellow widget are nested on the same level they will be resized such that the yellowWidget is twice as big as the blueWidget If some widgets are grouped in tabs, only one widget per group should be specified. Widgets not in the list might be changed to respect the constraints. Restores the state of dockwidget if it is created after the call to restoreState(). Returns if the state was restored; otherwise returns . See also restoreState() and saveState(). Restores the state of this mainwindow's toolbars and dockwidgets. Also restores the corner settings too. The version number is compared with that stored in state. If they do not match, the mainwindow's state is left unchanged, and this function returns ; otherwise, the state is restored, and this function returns . To restore geometry saved using QSettings, you can use code like this: See also saveState(), QWidget::saveGeometry(), QWidget::restoreGeometry(), and restoreDockWidget(). Saves the current state of this mainwindow's toolbars and dockwidgets. This includes the corner settings which can be set with setCorner(). The version number is stored as part of the data. The objectName property is used to identify each QToolBar and QDockWidget. You should make sure that this property is unique for each QToolBar and QDockWidget you add to the QMainWindow To restore the saved state, pass the return value and version number to restoreState(). To save the geometry when the window closes, you can implement a close event like this: See also restoreState(), QWidget::saveGeometry(), and QWidget::restoreGeometry(). Sets the given widget to be the main window's central widget. Note: QMainWindow takes ownership of the widget pointer and deletes it at the appropriate time. Sets the given dock widget area to occupy the specified corner. Sets the menu bar for the main window to menuBar. Note: QMainWindow takes ownership of the menuBar pointer and deletes it at the appropriate time. Sets the menu bar for the main window to menuBar. QMainWindow takes ownership of the menuBar pointer and deletes it at the appropriate time. Sets the status bar for the main window to statusbar. Setting the status bar to will remove it from the main window. Note that QMainWindow takes ownership of the statusbar pointer and deletes it at the appropriate time. Sets the tab position for the given dock widget areas to the specified tabPosition. By default, all dock areas show their tabs at the bottom. Note: The VerticalTabs dock option overrides the tab positions set by this method. See also tabPosition() and setTabShape(). Splits the space covered by the first dock widget into two parts, moves the first dock widget into the first part, and moves the second dock widget into the second part. The orientation specifies how the space is divided: A Qt::Horizontal split places the second dock widget to the right of the first; a Qt::Vertical split places the second dock widget below the first. Note: if first is currently in a tabbed docked area, second will be added as a new tab, not as a neighbor of first. This is because a single tab can contain only one dock widget. Note: The Qt::LayoutDirection influences the order of the dock widgets in the two parts of the divided area. When right-to-left layout direction is enabled, the placing of the dock widgets will be reversed. See also tabifyDockWidget(), addDockWidget(), and removeDockWidget(). Returns the status bar for the main window. This function creates and returns an empty status bar if the status bar does not exist. Note: The VerticalTabs dock option overrides the tab positions returned by this function. See also setTabPosition() and tabShape(). This signal is emitted when the tabified dock widget is activated by selecting the tab. The activated dock widget is passed in dockWidget. See also tabifyDockWidget() and tabifiedDockWidgets(). Returns the dock widgets that are tabified together with dockwidget. Moves second dock widget on top of first dock widget, creating a tabbed docked area in the main window. Removes the central widget from this main window. The ownership of the removed widget is passed to the caller. Returns the Qt::ToolBarArea for toolbar. If toolbar has not been added to the main window, this function returns . See also addToolBar(), addToolBarBreak(), and Qt::ToolBarArea. Returns whether there is a toolbar break before the toolbar. See also addToolBarBreak() and insertToolBarBreak(). This signal is emitted when the style used for tool buttons in the window is changed. The new style is passed in toolButtonStyle. You can connect this signal to other components to help maintain a consistent appearance for your application."
    },
    {
        "link": "https://doc.qt.io/qtforpython-5/PySide2/QtWidgets/QMainWindow.html",
        "document": "A central widget will typically be a standard Qt widget such as a or a . Custom widgets can also be used for advanced applications. You set the central widget with . Main windows have either a single (SDI) or multiple (MDI) document interface. You create MDI applications in Qt by using a as the central widget. We will now examine each of the other widgets that can be added to a main window. We give examples on how to create and add them.\n\nQt implements menus in and keeps them in a . s are added to the menus, which display them as menu items. You can add new menus to the main window’s menu bar by calling , which returns the for the window, and then add a menu with . comes with a default menu bar, but you can also set one yourself with . If you wish to implement a custom menu bar (i.e., not use the widget), you can set it with . An example of how to create menus follows: The function creates popup menus when the main window receives context menu events. The default implementation generates a menu with the checkable actions from the dock widgets and toolbars. You can reimplement for a custom menu.\n\ncan store the state of its layout with ; it can later be retrieved with . It is the position and size (relative to the size of the main window) of the toolbars and dock widgets that are stored. Application Example Dock Widgets Example MDI Example SDI Example Menus Example Constructs a with the given and the specified widget . sets the flag itself, and will hence always be created as a top-level widget. This enum contains flags that specify the docking behavior of . The user can drop one dock widget “on top” of another. The two widgets are stacked and a tab bar appears for selecting which one is visible. Each dock area contains a single stack of tabbed dock widgets. In other words, dock widgets cannot be placed next to each other in a dock area. If this option is set, has no effect. The two vertical dock areas on the sides of the main window show their tabs vertically. If this option is not set, all dock areas show their tabs at the bottom. Implies . See also . When dragging the titlebar of a dock, all the tabs that are tabbed with it are going to be dragged. Implies . Does not work well if some QDockWidgets have restrictions in which area they are allowed. (This enum value was added in Qt 5.6.) These options only control how dock widgets may be dropped in a . They do not re-arrange the dock widgets to conform with the specified options. For this reason they should be set before any dock widgets are added to the main window. Exceptions to this are the and options, which may be set at any time. Adds the given to the specified . Adds into the given in the direction specified by the . This is an overloaded function. Adds the into the specified in this main window. The is placed at the end of the current tool bar block (i.e. line). If the main window already manages then it will only move the toolbar to . Adds a toolbar break to the given after all the other objects that are present. Returns the central widget for the main window. This function returns zero if the central widget has not been set. Returns the dock widget area that occupies the specified . Returns a popup menu containing checkable entries for the toolbars and dock widgets present in the main window. If there are no toolbars and dock widgets present, this function returns . By default, this function is called by the main window when the user activates a context menu, typically by right-clicking on a toolbar or a dock widget. If you want to create a custom popup menu, reimplement this function and return a newly-created popup menu. Ownership of the popup menu is transferred to the caller. This property holds the docking behavior of . The default value is | . Returns the for . If has not been added to the main window, this function returns . This property holds whether the tab bar for tabbed dockwidgets is set to document mode.. This property holds size of toolbar icons in this mainwindow.. The default is the default tool bar icon size of the GUI style. Note that the icons used must be at least of this size as the icons are only scaled down. Inserts the into the area occupied by the toolbar so that it appears before it. For example, in normal left-to-right layout operation, this means that will appear to the left of the toolbar specified by in a horizontal toolbar area. Inserts a toolbar break before the toolbar specified by . This property holds whether manipulating dock widgets and tool bars is animated. When a dock widget or tool bar is dragged over the main window, the main window adjusts its contents to indicate where the dock widget or tool bar will be docked if it is dropped. Setting this property causes to move its contents in a smooth animation. Clearing this property causes the contents to snap into their new positions. By default, this property is set. It may be cleared if the main window contains widgets which are slow at resizing or repainting themselves. Setting this property is identical to setting the option using . This property holds whether docks can be nested. If this property is , dock areas can only contain a single row (horizontal or vertical) of dock widgets. If this property is , the area occupied by a dock widget can be split in either direction to contain more dock widgets. Dock nesting is only necessary in applications that contain a lot of dock widgets. It gives the user greater freedom in organizing their main window. However, dock nesting leads to more complex (and less intuitive) behavior when a dock widget is dragged over the main window, since there are more ways in which a dropped dock widget may be placed in the dock area. Setting this property is identical to setting the option using . Returns the menu bar for the main window. This function creates and returns an empty menu bar if the menu bar does not exist. If you want all windows in a Mac application to share one menu bar, don’t use this function to create it, because the menu bar created here will have this as its parent. Instead, you must create a menu bar that does not have a parent, which you can then share among all the Mac windows. Create a parent-less menu bar this way: Returns the menu bar for the main window. This function returns null if a menu bar hasn’t been constructed yet. Removes the from the main window layout and hides it. Note that the is not deleted. Removes the from the main window layout and hides it. Note that the is not deleted. Removes a toolbar break previously inserted before the toolbar specified by . Resizes the dock widgets in the list to the corresponding size in pixels from the list . If is , adjusts the width, otherwise adjusts the height of the dock widgets. The sizes will be adjusted such that the maximum and the minimum sizes are respected and the itself will not be resized. Any additional/missing space is distributed amongst the widgets according to the relative weight of the sizes. If the blue and the yellow widget are nested on the same level they will be resized such that the yellowWidget is twice as big as the blueWidget If some widgets are grouped in tabs, only one widget per group should be specified. Widgets not in the list might be changed to respect the constraints. Restores the state of if it is created after the call to . Returns if the state was restored; otherwise returns . Restores the of this mainwindow’s toolbars and dockwidgets. Also restores the corner settings too. The number is compared with that stored in . If they do not match, the mainwindow’s state is left unchanged, and this function returns ; otherwise, the state is restored, and this function returns . To restore geometry saved using , you can use code like this: Saves the current state of this mainwindow’s toolbars and dockwidgets. This includes the corner settings which can be set with . The number is stored as part of the data. The property is used to identify each and . You should make sure that this property is unique for each and you add to the To restore the saved state, pass the return value and number to . To save the geometry when the window closes, you can implement a close event like this: This property holds whether manipulating dock widgets and tool bars is animated. When a dock widget or tool bar is dragged over the main window, the main window adjusts its contents to indicate where the dock widget or tool bar will be docked if it is dropped. Setting this property causes to move its contents in a smooth animation. Clearing this property causes the contents to snap into their new positions. By default, this property is set. It may be cleared if the main window contains widgets which are slow at resizing or repainting themselves. Setting this property is identical to setting the option using . Sets the given to be the main window’s central widget. Note: takes ownership of the pointer and deletes it at the appropriate time. Sets the given dock widget to occupy the specified . This property holds whether docks can be nested. If this property is , dock areas can only contain a single row (horizontal or vertical) of dock widgets. If this property is , the area occupied by a dock widget can be split in either direction to contain more dock widgets. Dock nesting is only necessary in applications that contain a lot of dock widgets. It gives the user greater freedom in organizing their main window. However, dock nesting leads to more complex (and less intuitive) behavior when a dock widget is dragged over the main window, since there are more ways in which a dropped dock widget may be placed in the dock area. Setting this property is identical to setting the option using . This property holds the docking behavior of . The default value is | . This property holds whether the tab bar for tabbed dockwidgets is set to document mode.. This property holds size of toolbar icons in this mainwindow.. The default is the default tool bar icon size of the GUI style. Note that the icons used must be at least of this size as the icons are only scaled down. Sets the menu bar for the main window to . Note: takes ownership of the pointer and deletes it at the appropriate time. Sets the menu bar for the main window to . takes ownership of the pointer and deletes it at the appropriate time. Sets the status bar for the main window to . Setting the status bar to will remove it from the main window. Note that takes ownership of the pointer and deletes it at the appropriate time. Sets the tab position for the given dock widget to the specified . By default, all dock areas show their tabs at the bottom. The dock option overrides the tab positions set by this method. This property holds the tab shape used for tabbed dock widgets.. This property holds style of toolbar buttons in this mainwindow.. To have the style of toolbuttons follow the system settings, set this property to . On Unix, the user settings from the desktop environment will be used. On other platforms, means icon only. This property holds whether the window uses the unified title and toolbar look on macOS. Note that the Qt 5 implementation has several limitations compared to Qt 4:\n• None Use in windows with OpenGL content is not supported. This includes and .\n• None Using dockable or movable toolbars may result in painting errors and is not recommended Splits the space covered by the dock widget into two parts, moves the dock widget into the first part, and moves the dock widget into the second part. The specifies how the space is divided: A split places the second dock widget to the right of the first; a split places the second dock widget below the first. Note : if is currently in a tabbed docked area, will be added as a new tab, not as a neighbor of . This is because a single tab can contain only one dock widget. Note : The influences the order of the dock widgets in the two parts of the divided area. When right-to-left layout direction is enabled, the placing of the dock widgets will be reversed. Returns the status bar for the main window. This function creates and returns an empty status bar if the status bar does not exist. The dock option overrides the tab positions returned by this function. This property holds the tab shape used for tabbed dock widgets.. Returns the dock widgets that are tabified together with . Moves dock widget on top of dock widget, creating a tabbed docked area in the main window. Removes the central widget from this main window. The ownership of the removed widget is passed to the caller. Returns the for . If has not been added to the main window, this function returns . Returns whether there is a toolbar break before the . This property holds style of toolbar buttons in this mainwindow.. To have the style of toolbuttons follow the system settings, set this property to . On Unix, the user settings from the desktop environment will be used. On other platforms, means icon only. This property holds whether the window uses the unified title and toolbar look on macOS. Note that the Qt 5 implementation has several limitations compared to Qt 4:\n• None Use in windows with OpenGL content is not supported. This includes and .\n• None Using dockable or movable toolbars may result in painting errors and is not recommended"
    },
    {
        "link": "https://pythonguis.com/tutorials/pyqt-basic-widgets",
        "document": "In Qt, like in most GUI frameworks, widget is the name given to a component of the UI that the user can interact with. User interfaces are made up of multiple widgets, arranged within the window.\n\nQt comes with a large selection of widgets available and even allows you to create your own custom and customized widgets. In this tutorial, you'll learn the basics of some of the most commonly used widgets in Qt GUI applications.\n\nFirst, let's have a look at some of the most common PyQt widgets. The following code creates a range of PyQt widgets and adds them to a window layout so you can see them together:\n\nRun it! You'll see a window appear containing all the widgets we've created:\n\nWe'll cover how layouts work in Qt in the next tutorial.\n\nLet's have a look at all the example widgets, from top to bottom:\n\nThere are far more widgets than this, but they don’t fit so well! You can see them all by checking the Qt documentation.\n\nNext, we'll step through some of the most commonly used widgets and look at them in more detail. To experiment with the widgets, we'll need a simple application to put them in. Save the following code to a file named and run it to make sure it's working:\n\nIn the code above, we've imported a number of Qt widgets. Now we'll step through each of those widgets in turn, adding them to our application and seeing how they behave.\n\nWe'll start the tour with , arguably one of the simplest widgets available in the Qt toolbox. This is a simple one-line piece of text that you can position in your application. You can set the text by passing in a string as you create it:\n\nYou can also set the text of a label dynamically, by using the method:\n\nYou can also adjust font parameters, such as the size of the font or the alignment of text in the widget:\n\nFont tip Note that if you want to change the properties of a widget font it is usually better to get the current font, update it, and then apply it back. This ensures the font face remains in keeping with the desktop conventions.\n\nThe alignment is specified by using a flag from the namespace. The flags available for horizontal alignment are listed in the following table:\n\nSimilarly, the flags available for vertical alignment are:\n\nYou can combine flags together using pipes ( ). However, note that you can only use vertical or horizontal alignment flags at a time:\n\nNote that you use an OR pipe ( ) to combine the two flags (not ). This is because the flags are non-overlapping bitmasks. For example, has the hexadecimal value , while is . By ORing them together, we get the value , representing 'bottom left'. This principle applies to all other combinatorial Qt flags. If this is gibberish to you, then feel free to ignore it and move on. Just remember to use the pipe ( ) symbol.\n\nFinally, there is also a shorthand flag that centers in both directions simultaneously:\n\nWeirdly, you can also use to display an image using . This accepts a pixmap, which you can create by passing an image filename to the class.\n\nBelow is an image which you can download for this example.\n\nPlace the file in the same folder as your code, and then display it in your window as follows:\n\nWhat a lovely face. By default, the image scales while maintaining its aspect ratio. If you want it to stretch and scale to fit the window completely, then you can call on the object:\n\nThis way, your image will stretch and scale to fit the window completely.\n\nThe next widget to look at is , which, as the name suggests, presents a checkable box to the user. However, as with all Qt widgets, there are a number of configurable options to change the widget's default behaviors:\n\nYou can set a checkbox state programmatically using the or methods. The former accepts either or , which correspond to the checked or unchecked states, respectively. However, with , you also specify a particular checked state using a namespace flag:\n\nA checkbox that supports a partially-checked ( ) state is commonly referred to as 'tri-state', which is being neither on nor off. A checkbox in this state is commonly shown as a greyed-out checkbox, and is commonly used in hierarchical checkbox arrangements where sub-items are linked to parent checkboxes.\n\nIf you set the value to the checkbox will become tristate. You can also set a checkbox to be tri-state without setting the current state to partially checked by using\n\nYou may notice that when the script is running, the current state number is displayed as an with checked = , unchecked = , and partially checked = . You don’t need to remember these values, the namespace variable , for example. This is the value of these state's respective flags. This means you can test state using .\n\nThe is a drop-down list, closed by default with an arrow to open it. You can select a single item from the list, with the currently selected item being shown as a label on the widget. The combo box is suited for the selection of a choice from a long list of options.\n\nYou have probably seen the combo box used for the selection of font face, or size, in word processing applications. Although Qt actually provides a specific font-selection combo box as .\n\nYou can add items to a by passing a list of strings to . Items will be added in the order they are provided:\n\nThe signal is triggered when the currently selected item is updated, by default passing the index of the selected item in the list. There is also a signal, which instead provides the label of the currently selected item, which is often more useful.\n\ncan also be editable, allowing users to enter values not currently in the list and either have them inserted or simply used as a value. To make the box editable, use the method:\n\nYou can also set a flag to determine how the insertion is handled. These flags are stored on the class itself and are listed below:\n\nTo use these, apply the flag as follows:\n\nYou can also limit the number of items allowed in the box by using the method:\n\nFor a more in-depth look at the , check out our QComboBox documentation.\n\nThis widget is similar to , except options are presented as a scrollable list of items. It also supports the selection of multiple items at once. A offers a signal, which sends the (the element of the list widget), and a signal, which sends the text of the current item:\n\nThe widget is a single-line text editing box, into which users can type input. These are used for form fields, or settings where there is no restricted list of valid inputs. For example, when entering an email address, or computer name:\n\nAs demonstrated in the above code, you can set a maximum length for the text in a line edit using the method.\n\nThe has a number of signals available for different editing events, including when the Enter key is pressed (by the user), and when the user selection is changed. There are also two edit signals, one for when the text in the box has been edited and one for when it has been changed. The distinction here is between user edits and programmatic changes. The signal is only sent when the user edits text.\n\nAdditionally, it is possible to perform input validation using an input mask to define which characters are supported and where. This can be applied to the field as follows:\n\nThe above would allow a series of 3-digit numbers separated with periods, and could therefore be used to validate IPv4 addresses.\n\nprovides a small numerical input box with arrows to increase and decrease the value. supports integers, while the related widget, , supports floats:\n\nRun it, and you'll see a numeric entry box. The value shows pre and post-fix units and is limited to the range 3 to -10.\n\nThe demonstration code above shows the various features that are available for the widget.\n\nTo set the range of acceptable values, you can use the and methods. Alternatively, use to set both simultaneously. Annotation of value types is supported with both prefixes and suffixes that can be added to the number (e.g. for currency markers or units) using the and methods, respectively.\n\nClicking the up and down arrows on the widget will increase or decrease the value in the widget by an amount, which can be set using the method. Note that this has no effect on the values that are acceptable to the widget.\n\nBoth and have a signal, which fires whenever their value is altered. The raw signal sends the numeric value (either an or a ), while sends the value as a string, including both the prefix and suffix characters.\n\nYou can optionally disable text input on the spin box's line edit, by setting it to read-only. With this setting, the value can only be changed using the controls:\n\nThis setting also has the side effect of disabling the flashing cursor.\n\nprovides a slide-bar widget, which internally works like a . Rather than display the current value numerically, that value is represented by the position of the slider's handle along the length of the widget. This is often useful when providing adjustment between two extremes, but when absolute accuracy is not required. The most common use case of this type of widget is for volume controls in audio playback.\n\nThere is an additional signal that is triggered whenever the slider moves position and a signal that is emitted whenever the slider is clicked:\n\nRun this, and you'll see a slider widget. Drag the slider to change the value:\n\nYou can also construct a slider with a vertical or horizontal orientation by providing the orientation as you create it. The orientation flags are defined in the namespace:\n\nFinally, the widget is a rotatable widget that works just like the slider but appears as an analog dial. This widget looks nice, but from a UI perspective, it is not particularly user-friendly. However, dials are often used in audio applications as a representation of real-world analog dials:\n\nRun this, and you'll see a circular dial. Rotate it to select a number from the range:\n\nThe signals are the same as for the widget and retain the same names (e.g. ).\n\nThis concludes our brief tour of the common widgets used in PyQt applications. To see the full list of available widgets, including all their signals and attributes, check out the Qt documentation."
    },
    {
        "link": "https://tutorialspoint.com/pyqt5/pyqt5_quick_guide.htm",
        "document": "PyQt is a GUI widgets toolkit. It is a Python interface for Qt, one of the most powerful, and popular cross-platform GUI library. PyQt was developed by RiverBank Computing Ltd. The latest version of PyQt can be downloaded from its official website − riverbankcomputing.com\n\nPyQt API is a set of modules containing a large number of classes and functions. While QtCore module contains non-GUI functionality for working with file and directory etc., QtGui module contains all the graphical controls. In addition, there are modules for working with XML (QtXml), SVG (QtSvg), and SQL (QtSql), etc.\n\nA list of frequently used modules is given below −\n• None QtCore − Core non-GUI classes used by other modules\n• None QtSvg − Classes for displaying the contents of SVG files\n\nPyQt is compatible with all the popular operating systems including Windows, Linux, and Mac OS. It is dual licensed, available under GPL as well as commercial license. The latest stable version is PyQt5-5.13.2.\n\nWheels for 32-bit or 64-bit architecture are provided that are compatible with Python version 3.5 or later. The recommended way to install is using PIP utility −\n\nTo install development tools such as Qt Designer to support PyQt5 wheels, following is the command −\n\nYou can also build PyQt5 on Linux/macOS from the source code www.riverbankcomputing.com/static/Downloads/PyQt5\n\nPyQt5 API is not automatically compatible with earlier versions. Hence, Python code involving PyQt4 modules should be upgraded manually by making relevant changes. In this chapter, main differences between PyQt4 and PyQt5 have been listed.\n\nPyQt5 is not supported on versions of Python earlier than v2.6.\n\nPyQt5 doesn't support connect() method of QObject class for connection between signal and slot. Hence the usage can no more be implemented −\n\nOnly the following syntax is defined −\n\nClasses defined in earlier QtGui module have been distributed in QtGui, QtPrintSupport an QtWidgets modules.\n\nIn the new QFileDialog class, The getOpenFileNameAndFilter() method is replaced by getOpenFileName(), getOpenFileNamesAndFilter() by getOpenFileNames() and getSaveFileNameAndFilter() by getSaveFileName(). Older signatures of these methods also have changed.\n\nPyQt5 doesnt have provision to define a class that is sub-classed from more than one Qt class.\n\npyuic5 utility (to generates Python code from Designer's XML file) does not support the --pyqt3-wrapper flag.\n\npyrcc5 does not support the -py2 and -py3 flags. The output of pyrcc5 is compatible with all versions of Python v2.6 onwards.\n\nPyQt5 always invokes sip.setdestroyonexit() automatically and calls the C++ destructor of all wrapped instances that it owns.\n\nCreating a simple GUI application using PyQt involves the following steps −\n• None Set the caption of label as \"hello world\".\n• None Define the size and position of window by setGeometry() method.\n• None Enter the mainloop of application by app.exec_() method.\n\nFollowing is the code to execute Hello World program in PyQt −\n\nThe above code produces the following output −\n\nIt is also possible to develop an object oriented solution of the above code.\n• None Add a QLabel object and set the caption of label as \"hello world\".\n• None Define the size and position of window by setGeometry() method.\n• None Enter the mainloop of application by app.exec_() method.\n\nFollowing is the complete code of the object oriented solution −\n\nPyQt API is a large collection of classes and methods. These classes are defined in more than 20 modules.\n\nFollowing are some of the frequently used modules −\n\nPyQt5 development tools is a collection of useful utilities for Qt development. Following is a select list of such utilities −\n\nPyQt API contains more than 400 classes. The QObject class is at the top of class hierarchy. It is the base class of all Qt objects. Additionally, QPaintDevice class is the base class for all objects that can be painted.\n\nQApplication class manages the main settings and control flow of a GUI application. It contains main event loop inside which events generated by window elements and other sources are processed and dispatched. It also handles system-wide and application-wide settings.\n\nQWidget class, derived from QObject and QPaintDevice classes is the base class for all user interface objects. QDialog and QFrame classes are also derived from QWidget class. They have their own sub-class system.\n\nHere is a select list of frequently used widgets\n\nA typical GUI based applications top level window is created by QMainWindow widget object. Some widgets as listed above take their appointed place in this main window, while others are placed in the central widget area using various layout managers.\n\nThe following diagram shows the QMainWindow framework −\n\nThe PyQt installer comes with a GUI builder tool called Qt Designer. Using its simple drag and drop interface, a GUI interface can be quickly built without having to write the code. It is however, not an IDE such as Visual Studio. Hence, Qt Designer does not have the facility to debug and build the application.\n\nStart Qt Designer application which is a part of development tools and installed in scripts folder of the virtual environment.\n\nYou can then drag and drop required widgets from the widget box on the left pane. You can also assign value to properties of widget laid on the form.\n\nThe designed form is saved as demo.ui. This ui file contains XML representation of widgets and their properties in the design. This design is translated into Python equivalent by using pyuic5 command line utility. This utility is a wrapper for uic module of Qt toolkit. The usage of pyuic5 is as follows −\n\nIn the above command, -x switch adds a small amount of additional code to the generated Python script (from XML) so that it becomes a self-executable standalone application.\n\nThe resultant python script is executed to show the following dialog box −\n\nThe user can input data in input fields but clicking on Add button will not generate any action as it is not associated with any function. Reacting to user-generated response is called as event handling.\n\nUnlike a console mode application, which is executed in a sequential manner, a GUI based application is event driven. Functions or methods are executed in response to users actions like clicking on a button, selecting an item from a collection or a mouse click etc., called events.\n\nWidgets used to build the GUI interface act as the source of such events. Each PyQt widget, which is derived from QObject class, is designed to emit signal in response to one or more events. The signal on its own does not perform any action. Instead, it is connected to a slot. The slot can be any callable Python function.\n\nFirst design a simple form with a LineEdit control and a PushButton.\n\nIt is desired that if button is pressed, contents of text box should be erased. The QLineEdit widget has a clear() method for this purpose. Hence, the buttons clicked signal is to be connected to clear() method of the text box.\n\nTo start with, choose Edit signals/slots from Edit menu (or press F4). Then highlight the button with mouse and drag the cursor towards the textbox\n\nAs the mouse is released, a dialog showing signals of button and methods of slot will be displayed. Select clicked signal and clear() method\n\nThe Signal/Slot Editor window at bottom right will show the result −\n\nSave ui and Build and Python code from ui file as shown in the below code −\n\nGenerated Python code will have the connection between signal and slot by the following statement −\n\nRun signalslot.py and enter some text in the LineEdit. The text will be cleared if the button is pressed.\n\nInstead of using Designer, you can directly establish signal-slot connection by following syntax −\n\nSuppose if a function is to be called when a button is clicked. Here, the clicked signal is to be connected to a callable function. It can be achieved in any of the following technique −\n\nIn the following example, two QPushButton objects (b1 and b2) are added in QDialog window. We want to call functions b1_clicked() and b2_clicked() on clicking b1 and b2 respectively.\n\nWhen b1 is clicked, the clicked() signal is connected to b1_clicked() function −\n\nWhen b2 is clicked, the clicked() signal is connected to b2_clicked() function.\n\nThe above code produces the following output −\n\nA GUI widget can be placed inside the container window by specifying its absolute coordinates measured in pixels. The coordinates are relative to the dimensions of the window defined by setGeometry() method.\n\nIn the following code snippet, the top level window of 300 by 200 pixels dimensions is displayed at position (10, 10) on the monitor.\n\nA PushButton widget is added in the window and placed at a position 50 pixels towards right and 20 pixels below the top left position of the window.\n\nThis Absolute Positioning, however, is not suitable because of following reasons −\n• None The position of the widget does not change even if the window is resized.\n• None The appearance may not be uniform on different display devices with different resolutions.\n• None Modification in the layout is difficult as it may need redesigning the entire form.\n\nPyQt API provides layout classes for more elegant management of positioning of widgets inside the container. The advantages of Layout managers over absolute positioning are −\n• None Ensures uniform appearance on display devices with different resolutions.\n• None Adding or removing widget dynamically is possible without having to redesign.\n\nQt toolkit defines various layouts that can be used with Qt Designer utility.\n\nHere is the list of Classes which we will discuss one by one in this chapter.\n\nHere is the list of Widgets which we will discuss one by one in this chapter.\n\nQLabel A QLabel object acts as a placeholder to display non-editable text or image, or a movie of animated GIF. It can also be used as a mnemonic key for other widgets. QLineEdit QLineEdit object is the most commonly used input field. It provides a box in which one line of text can be entered. In order to enter multi-line text, QTextEdit object is required. QPushButton In PyQt API, the QPushButton class object presents a button which when clicked can be programmed to invoke a certain function. QRadioButton A QRadioButton class object presents a selectable button with a text label. The user can select one of many options presented on the form. This class is derived from QAbstractButton class. QCheckBox A rectangular box before the text label appears when a QCheckBox object is added to the parent window. Just as QRadioButton, it is also a selectable button. QComboBox A QComboBox object presents a dropdown list of items to select from. It takes minimum screen space on the form required to display only the currently selected item. QSpinBox A QSpinBox object presents the user with a textbox which displays an integer with up/down button on its right. QSlider Widget & Signal QSlider class object presents the user with a groove over which a handle can be moved. It is a classic widget to control a bounded value. QMenuBar, QMenu & QAction A horizontal QMenuBar just below the title bar of a QMainWindow object is reserved for displaying QMenu objects. QToolBar A QToolBar widget is a movable panel consisting of text buttons, buttons with icons or other widgets. QInputDialog This is a preconfigured dialog with a text field and two buttons, OK and Cancel. The parent window collects the input in the text box after the user clicks on Ok button or presses Enter. QFontDialog Another commonly used dialog, a font selector widget is the visual appearance of QDialog class. Result of this dialog is a Qfont object, which can be consumed by the parent window. QFileDialog This widget is a file selector dialog. It enables the user to navigate through the file system and select a file to open or save. The dialog is invoked either through static functions or by calling exec_() function on the dialog object. QTab If a form has too many fields to be displayed simultaneously, they can be arranged in different pages placed under each tab of a Tabbed Widget. The QTabWidget provides a tab bar and a page area. QStacked Functioning of QStackedWidget is similar to QTabWidget. It also helps in the efficient use of windows client area. QSplitter This is another advanced layout manager which allows the size of child widgets to be changed dynamically by dragging the boundaries between them. The Splitter control provides a handle that can be dragged to resize the controls. QDock A dockable window is a subwindow that can remain in floating state or can be attached to the main window at a specified position. Main window object of QMainWindow class has an area reserved for dockable windows. QStatusBar QMainWindow object reserves a horizontal bar at the bottom as the status bar. It is used to display either permanent or contextual status information. QList QListWidget class is an item-based interface to add or remove items from a list. Each item in the list is a QListWidgetItem object. ListWidget can be set to be multiselectable. QScrollBar A scrollbar control enables the user to access parts of the document that is outside the viewable area. It provides visual indicator to the current position. QCalendar QCalendar widget is a useful date picker control. It provides a month-based view. The user can select the date by the use of the mouse or the keyboard, the default being todays date.\n\nA QDialog widget presents a top level window mostly used to collect response from the user. It can be configured to be Modal (where it blocks its parent window) or Modeless (the dialog window can be bypassed).\n\nPyQt API has a number of preconfigured Dialog widgets such as InputDialog, FileDialog, FontDialog, etc.\n\nIn the following example, WindowModality attribute of Dialog window decides whether it is modal or modeless. Any one button on the dialog can be set to be default. The dialog is discarded by QDialog.reject() method when the user presses the Escape key.\n\nA PushButton on a top level QWidget window, when clicked, produces a Dialog window. A Dialog box doesnt have minimize and maximize controls on its title bar.\n\nThe user cannot relegate this dialog box in the background because its WindowModality is set to ApplicationModal.\n\nThe above code produces the following output. Click on button in main window and dialog box pops up −\n\nQMessageBox is a commonly used modal dialog to display some informational message and optionally ask the user to respond by clicking any one of the standard buttons on it. Each standard button has a predefined caption, a role and returns a predefined hexadecimal number.\n\nImportant methods and enumerations associated with QMessageBox class are given in the following table −\n\nIn the following example, click signal of the button on the top level window, the connected function displays the messagebox dialog.\n\nbuttonClicked() signal is connected to a slot function, which identifies the caption of source of the signal.\n\nThe complete code for the example is as follows −\n\nThe above code produces the following output. Message Box pops up when main windows button is clicked −\n\nIf you click on Ok or Cancel button on MessageBox, the following output is produced on the console −\n\nA typical GUI application may have multiple windows. Tabbed and stacked widgets allow to activate one such window at a time. However, many a times this approach may not be useful as view of other windows is hidden.\n\nOne way to display multiple windows simultaneously is to create them as independent windows. This is called as SDI (single Document Interface). This requires more memory resources as each window may have its own menu system, toolbar, etc.\n\nMDI (Multiple Document Interface) applications consume lesser memory resources. The sub windows are laid down inside main container with relation to each other. The container widget is called QMdiArea.\n\nQMdiArea widget generally occupies the central widget of QMainWondow object. Child windows in this area are instances of QMdiSubWindow class. It is possible to set any QWidget as the internal widget of subWindow object. Sub-windows in the MDI area can be arranged in cascaded or tile fashion.\n\nThe following table lists important methods of QMdiArea class and QMdiSubWindow class −\n\nQMdiArea object emits subWindowActivated() signal whereas windowStateChanged() signal is emitted by QMdisubWindow object.\n\nIn the following example, top level window comprising of QMainWindow has a menu and MdiArea.\n\nTriggered() signal of the menu is connected to windowaction() function.\n\nThe new action of menu adds a subwindow in MDI area with a title having an incremental number to it.\n\nCascaded and tiled buttons of the menu arrange currently displayed subwindows in cascaded and tiled fashion respectively.\n\nThe complete code is as follows −\n\nRun above code and three windows in cascased and tiled formation −\n\nThe provision of drag and drop is very intuitive for the user. It is found in many desktop applications where the user can copy or move objects from one window to another.\n\nMIME based drag and drop data transfer is based on QDrag class. QMimeData objects associate the data with their corresponding MIME type. It is stored on clipboard and then used in the drag and drop process.\n\nThe following QMimeData class functions allow the MIME type to be detected and used conveniently.\n\nMany QWidget objects support the drag and drop activity. Those that allow their data to be dragged have setDragEnabled() which must be set to true. On the other hand, the widgets should respond to the drag and drop events in order to store the data dragged into them.\n• None DragEnterEvent provides an event which is sent to the target widget as dragging action enters it.\n• None DragMoveEvent is used when the drag and drop action is in progress.\n• None DragLeaveEvent is generated as the drag and drop action leaves the widget.\n• None DropEvent, on the other hand, occurs when the drop is completed. The events proposed action can be accepted or rejected conditionally.\n\nIn the following code, the DragEnterEvent verifies whether the MIME data of the event contains text. If yes, the events proposed action is accepted and the text is added as a new item in the ComboBox.\n\nThe above code produces the following output −\n\nPyQt5 library contains QtSql module. It is an elaborate class system to communicate with many SQL based databases. Its QSqlDatabase provides access through a Connection object. Following is the list of currently available SQL drivers −\n\nFor this chapter, a connection with a SQLite database is established using the static method −\n\nOther methods of QSqlDatabase class are as follows −\n\nQSqlQuery class has the functionality to execute and manipulate SQL commands. Both DDL and DML type of SQL queries can be executed. First step is to create SQlite database using the following statements −\n\nNext, obtain Query object with QSqlQuery() method and call its most important method exec_(), which takes as an argument a string containing SQL statement to be executed.\n\nThe following script creates a SQLite database sports.db with a table of sportsperson populated with five records.\n\nTo confirm that the SQLite database is created with above records added in sportsmen table in it, use a SQLite Gui utility called SQLiteStudio.\n\nQSqlTableModel class in PyQt is a high-level interface that provides editable data model for reading and writing records in a single table. This model is used to populate a QTableView object. It presents to the user a scrollable and editable view that can be put on any top level window.\n\nA QSqlTableModel object is declared in the following manner −\n\nIts editing strategy can be set to any of the following −\n\nIn the following example, sportsperson table is used as a model and the strategy is set as −\n\nQTableView class is part of Model/View framework in PyQt. The QTableView object is created as follows −\n\nThis QTableView object and two QPushButton widgets are added to the top level QDialog window. Clicked() signal of add button is connected to addrow() which performs insertRow() on the model table.\n\nThe Slot associated with the delete button executes a lambda function that deletes a row, which is selected by the user.\n\nThe complete code is as follows −\n\nThe above code produces the following output −\n\nTry adding and deleting a few records and go back to SQLiteStudio to confirm the transactions.\n\nAll the QWidget classes in PyQt are sub classed from QPaintDevice class. A QPaintDevice is an abstraction of two dimensional space that can be drawn upon using a QPainter. Dimensions of paint device are measured in pixels starting from the top-left corner.\n\nQPainter class performs low level painting on widgets and other paintable devices such as printer. Normally, it is used in widgets paint event. The QPaintEvent occurs whenever the widgets appearance is updated.\n\nThe painter is activated by calling the begin() method, while the end() method deactivates it. In between, the desired pattern is painted by suitable methods as listed in the following table.\n\nIn the following code, various methods of PyQt's drawing methods are used.\n\nThe above code produces the following output −\n\nIn this chapter, we shall learn Brush Style Constants.\n\nGiven below are the Brush Style Constants −\n\nGiven below are the Predefined QColor Styles −\n\nGiven below are the Predefined QColor Objects −\n\nThe QClipboard class provides access to system-wide clipboard that offers a simple mechanism to copy and paste data between applications. Its action is similar to QDrag class and uses similar data types.\n\nQApplication class has a static method clipboard() which returns reference to clipboard object. Any type of MimeData can be copied to or pasted from the clipboard.\n\nFollowing are the clipboard class methods that are commonly used −\n\nSignal associated with clipboard object is −\n\nIn the following example, two TextEdit objects and two Pushbuttons are added to a top level window.\n\nTo begin with the clipboard object is instantiated. Copy() method of textedit object copies the data onto the system clipboard. When the Paste button is clicked, it fetches the clipboard data and pastes it in other textedit object.\n\nThe above code produces the following output −\n\nQPixmap class provides an off-screen representation of an image. It can be used as a QPaintDevice object or can be loaded into another widget, typically a label or button.\n\nQt API has another similar class QImage, which is optimized for I/O and other pixel manipulations. Pixmap, on the other hand, is optimized for showing it on screen. Both formats are interconvertible.\n\nThe types of image files that can be read into a QPixmap object are as follows −\n\nFollowing methods are useful in handling QPixmap object −\n\nThe most common use of QPixmap is to display image on a label/button.\n\nThe following example shows an image displayed on a QLabel by using the setPixmap() method.\n\nThe complete code is as follows −\n\nThe above code produces the following output −"
    },
    {
        "link": "https://stackoverflow.com/questions/54875522/how-to-set-custom-widget-on-qmainwindow-in-pyqt5",
        "document": "You have to understand that programming is not placing nonsensical code, for example: what did you try to do with ?, as well as the above there are several inconsistencies.\n\nOn the other hand QMainWindow is a special widget since it already has a layout:\n\nSo you must create a centralwidget where you set the layout.\n\nIf you are going to use layouts you should no longer use the geometry, move or resize methods since the layout would handle those properties.\n\nOn the other hand I think you want to make a formula where there is a description and an editor, in that case Qt provides the QFormLayout."
    },
    {
        "link": "https://dev.to/zenulabidin/python-audio-processing-at-lightspeed-part-3-pyo-30n9",
        "document": "As I promised here is Part 3 of the audio series. The library covered here is called pyo. Not only does this library aim to assist in composing music, it's also intended to be used as a backend for audio processing programs, for example Cecilia 5, PsychoPy, Soundgrain and Zyne.\n\nThis library is very large however I will only cover the basics here because it unfortunately has a nasty habit of failing to boot an audio server (see below section, and also the comments).\n\nThis library supports Python 2 as well as 3.5/6/7/8. The docs don't say whether it works on 3.8 but so far I've been using pyo on 3.8 without problems.\n\ninstalls pyo but you should also install too because Pyo has GUI functions you can take advantage of. Wxwidgets might take a long time to install because it has to compile C modules.\n\nThis example plays a 1000 Hz sine tone for 3 seconds - the \"beep\" you hear when words are censored:\n\nNote: sometimes you might get an error when running if you are using Portaudio on Linux. Sometimes I got these too and I haven't seemed to find a working solution for it. But remember this is the audio series, not every library is going to be perfect. If you have Jack installed, try using although I haven't tested this.\n\nWithout sleeping, running this snippet in a script or otherwise non-interactively won't play a sound because the script exited, and pyo sounds are stopped when the script exits. You could sleep with for as many seconds as you want to play, but another workaround would be to spawn a GUI with a button to play the sound like this:\n\nCreating the Sine object before booting the server (calling ) will raise a PyoServerStateException. The server needs to be booted before creating audio objects.\n\nAlso you may have noticed that the sine wave sounds very quiet. That is because the sine wave's gain (the parameter) was made very low. The loudness of all sounds can be controlled at once by adjusting , the gain. This example drops the gain by 20 dB:\n\nVariables should not be overwritten if you are using the GUI. If you overwrite with something else it won't play on the left channel.\n\nThe reason why we need to pass as the argument to is to allow it to make a prompt for you to type python commands in. does not return and if you Ctrl-C the terminal or quit the GUI then the whole Python process will exit. In order to make the GUI return to the python console instead you need to call it with .\n\nOne problem that I noticed with this interpreter is that you can't seem to type multi-line commands in it.\n\nI have a preference to starting the GUI instead of directly playing the sounds and that reflects in the examples I show here.\n\nSetting up your audio on Windows\n\nWindows needs special attention to make sure pyo plays audio properly. The default Windows audio host used by pyo is DirectSound, however any version of Windows since Vista should use the WSAPI host to play audio properly. So on those operating system versions, pyo needs to be configured to use WSAPI with . As stated earlier, not using the parameter defaults the server to use DirectSound which most likely won't produce the expected results unless you are using Windows XP.\n\nYou must also make sure that the sample rate used by your Windows audio device is the same as the one used by pyo, and pyo defaults to a 44100 Hz sample rate. To verify this you right-click the volume icon and click \"Playback Devices\", which should open a window like this:\n\nThen you right-click on your speakers or other audio device and select Properties which should then show you the sample rate used by the audio hardware. So if your speakers have a sample rate of 48000 Hz, you can tell pyo to launch a server with that sample rate with , and not specifying defaults to 441000.\n\nIt's not required but you can also turn on Exclusive Mode if you want which bypasses the Windows volume control and any other effects the audio driver does, and just pass whatever sound pyo makes directly to the speakers or other output device. In particular, sounds other programs make won't be heard (more information). The Priority checkbox lets pyo use the devices exclusively even if another program is using it. If you're not sure what to do here, leave both of these checkboxes alone.\n\nLast, and this applies to all operating systems, if you have a built-in sound card then you probably want to increase the buffer size to prevent glitches in audio playback, using something like (the default is 256).\n\nIncreasing the buffer size directly affects latency. Latency is determined by , so if your sound card is built-in like I just mentioned, it's going to have a small sample rate and so to avoid very small latencies which will cause samples of the sound to be skipped at playback, the buffer size must be increased. Increasing the buffer size by too much will cause samples to play very slowly and you will notice a gap between samples, so don't make the buffer size too large.\n\nAgain, pyo defaults to 44100 Hz sample rate, 32-bit float depth. 64-bit float depth can be used by importing instead of . Regarding bit depth, you shouldn't need to change it to make playback work.\n\nThere are audio objects which create a sound and are called sources. The audio objects that modify a sound are called processess, these return audio objects themselves. Processes can modify both sources and processes as you will see below. Finally audio objects are sent to a sink for output which could be a physical audio device or one of the channels of a speaker. Nearly all speakers have a left and right channel, some have more than two channels. If you have 5.1 surround then you typically have 6 channels and if you have 7.1 surround it's typically 8.\n\nAmong other sources, there is a sine wave source , a white noise source and a phase incrementor . I will have more to say about sources and processes in part 4.\n\nYou just make the audio objects you want to play and call on each of them. They will play as soon as you call or :\n\nCreating all of your pyo objects before starting playback improves performance of pyo.\n\nIt's also possible to chain the processes together. Here I pass the sine wave through four harmonizers:\n\nBy default, plays the audio object on channel 0 which is usually the left channel. To play it on all channels you have to call for each channel number. Passing a number to plays the sound on a specific channel. Usually, denotes the left channel, denotes the right channel and higher numbers denote sucessive channels, but it depends on the order your operating system numbers the channels.\n\ncan also control the delay before a sound is played and how long the sound plays. It has keyword arguments which controls the delay in seconds and , the duration in seconds. Fractions (floats) can be used in place of numbers. This example plays noise frequencies below 1000 Hz after a delay of 5 seconds for a duration of 10 seconds:\n\nAt any time, a sound can be stopped by calling its method.\n\nFinally, some audio objects don't play as soon as they are created. You need to call their method to play them and those objects will be pointed out as I cover them. All audio objects have a method that plays them, though it's usually called automatically, and an method that returns a boolean whether it is playing right now.\n\nAs if what we've seen so far wasn't good enough, pyo can also create widgets that allow you to control parameters to your audio objects while they're playing. This snippet creates GUI controls for two frequency modulators (FM) and one for the harmonics of the sine wave:\n\nIn this picture I paused the playback.\n\nIn the \"Simple additive synthesis\" control, we are able to manipulate each harmonic of the sine wave, which will result in a combined waveform with each of the sine waves of those frequency. Remember that harmonics are numbers which determine the shape of a waveform. The phase can be changed as well.\n\nAt this point it's worth noting waveforms are sometimes called signals especially in the field of signal processing.\n\npyo contains a object which creates an animated graph of the waveform that updates the graph in realtime as the waveform is played. Here is a visualization of three sine waves:\n\nAnd here is a visualization of band-limited square waves:\n\nA lot of new classes and parameters have been shown here. One of them is the parameter to an audio object. It changes the vertical offset of a waveform (audio object). There is no point in making it greater than 1 or less than -1 because only the parts of the waveform that reside between -1 and 1 will be heard. The waveform is first multiplied by the parameter and then added by the value in . Almost all audio objects have and arguments in their function signatures.\n\nThere is also a method that sqeezes the waveform between a minimum and maximum value. It's used like . This will shrink the sine wave between -0.25 and 0.5 values and it would be shown like that on the scope graph. The range minimum and maximum should be between -1 and 1.\n\nThe function takes a MIDI note number, which might be fractional, and converts it into a frequency in Hz. It can also take lists and tuples of MIDI note numbers.\n\nis a pseudo-random number generator which generates numbers beween and at frequency .\n\nmakes a fade-in and/or fade-out effect. Specifically, it makes an amplitude envelope that varies from 0 and 1. You have to explicitly call its method to start the fader.\n\nLast, there is a widget that plots the frequency of the waveform against the magnitude. Different freqencies inside the waveform have diffent sized amplitudes.\n\nThis spectrum widget has a strange looking horizontal scroll bar which can pan horizontaly into the plot range you want to see. In this spectrum, the frequency logarithm is plotted against the magnitude logarithm, filtered through a Hanning window.\n\nIf you made it this far, congratulations 🎉 this is where things start to get fun.\n\nAs stated in the pyo documentation, One of the most important thing with computer music is the trajectories taken by parameters over time. This is what gives life to the synthesized sound.\n\nAnd indeed it's very important. Good synthesized sound needs more than simple sine and square waves.\n\nEnter LFOs, low frequency oscillators. They are sounds which take a base waveform, a fundamental frequency and a sharpness (and of course and ), which is a metric of how many harmonics you want around the spectrum, higher means more harmonics. In pyo, an LFO can have one of 8 base waveforms:\n\nThe frequency you specify here is clamped between 0.00001 and the server sample rate/4.\n\nDespite its name, an LFO can represent very high fundamental frequencies (the object was actually misspelled LFO early in design phase). These LFOs are band-limited, which means none of its partials (sine waves the LFOs are made of) exceeds the Nyquist frequency, which is sample rate/2. The Nyquist frequency is the highest frequency that can be reproduced.\n\nOnce again, it's important the sample rate used by pyo is high enough so the higher harmonics don't wrap around the Nyquist frequency, producing aliasing in the waveform.\n\nLooks good, and sounds good too. 😎\n\nPyo audio objects can have more than one waveform, referred to in pyo as streams. The consequence of this is that nearly all object attributes can take list of values instead of a single value.\n\nIt is useful to mix down streams into a smaller number of streams before processing audio object, as this saves CPU cycles. This can be accomplished with the method. By default it mixes all the streams down to one stream.\n\nIt's immediately realized that having an audio object with two streams has the same effect has having a stereo channel, versus all the other audio objects we've dealt with so far which only had one stream and therefore were mono channels. A sound with two streams plays on two output channels at the same time. This has far reaching implications. It makes editing conventional stereo sound possible. Speech input can be mixed down to mono. You no longer have to call twice. In fact, an object with samples can play on channels so you can easily edit things like quadraphonic sound too.\n\nIt's safe to assume that the defining property of widely used audio processing tools is their ability to process multi-channel audio.\n\nWhen you pass lists of different lengths to different properties of the same object, the smaller lists wrap around, possibly many times, to fill the length of the longest list. But if you inspect the properties it shows the original lists.\n\nIn addition to , takes yet another parameter called which specifies a step that skips some channels and outputs to others. It's best described with an example. Assuming audio object has four streams, will output the four streams to channels 0, 2, 4 and 6 respectively (assuming your audio hardware supports at least 7 channels). That's about as precise as it gets (but see below). There is room for improvement in the way the output channels are chosen; I personally would want to use a list of channels as an argument to .\n\nIn fact, this very behavior is possible and implemented. If you pass a list to , each stream will be output to the respective channel. Just make sure that the list is the same length as the number of streams.\n\nPyo has four objects which can synthesize spectrum oscillators:\n• Blit, impulse train generator with control over the number of harmonics\n• RCosc, an RC circuit approximation (a capacitor and a resistor in series)\n\nI won't be displaying scopes or spectrums of these here since there are so many generators, but this demo lets you experiment with them. In here you can move the \"voice\" control to adjust the interpolation:\n\nPyo has two frequency modulation (FM) generators although it's simple for users to implement a custom generator.\n\nIn addition to white noise, pink noise and brown noise can be synthesized.\n\n\n\n \n\n \n\n Strange attractors (yes that's the name)\n\n\n\nThere is a special group of waveforms called strange attractors. Without getting into too much math, these attractors have fractal properties and displays chaotic behavior in the scope. Pyo has three strange attractors, Rossler, Lorenz and ChanLee, all of which support generating a stereo waveform.\n\nThe strange attractors can also be used to make LFOs. In that case the frequency of the LFE is a strange attractor object.\n\nTo wrap up this section I will show you generators that create random numbers which can then be used for such things like frequencies and parameters to and . These generators can take a list of frequency values which causes the generator to return that many random numbers.\n\nwill choose a random MIDI note from a list of notes (or list of lists of notes, which will trigger list expansion) at the given frequencies. makes a floating point number between a minimum and maximum value at the given frequencies. The \"i\" and Randi stands for interpolation. interpolates between old and new values. makes a random integer between 0 and a maximum number (exclusive) at the given frequencies. All of these take and parameters.\n\nThe large number of examples shows you that pyo is an advanced library but further discussion was spoiled because of the audio server problems which prevented me from doing anything with pyo. It's a shame, because it had a lot of other classes I didn't get to write about here. In the next part I will look at another library which hopefully doesn't contain these kind of errors.\n\nSometimes it takes just one bug to break the user experience."
    },
    {
        "link": "http://olivier.ajaxsoundstudio.com/pdfs/belanger_pyo_acmmm2016.pdf",
        "document": ""
    },
    {
        "link": "https://belangeo.github.io/pyo",
        "document": "Welcome to the pyo 1.0.6 documentation¶\n\nPyo is a Python module written in C to help digital signal processing script creation. It provides a complete set of classes to build audio softwares, compose algorithmic musics or simply explore audio processing with a simple, mature and powerful programming language."
    },
    {
        "link": "https://github.com/belangeo/pyo",
        "document": "pyo is a Python module written in C to help digital signal processing script creation.\n\npyo is a Python module containing classes for a wide variety of audio signal processing types. With pyo, user will be able to include signal processing chains directly in Python scripts or projects, and to manipulate them in real time through the interpreter. Tools in pyo module offer primitives, like mathematical operations on audio signal, basic signal processing (filters, delays, synthesis generators, etc.), but also complex algorithms to create sound granulation and others creative audio manipulations. pyo supports OSC protocol (Open Sound Control), to ease communications between softwares, and MIDI protocol, for generating sound events and controlling process parameters. pyo allows creation of sophisticated signal processing chains with all the benefits of a mature, and widely used, general programming language.\n\nFor more information and documentation, visit the PYO DOCUMENTATION.\n\nHow to install pre-built packages on any platform using pip: INSTALL Instructions.\n\nHow to get pyo running from sources on macOS and linux: COMPILE Instructions.\n\npyo was awarded second prize in the Lomus 2012 Free Software Competition.\n\nYou want to help the development of pyo ? Go to the pyo features market and make a donation for the feature you want to promote. You can also submit new features on the mailing-list ( https://github.com/belangeo/pyo/discussions ).\n\nIf you want to listen to scripts rendered in real-time, just connect to Radio Pyo !\n\nYou want to have your script played on the radio ? Download the template radiopyo_template.py, follow the rules and post it on the mailing-list !\n\nPsychoPy : An open-source application to allow the presentation of stimuli and collection of data for a wide range of neuroscience, psychology and psychophysics experiments.\n\nSoundgrain : A graphical interface where users can draw and edit trajectories to control granular sound synthesis.\n\nPyo Synth : Pyo Synth is an open source application that makes the manipulation of pyo scripts easier by letting you control it with a midi keyboard.\n\npyo is fully integrated to Python and very simple to use.\n\nThis project is developed by Olivier Bélanger on his free time to provide a fully integrated Python dsp module for sound exploration and music composition. If you feel this project is useful to you and want to support it and it's future development please consider donating money. I only ask for a small donation, but of course I appreciate any amount."
    },
    {
        "link": "https://stackoverflow.com/questions/61576953/generating-a-sine-wave-sound-in-python",
        "document": "the audio buffer must be packed into binary, for python3 use also simplified the sin curve synthesis by moving the angle theta increment constant to outside of the loop\n\nabove python executes just fine on my Ubuntu laptop across various release including ubuntu 20.04 ... however below is output to terminal when I run above code ... just ignore below messages sadly those are normal"
    }
]