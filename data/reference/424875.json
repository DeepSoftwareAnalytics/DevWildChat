[
    {
        "link": "https://stackoverflow.com/questions/17507416/rspec-doesnt-see-my-model-class-uninitialized-constant-error",
        "document": "I'm writing tests on Rspec for my models in Ruby on Rails application. And I receive this error while starting 'rspec spec'\n\nHere is my client_spec.rb:\n\nAnd at last client.rb (ROR Model and Class):\n\nIf it'd be useful my spec_helper.rb file:"
    },
    {
        "link": "https://stackoverflow.com/questions/19692297/rspec-testing-throws-uninitialized-constant-rails-nameerror",
        "document": "Please forgive any shortcomings in this (my first-ever) post on StackOverflow. I'm brand new to Ruby on Rails. I'm following the Rails Tutorial. I have spent many unsuccessful hours consulting other threads discussing the same Name Error that I'm raising in this question.\n\nAny attempt of mine to run an rspec test like so: $bundle exec rspec spec/models/user_spec.rb throws the now infamous error: `': uninitialized constant Rails (NameError)\n\nLet me know if there's any more information I should provide you in order to get the ball rolling.\n\nHere is my spec/models/user_spec.rb file:\n\nHere is my app/models/user.rb file:\n\n class User < ActiveRecord::Base end\n\nHere is my spec_helper.rb file:\n\nI have definitely run bundle install. I can also confirm that I've already created the database and run the migration (db/test.sqlite3 already exists)"
    },
    {
        "link": "https://github.com/rswag/rswag/issues/553",
        "document": "Currently working on a rails engine that exposes some functions via an API. Chose to use this gem to generate the API documentation that will be hosted somewhere. However, even with following the instructions on the readme, I'm still encountering errors.\n\nAccording to the rails engine documentation, dependencies are supposed to be added in the engine_name.gemspec file as opposed to in the Gemfile. So I added the following:\n\nUpon running the install generator: , that's when the error comes in.\n\nThe rswag_api.rb file is generated and added to config/initializers and the engine is mounted in my routes:\n\n\n\nHowever, it seems that Rswag::Api is not being recognized, hence the generator cannot proceed - as the related Rswag::Ui file is fails to be generated."
    },
    {
        "link": "https://rollbar.com/blog/ruby-nameerror",
        "document": "A is raised when a referenced variable or a constant, such as a module, a class, or a constant variable, isn't defined or is invalid. The error is a variation of the exception class and has several reasons to occur.\n\nWhen this error occurs, several class names appear in place of .\n\nWhat causes an Uninitialized Constant Error?\n\nLet’s look at the most common reasons why occurs:\n• Whenever a class or module is referred to in code that can't be found, this error occurs. This often happens because the method is missing, which is used to load another file and import all classes and method definitions from that file.\n• Methods and variables in Ruby start with lowercase letters, whereas class names begin with uppercase letters. So in the code, if this distinction is missing, we'll get an exception.\n• Ruby is case-sensitive, so if there is any typo in the code, this error pops up. One small example of that is: When the above code is executed, we get the following output:\n• If the code contains , which all new versions of Ruby disapprove of.\n\nLet’s examine and analyze one of the causes of errors. This one occurs when the configuration of the class file containing the method being called is not loaded into the Rails console or the server when started. Let's say a file with the name has been created in the folder of the Rails project.\n\nNow, we start the Rails console and use the below command line to call the function :\n\nWe get the following error:\n\nHere, is the class name. This error shows that the was not loaded when the Rails console was started.\n\nTo resolve this error, we have to load our class into the environment, and to do so, we have to add the following to the file of the Rails project:\n\nBy adding this line, we are setting for the file, because of which all the Ruby files that are present inside the folder will get automatically loaded whenever the Rails console or server is started.\n\nWhen we execute the same command in the console after adding the line, we get the correct output:\n\nLooking into the error makes it clear that the majority of reasons may be resolved by carefully reviewing the code to check for typographical errors or by making modifications to the file's source code.\n\nManaging errors and exceptions in your code is challenging. It can make deploying production code an unnerving experience. Being able to track, analyze, and manage errors in real-time can help you proceed with more confidence. Rollbar automates error monitoring and triaging, making fixing Ruby on Rails errors easier than ever. Try it today!"
    },
    {
        "link": "http://fuzzyblog.io/blog/rails/2019/07/10/rspec-uninitialized-constant-errors-on-model-tests.html",
        "document": "This one is an easy one but still tripped me up. I'm working on a project where generators on RSpec stub files are turned off (don't ask; disagreement about the utility of generators between two senior engineers and I lost) and I just got this error:\n\nAnd the error turned out to be that this line was missing:\n\nThat line is normally inserted by the generator but I built this spec file from scratch and just missed it. I've stared at that line a thousand, thousand times over the years but I suspect I never realized that what it did was tell RSpec something like this:\n\n\"Read the Rails directory structure and autoload all classes in the directories below /app\". Doh!"
    },
    {
        "link": "https://toptal.com/ruby-on-rails/rails-service-objects-tutorial",
        "document": "Ruby on Rails ships with everything you need to prototype your application quickly, but when your codebase starts growing, you’ll run into scenarios where the conventional Fat Model, Skinny Controller mantra breaks. When your business logic can’t fit into either a model or a controller, that’s when service objects come in and let us separate every business action into its own Ruby object.\n\nIn this article, I’ll explain when a service object is required; how to go about writing clean service objects and grouping them together for contributor sanity; the strict rules I impose on my service objects to tie them directly to my business logic; and how not to turn your service objects into a dumping ground for all the code you don’t know what to do with.\n\nWhy Do I Need Service Objects?\n\nTry this: What do you do when your application needs to tweet the text from ?\n\nIf you’ve been using vanilla Rails so far, then you’ve probably done something like this:\n\nThe problem here is that you’ve added at least ten lines to your controller, but they don’t really belong there. Also, what if you wanted to use the same functionality in another controller? Do you move this to a concern? Wait, but this code doesn’t really belong in controllers at all. Why can’t the Twitter API just come with a single prepared object for me to call?\n\nThe first time I did this, I felt like I’d done something dirty. My, previously, beautifully lean Rails controllers had started getting fat and I didn’t know what to do. Eventually, I fixed my controller with a service object.\n\nBefore you start reading this article, let’s pretend:\n• The Rails Way means “the conventional Ruby on Rails way of doing things” and the book doesn’t exist.\n• I’m a Rails expert… which I’m told every day that I am, but I have trouble believing it, so let’s just pretend that I really am one.\n\nService objects are Plain Old Ruby Objects (PORO) that are designed to execute one single action in your domain logic and do it well. Consider the example above: Our method already has the logic to do one single thing, and that is to create a tweet. What if this logic was encapsulated within a single Ruby class that we can instantiate and call a method to? Something like:\n\nThis is pretty much it; our service object, once created, can be called from anywhere, and it would do this one thing very well.\n\nFirst let’s create a new in a new folder called :\n\nAnd let’s just dump all our logic inside a new Ruby class:\n\nThen you can call anywhere in your app, and it will work. Rails will load this object magically because it autoloads everything under . Verify this by running:\n\nWant to know more about how works? Read the Autoloading and Reloading Constants Guide.\n\nLook, this feels great in theory, but is just a mouthful. It’s far too verbose with redundant words… much like HTML (ba-dum tiss!). In all seriousness, though, why do people use HTML when HAML is around? Or even Slim. I guess that’s another article for another time. Back to the task at hand:\n\nis a nice short class name, but the extra cruft around instantiating the object and calling the method is just too long! If only there were precedence in Ruby for calling something and having it execute itself immediately with the given parameters… oh wait, there is! It’s .\n\nIf this confuses you, let me explain. A can be -ed to execute itself with the given parameters. Which means, that if were a , we could call it with and the result would be equivalent to , which looks quite similar to our unwieldy old .\n\nSo let’s make our service object behave more like a !\n\nFirst, because we probably want to reuse this behavior across all our service objects, let’s borrow from the Rails Way and create a class called :\n\nDid you see what I did there? I added a class method called that creates a new instance of the class with the arguments or block you pass to it, and calls on the instance. Exactly what we we wanted! The last thing to do is to rename the method from our class to , and have the class inherit from :\n\nAnd finally, let’s wrap this up by calling our service object in the controller:\n\nThe example above has only one service object, but in the real world, things can get more complicated. For example, what if you had hundreds of services, and half of them were related business actions, e.g., having a service that followed another Twitter account? Honestly, I’d go insane if a folder contained 200 unique-looking files, so good thing there’s another pattern from the Rails Way that we can copy—I mean, use as inspiration: namespacing.\n\nLet’s pretend we’ve been tasked to create a service object that follows other Twitter profiles.\n\nLet’s look at the name of our previous service object: . It sounds like a person, or at the very least, a role in an organization. Someone that creates Tweets. I like to name my service objects as if they were just that: roles in an organization. Following this convention, I’ll call my new object: .\n\nNow, since I’m the supreme overlord of this app, I’m going to create a managerial position in my service hierarchy and delegate responsibility for both these services to that position. I’ll call this new managerial position .\n\nSince this manager does nothing but manage, let’s make it a module and nest our service objects under this module. Our folder structure will now look like:\n\nAnd our calls will now become , and .\n\nThe example above made API calls, but service objects can also be used when all the calls are to your database instead of an API. This is especially helpful if some business actions require multiple database updates wrapped in a transaction. For example, this sample code would use services to record a currency exchange taking place.\n\nWhat Do I Return from My Service Object?\n\nWe’ve discussed how to our service object, but what should the object return? There are three ways to approach this:\n\nThis one is simple: If an action works as intended, return ; otherwise, return :\n\nIf your service object fetches data from somewhere, you probably want to return that value:\n\nIf your service object is a bit more complex, and you want to handle different scenarios, you could just add enums to control the flow of your services:\n\nAnd then in your app, you can use:\n\nShouldn’t I Put Service Objects in Instead of ?\n\nThis is subjective. People’s opinions differ on where to put their service objects. Some people put them in , while some create . I fall in the latter camp. Rails’ Getting Started Guide describes the folder as the place to put “extended modules for your application.”\n\nIn my humble opinion, “extended modules” means modules that don’t encapsulate core domain logic and can generally be used across projects. In the wise words of a random Stack Overflow answer, put code in there that “can potentially become its own gem.”\n\nIt depends on your use case. Look—the fact that you’re reading this article right now suggests you’re trying to write code that doesn’t exactly belong in a model or controller. I recently read this article about how service objects are an anti-pattern. The author has his opinions, but I respectfully disagree.\n\nJust because some other person overused service objects doesn’t mean they’re inherently bad. At my startup, Nazdeeq, we use service objects as well as non-ActiveRecord models. But the difference between what goes where has always been apparent to me: I keep all business actions in service objects while keeping resources that don’t really need persistence in non-ActiveRecord models. At the end of the day, it’s for you to decide what pattern is good for you.\n\nHowever, do I think service objects in general are a good idea? Absolutely! They keep my code neatly organized, and what makes me confident in my use of POROs is that Ruby loves objects. No, seriously, Ruby loves objects. It’s insane, totally bonkers, but I love it! Case in point:\n\nSee? is literally an object.\n\nWhen Should I Not Use a Service Object?\n\nThis one’s easy. I have these rules:\n• Does your code handle routing, params or do other controller-y things?\n\n If so, don’t use a service object—your code belongs in the controller.\n• Are you trying to share your code in different controllers?\n\n In this case, don’t use a service object—use a concern.\n• Is your code like a model that doesn’t need persistence?\n\n If so, don’t use a service object. Use a non-ActiveRecord model instead.\n• Is your code a specific business action? (e.g., “Take out the trash,” “Generate a PDF using this text,” or “Calculate the customs duty using these complicated rules”)\n\n In this case, use a service object. That code probably doesn’t logically fit in either your controller or your model.\n\nOf course, these are my rules, so you’re welcome to adapt them to your own use cases. These have worked very well for me, but your mileage may vary.\n\nI have a four rules for creating service objects. These aren’t written in stone, and if you really want to break them, you can, but I will probably ask you to change it in code reviews unless your reasoning is sound.\n\nRule 1: Only One Public Method per Service Object\n\nService objects are single business actions. You can change the name of your public method if you like. I prefer using , but Gitlab CE’s codebase calls it and other people may use . Use whatever you want—you could call it for all I care. Just don’t create two public methods for a single service object. Break it into two objects if you need to.\n\nRule 2: Name Service Objects Like Dumb Roles at a Company\n\nService objects are single business actions. Imagine if you hired one person at the company to do that one job, what would you call them? If their job is to create tweets, call them . If their job is to read specific tweets, call them .\n\nService objects are single business actions. I broke the functionality into two pieces: , and . What I didn’t do is create a single generic object called and dump all of the API functionality in there. Please don’t do this. This goes against the “business action” mindset and makes the service object look like the Twitter Fairy. If you want to share code among the business objects, just create a object or module and mix that into your service objects.\n\nFor the umpteenth time: Service objects are single business actions. I can’t say this enough. If you’ve got a person that reads tweets, they’ll either give you the tweet, or say, “This tweet doesn’t exist.” Similarly, don’t let your service object panic, jump on your controller’s desk, and tell it to halt all work because “Error!” Just return and let the controller move on from there.\n\nThis article wouldn’t have been possible without the amazing community of Ruby developers at Toptal. If I ever run into a problem, the community is the most helpful group of talented engineers I’ve ever met.\n\nIf you’re using service objects, you may find yourself wondering how to force certain answers while testing. I recommend reading this article on how to create mock service objects in Rspec that will always return the result you want, without actually hitting the service object!\n\nIf you want to learn more about Ruby tricks, I recommend Creating a Ruby DSL: A Guide to Advanced Metaprogramming by fellow Toptaler Máté Solymosi. He breaks down how the file doesn’t feel like Ruby and helps you build your own DSL."
    },
    {
        "link": "https://medium.com/nyc-ruby-on-rails/design-patterns-in-ruby-on-rails-service-objects-a90bf9178689",
        "document": "Welcome to our guide on Ruby on Rails service objects, a cornerstone of efficient and organized code. This article delves into service objects, vital for optimizing Ruby on Rails applications. They encapsulate business logic and operations, streamlining tasks and boosting maintainability. Whether you’re experienced or new to Rails, this guide will help you master service objects, enhancing your development process.\n\nIn Rails, a Service Object is a Ruby class designed to handle business logic that doesn’t fit into models, controllers, or helpers. It typically contains a single public method for a specific task, organizing operations, validations, or calculations. This pattern aims to maintain code organization and testability.\n\nService Objects in Rails applications handle various tasks like payment processing, email sending, file uploads, or data manipulation from external APIs. By segregating these tasks, Service Objects ensure clean models and controllers, facilitate testing, and promote reusability. To implement a Service Object, create a new class in the app/services directory, defining a public method for the required functionality.\n\nHere’s an example of a simple Service Object in Rails:\n\nIn this example, the Service Object takes a name and email as arguments and creates a new object with those attributes. If the user is successfully saved to the database, it sends a welcome email using a object and returns the newly created user. If the save fails, it returns .\n\nTo use this Service Object in a controller, you can simply call the method:\n\nIn this example, the calls the Service Object to create a new user with the parameters passed in the request. If the user is successfully created, it redirects to the user's show page. Otherwise, it renders the new user form again.\n\nWhen should you use Service Objects?\n\nService Objects should be used when the business logic of an application can’t be easily encapsulated within a model or controller, or when it requires additional processing beyond the basic CRUD operations. Here are some scenarios when you might consider using Service Objects:\n\nIf you have a complex process that involves multiple models or external APIs, it may be difficult to encapsulate that logic within a model or controller. In this case, you can create a Service Object that encapsulates the complex process and makes it more manageable.\n\nIf you have complex business rules that need to be enforced across multiple models or controllers, you can create a Service Object that encapsulates those rules and ensures they are enforced consistently throughout the application.\n\nIf you need to integrate with a third-party API, you can create a Service Object that encapsulates the integration logic and provides a clean interface for the rest of the application to use.\n\nIf you need to perform a long-running or resource-intensive task, you can create a Service Object that runs the task in the background and provides progress updates to the user.\n\nIf you have a piece of logic that is used in multiple parts of the application, you can create a Service Object that encapsulates that logic and makes it easy to reuse.\n\nIn general, if you find yourself writing complex, non-CRUD logic in your models or controllers, or if you’re having trouble testing that logic, it may be a good idea to consider using a Service Object. By encapsulating your business logic in a separate object, you can make your code more modular, easier to test, and easier to maintain over time.\n\nWhen Should You NOT Use Service Objects?\n\nWhile Service Objects can be useful in many situations, there are also cases where they may not be the best solution. Here are some scenarios where you might consider not using Service Objects:\n\nIf your application’s business logic consists mainly of simple CRUD operations (Create, Read, Update, Delete), it may not be necessary to use Service Objects. These operations can usually be handled directly by the model or controller.\n\nIf your controllers are already lightweight and only contain basic CRUD actions, it may not be necessary to use Service Objects. In this case, the business logic can often be handled directly by the model or a helper.\n\nIf the Service Object pattern is used excessively, it can lead to over-engineering and unnecessary complexity in the application. If the logic can be easily handled within the model or controller without adding significant complexity, it may be better to keep it there.\n\nIf performance is not a major concern, it may not be necessary to use Service Objects. In some cases, the added overhead of creating a new object and calling a method may outweigh the benefits of encapsulating the logic.\n\nIf the Service Object is used to perform tasks that should be handled by another part of the application, it may be a sign of a lack of separation of concerns. For example, if the Service Object is used to send email notifications, it may be better to use a mailer instead.\n\nIn general, it’s important to consider the complexity and maintainability of your application when deciding whether or not to use Service Objects. If the logic is simple and can be handled directly by the model or controller, it may not be necessary to use a Service Object. However, if the logic is complex, hard to test, or needs to be reused in multiple parts of the application, a Service Object can be a useful tool to encapsulate that logic and make it more manageable.\n\nIn Ruby on Rails development, service objects are crucial for enhancing code efficiency and maintainability. This article delves into their role in improving application development by encapsulating complex business logic, thus promoting code organization, modularity, and testability. These objects handle diverse tasks like complex data processing and third-party API integration, boosting productivity and reducing redundancy.\n\nHowever, their use should be balanced, especially in simpler CRUD operations where models or controllers suffice, to avoid over-engineering. Properly implemented, service objects can significantly improve the efficiency, scalability, and maintenance of Ruby on Rails applications, making them a valuable tool for developers."
    },
    {
        "link": "https://medium.com/@thilorusche/service-objects-for-rails-9c5973dc8bc2",
        "document": "I’ve been re-reading “ Sustainable Web Development with Ruby on Rails ” by David Bryan Copeland, an in-depth guide to real-world Rails development I cannot recommend enough. While every re-read surfaces some new ways in which to improve our code base, at SportsKey we have been using service objects to isolate our business logic for quite some time. I’d like to share how we do it, and what I consider the benefits of this approach.\n\nWhere, oh where does it go?\n\nWhere and how to implement the business logic in a Rails application has been hotly debated over the years. First we got fat controllers as an anti-pattern, with the fat models, skinny controllers philosophy as the solution. When our models got too bloated with multiple responsibilities, it became fashionable to extract logic into concerns, which in my opinion doesn’t accomplish much more than spreading logic into separate files that *still* bloat models at runtime, and make it much harder to easily understand the capabilities of a class.\n\nThen service objects became the way to go. But even those seem to be getting a bad rap these days. I don’t think that’s warranted, and at SportsKey, we’re sticking with service objects (or whatever you wish to call them) for encapsulating and isolating our business logic.\n\nThere are gems and whole sub-frameworks out there that aim to solve the problem of implementing business logic, most notably trailblazer. However, after several years of enthusiastically embracing such addons and then painfully ripping them out again, I am of the firm belief that service objects should not add another layer of complexity or semi-understood third-party magic to your codebase.\n\nThere’s really not much involved in rolling your own service objects, and the considerable upside is that you understand everything going on under the hood. You don’t need that level of understanding of, for example, how request parameters are parsed — by all means let Rails handle that for you, and trust that it Just Works™️. Business logic is a different beast altogether — there’s no convention over configuration here to hold your hand, nor can you stand on the shoulder of a thousand apps that came before you and had to do the same thing.\n\nSo how do we structure and use service objects then?\n\nLet’s take it from the top — here’s a typical example of how we might call a service in a controller action. I’m omitting our use of form objects, authorization checks, I18n, namespacing and some other niceties for clarity. None of them make the average controller method much fatter than this.\n\nThis example shows a few basic conventions for our controller methods:\n• No more than a single flow control statement\n• One and only one data processing call — usually to a service object, unless the processing is as trivial as calling on a model of form object\n• No more than one assignment (plus a flash message if warranted)\n• No more than one redirect\n\nSo it’s basically: parse and validate input, delegate processing, output based on the result. That’s all controllers should do in MVC, and it ensures they stay as skinny as possible.\n\nBy convention, our services assume that their primary arguments have been validated beforehand. Validation can be complex, and we actually handle those with form objects using dry-validation, which I’ve omitted from the example because it’s not really relevant here.\n\nOf course, validation also implements some requirements of the business domain, as does authorization. So strictly speaking, our use of service objects implements our business *processes* only, and the totality of business logic is distributed across two additional areas — form objects and access policies. But all three have well-defined boundaries and quite different responsibilities, which makes this approach highly flexible.\n\nThese conventions allow us to call our services with the bang! version and treating anything going wrong as an actual exception (i.e. the payment API is down) rather than a run-of-the-mill error that might happen under normal circumstances (such as a card declined error, which in this example would have been caught by the frontend, in most scenarios).\n\nFor us at SportsKey, making a booking and processing the associated payment involves a lot of steps and some complex validation, decision making and error handling. Many, many commercial Rails applications process orders and payments, and every single one of them will do it slightly differently, according to the needs and requirements of their business. That’s why there are no built-in Rails conventions for this stuff — it’s simply not possible or even desirable to standardize any of it.\n\nLet’s take a look under the hood\n\nHere’s how we might implement the service for processing a booking with a payment. (Or rather, a reference to a pre-authorized payment — we don’t handle credit card data ourselves, ever. Stripe does that for us.) This is a made-up example, but it accurately reflects our conventions:\n\nThis class does a lot, but that’s the nature of business logic — it’s complex but usually quite sequential. It also doesn’t look very ruby-like — it’s not neatly object-oriented code. It’s not SOLID! It looks rather… procedural, doesn’t it? This is fully intentional.\n\nNo matter what the cool kids say, a procedural style of coding has its place even in an object-oriented or functional language, and naturally sequential steps like these are prime candidates. Just by glancing at the only public method of this service object, anyone who has never seen this code before can quickly understand *what it does*. Not how, but what. It reflects the actual business domain. In fact, our sales team could probably understand what it does.\n\nTo me, that’s the secret sauce to finding your way around the business logic part of a Rails application. As a developer unfamiliar with our code base, you may have seen a dozen other Rails apps before, and know your way around controllers, views, models and even helpers blindfolded in the dark, thanks to the ubiquitous and well-established Rails conventions. But you’ve never seen our business logic before. That’s our unique snowflake, and being able to get the gist of it at a glance is extremely valuable.\n\nA nice side effect of using service objects like this is the ability to nest them. Over time, we’ve encapsulated most processes this way, and the private methods become pretty trivial:\n\nIn fact, at this point, these tiny methods become just another pointless indirection, and can just be ditched in favor of calling the other services directly:\n\nMaybe no longer as readable to our sales team, but still :)\n\nThis makes our whole suite of domain logic both easily testable and reusable in different contexts. In other words, highly composable. After a while, implementing new logic becomes just a game of Lego.\n\nBut wait, there’s still some magic in there\n\nRight. What’s this we’re inheriting from here? Glad you asked. This is the base class for our services in all its g̶l̶o̶r̶y simplicity:\n\nIt allows use to invoke a service with a bang!, raising exceptions if they occur, or without one, which will always return a simple and well-defined result object which can be checked for success for failure, as well as a payload and or error if we need to process the result further.\n\nThis implementation also provides some syntactic sugar for invoking services via a class method instead of the slightly longer way of calling an instance method on an actual object, i.e. instead of . We could even just use ruby's dot-parentheses shorthand for the non-bang version if we wanted to, but I’m not a fan of that — I like the expressiveness of the slightly more verbose version.\n\nJust let it flow\n\nSpeaking of the non-bang version, its primary use is to handle commonly encountered failures that are not really exceptions. Using exceptions for flow control is an anti-pattern. A typical use case for the non-bang version might look like this:\n\nBut ultimately, if you validate input as a separate step before processing, like we do with form objects, anything going wrong inside a service object is in all likelihood an actual exception worth investigating, and should raise an error notification to your dev team. (Handling this exception gracefully in the UI so your users don’t see a standard 500 error is another matter.) So we use the bang! version by default.\n\nSo this is how we do it, and it’s served us well. Of course it’s not the only way, nor necessarily the best, it’s just what works for us, at our particular scale (which is small-ish, in the grand scheme of things).\n\nWhat works for you? Share your thoughts in the comments!"
    },
    {
        "link": "https://reddit.com/r/rails/comments/2enurh/what_are_the_best_practices_for_rails_testing",
        "document": "Ok, so I neglected testing for my simple rails apps. I often skipped them or written only couple methods. But I want to change this and learn more on the subject.\n\nWhat are the current best practices for testing Rails apps? I see that there are many approaches, TestUnit, RSpec, Cucumber... Can't decide which way I should go... ;-)\n\nCan you also recommend some good resources to learn BDD/TDD approach? I think I'll start with https://pragprog.com/book/achbd/the-rspec-book but if you have any suggestions, I would be grateful to hear them!\n\nUpdate: Thank you all for the valuable feedback!"
    },
    {
        "link": "https://forum.upcase.com/t/how-do-you-test-service-classes-in-rails/2702",
        "document": "I prefer to test my classes in isolation, so I’d go with the approach you described in your first bullet. However, rather than referencing specific class names and stubbing class objects, I’d instead inject the dependencies like this: Then, in my tests, I’d pass in doubles and assert that they received the right messages.\n\nPutting those arguments in a hash is totally fine, and probably better than having them as positional arguments. However, I think this is a classic case of treating the symptom rather than the cause. A class that needs 4 collaborators would almost certainly benefit from being split up. Even 3 raises my code-smell sense.\n\nFollowing on from @benorenstein’s point, possibly using some observers would split up the responsibilities of . The method could simply publish a topic that says “Hey, whoever is listening, I’ve signed this guy up!”. You’d then have listeners that would do your “Secret thing” and another that would log the successful signup. You could try the new Wisper gem which looks like a good choice. Here’s a quick lightning talk about it\n\nThank you @benorenstein and @aaronmcadam, most probably, I’m just not structuring the app correctly. I’m not sure though how you can lessen the number of collaborators. Let’s say hypothetically, when a user signs up to myapp.com via Github, we\n• Ask Resque/Delayed Job to queue saving the user’s avatar\n• Save the user’s repos to the database How would you split this class?\n\nbecause I end up with code in random places… if I’m just going to use a callback once I’ll usually just inline the method call One of the tradeoffs of OO is indirection and not being able to see a full procedure in one place. What we get in return is more maintainable and changeable objects. This video does a great job of summing up that idea. I also refer to the legend that is Sandi Metz on SOLID principles."
    }
]