[
    {
        "link": "https://dev.epicgames.com/documentation/en-us/unreal-engine/garbage-collection-settings-in-the-unreal-engine-project-settings",
        "document": "Maximum Number of UObjects that Can Exist in Cooked Game Maximum number of UObjects that can exist in the cooked game. Keep this as small as possible.\n\nMaximum Number of UObjects that Can Exist in the Editor Game Maximum number of objects that can exist in the editor game. Make sure this can hold enough objects for the editor and commandlets within a reasonable limit."
    },
    {
        "link": "https://dev.epicgames.com/documentation/en-us/unreal-engine/unreal-object-handling-in-unreal-engine",
        "document": "Marking classes, properties, and functions with the appropriate macros turns them into , , and . This gives Unreal Engine access to them, which allows for a number of under-the-hood handling features to be implemented.\n\nare automatically zeroed on initialization, before the constructor is called. This happens for the whole class, and native members alike. Members can subsequently be initialized with custom values in the class constructor.\n\nWhen an or is destroyed or otherwise removed from play, all references to it that are visible to the reflection system ( pointers and pointers stored in Unreal Engine container classes such as ) are automatically nulled. This is beneficial in that it prevents dangling pointers from persisting and causing trouble down the road, but it also means that and pointers can become null if some other piece of code destroys them. The ultimate advantage of this is that null-checking is more reliable, as it detects both standard-case null pointers and cases where a non-null pointer would have been pointing at deleted memory.\n\nIt is important to realize that this feature applies only to or references marked with or stored in an Unreal Engine container class. An Object reference stored in a raw pointer will be unknown to the Unreal Engine, and will not be automatically nulled, nor will it prevent garbage collection. Note this does not mean that all variables must be . If you want an Object pointer that is not a , consider using . This is a \"weak\" pointer, meaning it will not prevent garbage collection, but it can be queried for validity before being accessed and will be set to null if the Object it points to is destroyed.\n\nAnother case where a referenced UObject UProperty will be automatically null'ed is when using 'Force Delete' on an asset in the editor. As a result, all code operating on UObjects which are assets must handle these pointers becoming null.\n\nWhen a is serialized, all values are automatically written or read unless explicitly marked as \"transient\" or unchanged from the post-constructor default value. For example, you could place an instance in a level, set its Health to 500, save it and successfully reload it without writing a single line of code beyond the definition.\n\nWhen UProperties are added or removed, loading pre-existing content is handled seamlessly. New properties get default values copied from the new CDO. Removed properties are silently ignored.\n\nIf custom behavior is required, the function can be overridden. This can be useful to detect data errors, check version numbers, or perform automatic conversions or updates if the data format has changed.\n\nWhen the Class Default Object (or CDO) of a has changed, the engine will try to apply those changes to all instances of the class when they are loaded. For a given Object instance, if the updated variable's value matches the value in the old CDO, it will be updated to the value it holds in the new CDO. If the variable has any other value, the assumption is that the value was set intentionally, and those changes will be preserved.\n\nAs an example, let us say you saved a level with several of your Objects placed in it, and you had set the default Health value in the constructor to 100. Let us also assume you set the health for Enemy_3 to 500, because they are particularly tough. Now imagine you changed your mind and increased the default value of Health to 150. When you next load your level, Unreal will realize you have changed the CDO and will update all instances of with the old default Health value (100) to have a Health value of 150. Enemy_3's Health will remain at 500 because it wasn't using the old default value.\n\nand are understood by the Editor, and the Editor can expose these values automatically for editing without the need to write special code. This can optionally include integration into the Blueprint visual scripting system. There are many options to control the accessibility and exposure of variables and functions.\n\nBecause are part of the Unreal Engine's reflection system, they always know what they are, and type-related decisions and casts can be made at runtime.\n\nIn native code, every class has a custom typedef set to its parent class, which allows easy control of overriding behavior. As an example:\n\nAs you can see, calling will result in the MegaBoss saying \"Powering up! Time to fight!\".\n\nAlso, you can safely cast an Object from a base class to a more derived class using the templated Cast function, or query if an Object is of a particular class using . A quick example follows:\n\nHere we have used to attempt to cast the to an . If the Object in question is not actually an (or a child class thereof), the cast will return a null pointer and we can react appropriately. In the code above, the function will only be called against the MegaBoss.\n\nUnreal implements a garbage collection scheme whereby that are no longer referenced or have been explicitly flagged for destruction will be cleaned up at regular intervals. The engine builds a reference graph to determine which are still in use and which ones are orphaned. At the root of this graph is a set of designated as the \"root set\". Any can be added to the root set. When garbage collection occurs, the engine can track all referenced by searching the tree of known references, starting from the root set. Any unreferenced , meaning those which are not found in the tree search, will be assumed to be unneeded, and will be removed.\n\nOne practical implication here is that you typically need to maintain a reference to any Object you wish to keep alive, whether it's a simple Object pointer or an Unreal Engine container class that contains Object pointer types, such as . Actors and their Components are frequently an exception to this, since the Actors are usually referenced by an Object that links back to the root set, such as the Level to which they belong, and the Actor's Components are referenced by the Actor itself. Actors can be explicitly marked for destruction by calling their function, which is the standard way to remove an Actor from an in-progress game. Components can be destroyed explicitly with the function, but they are usually destroyed when their owning Actor is removed from the game.\n\nGarbage collection in Unreal Engine 4 is fast and efficient, and has a number of built-in features designed to minimize overhead, such as multithreaded reachability analysis to identify orphaned Objects, and unhashing code optimized to remove Actors from containers as quickly as possible. There are other features that can be adjusted to gain more precise control over how and when garbage collection is performed, most of which are found in Project Settings under Engine - Garbage Collection. The following settings are commonly used to tune garbage collector performance for a project:\n\nThe system includes a robust set of functionality to facilitate network communication and multiplayer games.\n\ncan be tagged to tell the Engine to replicate their data during network play. A common model here is that a variable gets changed on the server, and the Engine then detects this change and sends it reliably to all clients. Clients can optionally receive a callback function when the variable changes from replication.\n\ncan also be tagged to execute on a remote machine. A \"server\" function, for example, when called on a client machine, will cause the function to execute on the server machine for the server's version of the Actor. A \"client\" function, on the other hand, can be called from the server and will run on the owning client's version of that Actor."
    },
    {
        "link": "https://forums.unrealengine.com/t/knowledge-base-garbage-collector-internals/501800",
        "document": "I’m not aware of any such plans. (EDIT: We’re working on it! )\n\n If the marking phases are having an impact on your game’s performance it might be a symptom of your game having too many UObjects alive. Usually bigger games don’t need more than a couple hundred thousand UObjects alive at any time.\n\nIf you’re spawning lots of UObjects with short lifetimes you can look into either re-using them, using FStructs instead of UObjects where you can, or putting them into a GC cluster to reduce garbage collection overhead.\n\nFor long-lived UObjects, there’s the option of loading in less / HLODding more."
    },
    {
        "link": "https://reddit.com/r/unrealengine/comments/96h25y/unreal_engine_garbage_collection_and_pointers",
        "document": "I am wondering how pointers behave in UE4, so I have a few questions:\n• Do pointers get deleted when it goes out of scope?\n• What c++ smart pointer is the most similar to standard pointers in UE4?\n• Does UE4 have any other type of smart pointers?\n• If 4 is true, what is the c++ equivilant?\n\nI hope someone can answer these questions,"
    },
    {
        "link": "https://unrealcommunity.wiki/memory-management-6rlf3v4i",
        "document": "Garbage collection (GC) tracks (s) and its sub-classes, which include AActor and UActorComponent. When creating a new , Unreal will automatically add them to its internal objects list, so even with improper use, it's not easy to have memory leaks, but it is easy to cause crashes.\n\nUObjects should never be created with , but only with the default creation methods ( , , )\n\nObjects are primarily kept alive in 3 ways:\n• By having a strong reference (UPROPERTY) to them (from objects that are also referenced)\n• By calling (from objects that are also referenced)\n• By adding them to the root set with (typically unnecessary)\n\nWhen objects do not fulfill any of the above conditions, on the next GC cycle they will be marked as unreachable and garbage collected (destroyed).\n\nPassing an object as an to another object does not automatically mean the other object will be kept alive, the same goes for default subobjects.\n\nTo force the destruction of objects that are still reachable, you can call or on them, and it will force their destruction on the next GC cycle (you generally want to avoid doing this, as that is what garbage collection is for, and some classes, like and do not directly support it).\n\nThe destruction of an object doesn't necessarily all happen in the same frame, when garbage collection starts on it, it will first call (do not call this yourself), then, when ready .\n\nThe GC runs in the game thread so you can trust that it won't clean up an object within the lifetime of a function.\n\nWhile the most common way of keeping objects alive is through a , actors and components work differently:\n\nLevels reference their actors and actors reference their components. Both work by overriding the implementation and collecting what they do not want to be garbage collected. This means that even if there are no strong references to level actors and components, they won't be garbage collected until manually destroyed, or their level is unloaded.\n\nThe garbage collector will automatically clear the following references to garbage collected objects1:\n• Raw pointers declared with - will be set to nullptr\n• Raw pointers in compatible containers declared with (such as , or ) - the affected elements will be set as nullptr but not removed\n\nWhenever code references an or a , it has to deal with the possibility that could be called on the actor or could be called on the component. These functions will mark them for pending kill, thus triggering their garbage collection at the first opportunity (note that destroying an actor also destroys all its components). Since the garbage collector automatically nulls out pointers when it actually gets to destroy them, null-checking an actor or component pointer is sufficient to know it's safe to use, though you might also want to check on them (through ) to avoid accessing them after they have been marked for destruction ( already checks for this when retrieving the raw pointer).\n\nis a global function that automatically checks if an object pointer is non-null and not pending kill.\n\nShould not be used for Garbage Collection checks, as on pointers it will always return true, while on raw pointer it will return true or false depending on whether the object had already been destroyed, but in the latter case it's also likely to also crash the application as the pointed memory could have been overwritten.\n\nIf you write your own non-garbage classes that references garbage collected objects, you may want to sub-class FGCObject.\n\nThe Unreal Smart Pointer Library ( , , ) is for code that is not based on the UObject system. It is similar in function to the C++11 standard library smart pointers. Unreal Smart Pointers cannot be used to reference UObjects, because the garbage collector isn't aware of smart pointers2.\n• Objects - Explanations of the basic gameplay elements, Actors and Objects\n• Unreal Object Handling - Overview of the features of the UObject system"
    },
    {
        "link": "https://dev.epicgames.com/documentation/en-us/unreal-engine/API",
        "document": "The API reference is an early work in progress, and some information may be missing or out of date. It serves mainly as a low level index of Engine classes and functions. For tutorials, walkthroughs and detailed guides to programming with Unreal, please see the Unreal Engine Programming home on the web.\n\nTo explore the API from some of the most frequently encountered Unreal concepts and types, see the API Quick Start page."
    },
    {
        "link": "https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Engine/Engine/UEngine/ShouldForceGarbageCollection",
        "document": "Allows derived classes to force garbage collection based on various factors (low on available UObject slots / other resources)"
    },
    {
        "link": "https://forums.unrealengine.com/t/c-widgets-and-force-garbage-collector/442532",
        "document": "After over a year in maintenance mode, the official Unreal Engine Wiki is now permanently offline. These resources now live on a new community-run Unreal Engine Community Wiki — ue4community.wiki! You will be able to find content from the official..."
    },
    {
        "link": "https://forums.unrealengine.com/t/force-garbage-collection-immediately/118365",
        "document": "Just wanted to add a little bit here, i just noticed today they have actually added a client function in the player controller.\n\nSo we can use that as well"
    },
    {
        "link": "https://forums.unrealengine.com/t/solved-getworld-from-static-function-without-pass-an-object/245939",
        "document": "Hi! I am slowly moving from Blueprint to C++ and I have a question:\n\nI have a blueprint function library with a function were I give a couple float values and it returns another float result doing math with ‘time since creation’ of ‘playercontroller’\n\nI am trying to do the same from a C++ function library but the only way I found of get world context is passing any object to the function so i can get world context of that object.\n\nI want to do exactly the same I achieve with blueprints that means not passing any object to get the world contexts. I tried to use ‘this’ as reference but the engine dont allow because is a static function. Any help?\n\nhere is what i have working so far…i send a ‘Me’ object but i want to avoid sending any object."
    }
]